[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\nint counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< LL >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        LL tmp = solve(bam[l-1], r, false, min(mn, p[bam[l-1]]), max(mx, p[bam[l-1]]));\n        tmp += (side ? durotto(bam[l-1], r) : durotto(bam[l-1], l));\n        options.push_back(tmp);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        LL tmp = solve(l, dan[r+1], true, min(mn, p[dan[r+1]]), max(mx, p[dan[r+1]]));\n        tmp += (side ? durotto(r, dan[r+1]) : durotto(l, dan[r+1]));\n        options.push_back(tmp);\n    }\n    LL ans = l-r;\n    if (options.size() >= 1) {\n        ans = options.front();\n        if (options.size() >= 2) {\n            ans = min(ans, options[1]);\n        }\n    }\n    counter++;\n    return dp[side][l][r] = ans;\n}\n\nLL ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n    }\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=200005;\nconst long long INF=1e18;\nint n;\nint x[N],y[N];\nint pre[N],nxt[N];\nstruct Node\n{\n\tint x,y,id;\n}pos[N];\nvector<int>val;\nint id[N];\nint dis(int a,int b)\n{\n\treturn abs(x[a]-x[b])+abs(y[a]-y[b]);\n}\nmap<int,long long>dp[2][N];\nlong long solve(int l,int r,int side,int Min,int Max)\n{\n\tif(dp[side][l][r]) return dp[side][l][r];\n\tlong long res=INF;\n\tif(l>1&&(pos[l-1].y==Min-1||pos[l-1].y==Max+1))\n\t{\n\t\tint L=pre[l-1];\n\t\tlong long tmp=solve(L,r,0,min(Min,pos[L].y),max(Max,pos[L].y))+dis(pos[L].id,pos[side?r:l].id);\n\t\tres=min(res,tmp);\n\t}\n\tif(r<n&&(pos[r+1].y==Min-1||pos[r+1].y==Max+1))\n\t{\n\t\tint R=nxt[r+1];\n\t\tlong long tmp=solve(l,R,1,min(Min,pos[R].y),max(Max,pos[R].y))+dis(pos[R].id,pos[side?r:l].id);\n\t\tres=min(res,tmp);\n\t}\n\tif(res==INF) res=l-r;\n\tdp[side][l][r]=res;\n\treturn res;\n}\nlong long ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tval.push_back(y[i]);\n\t\tpos[i].x=x[i],pos[i].y=y[i],pos[i].id=i; \n\t}\n\tsort(pos+1,pos+n+1,[](const Node &a,const Node &b){return a.x<b.x;}); \n\tsort(val.begin(),val.end());\n\tfor(int i=1;i<=n;i++)\n\t\tpos[i].y=lower_bound(val.begin(),val.end(),pos[i].y)-val.begin()+1;\n\tpre[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(abs(pos[i].y-pos[i-1].y)==1) pre[i]=pre[i-1];\n\t\telse pre[i]=i;\n\tnxt[n]=n;\n\tfor(int i=n-1;i>=1;i--)\n\t\tif(abs(pos[i].y-pos[i+1].y)==1) nxt[i]=nxt[i+1];\n\t\telse nxt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tans[pos[i].id]=solve(i,i,0,pos[i].y,pos[i].y);\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\nint counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< LL >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        LL tmp = solve(bam[l-1], r, false, min(mn, p[bam[l-1]]), max(mx, p[bam[l-1]]));\n        tmp += (side ? durotto(bam[l-1], r) : durotto(bam[l-1], l));\n        options.push_back(tmp);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        LL tmp = solve(l, dan[r+1], true, min(mn, p[dan[r+1]]), max(mx, p[dan[r+1]]));\n        tmp += (side ? durotto(r, dan[r+1]) : durotto(l, dan[r+1]));\n        options.push_back(tmp);\n    }\n    LL ans = l-r;\n    if (options.size() >= 1) {\n        ans = options.front();\n        if (options.size() >= 2) {\n            ans = min(ans, options[1]);\n        }\n    }\n    counter++;\n    return dp[side][l][r] = ans;\n}\n\nint ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n    }\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nconst long long inf=1ll<<60;\nint N,MX,MY,id[1000010],Y[1000010],rk_Y[1000010];\nstruct Point{int i,x,y;}P[200010];\nint diff(int x,int y){return x>y?x-y:y-x;}\nint dist(Point*p,Point*q){return diff(p->x,q->x)+diff(p->y,q->y);}\nvoid cmin(int&x,int y){y<x?x=y:1;}\nvoid cmax(int&x,int y){y>x?x=y:1;}\nint pre_len[200010]; \nlong long ans[200010];\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0,x,y;i<N;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tid[x]=i;Y[x]=y;rk_Y[y]++;\n\t\tcmax(MX,x);cmax(MY,y);\n\t}\n\tfor(int i=1;i<=MY;i++)rk_Y[i]+=rk_Y[i-1];\n\tfor(int x=1,n=0;x<=MX;x++)if(Y[x])P[n++]=(Point){id[x],x,Y[x]};\n\tfor(int L=0,R=0;L<N;L=R){\n\t\tint mn=rk_Y[P[L].y],mx=mn;\n\t\tfor(R=L+1;R<N&&diff(rk_Y[P[R].y],rk_Y[P[R-1].y])==1;R++){\n\t\t\tcmin(mn,rk_Y[P[R].y]);\n\t\t\tcmax(mx,rk_Y[P[R].y]);\n\t\t}\n\t\tif(R-L>1){\n\t\t\tint l=L,r=R;\n\t\t\tlong long dis[2][2]={{0,inf},{inf,0}};\n\t\t\tbool fl=1;\n//\t\t\tprintf(\"L=%d R=%d\\n\",L,R);\n\t\t\twhile(fl){\n\t\t\t\tfl=0;\n\t\t\t\tPoint*p[2][2]={{P+l,P+r-1},{P+l,P+r-1}};\n\t\t\t\tint G[2][2]={0},last_mn=mn,last_mx=mx;\n\t\t\t\tbool dir=l&&P[l-1].y<P[l].y;\n\t\t\t\tfor(;l;fl=1){\n\t\t\t\t\tint y=rk_Y[P[l-1].y];\n\t\t\t\t\tif(y==mn-1&&dir)--mn;\n\t\t\t\t\telse if(y==mx+1&&!dir)++mx;\n\t\t\t\t\telse break;\n\t\t\t\t\t--l;\n\t\t\t\t\tG[0][0]+=dist(p[0][0],P+l);G[0][1]+=dist(p[0][0],P+l)*2;\n\t\t\t\t\tG[1][0]+=dist(p[0][1],P+l);G[1][1]+=dist(p[0][1],P+l)*2;\n\t\t\t\t\tp[0][0]=p[0][1]=P+l;\n//\t\t\t\t\tprintf(\"[%d,%d;%d,%d]\\n\",G[0][0],G[0][1],G[1][0],G[1][1]);\n\t\t\t\t}\n\t\t\t\tif(p[0][0]!=p[0][1])G[1][0]+=dist(p[0][0],p[0][1]);\n\t\t\t\tdir=r<N&&P[r].y>P[r-1].y;\n\t\t\t\tmn=last_mn;mx=last_mx;\n\t\t\t\tfor(;r<N;fl=1){\n\t\t\t\t\tint y=rk_Y[P[r].y];\n\t\t\t\t\tif(y==mn-1&&!dir)--mn;\n\t\t\t\t\telse if(y==mx+1&&dir)++mx;\n\t\t\t\t\telse break;\n\t\t\t\t\tG[0][0]+=dist(p[1][0],P+r)*2;G[0][1]+=dist(p[1][0],P+r);\n\t\t\t\t\tG[1][0]+=dist(p[1][1],P+r)*2;G[1][1]+=dist(p[1][1],P+r);\n\t\t\t\t\tp[1][0]=p[1][1]=P+r;r++;\n//\t\t\t\t\tprintf(\"[%d,%d;%d,%d]\\n\",G[0][0],G[0][1],G[1][0],G[1][1]);\n\t\t\t\t}\n\t\t\t\tif(p[1][0]!=p[1][1])G[0][1]+=dist(p[1][0],p[1][1]);\n\t\t\t\tcmin(mn,rk_Y[P[l].y]);\n\t\t\t\tcmax(mx,rk_Y[P[l].y]);\n\t\t\t\tlong long d[2][2]={{inf,inf},{inf,inf}};\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\t\tfor(int k=0;k<2;k++)if(dis[i][j]+G[j][k]<d[i][k])d[i][k]=dis[i][j]+G[j][k];\n//\t\t\t\tprintf(\"l=%d r=%d\\n\",l,r);\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\t\tfor(int j=0;j<2;j++)dis[i][j]=d[i][j];//,printf(\"d(%d,%d)=%lld\\n\",i,j,d[i][j]);\n\t\t\t}\n\t\t\tpre_len[L]=0;\n\t\t\tfor(int i=L;i+1<R;i++)pre_len[i+1]=pre_len[i]+dist(P+i,P+i+1);\n\t\t\tfor(int i=L;i<R;i++){\n\t\t\t\tlong long d[2]={pre_len[R-1]*2-pre_len[i],pre_len[R-1]+pre_len[i]};\n\t\t\t\tans[P[i].i]=inf;\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\tfor(int k=0;k<2;k++)if(d[j]+dis[j][k]<ans[P[i].i])ans[P[i].i]=d[j]+dis[j][k];\n\t\t\t\tans[P[i].i]-=r-l-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)printf(\"%lld\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 09.08.2020 16:54:47       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto old_x = x;\n  auto old_y = y;\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  vector<int> p(n);\n  vector<int> id(n);\n  for (int i = 0; i < n; i++) {\n    int j = (int) (lower_bound(x.begin(), x.end(), old_x[i]) - x.begin());\n    int k = (int) (lower_bound(y.begin(), y.end(), old_y[i]) - y.begin());\n    p[j] = k;\n    id[j] = i;\n  }\n  auto Dist = [&](int i, int j) {\n    return abs(x[i] - x[j]) + abs(y[p[i]] - y[p[j]]);\n  };\n  vector<long long> ans(n);\n  int beg = 0;\n  while (beg < n) {\n    int end = beg;\n    while (end + 1 < n && abs(p[end] - p[end + 1]) == 1) {\n      ++end;\n    }\n    int from = beg;\n    int to = end;\n    int mn = min(p[beg], p[end]);\n    int mx = max(p[beg], p[end]);\n    vector<tuple<int, int, int, int>> segs;\n    segs.emplace_back(from, to, mn, mx);\n    while (true) {\n      if (from > 0 && p[from - 1] == mn - 1 && to < n - 1 && p[to + 1] == mx + 1) {\n        while (from > 0 && p[from - 1] == mn - 1) {\n          --mn;\n          --from;\n        }\n        while (to < n - 1 && p[to + 1] == mx + 1) {\n          ++mx;\n          ++to;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      if (from > 0 && p[from - 1] == mx + 1 && to < n - 1 && p[to + 1] == mn - 1) {\n        while (from > 0 && p[from - 1] == mx + 1) {\n          ++mx;\n          --from;\n        }\n        while (to < n - 1 && p[to + 1] == mn - 1) {\n          --mn;\n          ++to;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      if (from > 0 && p[from - 1] == mn - 1) {\n        while (from > 0 && p[from - 1] == mn - 1) {\n          --mn;\n          --from;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      if (from > 0 && p[from - 1] == mx + 1) {\n        while (from > 0 && p[from - 1] == mx + 1) {\n          ++mx;\n          --from;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      if (to < n - 1 && p[to + 1] == mn - 1) {\n        while (to < n - 1 && p[to + 1] == mn - 1) {\n          --mn;\n          ++to;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      if (to < n - 1 && p[to + 1] == mx + 1) {\n        while (to < n - 1 && p[to + 1] == mx + 1) {\n          ++mx;\n          ++to;\n        }\n        segs.emplace_back(from, to, mn, mx);\n        continue;\n      }\n      break;\n    }\n    int rooks = to - from + 1;\n    reverse(segs.begin(), segs.end());\n    long long L = 0;\n    long long R = 0;\n    for (int i = 1; i < (int) segs.size(); i++) {\n      int from = get<0>(segs[i]);\n      int to = get<1>(segs[i]);\n      int mn = get<2>(segs[i]);\n      int mx = get<3>(segs[i]);\n      int big_from = get<0>(segs[i - 1]);\n      int big_to = get<1>(segs[i - 1]);\n      int big_mn = get<2>(segs[i - 1]);\n      int big_mx = get<3>(segs[i - 1]);\n      if (from == big_from) {\n        long long newL = Dist(from, big_to) + R;\n        long long newR = Dist(to, big_to) + R;\n        L = newL;\n        R = newR;\n        continue;\n      }\n      if (to == big_to) {\n        long long newL = Dist(big_from, from) + L;\n        long long newR = Dist(big_from, to) + L;\n        L = newL;\n        R = newR;\n        continue;\n      }\n      long long newL = min(Dist(from, big_to) + Dist(big_to, big_from) + L,\n                           Dist(from, big_from) + Dist(big_from, big_to) + R);\n      long long newR = min(Dist(  to, big_to) + Dist(big_to, big_from) + L,\n                           Dist(  to, big_from) + Dist(big_from, big_to) + R);\n      L = newL;\n      R = newR;\n    }\n    for (int i = beg; i <= end; i++) {\n      ans[id[i]] = min(Dist(i, beg) + Dist(beg, end) + R, Dist(i, end) + Dist(end, beg) + L) - (rooks - 1);\n    }\n    beg = end + 1;\n  }\n  for (int i = 0; i < n; i++) {\n    cout << ans[i] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n    return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n    return a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n    hi ++; assert(lo <= hi); // assuming f is increasing\n    while (lo < hi) { // find first index such that f is true \n        T mid = half(lo+hi);\n        f(mid) ? hi = mid : lo = mid+1; \n    } \n    return lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n    lo --; assert(lo <= hi); // assuming f is decreasing\n    while (lo < hi) { // find first index such that f is true \n        T mid = half(lo+hi+1);\n        f(mid) ? lo = mid : hi = mid-1;\n    } \n    return lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n    sort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n    #ifdef LOCAL\n        return b ? \"true\" : \"false\"; \n    #else \n        return ts((int)b);\n    #endif\n}\ntemplate<class A> str ts(complex<A> c) { \n    stringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n    str res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n    res += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n    str res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n    return res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n    #ifdef LOCAL\n        bool fst = 1; str res = \"{\";\n        for (const auto& x: v) {\n            if (!fst) res += \", \";\n            fst = 0; res += ts(x);\n        }\n        res += \"}\"; return res;\n    #else\n        bool fst = 1; str res = \"\";\n        for (const auto& x: v) {\n            if (!fst) res += \" \";\n            fst = 0; res += ts(x);\n        }\n        return res;\n\n    #endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n    #ifdef LOCAL\n        return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n    #else\n        return ts(p.f)+\" \"+ts(p.s);\n    #endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n    pr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n    pr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n    cerr << ts(h); if (sizeof...(t)) cerr << \", \";\n    DBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n    #define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n    #define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n         << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n    #define dbg(...) 0\n    #define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n    unsyncIO();\n    // cin.exceptions(cin.failbit); \n    // throws exception when do smth illegal\n    // ex. try to read letter into int\n    if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst int mx = 200005;\n\nint N;\npl P[mx];\nmap<int, int> m;  //compress y \nmap<int, int> toind; // original index of x coor\nll ans[mx];\n\nll getDist(int i, int j){\n    return abs(P[j].f-P[i].f)+abs(P[j].s-P[i].s);\n}\n\npl search(int l, int r, int L, int R){\n    dbg(l, r, L, R);\n    int dir = 0;\n    if(l-1 >= 1){\n        if(m[P[l-1].s] == L-1) dir = 1;\n        else if(m[P[l-1].s] == R+1) dir = 2;\n    }\n    if(r+1 <= N){\n        if(m[P[r+1].s] == R+1) dir = 1;\n        else if(m[P[r+1].s] == L-1) dir = 2;\n    }\n    dbg(dir);\n    if(dir == 0) return mp(-(r-l), -(r-l));\n\n    int lind = l;\n    int rind = r;\n\n    for(int i = l-1; i >= 1; i--){\n        if(dir == 1 && m[P[i].s] == i-l+L){\n            lind = i;\n        }\n        else if(dir == 2 && m[P[i].s] == R-i+l){\n            lind = i;\n        }\n        else break;\n    }\n\n    for(int i = r+1; i <= N; i++){\n        if(dir == 1 && m[P[i].s] == i-r+R){\n            rind = i;\n        }\n        else if(dir == 2 && m[P[i].s] == L-i+r){\n            rind = i;\n        }\n        else break;\n    }\n\n    int nL, nR;\n    if(dir == 1){\n        nL = min(L, m[P[lind].s]);\n        nR = max(R, m[P[rind].s]);\n    }\n    else{\n        nL = min(L, m[P[rind].s]);\n        nR = max(R, m[P[lind].s]);\n    }\n\n    pl val = search(lind, rind, nL, nR);\n    pl res = mp(INF, INF);\n    if(lind == l){\n        ckmin(res.f, val.s+getDist(l, rind));\n        ckmin(res.s, val.s+getDist(r, rind));\n    }\n    if(rind == r){\n        ckmin(res.f, val.f+getDist(l, lind));\n        ckmin(res.s, val.f+getDist(r, lind));\n    }\n    ckmin(res.f, val.f+getDist(l, rind)+getDist(rind, lind));\n    ckmin(res.f, val.s+getDist(l, lind)+getDist(lind, rind));\n    ckmin(res.s, val.f+getDist(r, rind)+getDist(rind, lind));\n    ckmin(res.s, val.s+getDist(r, lind)+getDist(lind, rind));\n    \n    dbg(res);\n    return res;\n}\n\nint main() {\n    setIO();\n    cin >> N;\n    vpi v;\n    for(int i = 1; i <= N; i++){\n        cin >> P[i].f >> P[i].s;\n        m[P[i].s];\n        toind[P[i].f] = i;\n    }\n    int cnt = 0;\n    for(auto &u: m){\n        u.s = ++cnt;\n    }\n    sort(P+1, P+1+N);\n    for(int i = 1; i <= N; i++){\n        if(i-1 >= 1 && m[P[i-1].s] == m[P[i].s]-1) continue;\n        if(i-1 >= 1 && m[P[i-1].s] == m[P[i].s]+1) continue;\n        if(i+1 > N){\n            ans[toind[P[i].f]] = 0;\n            continue;\n        }\n        //edit i after finding a range\n        if(m[P[i+1].s] == m[P[i].s]+1){\n            int maxi = i+1;\n            for(int j = i+1; j <= N; j++){\n                if(m[P[j].s] == m[P[i].s]+j-i){\n                    maxi = j;\n                }\n                else break;\n            }\n            pl x = search(i, maxi, m[P[i].s], m[P[i].s]+maxi-i);\n            for(int j = i; j <= maxi; j++){\n                ans[toind[P[j].f]] = min(x.f+getDist(j, maxi)+getDist(i, maxi), x.s+getDist(j, i)+getDist(i, maxi));\n            }\n            dbg(i, maxi);\n            i = maxi;\n        }\n        else if(m[P[i+1].s] == m[P[i].s]-1){\n            int maxi = i+1;\n            for(int j = i+1; j <= N; j++){\n                if(m[P[j].s] == m[P[i].s]-j+i){\n                    maxi = j;\n                }\n                else break;\n            }\n            pl x = search(i, maxi, m[P[i].s]-maxi+i, m[P[i].s]);\n            for(int j = i; j <= maxi; j++){\n                ans[toind[P[j].f]] = min(x.f+getDist(j, maxi)+getDist(i, maxi), x.s+getDist(j, i)+getDist(i, maxi));\n            }\n            dbg(i, maxi);\n            i = maxi;\n        }\n        else{\n            ans[toind[P[i].f]] = 0;\n        }\n        \n    }\n\n    for(int i = 1; i <= N; i++){\n        ps(ans[i]);\n    }\n\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?)\n    * do smth instead of nothing and stay organized\n    * WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; --i)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\n//using P = pair<int,int>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\n\nstruct P {\n    int i;\n    int x;\n    int y;\n    int yrank;};\n\nll dist(P a, P b) {return abs(a.x - b.x) + abs(a.y - b.y);}\n\nvector<int> ld, lu, rd, ru;\nint n;\nvector<P> p;\nmap<tuple<int, int, int>, ll> memo1, memo2;\nll f2(int i, int L, int R, int yl, int yu);\n\nll f1(int i, int L, int R, int yl, int yu) {\n    if (memo1.count({i, L, R}) > 0) return memo1[{i, L, R}];\n    // [L, R] * [yl, yu] is available\n    bool ok_l = L-1 >= 0 && p[L-1].yrank == yl - 1, \n         ok_r = R+1 < n && p[R+1].yrank == yu + 1;\n    ll ret;\n    if (!ok_l && !ok_r) {\n        ret = f2(i, L, R, yl, yu);\n    } else if (!ok_r) {\n        int nl = ld[L-1];\n        ret = dist(p[i], p[nl]) - (L - nl) + f2(nl, nl, R, p[nl].yrank, yu);\n    } else if (!ok_l) {\n        int nr = ru[R+1];\n        ret = dist(p[i], p[nr]) - (nr - R) + f2(nr, L, nr, yl, p[nr].yrank);\n    } else {\n        int nl = ld[L-1];\n        int nr = ru[R+1];\n        ret = min(dist(p[i], p[nr]) + dist(p[nr], p[nl]) - (L - nl + nr - R) + f2(nl, nl, nr, p[nl].yrank, p[nr].yrank),\n                  dist(p[i], p[nl]) + dist(p[nl], p[nr]) - (L - nl + nr - R) + f2(nr, nl, nr, p[nl].yrank, p[nr].yrank));\n    }\n    return memo1[{i, L, R}] = ret;\n}\n\nll f2(int i, int L, int R, int yl, int yu) {\n    if (memo2.count({i, L, R}) > 0) return memo2[{i, L, R}];\n    // [L, R] * [yl, yu] is available\n    bool ok_l = L-1 >= 0 && p[L-1].yrank == yu + 1, \n         ok_r = R+1 < n && p[R+1].yrank == yl - 1;\n    ll ret;\n    if (!ok_l && !ok_r) {\n        ret = 0;\n    } else if (!ok_r) {\n        int nl = lu[L-1];\n        ret = dist(p[i], p[nl]) - (L - nl) + f1(nl, nl, R, yl, p[nl].yrank);\n    } else if (!ok_l) {\n        int nr = rd[R+1];\n        ret = dist(p[i], p[nr]) - (nr - R) + f1(nr, L, nr, p[nr].yrank, yu);\n    } else {\n        int nl = lu[L-1];\n        int nr = rd[R+1];\n        ret = min(dist(p[i], p[nr]) + dist(p[nr], p[nl]) - (L - nl + nr - R) + f1(nl, nl, nr, p[nr].yrank, p[nl].yrank),\n                  dist(p[i], p[nl]) + dist(p[nl], p[nr]) - (L - nl + nr - R) + f1(nr, nl, nr, p[nr].yrank, p[nl].yrank));\n    }\n    return memo2[{i, L, R}] = ret;\n}\n\n\nint main() {\n    cin >> n;\n    p = vector<P>(n);\n    ld = vector<int>(n); \n    lu = vector<int>(n); \n    rd = vector<int>(n); \n    ru = vector<int>(n); \n    rep(i, n) {\n        cin >> p[i].x >> p[i].y;\n        p[i].i = i;\n    }\n    sort(all(p), [](P a, P b) {return a.y < b.y;});\n    rep(i, n) p[i].yrank = i;\n    sort(all(p), [](P a, P b) {return a.x < b.x;});\n    {\n        int pre = -2, cur = -1;\n        rep(i, n) {\n            if (pre + 1 != p[i].yrank) cur = i;\n            ld[i] = cur;\n            pre = p[i].yrank;\n        }\n    }\n    {\n        int pre = -2, cur = -1;\n        rep(i, n) {\n            if (pre - 1 != p[i].yrank) cur = i;\n            lu[i] = cur;\n            pre = p[i].yrank;\n        }\n    }\n    {\n        int pre = -2, cur = -1;\n        rrep(i, n) {\n            if (pre + 1 != p[i].yrank) cur = i;\n            rd[i] = cur;\n            pre = p[i].yrank;\n        }\n    }\n    {\n        int pre = -2, cur = -1;\n        rrep(i, n) {\n            if (pre - 1 != p[i].yrank) cur = i;\n            ru[i] = cur;\n            pre = p[i].yrank;\n        }\n    }\n\n    vector<ll> ans(n);\n    rep(i, n) {\n        ll a = f1(i, i, i, p[i].yrank, p[i].yrank);\n        ans[p[i].i] = a;\n    }\n    rep(i, n) cout << ans[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n\tint pl,pr,vl,vr,type;\n\tvector<int> sons;\n} a[404040];\n\nstruct Point {\n\tint x,y,tag;\n}point[202020];\n\nint ans[202020],dp[404040][2],n,tot,x[202020],y[202020],p[202020],rkx[202020],rky[202020];\n\ninline int dist(int a, int b) {\n\treturn abs(x[p[a]]-x[p[b]])+abs(y[p[a]]-y[p[b]]);\n}\n\nint l[202020],r[202020];\n\nvoid work(int pos) {\n\t//cout << pos << endl;\n\tif (pos <= n) {\n\t\tans[p[pos]] = dp[pos][0];\n\t\treturn;\n\t}\n\tvector <int> &s = a[pos].sons;\n\tfor (int i = 0, last = a[pos].pl;i < s.size(); i++) {\n\t\tl[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pr + 1;\n\t}\n\tfor (int i = s.size() - 1, last = a[pos].pr; i >= 0; i--) {\n\t\tr[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pl - 1;\n\t}\n\tfor (int i = 0;i < s.size(); i++) {\n\t\tint dest = s[i], pl = l[i], pr = r[i];\n\t\t\n\t\tif (pl == a[dest].pl && pr == a[dest].pr) \n\t\t\tdp[dest][0] = dp[dest][1] = 0;\n\t\t\n\t\telse if (pl == a[dest].pl) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr) + dp[pos][1];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr) + dp[pos][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr);\n\t\t\t}\n\t\t} else if (pr == a[dest].pr) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl) + dp[pos][0];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl) + dp[pos][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = min(dp[pos][0] + dist(a[dest].pl, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dp[pos][0] + dist(a[dest].pr, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = min(dist(a[dest].pl, pr) + dist(pl, pr), dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dist(a[dest].pr, pr) + dist(pl, pr), dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t}\n\t\t}\n\t\tdp[dest][0] -= a[dest].pl - pl + pr - a[dest].pr;\n\t\tdp[dest][1] -= a[dest].pl - pl + pr - a[dest].pr;\n\t}\n\tfor (int i = 0;i < s.size(); i++)\n\t\twork(s[i]);\n}\ninline bool chk(Node &A,Node &B) {\n\treturn max(A.vr,B.vr)-min(A.vl,B.vl) == max(A.pr,B.pr)-min(A.pl,B.pl);\n}\ninline int join(int x, int y) {\n\tif (a[x].vl < a[y].vl) {\n\t\ta[++tot].type = 1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[x].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[y].vr;\n\t} \n\telse {\t\t\n\t\ta[++tot].type = -1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[y].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[x].vr;\n\t}\n\ta[tot].sons.push_back(x);\n\ta[tot].sons.push_back(y);\n\treturn tot;\n}\nint s[202020];\ninline void buildTree() {\n\tfor (int i = 1;i <= n; i++) {\n\t\ta[++tot].type = 0;\n\t\ta[tot].pl = a[tot].pr = i;\n\t\ta[tot].vl = a[tot].vr = rky[p[i]];\n\t}\n\tint top = 0;\n\tfor (int i = 1;i <= n; i++) {\n\t\tbool fl = 1;\n\t\ts[++top] = i;\n\t\twhile (fl) {\n\t\t\tfl = 0;\n\t\t\tif (top >= 2 && a[s[top - 1]].type == 1 && a[s[top - 1]].vr + 1 == a[s[top]].vl) {\n\t\t\t\ta[s[top - 1]].vr = a[s[top]].vr;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && a[s[top - 1]].type == -1 && a[s[top - 1]].vl - 1 == a[s[top]].vr) {\n\t\t\t\ta[s[top - 1]].vl = a[s[top]].vl;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && chk(a[s[top]],a[s[top-1]])) {\n\t\t\t\tint x,y;\n\t\t\t\ty = s[top--];\n\t\t\t\tx = s[top--];\n\t\t\t\ts[++top] = join(x, y);\n\t\t\t\tfl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= top; i++)\n\t\twork(s[i]);\n}\nbool cmpx(Point A,Point B) {\n\treturn A.x < B.x;\n}\nbool cmpy(Point A,Point B) {\n\treturn A.y < B.y;\n}\nint main() {\n\tscanf(\"%d\",&n); \n\tfor (int i = 1;i <= n; i++) {\n\t\tscanf(\"%d%d\",&point[i].x,&point[i].y),point[i].tag = i;\n\t\tx[i] = point[i].x;\n\t\ty[i] = point[i].y;\n\t}\n\tsort(point+1,point+n+1,cmpx);\n\tfor (int i = 1;i <= n; i++)\n\t\trkx[point[i].tag] = i;\n\t\t\n\tsort(point+1,point+n+1,cmpy);\n\tfor (int i = 1;i <= n; i++)\n\t\trky[point[i].tag] = i;\n\t\t\n\tfor (int i = 1;i <= n; i++)\n\t\tp[rkx[i]] = i;\n\t\t\n\tbuildTree();\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\n//int counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< int >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        options.push_back(0);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        options.push_back(1);\n    }\n\n    LL ans = 0;\n    if (options.size() == 0) {\n        ans = l-r;\n    } else if (options.size() == 1) {\n        if (options[0] == 0) {\n            int _l = bam[l-1];\n            ans = solve(_l, r, false, min(mn, p[_l]), max(mx, p[_l]));\n            ans += (side ? durotto(r, _l) : durotto(l, _l));\n        } else {\n            int _r = dan[r+1];\n            ans = solve(l, _r, true, min(mn, p[_r]), max(mx, p[_r]));\n            ans += (side ? durotto(r, _r) : durotto(l, _r));\n        }\n    } else if (options.size() == 2) {\n        ans = 1e15;\n        int _l = bam[l-1];\n        int _r = dan[r+1];\n        int _mn = min(mn, min(p[_l], p[_r]));\n        int _mx = max(mx, max(p[_l], p[_r]));\n        {\n            LL tmp = solve(_l, _r, true, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _l)*2+durotto(r, _r);\n            } else {\n                tmp += durotto(l, _l)*2+durotto(l, _r);\n            }\n            ans = min(ans, tmp);\n        }\n        {\n            LL tmp = solve(_l, _r, false, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _r)*2+durotto(r, _l);\n            } else {\n                tmp += durotto(l, _r)*2+durotto(l, _l);\n            }\n            ans = min(ans, tmp);\n        }\n    }\n\n//    counter++;\n//    cout << options.size() << \" options\" << endl;\n//    cout << \"dp[\" << side << \"][\" << l << \"][\" << r << \"] = \" << ans << endl;\n    return dp[side][l][r] = ans;\n}\n\nLL ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n//        cout << \"q[\" << idY[i] << \"] = \" << i+1 << endl;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n//        cout << p[i] << \" \";\n    }\n//    cout << endl;\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100086\n\nusing namespace std;\n\nint main(){\n\tint N; cin >> N;\n\tvector<long long> Xs(N);\n\tvector<long long> Ys(N);\n\tvector<array<long long, 2>> rooks(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tXs[i] = x, Ys[i] = y;\n\t\trooks[i] = {x, y};\n\t}\n\tsort(Xs.begin(), Xs.end());\n\tsort(Ys.begin(), Ys.end());\n\tvector<int> P(N);\n\tvector<int> invP(N);\n\tvector<int> rookID(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = int(lower_bound(Xs.begin(), Xs.end(), rooks[i][0]) - Xs.begin());\n\t\tint y = int(lower_bound(Ys.begin(), Ys.end(), rooks[i][1]) - Ys.begin());\n\t\trookID[x] = i;\n\t\tP[x] = y;\n\t\tinvP[y] = x;\n\t}\n\n\tvector<long long> ans(N);\n\n\tvector<array<int, 2>> runs; runs.reserve(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint j = i;\n\t\twhile (j+1 < N && abs(P[j] - P[j+1]) == 1) {\n\t\t\tj++;\n\t\t}\n\t\truns.push_back({i,j});\n\t\ti = j;\n\t}\n\n\tint R = int(runs.size());\n\tfor (int st = 0; st < R; st++) {\n\t\tint a = st, b = st;\n\t\tint x0 = runs[st][0], y0 = P[x0];\n\t\tint x1 = runs[st][1], y1 = P[x1];\n\t\tlong long cost[2][2];\n\t\tcost[0][0] = cost[1][1] = 2 * (abs(Xs[x0] - Xs[x1]) + abs(Ys[y0] - Ys[y1]));\n\t\tcost[0][1] = cost[1][0] = abs(Xs[x0] - Xs[x1]) + abs(Ys[y0] - Ys[y1]);\n\t\twhile (true) {\n\t\t\tassert(x0 <= x1 && abs(x0 - x1) == abs(y0 - y1));\n\t\t\tbool can_left = x0-1 >= 0 && abs(P[x0-1] - y1) == 1;\n\t\t\tbool can_right = x1+1 < N && abs(P[x1+1] - y0) == 1;\n\t\t\tif (!(can_left || can_right)) break;\n\t\t\tif (can_left) a--;\n\t\t\tif (can_right) b++;\n\t\t\tint nx0, ny0, nx1, ny1;\n\t\t\tif (can_left) {\n\t\t\t\tnx0 = runs[a][0];\n\t\t\t\tny0 = P[nx0];\n\t\t\t} else {\n\t\t\t\tnx0 = x0;\n\t\t\t\tny0 = y1;\n\t\t\t}\n\t\t\tif (can_right) {\n\t\t\t\tnx1 = runs[b][1];\n\t\t\t\tny1 = P[nx1];\n\t\t\t} else {\n\t\t\t\tnx1 = x1;\n\t\t\t\tny1 = y0;\n\t\t\t}\n\n\t\t\tfor (int s = 0; s < 2; s++) {\n\t\t\t\tlong long nc0 = min(\n\t\t\t\t\tcost[s][0] + abs(Xs[x0] - Xs[nx0]) + abs(Ys[y0] - Ys[ny0]),\n\t\t\t\t\tcost[s][1] + abs(Xs[x1] - Xs[nx0]) + abs(Ys[y1] - Ys[ny0])\n\t\t\t\t);\n\t\t\t\tlong long nc1 = min(\n\t\t\t\t\tcost[s][0] + abs(Xs[x0] - Xs[nx1]) + abs(Ys[y0] - Ys[ny1]),\n\t\t\t\t\tcost[s][1] + abs(Xs[x1] - Xs[nx1]) + abs(Ys[y1] - Ys[ny1])\n\t\t\t\t);\n\t\t\t\tlong long nd = abs(Xs[nx0] - Xs[nx1]) + abs(Ys[ny0] - Ys[ny1]);\n\t\t\t\tif (can_left && can_right) {\n\t\t\t\t\tcost[s][0] = nc1 + nd;\n\t\t\t\t\tcost[s][1] = nc0 + nd;\n\t\t\t\t} else if (can_left) {\n\t\t\t\t\tcost[s][0] = nc0;\n\t\t\t\t\tcost[s][1] = nc0 + nd;\n\t\t\t\t} else if (can_right) {\n\t\t\t\t\tcost[s][0] = nc1 + nd;\n\t\t\t\t\tcost[s][1] = nc1;\n\t\t\t\t} else assert(false);\n\t\t\t}\n\n\t\t\tx0 = nx0;\n\t\t\ty0 = ny0;\n\t\t\tx1 = nx1;\n\t\t\ty1 = ny1;\n\t\t}\n\n\t\tint num_rooks = x1 - x0 + 1;\n\t\tfor (int i = runs[st][0]; i <= runs[st][1]; i++) {\n\t\t\tlong long cnds[2];\n\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\tcnds[z] = abs(Xs[i] - Xs[runs[st][z]]) + abs(Ys[P[i]] - Ys[P[runs[st][z]]]) + min(cost[z][0], cost[z][1]);\n\t\t\t}\n\t\t\tans[rookID[i]] = min(cnds[0], cnds[1]) - (num_rooks - 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << ans[i] << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "にゃーん"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200009;\n\nint n;\nstruct Point{\n\tint x,y,id;\n\tbool operator < (const Point &rhs) const{\n\t\treturn x<rhs.x;\n\t}\n}r[maxn];\n\nint sy[maxn];\n\nlong long ans[maxn];\nlong long f[maxn][2];\nvector<pair<int,int>>section;\n\nint dist(int i,int j){\n\treturn abs(r[i].x-r[j].x)+abs(r[i].y-r[j].y);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tr[i].id=i;scanf(\"%d%d\",&r[i].x,&r[i].y);\n\t\tsy[i]=r[i].y;\n\t}\n\tsort(r+1,r+1+n);\n\tsort(sy+1,sy+1+n);sy[0]=0;sy[n+1]=1e9;\n\t\n\tfor(int i=1;i<=n;++i)ans[i]=-1;\n\tfor(int i=1;i<=n;++i){\n\t\tif(ans[r[i].id]!=-1)continue;\n\t\tint t=lower_bound(sy+1,sy+1+n,r[i].y)-sy;\n\t\tint t1=t-1,t2=t+1,L=i,R=i,predir=-1,dir;\n\t\tfor(;;){\n\t\t\tint flag=0; \n\t\t\tfor(int i:{L-1,R+1}){\n\t\t\t\tif(i<=0||i>n)continue;\n\t\t\t\tif(r[i].y!=sy[t1]&&r[i].y!=sy[t2])continue;\n\t\t\t\tif(i==L-1){\n\t\t\t\t\tdir=r[i].y==sy[t1];\n\t\t\t\t}else{\n\t\t\t\t\tdir=r[i].y==sy[t2];\n\t\t\t\t}\n\t\t\t\tif(predir!=-1&&dir!=predir){\n\t\t\t\t\tsection.push_back(pair<int,int>(L,R));\n\t\t\t\t}\n\t\t\t\tpredir=dir;\n\t\t\t\tif(r[i].y==sy[t1])--t1;else ++t2;\n\t\t\t\tif(i==L-1)--L;else ++R;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t\tif(!flag)break;\n\t\t}\n\t\tsection.push_back(pair<int,int>(L,R));\n\t\t\n\t\tint s=section.size();\n\t\tf[s-1][0]=f[s-1][1]=0;\n\t\tfor(int i=s-1;i>=1;--i){\n\t\t\tint l1=section[i].first,r1=section[i].second;\n\t\t\tint l2=section[i-1].first,r2=section[i-1].second;\n\t\t\tf[i-1][0]=min(dist(l2,l1)+dist(l1,r1)+f[i][1],(r1==r2?dist(l1,l2):dist(l2,r1)+dist(r1,l1))+f[i][0]);\n\t\t\tf[i-1][1]=min(dist(r2,r1)+dist(r1,l1)+f[i][0],(l1==l2?dist(r1,r2):dist(r2,l1)+dist(l1,r1))+f[i][1]);\n\t\t}\n\t\tL=section[0].first;R=section[0].second;\n\t\tfor(int i=L;i<=R;++i){\n\t\t\tint id=r[i].id;\n\t\t\tans[id]=min(dist(i,R)+dist(R,L)+f[0][0],dist(i,L)+dist(L,R)+f[0][1])-(section[s-1].second-section[s-1].first);\n\t\t}\n\t\tsection.clear();\n\t}\n\t\n\tfor(int i=1;i<=n;++i)printf(\"%lld\\n\",ans[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "✋(◉ ω ◉｀)よお"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000;\n\nint n,x[N+9],y[N+9];\nint ox[N+9],oy[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n\tox[i]=x[i];oy[i]=y[i];\n  }\n}\n\nint id[N+9],p[N+9];\n\nvoid Get_id(){\n  sort(ox+1,ox+n+1);\n  sort(oy+1,oy+n+1);\n  for (int i=1;i<=n;++i){\n\tx[i]=lower_bound(ox+1,ox+n+1,x[i])-ox;\n\ty[i]=lower_bound(oy+1,oy+n+1,y[i])-oy;\n\tid[x[i]]=i;p[x[i]]=y[i];\n  }\n}\n\nint le[N+9],ri[N+9];\n\nvoid Get_le_ri(){\n  le[1]=1;ri[n]=n;\n  for (int i=2;i<=n;++i) le[i]=abs(p[i]-p[i-1])==1?le[i-1]:i;\n  for (int i=n-1;i>=1;--i) ri[i]=abs(p[i]-p[i+1])==1?ri[i+1]:i;\n}\n\nmap<int,LL>dp[2][N+9];\n\nint Get_dis(int a,int b){\n  a=id[a];b=id[b];\n  return abs(ox[x[a]]-ox[x[b]])+abs(oy[y[a]]-oy[y[b]]);\n}\n\nLL Dfs_dp(int l,int r,int t,int mn,int mx){\n  if (dp[t][l].find(r)!=dp[t][l].end()) return dp[t][l][r];\n  LL res=l-r;\n  int flag=0;\n  if (l>1&&(p[l-1]==mn-1||p[l-1]==mx+1))\n\tres=Dfs_dp(le[l-1],r,0,min(mn,p[le[l-1]]),max(mx,p[ri[l-1]]))+Get_dis(le[l-1],t?r:l),flag=1;\n  if (r<n&&(p[r+1]==mn-1||p[r+1]==mx+1)){\n\tint now=Dfs_dp(l,ri[r+1],1,min(mn,p[ri[r+1]]),max(mx,p[ri[r+1]]))+Get_dis(ri[r+1],t?r:l);\n\tres=flag?min(res,now):now;\n  }\n  return dp[t][l][r]=res;\n}\n\nLL ans[N+9];\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i) ans[id[i]]=Dfs_dp(i,i,0,p[i],p[i]);\n}\n\nvoid work(){\n  Get_id();\n  Get_le_ri();\n  Get_dp();\n}\n\nvoid outo(){\n  for (int i=1;i<=n;++i)\n\tprintf(\"%lld\\n\",ans[i]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\nconst int N=2e5+5;\nconst long long inf=1e18;\npair< pair<int,int> , int > a[N];\nint n,x[N],y[N],l[N],r[N];\nmap<int,long long> f[2][N];\nlong long dis(pair<int,int> i,pair<int,int> j){\n\treturn abs(x[i.fi]-x[j.fi])+abs(y[i.se]-y[j.se]);\n}\nlong long dfs(int mn,int mx,int l,int r,int k){\n\tif(f[k][l].count(r)) return f[k][l][r];\n\tint L=::l[l-1],R=::r[r+1];long long ans=inf;\n\tif(l>1 && (a[l-1].fi.se==mn-1 || a[l-1].fi.se==mx+1))\n\t\tans=min(ans,dfs(min(a[L].fi.se,mn),max(a[L].fi.se,mx),L,r,0)+dis(a[L].fi,k==0?a[l].fi:a[r].fi));\n\tif(r<n && (a[r+1].fi.se==mn-1 || a[r+1].fi.se==mx+1))\n\t\tans=min(ans,dfs(min(a[R].fi.se,mn),max(a[R].fi.se,mx),l,R,1)+dis(a[R].fi,k==0?a[l].fi:a[r].fi));\n\tf[k][l][r]=(ans==inf?l-r:ans);\n\treturn f[k][l][r];\n}\nlong long ans[N];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>x[i]>>y[i],a[i]=make_pair(make_pair(x[i],y[i]),i);\n\tsort(a+1,a+n+1);\n\tsort(x+1,x+n+1);\n\tsort(y+1,y+n+1);\n\tfor(int i=1;i<=n;++i)\n\t\ta[i].fi.fi=lower_bound(x+1,x+n+1,a[i].fi.fi)-x,\n\t\ta[i].fi.se=lower_bound(y+1,y+n+1,a[i].fi.se)-x;\n\tl[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\tif(abs(a[i-1].fi.se-a[i].fi.se)==1) l[i]=l[i-1];\n\t\telse l[i]=i;\n\tr[n]=n;\n\tfor(int i=n-1;i>=1;--i)\n\t\tif(abs(a[i+1].fi.se-a[i].fi.se)==1) r[i]=r[i+1];\n\t\telse r[i]=i;\n\t//for(int i=1;i<=n;++i)cout<<a[i].fi.fi<<\" \"<<a[i].fi.se<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tans[a[i].se]=dfs(a[i].fi.se,a[i].fi.se,i,i,0);\n\tfor(int i=1;i<=n;++i)\n\t\tcout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\nint counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< LL >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        LL tmp = solve(bam[l-1], r, false, min(mn, p[bam[l-1]]), max(mx, p[bam[l-1]]));\n        tmp += (side ? durotto(bam[l-1], r) : durotto(bam[l-1], l));\n        options.push_back(tmp);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        LL tmp = solve(l, dan[r+1], true, min(mn, p[dan[r+1]]), max(mx, p[dan[r+1]]));\n        tmp += (side ? durotto(r, dan[r+1]) : durotto(l, dan[r+1]));\n        options.push_back(tmp);\n    }\n    LL ans = l-r;\n    if (options.size() >= 1) {\n        ans = options.front();\n        if (options.size() >= 2) {\n            ans = min(ans, options[1]);\n        }\n    }\n    counter++;\n    return dp[side][l][r] = ans;\n}\n\nLL ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n    }\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N; cin >> N;\n\tvector<int64_t> Xs(N);\n\tvector<int64_t> Ys(N);\n\tvector<array<int64_t, 2>> rooks(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tXs[i] = x, Ys[i] = y;\n\t\trooks[i] = {x, y};\n\t}\n\tsort(Xs.begin(), Xs.end());\n\tsort(Ys.begin(), Ys.end());\n\tvector<int> P(N);\n\tvector<int> invP(N);\n\tvector<int> rookID(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = int(lower_bound(Xs.begin(), Xs.end(), rooks[i][0]) - Xs.begin());\n\t\tint y = int(lower_bound(Ys.begin(), Ys.end(), rooks[i][1]) - Ys.begin());\n\t\trookID[x] = i;\n\t\tP[x] = y;\n\t\tinvP[y] = x;\n\t}\n\n\tvector<int64_t> ans(N);\n\n\tvector<array<int, 2>> runs; runs.reserve(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint j = i;\n\t\twhile (j+1 < N && abs(P[j] - P[j+1]) == 1) {\n\t\t\tj++;\n\t\t}\n\t\truns.push_back({i,j});\n\t\ti = j;\n\t}\n\n\tint R = int(runs.size());\n\tfor (int st = 0; st < R; st++) {\n\t\tint a = st, b = st;\n\t\tint x0 = runs[st][0], y0 = P[x0];\n\t\tint x1 = runs[st][1], y1 = P[x1];\n\t\tint64_t cost[2][2];\n\t\tcost[0][0] = cost[1][1] = 2 * (abs(Xs[x0] - Xs[x1]) + abs(Ys[y0] - Ys[y1]));\n\t\tcost[0][1] = cost[1][0] = abs(Xs[x0] - Xs[x1]) + abs(Ys[y0] - Ys[y1]);\n\t\twhile (true) {\n\t\t\tassert(x0 <= x1 && abs(x0 - x1) == abs(y0 - y1));\n\t\t\tbool can_left = x0-1 >= 0 && abs(P[x0-1] - y1) == 1;\n\t\t\tbool can_right = x1+1 < N && abs(P[x1+1] - y0) == 1;\n\t\t\tif (!(can_left || can_right)) break;\n\t\t\tif (can_left) a--;\n\t\t\tif (can_right) b++;\n\t\t\tint nx0, ny0, nx1, ny1;\n\t\t\tif (can_left) {\n\t\t\t\tnx0 = runs[a][0];\n\t\t\t\tny0 = P[nx0];\n\t\t\t} else {\n\t\t\t\tnx0 = x0;\n\t\t\t\tny0 = y1;\n\t\t\t}\n\t\t\tif (can_right) {\n\t\t\t\tnx1 = runs[b][1];\n\t\t\t\tny1 = P[nx1];\n\t\t\t} else {\n\t\t\t\tnx1 = x1;\n\t\t\t\tny1 = y0;\n\t\t\t}\n\n\t\t\tfor (int s = 0; s < 2; s++) {\n\t\t\t\tint64_t nc0 = min(\n\t\t\t\t\tcost[s][0] + abs(Xs[x0] - Xs[nx0]) + abs(Ys[y0] - Ys[ny0]),\n\t\t\t\t\tcost[s][1] + abs(Xs[x1] - Xs[nx0]) + abs(Ys[y1] - Ys[ny0])\n\t\t\t\t);\n\t\t\t\tint64_t nc1 = min(\n\t\t\t\t\tcost[s][0] + abs(Xs[x0] - Xs[nx1]) + abs(Ys[y0] - Ys[ny1]),\n\t\t\t\t\tcost[s][1] + abs(Xs[x1] - Xs[nx1]) + abs(Ys[y1] - Ys[ny1])\n\t\t\t\t);\n\t\t\t\tint64_t nd = abs(Xs[nx0] - Xs[nx1]) + abs(Ys[ny0] - Ys[ny1]);\n\t\t\t\tif (can_left && can_right) {\n\t\t\t\t\tcost[s][0] = nc1 + nd;\n\t\t\t\t\tcost[s][1] = nc0 + nd;\n\t\t\t\t} else if (can_left) {\n\t\t\t\t\tcost[s][0] = nc0;\n\t\t\t\t\tcost[s][1] = nc0 + nd;\n\t\t\t\t} else if (can_right) {\n\t\t\t\t\tcost[s][0] = nc1 + nd;\n\t\t\t\t\tcost[s][1] = nc1;\n\t\t\t\t} else assert(false);\n\t\t\t}\n\n\t\t\tx0 = nx0;\n\t\t\ty0 = ny0;\n\t\t\tx1 = nx1;\n\t\t\ty1 = ny1;\n\t\t}\n\n\t\tint num_rooks = x1 - x0 + 1;\n\t\tfor (int i = runs[st][0]; i <= runs[st][1]; i++) {\n\t\t\tint64_t cnds[2];\n\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\tcnds[z] = abs(Xs[i] - Xs[runs[st][z]]) + abs(Ys[P[i]] - Ys[P[runs[st][z]]]) + min(cost[z][0], cost[z][1]);\n\t\t\t}\n\t\t\tans[rookID[i]] = min(cnds[0], cnds[1]) - (num_rooks - 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << ans[i] << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nstruct PermutationTree{\n\n\tstatic const int N = 200007;\n\t#define ll long long\n\t#define ii pair<ll,ll>\n\t#define iii pair<ii,ll>\n\t#define fi first\n\t#define se second\n\n\t#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n\n\n\tstruct node{\n\t\tint s,e,m;\n\t\tll val=0,lazy=0;\n\t\tnode *l,*r;\n\t\t\n\t\tnode (int _s,int _e){\n\t\t\ts=_s,e=_e,m=s+e>>1;\n\t\t\t\n\t\t\tif (s!=e){\n\t\t\t\tl=new node(s,m);\n\t\t\t\tr=new node(m+1,e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid propo(){\n\t\t\tif (lazy){\n\t\t\t\tval+=lazy;\n\t\t\t\tif (s!=e){\n\t\t\t\t\tl->lazy+=lazy;\n\t\t\t\t\tr->lazy+=lazy;\n\t\t\t\t}\n\t\t\t\tlazy=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid update(int i,int j,ll k){\n\t\t\tif (s==i && e==j) lazy+=k;\n\t\t\telse{\n\t\t\t\tif (j<=m) l->update(i,j,k);\n\t\t\t\telse if (m<i) r->update(i,j,k);\n\t\t\t\telse l->update(i,m,k),r->update(m+1,j,k);\n\t\t\t\t\n\t\t\t\tl->propo(),r->propo();\n\t\t\t\tval=min(l->val,r->val);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll query(int i,int j){\n\t\t\tpropo();\n\t\t\t\n\t\t\tif (s==i && e==j) return val;\n\t\t\telse if (j<=m) return l->query(i,j);\n\t\t\telse if (m<i) return r->query(i,j);\n\t\t\telse return min(l->query(i,m),r->query(m+1,j));\n\t\t}\n\t};\n\n\tint n,q;\n\tint arr[N];\n\tii range[N];\n\tii span[N];\n\tvector<int> children[N];\n\tint parent[N];\n\tint typ[N];\n\tint idx; //new index to assign to nodes\n\n\tii get_range(ii i,ii j){\n\t\treturn ii(min(i.fi,j.fi),max(i.se,j.se));\n\t}\n\n\tvoid add_edge(int u,int v){ //u is parent of v\n\t\tparent[v]=u;\n\t\tchildren[u].push_back(v);\n\t}\n\n\tbool adj(int i,int j){\n\t\treturn range[i].se==range[j].fi-1;\n\t}\n\n\tint length(int i){\n\t\treturn range[i].se-range[i].fi+1;\n\t}\n\n\tvoid build(vector<int> v){\n\t\tn = v.size();\n\t\tfor (int i = 0; i < n; ++i) arr[i] = v[i];\n\t\tidx=n;\n\t\tmemset(parent,-1,sizeof(parent));\n\t\t\n\t\tnode *root=new node(0,N);\n\t\tvector<int> mx={-1},mn={-1}; //stacks for max and min\n\t\t\n\t\tvector<int> nodes; //stack of cut and join nodes\n\t\t\n\t\trep(x,0,n){\n\t\t\t//update Q values\n\t\t\twhile (mx.back()!=-1 && arr[mx.back()]<arr[x]){\n\t\t\t\tint temp=mx.back();\n\t\t\t\tmx.pop_back();\n\t\t\t\troot->update(mx.back()+1,temp,arr[x]-arr[temp]);\n\t\t\t}\n\t\t\tmx.push_back(x);\n\t\t\t\n\t\t\twhile (mn.back()!=-1 && arr[mn.back()]>arr[x]){\n\t\t\t\tint temp=mn.back();\n\t\t\t\tmn.pop_back();\n\t\t\t\troot->update(mn.back()+1,temp,arr[temp]-arr[x]);\n\t\t\t}\n\t\t\tmn.push_back(x);\n\t\t\t\n\t\t\t//handle stack updates\n\t\t\trange[x]=ii(arr[x],arr[x]);\n\t\t\tspan[x]=ii(x,x);\n\t\t\tint curr=x;\n\t\t\t\n\t\t\twhile (true){\n\t\t\t\tif (!nodes.empty() && (adj(nodes.back(),curr) || adj(curr,nodes.back()))){\n\t\t\t\t\tif ((adj(nodes.back(),curr) && typ[nodes.back()]==1)||\n\t\t\t\t\t  (adj(curr,nodes.back()) && typ[nodes.back()]==2)){\n\t\t\t\t\t\tadd_edge(nodes.back(),curr);\n\t\t\t\t\t\t\n\t\t\t\t\t\trange[nodes.back()]=get_range(range[nodes.back()],range[curr]);\n\t\t\t\t\t\tspan[nodes.back()]=get_range(span[nodes.back()],span[curr]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurr=nodes.back();\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse{ //make a new join node\n\t\t\t\t\t\ttyp[idx]=(adj(nodes.back(),curr) ? 1:2);\n\t\t\t\t\t\tadd_edge(idx,nodes.back());\n\t\t\t\t\t\tadd_edge(idx,curr);\n\t\t\t\t\t\t\n\t\t\t\t\t\trange[idx]=get_range(range[nodes.back()],range[curr]);\n\t\t\t\t\t\tspan[idx]=get_range(span[nodes.back()],span[curr]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t\tcurr=idx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (x-(length(curr)-1) && root->query(0,x-length(curr))==0){\n\t\t\t\t\tint len=length(curr);\n\t\t\t\t\tii r=range[curr];\n\t\t\t\t\tii s=span[curr];\n\t\t\t\t\t\n\t\t\t\t\tadd_edge(idx,curr);\n\t\t\t\t\t\n\t\t\t\t\tdo{\n\t\t\t\t\t\tlen+=length(nodes.back());\n\t\t\t\t\t\tr=get_range(r,range[nodes.back()]);\n\t\t\t\t\t\ts=get_range(s,span[nodes.back()]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tadd_edge(idx,nodes.back());\n\t\t\t\t\t\t\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t} while (r.se-r.fi+1!=len);\n\t\t\t\t\t\n\t\t\t\t\treverse(all(children[idx]));\n\t\t\t\t\trange[idx]=r;\n\t\t\t\t\tspan[idx]=s;\n\t\t\t\t\tcurr=idx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.push_back(curr);\n\t\t\troot->update(0,x,-1);\n\t\t}\n\t}\n\n\tpair<int, int> get_range(int x) {\n\t\treturn range[x];\n\t}\n\n\tpair<int, int> get_seg(int x) {\n\t\treturn span[x];\n\t}\n\n\tvector<int> get_sons(int x) {\n\t\treturn children[x];\n\t}\n\n\tbool if_cut(int x) {\n\t\tauto var = get_sons(x);\n\n\t\tvector<pair<int, int> > tet;\n\t\tfor (auto x : var) tet.pb(range[x]);\n\n\t\tauto ctet = tet;\n\t\tsort(all(tet));\n\n\t\tif (tet == ctet) return true;\n\t\treverse(all(tet));\n\t\tif (tet == ctet) return true;\n\t\treturn false;\n\n\t}\n\n\tint get_root() {\n\t\tint cur = 0;\n\t\twhile (parent[cur] != -1){\n\t\t\tcur = parent[cur];\n\t\t}\n\t\treturn cur;\n\t}\n\n\tint get_parent(int x) {\n\t\treturn parent[x];\n\t}\n\n};\n\nPermutationTree tree;\n\nvector<pair<int, int> > arr;\nmap<pair<int, int>, int> tet;\n\nvector<ll> ans;\n\nint get_dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.x-b.x) + abs(a.y-b.y);\n}\n\nvoid solve(int root, ll x, ll y) {\n\tauto res = tree.get_seg(root);\n\t//cout << res.x << \" \" << res.y << \" \" << x << \" \" << y << endl;\n\tif (res.x == res.y) {\n\t\tans[tet[arr[res.x]]] = min(x, y);\n\t\treturn;\n\t}\n\n\tauto children = tree.get_sons(root);\n\n\tif (!tree.if_cut(root)) {\n\t\tfor (auto x : children) {\n\t\t\tsolve(x, 0, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tint sz = children.size();\n\n\tvector<int> take_right(sz), take_left(sz);\n\tvector<int> cnt_left(sz), cnt_right(sz);\n\n\tfor (int i = 0; i < sz; ++i) {\n\t\tauto cur = tree.get_seg(children[i]);\n\t\tif (cur.x != cur.y) take_left[i] = 0, cnt_left[i] = 0;\n\t\telse {\n\t\t\ttake_left[i] = 1;\n\t\t\tcnt_left[i] = cur.y  - cur.x+1;\n\t\t\tif (i > 0) {\n\t\t\t\ttake_left[i] += take_left[i-1];\n\t\t\t\tcnt_left[i] += cnt_left[i-1];\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(all(children));\n\n\tfor (int i = 0; i < sz; ++i) {\n\t\tauto cur = tree.get_seg(children[i]);\n\t\tif (cur.x != cur.y) {\n\t\t\ttake_right[i] = 0;\n\t\t\tcnt_right[i] = 0;\n\t\t}\n\t\telse {\n\t\t\ttake_right[i] = 1;\n\t\t\tcnt_right[i] = cur.y  - cur.x+1;\n\t\t\tif (i > 0) {\n\t\t\t\ttake_right[i] += take_right[i-1];\n\t\t\t\tcnt_right[i] += cnt_right[i-1];\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(all(children));\n\treverse(all(take_right));\n\treverse(all(cnt_right));\n\n\t//cout << res.x << \" \" << res.y << \" \" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < children.size(); ++i) {\n\n\t\tint L = tree.get_seg(children[i]).x;\n\t\tint R = tree.get_seg(children[i]).y;\n\n\t\tll a = 1e18, b = 1e18;\n\n\t\tint tl = 0, tr = 0, cl = 0, cr = 0;\n\n\t\tif (i > 0) {\n\t\t\tcl = cnt_left[i-1];\n\t\t\ttl = take_left[i-1];\n\t\t}\n\t\tif (i + 1 < children.size()) {\n\t\t\tcr = cnt_right[i+1];\n\t\t\ttr = take_right[i+1];\n\t\t}\n\n\t\tll left_sign = 0, right_sign = 0;\n\t\tif (cr+cl+1 == children.size()) left_sign = x, right_sign = y;\n\n\t\tint e = L-tl, f = R+tr;\n\t\tif (cl==0) e = R;\n\t\tif (cr==0) f = L;\n\n\t\ta = min({a, right_sign + get_dist(arr[L], arr[L - tl]) + get_dist(arr[L-tl], arr[R+tr]) - tl - tr, left_sign + get_dist(arr[L], arr[f]) + get_dist(arr[L-tl], arr[f]) - tl - tr});\n\t\tb = min({b, right_sign + get_dist(arr[R], arr[e]) + get_dist(arr[e], arr[R+tr]) - tl - tr, left_sign + get_dist(arr[R], arr[R+tr]) + get_dist(arr[L-tl], arr[R+tr]) - tl - tr});\n\n\t\t//cout << a << \" \" << b << \" \" << L << \" \" << R << \" \" << tl << \" \" << tr << endl;\n\n\t\tsolve(children[i], a, b);\n\n\t}\n\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"K_input.txt\", \"r\", stdin);\n\t//freopen(\"K_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tans.assign(n, -1);\n\n\tvector<int> ys;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tys.pb(y);\n\t\tarr.pb(mp(x, y));\n\t\ttet[mp(x, y)] = i;\n\t}\n\n\tsort(all(arr));\n\tsort(all(ys));\n\n\tmap<int, int> tet;\n\tfor (int i = 0; i < ys.size(); ++i) tet[ys[i]] = i;\n\n\tvector<int> v(n);\n\n\tfor (int i =0; i < n; ++i) {\n\t\tv[i] = tet[arr[i].y];\n\t\t//cout << v[i] << \" \";\n\t}\n\n\ttree.build(v);\n\tint root = tree.get_root();\n\n\tsolve(root, 0, 0);\n\n\tfor (auto x : ans) {\n\t\tcout << x << '\\n';\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fan Club !!\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 1000000007;//998244353\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nint n, x[200005], y[200005], p[200005], rev[200005];\nll ans[200005];\nvector<int>zax, zay;\n//0...-1 1...+1\nint L[2][200005], R[2][200005];\nmap<P, pair<ll, ll>>cache;\nll get_dist(int a, int b){\n\treturn abs(zax[a]-zax[b]) + abs(zay[p[a]]-zay[p[b]]);\n}\nint Mi;\n//first...(lb, p[lb]) second...(ub,p[ub])\npair<ll, ll>solve(int lb, int ub, int mn, int mx){\n\tif(cache.find(mp(lb, ub)) != cache.end()) return cache[mp(lb, ub)];\n\tif( (lb > 0 && p[lb-1] == mn-1) || (ub < n-1 && p[ub+1] == mx+1) ){\n\t\t// bottom left - upper right\n\t\tint Lz = (lb > 0 && p[lb-1] == mn-1) ? L[0][lb-1] : lb;\n\t\tint Rz = (ub < n-1 && p[ub+1] == mx+1) ? R[1][ub+1] : ub;\n\t\tauto ret = solve(Lz, Rz, min(mn, p[Lz]), max(mx, p[Rz]));\n\t\tll all = get_dist(Lz, Rz);\n\t\tll F = min(ub!=Rz?get_dist(lb,Rz)+all+ret.fi:get_dist(lb, Lz)+ret.fi, lb!=Lz?get_dist(lb,Lz)+all+ret.sc:get_dist(lb, Rz)+ret.sc);\n\t\tll S = min(lb!=Lz?get_dist(ub,Lz)+all+ret.sc:get_dist(ub, Rz)+ret.sc, ub!=Rz?get_dist(ub,Rz)+all+ret.fi:get_dist(ub, Lz)+ret.fi);\n\t\treturn cache[mp(lb, ub)] = mp(F, S);\n\t}\n\telse if( (lb > 0 && p[lb-1] == mx+1) || (ub < n-1 && p[ub+1] == mn-1)){\n\t\t// upper left - bottom right\n\t\tint Lz = (lb > 0 && p[lb-1] == mx+1) ? L[1][lb-1] : lb;\n\t\tint Rz = (ub < n-1 && p[ub+1] == mn-1) ? R[0][ub+1] : ub;\n\t\tauto ret = solve(Lz, Rz, min(mn, p[Rz]), max(mx, p[Lz]));\n\t\tll all = get_dist(Lz, Rz);\n\t\tll F = min(ub!=Rz?get_dist(lb,Rz)+all+ret.fi:get_dist(lb, Lz)+ret.fi, lb!=Lz?get_dist(lb,Lz)+all+ret.sc:get_dist(lb, Rz)+ret.sc);\n\t\tll S = min(lb!=Lz?get_dist(ub,Lz)+all+ret.sc:get_dist(ub, Rz)+ret.sc, ub!=Rz?get_dist(ub,Rz)+all+ret.fi:get_dist(ub, Lz)+ret.fi);\n\t\treturn cache[mp(lb, ub)] = mp(F, S);\n\t}\n\telse{\n\t\t//end\n\t\tMi = ub-lb;\n\t\treturn mp(0ll, 0ll);\n\t}\n}\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t\tzax.pb(x[i]); zay.pb(y[i]);\n\t}\n\tSORT(zax); SORT(zay);\n\trep(i, n){\n\t\tx[i] = POSL(zax, x[i]);\n\t\ty[i] = POSL(zay, y[i]);\n\t\tp[x[i]] = y[i];\n\t\trev[x[i]] = i;\n\t}\n\trep(i, n){\n\t\tif(i == 0 || p[i]-1 != p[i-1]) L[0][i] = i;\n\t\telse L[0][i] = L[0][i-1];\n\t\t\n\t\tif(i == 0 || p[i]+1 != p[i-1]) L[1][i] = i;\n\t\telse L[1][i] = L[1][i-1];\n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i == n-1 || p[i]-1 != p[i+1]) R[0][i] = i;\n\t\telse R[0][i] = R[0][i+1];\n\t\t\n\t\tif(i == n-1 || p[i]+1 != p[i+1]) R[1][i] = i;\n\t\telse R[1][i] = R[1][i+1];\n\t}\n\trep(i, n){\n\t\tauto ret = solve(i, i, p[i], p[i]);\n\t\tassert(ret.fi == ret.sc);\n\t\tans[rev[i]] = ret.fi - Mi;\n\t}\n\trep(i, n) printf(\"%lld\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000;\n\nint n,x[N+9],y[N+9];\nint ox[N+9],oy[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n\tox[i]=x[i];oy[i]=y[i];\n  }\n}\n\nint id[N+9],p[N+9];\n\nvoid Get_id(){\n  sort(ox+1,ox+n+1);\n  sort(oy+1,oy+n+1);\n  for (int i=1;i<=n;++i){\n\tx[i]=lower_bound(ox+1,ox+n+1,x[i])-ox;\n\ty[i]=lower_bound(oy+1,oy+n+1,y[i])-oy;\n\tid[x[i]]=i;p[x[i]]=y[i];\n  }\n}\n\nint le[N+9],ri[N+9];\n\nvoid Get_le_ri(){\n  le[1]=1;ri[n]=n;\n  for (int i=2;i<=n;++i) le[i]=abs(p[i]-p[i-1])==1?le[i-1]:i;\n  for (int i=n-1;i>=1;--i) ri[i]=abs(p[i]-p[i+1])==1?ri[i+1]:i;\n}\n\nmap<int,LL>dp[2][N+9];\n\nint Get_dis(int a,int b){\n  a=id[a];b=id[b];\n  return abs(ox[x[a]]-ox[x[b]])+abs(oy[y[a]]-oy[y[b]]);\n}\n\nLL Dfs_dp(int l,int r,int t,int mn,int mx){\n  if (dp[t][l].find(r)!=dp[t][l].end()) return dp[t][l][r];\n  LL res=l-r;\n  int flag=0;\n  if (l>1&&(p[l-1]==mn-1||p[l-1]==mx+1))\n\tres=Dfs_dp(le[l-1],r,0,min(mn,p[le[l-1]]),max(mx,p[ri[l-1]]))+Get_dis(le[l-1],t?r:l),flag=1;\n  if (r<n&&(p[r+1]==mn-1||p[r+1]==mx+1)){\n\tLL now=Dfs_dp(l,ri[r+1],1,min(mn,p[ri[r+1]]),max(mx,p[ri[r+1]]))+Get_dis(ri[r+1],t?r:l);\n\tres=flag?min(res,now):now;\n  }\n  return dp[t][l][r]=res;\n}\n\nLL ans[N+9];\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i) ans[id[i]]=Dfs_dp(i,i,0,p[i],p[i]);\n}\n\nvoid work(){\n  Get_id();\n  Get_le_ri();\n  Get_dp();\n}\n\nvoid outo(){\n  for (int i=1;i<=n;++i)\n\tprintf(\"%lld\\n\",ans[i]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N = 400010;\nint n, m, a[N];\nll ans[N],disL[N],disR[N];\nint cc[N];\nvector<array<int,3>> pos;\nVI vy;\nint x[N],y[N],ww[N],posl[N],posr[N];\nbool sg[N];\n\nnamespace xihetree {\n#define rg register\n\nint st1[N], st2[N], tp1, tp2, rt;\nint L[N], R[N], M[N], id[N], cnt, typ[N], bin[20], st[N], tp;\n//本篇代码原题应为 CERC2017 Intrinsic Interval\n// a数组即为原题中对应的排列\n// st1和st2分别两个单调栈，tp1、tp2为对应的栈顶，rt为析合树的根\n// L、R数组表示该析合树节点的左右端点，M数组的作用在析合树构造时有提到\n// id存储的是排列中某一位置对应的节点编号，typ用于标记析点还是合点\n// st为存储析合树节点编号的栈，tp为其栈顶\nstruct RMQ {  // 预处理 RMQ（Max & Min）\n  int lg[N], mn[N][17], mx[N][17];\n  void chkmn(int& x, int y) {\n    if (x > y) x = y;\n  }\n  void chkmx(int& x, int y) {\n    if (x < y) x = y;\n  }\n  void build() {\n    for (int i = bin[0] = 1; i < 20; ++i) bin[i] = bin[i - 1] << 1;\n    for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;\n    for (int i = 1; i <= n; ++i) mn[i][0] = mx[i][0] = a[i];\n    for (int i = 1; i < 17; ++i)\n      for (int j = 1; j + bin[i] - 1 <= n; ++j)\n        mn[j][i] = min(mn[j][i - 1], mn[j + bin[i - 1]][i - 1]),\n        mx[j][i] = max(mx[j][i - 1], mx[j + bin[i - 1]][i - 1]);\n  }\n  int ask_mn(int l, int r) {\n    int t = lg[r - l + 1];\n    return min(mn[l][t], mn[r - bin[t] + 1][t]);\n  }\n  int ask_mx(int l, int r) {\n    int t = lg[r - l + 1];\n    return max(mx[l][t], mx[r - bin[t] + 1][t]);\n  }\n} D;\n// 维护 L_i\n\nstruct SEG {  // 线段树\n#define ls (k << 1)\n#define rs (k << 1 | 1)\n  int mn[N << 1], ly[N << 1];  // 区间加；区间最小值\n  void pushup(int k) { mn[k] = min(mn[ls], mn[rs]); }\n  void mfy(int k, int v) { mn[k] += v, ly[k] += v; }\n  void pushdown(int k) {\n    if (ly[k]) mfy(ls, ly[k]), mfy(rs, ly[k]), ly[k] = 0;\n  }\n  void update(int k, int l, int r, int x, int y, int v) {\n    if (l == x && r == y) {\n      mfy(k, v);\n      return;\n    }\n    pushdown(k);\n    int mid = (l + r) >> 1;\n    if (y <= mid)\n      update(ls, l, mid, x, y, v);\n    else if (x > mid)\n      update(rs, mid + 1, r, x, y, v);\n    else\n      update(ls, l, mid, x, mid, v), update(rs, mid + 1, r, mid + 1, y, v);\n    pushup(k);\n  }\n  int query(int k, int l, int r) {  // 询问 0 的位置\n    if (l == r) return l;\n    pushdown(k);\n    int mid = (l + r) >> 1;\n    if (!mn[ls])\n      return query(ls, l, mid);\n    else\n      return query(rs, mid + 1, r);\n    // 如果不存在 0 的位置就会自动返回当前你查询的位置\n  }\n} T;\n\nint o = 1, hd[N], dep[N], fa[N][18];\nint tot=0;\nstruct Edge {\n  int v, nt;\n} E[N << 1];\nint disto(int u,int v) {\n\treturn abs(x[u]-x[v])+abs(y[u]-y[v]);\n}\nvoid add(int u, int v) {  // 树结构加边\n  E[o] = (Edge){v, hd[u]};\n  hd[u] = o++;\n}\n\nvoid ddfs(int u) {\n\tint sg=L[u]==R[u];\n\tL[u]=tot+1;\n\tif (sg) tot++;\n\tVI child;\n\t  for (int i = hd[u]; i; i = E[i].nt) {\n\t    int v = E[i].v;\n\t    child.pb(v);\n\t}\n\treverse(all(child));\n\tfor (auto v:child) {\n\t    ddfs(v);\n\t  }\n\tR[u]=tot;\n}\nvoid dfs(int u) {\n\t//printf(\"u %d L %d R %d type %d\\n\",u,L[u],R[u],typ[u]);\n\t//printf(\"disL %lld disR %lld cnt %d\\n\",disL[u],disR[u],cc[u]);\n\tif (L[u]==R[u]) {\n\t\tans[ww[L[u]]]=min(disL[u],disR[u])-cc[u];\n\t\treturn;\n\t}\n\tif (typ[u]==1) {\n\t\tVI child;\n\t  \tfor (int i = hd[u]; i; i = E[i].nt) {\n\t    \tint v = E[i].v;\n\t    \tchild.pb(v);\n\t    \tsg[v]=L[v]==R[v];\n\t\t}\n\t\treverse(all(child));\n\t\tint gol=0;\n\t\trep(i,0,SZ(child)) {\n\t\t\tif (!sg[child[i]]) {\n\t\t\t\tposl[i]=gol;\n\t\t\t\tgol=i+1;\n\t\t\t} else {\n\t\t\t\tposl[i]=gol;\n\t\t\t}\n\t\t}\n\t\tint gor=SZ(child)-1;\n\t\tper(i,0,SZ(child)) {\n\t\t\tif (!sg[child[i]]) {\n\t\t\t\tposr[i]=gor;\n\t\t\t\tgor=i-1;\n\t\t\t\t//printf(\"nsg %d %d\\n\",u,i);\n\t\t\t} else {\n\t\t\t\tposr[i]=gor;\n\t\t\t}\n\t\t}\n\t\trep(i,0,SZ(child)) {\n\t\t\tint v=child[i];\n\t\t\tint l=L[child[posl[i]]],r=R[child[posr[i]]];\n\t\t\t//printf(\"zzzzz %d %d %d\\n\",v,posl[i],posr[i]);;\n\t\t\tif (posl[i]==0&&posr[i]==SZ(child)-1) {\n\t\t\t\tcc[v]=cc[u]+r-l-(R[v]-L[v]);\n\t\t\t\tif (i!=0&&i!=SZ(child)-1) {\n\t\t\t\t\tdisL[v]=min(disL[u]+disto(L[v],r),disR[u]+disto(L[v],l))+disto(r,l);\n\t\t\t\t\tdisR[v]=min(disL[u]+disto(R[v],r),disR[u]+disto(R[v],l))+disto(r,l);\n\t\t\t\t} else if (i==0) {\n\t\t\t\t\tdisL[v]=min(disL[u]+disto(L[v],r),disR[u]+disto(L[v],l))+disto(r,l);\n\t\t\t\t\tdisR[v]=min(disL[u]+disto(R[v],r)+disto(r,l),disR[u]+disto(R[v],r));\t\n\t\t\t\t} else {\n\t\t\t\t\tdisL[v]=min(disL[u]+disto(L[v],l),disR[u]+disto(L[v],l)+disto(r,l));\n\t\t\t\t\tdisR[v]=min(disL[u]+disto(R[v],r),disR[u]+disto(R[v],l))+disto(r,l);\n\n\t\t\t\t}\n\t\t\t\t//printf(\"gggggg %d %d %d\\n\",r,l,disto(r,l));\n\t\t\t\t//printf(\"zzz %d %d %d %d\\n\",cc[u],r-l,R[v]-L[v],cc[u]+r-l-(R[v]-L[v]));\n\t\t\t} else {\n\t\t\t\tcc[v]=r-l-(R[v]-L[v]);\n\t\t\t\tif (posl[i]!=i&&posr[i]!=i) {\n\t\t\t\t\tdisL[v]=min(disto(L[v],r),disto(L[v],l))+disto(r,l);\n\t\t\t\t\tdisR[v]=min(disto(R[v],r),disto(R[v],l))+disto(r,l);\n\t\t\t\t} else if (posr[i]!=i) {\n\t\t\t\t\tdisL[v]=disto(L[v],r);\n\t\t\t\t\tdisR[v]=disto(R[v],r);\n\t\t\t\t} else if (posl[i]!=i) {\n\t\t\t\t\tdisL[v]=disto(L[v],l);\n\t\t\t\t\tdisR[v]=disto(R[v],l);\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t//printf(\"fuck \")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//if (typ[u]==)\n  for (int i = hd[u]; i; i = E[i].nt) {\n    int v = E[i].v;\n    //printf(\"edge %d %d\\n\",u,v);\n    dep[v] = dep[u] + 1;\n    dfs(v);\n  }\n}\n\n// 判断当前区间是否为连续段\nbool judge(int l, int r) { return D.ask_mx(l, r) - D.ask_mn(l, r) == r - l; }\n\n// 建树\nvoid build() {\n  for (int i = 1; i <= n; ++i) {\n    // 单调栈\n    // 在区间 [st1[tp1-1]+1,st1[tp1]] 的最小值就是 a[st1[tp1]]\n    // 现在把它出栈，意味着要把多减掉的 Min 加回来。\n    // 线段树的叶结点位置 j 维护的是从 j 到当前的 i 的\n    // Max{j,i}-Min{j,i}-(i-j)\n    // 区间加只是一个 Tag。\n    // 维护单调栈的目的是辅助线段树从 i-1 更新到 i。\n    // 更新到 i 后，只需要查询全局最小值即可知道是否有解\n\n    while (tp1 && a[i] <= a[st1[tp1]])  // 单调递増的栈，维护 Min\n      T.update(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], a[st1[tp1]]), tp1--;\n    while (tp2 && a[i] >= a[st2[tp2]])\n      T.update(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], -a[st2[tp2]]), tp2--;\n\n    T.update(1, 1, n, st1[tp1] + 1, i, -a[i]);\n    st1[++tp1] = i;\n    T.update(1, 1, n, st2[tp2] + 1, i, a[i]);\n    st2[++tp2] = i;\n\n    id[i] = ++cnt;\n    L[cnt] = R[cnt] = i;  // 这里的 L,R 是指值域的上下界\n    int le = T.query(1, 1, n), now = cnt;\n    while (tp && L[st[tp]] >= le) {\n      if (typ[st[tp]] && judge(M[st[tp]], i)) {\n        // 判断是否能成为儿子，如果能就做\n        R[st[tp]] = i, add(st[tp], now), now = st[tp--];\n      } else if (judge(L[st[tp]], i)) {\n        typ[++cnt] = 1;  // 合点一定是被这样建出来的\n        L[cnt] = L[st[tp]], R[cnt] = i, M[cnt] = L[now];\n        // 这里M数组的作用是保证合点的儿子排列是单调的\n        add(cnt, st[tp--]), add(cnt, now);\n        now = cnt;\n      } else {\n        add(++cnt, now);  // 新建一个结点，把 now 添加为儿子\n        // 如果从当前结点开始不能构成连续段，就合并。\n        // 直到找到一个结点能构成连续段。而且我们一定能找到这样\n        // 一个结点。\n        do\n          add(cnt, st[tp--]);\n        while (tp && !judge(L[st[tp]], i));\n        L[cnt] = L[st[tp]], R[cnt] = i, add(cnt, st[tp--]);\n        now = cnt;\n      }\n    }\n    st[++tp] = now;  // 增量结束，把当前点压栈\n\n    T.update(1, 1, n, 1, i, -1);  // 因为区间右端点向后移动一格，因此整体 -1\n  }\n\n  rt = st[1];  // 栈中最后剩下的点是根结点\n}\nvoid gao() {\n  D.build();\n  build();\n  ddfs(rt);\n  dfs(rt);\n}\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) {\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tpos.pb({x[i],y[i],i});\n\t\tvy.pb(y[i]);\n\t}\n\tsort(all(pos));\n\tsort(all(vy));\n\trep(i,0,n) {\n\t\tww[i+1]=pos[i][2];\n\t\tx[i+1]=pos[i][0];\n\t\ty[i+1]=pos[i][1];\n\t\ta[i+1]=lower_bound(all(vy),pos[i][1])-vy.begin()+1;\n\t//\tprintf(\"%d \",a[i+1]);\n\t}\n\t//puts(\"\");\n\txihetree::gao();\n\trep(i,1,n+1) printf(\"%lld\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\n#define N 200020\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nstruct Rook{\n\tint x,y,id;\n\tbool operator <(const Rook b)const{\n\t\treturn x<b.x;\n\t}\n}a[N];\nint n;\nvector<int> ys;\npair<ll,ll> ans[N];\n\ninline int Abs(int x){\n\treturn x>=0?x:-x;\n}\ninline int Dis(int i,int j){\n\treturn Abs(a[i].x-a[j].x)+Abs(a[i].y-a[j].y);\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].id=i;\n\t\ta[i].x=read(),a[i].y=read();\n\t\tys.push_back(a[i].y);\n\t}\n\tsort(a+1,a+n+1);\n\tys.push_back(-inf),ys.push_back(inf);\n\tsort(ys.begin(),ys.end());\n\tmemset(ans,~0x3f,sizeof(ans));\n\tfor(int S=1;S<=n;++S){\n\t\tif(ans[a[S].id].first>=0)continue;\n\t\tint by=lower_bound(ys.begin(),ys.end(),a[S].y)-ys.begin();\n\t\tint ly=by-1,ry=by+1,L=S,R=S;\n\t\tint las=-1;\n\t\tbool ok;\n\t\tvector<pair<int,int> > it;\n\t\tdo{\n\t\t\tok=false;\n\t\t\tfor(int i:{L-1,R+1}){\n\t\t\t\tif(i<1||i>n)continue;\n\t\t\t\tbool pre=ys[ly]==a[i].y,suf=ys[ry]==a[i].y;\n\t\t\t\tif(pre||suf){\n\t\t\t\t\tint dir=(pre==(i==L-1));\n\t\t\t\t\tif(las^dir){\n\t\t\t\t\t\tif(~pre)it.emplace_back(L,R);\n\t\t\t\t\t\tlas=dir;\n\t\t\t\t\t}\n\t\t\t\t\tif(pre)--ly;else ++ry;\n\t\t\t\t\tif(i==L-1)--L;else ++R;\n\t\t\t\t\tok=true;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ok);\n\t\tif(it.empty()||it.back()!=make_pair(L,R)){\n\t\t\tit.emplace_back(L,R);\n\t\t}\n\t\tstatic ll dp[N][2];\n\t\tint m=it.size();\n\t\tdp[m-1][0]=dp[m-1][1]=0;\n\t\tfor(int u=m-1;u>=1;--u){\n\t\t\tint L1=it[u].first,R1=it[u].second;\n\t\t\tint L2=it[u-1].first,R2=it[u-1].second;\n\t\t\tdp[u-1][0]=min(dp[u][0]+((R1==R2)?Dis(L1,L2):Dis(L1,R1)+Dis(R1,L2)),dp[u][1]+Dis(R1,L1)+Dis(L1,L2));\n\t\t\tdp[u-1][1]=min(dp[u][1]+((L1==L2)?Dis(R1,R2):Dis(R1,L1)+Dis(L1,R2)),dp[u][0]+Dis(L1,R1)+Dis(R1,R2));\n\t\t}\n\t\tint eL=it[0].first,eR=it[0].second;\n\t\tfor(int i=eL;i<=eR;++i){\n\t\t\tans[a[i].id]=make_pair(R-L,min(dp[0][0]+Dis(eL,eR)+Dis(eR,i),dp[0][1]+Dis(eR,eL)+Dis(eL,i)));\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%lld\\n\",ans[i].second-ans[i].first);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n\nnamespace IO {\n  const int IN_LEN = 1 << 18 | 1;\n  static char buf[IN_LEN] , *s , *t;\n  inline int Getchar( void ) { return s == t && ( t = ( s = buf ) + fread( buf , 1 , IN_LEN , stdin ) ) , s == t ? -1 : *s++; }\n  template <class T> inline void read( T & x ) {\n    static int c , f; c = Getchar() , x = f = 0;\n    while( c < '0' || c > '9' ) { if( c == '-' ) f = 1; c = Getchar(); }\n    while( c <= '9' && c >= '0' ) x = x * 10 + c - 48 , c = Getchar(); \n    x = f ? -x : x;\n  }\n} using IO::read;\n\nusing namespace std;\n\ntypedef long long lol;\ntypedef pair<int,int> pii;\nconst int N = 2e5 + 5;\n\nlol ans[N] , f[N][2];\n\nstruct Data {\n  int x , y , id , _y;\n  bool operator < ( const Data & rhs ) const {\n    return x < rhs.x;\n  }\n  lol friend dist( Data a , Data b ) {\n    return abs( a.x - b.x ) + abs( a._y - b._y );\n  }\n} dat[N];\n\nint n , discre[N] , discre_tot;\n\ninline int discreid( int x ) { return lower_bound( discre + 1 , discre + 1 + discre_tot , x ) - discre; }\n\nint main( void ) {\n  read( n );\n  for( int i = 1 ; i <= n ; ++i ) {\n    read( dat[i].x );\n    read( dat[i].y );\n    discre[i] = dat[i].y;\n    dat[i]._y = dat[i].y;\n    dat[i].id = i;\n  }\n  memset( ans , -1 , sizeof ans );\n  sort( dat + 1 , dat + 1 + n );\n  sort( discre + 1 , discre + 1 + n );\n  discre_tot = unique( discre + 1 , discre + 1 + n ) - discre - 1;\n  for( int i = 1 ; i <= n ; ++i )\n    dat[i].y = discreid( dat[i].y );\n  for( int i = 1 , L , R , l , r , _mono , _updl , _updr , sz , _cnt ; i <= n ; ++i )\n    if( !~ans[dat[i].id] ) {\n      l = r = i , L = dat[i].y , R = dat[i].y;\n      _mono = 0;\n      if( i < n && dat[i + 1].y == dat[i].y + 1 ) _mono = 1;\n      if( i < n && dat[i + 1].y == dat[i].y - 1 ) _mono = -1;\n      if( !_mono ) {\n        if( i > 1 && dat[i - 1].y == dat[i].y - 1 ) _mono = 1;\n        if( i > 1 && dat[i - 1].y == dat[i].y + 1 ) _mono = -1;\n      }\n      if( !_mono ) {\n        ans[dat[i].id] = 0;\n        continue;\n      }\n      vector<pii> layer;\n      vector<int> cnt;\n      while( 114514 ) {\n        _updl = _updr = _cnt = 0;\n        while( l > 1 && dat[l - 1].y == L - _mono ) --l , L -= _mono , _updl = 1 , ++_cnt;\n        while( r < n && dat[r + 1].y == R + _mono ) ++r , R += _mono , _updr = 1 , ++_cnt;\n        if( _updl || _updr ) {\n          cnt.push_back( _cnt );\n          if( !layer.size() ) layer.push_back( pii( l , r ) );\n          else {\n            int _l = l , _r = r;\n            if( !_updl ) _l = r - _cnt + 1;\n            if( !_updr ) _r = l + _cnt - 1;\n            layer.push_back( pii( _l , _r ) );\n          }\n          swap( L , R );\n          _mono = -_mono;\n        } else break;\n      }\n      sz = layer.size();\n      memset( f , 0x3f , sizeof( int ) * 2 * sz );\n      f[sz - 1][0] = f[sz - 1][1] = 0;\n      for( int _ = sz - 2 , l , r , _l , _r , _t ; ~_ ; --_ ) {\n        l = layer[_].fi , r = layer[_].se;\n        _l = layer[_+1].fi , _r = layer[_+1].se;\n        _t = cnt[_+1];\n        f[_][0] = min( dist( dat[l] , dat[_r] ) + f[_+1][0] , dist( dat[l] , dat[_l] ) + f[_+1][1] ) + dist( dat[_l] , dat[_r] ) - _t;\n        f[_][1] = min( dist( dat[r] , dat[_r] ) + f[_+1][0] , dist( dat[r] , dat[_l] ) + f[_+1][1] ) + dist( dat[_l] , dat[_r] ) - _t;\n      }\n      l = layer[0].fi , r = layer[0].se;\n      for( int _ = l ; _ <= r ; ++_ )\n        ans[dat[_].id] = min( dist( dat[_] , dat[r] ) + f[0][0] , dist( dat[_] , dat[l] ) + f[0][1] ) + dist( dat[l] , dat[r] ) - ( r - l );\n    }\n  for( int i = 1 ; i <= n ; ++i )\n    printf(\"%lld\\n\",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int MAXM = 1e6 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct Node {\n\tint pl, pr, vl, vr, type;\n\tvector <int> sons;\n} a[MAXN * 2];\nll ans[MAXN], dp[MAXN * 2][2];\nint n, tot, x[MAXN], y[MAXN], p[MAXN], rkx[MAXN], rky[MAXN];\nint dist(int a, int b) {\n\tif (a == b) return 0;\n\telse return abs(x[p[a]] - x[p[b]]) + abs(y[p[a]] - y[p[b]]);\n}\nvoid work(int pos) {\n\tif (pos <= n) {\n\t\tans[p[pos]] = dp[pos][0];\n\t\treturn;\n\t}\n\tvector <int> &s = a[pos].sons;\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 0, last = a[pos].pl; i < s.size(); i++) {\n\t\tl[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pr + 1;\n\t}\n\tfor (int i = s.size() - 1, last = a[pos].pr; i >= 0; i--) {\n\t\tr[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pl - 1;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint dest = s[i], pl = l[i], pr = r[i];\n\t\tif (pl == a[dest].pl && pr == a[dest].pr) dp[dest][0] = dp[dest][1] = 0;\n\t\telse if (pl == a[dest].pl) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr) + dp[pos][1];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr) + dp[pos][1];\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr);\n\t\t\t}\n\t\t} else if (pr == a[dest].pr) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl) + dp[pos][0];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl) + dp[pos][0];\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = min(dp[pos][0] + dist(a[dest].pl, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dp[pos][0] + dist(a[dest].pr, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = min(dist(a[dest].pl, pr) + dist(pl, pr), dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dist(a[dest].pr, pr) + dist(pl, pr), dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t}\n\t\t}\n\t\tdp[dest][0] -= a[dest].pl - pl + pr - a[dest].pr;\n\t\tdp[dest][1] -= a[dest].pl - pl + pr - a[dest].pr;\n\t}\n\tfor (int i = 0; i < s.size(); i++)\n\t\twork(s[i]);\n}\nint leaf(int x) {\n\ta[++tot].type = 0;\n\ta[tot].pl = a[tot].pr = x;\n\ta[tot].vl = a[tot].vr = rky[p[x]];\n\treturn tot;\n}\nint join(int x, int y) {\n\tif (a[x].vl < a[y].vl) {\n\t\tassert(a[x].vr + 1 == a[y].vl);\n\t\ta[++tot].type = 1;\n\t\ta[tot].pl = a[x].pl, a[tot].vl = a[x].vl;\n\t\ta[tot].pr = a[y].pr, a[tot].vr = a[y].vr;\n\t} else {\n\t\tassert(a[y].vr + 1 == a[x].vl);\n\t\ta[++tot].type = -1;\n\t\ta[tot].pl = a[x].pl, a[tot].vr = a[x].vr;\n\t\ta[tot].pr = a[y].pr, a[tot].vl = a[y].vl;\n\t}\n\ta[tot].sons.push_back(x);\n\ta[tot].sons.push_back(y);\n\treturn tot;\n}\nvoid buildTree() {\n\tfor (int i = 1; i <= n; i++)\n\t\tleaf(i);\n\tstatic int s[MAXN]; int top = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tbool flg = true; s[++top] = i;\n\t\twhile (flg) {\n\t\t\tflg = false;\n\t\t\tif (top >= 2 && a[s[top - 1]].type == 1 && a[s[top - 1]].vr + 1 == a[s[top]].vl) {\n\t\t\t\ta[s[top - 1]].vr = a[s[top]].vr;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tflg = true, top--;\n\t\t\t} else if (top >= 2 && a[s[top - 1]].type == -1 && a[s[top - 1]].vl - 1 == a[s[top]].vr) {\n\t\t\t\ta[s[top - 1]].vl = a[s[top]].vl;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tflg = true, top--;\n\t\t\t} else if (top >= 2 && max(a[s[top]].vr, a[s[top - 1]].vr) - min(a[s[top]].vl, a[s[top - 1]].vl) == max(a[s[top]].pr, a[s[top - 1]].pr) - min(a[s[top]].pl, a[s[top - 1]].pl)) {\n\t\t\t\tint y = s[top--], x = s[top--];\n\t\t\t\ts[++top] = join(x, y);\n\t\t\t\tflg = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= top; i++)\n\t\twork(s[i]);\n}\nvoid getrk(int n, int *x, int *rkx) {\n\tstatic int cnt[MAXM];\n\tmemset(cnt, 0, sizeof(cnt));\n\tfor (int i = 1; i <= n; i++)\n\t\tcnt[x[i]]++;\n\tfor (int i = 1; i < MAXM; i++)\n\t\tcnt[i] += cnt[i - 1];\n\tfor (int i = 1; i <= n; i++)\n\t\trkx[i] = cnt[x[i]];\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(x[i]), read(y[i]);\n\tgetrk(n, x, rkx);\n\tgetrk(n, y, rky);\n\tfor (int i = 1; i <= n; i++)\n\t\tp[rkx[i]] = i;\n\tbuildTree();\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\n//int counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< int >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        options.push_back(0);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        options.push_back(1);\n    }\n\n    LL ans = 0;\n    if (options.size() == 0) {\n        ans = l-r;\n    } else if (options.size() == 1) {\n        if (options[0] == 0) {\n            int _l = bam[l-1];\n            ans = solve(_l, r, false, min(mn, p[_l]), max(mx, p[_l]));\n            ans += (side ? durotto(r, _l) : durotto(l, _l));\n        } else {\n            int _r = dan[r+1];\n            ans = solve(l, _r, true, min(mn, p[_r]), max(mx, p[_r]));\n            ans += (side ? durotto(r, _r) : durotto(l, _r));\n        }\n    } else if (options.size() == 2) {\n        ans = 1e15;\n        int _l = bam[l-1];\n        int _r = dan[r+1];\n        int _mn = min(mn, min(p[_l], p[_r]));\n        int _mx = max(mx, max(p[_l], p[_r]));\n        {\n            LL tmp = solve(_l, _r, true, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _l)*2+durotto(r, _r);\n            } else {\n                tmp += durotto(l, _l)*2+durotto(l, _r);\n            }\n            ans = min(ans, tmp);\n        }\n        {\n            LL tmp = solve(_l, _r, false, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _r)*2+durotto(r, _l);\n            } else {\n                tmp += durotto(l, _r)*2+durotto(l, _l);\n            }\n            ans = min(ans, tmp);\n        }\n    }\n\n//    counter++;\n//    cout << options.size() << \" options\" << endl;\n//    cout << \"dp[\" << side << \"][\" << l << \"][\" << r << \"] = \" << ans << endl;\n    return dp[side][l][r] = ans;\n}\n\nint ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n//        cout << \"q[\" << idY[i] << \"] = \" << i+1 << endl;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n//        cout << p[i] << \" \";\n    }\n//    cout << endl;\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\n#define N 200020\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nstruct Rook{\n\tint x,y,id;\n\tbool operator <(const Rook b)const{\n\t\treturn x<b.x;\n\t}\n}a[N];\nint n;\nvector<int> ys;\npair<ll,ll> ans[N];\n\ninline int Abs(int x){\n\treturn x>=0?x:-x;\n}\ninline int Dis(int i,int j){\n\treturn Abs(a[i].x-a[j].x)+Abs(a[i].y-a[j].y);\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].id=i;\n\t\ta[i].x=read(),a[i].y=read();\n\t\tys.push_back(a[i].y);\n\t}\n\tsort(a+1,a+n+1);\n\tys.push_back(-inf),ys.push_back(inf);\n\tsort(ys.begin(),ys.end());\n\tmemset(ans,-1,sizeof(ans));\n\tfor(int S=1;S<=n;++S){\n\t\tif(~ans[a[S].id].first)continue;\n\t\tint by=lower_bound(ys.begin(),ys.end(),a[S].y)-ys.begin();\n\t\tint ly=by-1,ry=by+1,L=S,R=S;\n\t\tint las=-1;\n\t\tbool ok;\n\t\tvector<pair<int,int> > it;\n\t\tdo{\n\t\t\tok=false;\n\t\t\tfor(int i:{L-1,R+1}){\n\t\t\t\tif(i<1||i>n)continue;\n\t\t\t\tbool pre=ys[ly]==a[i].y,suf=ys[ry]==a[i].y;\n\t\t\t\tif(pre||suf){\n\t\t\t\t\tint dir=(pre==(i==L-1));\n\t\t\t\t\tif(las^dir){\n\t\t\t\t\t\tif(~las)it.emplace_back(L,R);\n\t\t\t\t\t\tlas=dir;\n\t\t\t\t\t}\n\t\t\t\t\tif(pre)--ly;else ++ry;\n\t\t\t\t\tif(i==L-1)--L;else ++R;\n\t\t\t\t\tok=true;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ok);\n\t\tif(it.empty()||it.back()!=make_pair(L,R)){\n\t\t\tit.emplace_back(L,R);\n\t\t}\n\t\tstatic ll dp[N][2];\n\t\tint m=it.size();\n\t\tdp[m-1][0]=dp[m-1][1]=0;\n\t\tfor(int u=m-1;u>=1;--u){\n\t\t\tint L1=it[u].first,R1=it[u].second;\n\t\t\tint L2=it[u-1].first,R2=it[u-1].second;\n\t\t\tdp[u-1][0]=min(dp[u][0]+((R1==R2)?Dis(L1,L2):Dis(L1,R1)+Dis(R1,L2)),dp[u][1]+Dis(R1,L1)+Dis(L1,L2));\n\t\t\tdp[u-1][1]=min(dp[u][1]+((L1==L2)?Dis(R1,R2):Dis(R1,L1)+Dis(L1,R2)),dp[u][0]+Dis(L1,R1)+Dis(R1,R2));\n\t\t}\n\t\tint eL=it[0].first,eR=it[0].second;\n\t\tfor(int i=eL;i<=eR;++i){\n\t\t\tans[a[i].id]=make_pair(R-L,min(dp[0][0]+Dis(eL,eR)+Dis(eR,i),dp[0][1]+Dis(eR,eL)+Dis(eL,i)));\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%lld\\n\",ans[i].second-ans[i].first);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  debug_out(H);\n  cerr << \" \";\n  debug_out(T...);\n}\n\ntemplate <typename T>\nvoid debug_out(set<T> a) {\n  vector<T> _a;\n  for(T t : a) _a.push_back(t);\n  debug_out(_a);\n}\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint n;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  vector<pair<int, int>> rooks(n);\n  for(int i = 0; i < n; i++) cin >> rooks[i].first >> rooks[i].second;\n  vector<int> final_id(n);\n  iota(final_id.begin(), final_id.end(), 0);\n  sort(final_id.begin(), final_id.end(), [&](int i, int j){return rooks[i] < rooks[j];});\n  sort(rooks.begin(), rooks.end());\n  vector<int> to_sort(n);\n  iota(to_sort.begin(), to_sort.end(), 0);\n  sort(to_sort.begin(), to_sort.end(), [&](int i, int j){return rooks[i].second < rooks[j].second;});\n  vector<int> pos(n);\n  for(int i = 0; i < n; i++) pos[to_sort[i]] = i;\n  SparseTable<int> to_min(pos, [&](int i, int j){return min(i, j);});\n  SparseTable<int> to_max(pos, [&](int i, int j){return max(i, j);});\n  vector<int> go_left(n);\n  vector<int> go_right(n);\n  for(int i = 0; i < n; i++) {\n    if(i == 0) continue;\n    if(abs(pos[i] - pos[i - 1]) == 1) go_left[i] = go_left[i - 1];\n    else go_left[i] = i;\n  }\n  for(int i = n - 1; i >= 0; i--) {\n    if(i == n - 1) {\n      go_right[i] = n - 1;\n      continue;\n    }\n    if(abs(pos[i] - pos[i + 1]) == 1) go_right[i] = go_right[i + 1];\n    else go_right[i] = i;\n  }\n  map<pair<int, int>, pair<long long, long long>> dp;\n  map<pair<int, int>, int> cursed;\n  auto dis = [&](int i, int j) {\n    return 1LL * abs(rooks[i].first - rooks[j].first) + 1LL * abs(rooks[i].second - rooks[j].second);\n  };\n  function<pair<long long, long long>(int, int)> dfs = [&](int l, int r) {\n    if(dp.count(make_pair(l, r))) return dp[make_pair(l, r)];\n    int sl = l;\n    int sr = r;\n    if(l) {\n      int v = pos[l - 1];\n      int x = to_min.get(l, r);\n      int y = to_max.get(l, r);\n      if(abs(v - x) == 1 || abs(v - y) == 1) {\n        sl = go_left[l - 1];\n      }\n    }\n    if(r < n - 1) {\n      int v = pos[r + 1];\n      int x = to_min.get(l, r);\n      int y = to_max.get(l, r);\n      if(abs(v - x) == 1 || abs(v - y) == 1) {\n        sr = go_right[r + 1];\n      }\n    }\n    if(sl == l && sr == r) {\n      cursed[make_pair(l, r)] = r - l + 1;\n      return make_pair(0LL, 0LL);\n    }\n    auto foo = dfs(sl, sr);\n    cursed[make_pair(l, r)] = cursed[make_pair(sl, sr)];\n    pair<long long, long long> res = foo;\n    long long get_left = res.first;\n    long long get_right = res.second;\n    if(sl == l && sr != r) {\n      dp[make_pair(l, r)] = make_pair(dis(l, sr) + get_right, dis(r, sr) + get_right);\n    }\n    if(sl != l && sr == r) {\n      dp[make_pair(l, r)] = make_pair(dis(l, sl) + get_left, dis(r, sl) + get_left);\n    }\n    if(sl != l && sr != r) {\n      long long move_left = min(dis(l, sr) + dis(sr, sl) + res.first, dis(l, sl) + dis(sl, sr) + res.second);\n      long long move_right = min(dis(r, sr) + dis(sr, sl) + res.first, dis(r, sl) + dis(sl, sr) + res.second);\n      dp[make_pair(l, r)] = make_pair(move_left, move_right);\n    }\n    return dp[make_pair(l, r)];\n  };\n  vector<long long> res(n);\n  for(int i = 0; i < n; i++) {\n    auto foo = dfs(go_left[i], go_right[i]);\n    int cnt = cursed[make_pair(go_left[i], go_right[i])];\n    pair<long long, long long> way = foo;\n    res[final_id[i]] = min(dis(i, go_left[i]) + dis(go_left[i], go_right[i]) + way.second, dis(i, go_right[i]) + dis(go_right[i], go_left[i]) + way.first) - cnt + 1;\n  }\n  for(long long i : res) {\n    cout << i << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n\n/**\n * Description: Calculates least common ancestor in tree with verts \n \t* $0\\ldots N-1$ and root $R$ using binary jumping. \n * Time: O(N\\log N) build, O(\\log N) query\n * Memory: O(N\\log N)\n * Source: USACO Camp, KACTL\n * Verification: *\n */\n \nstruct LCA {\n\tint N; vector<vi> par, adj; vi depth;\n\tvoid init(int _N) {  N = _N;\n\t\tint d = 1; while ((1<<d) < N) d ++;\n\t\tpar.assign(d,vi(N)); adj.rsz(N); depth.rsz(N);\n\t}\n\tvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\n\tvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\tvoid dfs(int x = 0) {\n\t\tFOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n\t\ttrav(y,adj[x]) if (y != par[0][x]) \n\t\t\tdepth[y] = depth[par[0][y] = x]+1, dfs(y);\n\t}\n\tint jmp(int x, int d) {\n\t\tF0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n\t\treturn x; }\n\tint lca(int x, int y) {\n\t\tif (depth[x] < depth[y]) swap(x,y);\n\t\tx = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n\t\tR0F(i,sz(par)) {\n\t\t\tint X = par[i][x], Y = par[i][y];\n\t\t\tif (X != Y) x = X, y = Y;\n\t\t}\n\t\treturn par[0][x];\n\t}\n\tint dist(int x, int y) { // # edges on path\n\t\treturn depth[x]+depth[y]-2*depth[lca(x,y)]; }\n};\n \nLCA LC;\n \ntypedef pi T;\n \nconst int SZ = 1<<19;\nstruct LazySeg { \n\tconst T ID = {MOD,0}; \n\tT comb(T l, T r) { \n\t\treturn l.f != r.f ? min(l,r) : T{l.f,l.s+r.s}; }\n\tT seg[2*SZ]; int lazy[2*SZ]; \n\tLazySeg() { \n\t\tF0R(i,2*SZ) lazy[i] = 0; \n\t\tF0R(i,SZ) seg[SZ+i] = {0,1};\n\t\tROF(i,1,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);\n\t}\n\tvoid push(int ind, int L, int R) { /// modify values for current node\n\t\tif (L != R) F0R(i,2) lazy[2*ind+i] += lazy[ind]; /// prop to children\n\t\tseg[ind].f += lazy[ind]; // dependent on operation\n\t\tlazy[ind] = 0; \n\t} // recalc values for current node\n\tvoid pull(int ind) { seg[ind] = comb(seg[2*ind],seg[2*ind+1]); }\n\tvoid build() { ROF(i,1,SZ) pull(i); }\n\tvoid upd(int lo,int hi,int inc,int ind=1,int L=0, int R=SZ-1) {\n\t\tpush(ind,L,R); if (hi < L || R < lo) return;\n\t\tif (lo <= L && R <= hi) { \n\t\t\tlazy[ind] = inc; push(ind,L,R); return; }\n\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); \n\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);\n\t}\n\tpi query(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {\n\t\tpush(ind,L,R); if (hi < L || R < lo) return {MOD,0};\n\t\tif (lo <= L && R <= hi) return seg[ind];\n\t\tint M = (L+R)/2;\n\t\treturn comb(query(lo,hi,2*ind,L,M),query(lo,hi,2*ind+1,M+1,R));\n\t}\n};\n \nint n;\nvi p;\nvector<vi> child;\nvpi inter, range;\nvi typ;\nvi loc, rloc;\n \npi operator+(pi a, pi b) { return {min(a.f,b.f),max(a.s,b.s)}; }\nint len(pi p) { return p.s-p.f; }\nbool adj(int _a, int _b) {\n\tpi a = range[_a], b = range[_b];\n\treturn a.s+1 == b.f || b.s+1 == a.f; \n}\n\nint N;\nint root;\n\nvoid solve() {\n\tdbg(p);\n\t// mx-mn-len >= 0\n\tLazySeg L;\n\tvi mn{-1}, mx{-1};\n\tvi st;\n\tF0R(i,n) {\n\t\tif (i) L.upd(0,i-1,-1);\n\t\tdbg(\"ADDING\",i);\n\t\t{\n\t\t\twhile (mn.bk != -1 && p[mn.bk] > p[i]) {\n\t\t\t\tint t = mn.bk; mn.pop_back();\n\t\t\t\tL.upd(mn.bk+1,t,p[t]);\n\t\t\t}\n\t\t\tL.upd(mn.bk+1,i,-p[i]); mn.pb(i); \n\t\t}\n\t\t{\n\t\t\twhile (mx.bk != -1 && p[mx.bk] < p[i]) {\n\t\t\t\tint t = mx.bk; mx.pop_back();\n\t\t\t\tL.upd(mx.bk+1,t,-p[t]);\n\t\t\t}\n\t\t\tL.upd(mx.bk+1,i,p[i]); mx.pb(i);\n\t\t}\n\t\tint cur = N++; loc.pb(cur);\n\t\tinter.pb({i,i}); range.pb({p[i],p[i]}); typ.pb(0); child.eb();\n\t\twhile (sz(st)) {\n\t\t\tif (adj(st.bk,cur)) {\n\t\t\t\tif (sz(child[st.bk]) && adj(child[st.bk].bk,cur)) {\n\t\t\t\t\tassert(typ[st.bk]); // join node\n\t\t\t\t\tinter[st.bk] = inter[st.bk]+inter[cur];\n\t\t\t\t\trange[st.bk] = range[st.bk]+range[cur];\n\t\t\t\t\tchild[st.bk].pb(cur);\n\t\t\t\t\tcur = st.bk; st.pop_back();\n\t\t\t\t} else { // make new join node\n\t\t\t\t\tint CUR = N++;\n\t\t\t\t\tinter.pb(inter[cur]+inter[st.bk]);\n\t\t\t\t\trange.pb(range[cur]+range[st.bk]);\n\t\t\t\t\ttyp.pb(range[st.bk] < range[cur] ? 1 : 2);\n\t\t\t\t\tchild.pb({st.bk,cur});\n\t\t\t\t\tcur = CUR; st.pop_back();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (L.query(0,inter[cur].f-1).f != 0) break;\n\t\t\tint CUR = N++;\n\t\t\tinter.pb(inter[cur]); range.pb(range[cur]); typ.pb(0); child.pb({cur});\n\t\t\tdo {\n\t\t\t\tassert(sz(st));\n\t\t\t\tinter[CUR] = inter[CUR]+inter[st.bk];\n\t\t\t\trange[CUR] = range[CUR]+range[st.bk];\n\t\t\t\tchild[CUR].pb(st.bk); st.pop_back();\n\t\t\t} while (len(inter.bk) != len(range.bk));\n\t\t\treverse(all(child[CUR])); cur = CUR;\n\t\t}\n\t\tst.pb(cur);\n\t}\n\tassert(sz(st) == 1);\n\troot = st.bk;\n\tdbg(root);\n\tLC.init(N);\n\tF0R(i,N) trav(t,child[i]) LC.ae(i,t);\n\tF0R(i,N) dbg(i,typ[i],inter[i],range[i],child[i]);\n\tLC.gen(root);\n\tF0R(i,N) if (typ[i]) {\n\t\tif (typ[i] == 1) {\n\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].s+1 == range[child[i][j]].f);\n\t\t} else {\n\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].f-1 == range[child[i][j]].s);\n\t\t}\n\t}\n\trloc = vi(N,-1);\n\t// dbg(\"OOPS\",loc);\n\tF0R(i,n) rloc[loc[i]] = i;\n}\n\nvector<array<ll,2>> ans;\n\nbool sing(int x) {\n\treturn rloc[x] != -1;\n}\n\nvector<array<pi,2>> ex;\n\nvector<pair<pi,int>> v;\n\nvoid dfsEx(int x) {\n\tif (rloc[x] != -1) {\n\t\tex[x][0] = ex[x][1] = v[rloc[x]].f;\n\t\treturn;\n\t}\n\tassert(sz(child[x]));\n\tF0R(i,sz(child[x])) {\n\t\tint c = child[x][i];\n\t\tdfsEx(c);\n\t\tif (i == 0) ex[x][0] = ex[c][0];\n\t\tif (i == sz(child[x])-1) ex[x][1] = ex[c][1];\n\t}\n}\n\nll dis(pi a, pi b) { return abs(a.f-b.f)+abs(a.s-b.s)-1; }\n\nvoid dfs(int x) {\n\t// dbg(\"DFS\",x);\n\t// if (rloc[x] != -1) dbg(\"HUH\",x,rloc[x],typ[x]);\n\tF0R(i,sz(child[x])) {\n\t\tint c = child[x][i];\n\t\tint l = i, r = i;\n\t\tif (typ[x]) {\n\t\t\twhile (l && sing(child[x][l-1])) l --;\n\t\t\twhile (r+1 < sz(child[x]) && sing(child[x][r+1])) r ++;\n\t\t}\n\t\tif (x == 2) dbg(x,child[x],c,l,r);\n\t\tauto endLef = [&](pi p) {\n\t\t\tll ans = 0;\n\t\t\tFOR(z,i+1,r+1) {\n\t\t\t\tans += dis(p,ex[child[x][z]][0]);\n\t\t\t\tp = ex[child[x][z]][0];\n\t\t\t}\n\t\t\tROF(z,l,i) {\n\t\t\t\tans += dis(p,ex[child[x][z]][0]);\n\t\t\t\tp = ex[child[x][z]][0];\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tauto endRig = [&](pi p) {\n\t\t\tll ans = 0;\n\t\t\tROF(z,l,i) {\n\t\t\t\tans += dis(p,ex[child[x][z]][0]);\n\t\t\t\tp = ex[child[x][z]][0];\n\t\t\t}\n\t\t\tFOR(z,i+1,r+1) {\n\t\t\t\tans += dis(p,ex[child[x][z]][0]);\n\t\t\t\tp = ex[child[x][z]][0];\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tif (l == 0 && r == sz(child[x])-1) {\n\t\t\tF0R(q,2) {\n\t\t\t\tans[c][q] = INF;\n\t\t\t\tif (i > l) ckmin(ans[c][q],endLef(ex[c][q])+ans[x][0]);\n\t\t\t\tif (i < r) ckmin(ans[c][q],endRig(ex[c][q])+ans[x][1]);\n\t\t\t}\n\t\t} else {\n\t\t\tans[c][0] = min(endLef(ex[c][0]),endRig(ex[c][0]));\n\t\t\tans[c][1] = min(endLef(ex[c][1]),endRig(ex[c][1]));\n\t\t}\n\t\tdfs(c);\n\t}\n}\n\nvoid go() {\n\tans.rsz(N); ex.rsz(N);\n\t// dbg(\"GOING\");\n\tdfsEx(root);\n\t// dbg(\"DONEEX\",ex[root]); exit(0);\n\tdfs(root);\n\tF0R(i,N) dbg(i,ex[i],child[i],rloc[i],ans[i]);\n}\n\n\nvoid genAns() {\n\tvl ret(n);\n\tret.rsz(n);\n\tF0R(i,n) ret[i] = ans[loc[i]][0];\n\tvl oops(n);\n\tF0R(i,n) oops[v[i].s] = i;\n\tF0R(i,n) ps(ret[oops[i]]);\n}\n\n\nint main() {\n\tsetIO(); re(n);\n\tv.rsz(n);\n\tint cnt = 0;\n\tvi y;\n\ttrav(t,v) {\n\t\tre(t.f); t.s = cnt++;\n\t\ty.pb(t.f.s);\n\t}\n\tremDup(y);\n\tdbg(y);\n\tsort(all(v));\n\ttrav(t,v) p.pb(lb(all(y),t.f.s)-begin(y));\n\tsolve();\n\tgo();\n\tgenAns();\n\t// ps(p);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 200000;\nconst int MAXNODE = MAXN + MAXN - 1;\nstruct P { int x, y; };\nstruct Node { deque<int> lst; vector<int> vec; int kind; int lidx, ridx; };\n\nint n;\nP p[MAXN];\nll ans[MAXN];\n\nint x2idx[MAXN];\nint xx[MAXN], nxx;\nint yy[MAXN], nyy;\n\nint lx[MAXN], hx[MAXN], ly[MAXN], hy[MAXN];\nint par[MAXN], sz[MAXN], leader[MAXN];\n\nNode node[MAXNODE]; int nnode;\nbool contained[MAXNODE];\n\nll outsidecost[MAXNODE][2];\n\nint leftmost[MAXNODE], rightmost[MAXNODE]; \nll totalcostleft[MAXNODE][2], totalcostright[MAXNODE][2];\n\n\n\nint dist(int a, int b) { if (a == b) return 0; return abs(xx[p[a].x] - xx[p[b].x]) + abs(yy[p[a].y] - yy[p[b].y]) - 1; }\n\nvoid dfsinit(int at) {\n\tvector<int> cur = node[at].vec;\n\tint len = SZ(cur);\n\tif (at < n) { assert(len == 0); node[at].lidx = node[at].ridx = x2idx[at]; return; }\n\tassert(len >= 2);\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tdfsinit(to);\n\t\tif (i == 0) node[at].lidx = node[to].lidx;\n\t\tif (i == len - 1) node[at].ridx = node[to].ridx;\n\t}\n}\nvoid dfscalc(int at) {\n\tvector<int> cur = node[at].vec;\n\tint len = SZ(cur);\n\tif (len == 0) return;\n\t//printf(\"dfs(%d) (%lld/%lld)\\n\", at, outsidecost[at][0], outsidecost[at][1]);\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tif (i - 1 < 0) { leftmost[i] = i, totalcostleft[i][0] = 0, totalcostleft[i][1] = 0; continue; }\n\t\tint pto = cur[i - 1];\n\t\tif (node[pto].kind != 0) { leftmost[i] = i, totalcostleft[i][0] = 0, totalcostleft[i][1] = dist(node[to].lidx, node[to].ridx); continue; }\n\t\tleftmost[i] = leftmost[i - 1]; REP(side, 2) totalcostleft[i][side] = dist(side == 0 ? node[to].lidx : node[to].ridx, node[pto].ridx) + totalcostleft[i - 1][1];\n\t}\n\tfor (int i = len - 1; i >= 0; --i) {\n\t\tint to = cur[i];\n\t\tif (i + 1 >= len) { rightmost[i] = i, totalcostright[i][0] = 0, totalcostright[i][1] = 0; continue; }\n\t\tint pto = cur[i + 1];\n\t\tif (node[pto].kind != 0) { rightmost[i] = i, totalcostright[i][0] = 0, totalcostright[i][1] = dist(node[to].lidx, node[to].ridx); continue; }\n\t\trightmost[i] = rightmost[i + 1]; REP(side, 2) totalcostright[i][side] = dist(side == 0 ? node[to].lidx : node[to].ridx, node[pto].lidx) + totalcostright[i + 1][0];\n\t}\n\t//REP(i, len) printf(\"%d: leftmost=%d rightmost=%d totalcostleft=%lld/%lld totalcostright=%lld/%lld\\n\", i, leftmost[i], rightmost[i], totalcostleft[i][0], totalcostleft[i][1], totalcostright[i][0], totalcostright[i][1]);\n\tREP(i, len) {\n\t\tint to = cur[i]; bool canall = leftmost[i] == 0 && rightmost[i] == len - 1;\n\t\tREP(side,2) {\n\t\t\tint aidx = i == rightmost[i] ? side == 0 ? node[cur[i]].lidx : node[cur[i]].ridx : node[cur[rightmost[i]]].ridx;\n\t\t\tint bidx = i == leftmost[i] ? side == 0 ? node[cur[i]].lidx : node[cur[i]].ridx : node[cur[leftmost[i]]].lidx;\n\t\t\tll a = totalcostright[i][side] + (i == leftmost[i] ? 0 : dist(aidx, node[cur[i - 1]].ridx) + totalcostleft[i - 1][1]) + (canall ? outsidecost[at][i != leftmost[i] ? 0 : 1] : 0);\n\t\t\tll b = totalcostleft[i][side] + (i == rightmost[i] ? 0 : dist(bidx, node[cur[i + 1]].lidx) + totalcostright[i + 1][0]) + (canall ? outsidecost[at][i != rightmost[i] ? 1 : 0] : 0);\n\t\t\t//printf(\"\\t%lld vs %lld\\n\", a, b);\n\t\t\toutsidecost[to][side] = min(a, b);\n\t\t}\n\t}\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tdfscalc(to);\n\t}\n}\n\nint makenode(int a, int b, int kind) {\n\tint ret = nnode++;\n\tnode[ret].lst.clear(); node[ret].lst.PB(a); node[ret].lst.PB(b); node[ret].kind = kind;\n\treturn ret;\n}\n\nint merge(int a, int b, int kind) {\n\tif (node[a].kind == kind && node[b].kind == kind) {\n\t\tif (SZ(node[a].lst) >= SZ(node[b].lst)) {\n\t\t\twhile (SZ(node[b].lst) != 0) { int x = node[b].lst.front(); node[b].lst.pop_front(); node[a].lst.push_back(x); }\n\t\t\treturn a;\n\t\t} else {\n\t\t\twhile (SZ(node[a].lst) != 0) { int x = node[a].lst.back(); node[a].lst.pop_back(); node[b].lst.push_front(x); }\n\t\t\treturn b;\n\t\t}\n\t}\n\tif (node[a].kind == kind) {\n\t\tnode[a].lst.push_back(b);\n\t\treturn a;\n\t}\n\tif (node[b].kind == kind) {\n\t\tnode[b].lst.push_front(a);\n\t\treturn b;\n\t}\n\treturn makenode(a, b, kind);\n}\n\nint uffind(int x) {\n\tif (par[x] == x) return par[x];\n\treturn par[x] = uffind(par[x]);\n}\nvoid ufunite(int a, int b, int kind) {\n\t//printf(\"uniting %d and %d\\n\", a, b);\n\ta = uffind(a);\n\tb = uffind(b);\n\tint oa = a, ob = b;\n\tassert(a != b);\n\tif (sz[a] < sz[b]) swap(a, b);\n\tpar[b] = a;\n\tsz[a] += sz[b];\n\tlx[a] = min(lx[a], lx[b]);\n\thx[a] = max(hx[a], hx[b]);\n\tly[a] = min(ly[a], ly[b]);\n\thy[a] = max(hy[a], hy[b]);\n\tleader[a] = merge(leader[oa], leader[ob], kind);\n}\n\nvoid solve() {\n\tnxx = 0; REP(i, n) xx[nxx++] = p[i].x; sort(xx, xx + nxx); nxx = unique(xx, xx + nxx) - xx; assert(nxx == n); REP(i, n) p[i].x = lower_bound(xx, xx + nxx, p[i].x) - xx;\n\tnyy = 0; REP(i, n) yy[nyy++] = p[i].y; sort(yy, yy + nyy); nyy = unique(yy, yy + nyy) - yy; assert(nyy == n); REP(i, n) p[i].y = lower_bound(yy, yy + nyy, p[i].y) - yy;\n\n\tnnode = n;\n\tREP(i, n) {\n\t\tint x = p[i].x, y = p[i].y;\n\t\tx2idx[x] = i;\n\t\tnode[x].lst.clear(); node[x].kind = 0;\n\t\tpar[x] = x, sz[x] = 1, lx[x] = hx[x] = x, ly[x] = hy[x] = y, leader[x] = x;\n\t}\n\tREP(i, n) {\n\t\tint b = uffind(i);\n\t\twhile (true) {\n\t\t\tb = uffind(b);\n\t\t\tif (lx[b] - 1 >= 0) {\n\t\t\t\tint a = uffind(lx[b] - 1);\n\t\t\t\tassert(hx[a] == lx[b] - 1);\n\t\t\t\tif (hy[a] == ly[b] - 1) {\n\t\t\t\t\tufunite(a, b, +1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ly[a] == hy[b] + 1) {\n\t\t\t\t\tufunite(a, b, -1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hx[b] + 1 < n) {\n\t\t\t\tint c = uffind(hx[b] + 1);\n\t\t\t\tassert(lx[c] == hx[b] + 1);\n\t\t\t\tif (hy[c] == ly[b] - 1) {\n\t\t\t\t\tufunite(b, c, -1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(ly[c]==hy[b]+1) {\n\t\t\t\t\tufunite(b, c, +1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tREP(i, nnode) { node[i].vec.clear(); while (SZ(node[i].lst) > 0) { int x = node[i].lst.front(); node[i].lst.pop_front(); node[i].vec.PB(x); } }\n\tREP(i, nnode) contained[i] = false;\n\tREP(i, nnode) REPSZ(j, node[i].vec) { int x = node[i].vec[j]; contained[x] = true; }\n\t//FOR(i, n, nnode) { printf(\"%d:\", i); REPSZ(j, node[i].vec) printf(\" %d\", node[i].vec[j]); puts(\"\"); }\n\tREP(i, nnode) if (!contained[i]) { outsidecost[i][0] = outsidecost[i][1] = 0; dfsinit(i); dfscalc(i); }\n\tREP(i, n) ans[x2idx[i]] = outsidecost[i][0];\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tREP(i, n) scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tsolve();\n\tREP(i, n) printf(\"%lld\\n\", ans[i]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\n//int counter;\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< int >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        options.push_back(0);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        options.push_back(1);\n    }\n\n    LL ans = 0;\n    if (options.size() == 0) {\n        ans = l-r;\n    } else if (options.size() == 1) {\n        if (options[0] == 0) {\n            ans = solve(l-1, r, false, min(mn, p[l-1]), max(mx, p[l-1]));\n            ans += (side ? durotto(l-1, r) : durotto(l-1, l));\n        } else {\n            ans = solve(l, r+1, true, min(mn, p[r+1]), max(mx, p[r+1]));\n            ans += (side ? durotto(r, r+1) : durotto(l, r+1));\n        }\n    } else if (options.size() == 2) {\n        ans = 1e15;\n        int _l = bam[l-1];\n        int _r = dan[r+1];\n        int _mn = min(mn, min(p[_l], p[_r]));\n        int _mx = max(mx, max(p[_l], p[_r]));\n        {\n            LL tmp = solve(_l, _r, true, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _l)*2+durotto(r, _r);\n            } else {\n                tmp += durotto(l, _l)*2+durotto(l, _r);\n            }\n            ans = min(ans, tmp);\n        }\n        {\n            LL tmp = solve(_l, _r, false, _mn, _mx);\n            if (side) {\n                tmp += durotto(r, _r)*2+durotto(r, _l);\n            } else {\n                tmp += durotto(l, _r)*2+durotto(l, _l);\n            }\n            ans = min(ans, tmp);\n        }\n    }\n\n//    counter++;\n//    cout << options.size() << \" options\" << endl;\n//    cout << \"dp[\" << side << \"][\" << l << \"][\" << r << \"] = \" << ans << endl;\n    return dp[side][l][r] = ans;\n}\n\nint ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n//        cout << \"q[\" << idY[i] << \"] = \" << i+1 << endl;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n//        cout << p[i] << \" \";\n    }\n//    cout << endl;\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i+1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n//    cout << \"counter: \" << counter << endl;\n\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) { \n\t// note: if (lo+hi)/2 is used instead of half(lo+hi) then this will loop infinitely when lo=hi\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? \"true\" : \"false\"; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = \"{\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \", \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += \"}\"; return res;\n\t#else\n\t\tbool fst = 1; str res = \"\";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += \" \";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n\t#else\n\t\treturn ts(p.f)+\" \"+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n\t\t << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n\n/**\n * Description: Calculates least common ancestor in tree with verts \n \t* $0\\ldots N-1$ and root $R$ using binary jumping. \n * Time: O(N\\log N) build, O(\\log N) query\n * Memory: O(N\\log N)\n * Source: USACO Camp, KACTL\n * Verification: *\n */\n \nstruct LCA {\n\tint N; vector<vi> par, adj; vi depth;\n\tvoid init(int _N) {  N = _N;\n\t\tint d = 1; while ((1<<d) < N) d ++;\n\t\tpar.assign(d,vi(N)); adj.rsz(N); depth.rsz(N);\n\t}\n\tvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }\n\tvoid gen(int R = 0) { par[0][R] = R; dfs(R); }\n\tvoid dfs(int x = 0) {\n\t\tFOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];\n\t\ttrav(y,adj[x]) if (y != par[0][x]) \n\t\t\tdepth[y] = depth[par[0][y] = x]+1, dfs(y);\n\t}\n\tint jmp(int x, int d) {\n\t\tF0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];\n\t\treturn x; }\n\tint lca(int x, int y) {\n\t\tif (depth[x] < depth[y]) swap(x,y);\n\t\tx = jmp(x,depth[x]-depth[y]); if (x == y) return x;\n\t\tR0F(i,sz(par)) {\n\t\t\tint X = par[i][x], Y = par[i][y];\n\t\t\tif (X != Y) x = X, y = Y;\n\t\t}\n\t\treturn par[0][x];\n\t}\n\tint dist(int x, int y) { // # edges on path\n\t\treturn depth[x]+depth[y]-2*depth[lca(x,y)]; }\n};\n \nLCA LC;\n \ntypedef pi T;\n \nconst int SZ = 1<<19;\nstruct LazySeg { \n\tconst T ID = {MOD,0}; \n\tT comb(T l, T r) { \n\t\treturn l.f != r.f ? min(l,r) : T{l.f,l.s+r.s}; }\n\tT seg[2*SZ]; int lazy[2*SZ]; \n\tLazySeg() { \n\t\tF0R(i,2*SZ) lazy[i] = 0; \n\t\tF0R(i,SZ) seg[SZ+i] = {0,1};\n\t\tROF(i,1,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);\n\t}\n\tvoid push(int ind, int L, int R) { /// modify values for current node\n\t\tif (L != R) F0R(i,2) lazy[2*ind+i] += lazy[ind]; /// prop to children\n\t\tseg[ind].f += lazy[ind]; // dependent on operation\n\t\tlazy[ind] = 0; \n\t} // recalc values for current node\n\tvoid pull(int ind) { seg[ind] = comb(seg[2*ind],seg[2*ind+1]); }\n\tvoid build() { ROF(i,1,SZ) pull(i); }\n\tvoid upd(int lo,int hi,int inc,int ind=1,int L=0, int R=SZ-1) {\n\t\tpush(ind,L,R); if (hi < L || R < lo) return;\n\t\tif (lo <= L && R <= hi) { \n\t\t\tlazy[ind] = inc; push(ind,L,R); return; }\n\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); \n\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);\n\t}\n\tpi query(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {\n\t\tpush(ind,L,R); if (hi < L || R < lo) return {MOD,0};\n\t\tif (lo <= L && R <= hi) return seg[ind];\n\t\tint M = (L+R)/2;\n\t\treturn comb(query(lo,hi,2*ind,L,M),query(lo,hi,2*ind+1,M+1,R));\n\t}\n};\n \nint n;\nvi p;\nvector<vi> child;\nvpi inter, range;\nvi typ;\nvi loc, rloc;\n \npi operator+(pi a, pi b) { return {min(a.f,b.f),max(a.s,b.s)}; }\nint len(pi p) { return p.s-p.f; }\nbool adj(int _a, int _b) {\n\tpi a = range[_a], b = range[_b];\n\treturn a.s+1 == b.f || b.s+1 == a.f; \n}\n\nint N;\nint root;\n\nvoid solve() {\n\tdbg(p);\n\t// mx-mn-len >= 0\n\tLazySeg L;\n\tvi mn{-1}, mx{-1};\n\tvi st;\n\tF0R(i,n) {\n\t\tif (i) L.upd(0,i-1,-1);\n\t\tdbg(\"ADDING\",i);\n\t\t{\n\t\t\twhile (mn.bk != -1 && p[mn.bk] > p[i]) {\n\t\t\t\tint t = mn.bk; mn.pop_back();\n\t\t\t\tL.upd(mn.bk+1,t,p[t]);\n\t\t\t}\n\t\t\tL.upd(mn.bk+1,i,-p[i]); mn.pb(i); \n\t\t}\n\t\t{\n\t\t\twhile (mx.bk != -1 && p[mx.bk] < p[i]) {\n\t\t\t\tint t = mx.bk; mx.pop_back();\n\t\t\t\tL.upd(mx.bk+1,t,-p[t]);\n\t\t\t}\n\t\t\tL.upd(mx.bk+1,i,p[i]); mx.pb(i);\n\t\t}\n\t\tint cur = N++; loc.pb(cur);\n\t\tinter.pb({i,i}); range.pb({p[i],p[i]}); typ.pb(0); child.eb();\n\t\twhile (sz(st)) {\n\t\t\tif (adj(st.bk,cur)) {\n\t\t\t\tif (sz(child[st.bk]) && adj(child[st.bk].bk,cur)) {\n\t\t\t\t\tassert(typ[st.bk]); // join node\n\t\t\t\t\tinter[st.bk] = inter[st.bk]+inter[cur];\n\t\t\t\t\trange[st.bk] = range[st.bk]+range[cur];\n\t\t\t\t\tchild[st.bk].pb(cur);\n\t\t\t\t\tcur = st.bk; st.pop_back();\n\t\t\t\t} else { // make new join node\n\t\t\t\t\tint CUR = N++;\n\t\t\t\t\tinter.pb(inter[cur]+inter[st.bk]);\n\t\t\t\t\trange.pb(range[cur]+range[st.bk]);\n\t\t\t\t\ttyp.pb(range[st.bk] < range[cur] ? 1 : 2);\n\t\t\t\t\tchild.pb({st.bk,cur});\n\t\t\t\t\tcur = CUR; st.pop_back();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (L.query(0,inter[cur].f-1).f != 0) break;\n\t\t\tint CUR = N++;\n\t\t\tinter.pb(inter[cur]); range.pb(range[cur]); typ.pb(0); child.pb({cur});\n\t\t\tdo {\n\t\t\t\tassert(sz(st));\n\t\t\t\tinter[CUR] = inter[CUR]+inter[st.bk];\n\t\t\t\trange[CUR] = range[CUR]+range[st.bk];\n\t\t\t\tchild[CUR].pb(st.bk); st.pop_back();\n\t\t\t} while (len(inter.bk) != len(range.bk));\n\t\t\treverse(all(child[CUR])); cur = CUR;\n\t\t}\n\t\tst.pb(cur);\n\t}\n\tassert(sz(st) == 1);\n\troot = st.bk;\n\tdbg(root);\n\tLC.init(N);\n\tF0R(i,N) trav(t,child[i]) LC.ae(i,t);\n\tF0R(i,N) dbg(i,typ[i],inter[i],range[i],child[i]);\n\tLC.gen(root);\n\tF0R(i,N) if (typ[i]) {\n\t\tif (typ[i] == 1) {\n\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].s+1 == range[child[i][j]].f);\n\t\t} else {\n\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].f-1 == range[child[i][j]].s);\n\t\t}\n\t}\n\trloc = vi(N,-1);\n\t// dbg(\"OOPS\",loc);\n\tF0R(i,n) rloc[loc[i]] = i;\n}\n\nvector<array<ll,2>> ans;\n\nbool sing(int x) {\n\treturn rloc[x] != -1;\n}\n\nvector<array<pi,2>> ex;\n\nvector<pair<pi,int>> v;\n\nvoid dfsEx(int x) {\n\tif (rloc[x] != -1) {\n\t\tex[x][0] = ex[x][1] = v[rloc[x]].f;\n\t\treturn;\n\t}\n\tassert(sz(child[x]));\n\tF0R(i,sz(child[x])) {\n\t\tint c = child[x][i];\n\t\tdfsEx(c);\n\t\tif (i == 0) ex[x][0] = ex[c][0];\n\t\tif (i == sz(child[x])-1) ex[x][1] = ex[c][1];\n\t}\n}\n\nll dis(pi a, pi b) { return abs(a.f-b.f)+abs(a.s-b.s)-1; }\n\nvoid dfs(int x) {\n\t// dbg(\"DFS\",x);\n\t// if (rloc[x] != -1) dbg(\"HUH\",x,rloc[x],typ[x]);\n\tint zz = sz(child[x]);\n\tvi lef(zz), rig(zz);\n\t{\n\t\tint l = 0;\n\t\tF0R(i,zz) {\n\t\t\tif (!typ[x] || (i && !sing(child[x][i-1]))) l = i;\n\t\t\tlef[i] = l;\n\t\t}\n\t}\n\t{\n\t\tint r = zz-1;\n\t\tR0F(i,zz) {\n\t\t\tif (!typ[x] || (i < zz-1 && !sing(child[x][i+1]))) r = i;\n\t\t\trig[i] = r;\n\t\t}\n\t}\n\tvl cum(zz);\n\tFOR(i,1,zz) cum[i] = cum[i-1]+dis(ex[child[x][i]][0],ex[child[x][i-1]][0]);\n\tF0R(i,zz) {\n\t\tint c = child[x][i];\n\t\tint l = lef[i], r = rig[i];\n\t\t// int l = i, r = i;\n\t\t// if (typ[x]) {\n\t\t// \twhile (l && sing(child[x][l-1])) l --;\n\t\t// \twhile (r+1 < sz(child[x]) && sing(child[x][r+1])) r ++;\n\t\t// }\n\t\tauto getSum = [&](int l, int r) {\n\t\t\treturn cum[r]-cum[l];\n\t\t\t// ll ans = 0;\n\t\t\t// FOR(i,l,r) ans += dis(ex[child[x][i]][0],ex[child[x][i+1]][0]);\n\t\t\t// return ans;\n\t\t};\n\t\tauto endLef = [&](pi p) {\n\t\t\tll ans = 0;\n\t\t\tif (r > i) {\n\t\t\t\tans += dis(p,ex[child[x][i+1]][0]);\n\t\t\t\tans += getSum(i+1,r);\n\t\t\t\tp = ex[child[x][r]][0];\n\t\t\t}\n\t\t\tif (l < i) {\n\t\t\t\tans += dis(p,ex[child[x][i-1]][0]);\n\t\t\t\tans += getSum(l,i-1);\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tauto endRig = [&](pi p) {\n\t\t\tll ans = 0;\n\t\t\tif (l < i) {\n\t\t\t\tans += dis(p,ex[child[x][i-1]][0]);\n\t\t\t\tans += getSum(l,i-1);\n\t\t\t\tp = ex[child[x][l]][0];\n\t\t\t}\n\t\t\tif (i < r) {\n\t\t\t\tans += dis(p,ex[child[x][i+1]][0]);\n\t\t\t\tans += getSum(i+1,r);\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tif (l == 0 && r == sz(child[x])-1) {\n\t\t\tF0R(q,2) {\n\t\t\t\tans[c][q] = INF;\n\t\t\t\tif (i > l) ckmin(ans[c][q],endLef(ex[c][q])+ans[x][0]);\n\t\t\t\tif (i < r) ckmin(ans[c][q],endRig(ex[c][q])+ans[x][1]);\n\t\t\t}\n\t\t} else {\n\t\t\tans[c][0] = min(endLef(ex[c][0]),endRig(ex[c][0]));\n\t\t\tans[c][1] = min(endLef(ex[c][1]),endRig(ex[c][1]));\n\t\t}\n\t\tdfs(c);\n\t}\n}\n\nvoid go() {\n\tans.rsz(N); ex.rsz(N);\n\t// dbg(\"GOING\");\n\tdfsEx(root);\n\t// dbg(\"DONEEX\",ex[root]); exit(0);\n\tdfs(root);\n\tF0R(i,N) dbg(i,ex[i],child[i],rloc[i],ans[i]);\n}\n\n\nvoid genAns() {\n\tvl ret(n);\n\tret.rsz(n);\n\tF0R(i,n) ret[i] = ans[loc[i]][0];\n\tvl oops(n);\n\tF0R(i,n) oops[v[i].s] = i;\n\tF0R(i,n) ps(ret[oops[i]]);\n}\n\n\nint main() {\n\tsetIO(); re(n);\n\tv.rsz(n);\n\tint cnt = 0;\n\tvi y;\n\ttrav(t,v) {\n\t\tre(t.f); t.s = cnt++;\n\t\ty.pb(t.f.s);\n\t}\n\tremDup(y);\n\tdbg(y);\n\tsort(all(v));\n\ttrav(t,v) p.pb(lb(all(y),t.f.s)-begin(y));\n\tsolve();\n\tgo();\n\tgenAns();\n\t// ps(p);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 200000;\nconst int MAXNODE = MAXN + MAXN - 1;\nstruct P { int x, y; };\nstruct Node { deque<int> lst; vector<int> vec; int kind; int lidx, ridx; };\n\nint n;\nP p[MAXN];\nll ans[MAXN];\n\nint x2idx[MAXN];\nint xx[MAXN], nxx;\nint yy[MAXN], nyy;\n\nint lx[MAXN], hx[MAXN], ly[MAXN], hy[MAXN];\nint par[MAXN], sz[MAXN], leader[MAXN];\n\nNode node[MAXNODE]; int nnode;\nbool contained[MAXNODE];\n\nll outsidecost[MAXNODE][2];\n\nint leftmost[MAXNODE], rightmost[MAXNODE]; \nll totalcostleft[MAXNODE][2], totalcostright[MAXNODE][2];\n\n\n\nint dist(int a, int b) { if (a == b) return 0; return abs(xx[p[a].x] - xx[p[b].x]) + abs(yy[p[a].y] - yy[p[b].y]) - 1; }\n\nvoid dfsinit(int at) {\n\tvector<int> cur = node[at].vec;\n\tint len = SZ(cur);\n\tif (at < n) { assert(len == 0); node[at].lidx = node[at].ridx = x2idx[at]; return; }\n\tassert(len >= 2);\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tdfsinit(to);\n\t\tif (i == 0) node[at].lidx = node[to].lidx;\n\t\tif (i == len - 1) node[at].ridx = node[to].ridx;\n\t}\n}\nvoid dfscalc(int at) {\n\tvector<int> cur = node[at].vec;\n\tint len = SZ(cur);\n\tif (len == 0) return;\n\t//printf(\"dfs(%d) (%lld/%lld)\\n\", at, outsidecost[at][0], outsidecost[at][1]);\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tif (i - 1 < 0) { leftmost[i] = i, totalcostleft[i][0] = 0, totalcostleft[i][1] = 0; continue; }\n\t\tint pto = cur[i - 1];\n\t\tif (node[pto].kind != 0) { leftmost[i] = i, totalcostleft[i][0] = 0, totalcostleft[i][1] = 0; continue; }\n\t\tleftmost[i] = leftmost[i - 1]; REP(side, 2) totalcostleft[i][side] = dist(side == 0 ? node[to].lidx : node[to].ridx, node[pto].ridx) + totalcostleft[i - 1][1];\n\t}\n\tfor (int i = len - 1; i >= 0; --i) {\n\t\tint to = cur[i];\n\t\tif (i + 1 >= len) { rightmost[i] = i, totalcostright[i][0] = 0, totalcostright[i][1] = 0; continue; }\n\t\tint pto = cur[i + 1];\n\t\tif (node[pto].kind != 0) { rightmost[i] = i, totalcostright[i][0] = 0, totalcostright[i][1] = 0; continue; }\n\t\trightmost[i] = rightmost[i + 1]; REP(side, 2) totalcostright[i][side] = dist(side == 0 ? node[to].lidx : node[to].ridx, node[pto].lidx) + totalcostright[i + 1][0];\n\t}\n\t//REP(i, len) printf(\"%d: leftmost=%d rightmost=%d totalcostleft=%lld/%lld totalcostright=%lld/%lld\\n\", i, leftmost[i], rightmost[i], totalcostleft[i][0], totalcostleft[i][1], totalcostright[i][0], totalcostright[i][1]);\n\tREP(i, len) {\n\t\tint to = cur[i]; bool canall = leftmost[i] == 0 && rightmost[i] == len - 1;\n\t\tREP(side,2) {\n\t\t\tint aidx = i == rightmost[i] ? side == 0 ? node[cur[i]].lidx : node[cur[i]].ridx : node[cur[rightmost[i]]].ridx;\n\t\t\tint bidx = i == leftmost[i] ? side == 0 ? node[cur[i]].lidx : node[cur[i]].ridx : node[cur[leftmost[i]]].lidx;\n\t\t\tll a = totalcostright[i][side] + (i == leftmost[i] ? 0 : dist(aidx, node[cur[i - 1]].ridx) + totalcostleft[i - 1][1]) + (canall ? outsidecost[at][i != leftmost[i] ? 0 : 1] : 0);\n\t\t\tll b = totalcostleft[i][side] + (i == rightmost[i] ? 0 : dist(bidx, node[cur[i + 1]].lidx) + totalcostright[i + 1][0]) + (canall ? outsidecost[at][i != rightmost[i] ? 1 : 0] : 0);\n\t\t\t//printf(\"\\t%lld vs %lld\\n\", a, b);\n\t\t\toutsidecost[to][side] = min(a, b);\n\t\t}\n\t}\n\tREP(i, len) {\n\t\tint to = cur[i];\n\t\tdfscalc(to);\n\t}\n}\n\nint makenode(int a, int b, int kind) {\n\tint ret = nnode++;\n\tnode[ret].lst.clear(); node[ret].lst.PB(a); node[ret].lst.PB(b); node[ret].kind = kind;\n\treturn ret;\n}\n\nint merge(int a, int b, int kind) {\n\tif (node[a].kind == kind && node[b].kind == kind) {\n\t\tif (SZ(node[a].lst) >= SZ(node[b].lst)) {\n\t\t\twhile (SZ(node[b].lst) != 0) { int x = node[b].lst.front(); node[b].lst.pop_front(); node[a].lst.push_back(x); }\n\t\t\treturn a;\n\t\t} else {\n\t\t\twhile (SZ(node[a].lst) != 0) { int x = node[a].lst.back(); node[a].lst.pop_back(); node[b].lst.push_front(x); }\n\t\t\treturn b;\n\t\t}\n\t}\n\tif (node[a].kind == kind) {\n\t\tnode[a].lst.push_back(b);\n\t\treturn a;\n\t}\n\tif (node[b].kind == kind) {\n\t\tnode[b].lst.push_front(a);\n\t\treturn b;\n\t}\n\treturn makenode(a, b, kind);\n}\n\nint uffind(int x) {\n\tif (par[x] == x) return par[x];\n\treturn par[x] = uffind(par[x]);\n}\nvoid ufunite(int a, int b, int kind) {\n\t//printf(\"uniting %d and %d\\n\", a, b);\n\ta = uffind(a);\n\tb = uffind(b);\n\tint oa = a, ob = b;\n\tassert(a != b);\n\tif (sz[a] < sz[b]) swap(a, b);\n\tpar[b] = a;\n\tsz[a] += sz[b];\n\tlx[a] = min(lx[a], lx[b]);\n\thx[a] = max(hx[a], hx[b]);\n\tly[a] = min(ly[a], ly[b]);\n\thy[a] = max(hy[a], hy[b]);\n\tleader[a] = merge(leader[oa], leader[ob], kind);\n}\n\nvoid solve() {\n\tnxx = 0; REP(i, n) xx[nxx++] = p[i].x; sort(xx, xx + nxx); nxx = unique(xx, xx + nxx) - xx; assert(nxx == n); REP(i, n) p[i].x = lower_bound(xx, xx + nxx, p[i].x) - xx;\n\tnyy = 0; REP(i, n) yy[nyy++] = p[i].y; sort(yy, yy + nyy); nyy = unique(yy, yy + nyy) - yy; assert(nyy == n); REP(i, n) p[i].y = lower_bound(yy, yy + nyy, p[i].y) - yy;\n\n\tnnode = n;\n\tREP(i, n) {\n\t\tint x = p[i].x, y = p[i].y;\n\t\tx2idx[x] = i;\n\t\tnode[x].lst.clear(); node[x].kind = 0;\n\t\tpar[x] = x, sz[x] = 1, lx[x] = hx[x] = x, ly[x] = hy[x] = y, leader[x] = x;\n\t}\n\tREP(i, n) {\n\t\tint b = uffind(i);\n\t\twhile (true) {\n\t\t\tb = uffind(b);\n\t\t\tif (lx[b] - 1 >= 0) {\n\t\t\t\tint a = uffind(lx[b] - 1);\n\t\t\t\tassert(hx[a] == lx[b] - 1);\n\t\t\t\tif (hy[a] == ly[b] - 1) {\n\t\t\t\t\tufunite(a, b, +1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ly[a] == hy[b] + 1) {\n\t\t\t\t\tufunite(a, b, -1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hx[b] + 1 < n) {\n\t\t\t\tint c = uffind(hx[b] + 1);\n\t\t\t\tassert(lx[c] == hx[b] + 1);\n\t\t\t\tif (hy[c] == ly[b] - 1) {\n\t\t\t\t\tufunite(b, c, -1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if(ly[c]==hy[b]+1) {\n\t\t\t\t\tufunite(b, c, +1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tREP(i, nnode) { node[i].vec.clear(); while (SZ(node[i].lst) > 0) { int x = node[i].lst.front(); node[i].lst.pop_front(); node[i].vec.PB(x); } }\n\tREP(i, nnode) contained[i] = false;\n\tREP(i, nnode) REPSZ(j, node[i].vec) { int x = node[i].vec[j]; contained[x] = true; }\n\t//FOR(i, n, nnode) { printf(\"%d:\", i); REPSZ(j, node[i].vec) printf(\" %d\", node[i].vec[j]); puts(\"\"); }\n\tREP(i, nnode) if (!contained[i]) { outsidecost[i][0] = outsidecost[i][1] = 0; dfsinit(i); dfscalc(i); }\n\tREP(i, n) ans[x2idx[i]] = outsidecost[i][0];\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tREP(i, n) scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tsolve();\n\tREP(i, n) printf(\"%lld\\n\", ans[i]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\ntypedef long long ll;\n#define N 200020\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nstruct Rook{\n\tint x,y,id;\n\tbool operator <(const Rook b)const{\n\t\treturn x<b.x;\n\t}\n}a[N];\nint n;\nvector<int> ys;\npair<ll,ll> ans[N];\n\ninline int Abs(int x){\n\treturn x>=0?x:-x;\n}\ninline int Dis(int i,int j){\n\treturn Abs(a[i].x-a[j].x)+Abs(a[i].y-a[j].y);\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].id=i;\n\t\ta[i].x=read(),a[i].y=read();\n\t\tys.push_back(a[i].y);\n\t}\n\tsort(a+1,a+n+1);\n\tys.push_back(-inf),ys.push_back(inf);\n\tsort(ys.begin(),ys.end());\n\tmemset(ans,-1,sizeof(ans));\n\tfor(int S=1;S<=n;++S){\n\t\tif(~ans[a[S].id].first)continue;\n\t\tint by=lower_bound(ys.begin(),ys.end(),a[S].y)-ys.begin();\n\t\tint ly=by-1,ry=by+1,L=S,R=S;\n\t\tint las=-1;\n\t\tbool ok;\n\t\tvector<pair<int,int> > it;\n\t\tdo{\n\t\t\tok=false;\n\t\t\tfor(int i:{L-1,R+1}){\n\t\t\t\tif(i<1||i>n)continue;\n\t\t\t\tbool pre=ys[ly]==a[i].y,suf=ys[ry]==a[i].y;\n\t\t\t\tif(pre||suf){\n\t\t\t\t\tint dir=(pre==(i==L-1));\n\t\t\t\t\tif(las^dir){\n\t\t\t\t\t\tif(~pre)it.emplace_back(L,R);\n\t\t\t\t\t\tlas=dir;\n\t\t\t\t\t}\n\t\t\t\t\tif(pre)--ly;else ++ry;\n\t\t\t\t\tif(i==L-1)--L;else ++R;\n\t\t\t\t\tok=true;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ok);\n\t\tif(it.empty()||it.back()!=make_pair(L,R)){\n\t\t\tit.emplace_back(L,R);\n\t\t}\n\t\tstatic ll dp[N][2];\n\t\tint m=it.size();\n\t\tdp[m-1][0]=dp[m-1][1]=0;\n\t\tfor(int u=m-1;u>=1;--u){\n\t\t\tint L1=it[u].first,R1=it[u].second;\n\t\t\tint L2=it[u-1].first,R2=it[u-1].second;\n\t\t\tdp[u-1][0]=min(dp[u][0]+((R1==R2)?Dis(L1,L2):Dis(L1,R1)+Dis(R1,L2)),dp[u][1]+Dis(R1,L1)+Dis(L1,L2));\n\t\t\tdp[u-1][1]=min(dp[u][1]+((L1==L2)?Dis(R1,R2):Dis(R1,L1)+Dis(L1,R2)),dp[u][0]+Dis(L1,R1)+Dis(R1,R2));\n\t\t}\n\t\tint eL=it[0].first,eR=it[0].second;\n\t\tfor(int i=eL;i<=eR;++i){\n\t\t\tans[a[i].id]=make_pair(R-L,min(dp[0][0]+Dis(eL,eR)+Dis(eR,i),dp[0][1]+Dis(eR,eL)+Dis(eL,i)));\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tprintf(\"%lld\\n\",ans[i].second-ans[i].first);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n\tint pl,pr,vl,vr,type;\n\tvector<int> sons;\n} a[404040];\n\nstruct Point {\n\tint x,y,tag;\n}point[202020];\n\nint n,tot,x[202020],y[202020],p[202020],rkx[202020],rky[202020];\nlong long ans[202020],dp[404040][2];\ninline int dist(int a, int b) {\n\treturn abs(x[p[a]]-x[p[b]])+abs(y[p[a]]-y[p[b]]);\n}\n\nint l[202020],r[202020];\n\nvoid work(int pos) {\n\t//cout << pos << endl;\n\tif (pos <= n) {\n\t\tans[p[pos]] = dp[pos][0];\n\t\treturn;\n\t}\n\tvector <int> &s = a[pos].sons;\n\tfor (int i = 0, last = a[pos].pl;i < s.size(); i++) {\n\t\tl[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pr + 1;\n\t}\n\tfor (int i = s.size() - 1, last = a[pos].pr; i >= 0; i--) {\n\t\tr[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pl - 1;\n\t}\n\tfor (int i = 0;i < s.size(); i++) {\n\t\tint dest = s[i], pl = l[i], pr = r[i];\n\t\t\n\t\tif (pl == a[dest].pl && pr == a[dest].pr) \n\t\t\tdp[dest][0] = dp[dest][1] = 0;\n\t\t\n\t\telse if (pl == a[dest].pl) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr) + dp[pos][1];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr) + dp[pos][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr);\n\t\t\t}\n\t\t} else if (pr == a[dest].pr) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl) + dp[pos][0];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl) + dp[pos][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = min(dp[pos][0] + dist(a[dest].pl, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dp[pos][0] + dist(a[dest].pr, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = min(dist(a[dest].pl, pr) + dist(pl, pr), dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dist(a[dest].pr, pr) + dist(pl, pr), dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t}\n\t\t}\n\t\tdp[dest][0] -= a[dest].pl - pl + pr - a[dest].pr;\n\t\tdp[dest][1] -= a[dest].pl - pl + pr - a[dest].pr;\n\t}\n\tfor (int i = 0;i < s.size(); i++)\n\t\twork(s[i]);\n}\ninline bool chk(Node &A,Node &B) {\n\treturn max(A.vr,B.vr)-min(A.vl,B.vl) == max(A.pr,B.pr)-min(A.pl,B.pl);\n}\ninline int join(int x, int y) {\n\tif (a[x].vl < a[y].vl) {\n\t\ta[++tot].type = 1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[x].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[y].vr;\n\t} \n\telse {\t\t\n\t\ta[++tot].type = -1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[y].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[x].vr;\n\t}\n\ta[tot].sons.push_back(x);\n\ta[tot].sons.push_back(y);\n\treturn tot;\n}\nint s[202020];\ninline void buildTree() {\n\tfor (int i = 1;i <= n; i++) {\n\t\ta[++tot].type = 0;\n\t\ta[tot].pl = a[tot].pr = i;\n\t\ta[tot].vl = a[tot].vr = rky[p[i]];\n\t}\n\tint top = 0;\n\tfor (int i = 1;i <= n; i++) {\n\t\tbool fl = 1;\n\t\ts[++top] = i;\n\t\twhile (fl) {\n\t\t\tfl = 0;\n\t\t\tif (top >= 2 && a[s[top - 1]].type == 1 && a[s[top - 1]].vr + 1 == a[s[top]].vl) {\n\t\t\t\ta[s[top - 1]].vr = a[s[top]].vr;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && a[s[top - 1]].type == -1 && a[s[top - 1]].vl - 1 == a[s[top]].vr) {\n\t\t\t\ta[s[top - 1]].vl = a[s[top]].vl;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && chk(a[s[top]],a[s[top-1]])) {\n\t\t\t\tint x,y;\n\t\t\t\ty = s[top--];\n\t\t\t\tx = s[top--];\n\t\t\t\ts[++top] = join(x, y);\n\t\t\t\tfl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= top; i++)\n\t\twork(s[i]);\n}\nbool cmpx(Point A,Point B) {\n\treturn A.x < B.x;\n}\nbool cmpy(Point A,Point B) {\n\treturn A.y < B.y;\n}\nint main() {\n\tscanf(\"%d\",&n); \n\tfor (int i = 1;i <= n; i++) {\n\t\tscanf(\"%d%d\",&point[i].x,&point[i].y),point[i].tag = i;\n\t\tx[i] = point[i].x;\n\t\ty[i] = point[i].y;\n\t}\n\tsort(point+1,point+n+1,cmpx);\n\tfor (int i = 1;i <= n; i++)\n\t\trkx[point[i].tag] = i;\n\t\t\n\tsort(point+1,point+n+1,cmpy);\n\tfor (int i = 1;i <= n; i++)\n\t\trky[point[i].tag] = i;\n\t\t\n\tfor (int i = 1;i <= n; i++)\n\t\tp[rkx[i]] = i;\n\t\t\n\tbuildTree();\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000;\n\nint n,x[N+9],y[N+9];\nint idx[N+9],idy[N+9];\n\nbool cmp0(const int &a,const int &b){return x[a]<x[b];}\nbool cmp1(const int &a,const int &b){return y[a]<y[b];}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n\tidx[i]=i;idy[i]=i;\n  }\n}\n\nint p[N+9],q[N+9];\n// p[i] -> 将点离散化后 x=i , y=p[i]\n\nvoid Get_p(){\n  sort(idx+1,idx+n+1,cmp0);\n  sort(idy+1,idy+n+1,cmp1);\n  for (int i=1;i<=n;++i) q[idy[i]]=i;\n  for (int i=1;i<=n;++i) p[i]=q[idx[i]];\n}\n\nint bam[N+9],dan[N+9];\n\n// bam[i] -> i 所属连续段的开头\n// dan[i] -> i 所属连续短的结尾\n\nvoid Get_bam(){\n  bam[1]=1;dan[n]=n;\n  for (int i=2;i<=n;++i) bam[i]=abs(p[i]-p[i-1])==1?bam[i-1]:i;\n  for (int i=n-1;i>=1;--i) dan[i]=abs(p[i]-p[i+1])==1?dan[i+1]:i;\n}\n\nint Get_dis(int a,int b){\n  a=idx[a];b=idx[b];\n  return abs(x[a]-x[b])+abs(y[a]-y[b]);\n}\n\nmap<int,LL>dp[2][N+9];\n\nLL Dfs_ans(int l,int r,bool gg,int mn,int mx){\n  map<int,LL>::iterator it=dp[gg][l].find(r);\n  if (it!=dp[gg][l].end()) return it->second;\n  vector<LL>opt;\n  if (l>1&&(p[l-1]==mn-1||p[l-1]==mx+1)){\n\tLL tmp=Dfs_ans(bam[l-1],r,0,min(mn,p[bam[l-1]]),max(mx,p[bam[l-1]]));\n\ttmp+=Get_dis(bam[l-1],gg?r:l);\n\topt.push_back(tmp);\n  }\n  if (r<n&&(p[r+1]==mn-1||p[r+1]==mx+1)){\n\tLL tmp=Dfs_ans(l,dan[r+1],1,min(mn,p[dan[r+1]]),max(mx,p[dan[r+1]]));\n\ttmp+=Get_dis(gg?r:l,dan[r+1]);\n\topt.push_back(tmp);\n  }\n  LL res=l-r;\n  if (opt.size()>=1){\n\tres=opt.front();\n\tif (opt.size()>=2) res=min(res,opt[1]);\n  }\n  return dp[gg][l][r]=res;\n}\n\nLL ans[N+9];\n\nvoid Get_ans(){\n  for (int i=1;i<=n;++i) ans[idx[i]]=Dfs_ans(i,i,0,p[i],p[i]);\n}\n\nvoid work(){\n  Get_p();\n  Get_bam();\n  Get_ans();\n}\n\nvoid outo(){\n  for (int i=1;i<=n;++i)\n\tprintf(\"%lld\\n\",ans[i]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <vector>\n#include <algorithm>\n#include <functional> \nusing namespace std;\n\nstruct Rook {\n    int x, y, id;\n    bool operator <(const Rook& other) const {\n        return x < other.x;\n    }\n};\n\nlong long hack;\n\ntemplate<class C>\nvoid min_self (C &a, C &&b) {\n    a = min(a, b);\n};\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    vector<Rook> rooks(n);\n    for(int i = 0; i < n; ++i) {\n        rooks[i].id = i;\n        scanf(\"%d%d\", &rooks[i].x, &rooks[i].y);\n    }\n    sort(rooks.begin(), rooks.end());\n    vector<int> ys{INT_MIN, INT_MAX}; // two sentinels for convenience\n    for(int i = 0; i < n; ++i) {\n        ys.push_back(rooks[i].y);\n    }\n    sort(ys.begin(), ys.end());\n    vector< pair<long long, long long> > answer(n, {-1, -1});\n    for(int start = 0; start < n; ++start) {\n        if(answer[rooks[start].id].first != -1) {\n            continue;\n        }\n\n        int start_y = lower_bound(ys.begin(), ys.end(), rooks[start].y) - ys.begin();\n        int y1 = start_y - 1, y2 = start_y + 1;\n\n        int L = start, R = start;\n        int prev_dir = -1;\n        vector< pair<int, int> > intervals;\n        while(true) {\n            bool found = false;\n            for(int i : {L - 1, R + 1}) {\n                if(0 <= i && i < n) {\n                    bool prev_y = (ys[y1] == rooks[i].y);\n                    bool next_y = (ys[y2] == rooks[i].y);\n                    if(prev_y || next_y) {\n                        int direction = (prev_y == (i == L - 1));\n                        if(prev_dir == -1) {\n                            prev_dir = direction;\n                        }\n                        if(prev_dir != direction) {\n                            intervals.emplace_back(L, R);\n                            prev_dir = direction;\n                        }\n                        prev_y ? y1-- : y2++;\n                        i == L-1 ? L-- : R++;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if(!found) {\n                break;\n            }\n        }\n        if(intervals.empty() || intervals.back() != make_pair(L, R)) {\n            intervals.emplace_back(L, R);\n        }\n        const int s = intervals.size();\n\n        const long long INF = 1e18L + 5;\n        \n        auto f = [&] (int i, int j) {\n            return abs(rooks[i].x - rooks[j].x) + abs(rooks[i].y - rooks[j].y);\n        };\n        \n        vector< vector<long long> > dp(s, vector<long long>(2, INF));\n        dp[s-1][0] = dp[s-1][1] = 0;\n        for(int who = s - 1; who >= 1; --who) {\n            int L1 = intervals[who].first;\n            int L2 = intervals[who-1].first;\n            int R1 = intervals[who-1].second;\n            int R2 = intervals[who].second;\n            hack += (long long) (L2 - L1) * (R2 - R1);\n            min_self(dp[who-1][0], dp[who][0] + (R1 == R2 ? f(L1, L2) : f(L1, R2) + f(R2, L2)));\n            min_self(dp[who-1][1], dp[who][0] + f(L1, R2) + f(R2, R1));\n            min_self(dp[who-1][0], dp[who][1] + f(R2, L1) + f(L1, L2));\n            min_self(dp[who-1][1], dp[who][1] + (L1 == L2 ? f(R1, R2) : f(R2, L1) + f(L1, R1)));\n        }\n        int low = intervals[0].first, high = intervals[0].second;\n        for(int i = low; i <= high; ++i) {\n            answer[rooks[i].id] = {\n                R - L,\n                min(dp[0][0] + f(low, high) + f(high, i), dp[0][1] + f(high, low) + f(low, i))\n            };\n        }\n    }\n    for(auto p : answer) {\n        printf(\"%lld\\n\", p.second - p.first);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\n\nstruct point {\n    int x,y,id;\n};\npoint p[maxn];\nint ny[maxn],idy[maxn];\n\nint n;\n\nint l[maxn],r[maxn];\n\nint sx[maxn];\nint fa[maxn];\nvector<int>ed[maxn]; int rd[maxn];\n\nll dp[maxn][2][2];\n\nint rk[maxn],tp;\nll ans[maxn];\n\ninline void get_rk()\n{\n    queue<int>q;\n    REP(i,1,n)if(fa[i]==i && !rd[i])q.push(i);\n    while(!q.empty())\n    {\n\tint u=q.front();q.pop();\n\trk[++tp]=u;\n\tfor(int v:ed[u])\n\t    if(!(--rd[v]))\n\t\tq.push(v);\n    }\n}\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n)p[i]=(point){read(),read(),i};\n    sort(p+1,p+n+1,[](point a,point b){ return a.x<b.x;});\n    REP(i,1,n)sx[i]=p[i].y; sort(sx+1,sx+n+1);\n    REP(i,1,n)ny[i]=lower_bound(sx+1,sx+n+1,p[i].y)-sx,idy[ny[i]]=i;\n    REP(i,1,n)fa[i]=i,l[i]=i,r[i]=i;\n    REP(i,1,n-1)\n    {\n\tif(abs(ny[i]-ny[i+1])==1)fa[i+1]=fa[i],r[fa[i+1]]=i+1;\n\telse {\n\t    int x=ny[i]+(ny[i]<ny[i+1]?1:-1);\n\t    if(idy[x]<i) ed[i+1].push_back(fa[i]),rd[fa[i]]++;\n\t    else ed[fa[i]].push_back(i+1),rd[i+1]++;\n\t}\n    }\n    DREP(i,n,1)l[i]=l[fa[i]],r[i]=r[fa[i]];\n    get_rk();\n}\n\ninline int Dis(int i,int j){ return abs(p[j].x-p[i].x)+abs(p[j].y-p[i].y);}\n\ninline void doing()\n{\n    REP(th,1,tp)\n    {\n\tint u=rk[th];\n\tint reml=l[u],remr=r[u];\n\tint &lx=l[u],&rx=r[u];\n\t\n\tdp[u][0][1]=l[u]==r[u]?0:Dis(l[u],r[u]);\n\tdp[u][1][0]=l[u]==r[u]?0:Dis(r[u],l[u]);\n\tdp[u][0][0]=dp[u][1][1]=inf;\n\t\n\tint ly=min(ny[lx],ny[rx]),ry=max(ny[lx],ny[rx]);\n\tint L,R;\n\tdo{\n\t    int le=lx>1 && (ly-1==ny[lx-1] || ny[lx-1]==ry+1),re=rx<n && (ly-1==ny[rx+1] || ry+1==ny[rx+1]);\n\t    L=fa[lx-1],R=rx+1;\n\t    if(!le && !re)break;\n\t    if(le && re)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]+Dis(r[rx+1],lx-1)+dp[L][1][0]);\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]+Dis(l[lx-1],rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tlx=l[lx-1]; rx=r[rx+1];\n\t    }\n\t    else if(le)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tlx=l[lx-1];\n\t    }else\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\trx=r[rx+1];\n\t    \n\t    }\n\t}while(1);\n\tREP(j,reml,remr)\n\t{\n\t    if(j==reml)ans[p[j].id]=min(dp[u][0][0],dp[u][0][1]);\n\t    else if(j==remr)ans[p[j].id]=min(dp[u][1][0],dp[u][1][1]);\n\t    else {\n\t\tans[p[j].id]=inf;\n\t\tREP(op,0,1)chkmin(ans[p[j].id],min(dp[u][0][op]+Dis(j,reml),dp[u][1][op]+Dis(j,remr)));\n\t    }\n\t    ans[p[j].id]-=rx-lx;\n\t}\n    }\n    REP(i,1,n)printf(\"%lld\\n\",ans[i]);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nstruct PermutationTree{\n\n\tstatic const int N = 400007;\n\t#define ll long long\n\t#define ii pair<ll,ll>\n\t#define iii pair<ii,ll>\n\t#define fi first\n\t#define se second\n\n\t#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n\n\n\tstruct node{\n\t\tint s,e,m;\n\t\tll val=0,lazy=0;\n\t\tnode *l,*r;\n\t\t\n\t\tnode (int _s,int _e){\n\t\t\ts=_s,e=_e,m=s+e>>1;\n\t\t\t\n\t\t\tif (s!=e){\n\t\t\t\tl=new node(s,m);\n\t\t\t\tr=new node(m+1,e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid propo(){\n\t\t\tif (lazy){\n\t\t\t\tval+=lazy;\n\t\t\t\tif (s!=e){\n\t\t\t\t\tl->lazy+=lazy;\n\t\t\t\t\tr->lazy+=lazy;\n\t\t\t\t}\n\t\t\t\tlazy=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid update(int i,int j,ll k){\n\t\t\tif (s==i && e==j) lazy+=k;\n\t\t\telse{\n\t\t\t\tif (j<=m) l->update(i,j,k);\n\t\t\t\telse if (m<i) r->update(i,j,k);\n\t\t\t\telse l->update(i,m,k),r->update(m+1,j,k);\n\t\t\t\t\n\t\t\t\tl->propo(),r->propo();\n\t\t\t\tval=min(l->val,r->val);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll query(int i,int j){\n\t\t\tpropo();\n\t\t\t\n\t\t\tif (s==i && e==j) return val;\n\t\t\telse if (j<=m) return l->query(i,j);\n\t\t\telse if (m<i) return r->query(i,j);\n\t\t\telse return min(l->query(i,m),r->query(m+1,j));\n\t\t}\n\t};\n\n\tint n,q;\n\tint arr[N];\n\tii range[N];\n\tii span[N];\n\tvector<int> children[N];\n\tint parent[N];\n\tint typ[N];\n\tint idx; //new index to assign to nodes\n\n\tii get_range(ii i,ii j){\n\t\treturn ii(min(i.fi,j.fi),max(i.se,j.se));\n\t}\n\n\tvoid add_edge(int u,int v){ //u is parent of v\n\t\tparent[v]=u;\n\t\tchildren[u].push_back(v);\n\t}\n\n\tbool adj(int i,int j){\n\t\treturn range[i].se==range[j].fi-1;\n\t}\n\n\tint length(int i){\n\t\treturn range[i].se-range[i].fi+1;\n\t}\n\n\tvoid build(vector<int> v){\n\t\tn = v.size();\n\t\tfor (int i = 0; i < n; ++i) arr[i] = v[i];\n\t\tidx=n;\n\t\tmemset(parent,-1,sizeof(parent));\n\t\t\n\t\tnode *root=new node(0,N);\n\t\tvector<int> mx={-1},mn={-1}; //stacks for max and min\n\t\t\n\t\tvector<int> nodes; //stack of cut and join nodes\n\t\t\n\t\trep(x,0,n){\n\t\t\t//update Q values\n\t\t\twhile (mx.back()!=-1 && arr[mx.back()]<arr[x]){\n\t\t\t\tint temp=mx.back();\n\t\t\t\tmx.pop_back();\n\t\t\t\troot->update(mx.back()+1,temp,arr[x]-arr[temp]);\n\t\t\t}\n\t\t\tmx.push_back(x);\n\t\t\t\n\t\t\twhile (mn.back()!=-1 && arr[mn.back()]>arr[x]){\n\t\t\t\tint temp=mn.back();\n\t\t\t\tmn.pop_back();\n\t\t\t\troot->update(mn.back()+1,temp,arr[temp]-arr[x]);\n\t\t\t}\n\t\t\tmn.push_back(x);\n\t\t\t\n\t\t\t//handle stack updates\n\t\t\trange[x]=ii(arr[x],arr[x]);\n\t\t\tspan[x]=ii(x,x);\n\t\t\tint curr=x;\n\t\t\t\n\t\t\twhile (true){\n\t\t\t\tif (!nodes.empty() && (adj(nodes.back(),curr) || adj(curr,nodes.back()))){\n\t\t\t\t\tif ((adj(nodes.back(),curr) && typ[nodes.back()]==1)||\n\t\t\t\t\t  (adj(curr,nodes.back()) && typ[nodes.back()]==2)){\n\t\t\t\t\t\tadd_edge(nodes.back(),curr);\n\t\t\t\t\t\t\n\t\t\t\t\t\trange[nodes.back()]=get_range(range[nodes.back()],range[curr]);\n\t\t\t\t\t\tspan[nodes.back()]=get_range(span[nodes.back()],span[curr]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcurr=nodes.back();\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse{ //make a new join node\n\t\t\t\t\t\ttyp[idx]=(adj(nodes.back(),curr) ? 1:2);\n\t\t\t\t\t\tadd_edge(idx,nodes.back());\n\t\t\t\t\t\tadd_edge(idx,curr);\n\t\t\t\t\t\t\n\t\t\t\t\t\trange[idx]=get_range(range[nodes.back()],range[curr]);\n\t\t\t\t\t\tspan[idx]=get_range(span[nodes.back()],span[curr]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t\tcurr=idx++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (x-(length(curr)-1) && root->query(0,x-length(curr))==0){\n\t\t\t\t\tint len=length(curr);\n\t\t\t\t\tii r=range[curr];\n\t\t\t\t\tii s=span[curr];\n\t\t\t\t\t\n\t\t\t\t\tadd_edge(idx,curr);\n\t\t\t\t\t\n\t\t\t\t\tdo{\n\t\t\t\t\t\tlen+=length(nodes.back());\n\t\t\t\t\t\tr=get_range(r,range[nodes.back()]);\n\t\t\t\t\t\ts=get_range(s,span[nodes.back()]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tadd_edge(idx,nodes.back());\n\t\t\t\t\t\t\n\t\t\t\t\t\tnodes.pop_back();\n\t\t\t\t\t} while (r.se-r.fi+1!=len);\n\t\t\t\t\t\n\t\t\t\t\treverse(all(children[idx]));\n\t\t\t\t\trange[idx]=r;\n\t\t\t\t\tspan[idx]=s;\n\t\t\t\t\tcurr=idx++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.push_back(curr);\n\t\t\troot->update(0,x,-1);\n\t\t}\n\t}\n\n\tpair<int, int> get_range(int x) {\n\t\treturn range[x];\n\t}\n\n\tpair<int, int> get_seg(int x) {\n\t\treturn span[x];\n\t}\n\n\tvector<int> get_sons(int x) {\n\t\treturn children[x];\n\t}\n\n\tbool if_cut(int x) {\n\t\tauto var = get_sons(x);\n\n\t\tvector<pair<int, int> > tet;\n\t\tfor (auto x : var) tet.pb(range[x]);\n\n\t\tauto ctet = tet;\n\t\tsort(all(tet));\n\n\t\tif (tet == ctet) return true;\n\t\treverse(all(tet));\n\t\tif (tet == ctet) return true;\n\t\treturn false;\n\n\t}\n\n\tint get_root() {\n\t\tint cur = 0;\n\t\twhile (parent[cur] != -1){\n\t\t\tcur = parent[cur];\n\t\t}\n\t\treturn cur;\n\t}\n\n\tint get_parent(int x) {\n\t\treturn parent[x];\n\t}\n\n};\n\nPermutationTree tree;\n\nvector<pair<int, int> > arr;\nmap<pair<int, int>, int> tet;\n\nvector<ll> ans;\n\nint get_dist(pair<int, int> a, pair<int, int> b) {\n\treturn abs(a.x-b.x) + abs(a.y-b.y);\n}\n\nvoid solve(int root, ll x, ll y) {\n\tauto res = tree.get_seg(root);\n\t//cout << res.x << \" \" << res.y << \" \" << x << \" \" << y << endl;\n\tif (res.x == res.y) {\n\t\tans[tet[arr[res.x]]] = min(x, y);\n\t\treturn;\n\t}\n\n\tauto children = tree.get_sons(root);\n\n\tif (!tree.if_cut(root)) {\n\t\tfor (auto x : children) {\n\t\t\tsolve(x, 0, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tint sz = children.size();\n\n\tvector<int> take_right(sz), take_left(sz);\n\tvector<int> cnt_left(sz), cnt_right(sz);\n\n\tfor (int i = 0; i < sz; ++i) {\n\t\tauto cur = tree.get_seg(children[i]);\n\t\tif (cur.x != cur.y) take_left[i] = 0, cnt_left[i] = 0;\n\t\telse {\n\t\t\ttake_left[i] = 1;\n\t\t\tcnt_left[i] = cur.y  - cur.x+1;\n\t\t\tif (i > 0) {\n\t\t\t\ttake_left[i] += take_left[i-1];\n\t\t\t\tcnt_left[i] += cnt_left[i-1];\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(all(children));\n\n\tfor (int i = 0; i < sz; ++i) {\n\t\tauto cur = tree.get_seg(children[i]);\n\t\tif (cur.x != cur.y) {\n\t\t\ttake_right[i] = 0;\n\t\t\tcnt_right[i] = 0;\n\t\t}\n\t\telse {\n\t\t\ttake_right[i] = 1;\n\t\t\tcnt_right[i] = cur.y  - cur.x+1;\n\t\t\tif (i > 0) {\n\t\t\t\ttake_right[i] += take_right[i-1];\n\t\t\t\tcnt_right[i] += cnt_right[i-1];\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(all(children));\n\treverse(all(take_right));\n\treverse(all(cnt_right));\n\n\t//cout << res.x << \" \" << res.y << \" \" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < children.size(); ++i) {\n\n\t\tint L = tree.get_seg(children[i]).x;\n\t\tint R = tree.get_seg(children[i]).y;\n\n\t\tll a = 1e18, b = 1e18;\n\n\t\tint tl = 0, tr = 0, cl = 0, cr = 0;\n\n\t\tif (i > 0) {\n\t\t\tcl = cnt_left[i-1];\n\t\t\ttl = take_left[i-1];\n\t\t}\n\t\tif (i + 1 < children.size()) {\n\t\t\tcr = cnt_right[i+1];\n\t\t\ttr = take_right[i+1];\n\t\t}\n\n\t\tll left_sign = 0, right_sign = 0;\n\t\tif (cr+cl+1 == children.size()) left_sign = x, right_sign = y;\n\n\t\tint e = L-tl, f = R+tr;\n\t\tif (cl==0) e = R;\n\t\tif (cr==0) f = L;\n\n\t\ta = min({a, right_sign + get_dist(arr[L], arr[L - tl]) + get_dist(arr[L-tl], arr[R+tr]) - tl - tr, left_sign + get_dist(arr[L], arr[f]) + get_dist(arr[L-tl], arr[f]) - tl - tr});\n\t\tb = min({b, right_sign + get_dist(arr[R], arr[e]) + get_dist(arr[e], arr[R+tr]) - tl - tr, left_sign + get_dist(arr[R], arr[R+tr]) + get_dist(arr[L-tl], arr[R+tr]) - tl - tr});\n\n\t\t//cout << a << \" \" << b << \" \" << L << \" \" << R << \" \" << tl << \" \" << tr << endl;\n\n\t\tsolve(children[i], a, b);\n\n\t}\n\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"K_input.txt\", \"r\", stdin);\n\t//freopen(\"K_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tans.assign(n, -1);\n\n\tvector<int> ys;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tys.pb(y);\n\t\tarr.pb(mp(x, y));\n\t\ttet[mp(x, y)] = i;\n\t}\n\n\tsort(all(arr));\n\tsort(all(ys));\n\n\tmap<int, int> tet;\n\tfor (int i = 0; i < ys.size(); ++i) tet[ys[i]] = i;\n\n\tvector<int> v(n);\n\n\tfor (int i =0; i < n; ++i) {\n\t\tv[i] = tet[arr[i].y];\n\t\t//cout << v[i] << \" \";\n\t}\n\n\ttree.build(v);\n\tint root = tree.get_root();\n\n\tsolve(root, 0, 0);\n\n\tfor (auto x : ans) {\n\t\tcout << x << '\\n';\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include  // Rooks, by Errichto\nusing namespace std;\n#define sim template < class c\n#define ris return  this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge range(c i, c j) { return rge{i, j}; }\nsim > auto dud(c x) -> decltype(cerr << x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge d) {\n  this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    this << \", \" + 2  (it == d.b) << it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #VA_ARGS \": \" << (VA_ARGS) << \"] \"\n// debug & operator << (debug & dd, P p) { dd << \"(\" << p.x << \", \" << p.y << \")\"; return dd; }\n\nstruct Rook {\n    int x, y, id;\n    bool operator <(const Rook& other) const {\n        return x < other.x;\n    }\n};\nlong long hack;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    assert(2 <= n && n <= 200  1000);\n    vector rooks(n);\n    for(int i = 0; i < n; ++i) {\n        rooks[i].id = i;\n        scanf(\"%d%d\", &rooks[i].x, &rooks[i].y);\n        assert(1 <= min(rooks[i].x, rooks[i].y) && max(rooks[i].x, rooks[i].y) <= 1000  1000);\n    }\n    sort(rooks.begin(), rooks.end());\n    vector ys{INT_MIN, INT_MAX}; // two sentinels for convenience\n    for(int i = 0; i < n; ++i) {\n        ys.push_back(rooks[i].y);\n    }\n    sort(ys.begin(), ys.end());\n    for(int i = 0; i < n - 1; ++i) {\n        assert(ys[i] != ys[i+1]);\n        assert(rooks[i].x != rooks[i+1].x);\n    }\n    vector> answer(n, {-1, -1});\n    for(int start = 0; start < n; ++start) {\n        if(answer[rooks[start].id].first != -1) {\n            continue;\n        }\n\n        int start_y = lower_bound(ys.begin(), ys.end(), rooks[start].y) - ys.begin();\n        int y1 = start_y - 1, y2 = start_y + 1;\n\n        int L = start, R = start;\n        int prev_dir = -1;\n        vector> intervals;\n        while(true) {\n            bool found = false;\n            for(int i : {L - 1, R + 1}) {\n                if(0 <= i && i < n) {\n                    bool prev_y = (ys[y1] == rooks[i].y);\n                    bool next_y = (ys[y2] == rooks[i].y);\n                    if(prev_y || next_y) {\n                        int direction = (prev_y == (i == L - 1)); // 0 or 1\n                        // debug() << imie(start) imie(i) imie(direction);\n                        if(prev_dir == -1) {\n                            prev_dir = direction;\n                        }\n                        if(prev_dir != direction) {\n                            intervals.emplace_back(L, R);\n                            prev_dir = direction;\n                        }\n                        prev_y ? y1-- : y2++;\n                        i == L-1 ? L-- : R++;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if(!found) {\n                break;\n            }\n        }\n        if(intervals.empty() || intervals.back() != make_pair(L, R)) {\n            intervals.emplace_back(L, R);\n        }\n        const int s = intervals.size();\n        debug() << imie(start) imie(intervals);\n\n        { // complexity check\n            static int sum_s = 0, sum_len = 0;\n            if(s > 1) sum_s += s;\n            assert(sum_s <= n);\n            sum_len += R - L + 1;\n            assert(sum_len <= 3  n); // N + out + 2  border    ('out' and 'border' are disjoint)\n            static vector basic(n), out(n), border(n);\n            pair i_basic = intervals[0], i_out = intervals[max(0,s-2)], i_border = intervals.back();\n            for(int i = i_border.first; i <= i_border.second; ++i) {\n                if(i_basic.first <= i && i <= i_basic.second) {\n                    assert(++basic[i] == 1);\n                }\n                else if(i_out.first <= i && i <= i_out.second) {\n                    assert(++out[i] == 1 && border[i] == 0);\n                }\n                else {\n                    assert(++border[i] <= 2 && out[i] == 0);\n                }\n            }\n        }\n\n        const long long INF = 1e18L + 5;\n        auto min_self = & {\n            a = min(a, b);\n        };\n        auto f = & { // manhattan distance between two rooks\n            return abs(rooks[i].x - rooks[j].x) + abs(rooks[i].y - rooks[j].y);\n        };\n        vector> dp(s, vector(2, INF));\n        // dp[i][0] is minimum number of REMAINING operations if we did interval i and we are at its left end\n        // dp[i][1] -- same but right end\n        dp[s-1][0] = dp[s-1][1] = 0;\n        for(int who = s - 1; who >= 1; --who) {\n            // [L1, [L2, R1], R2]\n            int L1 = intervals[who].first;\n            int L2 = intervals[who-1].first;\n            int R1 = intervals[who-1].second;\n            int R2 = intervals[who].second;\n            hack += (long long) (L2 - L1)  (R2 - R1);\n            min_self(dp[who-1][0], dp[who][0] + (R1 == R2 ? f(L1, L2) : f(L1, R2) + f(R2, L2)));\n            min_self(dp[who-1][1], dp[who][0] + f(L1, R2) + f(R2, R1));\n            min_self(dp[who-1][0], dp[who][1] + f(R2, L1) + f(L1, L2));\n            min_self(dp[who-1][1], dp[who][1] + (L1 == L2 ? f(R1, R2) : f(R2, L1) + f(L1, R1)));\n        }\n        int low = intervals[0].first, high = intervals[0].second;\n        for(int i = low; i <= high; ++i) {\n            assert(answer[rooks[i].id] == make_pair(-1, -1LL));\n            answer[rooks[i].id] = {\n                R - L,\n                min(dp[0][0] + f(low, high) + f(high, i), dp[0][1] + f(high, low) + f(low, i))\n            };\n        }\n    }\n    for(pair p : answer) {\n        // printf(\"%d %lld\\n\", p.first, p.second - p.first);\n        printf(\"%lld\\n\", p.second - p.first);\n    }\n    cerr << \"hack = \" << hack << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2e5+7;\n//const int MAXN = 1e3+7;\n\nint X[MAXN], Y[MAXN];\nint idX[MAXN];\n\nint p[MAXN], q[MAXN];\nint bam[MAXN], dan[MAXN];\nint n;\n\nint durotto(int i, int j) {\n    i = idX[i];\n    j = idX[j];\n    return abs(X[i]-X[j])+abs(Y[i]-Y[j]);\n}\n\nmap< int , LL >dp[2][MAXN];\nLL solve(int l, int r, bool side, int mn, int mx) {\n    auto it = dp[side][l].find(r);\n    if (it != dp[side][l].end()) return it->second;\n\n    vector< LL >options;\n    if (l > 1 && (p[l-1]==mn-1||p[l-1]==mx+1)) {\n        LL tmp = solve(l-1, r, false, min(mn, p[l-1]), max(mx, p[l-1]));\n        tmp += (side ? durotto(l-1, r) : durotto(l-1, l)) - 1;\n        options.push_back(tmp);\n    }\n    if (r < n && (p[r+1]==mn-1||p[r+1]==mx+1)) {\n        LL tmp = solve(l, r+1, true, min(mn, p[r+1]), max(mx, p[r+1]));\n        tmp += (side ? durotto(r, r+1) : durotto(l, r+1)) - 1;\n        options.push_back(tmp);\n    }\n    LL ans = 0;\n    if (options.size() >= 1) {\n        ans = options.front();\n        if (options.size() >= 2) {\n            ans = min(ans, options[1]);\n        }\n    }\n    return dp[side][l][r] = ans;\n}\n\nint ans[MAXN];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n;\n\n    vector< int >idY(n, 0);\n    for (int i = 1; i <= n; i++) {\n        cin >> X[i] >> Y[i];\n        idX[i] = i;\n        idY[i-1] = i;\n    }\n\n    sort(idX+1, idX+n+1, [&](int i, int j) {\n        return X[i] < X[j];\n    });\n    sort(idY.begin(), idY.end(), [&](int i, int j) {\n        return Y[i] < Y[j];\n    });\n    for (int i = 0; i < n; i++) {\n        q[idY[i]] = i+1;\n//        cout << \"q[\" << idY[i] << \"] = \" << i+1 << endl;\n    }\n    for (int i = 1; i <= n; i++) {\n        p[i] = q[idX[i]];\n//        cout << p[i+1] << \" \";\n    }\n//    cout << endl;\n\n    bam[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        bam[i] = i;\n        if (abs(p[i]-p[i-1])==1) bam[i] = bam[i-1];\n    }\n    dan[n] = n;\n    for (int i = n-1; i > 0; i--) {\n        dan[i] = i;\n        if (abs(p[i]-p[i-1])==1) dan[i] = dan[i+1];\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ans[idX[i]] = solve(i, i, false, p[i], p[i]);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        cout << ans[i] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=200000;\n\nint n,x[N+9],y[N+9];\nint ox[N+9],oy[N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i){\n\tscanf(\"%d%d\",&x[i],&y[i]);\n\tox[i]=x[i];oy[i]=y[i];\n  }\n}\n\nint id[N+9],p[N+9];\n\nvoid Get_id(){\n  sort(ox+1,ox+n+1);\n  sort(oy+1,oy+n+1);\n  for (int i=1;i<=n;++i){\n\tx[i]=lower_bound(ox+1,ox+n+1,x[i])-ox;\n\ty[i]=lower_bound(oy+1,oy+n+1,y[i])-oy;\n\tid[x[i]]=i;p[x[i]]=y[i];\n  }\n}\n\nint le[N+9],ri[N+9];\n\nvoid Get_le_ri(){\n  le[1]=1;ri[n]=n;\n  for (int i=2;i<=n;++i) le[i]=abs(p[i]-p[i-1])==1?le[i-1]:i;\n  for (int i=n-1;i>=1;--i) ri[i]=abs(p[i]-p[i+1])==1?ri[i+1]:i;\n}\n\nmap<int,LL>dp[2][N+9];\n\nint Get_dis(int a,int b){\n  a=id[a];b=id[b];\n  return abs(ox[x[a]]-ox[x[b]])+abs(oy[y[a]]-oy[y[b]]);\n}\n\nLL Dfs_dp(int l,int r,int t,int mn,int mx){\n  if (dp[t][l].find(r)!=dp[t][l].end()) return dp[t][l][r];\n  LL res=l-r;\n  int flag=0;\n  if (l>1&&(p[l-1]==mn-1||p[l-1]==mx+1))\n\tres=Dfs_dp(le[l-1],r,0,min(mn,p[le[l-1]]),max(mx,p[le[l-1]]))+Get_dis(le[l-1],t?r:l),flag=1;\n  if (r<n&&(p[r+1]==mn-1||p[r+1]==mx+1)){\n\tLL now=Dfs_dp(l,ri[r+1],1,min(mn,p[ri[r+1]]),max(mx,p[ri[r+1]]))+Get_dis(ri[r+1],t?r:l);\n\tres=flag?min(res,now):now;\n  }\n  return dp[t][l][r]=res;\n}\n\nLL ans[N+9];\n\nvoid Get_dp(){\n  for (int i=1;i<=n;++i) ans[id[i]]=Dfs_dp(i,i,0,p[i],p[i]);\n}\n\nvoid work(){\n  Get_id();\n  Get_le_ri();\n  Get_dp();\n}\n\nvoid outo(){\n  for (int i=1;i<=n;++i)\n\tprintf(\"%lld\\n\",ans[i]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n    return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n    return a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n    hi ++; assert(lo <= hi); // assuming f is increasing\n    while (lo < hi) { // find first index such that f is true \n        T mid = half(lo+hi);\n        f(mid) ? hi = mid : lo = mid+1; \n    } \n    return lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n    lo --; assert(lo <= hi); // assuming f is decreasing\n    while (lo < hi) { // find first index such that f is true \n        T mid = half(lo+hi+1);\n        f(mid) ? lo = mid : hi = mid-1;\n    } \n    return lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n    sort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n    #ifdef LOCAL\n        return b ? \"true\" : \"false\"; \n    #else \n        return ts((int)b);\n    #endif\n}\ntemplate<class A> str ts(complex<A> c) { \n    stringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n    str res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n    res += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n    str res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n    return res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n    #ifdef LOCAL\n        bool fst = 1; str res = \"{\";\n        for (const auto& x: v) {\n            if (!fst) res += \", \";\n            fst = 0; res += ts(x);\n        }\n        res += \"}\"; return res;\n    #else\n        bool fst = 1; str res = \"\";\n        for (const auto& x: v) {\n            if (!fst) res += \" \";\n            fst = 0; res += ts(x);\n        }\n        return res;\n\n    #endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n    #ifdef LOCAL\n        return \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; \n    #else\n        return ts(p.f)+\" \"+ts(p.s);\n    #endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n    pr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n    pr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n    cerr << ts(h); if (sizeof...(t)) cerr << \", \";\n    DBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n    #define dbg(...) cerr << \"Line(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n    #define chk(...) if (!(__VA_ARGS__)) cerr << \"Line(\" << __LINE__ << \") -> function(\" \\\n         << __FUNCTION__  << \") -> CHK FAILED: (\" << #__VA_ARGS__ << \")\" << \"\\n\", exit(0);\n#else\n    #define dbg(...) 0\n    #define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = \"\") {\n    unsyncIO();\n    // cin.exceptions(cin.failbit); \n    // throws exception when do smth illegal\n    // ex. try to read letter into int\n    if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nconst int mx = 200005;\n\nint N;\npl P[mx];\nmap<int, int> m;  //compress y \nmap<int, int> toind; // original index of x coor\nll ans[mx];\n\nll getDist(int i, int j){\n    return abs(P[j].f-P[i].f)+abs(P[j].s-P[i].s);\n}\n\npl search(int l, int r, int L, int R){\n    //dbg(l, r, L, R);\n    int dir = 0;\n    if(l-1 >= 1){\n        if(m[P[l-1].s] == L-1) dir = 1;\n        else if(m[P[l-1].s] == R+1) dir = 2;\n    }\n    if(r+1 <= N){\n        if(m[P[r+1].s] == R+1) dir = 1;\n        else if(m[P[r+1].s] == L-1) dir = 2;\n    }\n    //dbg(dir);\n    if(dir == 0) return mp(-(r-l), -(r-l));\n\n    int lind = l;\n    int rind = r;\n\n    for(int i = l-1; i >= 1; i--){\n        if(dir == 1 && m[P[i].s] == i-l+L){\n            lind = i;\n        }\n        else if(dir == 2 && m[P[i].s] == R-i+l){\n            lind = i;\n        }\n        else break;\n    }\n\n    for(int i = r+1; i <= N; i++){\n        if(dir == 1 && m[P[i].s] == i-r+R){\n            rind = i;\n        }\n        else if(dir == 2 && m[P[i].s] == L-i+r){\n            rind = i;\n        }\n        else break;\n    }\n\n    int nL, nR;\n    if(dir == 1){\n        nL = min(L, m[P[lind].s]);\n        nR = max(R, m[P[rind].s]);\n    }\n    else{\n        nL = min(L, m[P[rind].s]);\n        nR = min(R, m[P[lind].s]);\n    }\n\n    pl val = search(lind, rind, nL, nR);\n    pl res = mp(INF, INF);\n    if(lind == l){\n        ckmin(res.f, val.s+getDist(l, rind));\n        ckmin(res.s, val.s+getDist(r, rind));\n    }\n    if(rind == r){\n        ckmin(res.f, val.f+getDist(l, lind));\n        ckmin(res.s, val.f+getDist(r, lind));\n    }\n    ckmin(res.f, val.f+getDist(l, rind)+getDist(rind, lind));\n    ckmin(res.f, val.s+getDist(l, lind)+getDist(lind, rind));\n    ckmin(res.s, val.f+getDist(r, rind)+getDist(rind, lind));\n    ckmin(res.s, val.s+getDist(r, lind)+getDist(lind, rind));\n    \n    //dbg(res);\n    return res;\n}\n\nint main() {\n    setIO();\n    cin >> N;\n    vpi v;\n    for(int i = 1; i <= N; i++){\n        cin >> P[i].f >> P[i].s;\n        m[P[i].s];\n        toind[P[i].f] = i;\n    }\n    int cnt = 0;\n    for(auto &u: m){\n        u.s = ++cnt;\n    }\n    sort(P+1, P+1+N);\n    for(int i = 1; i <= N; i++){\n        if(i-1 >= 1 && m[P[i-1].s] == m[P[i].s]-1) continue;\n        if(i-1 >= 1 && m[P[i-1].s] == m[P[i].s]+1) continue;\n        if(i+1 > N){\n            ans[toind[P[i].f]] = 0;\n            continue;\n        }\n        //edit i after finding a range\n        if(m[P[i+1].s] == m[P[i].s]+1){\n            int maxi = i+1;\n            for(int j = i+1; j <= N; j++){\n                if(m[P[j].s] == m[P[i].s]+j-i){\n                    maxi = j;\n                }\n                else break;\n            }\n            pl x = search(i, maxi, m[P[i].s], m[P[i].s]+maxi-i);\n            for(int j = i; j <= maxi; j++){\n                ans[toind[P[j].f]] = min(x.f+getDist(j, maxi)+getDist(i, maxi), x.s+getDist(j, i)+getDist(i, maxi));\n            }\n            //dbg(i, maxi);\n            i = maxi;\n        }\n        else if(m[P[i+1].s] == m[P[i].s]-1){\n            int maxi = i+1;\n            for(int j = i+1; j <= N; j++){\n                if(m[P[j].s] == m[P[i].s]-j+i){\n                    maxi = j;\n                }\n                else break;\n            }\n            pl x = search(i, maxi, m[P[i].s]-maxi+i, m[P[i].s]);\n            for(int j = i; j <= maxi; j++){\n                ans[toind[P[j].f]] = min(x.f+getDist(j, maxi)+getDist(i, maxi), x.s+getDist(j, i)+getDist(i, maxi));\n            }\n            //dbg(i, maxi);\n            i = maxi;\n        }\n        else{\n            ans[toind[P[i].f]] = 0;\n        }\n        \n    }\n\n    for(int i = 1; i <= N; i++){\n        ps(ans[i]);\n    }\n\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?)\n    * do smth instead of nothing and stay organized\n    * WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define incm(x,y) {x=((x)+(y))%mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nstruct ii\n{\n\tint x,y,id;\n}b[200005];\nint n,m,i,j,mx[200005][19],mi[200005][19],a[200005],x,y,smi[800005],tag[800005],lg[800005];\nint l[400005],r[400005],id[400005],rstl[400005],typ[400005];\nint stk0[400005],stk1[400005],stk2[400005],tp0,tp1,tp2,cnt,rt;\nlong long dp[400005][2],res[400005];\nvector<int> bi[400005];int fa[400005][19],dep[400005];\nvector<int> allx,ally;\nint qrymin(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn min(mi[l][k],mi[r-(1<<k)+1][k]);\n}\nint qrymax(int l,int r)\n{\n\tint k=lg[r-l+1];\n\treturn max(mx[l][k],mx[r-(1<<k)+1][k]);\n}\nbool check(int l,int r)\n{\n\tint vl=qrymin(l,r),vr=qrymax(l,r);\n\treturn vr-vl+1==r-l+1;\n}\nvoid upd(int x,int y)\n{\n\ttag[x]+=y;\n\tsmi[x]+=y;\n}\nvoid pushdo(int x)\n{\n\tif(tag[x]){\n\t\tupd(x*2,tag[x]);\n\t\tupd(x*2+1,tag[x]);\n\t\ttag[x]=0;\n\t}\n}\nvoid update(int x,int l,int r,int ql,int qr,int c)\n{\n\tif(ql<=l&&r<=qr){\n\t\tupd(x,c);\n\t\treturn;\n\t}int mid=(l+r)/2;\n\tpushdo(x);\n\tif(ql<=mid)update(x+x,l,mid,ql,qr,c);\n\tif(qr>mid)update(x+x+1,mid+1,r,ql,qr,c);\n\tsmi[x]=min(smi[x+x],smi[x+x+1]);\n}\nint query(int x,int l,int r)\n{\n\twhile(l<r){\n\t\tpushdo(x);\n\t\tint mid=(l+r)/2;\n\t\tif(!smi[x+x]){\n\t\t\tx=x+x;r=mid;\n\t\t}\n\t\telse{\n\t\t\tx=x+x+1;l=mid+1;\n\t\t}\n\t}\n\treturn l;\n}\nvoid build()\n{\n\tint i;tp0=tp1=tp2=cnt=0;\n\tfz1(i,n){\n\t\twhile(tp1&&a[stk1[tp1]]>=a[i]){\n\t\t\tupdate(1,1,n,stk1[tp1-1]+1,stk1[tp1],a[stk1[tp1]]);\n\t\t\ttp1--;\n\t\t}stk1[++tp1]=i;update(1,1,n,stk1[tp1-1]+1,stk1[tp1],-a[stk1[tp1]]);\n\t\t\n\t\twhile(tp2&&a[stk2[tp2]]<=a[i]){\n\t\t\tupdate(1,1,n,stk2[tp2-1]+1,stk2[tp2],-a[stk2[tp2]]);\n\t\t\ttp2--;\n\t\t}stk2[++tp2]=i;update(1,1,n,stk2[tp2-1]+1,stk2[tp2],a[stk2[tp2]]);\n\t\t\n\t\tint le=query(1,1,n),cur=id[i]=++cnt;\n\t\tl[cur]=r[cur]=i;\n\t\twhile(tp0&&l[stk0[tp0]]>=le){\n\t\t\tif(typ[stk0[tp0]]&&check(rstl[stk0[tp0]],i)){\n\t\t\t\tbi[stk0[tp0]].push_back(cur);\n\t\t\t\trstl[stk0[tp0]]=l[cur];\n\t\t\t\tr[stk0[tp0]]=r[cur];\n\t\t\t\tcur=stk0[tp0--];\n\t\t\t}\n\t\t\telse if(check(l[stk0[tp0]],i)){\n\t\t\t\ttyp[++cnt]=1;\n\t\t\t\tbi[cnt].push_back(stk0[tp0]);\n\t\t\t\tbi[cnt].push_back(cur);\n\t\t\t\tl[cnt]=l[stk0[tp0]];\n\t\t\t\trstl[cnt]=l[cur];\n\t\t\t\tr[cnt]=r[cur];\n\t\t\t\t--tp0;\n\t\t\t\tcur=cnt;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttyp[++cnt]=0;\n\t\t\t\tbi[cnt].push_back(cur);\n\t\t\t\tbi[cnt].push_back(stk0[tp0--]);\n\t\t\t\twhile(tp0&&!check(l[stk0[tp0]],i)){\n\t\t\t\t\tbi[cnt].push_back(stk0[tp0--]);\n\t\t\t\t}\n\t\t\t\tl[cnt]=l[stk0[tp0]];\n\t\t\t\tr[cnt]=r[cur];\n\t\t\t\tbi[cnt].push_back(stk0[tp0--]);\n\t\t\t\treverse(bi[cnt].begin(),bi[cnt].end());\n\t\t\t\tcur=cnt;\n\t\t\t}\n\t\t}\n\t\tstk0[++tp0]=cur;\n\t\tupdate(1,1,n,1,i,-1);\n\t}\n\trt=stk0[1];\n}\nint dis(int x,int y)\n{\n\treturn abs(b[x].x-b[y].x)+abs(b[x].y-b[y].y);\n}\nvoid dfs(int x,int p)\n{\n\tint tl=0,tr=0,i;\n\tfz0k(i,bi[x].size()){\n\t\tif(typ[x]){\n\t\t\ttr=max(tr,i);\n\t\t\tif(i&&l[bi[x][i-1]]<r[bi[x][i-1]]) tl=i;\n\t\t\twhile(tr+1<bi[x].size()&&l[bi[x][tr+1]]==r[bi[x][tr+1]]) tr++;\n\t\t}\n\t\telse{\n\t\t\ttl=tr=i;\n\t\t}\n\t\tint gl=l[bi[x][tl]],gr=r[bi[x][tr]],y=bi[x][i],fl=l[y],fr=r[y];\n\t\tif(tl==0&&tr==bi[x].size()-1){\n\t\t\tdp[y][0]=min(dp[x][0]+dis(fl,gr)+dis(gl,gr),dp[x][1]+dis(fl,gl)+dis(gl,gr));\n\t\t\tdp[y][1]=min(dp[x][0]+dis(fr,gr)+dis(gl,gr),dp[x][1]+dis(fr,gl)+dis(gl,gr));\n\t\t\tif(fl==gl) dp[y][1]=min(dp[y][1],dp[x][1]+dis(fr,gr));\n\t\t\tif(fr==gr) dp[y][0]=min(dp[y][0],dp[x][0]+dis(fl,gl)); \n\t\t}\n\t\telse{\n\t\t\tdp[y][0]=min(dis(fl,gr)+dis(gl,gr),dis(fl,gl)+dis(gl,gr));\n\t\t\tdp[y][1]=min(dis(fr,gr)+dis(gl,gr),dis(fr,gl)+dis(gl,gr));\n\t\t\tif(fl==gl) dp[y][1]=min(dp[y][1],0ll+dis(fr,gr));\n\t\t\tif(fr==gr) dp[y][0]=min(dp[y][0],0ll+dis(fl,gl));\n\t\t}\n\t\tdp[y][0]-=(tr-tl);\n\t\tdp[y][1]-=(tr-tl);\n\t}\n\tff(bi[x],it){\n\t\tdfs(*it,x);\n\t}\n}\nbool cmp(ii x,ii y)\n{\n\treturn x.x<y.x;\n}\nint main()\n{\n\tread(n);\n\tfz1(i,n){\n\t\tread(b[i].x);\n\t\tread(b[i].y);\n\t\tb[i].id=i;\n//\t\tallx.push_back(b[i].x);\n\t\tally.push_back(b[i].y);\n\t}\n//\tsort(allx.begin(),allx.end());\n//\tallx.resize(unique(allx.begin(),allx.end())-allx.begin());\n\tsort(ally.begin(),ally.end());\n\tally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\tsort(b+1,b+n+1,cmp);\n\tfz1(i,n){\n\t\ta[i]=upper_bound(ally.begin(),ally.end(),b[i].y)-ally.begin();\n\t}\n\tfz(i,2,200000){\n\t\tlg[i]=lg[i/2]+1;\n\t}\n\tfz1(i,n){\n\t\tmx[i][0]=mi[i][0]=a[i];\n\t}\n\tfz1(j,18)fz1(i,n-(1<<j)+1){\n\t\tmx[i][j]=max(mx[i][j-1],mx[i+(1<<(j-1))][j-1]);\n\t\tmi[i][j]=min(mi[i][j-1],mi[i+(1<<(j-1))][j-1]);\n\t}\n\tbuild();\n\tdep[rt]=1;\n/*\tfz1(i,cnt){\n\t\tff(bi[i],it)cerr<<*it<<' ';cerr<<endl;\n\t}*/\n\tdfs(rt,0);\n\tfz1(i,n){\n\t\tres[b[i].id]=min(dp[id[i]][0],dp[id[i]][1]);\n\t}\n\tfz1(i,n){\n\t\tprintf(\"%lld\\n\",res[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=300005,mod=1000000007;\nint n,h,a[N],x[N],y[N],s[N],d[N],ans;\nvector<int>v;\nint qp(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid pre(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tx[k]=y[k]=l;\n\t\treturn;\n\t}\n\ts[k<<1]=s[k]*(k<<1)%mod;\n\ts[k<<1|1]=s[k]*(k<<1|1)%mod;\n\tint mid=l+r>>1;\n\tpre(k<<1,l,mid);\n\tpre(k<<1|1,mid+1,r);\n\tx[k]=x[k<<1];\n\ty[k]=y[k<<1|1];\n}\nvoid clear(int k)\n{\n\td[k]=0;\n\tif(k==1)\n\t\treturn;\n\tclear(k/2);\n}\nvoid rec1(int k,int t)\n{\n\tt=t*k%mod;\n\td[k]=(d[k]+t)%mod;\n\tif(k==1)\n\t\treturn;\n\trec1(k/2,t);\n}\nvoid rec2(int k,int t,int l)\n{\n\tt=t*k%mod;\n\tans=(ans+t*(d[k^1])%mod*(k/2)%mod*qp(l,mod-2)%mod)%mod;\n\tif(k==1)\n\t\treturn;\n\trec2(k/2,t,l);\n}\nsigned main()\n{\n\tios::sync_with_stdio(0);\n\tcin>>h;\n\tn=(1<<h)-1;\n\tfor(int i=1;i<=n/2+1;i++)\n\t\tcin>>a[i];\n\ts[1]=1;\n\tpre(1,1,n/2+1);\n\tfor(int i=1;i<=n/2;i++)\n\t{\t\n\t\tv.clear();\n\t\tfor(int j=x[i<<1];j<=y[i<<1];j++)\n\t\t{\n\t\t\trec1(a[j]+n/2,s[j+n/2]);\n\t\t\tv.push_back(a[j]+n/2);\n\t\t}\n\t\tfor(int j=x[i<<1|1];j<=y[i<<1|1];j++)\n\t\t\trec2(a[j]+n/2,s[j+n/2],i==1?1:s[i]*s[i/2]%mod);\n\t\tfor(auto j:v)\n\t\t\tclear(j);\n\t}\t\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\n//not a multiset\n//find_by_order(k) -> itr of k-th(0-based) element\n//order_of_key(k) -> index of lower_bound(k)\nusing ordered_set=tree<\nint,\nnull_type,\nless<int>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n\n//https://codeforces.com/blog/entry/62393\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\t// http://xorshift.di.unimi.it/splitmix64.c\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\n\tsize_t operator()(uint64_t x) const {\n\t\tstatic const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n\n\tsize_t operator()(pair<int,int> x) const {\n\t\treturn operator()(uint64_t(x.first)<<32|x.second);\n\t}\n};\n\ntemplate<class t,class u>\nusing hash_table=gp_hash_table<t,u,custom_hash>;\n\n//count が使えない\n//find を，しようね！\n//move コンストラクタがないのでマージテクで壊れる バカ\n//value を null_type にすることで unordered_set が実現できる\n//insert などの関数が存在する (ドキュメント，どこ？)\n//https://gcc.gnu.org/onlinedocs/libstdc++/manual/policy_data_structures.html (長すぎ，HELP)\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nconst int nmax=200010;\n\nint n;\nstruct Rook{\n\tint x,y,i,a,b;\n\tbool operator<(const Rook&r)const{return x<r.x;}\n};\nRook z[nmax];\n\nusing P=pair<ll,ll>;\n\nhash_table<pi,P> memo;\n\nint lf[2][nmax],rt[2][nmax];\nint w[2]{1,-1};\n\nint getdist(const Rook&a,const Rook&b){\n\treturn abs(a.x-b.x)+abs(a.y-b.y);\n}\n\nP slv(int l,int r,int bot,int top){\n\tpi key(l,r);\n\t{\n\t\tauto itr=memo.find(key);\n\t\tif(itr!=memo.ed)return itr->b;\n\t}\n\t\n\tint tar[2]{bot,top};\n\trep(k,2){\n\t\tint i=l,j=r;\n\t\tif(i>0&&z[i-1].b+w[k]==tar[0]){\n\t\t\ti=lf[k][i-1];\n\t\t}\n\t\tif(j+1<n&&tar[1]+w[k]==z[j+1].b){\n\t\t\tj=rt[k][j+1];\n\t\t}\n\t\tif(pi(i,j)!=pi(l,r)){\n\t\t\tdmp2(l,r,i,j);\n\t\t\tP res=slv(i,j,min({bot,z[i].b,z[j].b}),max({top,z[i].b,z[j].b}));\n\t\t\tll a=infLL,b=infLL;\n\t\t\tint lc=l-i,rc=j-r;\n\t\t\tif(lc&&rc){\n\t\t\t\tint base=getdist(z[i],z[j])-lc-rc;\n\t\t\t\ta=min(getdist(z[j],z[l])+res.a,getdist(z[i],z[l])+res.b)+base;\n\t\t\t\tb=min(getdist(z[j],z[r])+res.a,getdist(z[i],z[r])+res.b)+base;\n\t\t\t}else if(lc){\n\t\t\t\ta=getdist(z[i],z[l])-lc+res.a;\n\t\t\t\tb=getdist(z[i],z[r])-lc+res.a;\n\t\t\t}else if(rc){\n\t\t\t\ta=getdist(z[j],z[l])-rc+res.b;\n\t\t\t\tb=getdist(z[j],z[r])-rc+res.b;\n\t\t\t}else assert(0);\n\t\t\treturn memo[key]=P(a,b);\n\t\t}\n\t\tswap(tar[0],tar[1]);\n\t}\n\t\n\treturn memo[key]=P(0,0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>z[i].x>>z[i].y;\n\t\tz[i].i=i;\n\t}\n\tsort(z,z+n);\n\tvi xs(n),ys(n);\n\trep(i,n){\n\t\txs[i]=z[i].x;\n\t\tys[i]=z[i].y;\n\t}\n\tsort(all(xs));\n\tsort(all(ys));\n\trep(i,n){\n\t\tz[i].a=lwb(xs,z[i].x);\n\t\tz[i].b=lwb(ys,z[i].y);\n\t}\n\t\n\trep(k,2){\n\t\trep(i,n){\n\t\t\tlf[k][i]=i;\n\t\t\tif(i>0&&z[i-1].b+w[k]==z[i].b)\n\t\t\t\tlf[k][i]=lf[k][i-1];\n\t\t}\n\t\tper(i,n){\n\t\t\trt[k][i]=i;\n\t\t\tif(i+1<n&&z[i].b+w[k]==z[i+1].b)\n\t\t\t\trt[k][i]=rt[k][i+1];\n\t\t}\n\t}\n\t\n\tvc<ll> ans(n);\n\trep(i,n)ans[z[i].i]=slv(i,i,z[i].b,z[i].b).a;\n\tfor(auto v:ans)print(v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n\nnamespace IO {\n  const int IN_LEN = 1 << 18 | 1;\n  static char buf[IN_LEN] , *s , *t;\n  inline int Getchar( void ) { return s == t && ( t = ( s = buf ) + fread( buf , 1 , IN_LEN , stdin ) ) , s == t ? -1 : *s++; }\n  template <class T> inline void read( T & x ) {\n    static int c , f; c = Getchar() , x = f = 0;\n    while( c < '0' || c > '9' ) { if( c == '-' ) f = 1; c = Getchar(); }\n    while( c <= '9' && c >= '0' ) x = x * 10 + c - 48 , c = Getchar(); \n    x = f ? -x : x;\n  }\n} using IO::read;\n\nusing namespace std;\n\ntypedef long long lol;\ntypedef pair<int,int> pii;\nconst int N = 2e5 + 5;\n\nlol ans[N] , f[N][2];\n\nstruct Data {\n  int x , y , id , _y;\n  bool operator < ( const Data & rhs ) const {\n    return x < rhs.x;\n  }\n  lol friend dist( Data a , Data b ) {\n    return abs( a.x - b.x ) + abs( a._y - b._y );\n  }\n} dat[N];\n\nint n , discre[N] , discre_tot;\n\ninline int discreid( int x ) { return lower_bound( discre + 1 , discre + 1 + discre_tot , x ) - discre; }\n\nint main( void ) {\n  read( n );\n  for( int i = 1 ; i <= n ; ++i ) {\n    read( dat[i].x );\n    read( dat[i].y );\n    discre[i] = dat[i].y;\n    dat[i]._y = dat[i].y;\n    dat[i].id = i;\n  }\n  memset( ans , -1 , sizeof ans );\n  sort( dat + 1 , dat + 1 + n );\n  sort( discre + 1 , discre + 1 + n );\n  discre_tot = unique( discre + 1 , discre + 1 + n ) - discre - 1;\n  for( int i = 1 ; i <= n ; ++i )\n    dat[i].y = discreid( dat[i].y );\n  for( int i = 1 , L , R , l , r , _mono , _updl , _updr , sz , _cnt ; i <= n ; ++i )\n    if( !~ans[dat[i].id] ) {\n      l = r = i , L = dat[i].y , R = dat[i].y;\n      _mono = 0;\n      if( i < n && dat[i + 1].y == dat[i].y + 1 ) _mono = 1;\n      if( i < n && dat[i + 1].y == dat[i].y - 1 ) _mono = -1;\n      if( !_mono ) {\n        if( i > 1 && dat[i - 1].y == dat[i].y - 1 ) _mono = 1;\n        if( i > 1 && dat[i - 1].y == dat[i].y + 1 ) _mono = -1;\n      }\n      if( !_mono ) {\n        ans[dat[i].id] = 0;\n        continue;\n      }\n      vector<pii> layer;\n      vector<int> cnt;\n      while( 114514 ) {\n        _updl = _updr = _cnt = 0;\n        while( l > 1 && dat[l - 1].y == L - _mono ) --l , L -= _mono , _updl = 1 , ++_cnt;\n        while( r < n && dat[r + 1].y == R + _mono ) ++r , R += _mono , _updr = 1 , ++_cnt;\n        if( _updl || _updr ) {\n          cnt.push_back( _cnt );\n          if( !layer.size() ) layer.push_back( pii( l , r ) );\n          else {\n            int _l = l , _r = r;\n            if( !_updl ) _l = r - _cnt + 1;\n            if( !_updr ) _r = l + _cnt - 1;\n            layer.push_back( pii( _l , _r ) );\n          }\n          swap( L , R );\n          _mono = -_mono;\n        } else break;\n      }\n      sz = layer.size();\n      memset( f , 0x3f , sizeof( int ) * 2 * sz );\n      f[sz - 1][0] = f[sz - 1][1] = 0;\n      for( int _ = sz - 2 , l , r , _l , _r , _t ; ~_ ; --_ ) {\n        l = layer[_].fi , r = layer[_].se;\n        _l = layer[_+1].fi , _r = layer[_+1].se;\n        _t = cnt[_+1];\n        f[_][0] = min( dist( dat[l] , dat[_r] ) + f[_+1][0] , dist( dat[l] , dat[_l] ) + f[_+1][1] ) + dist( dat[_l] , dat[_r] ) - _t;\n        f[_][1] = min( dist( dat[r] , dat[_r] ) + f[_+1][0] , dist( dat[r] , dat[_l] ) + f[_+1][1] ) + dist( dat[_l] , dat[_r] ) - _t;\n      }\n      l = layer[0].fi , r = layer[0].se;\n      for( int _ = l ; _ <= r ; ++_ )\n        ans[dat[_].id] = min( dist( dat[_] , dat[r] ) + f[0][0] , dist( dat[_] , dat[l] ) + f[0][1] ) + dist( dat[l] , dat[r] ) - ( r - l );\n    }\n  for( int i = 1 ; i <= n ; ++i )\n    printf(\"%lld\\n\",ans[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  // Rooks, by Errichto\nusing namespace std;\n#define sim template < class c\n#define ris return  this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge range(c i, c j) { return rge{i, j}; }\nsim > auto dud(c x) -> decltype(cerr << x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge d) {\n  this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    this << \", \" + 2  (it == d.b) << it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #VA_ARGS \": \" << (VA_ARGS) << \"] \"\n// debug & operator << (debug & dd, P p) { dd << \"(\" << p.x << \", \" << p.y << \")\"; return dd; }\n\nstruct Rook {\n    int x, y, id;\n    bool operator <(const Rook& other) const {\n        return x < other.x;\n    }\n};\nlong long hack;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    assert(2 <= n && n <= 200  1000);\n    vector rooks(n);\n    for(int i = 0; i < n; ++i) {\n        rooks[i].id = i;\n        scanf(\"%d%d\", &rooks[i].x, &rooks[i].y);\n        assert(1 <= min(rooks[i].x, rooks[i].y) && max(rooks[i].x, rooks[i].y) <= 1000  1000);\n    }\n    sort(rooks.begin(), rooks.end());\n    vector ys{INT_MIN, INT_MAX}; // two sentinels for convenience\n    for(int i = 0; i < n; ++i) {\n        ys.push_back(rooks[i].y);\n    }\n    sort(ys.begin(), ys.end());\n    for(int i = 0; i < n - 1; ++i) {\n        assert(ys[i] != ys[i+1]);\n        assert(rooks[i].x != rooks[i+1].x);\n    }\n    vector> answer(n, {-1, -1});\n    for(int start = 0; start < n; ++start) {\n        if(answer[rooks[start].id].first != -1) {\n            continue;\n        }\n\n        int start_y = lower_bound(ys.begin(), ys.end(), rooks[start].y) - ys.begin();\n        int y1 = start_y - 1, y2 = start_y + 1;\n\n        int L = start, R = start;\n        int prev_dir = -1;\n        vector> intervals;\n        while(true) {\n            bool found = false;\n            for(int i : {L - 1, R + 1}) {\n                if(0 <= i && i < n) {\n                    bool prev_y = (ys[y1] == rooks[i].y);\n                    bool next_y = (ys[y2] == rooks[i].y);\n                    if(prev_y || next_y) {\n                        int direction = (prev_y == (i == L - 1)); // 0 or 1\n                        // debug() << imie(start) imie(i) imie(direction);\n                        if(prev_dir == -1) {\n                            prev_dir = direction;\n                        }\n                        if(prev_dir != direction) {\n                            intervals.emplace_back(L, R);\n                            prev_dir = direction;\n                        }\n                        prev_y ? y1-- : y2++;\n                        i == L-1 ? L-- : R++;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if(!found) {\n                break;\n            }\n        }\n        if(intervals.empty() || intervals.back() != make_pair(L, R)) {\n            intervals.emplace_back(L, R);\n        }\n        const int s = intervals.size();\n        debug() << imie(start) imie(intervals);\n\n        { // complexity check\n            static int sum_s = 0, sum_len = 0;\n            if(s > 1) sum_s += s;\n            assert(sum_s <= n);\n            sum_len += R - L + 1;\n            assert(sum_len <= 3  n); // N + out + 2  border    ('out' and 'border' are disjoint)\n            static vector basic(n), out(n), border(n);\n            pair i_basic = intervals[0], i_out = intervals[max(0,s-2)], i_border = intervals.back();\n            for(int i = i_border.first; i <= i_border.second; ++i) {\n                if(i_basic.first <= i && i <= i_basic.second) {\n                    assert(++basic[i] == 1);\n                }\n                else if(i_out.first <= i && i <= i_out.second) {\n                    assert(++out[i] == 1 && border[i] == 0);\n                }\n                else {\n                    assert(++border[i] <= 2 && out[i] == 0);\n                }\n            }\n        }\n\n        const long long INF = 1e18L + 5;\n        auto min_self = & {\n            a = min(a, b);\n        };\n        auto f = & { // manhattan distance between two rooks\n            return abs(rooks[i].x - rooks[j].x) + abs(rooks[i].y - rooks[j].y);\n        };\n        vector> dp(s, vector(2, INF));\n        // dp[i][0] is minimum number of REMAINING operations if we did interval i and we are at its left end\n        // dp[i][1] -- same but right end\n        dp[s-1][0] = dp[s-1][1] = 0;\n        for(int who = s - 1; who >= 1; --who) {\n            // [L1, [L2, R1], R2]\n            int L1 = intervals[who].first;\n            int L2 = intervals[who-1].first;\n            int R1 = intervals[who-1].second;\n            int R2 = intervals[who].second;\n            hack += (long long) (L2 - L1)  (R2 - R1);\n            min_self(dp[who-1][0], dp[who][0] + (R1 == R2 ? f(L1, L2) : f(L1, R2) + f(R2, L2)));\n            min_self(dp[who-1][1], dp[who][0] + f(L1, R2) + f(R2, R1));\n            min_self(dp[who-1][0], dp[who][1] + f(R2, L1) + f(L1, L2));\n            min_self(dp[who-1][1], dp[who][1] + (L1 == L2 ? f(R1, R2) : f(R2, L1) + f(L1, R1)));\n        }\n        int low = intervals[0].first, high = intervals[0].second;\n        for(int i = low; i <= high; ++i) {\n            assert(answer[rooks[i].id] == make_pair(-1, -1LL));\n            answer[rooks[i].id] = {\n                R - L,\n                min(dp[0][0] + f(low, high) + f(high, i), dp[0][1] + f(high, low) + f(low, i))\n            };\n        }\n    }\n    for(pair p : answer) {\n        // printf(\"%d %lld\\n\", p.first, p.second - p.first);\n        printf(\"%lld\\n\", p.second - p.first);\n    }\n    cerr << \"hack = \" << hack << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define pb push_back\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\n\nstruct node{\n  int s,e,m;\n  ll val=0,lazy=0;\n  node *l,*r;\n\n  node (int _s,int _e){\n    s=_s,e=_e,m=s+e>>1;\n\n    if (s!=e){\n      l=new node(s,m);\n      r=new node(m+1,e);\n    }\n  }\n\n  void propo(){\n    if (lazy){\n      val+=lazy;\n      if (s!=e){\n        l->lazy+=lazy;\n        r->lazy+=lazy;\n      }\n      lazy=0;\n    }\n  }\n\n  void update(int i,int j,ll k){\n    if (s==i && e==j) lazy+=k;\n    else{\n      if (j<=m) l->update(i,j,k);\n      else if (m<i) r->update(i,j,k);\n      else l->update(i,m,k),r->update(m+1,j,k);\n\n      l->propo(),r->propo();\n      val=min(l->val,r->val);\n    }\n  }\n\n  ll query(int i,int j){\n    propo();\n\n    if (s==i && e==j) return val;\n    else if (j<=m) return l->query(i,j);\n    else if (m<i) return r->query(i,j);\n    else return min(l->query(i,m),r->query(m+1,j));\n  }\n};\n\nint n,q;\nint arr[200005];\nii range[400005];\nii span[400005];\nvector<int> children[400005];\nint parent[400005];\nint typ[400005];\nint idx; //new index to assign to nodes\n\nii get_range(ii i,ii j){\n  return ii(min(i.fi,j.fi),max(i.se,j.se));\n}\n\nvoid add_edge(int u,int v){ //u is parent of v\n  parent[v]=u;\n  children[u].push_back(v);\n}\n\nbool adj(int i,int j){\n  return range[i].se==range[j].fi-1;\n}\n\nint length(int i){\n  return range[i].se-range[i].fi+1;\n}\n\nint build(){\n  idx=n;\n  memset(parent,-1,sizeof(parent));\n\n  node *root=new node(0,200005);\n  vector<int> mx={-1},mn={-1}; //stacks for max and min\n\n  vector<int> nodes; //stack of cut and join nodes\n\n  rep(x,0,n){\n    //update Q values\n    while (mx.back()!=-1 && arr[mx.back()]<arr[x]){\n      int temp=mx.back();\n      mx.pop_back();\n      root->update(mx.back()+1,temp,arr[x]-arr[temp]);\n    }\n    mx.push_back(x);\n\n    while (mn.back()!=-1 && arr[mn.back()]>arr[x]){\n      int temp=mn.back();\n      mn.pop_back();\n      root->update(mn.back()+1,temp,arr[temp]-arr[x]);\n    }\n    mn.push_back(x);\n\n    //handle stack updates\n    range[x]=ii(arr[x],arr[x]);\n    span[x]=ii(x,x);\n    int curr=x;\n\n    while (true){\n      if (!nodes.empty() && (adj(nodes.back(),curr) || adj(curr,nodes.back()))){\n        if ((adj(nodes.back(),curr) && typ[nodes.back()]==1)||\n            (adj(curr,nodes.back()) && typ[nodes.back()]==2)){\n          add_edge(nodes.back(),curr);\n\n          range[nodes.back()]=get_range(range[nodes.back()],range[curr]);\n          span[nodes.back()]=get_range(span[nodes.back()],span[curr]);\n\n          curr=nodes.back();\n          nodes.pop_back();\n        }\n        else{ //make a new join node\n          typ[idx]=(adj(nodes.back(),curr) ? 1:2);\n          add_edge(idx,nodes.back());\n          add_edge(idx,curr);\n\n          range[idx]=get_range(range[nodes.back()],range[curr]);\n          span[idx]=get_range(span[nodes.back()],span[curr]);\n\n          nodes.pop_back();\n          curr=idx++;\n        }\n      }\n      else if (x-(length(curr)-1) && root->query(0,x-length(curr))==0){\n        int len=length(curr);\n        ii r=range[curr];\n        ii s=span[curr];\n\n        add_edge(idx,curr);\n\n        do{\n          len+=length(nodes.back());\n          r=get_range(r,range[nodes.back()]);\n          s=get_range(s,span[nodes.back()]);\n\n          add_edge(idx,nodes.back());\n\n          nodes.pop_back();\n        } while (r.se-r.fi+1!=len);\n\n        reverse(all(children[idx]));\n        range[idx]=r;\n        span[idx]=s;\n        curr=idx++;\n      }\n      else{\n        break;\n      }\n    }\n\n    nodes.push_back(curr);\n    root->update(0,x,-1);\n  }\n\n  assert(nodes.size() == 1);\n  return nodes[0];\n}\n\nconstexpr int64 INF = (int64) 1e18;\n\n\nclass Task {\n public:\n  vector<int> compress(const vector<int64>& x) {\n    vector<int64> xs = x;\n    sort(all(xs));\n    vector<int> res(x.size());\n    for (int i = 0; i < x.size(); ++i) {\n      res[i] = lower_bound(all(xs), x[i]) - xs.begin();\n    }\n    return res;\n  }\n\n  void dfs(int root, int64 extraIfMin, int64 extraIfMax) {\n    if (range[root].first == range[root].second) {\n      answers[answerPos[range[root].first]] = min(extraIfMin, extraIfMax);\n      return;\n    }\n    if (typ[root] == 0) {\n      for (int x : children[root]) {\n        dfs(x, 0, 0);\n      }\n    } else {\n      vector<int> nextNon1(children[root].size() + 1);\n      nextNon1[children[root].size()] = children[root].size();\n      for (int i = children[root].size() - 1; i >= 0; --i) {\n        if (range[children[root][i]].first == range[children[root][i]].second) {\n          nextNon1[i] = nextNon1[i + 1];\n        } else {\n          nextNon1[i] = i;\n        }\n      }\n      int prevNon1 = -1;\n      for (int i = 0; i < children[root].size(); ++i) {\n        int j = prevNon1 + 1;\n        int k = nextNon1[i + 1] - 1;\n        int i1 = range[children[root][i]].first;\n        int i2 = range[children[root][i]].second;\n        if (i1 != i2) {\n          prevNon1 = i;\n        }\n        int j1 = min(range[children[root][j]].first, range[children[root][k]].first);\n        int j2 = max(range[children[root][j]].second, range[children[root][k]].second);\n        int64 emin = INF;\n        int64 emax = INF;\n        for (int inner = 0; inner < 2; ++inner) {\n          int64 val = 0;\n          int from = inner == 0 ? i1 : i2;\n          if (j1 < i1) {\n            val += abs(x[answerPos[from]] - x[answerPos[j1]]) + abs(y[answerPos[from]] - y[answerPos[j1]]);\n            val += abs(x[answerPos[j2]] - x[answerPos[j1]]) + abs(y[answerPos[j2]] - y[answerPos[j1]]);\n          } else {\n            val += abs(x[answerPos[from]] - x[answerPos[j2]]) + abs(y[answerPos[from]] - y[answerPos[j2]]);\n          }\n          if (j == 0 && k + 1 == children[root].size()) {\n            val += extraIfMax;\n          }\n          if (inner == 0) {\n            emin = min(emin, val);\n          } else {\n            emax = min(emax, val);\n          }\n          val = 0;\n          if (j2 > i2) {\n            val += abs(x[answerPos[from]] - x[answerPos[j2]]) + abs(y[answerPos[from]] - y[answerPos[j2]]);\n            val += abs(x[answerPos[j2]] - x[answerPos[j1]]) + abs(y[answerPos[j2]] - y[answerPos[j1]]);\n          } else {\n            val += abs(x[answerPos[from]] - x[answerPos[j1]]) + abs(y[answerPos[from]] - y[answerPos[j1]]);\n          }\n          if (j == 0 && k == children[root].size() - 1) {\n            val += extraIfMin;\n          }\n          if (inner == 0) {\n            emin = min(emin, val);\n          } else {\n            emax = min(emax, val);\n          }\n        }\n        emin -= (k - j);\n        emax -= (k - j);\n        dfs(children[root][i], emin, emax);\n      }\n    }\n  }\n\n  vector<int64> x;\n  vector<int64> y;\n  vector<int64> answers;\n  vector<int> answerPos;\n\n  void solveOne(istream &in, ostream &out) {\n    in >> n;\n    x = vector<int64>(n);\n    y = vector<int64>(n);\n    for (int i = 0; i < n; ++i) {\n      in >> x[i] >> y[i];\n    }\n    vector<int> xc = compress(x);\n    vector<int> yc = compress(y);\n    answers = vector<int64>(n);\n    answerPos = vector<int>(n);\n    for (int i = 0; i < n; ++i) {\n      arr[xc[i]] = yc[i];\n      answerPos[yc[i]] = i;\n    }\n    int root = build();\n    dfs(root, 0, 0);\n    for (auto x : answers) {\n      out << x << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  Task solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <stack>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 2e5 + 20;\nconst ll inf = (ll) (1e18) + 7;\n\nint rx[N], ry[N];\n\nll dist(int i, int j) {\n  return abs(rx[i] - rx[j]) + abs(ry[i] - ry[j]);\n}\n                         \nnamespace Solver {\n    struct PermutationIntervalChecker {\n        std::vector<int> lg2;\n        std::vector<std::vector<int>> min, max;\n        int n;\n    public:\n        explicit PermutationIntervalChecker(const std::vector<int> &a) {\n            n = a.size();\n \n            lg2.resize(n + 1);\n            for(int i = 2; i <= n; i++) lg2[i] = lg2[i>>1] + 1;\n \n            min.resize(lg2[n]+1, std::vector<int>(n));\n            max.resize(lg2[n]+1, std::vector<int>(n));\n            min[0] = a;\n            max[0] = a;\n            for(int k = 0; k < lg2[n]; k++) {\n                for(int i = 0; i + (2 << k) - 1 < n; i++) {\n                    min[k + 1][i] = std::min(min[k][i], min[k][i + (1<<k)]);\n                    max[k + 1][i] = std::max(max[k][i], max[k][i + (1<<k)]);\n                }\n            }\n        }\n \n        bool is_interesting (int l, int r) {\n            int k = lg2[r - l + 1];\n            return std::max(max[k][l], max[k][r - (1<<k) + 1]) - std::min(min[k][l], min[k][r - (1<<k) + 1]) == r - l;\n        }\n    };\n \n    class LazySegmentTree {\n        typedef int T1; // Change this to what you need\n        typedef int T2; // Change this to what you need\n        T1 id = 0, initval = 0;\n        T2 unused = 0;\n        T1 combine(T1 a, T1 b){ return std::min(a, b); }\n        T2 combineL(T2 a, T2 b){ return a + b; }\n        void unlazy(int i, int nl, int nr){ arr[i] += lazy[i]; }\n \n        int n; std::vector<T1> arr; std::vector<T2> lazy;\n        void propagate(int x, int nl, int nr){\n            if(lazy[x] == unused) return;\n            if(x < n){\n                lazy[x*2] = combineL(lazy[x*2], lazy[x]);\n                lazy[x*2+1] = combineL(lazy[x*2+1], lazy[x]);\n            }\n            unlazy(x, nl, nr);\n            lazy[x] = unused;\n        }\n        void update(int l,int r,T2 val,int x,int nl,int nr){\n            propagate(x, nl, nr);\n            if(r < nl || nr < l) return;\n            if(l <= nl && nr <= r){\n                lazy[x] = combineL(lazy[x], val);\n                propagate(x, nl, nr);\n                return;\n            }\n            int mid = (nl + nr) / 2;\n            update(l,r,val,x*2,nl,mid);\n            update(l,r,val,x*2+1,mid+1,nr);\n            arr[x] = combine(arr[x*2], arr[x*2+1]);\n        }\n        T1 query(int l,int r,int x,int nl,int nr){\n            propagate(x, nl, nr);\n            if(r < nl || nr < l) return id;\n            if(l <= nl && nr <= r) return arr[x];\n            int mid = (nl + nr) / 2;\n            return combine(query(l,r,x*2,nl,mid),\n                           query(l,r,x*2+1,mid+1,nr));\n        }\n        int find_zero(int x, int nl, int nr) {\n            if(nl == nr) return nl;\n            propagate(x, nl, nr);\n            int mid = (nl + nr) / 2;\n            if(arr[x*2] + lazy[x*2] == 0) {\n                return find_zero(x*2, nl, mid);\n            }else {\n                return find_zero(x*2+1, mid+1, nr);\n            }\n \n        }\n    public:\n        explicit LazySegmentTree(int sz) {\n            n = 1;\n            while(n < sz) n *= 2;\n            arr.resize(n*2, initval); lazy.resize(n*2, unused);\n        }\n        void update(int l,int r,T2 val)\n        {update(l,r,val,1,0,n-1);}\n        int find_zero() {\n            return find_zero(1, 0, n-1);\n        }\n    };\n \n    enum NODE_TYPE { ANALYTIC, CONVERGE };\n    struct Node {\n        int l, r, m;\n        NODE_TYPE type = ANALYTIC;\n        std::vector<std::reference_wrapper<Node>> children;\n    };\n \n    class PermutationTree {\n        std::vector<Node> tree;\n        std::vector<int> id;\n        int n;\n        Node root;\n \n        void dfs (Node &node, ll left, ll right, vector <ll> &ans, int x, int y) {\n          if (node.l == node.r) {\n            ans[node.l] = min(left, right) - (y - x);\n            return;\n          } else {\n            if (node.type != CONVERGE) {\n              for (Node &child : node.children) {\n                dfs(child, 0, 0, ans, child.l, child.r);\n              }\n            } else {\n              vector <pair <int, int> > t;\n              for (Node &child : node.children) {\n                t.push_back({child.l, child.r});\n              }\n              vector <int> vl(t.size()), vr(t.size());\n              for (int i = 0; i < (int) t.size(); i++) {\n                if (i && t[i - 1].first == t[i - 1].second) {\n                  vl[i] = vl[i - 1];\n                } else {\n                  vl[i] = i;\n                }\n              }\n              for (int i= (int) t.size() - 1; i >= 0; i--) {\n                if (i + 1 < (int) t.size() && t[i + 1].first == t[i + 1].second) {\n                  vr[i] = vr[i + 1];\n                } else {\n                  vr[i] = i;\n                }\n              }\n              for (int i = 0; i < (int) t.size(); i++) {\n                int l = vl[i], r = vr[i];\n                bool complete = (l == 0 && r == (int) t.size() - 1);\n                if (!left && !right) complete = false;\n                ll left_ans = inf, right_ans = inf;\n                {\n                  {\n                    ll val = dist(t[l].first, t[i].first) + ((r != i) || complete) * dist(t[l].first, t[r].second);\n                    if (complete) val += right;\n                    left_ans = min(left_ans, val);\n                  }\n                  {\n                    ll val = dist(t[r].second, t[i].first) + ((l != i) || complete) * dist(t[l].first, t[r].second);\n                    if (complete) val += left;\n                    left_ans = min(left_ans, val);\n                  }\n                }\n                {\n                  {\n                    ll val = dist(t[l].first, t[i].second) + ((r != i) || complete) * dist(t[l].first, t[r].second);\n                    if (complete) val += right;\n                    right_ans = min(right_ans, val);\n                  }\n                  {\n                    ll val = dist(t[r].second, t[i].second) + ((l != i) || complete) * dist(t[l].first, t[r].second);\n                    if (complete) val += left;\n                    right_ans = min(right_ans, val);\n                  }\n                }\n                if (complete) {\n                  if (r == i) {\n                    left_ans = min(left_ans, left + dist(t[l].first, t[i].first));\n                    right_ans = min(right_ans, left + dist(t[l].first, t[i].second));\n                  }\n                  if (l == i) {\n                    left_ans = min(left_ans, right + dist(t[i].first, t[r].second));\n                    right_ans = min(right_ans, right + dist(t[i].second, t[r].second));\n                  }\n                }\n                if (complete)\n                  dfs(node.children[i], left_ans, right_ans, ans, x, y);\n                else\n                  dfs(node.children[i], left_ans, right_ans, ans, t[l].first, t[r].second);\n              }\n            }\n          }\n        }\n        /*\n            long long ret = 0;\n \n            for(Node &child : node.children) {\n                ret += dfs(child, x);\n            }\n \n            if(node.type == CONVERGE) {\n                struct State { int cl, cr, len; };\n                std::vector<State> states;\n                int cl = 0, cr = node.children.size() - 1;\n                for(Node &child : node.children) {\n                    states.push_back({ cl, cr, child.r - child.l + 1 });\n                    cl += 1;\n                    cr -= 1;\n                }\n \n                for(int i = 0, j = 0, len = 0, sumcl = 0; j < states.size(); j++) {\n                    len += states[j].len;\n                    while(i <= j && len >= x) {\n                        len -= states[i].len;\n                        (sumcl += states[i].cl) %= MOD;\n                        i++;\n                    }\n                    ret += 1ll * sumcl * states[j].cr % MOD;\n                }\n            }\n            ret %= MOD;\n            return ret;\n        }\n        */\n    public:\n        explicit PermutationTree (const std::vector<int> &p) {\n            n = p.size();\n \n            PermutationIntervalChecker checker(p);\n            LazySegmentTree seg(n); // For each j, contains {max(p[j..i]) - min(p[j..i])} - {i-j}\n \n            std::stack<int> stkMin, stkMax;\n            std::stack<std::reference_wrapper<Node>> stkPath;\n \n            tree.reserve(n*2);\n            id.resize(n);\n            for(int i = 0; i < n; i++) {\n                auto processHistogram = [&](std::stack<int> &stk, int coef) {\n                    while(!stk.empty() && (p[i] - p[stk.top()]) * coef > 0) {\n                        int r = stk.top(); stk.pop();\n                        int l = (stk.empty() ? -1 : stk.top()) + 1;\n                        seg.update(l, r, -coef * p[r]);\n                    }\n                    int l = (stk.empty() ? -1 : stk.top()) + 1;\n                    seg.update(l, i, coef * p[i]);\n                    stk.push(i);\n                };\n                processHistogram(stkMax, +1);\n                processHistogram(stkMin, -1);\n \n                id[i] = tree.size();\n                tree.push_back({i, i});\n \n                int le = seg.find_zero();\n                std::reference_wrapper<Node> cur = tree.back();\n \n                while(!stkPath.empty() && stkPath.top().get().l >= le) {\n                    Node &node = stkPath.top();\n                    if(node.l < le) break;\n \n                    if(node.type == CONVERGE && checker.is_interesting(node.m, i)) {\n                        node.r = i;\n                        node.children.push_back(cur);\n                        cur = node;\n                        stkPath.pop();\n                    }else if(checker.is_interesting(node.l, i)) {\n                        tree.push_back({node.l, i, cur.get().l, CONVERGE, {node, cur}});\n                        stkPath.pop();\n                        cur = tree.back();\n                    }else {\n                        tree.push_back({});\n                        Node &new_node = tree.back();\n                        new_node.children.push_back(cur);\n                        do {\n                            new_node.children.push_back(stkPath.top());\n                            stkPath.pop();\n                        }while(!stkPath.empty() && !checker.is_interesting(stkPath.top().get().l, i));\n \n                        assert(!stkPath.empty());\n                        new_node.l = stkPath.top().get().l;\n                        new_node.r = i;\n                        new_node.type = ANALYTIC;\n                        new_node.children.push_back(stkPath.top());\n                        stkPath.pop();\n                        cur = new_node;\n                    }\n                }\n \n                stkPath.push(cur);\n                seg.update(0, i, -1);\n            }\n            while(stkPath.size() > 1) stkPath.pop();\n            assert(stkPath.size() == 1);\n            root = stkPath.top();\n        }\n \n        vector <ll> solve() {\n          vector <ll> ans(n);\n          dfs(root, 0, 0, ans, 0, n - 1);\n          return ans;\n        }\n    };\n \n    vector <ll> solve (const std::vector<int>& p) {\n        PermutationTree tree(p);\n        return tree.solve();\n    }\n};\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <pair <int, int> > e;\n  vector <int> ord;\n  vector <int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    e.push_back({x[i], i});\n    ord.push_back(y[i]);\n  }\n  sort(ord.begin(), ord.end());\n  sort(e.begin(), e.end());\n  vector <int> p(n);\n  for (int i= 0; i < n; i++) {\n    rx[i] = e[i].first;\n    ry[i] = y[e[i].second];\n    p[i] = lower_bound(ord.begin(), ord.end(), y[e[i].second]) - ord.begin();\n  }\n  auto s = Solver::solve(p);\n  vector <ll> ret(n);\n  for (int i = 0; i < n; i++) {\n    ret[e[i].second] = s[i];\n  }\n  for (int i = 0; i < n; i++) cout << ret[i] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\n\nstruct point {\n    int x,y,id;\n};\npoint p[maxn];\nint ny[maxn],idy[maxn];\n\nint n;\n\nint l[maxn],r[maxn];\n\nint sx[maxn];\nint fa[maxn];\nvector<int>ed[maxn]; int rd[maxn];\n\nll dp[maxn][2][2];\n\nint rk[maxn],tp;\nll ans[maxn];\n\ninline void get_rk()\n{\n    queue<int>q;\n    REP(i,1,n)if(fa[i]==i && !rd[i])q.push(i);\n    while(!q.empty())\n    {\n\tint u=q.front();q.pop();\n\trk[++tp]=u;\n\tfor(int v:ed[u])\n\t    if(!(--rd[v]))\n\t\tq.push(v);\n    }\n}\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n)p[i]=(point){read(),read(),i};\n    sort(p+1,p+n+1,[](point a,point b){ return a.x<b.x;});\n    REP(i,1,n)sx[i]=p[i].y; sort(sx+1,sx+n+1);\n    REP(i,1,n)ny[i]=lower_bound(sx+1,sx+n+1,p[i].y)-sx,idy[ny[i]]=i;\n    REP(i,1,n)fa[i]=i,l[i]=i,r[i]=i;\n    REP(i,1,n-1)\n    {\n\tif(abs(ny[i]-ny[i+1])==1)fa[i+1]=fa[i],r[fa[i+1]]=i+1;\n\telse {\n\t    int x=ny[i]+1;\n\t    if(idy[x]<i) ed[i+1].push_back(fa[i]),rd[fa[i]]++;\n\t    else ed[fa[i]].push_back(i+1),rd[i+1]++;\n\t}\n    }\n    DREP(i,n,1)l[i]=l[fa[i]],r[i]=r[fa[i]];\n    get_rk();\n}\n\ninline int Dis(int i,int j){ return abs(p[j].x-p[i].x)+abs(p[j].y-p[i].y);}\n\ninline void doing()\n{\n    REP(th,1,tp)\n    {\n\tint u=rk[th];\n\tint reml=l[u],remr=r[u];\n\tint &lx=l[u],&rx=r[u];\n\t\n\tdp[u][0][1]=l[u]==r[u]?0:Dis(l[u],r[u]);\n\tdp[u][1][0]=l[u]==r[u]?0:Dis(r[u],l[u]);\n\tdp[u][0][0]=dp[u][1][1]=inf;\n\t\n\tint ly=min(ny[lx],ny[lx]),ry=max(ny[lx],ny[lx]);\n\tint L,R;\n\tdo{\n\t    int le=lx>1 && (ly-1==ny[lx-1] || ny[lx-1]==ry+1),re=rx<n && (ly-1==ny[rx+1] || ry+1==ny[rx+1]);\n\t    L=fa[lx-1],R=rx+1;\n\t    if(!le && !re)break;\n\t    if(le && re)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]+Dis(r[rx+1],lx-1)+dp[L][1][0]);\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]+Dis(l[lx-1],rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tlx=l[lx-1]; rx=r[rx+1];\n\t    }\n\t    else if(le)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tlx=l[lx-1];\n\t    }else\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\trx=r[rx+1];\n\t    \n\t    }\n\t}while(1);\n\tREP(j,reml,remr)\n\t{\n\t    if(j==reml)ans[p[j].id]=min(dp[u][0][0],dp[u][0][1]);\n\t    else if(j==remr)ans[p[j].id]=min(dp[u][1][0],dp[u][1][1]);\n\t    else {\n\t\tREP(op,0,1)ans[p[j].id]=min(dp[u][0][op]+Dis(j,reml),dp[u][1][op]+Dis(j,remr));\n\t    }\n\t    ans[p[j].id]-=rx-lx;\n\t}\n    }\n    REP(i,1,n)printf(\"%lld\\n\",ans[i]);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 200005;\n\nconst long long INF = 0x3f3f3f3f3f3f3f3fll;\n\nint n;\n\nstruct Node {\n\tint x, y, id;\n\t\n\tbool operator < (const Node &rhs) const {\n\t\treturn x < rhs.x;\n\t}\n} a[N];\n\nlong long ans[N];\n\nstd::vector<int> Y;\n\nint myabs(int a) {\n\treturn a > 0 ? a : -a;\n}\n\nint dist(int i, int j) {\n\treturn myabs(a[i].x - a[j].x) + myabs(a[i].y - a[j].y);\n}\n\nvoid upd(long long &a, long long b) {\n\ta = std::min(a, b);\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i].x), read(a[i].y);\n\t\ta[i].id = i;\n\t\tY.push_back(a[i].y);\n\t\tans[i] = -1;\n\t}\n\tstd::sort(a + 1, a + 1 + n);\n\tY.push_back(0), Y.push_back(1000001);\n\tstd::sort(Y.begin(), Y.end());\n\n\tfor (int st = 1; st <= n; ++st) {\n\t\tif (~ans[a[st].id]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint y = std::lower_bound(Y.begin(), Y.end(), a[st].y) - Y.begin();\n\t\tint L = st, R = st;\n\t\tint Ly = y - 1, Ry = y + 1;\n\n\t\tint lst = -1;\n\t\tstd::vector<std::pair<int, int>> A;\n\n\t\twhile (1) {\n\t\t\tbool flag = 0;\n\t\t\tfor (int i : {L - 1, R + 1}) {\n\t\t\t\tif (1 <= i && i <= n) {\n\t\t\t\t\tbool fL = Y[Ly] == a[i].y;\n\t\t\t\t\tbool fR = Y[Ry] == a[i].y;\n\t\t\t\t\tif (fL || fR) {\n\t\t\t\t\t\tint d = fL ^ (i == L - 1);\n\t\t\t\t\t\tif (lst == -1) {\n\t\t\t\t\t\t\tlst = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lst != d) {\n\t\t\t\t\t\t\tA.push_back({L, R});\n\t\t\t\t\t\t\tlst = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (fL) {\n\t\t\t\t\t\t\t--Ly;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++Ry;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i == L - 1) {\n\t\t\t\t\t\t\t--L;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++R;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (A.empty() || A.back() != std::make_pair(L, R)) {\n\t\t\tA.push_back({L, R});\n\t\t}\n\n\t\tint t = A.size();\n\t\tstd::vector<std::vector<long long>> f(t, std::vector<long long>(2, INF));\n\t\tf[t - 1][0] = f[t - 1][1] = 0;\n\t\tfor (int i = t - 1; i; --i) {\n\t\t\tint L1 = A[i].first;\n\t\t\tint L2 = A[i - 1].first;\n\t\t\tint R1 = A[i - 1].second;\n\t\t\tint R2 = A[i].second;\n\t\t\tupd(f[i - 1][0], f[i][0] + (R1 == R2 ? dist(L1, L2) : dist(L2, R2) + dist(L1, R2)));\n\t\t\tupd(f[i - 1][1], f[i][0] + dist(R1, R2) + dist(L1, R2));\n\t\t\tupd(f[i - 1][0], f[i][1] + dist(L1, L2) + dist(L1, R2));\n\t\t\tupd(f[i - 1][1], f[i][1] + (L1 == L2 ? dist(R1, R2) : dist(L1, R1) + dist(L1, R2)));\n\t\t}\n\t\t// if (L == 1 && R == 5) {\n\t\t// \tdebug(\"%lld %lld\\n\", f[0][0], f[0][1]);\n\t\t// }\n\t\t\n\t\tint l = A[0].first, r = A[0].second;\n\t\tfor (int i = l; i <= r; ++i) {\n\t\t\tans[a[i].id] = std::min(f[0][0] + dist(l, r) + dist(r, i), f[0][1] + dist(l, r) + dist(l, i)) - (R - L);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tprint(ans[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define pb push_back\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\n\nstruct node{\n  int s,e,m;\n  ll val=0,lazy=0;\n  node *l,*r;\n\n  node (int _s,int _e){\n    s=_s,e=_e,m=s+e>>1;\n\n    if (s!=e){\n      l=new node(s,m);\n      r=new node(m+1,e);\n    }\n  }\n\n  void propo(){\n    if (lazy){\n      val+=lazy;\n      if (s!=e){\n        l->lazy+=lazy;\n        r->lazy+=lazy;\n      }\n      lazy=0;\n    }\n  }\n\n  void update(int i,int j,ll k){\n    if (s==i && e==j) lazy+=k;\n    else{\n      if (j<=m) l->update(i,j,k);\n      else if (m<i) r->update(i,j,k);\n      else l->update(i,m,k),r->update(m+1,j,k);\n\n      l->propo(),r->propo();\n      val=min(l->val,r->val);\n    }\n  }\n\n  ll query(int i,int j){\n    propo();\n\n    if (s==i && e==j) return val;\n    else if (j<=m) return l->query(i,j);\n    else if (m<i) return r->query(i,j);\n    else return min(l->query(i,m),r->query(m+1,j));\n  }\n};\n\nint n,q;\nint arr[200005];\nii range[400005];\nii span[400005];\nvector<int> children[400005];\nint parent[400005];\nint typ[400005];\nint idx; //new index to assign to nodes\n\nii get_range(ii i,ii j){\n  return ii(min(i.fi,j.fi),max(i.se,j.se));\n}\n\nvoid add_edge(int u,int v){ //u is parent of v\n  parent[v]=u;\n  children[u].push_back(v);\n}\n\nbool adj(int i,int j){\n  return range[i].se==range[j].fi-1;\n}\n\nint length(int i){\n  return range[i].se-range[i].fi+1;\n}\n\nint build(){\n  idx=n;\n  memset(parent,-1,sizeof(parent));\n\n  node *root=new node(0,200005);\n  vector<int> mx={-1},mn={-1}; //stacks for max and min\n\n  vector<int> nodes; //stack of cut and join nodes\n\n  rep(x,0,n){\n    //update Q values\n    while (mx.back()!=-1 && arr[mx.back()]<arr[x]){\n      int temp=mx.back();\n      mx.pop_back();\n      root->update(mx.back()+1,temp,arr[x]-arr[temp]);\n    }\n    mx.push_back(x);\n\n    while (mn.back()!=-1 && arr[mn.back()]>arr[x]){\n      int temp=mn.back();\n      mn.pop_back();\n      root->update(mn.back()+1,temp,arr[temp]-arr[x]);\n    }\n    mn.push_back(x);\n\n    //handle stack updates\n    range[x]=ii(arr[x],arr[x]);\n    span[x]=ii(x,x);\n    int curr=x;\n\n    while (true){\n      if (!nodes.empty() && (adj(nodes.back(),curr) || adj(curr,nodes.back()))){\n        if ((adj(nodes.back(),curr) && typ[nodes.back()]==1)||\n            (adj(curr,nodes.back()) && typ[nodes.back()]==2)){\n          add_edge(nodes.back(),curr);\n\n          range[nodes.back()]=get_range(range[nodes.back()],range[curr]);\n          span[nodes.back()]=get_range(span[nodes.back()],span[curr]);\n\n          curr=nodes.back();\n          nodes.pop_back();\n        }\n        else{ //make a new join node\n          typ[idx]=(adj(nodes.back(),curr) ? 1:2);\n          add_edge(idx,nodes.back());\n          add_edge(idx,curr);\n\n          range[idx]=get_range(range[nodes.back()],range[curr]);\n          span[idx]=get_range(span[nodes.back()],span[curr]);\n\n          nodes.pop_back();\n          curr=idx++;\n        }\n      }\n      else if (x-(length(curr)-1) && root->query(0,x-length(curr))==0){\n        int len=length(curr);\n        ii r=range[curr];\n        ii s=span[curr];\n\n        add_edge(idx,curr);\n\n        do{\n          len+=length(nodes.back());\n          r=get_range(r,range[nodes.back()]);\n          s=get_range(s,span[nodes.back()]);\n\n          add_edge(idx,nodes.back());\n\n          nodes.pop_back();\n        } while (r.se-r.fi+1!=len);\n\n        reverse(all(children[idx]));\n        range[idx]=r;\n        span[idx]=s;\n        curr=idx++;\n      }\n      else{\n        break;\n      }\n    }\n\n    nodes.push_back(curr);\n    root->update(0,x,-1);\n  }\n\n  assert(nodes.size() == 1);\n  return nodes[0];\n}\n\nconstexpr int64 INF = (int64) 1e18;\n\n\nclass Task {\n public:\n  vector<int> compress(const vector<int64>& x) {\n    vector<int64> xs = x;\n    sort(all(xs));\n    vector<int> res(x.size());\n    for (int i = 0; i < x.size(); ++i) {\n      res[i] = lower_bound(all(xs), x[i]) - xs.begin();\n    }\n    return res;\n  }\n\n  void dfs(int root, int64 extraIfMin, int64 extraIfMax) {\n    if (range[root].first == range[root].second) {\n      answers[answerPos[range[root].first]] = min(extraIfMin, extraIfMax);\n      return;\n    }\n    if (typ[root] == 0) {\n      for (int x : children[root]) {\n        dfs(x, 0, 0);\n      }\n    } else {\n      for (int i = 0; i < children[root].size(); ++i) {\n        int j = i;\n        while (j > 0 && range[children[root][j - 1]].first == range[children[root][j - 1]].second) --j;\n        int k = i;\n        while (k + 1 < children[root].size() &&\n               range[children[root][k + 1]].first == range[children[root][k + 1]].second)\n          ++k;\n        int i1 = range[children[root][i]].first;\n        int i2 = range[children[root][i]].second;\n        int j1 = min(range[children[root][j]].first, range[children[root][k]].first);\n        int j2 = max(range[children[root][j]].second, range[children[root][k]].second);\n        int64 emin = INF;\n        int64 emax = INF;\n        for (int inner = 0; inner < 2; ++inner) {\n          int64 val = 0;\n          int from = inner == 0 ? i1 : i2;\n          if (j1 < i1) {\n            val += abs(x[answerPos[from]] - x[answerPos[j1]]) + abs(y[answerPos[from]] - y[answerPos[j1]]);\n            val += abs(x[answerPos[j2]] - x[answerPos[j1]]) + abs(y[answerPos[j2]] - y[answerPos[j1]]);\n          } else {\n            val += abs(x[answerPos[from]] - x[answerPos[j2]]) + abs(y[answerPos[from]] - y[answerPos[j2]]);\n          }\n          if (j == 0 && k + 1 == children[root].size()) {\n            val += extraIfMax;\n          }\n          if (inner == 0) {\n            emin = min(emin, val);\n          } else {\n            emax = min(emax, val);\n          }\n          val = 0;\n          if (j2 > i2) {\n            val += abs(x[answerPos[from]] - x[answerPos[j2]]) + abs(y[answerPos[from]] - y[answerPos[j2]]);\n            val += abs(x[answerPos[j2]] - x[answerPos[j1]]) + abs(y[answerPos[j2]] - y[answerPos[j1]]);\n          } else {\n            val += abs(x[answerPos[from]] - x[answerPos[j1]]) + abs(y[answerPos[from]] - y[answerPos[j1]]);\n          }\n          if (j == 0 && k == children[root].size() - 1) {\n            val += extraIfMin;\n          }\n          if (inner == 0) {\n            emin = min(emin, val);\n          } else {\n            emax = min(emax, val);\n          }\n        }\n        emin -= (k - j);\n        emax -= (k - j);\n        dfs(children[root][i], emin, emax);\n      }\n    }\n  }\n\n  vector<int64> x;\n  vector<int64> y;\n  vector<int64> answers;\n  vector<int> answerPos;\n\n  void solveOne(istream &in, ostream &out) {\n    in >> n;\n    x = vector<int64>(n);\n    y = vector<int64>(n);\n    for (int i = 0; i < n; ++i) {\n      in >> x[i] >> y[i];\n    }\n    vector<int> xc = compress(x);\n    vector<int> yc = compress(y);\n    answers = vector<int64>(n);\n    answerPos = vector<int>(n);\n    for (int i = 0; i < n; ++i) {\n      arr[xc[i]] = yc[i];\n      answerPos[yc[i]] = i;\n    }\n    int root = build();\n    dfs(root, 0, 0);\n    for (auto x : answers) {\n      out << x << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  Task solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <functional> \nusing namespace std;\n\nstruct Rook {\n    int x, y, id;\n    bool operator <(const Rook& other) const {\n        return x < other.x;\n    }\n};\n\nlong long hack;\n\ntemplate<class C>\nvoid min_self (C &a, C &&b) {\n    a = min(a, b);\n};\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    vector<Rook> rooks(n);\n    for(int i = 0; i < n; ++i) {\n        rooks[i].id = i;\n        scanf(\"%d%d\", &rooks[i].x, &rooks[i].y);\n    }\n    sort(rooks.begin(), rooks.end());\n    vector<int> ys{INT_MIN, INT_MAX}; // two sentinels for convenience\n    for(int i = 0; i < n; ++i) {\n        ys.push_back(rooks[i].y);\n    }\n    sort(ys.begin(), ys.end());\n    vector< pair<long long, long long> > answer(n, {-1, -1});\n    for(int start = 0; start < n; ++start) {\n        if(answer[rooks[start].id].first != -1) {\n            continue;\n        }\n\n        int start_y = lower_bound(ys.begin(), ys.end(), rooks[start].y) - ys.begin();\n        int y1 = start_y - 1, y2 = start_y + 1;\n\n        int L = start, R = start;\n        int prev_dir = -1;\n        vector< pair<int, int> > intervals;\n        while(true) {\n            bool found = false;\n            for(int i : {L - 1, R + 1}) {\n                if(0 <= i && i < n) {\n                    bool prev_y = (ys[y1] == rooks[i].y);\n                    bool next_y = (ys[y2] == rooks[i].y);\n                    if(prev_y || next_y) {\n                        int direction = (prev_y == (i == L - 1));\n                        if(prev_dir == -1) {\n                            prev_dir = direction;\n                        }\n                        if(prev_dir != direction) {\n                            intervals.emplace_back(L, R);\n                            prev_dir = direction;\n                        }\n                        prev_y ? y1-- : y2++;\n                        i == L-1 ? L-- : R++;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if(!found) {\n                break;\n            }\n        }\n        if(intervals.empty() || intervals.back() != make_pair(L, R)) {\n            intervals.emplace_back(L, R);\n        }\n        const int s = intervals.size();\n\n        const long long INF = 1e18L + 5;\n        \n        auto f = [&] (int i, int j) {\n            return abs(rooks[i].x - rooks[j].x) + abs(rooks[i].y - rooks[j].y);\n        };\n        \n        vector< vector<long long> > dp(s, vector<long long>(2, INF));\n        dp[s-1][0] = dp[s-1][1] = 0;\n        for(int who = s - 1; who >= 1; --who) {\n            int L1 = intervals[who].first;\n            int L2 = intervals[who-1].first;\n            int R1 = intervals[who-1].second;\n            int R2 = intervals[who].second;\n            hack += (long long) (L2 - L1) * (R2 - R1);\n            min_self(dp[who-1][0], dp[who][0] + (R1 == R2 ? f(L1, L2) : f(L1, R2) + f(R2, L2)));\n            min_self(dp[who-1][1], dp[who][0] + f(L1, R2) + f(R2, R1));\n            min_self(dp[who-1][0], dp[who][1] + f(R2, L1) + f(L1, L2));\n            min_self(dp[who-1][1], dp[who][1] + (L1 == L2 ? f(R1, R2) : f(R2, L1) + f(L1, R1)));\n        }\n        int low = intervals[0].first, high = intervals[0].second;\n        for(int i = low; i <= high; ++i) {\n            answer[rooks[i].id] = {\n                R - L,\n                min(dp[0][0] + f(low, high) + f(high, i), dp[0][1] + f(high, low) + f(low, i))\n            };\n        }\n    }\n    for(auto p : answer) {\n        printf(\"%lld\\n\", p.second - p.first);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define fi first\n#define se second\nconst int N=2e5+5;\nconst long long inf=1e18;\npair< pair<int,int> , int > a[N];\nint n,x[N],y[N],l[N],r[N];\nmap<int,long long> f[2][N];\nlong long dis(pair<int,int> i,pair<int,int> j){\n\treturn abs(x[i.fi]-x[j.fi])+abs(y[i.se]-y[j.se]);\n}\nlong long dfs(int mn,int mx,int l,int r,int k){\n\tif(f[k][l].count(r)) return f[k][l][r];\n\tint L=::l[l-1],R=::r[r+1];long long ans=inf;\n\tif(l>1 && (a[l-1].fi.se==mn-1 || a[l-1].fi.se==mx+1))\n\t\tans=min(ans,dfs(min(a[L].fi.se,mn),max(a[L].fi.se,mx),L,r,0)+dis(a[L].fi,k==0?a[l].fi:a[r].fi));\n\tif(r<n && (a[r+1].fi.se==mn-1 || a[r+1].fi.se==mx+1))\n\t\tans=min(ans,dfs(min(a[R].fi.se,mn),max(a[R].fi.se,mx),l,R,1)+dis(a[R].fi,k==0?a[l].fi:a[r].fi));\n\tf[k][l][r]=(ans==inf?l-r:ans);\n\treturn f[k][l][r];\n}\nlong long ans[N];\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>x[i]>>y[i],a[i]=make_pair(make_pair(x[i],y[i]),i);\n\tsort(a+1,a+n+1);\n\tsort(x+1,x+n+1);\n\tsort(y+1,y+n+1);\n\tfor(int i=1;i<=n;++i)\n\t\ta[i].fi.fi=lower_bound(x+1,x+n+1,a[i].fi.fi)-x,\n\t\ta[i].fi.se=lower_bound(y+1,y+n+1,a[i].fi.se)-y;\n\tl[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t\tif(abs(a[i-1].fi.se-a[i].fi.se)==1) l[i]=l[i-1];\n\t\telse l[i]=i;\n\tr[n]=n;\n\tfor(int i=n-1;i>=1;--i)\n\t\tif(abs(a[i+1].fi.se-a[i].fi.se)==1) r[i]=r[i+1];\n\t\telse r[i]=i;\n\t//for(int i=1;i<=n;++i)cout<<a[i].fi.fi<<\" \"<<a[i].fi.se<<endl;\n\tfor(int i=1;i<=n;++i)\n\t\tans[a[i].se]=dfs(a[i].fi.se,a[i].fi.se,i,i,0);\n\tfor(int i=1;i<=n;++i)\n\t\tcout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define pb push_back\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\n\nstruct node{\n  int s,e,m;\n  ll val=0,lazy=0;\n  node *l,*r;\n\n  node (int _s,int _e){\n    s=_s,e=_e,m=s+e>>1;\n\n    if (s!=e){\n      l=new node(s,m);\n      r=new node(m+1,e);\n    }\n  }\n\n  void propo(){\n    if (lazy){\n      val+=lazy;\n      if (s!=e){\n        l->lazy+=lazy;\n        r->lazy+=lazy;\n      }\n      lazy=0;\n    }\n  }\n\n  void update(int i,int j,ll k){\n    if (s==i && e==j) lazy+=k;\n    else{\n      if (j<=m) l->update(i,j,k);\n      else if (m<i) r->update(i,j,k);\n      else l->update(i,m,k),r->update(m+1,j,k);\n\n      l->propo(),r->propo();\n      val=min(l->val,r->val);\n    }\n  }\n\n  ll query(int i,int j){\n    propo();\n\n    if (s==i && e==j) return val;\n    else if (j<=m) return l->query(i,j);\n    else if (m<i) return r->query(i,j);\n    else return min(l->query(i,m),r->query(m+1,j));\n  }\n};\n\nint n,q;\nint arr[200005];\nii range[400005];\nii span[400005];\nvector<int> children[400005];\nint parent[400005];\nint typ[400005];\nint idx; //new index to assign to nodes\n\nii get_range(ii i,ii j){\n  return ii(min(i.fi,j.fi),max(i.se,j.se));\n}\n\nvoid add_edge(int u,int v){ //u is parent of v\n  parent[v]=u;\n  children[u].push_back(v);\n}\n\nbool adj(int i,int j){\n  return range[i].se==range[j].fi-1;\n}\n\nint length(int i){\n  return range[i].se-range[i].fi+1;\n}\n\nint build(){\n  idx=n;\n  memset(parent,-1,sizeof(parent));\n\n  node *root=new node(0,200005);\n  vector<int> mx={-1},mn={-1}; //stacks for max and min\n\n  vector<int> nodes; //stack of cut and join nodes\n\n  rep(x,0,n){\n    //update Q values\n    while (mx.back()!=-1 && arr[mx.back()]<arr[x]){\n      int temp=mx.back();\n      mx.pop_back();\n      root->update(mx.back()+1,temp,arr[x]-arr[temp]);\n    }\n    mx.push_back(x);\n\n    while (mn.back()!=-1 && arr[mn.back()]>arr[x]){\n      int temp=mn.back();\n      mn.pop_back();\n      root->update(mn.back()+1,temp,arr[temp]-arr[x]);\n    }\n    mn.push_back(x);\n\n    //handle stack updates\n    range[x]=ii(arr[x],arr[x]);\n    span[x]=ii(x,x);\n    int curr=x;\n\n    while (true){\n      if (!nodes.empty() && (adj(nodes.back(),curr) || adj(curr,nodes.back()))){\n        if ((adj(nodes.back(),curr) && typ[nodes.back()]==1)||\n            (adj(curr,nodes.back()) && typ[nodes.back()]==2)){\n          add_edge(nodes.back(),curr);\n\n          range[nodes.back()]=get_range(range[nodes.back()],range[curr]);\n          span[nodes.back()]=get_range(span[nodes.back()],span[curr]);\n\n          curr=nodes.back();\n          nodes.pop_back();\n        }\n        else{ //make a new join node\n          typ[idx]=(adj(nodes.back(),curr) ? 1:2);\n          add_edge(idx,nodes.back());\n          add_edge(idx,curr);\n\n          range[idx]=get_range(range[nodes.back()],range[curr]);\n          span[idx]=get_range(span[nodes.back()],span[curr]);\n\n          nodes.pop_back();\n          curr=idx++;\n        }\n      }\n      else if (x-(length(curr)-1) && root->query(0,x-length(curr))==0){\n        int len=length(curr);\n        ii r=range[curr];\n        ii s=span[curr];\n\n        add_edge(idx,curr);\n\n        do{\n          len+=length(nodes.back());\n          r=get_range(r,range[nodes.back()]);\n          s=get_range(s,span[nodes.back()]);\n\n          add_edge(idx,nodes.back());\n\n          nodes.pop_back();\n        } while (r.se-r.fi+1!=len);\n\n        reverse(all(children[idx]));\n        range[idx]=r;\n        span[idx]=s;\n        curr=idx++;\n      }\n      else{\n        break;\n      }\n    }\n\n    nodes.push_back(curr);\n    root->update(0,x,-1);\n  }\n\n  assert(nodes.size() == 1);\n  return nodes[0];\n}\n\nconstexpr int64 INF = (int64) 1e18;\n\n\nclass Task {\n public:\n  vector<int> compress(const vector<int64>& x) {\n    vector<int64> xs = x;\n    sort(all(xs));\n    vector<int> res(x.size());\n    for (int i = 0; i < x.size(); ++i) {\n      res[i] = lower_bound(all(xs), x[i]) - xs.begin();\n    }\n    return res;\n  }\n\n  void dfs(int root, int64 extraIfMin, int64 extraIfMax) {\n    if (range[root].first == range[root].second) {\n      answers[answerPos[range[root].first]] = min(extraIfMin, extraIfMax);\n      return;\n    }\n    if (typ[root] == 0) {\n      for (int x : children[root]) {\n        dfs(x, 0, 0);\n      }\n    } else {\n      for (int i = 0; i < children[root].size(); ++i) {\n        int j = i;\n        while (j > 0 && range[children[root][j - 1]].first == range[children[root][j - 1]].second) --j;\n        int k = i;\n        while (k + 1 < children[root].size() &&\n               range[children[root][k + 1]].first == range[children[root][k + 1]].second)\n          ++k;\n        int i1 = range[children[root][i]].first;\n        int j1 = typ[children[root][j]] == 1 ? range[children[root][j]].first : range[children[root][j]].second;\n        int k1 = typ[children[root][k]] == 1 ? range[children[root][k]].second : range[children[root][k]].first;\n        int64 emin1 = 0;\n        if (j < i) {\n          emin1 += abs(x[answerPos[i1]] - x[answerPos[j1]]) + abs(y[answerPos[i1]] - y[answerPos[j1]]);\n          emin1 += abs(x[answerPos[k1]] - x[answerPos[j1]]) + abs(y[answerPos[k1]] - y[answerPos[j1]]);\n        } else {\n          emin1 += abs(x[answerPos[i1]] - x[answerPos[k1]]) + abs(y[answerPos[i1]] - y[answerPos[k1]]);\n        }\n        if (j == 0 && k + 1 == children[root].size()) {\n          emin1 += typ[root] == 1 ? extraIfMax : extraIfMin;\n        }\n        int64 emin2 = 0;\n        if (k > i) {\n          emin2 += abs(x[answerPos[i1]] - x[answerPos[k1]]) + abs(y[answerPos[i1]] - y[answerPos[k1]]);\n          emin2 += abs(x[answerPos[k1]] - x[answerPos[j1]]) + abs(y[answerPos[k1]] - y[answerPos[j1]]);\n        } else {\n          emin2 += abs(x[answerPos[i1]] - x[answerPos[j1]]) + abs(y[answerPos[i1]] - y[answerPos[j1]]);\n        }\n        if (j == 0 && k == children[root].size() - 1) {\n          emin2 += typ[root] == 1 ? extraIfMin : extraIfMax;\n        }\n        int64 emin = min(emin1, emin2) - (k - j);\n        i1 = range[children[root][i]].second;\n        int64 emax1 = 0;\n        if (j < i) {\n          emax1 += abs(x[answerPos[i1]] - x[answerPos[j1]]) + abs(y[answerPos[i1]] - y[answerPos[j1]]);\n          emax1 += abs(x[answerPos[k1]] - x[answerPos[j1]]) + abs(y[answerPos[k1]] - y[answerPos[j1]]);\n        } else {\n          emax1 += abs(x[answerPos[i1]] - x[answerPos[k1]]) + abs(y[answerPos[i1]] - y[answerPos[k1]]);\n        }\n        if (j == 0 && k + 1 == children[root].size()) {\n          emax1 += typ[root] == 1 ? extraIfMax : extraIfMin;\n        }\n        int64 emax2 = 0;\n        if (k > i) {\n          emax2 += abs(x[answerPos[i1]] - x[answerPos[k1]]) + abs(y[answerPos[i1]] - y[answerPos[k1]]);\n          emax2 += abs(x[answerPos[k1]] - x[answerPos[j1]]) + abs(y[answerPos[k1]] - y[answerPos[j1]]);\n        } else {\n          emax2 += abs(x[answerPos[i1]] - x[answerPos[j1]]) + abs(y[answerPos[i1]] - y[answerPos[j1]]);\n        }\n        if (j == 0 && k + 1 == children[root].size())  {\n          emax2 += typ[root] == 1 ? extraIfMin : extraIfMax;\n        }\n        int64 emax = min(emax1, emax2) - (k - j);\n        dfs(children[root][i], emin, emax);\n      }\n    }\n  }\n\n  vector<int64> x;\n  vector<int64> y;\n  vector<int64> answers;\n  vector<int> answerPos;\n\n  void solveOne(istream &in, ostream &out) {\n    in >> n;\n    x = vector<int64>(n);\n    y = vector<int64>(n);\n    for (int i = 0; i < n; ++i) {\n      in >> x[i] >> y[i];\n    }\n    vector<int> xc = compress(x);\n    vector<int> yc = compress(y);\n    answers = vector<int64>(n);\n    answerPos = vector<int>(n);\n    for (int i = 0; i < n; ++i) {\n      arr[xc[i]] = yc[i];\n      answerPos[yc[i]] = i;\n    }\n    int root = build();\n    dfs(root, 0, 0);\n    for (auto x : answers) {\n      out << x << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  Task solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ninline int read()\n{\n    int s=0,f=1; char ch=getchar();\n    while(!isdigit(ch) && ch!='-')ch=getchar();\n    if(ch=='-')ch=getchar(),f=-1;\n    while(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n    return ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\n\nstruct point {\n    int x,y,id;\n};\npoint p[maxn];\nint ny[maxn],idy[maxn];\nint to[maxn];\n\nint n;\n\nint l[maxn],r[maxn];\n\nint sx[maxn];\nint fa[maxn];\nvector<int>ed[maxn]; int rd[maxn];\n\nll dp[maxn][2][2];\n\nint rk[maxn],tp;\nll ans[maxn];\n\ninline void get_rk()\n{\n    queue<int>q;\n    REP(i,1,n)if(fa[i]==i && !rd[i])q.push(i);\n    while(!q.empty())\n    {\n\tint u=q.front();q.pop();\n\trk[++tp]=u;\n\tfor(int v:ed[u])\n\t    if(!(--rd[v]))\n\t\tq.push(v);\n    }\n}\n\ninline void init()\n{\n    n=read();\n    REP(i,1,n)p[i]=(point){read(),read(),i};\n    sort(p+1,p+n+1,[](point a,point b){ return a.x<b.x;});\n    REP(i,1,n)sx[i]=p[i].y; sort(sx+1,sx+n+1);\n    REP(i,1,n)ny[i]=lower_bound(sx+1,sx+n+1,p[i].y)-sx,idy[ny[i]]=i;\n    REP(i,1,n)fa[i]=i,l[i]=i,r[i]=i;\n    REP(i,1,n)to[p[i].id]=i;\n    REP(i,1,n-1)\n    {\n\tif(abs(ny[i]-ny[i+1])==1)fa[i+1]=fa[i],r[fa[i+1]]=i+1;\n\telse {\n\t    int x=ny[i]+(ny[i]<ny[i+1]?1:-1);\n\t    if(idy[x]<i) ed[i+1].push_back(fa[i]),rd[fa[i]]++;\n\t    else ed[fa[i]].push_back(i+1),rd[i+1]++;\n\t}\n    }\n    DREP(i,n,1)l[i]=l[fa[i]],r[i]=r[fa[i]];\n    get_rk();\n}\n\ninline int Dis(int i,int j){ return abs(p[j].x-p[i].x)+abs(p[j].y-p[i].y);}\n\ninline void doing()\n{\n    REP(th,1,tp)\n    {\n\tint u=rk[th];\n\n\tif(u==1)\n\t    u=1;\n\t\n\tint reml=l[u],remr=r[u];\n\tint &lx=l[u],&rx=r[u];\n\t\n\tdp[u][0][1]=l[u]==r[u]?0:Dis(l[u],r[u]);\n\tdp[u][1][0]=l[u]==r[u]?0:Dis(r[u],l[u]);\n\tdp[u][0][0]=dp[u][1][1]=inf;\n\t\n\tint L,R,ly,ry;\n\tly=min(ny[lx],ny[rx]),ry=max(ny[lx],ny[rx]);\n\t\n\tdo{\n\t    \n\t    int le=lx>1 && (ly-1==ny[lx-1] || ny[lx-1]==ry+1),re=rx<n && (ly-1==ny[rx+1] || ry+1==ny[rx+1]);\n\t    L=fa[lx-1],R=rx+1;\n\t    if(!le && !re)break;\n\t    if(le && re)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]+Dis(r[rx+1],lx-1)+dp[L][1][0]);\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]+Dis(l[lx-1],rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tchkmax(ry,max(ny[rx+1],ny[r[rx+1]]));\n\t\tchkmin(ly,min(ny[rx+1],ny[r[rx+1]]));\n\t\tchkmax(ry,max(ny[lx-1],ny[l[lx-1]]));\n\t\tchkmin(ly,min(ny[lx-1],ny[l[lx-1]]));\n\t\tlx=l[lx-1]; rx=r[rx+1];\n\t\t\n\t    }\n\t    else if(le)\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][0],dp[u][st][now]+Dis(now?rx:lx,lx-1)+dp[L][1][0]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tchkmax(ry,max(ny[lx-1],ny[l[lx-1]]));\n\t\tchkmin(ly,min(ny[lx-1],ny[l[lx-1]]));\n\t\tlx=l[lx-1];\n\t    }else\n\t    {\n\t\tstatic ll f[2][2]; memset(f,inf,sizeof(f));\n\t\tREP(st,0,1)REP(now,0,1)\n\t\t{\n\t\t    chkmin(f[st][1],dp[u][st][now]+Dis(now?rx:lx,rx+1)+dp[R][0][1]);\n\t\t}\n\t\tmemcpy(dp[u],f,sizeof(f));\n\t\tchkmax(ry,max(ny[rx+1],ny[r[rx+1]]));\n\t\tchkmin(ly,min(ny[rx+1],ny[r[rx+1]]));\n\t\trx=r[rx+1];\n\t    \n\t    }\n\t}while(1);\n\tREP(j,reml,remr)\n\t{\n\t    if(j==reml)ans[p[j].id]=min(dp[u][0][0],dp[u][0][1]);\n\t    else if(j==remr)ans[p[j].id]=min(dp[u][1][0],dp[u][1][1]);\n\t    else {\n\t\tans[p[j].id]=inf;\n\t\tREP(op,0,1)chkmin(ans[p[j].id],min(dp[u][0][op]+Dis(j,reml),dp[u][1][op]+Dis(j,remr)));\n\t    }\n\t    ans[p[j].id]-=rx-lx;\n\t}\n    }\n    REP(i,1,n)printf(\"%lld\\n\",ans[i]);\n}\n\nint main()\n{\n\n    init();\n    doing();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 2e5+10;\nint n,x[N],y[N],l[N],r[N];\npair<pa,int> a[N];\nll ans[N];\n\nconst ll inf = 1e15;\nmap<int,ll>dp[2][N];\ninline ll dis(pa a,pa b){\n\treturn abs(x[a.fi]-x[b.fi])+abs(y[a.se]-y[b.se]);\n}\ninline ll dfs(int l,int r,bool k,int mn,int mx){\n\tif (dp[k][l].count(r)) return dp[k][l][r];\n\tll ans=inf;\n\tint L=::l[l-1],R=::r[r+1];\n\tif (l>1&&(a[l-1].fi.se==mn-1||a[l-1].fi.se==mx+1)){\n\t\tans=min(ans,dfs(L,r,0,min(mn,a[L].fi.se),max(mx,a[L].fi.se))+dis(!k?a[l].fi:a[r].fi,a[L].fi));\n\t}\n\tif (r<n&&(a[r+1].fi.se==mn-1||a[r+1].fi.se==mx+1)){\n\t\tans=min(ans,dfs(l,R,1,min(mn,a[R].fi.se),max(mx,a[R].fi.se))+dis(!k?a[l].fi:a[r].fi,a[R].fi));\n\t}\n\treturn dp[k][l][r]=(ans==inf?l-r:ans);\n}\n\nint main(){\n\tn=read();\n\tFor(i,1,n) x[i]=read(),y[i]=read(),a[i]={{x[i],y[i]},i};\n\tsort(a+1,a+1+n),sort(x+1,x+1+n),sort(y+1,y+1+n);\n\tFor(i,1,n){\n\t\ta[i].fi.fi=lower_bound(x+1,x+1+n,a[i].fi.fi)-x;\n\t\ta[i].fi.se=lower_bound(y+1,y+1+n,a[i].fi.se)-y;\n\t}\n\tl[1]=1;\n\tFor(i,2,n){\n\t\tif (abs(a[i].fi.se-a[i-1].fi.se)==1) l[i]=l[i-1];\n\t\t\telse l[i]=i;\n\t}\n\tr[n]=n;\n\tDow(i,n-1,1)\n\t\tif (abs(a[i].fi.se-a[i+1].fi.se)==1) r[i]=r[i+1];\n\t\t\telse r[i]=i;\n\tFor(i,1,n) ans[a[i].se]=dfs(i,i,0,a[i].fi.se,a[i].fi.se);\n\tFor(i,1,n) printf(\"%lld\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    int read_unsafe() { return 0; }\n    template <class H, class... T> int read_unsafe(H& h, T&... t) {\n        bool f = read_single(h);\n        if (!f) return 0;\n        return 1 + read_unsafe(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value>* = nullptr>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(__int128 val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\nstruct UnionFind {\n    int n;\n    V<int> p, r;\n    int gn;\n    UnionFind(int _n = 0) : n(_n), p(n, -1), r(n, 1), gn(n) {}\n    void merge(int a, int b) {\n        assert(0 <= a && a < n);\n        assert(0 <= b && b < n);\n        int x = group(a), y = group(b);\n        if (x == y) return; // same\n        gn--;\n        if (r[x] < r[y]) swap(x, y);\n        p[y] = x;\n        r[x] += r[y];\n    }\n    int group(int a) {\n        assert(0 <= a && a < n);\n        if (p[a] == -1) return a;\n        return p[a] = group(p[a]);\n    }\n    bool same(int a, int b) {\n        assert(0 <= a && a < n);\n        assert(0 <= b && b < n);\n        return group(a) == group(b);\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nll pdist(ll xa, ll ya, ll xb, ll yb) {\n    return abs(xa - xb) + abs(ya - yb);\n}\n\nV<ll> solve(V<int> ys, V<ll> xv, V<ll> yv) {\n    int n = int(ys.size());\n    V<ll> dist(n - 1);\n    V<ll> dsm(n);\n    for (int i = 0; i < n - 1; i++) {\n        dist[i] = pdist(xv[i], yv[i], xv[i + 1], yv[i + 1]);\n        dsm[i + 1] = dsm[i] + dist[i];\n    }\n             ;\n\n\n    auto uf = UnionFind(n);\n    for (int i = 0; i < n - 1; i++) {\n        if (abs(ys[i] - ys[i + 1]) == 1) {\n            uf.merge(i, i + 1);\n        }\n    }\n    int m = uf.gn;\n    using P = pair<int, int>;\n    V<P> rngs(m);\n    V<int> ymins(m), ymaxs(m);\n    {\n        int l = 0;\n        for (int i = 0; i < m; i++) {\n            int r = l;\n            while (r < n && uf.same(l, r)) r++;\n            r--;\n            rngs[i] = {l, r};\n            ymins[i] = TEN(9);\n            ymaxs[i] = -TEN(9);\n            for (int j = l; j <= r; j++) {\n                ymins[i] = min(ymins[i], ys[j]);\n                ymaxs[i] = max(ymaxs[i], ys[j]);\n            }\n            l = r + 1;\n        }\n    }\n             ;\n    using Key = tuple<int, int, int>;\n    map<Key, ll> dp;\n    auto dfs = [&](auto self, int lid, int rid, int ymin, int ymax, int pos) {\n        bool lok = false, rok = false;\n        {\n            int l = rngs[lid].first;\n            if (l) {\n                int z = ys[l - 1];\n                if (z == ymin - 1 || z == ymax + 1) {\n                    lok = true;\n                }\n            }\n        }\n        {\n            int r = rngs[rid].second;\n            if (r + 1 < n) {\n                int z = ys[r + 1];\n                if (z == ymin - 1 || z == ymax + 1) {\n                    rok = true;\n                }\n            }\n        }\n        if (!lok && !rok) return - ll(rngs[rid].second - rngs[lid].first);\n\n        Key key = {lid, rid, pos};\n        if (dp.count(key)) return dp[key];\n\n        ll ans = TEN(18);\n        if (lok) {\n            int mpos = rngs[lid - 1].second;\n            int npos = rngs[lid - 1].first;\n            ll di = pdist(xv[pos], yv[pos], xv[mpos], yv[mpos]) + dsm[mpos] - dsm[npos];\n            ans = min(ans, di + self(self, lid - 1, rid, min(ymin, ymins[lid - 1]), max(ymax, ymaxs[lid - 1]), npos));\n        }\n        if (rok) {\n            int mpos = rngs[rid + 1].first;\n            int npos = rngs[rid + 1].second;\n            ll di = pdist(xv[pos], yv[pos], xv[mpos], yv[mpos]) + dsm[npos] - dsm[mpos];\n            ans = min(ans, di + self(self, lid, rid + 1, min(ymin, ymins[rid + 1]), max(ymax, ymaxs[rid + 1]), npos));\n        }\n        return dp[key] = ans;\n    };\n\n    V<ll> ans(n, TEN(18));\n    for (int i = 0; i < m; i++) {\n        auto rng = rngs[i];\n        int l = rng.first, r = rng.second;\n        for (int j = l; j <= r; j++) {\n            {\n                ll di = dsm[r] - dsm[j] + dsm[r] - dsm[l];\n                          ;\n                ans[j] = min(ans[j], di + dfs(dfs, i, i, ymins[i], ymaxs[i], l));\n            }\n            {\n                ll di = dsm[j] - dsm[l] + dsm[r] - dsm[l];\n                          ;\n                ans[j] = min(ans[j], di + dfs(dfs, i, i, ymins[i], ymaxs[i], r));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int n;\n    sc.read(n);\n\n    V<ll> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        sc.read(x[i], y[i]);\n    }\n\n    V<int> xidx(n), yidx(n);\n    iota(xidx.begin(), xidx.end(), 0);\n    iota(yidx.begin(), yidx.end(), 0);\n    sort(xidx.begin(), xidx.end(), [&](int a, int b) { return x[a] < x[b]; });\n    sort(yidx.begin(), yidx.end(), [&](int a, int b) { return y[a] < y[b]; });\n\n                   ;\n\n    V<int> rxi(n), ryi(n);\n    for (int i = 0; i < n; i++) {\n        rxi[xidx[i]] = i;\n        ryi[yidx[i]] = i;\n    }\n\n    V<int> ys(n);\n    V<ll> xv(n), yv(n);\n    for (int i = 0; i < n; i++) {\n        int p = xidx[i];\n        ys[i] = ryi[p];\n        xv[i] = x[p];\n        yv[i] = y[p];\n    }\n\n    auto ans = solve(ys, xv, yv);\n                        ;\n\n    for (int i = 0; i < n; i++) {\n        pr.writeln(ans[rxi[i]]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n\tint pl,pr,vl,vr,type;\n\tvector<int> sons;\n} a[404040];\n\nstruct Point {\n\tint x,y,tag;\n}point[202020];\n\nint ans[202020],dp[404040][2],n,tot,x[202020],y[202020],p[202020],rkx[202020],rky[202020];\n\ninline int dist(int a, int b) {\n\treturn abs(x[p[a]]-x[p[b]])+abs(y[p[a]]-y[p[b]]);\n}\n\nint l[MAXN], r[MAXN];\n\nvoid work(int pos) {\n\t//cout << pos << endl;\n\tif (pos <= n) {\n\t\tans[p[pos]] = dp[pos][0];\n\t\treturn;\n\t}\n\tvector <int> &s = a[pos].sons;\n\tfor (int i = 0, last = a[pos].pl; i < s.size(); i++) {\n\t\tl[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pr + 1;\n\t}\n\tfor (int i = s.size() - 1, last = a[pos].pr; i >= 0; i--) {\n\t\tr[i] = last; if (a[s[i]].type != 0) last = a[s[i]].pl - 1;\n\t}\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint dest = s[i], pl = l[i], pr = r[i];\n\t\t\n\t\tif (pl == a[dest].pl && pr == a[dest].pr) \n\t\t\tdp[dest][0] = dp[dest][1] = 0;\n\t\t\n\t\telse if (pl == a[dest].pl) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr) + dp[pos][1];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr) + dp[pos][1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pr);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pr);\n\t\t\t}\n\t\t} else if (pr == a[dest].pr) {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl) + dp[pos][0];\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl) + dp[pos][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[dest][0] = dist(a[dest].pl, pl);\n\t\t\t\tdp[dest][1] = dist(a[dest].pr, pl);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pl == a[pos].pl && pr == a[pos].pr) {\n\t\t\t\tdp[dest][0] = min(dp[pos][0] + dist(a[dest].pl, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dp[pos][0] + dist(a[dest].pr, pr) + dist(pl, pr), dp[pos][1] + dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t} else {\n\t\t\t\tdp[dest][0] = min(dist(a[dest].pl, pr) + dist(pl, pr), dist(a[dest].pl, pl) + dist(pl, pr));\n\t\t\t\tdp[dest][1] = min(dist(a[dest].pr, pr) + dist(pl, pr), dist(a[dest].pr, pl) + dist(pl, pr));\n\t\t\t}\n\t\t}\n\t\tdp[dest][0] -= a[dest].pl - pl + pr - a[dest].pr;\n\t\tdp[dest][1] -= a[dest].pl - pl + pr - a[dest].pr;\n\t}\n\tfor (int i = 0; i < s.size(); i++)\n\t\twork(s[i]);\n}\ninline bool chk(Node &A,Node &B) {\n\treturn max(A.vr,B.vr)-min(A.vl,B.vl) == max(A.pr,B.pr)-min(A.pl,B.pl);\n}\ninline int join(int x, int y) {\n\tif (a[x].vl < a[y].vl) {\n\t\ta[++tot].type = 1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[x].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[y].vr;\n\t} \n\telse {\t\t\n\t\ta[++tot].type = -1;\n\t\ta[tot].pl = a[x].pl;\n\t\ta[tot].vl = a[y].vl;\n\t\ta[tot].pr = a[y].pr;\n\t\ta[tot].vr = a[x].vr;\n\t}\n\ta[tot].sons.push_back(x);\n\ta[tot].sons.push_back(y);\n\treturn tot;\n}\nint s[MAXN];\ninline void buildTree() {\n\tfor (int i = 1;i <= n; i++) {\n\t\ta[++tot].type = 0;\n\t\ta[tot].pl = a[tot].pr = i;\n\t\ta[tot].vl = a[tot].vr = rky[p[i]];\n\t}\n\tint top = 0;\n\tfor (int i = 1;i <= n; i++) {\n\t\tbool fl = 1;\n\t\ts[++top] = i;\n\t\twhile (fl) {\n\t\t\tfl = 0;\n\t\t\tif (top >= 2 && a[s[top - 1]].type == 1 && a[s[top - 1]].vr + 1 == a[s[top]].vl) {\n\t\t\t\ta[s[top - 1]].vr = a[s[top]].vr;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && a[s[top - 1]].type == -1 && a[s[top - 1]].vl - 1 == a[s[top]].vr) {\n\t\t\t\ta[s[top - 1]].vl = a[s[top]].vl;\n\t\t\t\ta[s[top - 1]].pr = a[s[top]].pr;\n\t\t\t\ta[s[top - 1]].sons.push_back(s[top]);\n\t\t\t\tfl = 1;\n\t\t\t\ttop--;\n\t\t\t} \n\t\t\telse if (top >= 2 && chk(a[s[top]],a[s[top-1]])) {\n\t\t\t\tint x,y;\n\t\t\t\ty = s[top--];\n\t\t\t\tx = s[top--];\n\t\t\t\ts[++top] = join(x, y);\n\t\t\t\tfl = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= top; i++)\n\t\twork(s[i]);\n}\nbool cmpx(Point A,Point B) {\n\treturn A.x < B.x;\n}\nbool cmpy(Point A,Point B) {\n\treturn A.y < B.y;\n}\nint main() {\n\tscanf(\"%d\",&n); \n\tfor (int i = 1;i <= n; i++) {\n\t\tscanf(\"%d%d\",&point[i].x,&point[i].y),point[i].tag = i;\n\t\tx[i] = point[i].x;\n\t\ty[i] = point[i].y;\n\t}\n\tsort(point+1,point+n+1,cmpx);\n\tfor (int i = 1;i <= n; i++)\n\t\trkx[point[i].tag] = i;\n\t\t\n\tsort(point+1,point+n+1,cmpy);\n\tfor (int i = 1;i <= n; i++)\n\t\trky[point[i].tag] = i;\n\t\t\n\tfor (int i = 1;i <= n; i++)\n\t\tp[rkx[i]] = i;\n\t\t\n\tbuildTree();\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tprintf(\"%lld\\n\", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\n\n\n\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n\t<title>F - Rooks</title>\n\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n\t<meta http-equiv=\"Content-Language\" content=\"en\">\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n\t<meta name=\"format-detection\" content=\"telephone=no\">\n\t<meta name=\"google-site-verification\" content=\"nXGC_JxO0yoP1qBzMnYD_xgufO6leSLw1kyNo2HZltM\" />\n\n\t\n\t<meta name=\"description\" content=\"AtCoder is a programming contest site for anyone from beginners to experts. We hold weekly programming contests online.\">\n\t<meta name=\"author\" content=\"AtCoder Inc.\">\n\n\t<meta property=\"og:site_name\" content=\"AtCoder\">\n\t\n\t<meta property=\"og:title\" content=\"F - Rooks\" />\n\t<meta property=\"og:description\" content=\"AtCoder is a programming contest site for anyone from beginners to experts. We hold weekly programming contests online.\" />\n\t<meta property=\"og:type\" content=\"website\" />\n\t<meta property=\"og:url\" content=\"https://atcoder.jp/contests/agc047/tasks/agc047_f\" />\n\t<meta property=\"og:image\" content=\"https://img.atcoder.jp/assets/atcoder.png\" />\n\t<meta name=\"twitter:card\" content=\"summary\" />\n\t<meta name=\"twitter:site\" content=\"@atcoder\" />\n\t\n\t<meta property=\"twitter:title\" content=\"F - Rooks\" />\n\n\t<link href=\"//fonts.googleapis.com/css?family=Lato:400,700\" rel=\"stylesheet\" type=\"text/css\">\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"//img.atcoder.jp/public/8c9497a/css/bootstrap.min.css\">\n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"//img.atcoder.jp/public/8c9497a/css/base.css\">\n\t<link rel=\"shortcut icon\" type=\"image/png\" href=\"//img.atcoder.jp/assets/favicon.png\">\n\t<link rel=\"apple-touch-icon\" href=\"//img.atcoder.jp/assets/atcoder.png\">\n\t<script src=\"//img.atcoder.jp/public/8c9497a/js/lib/jquery-1.9.1.min.js\"></script>\n\t<script src=\"//img.atcoder.jp/public/8c9497a/js/lib/bootstrap.min.js\"></script>\n\t<script src=\"//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.1.4/js.cookie.min.js\"></script>\n\t<script src=\"//cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js\"></script>\n\t<script src=\"//cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/locale/ja.js\"></script>\n\t<script>\n\t\tvar LANG = \"en\";\n\t\tvar userScreenName = \"wycywf\";\n\t\tvar csrfToken = \"pxc8jUTL+cnm+3pHyWXo+ZvXhCoZvLir5KjhyviaOWM=\"\n\t</script>\n\t<script src=\"//img.atcoder.jp/public/8c9497a/js/utils.js\"></script>\n\t\n\t\n\t\t<script src=\"//img.atcoder.jp/public/8c9497a/js/contest.js\"></script>\n\t\t<link href=\"//img.atcoder.jp/public/8c9497a/css/contest.css\" rel=\"stylesheet\" />\n\t\t<script>\n\t\t\tvar contestScreenName = \"agc047\";\n\t\t\tvar remainingText = \"Remaining Time\";\n\t\t\tvar countDownText = \"Contest begins in\";\n\t\t\tvar startTime = moment(\"2020-08-09T21:00:00+09:00\");\n\t\t\tvar endTime = moment(\"2020-08-09T23:20:00+09:00\");\n\t\t</script>\n\t\t<style></style>\n\t\n\t\n\t\t<script type=\"text/x-mathjax-config\">MathJax.Hub.Config({messageStyle:\"none\",tex2jax:{skipTags:[\"script\",\"noscript\",\"style\",\"textarea\",\"code\"],inlineMath:[['\\\\(','\\\\)']]},delayStartupUntil:\"onload\"});</script>\n\t\t<script src=\"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n\t\t<script>$(function(){$('var').each(function(){$(this).html('\\\\('+$(this).html()+'\\\\)');});});</script>\n\t\n\t\n\t\t<link href=\"//cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/css/select2.min.css\" rel=\"stylesheet\" />\n\t\t<link href=\"//cdnjs.cloudflare.com/ajax/libs/select2-bootstrap-theme/0.1.0-beta.10/select2-bootstrap.min.css\" rel=\"stylesheet\" />\n\t\t<script src=\"//img.atcoder.jp/public/8c9497a/js/lib/select2.min.js\"></script>\n\t\n\t\n\t\t<link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/codemirror/5.38.0/codemirror.min.css\">\n\t\t<script src=\"//cdnjs.cloudflare.com/ajax/libs/codemirror/5.38.0/codemirror.min.js\"></script>\n\t\t<script src=\"//img.atcoder.jp/public/8c9497a/js/codeMirror/merged.js\"></script>\n\t\n\t\n\t\t<script src=\"//cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js\"></script>\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t<script src=\"//img.atcoder.jp/public/8c9497a/js/base.js\"></script>\n\t<script src=\"//img.atcoder.jp/public/8c9497a/js/ga.js\"></script>\n</head>\n\n<body>\n\n<script type=\"text/javascript\">\n\tvar __pParams = __pParams || [];\n\t__pParams.push({client_id: '468', c_1: 'atcodercontest', c_2: 'ClientSite'});\n</script>\n<script type=\"text/javascript\" src=\"https://cdn.d2-apps.net/js/tr.js\" async></script>\n\n\n<div id=\"modal-contest-start\" class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n\t<div class=\"modal-dialog\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n\t\t\t\t<h4 class=\"modal-title\">Contest started</h4>\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\t\t\t\t<p>AtCoder Grand Contest 047 has begun.</p>\n\t\t\t</div>\n\t\t\t<div class=\"modal-footer\">\n\t\t\t\t\n\t\t\t\t\t<a class=\"btn btn-primary\" href='/contests/agc047/tasks'>Go to the task list page</a>\n\t\t\t\t\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n<div id=\"modal-contest-end\" class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n\t<div class=\"modal-dialog\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n\t\t\t\t<h4 class=\"modal-title\">Contest is over</h4>\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\t\t\t\t<p>AtCoder Grand Contest 047 has ended.</p>\n\t\t\t</div>\n\t\t\t<div class=\"modal-footer\">\n\t\t\t\t<button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Close</button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n<div id=\"main-div\" class=\"float-container\">\n\n\n\t<nav class=\"navbar navbar-inverse navbar-fixed-top\">\n\t\t<div class=\"container-fluid\">\n\t\t\t<div class=\"navbar-header\">\n\t\t\t\t<button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar-collapse\" aria-expanded=\"false\">\n\t\t\t\t\t<span class=\"icon-bar\"></span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span>\n\t\t\t\t</button>\n\t\t\t\t<a class=\"navbar-brand\" href=\"/home\"></a>\n\t\t\t</div>\n\t\t\t<div class=\"collapse navbar-collapse\" id=\"navbar-collapse\">\n\t\t\t\t<ul class=\"nav navbar-nav\">\n\t\t\t\t\n\t\t\t\t\t<li><a class=\"contest-title\" href=\"/contests/agc047\">AtCoder Grand Contest 047</a></li>\n\t\t\t\t\n\t\t\t\t</ul>\n\t\t\t\t<ul class=\"nav navbar-nav navbar-right\">\n\t\t\t\t\t\n\t\t\t\t\t<li class=\"dropdown\">\n\t\t\t\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t\t\t<img src='//img.atcoder.jp/assets/top/img/flag-lang/en.png'> English <span class=\"caret\"></span>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t\t<ul class=\"dropdown-menu\">\n\t\t\t\t\t\t\t<li><a href=\"/contests/agc047/tasks/agc047_f?lang=ja\"><img src='//img.atcoder.jp/assets/top/img/flag-lang/ja.png'> 日本語</a></li>\n\t\t\t\t\t\t\t<li><a href=\"/contests/agc047/tasks/agc047_f?lang=en\"><img src='//img.atcoder.jp/assets/top/img/flag-lang/en.png'> English</a></li>\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</li>\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t<li class=\"dropdown\">\n\t\t\t\t\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\">\n\t\t\t\t\t\t\t\t<span class=\"glyphicon glyphicon-cog\" aria-hidden=\"true\"></span> wycywf (Contestant) <span class=\"caret\"></span>\n\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t<ul class=\"dropdown-menu\">\n\t\t\t\t\t\t\t\t<li><a href=\"/users/wycywf\"><span class=\"glyphicon glyphicon-user\" aria-hidden=\"true\"></span> My Profile</a></li>\n\t\t\t\t\t\t\t\t<li class=\"divider\"></li>\n\t\t\t\t\t\t\t\t<li><a href=\"/settings\"><span class=\"glyphicon glyphicon-wrench\" aria-hidden=\"true\"></span> General Settings</a></li>\n\t\t\t\t\t\t\t\t<li><a href=\"/settings/icon\"><span class=\"glyphicon glyphicon-picture\" aria-hidden=\"true\"></span> Change Photo</a></li>\n\t\t\t\t\t\t\t\t<li><a href=\"/settings/password\"><span class=\"glyphicon glyphicon-lock\" aria-hidden=\"true\"></span> Change Password</a></li>\n\t\t\t\t\t\t\t\t<li><a href=\"/settings/fav\"><span class=\"glyphicon glyphicon-star\" aria-hidden=\"true\"></span> Manage Fav</a></li>\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<li class=\"divider\"></li>\n\t\t\t\t\t\t\t\t<li><a href=\"javascript:void(form_logout.submit())\"><span class=\"glyphicon glyphicon-log-out\" aria-hidden=\"true\"></span> Sign Out</a></li>\n\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\n\t\t\t\t</ul>\n\t\t\t</div>\n\t\t</div>\n\t</nav>\n\n\t<form method=\"POST\" name=\"form_logout\" action=\"/logout?continue=https%3A%2F%2Fatcoder.jp%2Fcontests%2Fagc047%2Ftasks%2Fagc047_f\">\n\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"pxc8jUTL&#43;cnm&#43;3pHyWXo&#43;ZvXhCoZvLir5KjhyviaOWM=\" />\n\t</form>\n\t<div id=\"main-container\" class=\"container\"\n\t\t \tstyle=\"padding-top:50px;\">\n\t\t\n\n<div class=\"row\">\n\t<div id=\"contest-nav-tabs\" class=\"col-sm-12 mb-2 cnvtb-fixed\">\n\t<div>\n\t\t<small class=\"contest-duration\">\n\t\t\t\n\t\t\t\tContest Duration:\n\t\t\t\t<a href='http://www.timeanddate.com/worldclock/fixedtime.html?iso=20200809T2100&p1=248' target='blank'><time class='fixtime fixtime-full'>2020-08-09 21:00:00+0900</time></a> ~ <a href='http://www.timeanddate.com/worldclock/fixedtime.html?iso=20200809T2320&p1=248' target='blank'><time class='fixtime fixtime-full'>2020-08-09 23:20:00+0900</time></a> (local time)\n\t\t\t\t(140 minutes)\n\t\t\t\n\t\t</small>\n\t\t<small class=\"back-to-home pull-right\"><a href=\"/home\">Back to Home</a></small>\n\t</div>\n\t<ul class=\"nav nav-tabs\">\n\t\t<li><a href=\"/contests/agc047\"><span class=\"glyphicon glyphicon-home\" aria-hidden=\"true\"></span> Top</a></li>\n\t\t\n\t\t\t<li class=\"active\"><a href=\"/contests/agc047/tasks\"><span class=\"glyphicon glyphicon-tasks\" aria-hidden=\"true\"></span> Tasks</a></li>\n\t\t\n\n\t\t\n\t\t\t<li><a href=\"/contests/agc047/clarifications\"><span class=\"glyphicon glyphicon-question-sign\" aria-hidden=\"true\"></span> Clarifications <span id=\"clar-badge\" class=\"badge\"></span></a></li>\n\t\t\n\n\t\t\n\t\t\t<li><a href=\"/contests/agc047/submit?taskScreenName=agc047_f\"><span class=\"glyphicon glyphicon-send\" aria-hidden=\"true\"></span> Submit</a></li>\n\t\t\n\n\t\t\n\t\t\t<li>\n\t\t\t\t<a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"><span class=\"glyphicon glyphicon-list\" aria-hidden=\"true\"></span> Results<span class=\"caret\"></span></a>\n\t\t\t\t<ul class=\"dropdown-menu\">\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t<li><a href=\"/contests/agc047/submissions/me\"><span class=\"glyphicon glyphicon-user\" aria-hidden=\"true\"></span> My Submissions</a></li>\n\t\t\t\t\t\t<li class=\"divider\"></li>\n\t\t\t\t\t\t<li><a href=\"/contests/agc047/score\"><span class=\"glyphicon glyphicon-dashboard\" aria-hidden=\"true\"></span> My Score</a></li>\n\t\t\t\t\t\n\t\t\t\t</ul>\n\t\t\t</li>\n\t\t\n\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\t<li><a href=\"/contests/agc047/standings\"><span class=\"glyphicon glyphicon-sort-by-attributes-alt\" aria-hidden=\"true\"></span> Standings</a></li>\n\t\t\t\t\n\t\t\t\n\t\t\n\n\t\t\n\t\t\t<li><a href=\"/contests/agc047/custom_test\"><span class=\"glyphicon glyphicon-wrench\" aria-hidden=\"true\"></span> Custom Test</a></li>\n\t\t\n\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t<li><a href=\"https://codeforces.com/blog/entry/81159\" target=\"_blank\" rel=\"noopener\"><span class=\"glyphicon glyphicon-comment\" aria-hidden=\"true\"></span> Discuss</a></li>\n\t\t\t\n\t\t\n\n\t\t<li class=\"pull-right\"><a id=\"fix-cnvtb\" href=\"javascript:void(0)\"><span class=\"glyphicon glyphicon-pushpin\" aria-hidden=\"true\"></span></a></li>\n\t</ul>\n</div>\n\t<div class=\"col-sm-12\">\n\t\t<span class=\"h2\">\n\t\t\tF - Rooks\n\t\t\t\n\t\t</span>\n\t\t<span id=\"task-lang-btn\" class=\"pull-right\"><span data-lang=\"ja\"><img src='//img.atcoder.jp/assets/top/img/flag-lang/ja.png'></span> / <span data-lang=\"en\"><img src='//img.atcoder.jp/assets/top/img/flag-lang/en.png'></span></span>\n\t\t<script>\n\t\t\t$(function() {\n\t\t\t\tvar ts = $('#task-statement span.lang');\n\t\t\t\tif (ts.children('span').size() <= 1) {\n\t\t\t\t\t$('#task-lang-btn').hide();\n\t\t\t\t\tts.children('span').show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar REMEMBER_LB = 5;\n\t\t\t\tvar LS_KEY = 'task_lang';\n\t\t\t\tvar taskLang = getLS(LS_KEY) || '';\n\t\t\t\tvar changeTimes = 0;\n\t\t\t\tif (taskLang == 'ja' || taskLang == 'en') {\n\t\t\t\t\tchangeTimes = REMEMBER_LB;\n\t\t\t\t} else {\n\t\t\t\t\tvar changeTimes = parseInt(taskLang, 10);\n\t\t\t\t\tif (isNaN(changeTimes)) {\n\t\t\t\t\t\tchangeTimes = 0;\n\t\t\t\t\t\tdelLS(LS_KEY);\n\t\t\t\t\t}\n\t\t\t\t\tchangeTimes++;\n\t\t\t\t\ttaskLang = LANG;\n\t\t\t\t}\n\t\t\t\tts.children('span.lang-' + taskLang).show();\n\n\t\t\t\t$('#task-lang-btn span').click(function() {\n\t\t\t\t\tvar l = $(this).data('lang');\n\t\t\t\t\tts.children('span').hide();\n\t\t\t\t\tts.children('span.lang-' + l).show();\n\t\t\t\t\tif (changeTimes < REMEMBER_LB) setLS(LS_KEY, changeTimes);\n\t\t\t\t\telse setLS(LS_KEY, l);\n\t\t\t\t});\n\t\t\t});\n\t\t</script>\n\t\t<hr/>\n\t\t<p>\n\t\t\tTime Limit: 1.25 sec / Memory Limit: 1024 MB\n\t\t\t\n\t\t</p>\n\n\t\t<div id=\"task-statement\">\n\t\t\t\n\t\t\t<span class=\"lang\">\n<span class=\"lang-ja\">\n<p>配点 : <var>2200</var> 点</p>\n\n<div class=\"part\">\n<section>\n<h3>問題文</h3><p>無限に広がるチェス盤上の <var>N</var> 個の敵ルークの位置 <var>(X_i, Y_i)</var> が与えられます。<em>[訳注: ルークは将棋の飛車と似た動きをする駒です。]</em>\nどの二つのルークも、お互いを攻められる位置にはありません (すなわち、一行あたり、または一列あたりのルークの数は一個以下です)。</p>\n<p>あなたは、ルークのうち一個をキングに置き換え、キングを繰り返し動かしてできるだけ多くのルークを取ろうとしています。<em>[訳注: キングは将棋の王将と似た動きをする駒です。]</em></p>\n<p>ルークに攻められているマスに入ることはできません。\nまた、<strong>斜めに移動することで空きマスに移ることもできません</strong> (しかし、斜めに移動することでルークを取ることはできます)。</p>\n<p>(つまり、このキングの動きは、斜め四方向に動いて駒を取ることと縦横四方向に動くことができる強化版ポーンのようなものです。)</p>\n<p>各ルークについて、そのルークをキングで置き換えた際に取ることのできる最大数のルークを取るために必要な最小手数を求めてください。</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>制約</h3><ul>\n<li><var>2 \\leq N \\leq 200\\,000</var></li>\n<li><var>1 \\leq X_i, Y_i \\leq 10^6</var></li>\n<li><var>X_i \\neq X_j</var></li>\n<li><var>Y_i \\neq Y_j</var></li>\n<li>入力中の値はすべて整数である。</li>\n</ul>\n</section>\n</div>\n\n<hr />\n\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>入力</h3><p>入力は以下の形式で標準入力から与えられる。</p>\n<pre><var>N</var>\n<var>X_1</var> <var>Y_1</var>\n<var>X_2</var> <var>Y_2</var>\n<var>\\vdots</var>\n<var>X_N</var> <var>Y_N</var>\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力</h3><p><var>N</var> 行出力せよ。\n<var>i</var> 行目は、<var>(X_i, Y_i)</var> に置かれたルークをキングに置き換えた場合に対応する。\nこの行には、一つの整数、すなわち <var>M_i</var> 個のルークを取るために必要な最小手数を出力せよ。\nここで、<var>M_i</var> は (何手かけてもよいとして) この場合に取ることのできるルークの最大数である。</p>\n</section>\n</div>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>入力例 1</h3><pre>6\n1 8\n6 10\n2 7\n4 4\n9 3\n5 1\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 1</h3><pre>5\n0\n7\n5\n0\n0\n</pre>\n\n<p>下図を見てください。\nルーク <var>3</var> をキングに置き換えた場合、他のルークを最大で二個取ることができます。\n図の赤い経路がこの場合の最適な手順の一つ - ルーク <var>1</var> を取り、右下方向に進み続けてルーク <var>4</var> を取る - です。\nここでの手数は <var>7</var> 手であり、これが出力例の三つ目の数です。</p>\n<p align=\"center\"><img alt=\"path\" src=\"https://img.atcoder.jp/agc047/rooks_path_small3.png\"/></p>\n\n<p align=\"center\"><em><var>x</var> 軸正方向: 右、<var>y</var> 軸正方向: 上</em></p>\n\n<p>ルーク <var>2, 5, 6</var> のいずれかをキングに置き換えた場合には、他のルークを一個も取ることができません。このとき、最小手数は <var>0</var> です。</p>\n</section>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>入力例 2</h3><pre>5\n5 5\n100 100\n70 20\n81 70\n800 1\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 2</h3><pre>985\n985\n1065\n1034\n0\n</pre>\n\n</section>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>入力例 3</h3><pre>10\n2 5\n4 4\n13 12\n12 13\n14 17\n17 19\n22 22\n16 18\n19 27\n25 26\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>出力例 3</h3><pre>2\n2\n9\n9\n3\n3\n24\n5\n0\n25\n</pre></section>\n</div>\n</span>\n<span class=\"lang-en\">\n<p>Score : <var>2200</var> points</p>\n\n<div class=\"part\">\n<section>\n<h3>Problem Statement</h3><p>You are given positions <var>(X_i, Y_i)</var> of <var>N</var> enemy rooks on an infinite chessboard.\nNo two rooks attack each other (at most one rook per row or column).</p>\n<p>You're going to replace one rook with a king and then move the king repeatedly to beat as many rooks as possible.</p>\n<p>You can't enter a cell that is being attacked by a rook.\nAdditionally, you <strong>can't move diagonally to an empty cell</strong> (but you can beat a rook diagonally).</p>\n<p>(So this king moves like a superpawn that beats diagonally in 4 directions and moves horizontally/vertically in 4 directions.)</p>\n<p>For each rook, consider replacing it with a king, and find the minimum possible number of moves\n    needed to beat the maximum possible number of rooks.</p>\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Constraints</h3><ul>\n<li><var>2 \\leq N \\leq 200\\,000</var></li>\n<li><var>1 \\leq X_i, Y_i \\leq 10^6</var></li>\n<li><var>X_i \\neq X_j</var></li>\n<li><var>Y_i \\neq Y_j</var></li>\n<li>All values in input are integers.</li>\n</ul>\n</section>\n</div>\n\n<hr />\n\n<div class=\"io-style\">\n<div class=\"part\">\n<section>\n<h3>Input</h3><p>Input is given from Standard Input in the following format.</p>\n<pre><var>N</var>\n<var>X_1</var> <var>Y_1</var>\n<var>X_2</var> <var>Y_2</var>\n<var>\\vdots</var>\n<var>X_N</var> <var>Y_N</var>\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Output</h3><p>Print <var>N</var> lines.\nThe <var>i</var>-th line is for scenario of replacing the rook at <var>(X_i, Y_i)</var> with your king.\nThis line should contain one integer: the minimum number of moves to beat <var>M_i</var> rooks\n    where <var>M_i</var> denotes the maximum possible number of beaten rooks in this scenario (in infinite time).</p>\n</section>\n</div>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>Sample Input 1</h3><pre>6\n1 8\n6 10\n2 7\n4 4\n9 3\n5 1\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 1</h3><pre>5\n0\n7\n5\n0\n0\n</pre>\n\n<p>See the drawing below.\nIf we replace rook 3 with a king, we can beat at most two other rooks.\nThe red path is one of optimal sequences of moves: beat rook 1,\n    then keep going down and right until you can beat rook 4.\nThere are 7 steps and that's the third number in the output.</p>\n<p align=\"center\"><img alt=\"path\" src=\"https://img.atcoder.jp/agc047/rooks_path_small3.png\"/></p>\n\n<p align=\"center\"><em>x-coordinate increases from left to right,\n    while y increases bottom to top.</em></p>\n\n<p>Starting from rook 2, 5 or 6, we can't beat any other rook.\nThe optimal number of moves is 0.</p>\n</section>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>Sample Input 2</h3><pre>5\n5 5\n100 100\n70 20\n81 70\n800 1\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 2</h3><pre>985\n985\n1065\n1034\n0\n</pre>\n\n</section>\n</div>\n\n<hr />\n\n<div class=\"part\">\n<section>\n<h3>Sample Input 3</h3><pre>10\n2 5\n4 4\n13 12\n12 13\n14 17\n17 19\n22 22\n16 18\n19 27\n25 26\n</pre>\n\n</section>\n</div>\n\n<div class=\"part\">\n<section>\n<h3>Sample Output 3</h3><pre>2\n2\n9\n9\n3\n3\n24\n5\n0\n25\n</pre></section>\n</div>\n</span>\n</span>\n\n\t\t</div>\n\n\t\t\n\n\t\t\n\t\t<hr/>\n\t\t<form class=\"form-horizontal form-code-submit\" action=\"/contests/agc047/submit\" method=\"POST\">\n\t\t\t<input type=\"hidden\" name=\"data.TaskScreenName\" value=\"agc047_f\" />\n\t\t\t\n\t\t\t<div class=\"form-group \">\n\t\t\t\t<label class=\"control-label col-sm-2\" for=\"select-lang\">Language</label>\n\t\t\t\t<div id=\"select-lang\" class=\"col-sm-5\" data-name=\"data.LanguageId\">\n\t\t\t\t\t<select class=\"form-control current\" data-placeholder=\"-\" name=\"data.LanguageId\" required>\n\t\t\t\t\t\t<option></option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4001\" data-mime=\"text/x-csrc\">C (GCC 9.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4002\" data-mime=\"text/x-csrc\">C (Clang 10.0.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4003\" data-mime=\"text/x-c&#43;&#43;src\">C&#43;&#43; (GCC 9.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4004\" data-mime=\"text/x-c&#43;&#43;src\">C&#43;&#43; (Clang 10.0.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4005\" data-mime=\"text/x-java\">Java (OpenJDK 11.0.6)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4006\" data-mime=\"text/x-python\">Python (3.8.2)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4007\" data-mime=\"text/x-sh\">Bash (5.0.11)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4008\" data-mime=\"text/x-bc\">bc (1.07.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4009\" data-mime=\"text/x-sh\">Awk (GNU Awk 4.1.4)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4010\" data-mime=\"text/x-csharp\">C# (.NET Core 3.1.201)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4011\" data-mime=\"text/x-csharp\">C# (Mono-mcs 6.8.0.105)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4012\" data-mime=\"text/x-csharp\">C# (Mono-csc 3.5.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4013\" data-mime=\"text/x-clojure\">Clojure (1.10.1.536)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4014\" data-mime=\"text/x-crystal\">Crystal (0.33.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4015\" data-mime=\"text/x-d\">D (DMD 2.091.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4016\" data-mime=\"text/x-d\">D (GDC 9.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4017\" data-mime=\"text/x-d\">D (LDC 1.20.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4018\" data-mime=\"application/dart\">Dart (2.7.2)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4019\" data-mime=\"text/x-dc\">dc (1.4.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4020\" data-mime=\"text/x-erlang\">Erlang (22.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4021\" data-mime=\"elixir\">Elixir (1.10.2)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4022\" data-mime=\"text/x-fsharp\">F# (.NET Core 3.1.201)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4023\" data-mime=\"text/x-fsharp\">F# (Mono 10.2.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4024\" data-mime=\"text/x-forth\">Forth (gforth 0.7.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4025\" data-mime=\"text/x-fortran\">Fortran(GNU Fortran 9.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4026\" data-mime=\"text/x-go\">Go (1.14.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4027\" data-mime=\"text/x-haskell\">Haskell (GHC 8.8.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4028\" data-mime=\"text/x-haxe\">Haxe (4.0.3); js</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4029\" data-mime=\"text/x-haxe\">Haxe (4.0.3); Java</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4030\" data-mime=\"text/javascript\">JavaScript (Node.js 12.16.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4031\" data-mime=\"text/x-julia\">Julia (1.4.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4032\" data-mime=\"text/x-kotlin\">Kotlin (1.3.71)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4033\" data-mime=\"text/x-lua\">Lua (Lua 5.3.5)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4034\" data-mime=\"text/x-lua\">Lua (LuaJIT 2.1.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4035\" data-mime=\"text/x-sh\">Dash (0.5.8)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4036\" data-mime=\"text/x-nim\">Nim (1.0.6)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4037\" data-mime=\"text/x-objectivec\">Objective-C (Clang 10.0.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4038\" data-mime=\"text/x-common-lisp\">Common Lisp (SBCL 2.0.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4039\" data-mime=\"text/x-ocaml\">OCaml (4.10.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4040\" data-mime=\"text/x-octave\">Octave (5.2.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4041\" data-mime=\"text/x-pascal\">Pascal (FPC 3.0.4)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4042\" data-mime=\"text/x-perl\">Perl (5.26.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4043\" data-mime=\"text/x-perl\">Raku (Rakudo 2020.02.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4044\" data-mime=\"text/x-php\">PHP (7.4.4)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4045\" data-mime=\"text/x-prolog\">Prolog (SWI-Prolog 8.0.3)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4046\" data-mime=\"text/x-python\">PyPy2 (7.3.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4047\" data-mime=\"text/x-python\">PyPy3 (7.3.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4048\" data-mime=\"text/x-racket\">Racket (7.6)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4049\" data-mime=\"text/x-ruby\">Ruby (2.7.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4050\" data-mime=\"text/x-rustsrc\">Rust (1.42.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4051\" data-mime=\"text/x-scala\">Scala (2.13.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4052\" data-mime=\"text/x-java\">Java (OpenJDK 1.8.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4053\" data-mime=\"text/x-scheme\">Scheme (Gauche 0.9.9)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4054\" data-mime=\"text/x-sml\">Standard ML (MLton 20130715)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4055\" data-mime=\"text/x-swift\">Swift (5.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4056\" data-mime=\"text/plain\">Text (cat 8.28)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4057\" data-mime=\"text/typescript\">TypeScript (3.8)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4058\" data-mime=\"text/x-vb\">Visual Basic (.NET Core 3.1.101)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4059\" data-mime=\"text/x-sh\">Zsh (5.4.2)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4060\" data-mime=\"text/x-cobol\">COBOL - Fixed (OpenCOBOL 1.1.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4061\" data-mime=\"text/x-cobol\">COBOL - Free (OpenCOBOL 1.1.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4062\" data-mime=\"text/x-brainfuck\">Brainfuck (bf 20041219)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4063\" data-mime=\"text/x-ada\">Ada2012 (GNAT 9.2.1)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4064\" data-mime=\"text/x-unlambda\">Unlambda (2.0.0)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4065\" data-mime=\"text/x-python\">Cython (0.29.16)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4066\" data-mime=\"text/x-sh\">Sed (4.4)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t<option value=\"4067\" data-mime=\"text/x-vim\">Vim (8.2.0460)</option>\n\t\t\t\t\t\t\n\t\t\t\t\t</select>\n\t\t\t\t\t<span class=\"error\"></span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<script>var currentLang = getLS('defaultLang');</script>\n\t\t\t\n\t\t\t\n<div class=\"form-group\">\n\t<label class=\"control-label col-sm-2\" for=\"sourceCode\">Source Code</label>\n\t<div class=\"col-sm-7\" id=\"sourceCode\">\n\t\t<div class=\"div-editor\">\n\t\t\t<textarea class=\"form-control editor\" name=\"sourceCode\"></textarea>\n\t\t</div>\n\t\t<textarea class=\"form-control plain-textarea\" style=\"display:none;\"></textarea>\n\t\t<p>\n\t\t\t<span class=\"gray\">※ at most 512 KiB</span><br>\n\t\t\t<span class=\"gray\">※ Your source code will be saved as Main.<i>extension</i>.</span>\n\t\t</p>\n\t</div>\n\t<div class=\"col-sm-3 editor-buttons\">\n\t\t<p><button id=\"btn-open-file\" type=\"button\" class=\"btn btn-default btn-sm\">\n\t\t\t<span class=\"glyphicon glyphicon-folder-open\" aria-hidden=\"true\"></span> &nbsp; Open File\n\t\t</button></p>\n\t\t<p><button type=\"button\" class=\"btn btn-default btn-sm btn-toggle-editor\" data-toggle=\"button\" aria-pressed=\"false\" autocomplete=\"off\">\n\t\t\tToggle Editor\n\t\t</button></p>\n\t\t<p><button type=\"button\" class=\"btn btn-default btn-sm btn-auto-height\" data-toggle=\"button\" aria-pressed=\"false\" autocomplete=\"off\">\n\t\t\tAuto Height\n\t\t</button></p>\n\t</div>\n\t<input id=\"input-open-file\" type=\"file\" style=\"display:none;\">\n</div>\n\n\t\t\t<input type=\"hidden\" name=\"csrf_token\" value=\"pxc8jUTL&#43;cnm&#43;3pHyWXo&#43;ZvXhCoZvLir5KjhyviaOWM=\" />\n\t\t\t<div class=\"form-group\">\n\t\t\t\t<label class=\"control-label col-sm-2\" for=\"submit\"></label>\n\t\t\t\t<div class=\"col-sm-5\">\n\t\t\t\t\t<button type=\"submit\" class=\"btn btn-primary\" id=\"submit\">Submit</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</form>\n\t\t\n\t</div>\n</div>\n\n\n\n\n\t\t\n\t\t\t<hr>\n\t\t\t\n\t\t\t\n\t\t\t\n<div class=\"a2a_kit a2a_kit_size_20 a2a_default_style pull-right\" data-a2a-url=\"https://atcoder.jp/contests/agc047/tasks/agc047_f?lang=en\" data-a2a-title=\"F - Rooks\">\n\t<a class=\"a2a_button_facebook\"></a>\n\t<a class=\"a2a_button_twitter\"></a>\n\t\n\t\t<a class=\"a2a_button_telegram\"></a>\n\t\n\t<a class=\"a2a_dd\" href=\"https://www.addtoany.com/share\"></a>\n</div>\n\n\t\t\n\t\t<script async src=\"//static.addtoany.com/menu/page.js\"></script>\n\t\t\n\t</div> \n\t<hr>\n</div> \n\n\t<div class=\"container\" style=\"margin-bottom: 80px;\">\n\t\t\t<footer class=\"footer\">\n\t\t\t\n\t\t\t\t<ul>\n\t\t\t\t\t<li><a href=\"/contests/agc047/rules\">Rule</a></li>\n\t\t\t\t\t<li><a href=\"/contests/agc047/glossary\">Glossary</a></li>\n\t\t\t\t\t\n\t\t\t\t</ul>\n\t\t\t\n\t\t\t<ul>\n\t\t\t\t<li><a href=\"/tos\">Terms of service</a></li>\n\t\t\t\t<li><a href=\"/privacy\">Privacy Policy</a></li>\n\t\t\t\t<li><a href=\"/personal\">Information Protection Policy</a></li>\n\t\t\t\t<li><a href=\"/company\">Company</a></li>\n\t\t\t\t<li><a href=\"/faq\">FAQ</a></li>\n\t\t\t\t<li><a href=\"/contact\">Contact</a></li>\n\t\t\t\t\n\t\t\t</ul>\n\t\t\t<div class=\"text-center\">\n\t\t\t\t\t<small id=\"copyright\">Copyright Since 2012 &copy;<a href=\"http://atcoder.co.jp\">AtCoder Inc.</a> All rights reserved.</small>\n\t\t\t</div>\n\t\t\t</footer>\n\t</div>\n\t<p id=\"fixed-server-timer\" class=\"contest-timer\"></p>\n\t<div id=\"scroll-page-top\" style=\"display:none;\"><span class=\"glyphicon glyphicon-arrow-up\" aria-hidden=\"true\"></span> Page Top</div>\n\n</body>\n</html>\n\n"
  },
  {
    "language": "Python",
    "code": "#"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    xxx = inp[1::2]\n    yyy = inp[2::2]\n    xxx_idx = np.argsort(xxx)\n    yyy_idx = np.argsort(yyy)\n    # print('xxx_idx', xxx_idx)\n    # print('yyy_idx', yyy_idx)\n    xxx_num = np.argsort(xxx_idx)\n    yyy_num = np.argsort(yyy_idx)\n    # print('xxx_num', xxx_num)\n    # print('yyy_num', yyy_num)\n\n    # i: 入力順のルークの番号\n    # xi: x座標昇順にソートしたときの順番\n    # xxx_idx[xi] = i\n    # xxx_num[i] = xi\n\n    def get_xy_by_xi(xi):\n        i = xxx_idx[xi]\n        return xxx[i], yyy[i]\n\n    def calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt):\n        lpx, lpy = get_xy_by_xi(lpxi)\n        rnx, rny = get_xy_by_xi(rnxi)\n\n        diag_t = abs(rnx - lpx) + abs(rny - lpy) - rook_cnt\n\n        lllt = llt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        llrt = llt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        lrlt = lrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        lrrt = lrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n        rllt = rlt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        rlrt = rlt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        rrlt = rrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        rrrt = rrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n\n        llt = min(lllt, lrlt)\n        lrt = min(llrt, lrrt)\n        rlt = min(rllt, rrlt)\n        rrt = min(rlrt, rrrt)\n        # print('upd', lpx, lpy, rnx, rny)\n        # print('upd', llt, lrt, rlt, rrt)\n        # print('upd', lllt, llrt, lrlt, lrrt, rllt, rlrt, rrlt, rrrt)\n\n        return lpx, lpy, rnx, rny, llt, lrt, rlt, rrt\n\n    # free[xi] = xi+1 のルークと初期状態から互いに取り合える関係にあるか(0/1)\n    free = np.zeros(n, dtype=np.int8)\n\n    for i in range(n):\n        xi = xxx_num[i]\n        yi = yyy_num[i]\n        px_i = -1 if xi == 0 else xxx_idx[xi - 1]\n        nx_i = -2 if xi == n - 1 else xxx_idx[xi + 1]\n        py_i = -3 if yi == 0 else yyy_idx[yi - 1]\n        ny_i = -4 if yi == n - 1 else yyy_idx[yi + 1]\n        if px_i == py_i or px_i == ny_i:\n            free[xi - 1] = 1\n        if nx_i == py_i or nx_i == ny_i:\n            free[xi] = 1\n\n    # freeが連続する箇所は、どこから始めても互いに全て取り合える\n    # これを「グループ」とする\n    # グループの左端と右端のxiを求める\n    free_l = np.zeros(n, dtype=np.int64)\n    free_r = np.zeros(n, dtype=np.int64)\n    l = 0\n    for xi in range(n - 1):\n        if free[xi] == 0:\n            l = xi + 1\n        free_l[xi + 1] = l\n    r = n - 1\n    free_r[r] = r\n    for xi in range(n - 2, -1, -1):\n        if free[xi] == 0:\n            r = xi\n        free_r[xi] = r\n\n    # print(free)\n    # print(free_l)\n    # print(free_r)\n\n    # グループ内のルークを全部取った時点を0として、追加で取れるルークを取るのにかかる時間\n    # グループ内のルークを取り終わったのが、左端、右端のいずれかで2通り計算\n    # 同グループに属するルークはこの情報を共有できるので、一番左端のルークの位置に記録\n    # Key: xi\n    extra_l = np.zeros(n, dtype=np.int64)\n    extra_r = np.zeros(n, dtype=np.int64)\n    INF = 10 ** 18\n    lxi = 0\n    while lxi < n:\n        rxi = free_r[lxi]\n\n        if lxi == rxi:\n            lxi = rxi + 1\n            continue\n\n        li = xxx_idx[lxi]\n        ri = xxx_idx[rxi]\n        lyi = yyy_num[li]\n        ryi = yyy_num[ri]\n        lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n\n        original_li = lxi\n        lx = xxx[li]\n        ly = yyy[li]\n        rx = xxx[ri]\n        ry = yyy[ri]\n        llt, lrt, rlt, rrt = 0, INF, INF, 0\n\n        # print('li', li, 'ri', ri, 'lxi', lxi, 'lyi', lyi, 'rxi', rxi, 'ryi', ryi)\n\n        while True:\n            px_i = -1 if lxi == 0 else xxx_idx[lxi - 1]\n            py_i = -2 if lyi == 0 else yyy_idx[lyi - 1]\n            nx_i = -3 if rxi == n - 1 else xxx_idx[rxi + 1]\n            ny_i = -4 if ryi == n - 1 else yyy_idx[ryi + 1]\n            # print(px_i, py_i, nx_i, ny_i)\n            if px_i == py_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == ny_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    lyi = yyy_num[xxx_idx[lxi]]\n                    ryi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    lyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            elif px_i == ny_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == py_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    lyi = yyy_num[xxx_idx[lxi]]\n                    ryi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(uyi, lyi, ryi), max(uyi, lyi, ryi)\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n\n            elif nx_i == ny_i or nx_i == py_i:\n                rnxi = free_r[rxi + 1]\n                rook_cnt = rnxi - rxi\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                    calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, rnxi, rnxi, rook_cnt)\n                rxi = rnxi\n                ryi = yyy_num[xxx_idx[rxi]]\n                lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            else:\n                extra_l[original_li] = min(llt, lrt)\n                extra_r[original_li] = min(rlt, rrt)\n                break\n\n        lxi = rxi + 1\n\n    # print(extra_l)\n    # print(extra_r)\n\n    ans = np.zeros(n, dtype=np.int64)\n    for i in range(n):\n        xi = xxx_num[i]\n        x = xxx[i]\n        y = yyy[i]\n        lxi = free_l[xi]\n        lx = xxx[xxx_idx[lxi]]\n        ly = yyy[xxx_idx[lxi]]\n        rxi = free_r[xi]\n        rx = xxx[xxx_idx[rxi]]\n        ry = yyy[xxx_idx[rxi]]\n        lt = extra_l[lxi]\n        rt = extra_r[lxi]\n        diag = abs(rx - lx) + abs(ry - ly) - (rxi - lxi)\n        rlt = abs(rx - x) + abs(ry - y) + diag\n        lrt = abs(x - lx) + abs(y - ly) + diag\n        ans[i] = min(lt + rlt, rt + lrt)\n\n    return ans\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', '(i8[:],)')(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit('(i8[:],)', cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    xxx = inp[1::2]\n    yyy = inp[2::2]\n    xxx_idx = np.argsort(xxx)\n    yyy_idx = np.argsort(yyy)\n    # print('xxx_idx', xxx_idx)\n    # print('yyy_idx', yyy_idx)\n    xxx_num = np.argsort(xxx_idx)\n    yyy_num = np.argsort(yyy_idx)\n\n    # print('xxx_num', xxx_num)\n    # print('yyy_num', yyy_num)\n\n    # i: 入力順のルークの番号\n    # xi: x座標昇順にソートしたときの順番\n    # xxx_idx[xi] = i\n    # xxx_num[i] = xi\n\n    def get_xy_by_xi(xi):\n        i = xxx_idx[xi]\n        return xxx[i], yyy[i]\n\n    def calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt):\n        lpx, lpy = get_xy_by_xi(lpxi)\n        rnx, rny = get_xy_by_xi(rnxi)\n\n        diag_t = abs(rnx - lpx) + abs(rny - lpy) - rook_cnt\n\n        lllt = llt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        llrt = llt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        lrlt = lrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        lrrt = lrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n        rllt = rlt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        rlrt = rlt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        rrlt = rrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        rrrt = rrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n\n        llt = min(lllt, lrlt)\n        lrt = min(llrt, lrrt)\n        rlt = min(rllt, rrlt)\n        rrt = min(rlrt, rrrt)\n        # print('upd', lpx, lpy, rnx, rny)\n        # print('upd', llt, lrt, rlt, rrt)\n        # print('upd', lllt, llrt, lrlt, lrrt, rllt, rlrt, rrlt, rrrt)\n\n        return lpx, lpy, rnx, rny, llt, lrt, rlt, rrt\n\n    # free[xi] = xi+1 のルークと初期状態から互いに取り合える関係にあるか(0/1)\n    free = np.zeros(n, dtype=np.int8)\n\n    for i in range(n):\n        xi = xxx_num[i]\n        yi = yyy_num[i]\n        px_i = -1 if xi == 0 else xxx_idx[xi - 1]\n        nx_i = -2 if xi == n - 1 else xxx_idx[xi + 1]\n        py_i = -3 if yi == 0 else yyy_idx[yi - 1]\n        ny_i = -4 if yi == n - 1 else yyy_idx[yi + 1]\n        if px_i == py_i or px_i == ny_i:\n            free[xi - 1] = 1\n        if nx_i == py_i or nx_i == ny_i:\n            free[xi] = 1\n\n    # freeが連続する箇所は、どこから始めても互いに全て取り合える\n    # これを「グループ」とする\n    # グループの左端と右端のxiを求める\n    free_l = np.zeros(n, dtype=np.int64)\n    free_r = np.zeros(n, dtype=np.int64)\n    l = 0\n    for xi in range(n - 1):\n        if free[xi] == 0:\n            l = xi + 1\n        free_l[xi + 1] = l\n    r = n - 1\n    free_r[r] = r\n    for xi in range(n - 2, -1, -1):\n        if free[xi] == 0:\n            r = xi\n        free_r[xi] = r\n\n    # print(free)\n    # print(free_l)\n    # print(free_r)\n\n    # グループ内のルークを全部取った時点を0として、追加で取れるルークを取るのにかかる時間\n    # グループ内のルークを取り終わったのが、左端、右端のいずれかで2通り計算\n    # 同グループに属するルークはこの情報を共有できるので、一番左端のルークの位置に記録\n    # Key: xi\n    extra_l = np.zeros(n, dtype=np.int64)\n    extra_r = np.zeros(n, dtype=np.int64)\n    INF = 10 ** 18\n    lxi = 0\n    while lxi < n:\n        rxi = free_r[lxi]\n\n        if lxi == rxi:\n            lxi = rxi + 1\n            continue\n\n        li = xxx_idx[lxi]\n        ri = xxx_idx[rxi]\n        lyi = yyy_num[li]\n        ryi = yyy_num[ri]\n        lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n\n        original_li = lxi\n        lx = xxx[li]\n        ly = yyy[li]\n        rx = xxx[ri]\n        ry = yyy[ri]\n        llt, lrt, rlt, rrt = 0, INF, INF, 0\n\n        # print('li', li, 'ri', ri, 'lxi', lxi, 'lyi', lyi, 'rxi', rxi, 'ryi', ryi)\n\n        while True:\n            px_i = -1 if lxi == 0 else xxx_idx[lxi - 1]\n            py_i = -2 if lyi == 0 else yyy_idx[lyi - 1]\n            nx_i = -3 if rxi == n - 1 else xxx_idx[rxi + 1]\n            ny_i = -4 if ryi == n - 1 else yyy_idx[ryi + 1]\n            # print(px_i, py_i, nx_i, ny_i)\n            if px_i == py_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == ny_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    vyi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi, uyi, vyi), max(lyi, ryi, uyi, vyi)\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(lyi, ryi, uyi), max(lyi, ryi, uyi)\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            elif px_i == ny_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == py_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    vyi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi, uyi, vyi), max(lyi, ryi, uyi, vyi)\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(lyi, ryi, uyi), max(lyi, ryi, uyi)\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n\n            elif nx_i == ny_i or nx_i == py_i:\n                rnxi = free_r[rxi + 1]\n                rook_cnt = rnxi - rxi\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                    calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, rnxi, rnxi, rook_cnt)\n                rxi = rnxi\n                vyi = yyy_num[xxx_idx[rxi]]\n                lyi, ryi = min(lyi, ryi, vyi), max(lyi, ryi, vyi)\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            else:\n                extra_l[original_li] = min(llt, lrt)\n                extra_r[original_li] = min(rlt, rrt)\n                break\n\n        lxi = rxi + 1\n\n    # print(extra_l)\n    # print(extra_r)\n\n    ans = np.zeros(n, dtype=np.int64)\n    for i in range(n):\n        xi = xxx_num[i]\n        x = xxx[i]\n        y = yyy[i]\n        lxi = free_l[xi]\n        lx = xxx[xxx_idx[lxi]]\n        ly = yyy[xxx_idx[lxi]]\n        rxi = free_r[xi]\n        rx = xxx[xxx_idx[rxi]]\n        ry = yyy[xxx_idx[rxi]]\n        lt = extra_l[lxi]\n        rt = extra_r[lxi]\n        diag = abs(rx - lx) + abs(ry - ly) - (rxi - lxi)\n        rlt = abs(rx - x) + abs(ry - y) + diag\n        lrt = abs(x - lx) + abs(y - ly) + diag\n        ans[i] = min(lt + rlt, rt + lrt)\n\n    return ans\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', '(i8[:],)')(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit('(i8[:],)', cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    xxx = inp[1::2]\n    yyy = inp[2::2]\n    xxx_idx = np.argsort(xxx)\n    yyy_idx = np.argsort(yyy)\n    # print('xxx_idx', xxx_idx)\n    # print('yyy_idx', yyy_idx)\n    xxx_num = np.argsort(xxx_idx)\n    yyy_num = np.argsort(yyy_idx)\n\n    # print('xxx_num', xxx_num)\n    # print('yyy_num', yyy_num)\n\n    # i: 入力順のルークの番号\n    # xi: x座標昇順にソートしたときの順番\n    # xxx_idx[xi] = i\n    # xxx_num[i] = xi\n\n    def get_xy_by_xi(xi):\n        i = xxx_idx[xi]\n        return xxx[i], yyy[i]\n\n    def calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt):\n        lpx, lpy = get_xy_by_xi(lpxi)\n        rnx, rny = get_xy_by_xi(rnxi)\n\n        diag_t = abs(rnx - lpx) + abs(rny - lpy) - rook_cnt\n\n        lllt = llt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        llrt = llt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        lrlt = lrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        lrrt = lrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n        rllt = rlt + abs(rnx - lx) + abs(rny - ly) + diag_t\n        rlrt = rlt + abs(lx - lpx) + abs(ly - lpy) + diag_t\n        rrlt = rrt + abs(rnx - rx) + abs(rny - ry) + diag_t\n        rrrt = rrt + abs(rx - lpx) + abs(ry - lpy) + diag_t\n\n        llt = min(lllt, lrlt)\n        lrt = min(llrt, lrrt)\n        rlt = min(rllt, rrlt)\n        rrt = min(rlrt, rrrt)\n        # print('upd', lpx, lpy, rnx, rny)\n        # print('upd', llt, lrt, rlt, rrt)\n        # print('upd', lllt, llrt, lrlt, lrrt, rllt, rlrt, rrlt, rrrt)\n\n        return lpx, lpy, rnx, rny, llt, lrt, rlt, rrt\n\n    # free[xi] = xi+1 のルークと初期状態から互いに取り合える関係にあるか(0/1)\n    free = np.zeros(n, dtype=np.int8)\n\n    for i in range(n):\n        xi = xxx_num[i]\n        yi = yyy_num[i]\n        px_i = -1 if xi == 0 else xxx_idx[xi - 1]\n        nx_i = -2 if xi == n - 1 else xxx_idx[xi + 1]\n        py_i = -3 if yi == 0 else yyy_idx[yi - 1]\n        ny_i = -4 if yi == n - 1 else yyy_idx[yi + 1]\n        if px_i == py_i or px_i == ny_i:\n            free[xi - 1] = 1\n        if nx_i == py_i or nx_i == ny_i:\n            free[xi] = 1\n\n    # freeが連続する箇所は、どこから始めても互いに全て取り合える\n    # これを「グループ」とする\n    # グループの左端と右端のxiを求める\n    free_l = np.zeros(n, dtype=np.int64)\n    free_r = np.zeros(n, dtype=np.int64)\n    l = 0\n    for xi in range(n - 1):\n        if free[xi] == 0:\n            l = xi + 1\n        free_l[xi + 1] = l\n    r = n - 1\n    free_r[r] = r\n    for xi in range(n - 2, -1, -1):\n        if free[xi] == 0:\n            r = xi\n        free_r[xi] = r\n\n    # print(free)\n    # print(free_l)\n    # print(free_r)\n\n    # グループ内のルークを全部取った時点を0として、追加で取れるルークを取るのにかかる時間\n    # グループ内のルークを取り終わったのが、左端、右端のいずれかで2通り計算\n    # 同グループに属するルークはこの情報を共有できるので、一番左端のルークの位置に記録\n    # Key: xi\n    extra_l = np.zeros(n, dtype=np.int64)\n    extra_r = np.zeros(n, dtype=np.int64)\n    INF = 10 ** 18\n    lxi = 0\n    while lxi < n:\n        rxi = free_r[lxi]\n\n        if lxi == rxi:\n            lxi = rxi + 1\n            continue\n\n        li = xxx_idx[lxi]\n        ri = xxx_idx[rxi]\n        lyi = yyy_num[li]\n        ryi = yyy_num[ri]\n        lyi, ryi = min(lyi, ryi), max(lyi, ryi)\n\n        original_li = lxi\n        lx = xxx[li]\n        ly = yyy[li]\n        rx = xxx[ri]\n        ry = yyy[ri]\n        llt, lrt, rlt, rrt = 0, INF, INF, 0\n\n        # print('li', li, 'ri', ri, 'lxi', lxi, 'lyi', lyi, 'rxi', rxi, 'ryi', ryi)\n\n        while True:\n            px_i = -1 if lxi == 0 else xxx_idx[lxi - 1]\n            py_i = -2 if lyi == 0 else yyy_idx[lyi - 1]\n            nx_i = -3 if rxi == n - 1 else xxx_idx[rxi + 1]\n            ny_i = -4 if ryi == n - 1 else yyy_idx[ryi + 1]\n            # print(px_i, py_i, nx_i, ny_i)\n            if px_i == py_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == ny_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    vyi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi, uyi, vyi), max(lyi, ryi, uyi, vyi)\n                    # print(0, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(lyi, ryi, uyi), max(lyi, ryi, uyi)\n                    # print(1, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            elif px_i == ny_i:\n                lpxi = free_l[lxi - 1]\n                rook_cnt = lxi - lpxi\n\n                if nx_i == py_i:\n                    rnxi = free_r[rxi + 1]\n                    rook_cnt += rnxi - rxi\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, rnxi, rook_cnt)\n                    lxi = lpxi\n                    rxi = rnxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    vyi = yyy_num[xxx_idx[rxi]]\n                    lyi, ryi = min(lyi, ryi, uyi, vyi), max(lyi, ryi, uyi, vyi)\n                    # print(2, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                else:\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n                    lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                        calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, lpxi, lpxi, rook_cnt)\n                    lxi = lpxi\n                    uyi = yyy_num[xxx_idx[lxi]]\n                    lyi, ryi = min(lyi, ryi, uyi), max(lyi, ryi, uyi)\n                    # print(3, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, llt, lrt, rlt, rrt)\n\n            elif nx_i == ny_i or nx_i == py_i:\n                rnxi = free_r[rxi + 1]\n                rook_cnt = rnxi - rxi\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n                lx, ly, rx, ry, llt, lrt, rlt, rrt = \\\n                    calc_time(lx, ly, rx, ry, llt, lrt, rlt, rrt, rnxi, rnxi, rook_cnt)\n                rxi = rnxi\n                vyi = yyy_num[xxx_idx[rxi]]\n                lyi, ryi = min(lyi, ryi, vyi), max(lyi, ryi, vyi)\n                # print(4, lxi, rxi, lyi, ryi, '|', lx, ly, rx, ry, lt, rt)\n\n            else:\n                extra_l[original_li] = min(llt, lrt)\n                extra_r[original_li] = min(rlt, rrt)\n                break\n\n        lxi = rxi + 1\n\n    # print(extra_l)\n    # print(extra_r)\n\n    ans = np.zeros(n, dtype=np.int64)\n    for i in range(n):\n        xi = xxx_num[i]\n        x = xxx[i]\n        y = yyy[i]\n        lxi = free_l[xi]\n        lx = xxx[xxx_idx[lxi]]\n        ly = yyy[xxx_idx[lxi]]\n        rxi = free_r[xi]\n        rx = xxx[xxx_idx[rxi]]\n        ry = yyy[xxx_idx[rxi]]\n        lt = extra_l[lxi]\n        rt = extra_r[lxi]\n        diag = abs(rx - lx) + abs(ry - ly) - (rxi - lxi)\n        rlt = abs(rx - x) + abs(ry - y) + diag\n        lrt = abs(x - lx) + abs(y - ly) + diag\n        ans[i] = min(lt + rlt, rt + lrt)\n\n    return ans\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', '(i8[:],)')(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit('(i8[:],)', cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n# 整数の入力\na = int(input())\n\n# スペース区切りの整数の入力\nr_x = []\nr_y _ []\nfor i in range(a):\n  x, y = map(int, input().split())\n  r_x.append(x)\n  r_y.append(y)\n\n\ndef detect(x, y):\n  min_x = -10000000\n  max_x = 10000000\n  min_y = -10000000\n  max_y = 10000000\n\n  for x_ in r_x:\n    x__= x_ - x\n    if x__ > 0 and x__ < max_x:\n      max_x = x__\n    elif x__ < 0 and x__ > min_x:\n      min_x = x__\n      \n  for y_ in r_y:\n    y__= y_ - y\n    if y__ > 0 and y__ < max_y:\n      max_y = y__\n    elif y__ < 0 and y__ > min_y:\n      min_y = y__\n\n  return min_x, min_y, max_x, max_y\n\nfor x, y in zip(r_x, r_y):\n  min_x, min_y, max_x, max_y = detect(x, y)\n  \n  \n  \n  # 出力\n  print(\"{} {}\".format(a+b+c, s))"
  },
  {
    "language": "Python",
    "code": "print(\"わかりましぇん\")"
  }
]