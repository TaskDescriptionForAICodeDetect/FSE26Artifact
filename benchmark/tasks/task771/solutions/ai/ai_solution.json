[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_M 100005\n\nint N, M;\nint conditions[MAX_M][3];\nint card_values[MAX_N];\nbool card_known[MAX_N];\n\nint min_magic_cost() {\n    int magic_cost = 0;\n    memset(card_values, 0, sizeof(card_values));\n    memset(card_known, 0, sizeof(card_known));\n\n    for (int i = 0; i < M; i++) {\n        int x = conditions[i][0] - 1;\n        int y = conditions[i][1] - 1;\n        int expected_sum = conditions[i][2];\n\n        if (!card_known[x] && !card_known[y]) {\n            card_values[x] = 1;\n            card_known[x] = true;\n            magic_cost++;\n        }\n\n        if (card_known[x] && !card_known[y]) {\n            card_values[y] = expected_sum % 2 == \n            (card_values[x] % 2) ? 1 : 2;\n            card_known[y] = true;\n            magic_cost++;\n        }\n\n        if (!card_known[x] && card_known[y]) {\n            card_values[x] = expected_sum % 2 == \n            (card_values[y] % 2) ? 1 : 2;\n            card_known[x] = true;\n            magic_cost++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (!card_known[i]) {\n            card_values[i] = 1;\n            card_known[i] = true;\n            magic_cost++;\n        }\n    }\n\n    return magic_cost;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &conditions[i][0], &conditions[i][1], &conditions[i][2]);\n    }\n\n    int result = min_magic_cost();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAXN * 2];\nint head[MAXN];\nint edgeCount;\nint color[MAXN];\nbool visited[MAXN];\nbool isBipartite;\n\nvoid init() {\n    edgeCount = 0;\n    for (int i = 0; i < MAXN; i++) {\n        head[i] = -1;\n        color[i] = -1;\n        visited[i] = false;\n    }\n    isBipartite = true;\n}\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nvoid dfs(int u, int c) {\n    if (color[u] != -1) {\n        if (color[u] != c) {\n            isBipartite = false;\n        }\n        return;\n    }\n    color[u] = c;\n    visited[u] = true;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        dfs(v, 1 - c);\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    init();\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        if (c == 0) {\n            addEdge(a, b);\n            addEdge(b, a);\n        } else {\n            addEdge(a, b + N);\n            addEdge(b + N, a);\n            addEdge(b, a + N);\n            addEdge(a + N, b);\n        }\n    }\n    int res = 0;\n    for (int i = 1; i <= 2 * N; i++) {\n        if (!visited[i] && i <= N) {\n            dfs(i, 0);\n            int cnt0 = 0, cnt1 = 0;\n            for (int j = 1; j <= N; j++) {\n                if (color[j] == 0) cnt0++;\n                else if (color[j] == 1) cnt1++;\n            }\n            res += (cnt0 < cnt1) ? cnt0 : cnt1;\n        }\n    }\n    if (!isBipartite) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n};\n\nbool bfs(int start, vector<vector<Edge>>& graph, vector<int>& color, vector<bool>& visited) {\n    queue<int> q;\n    q.push(start);\n    color[start] = 0;\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (const Edge& e : graph[u]) {\n            int v = e.to;\n            int expected_color = (color[u] + e.weight) % 2;\n            if (!visited[v]) {\n                visited[v] = true;\n                color[v] = expected_color;\n                q.push(v);\n            } else if (color[v] != expected_color) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<Edge>> graph(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        graph[a].push_back({b, c});\n        graph[b].push_back({a, c});\n    }\n\n    vector<int> color(N + 1, -1);\n    vector<bool> visited(N + 1, false);\n    bool possible = true;\n    int components = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        if (!visited[i]) {\n            components++;\n            if (!bfs(i, graph, color, visited)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (possible) {\n        cout << components << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass DSU {\n    private int[] parent;\n    private int[] rank;\n\n    public DSU(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int xRoot = find(x);\n        int yRoot = find(y);\n        if (xRoot == yRoot) return;\n        if (rank[xRoot] < rank[yRoot]) {\n            parent[xRoot] = yRoot;\n        } else if (rank[yRoot] < rank[xRoot]) {\n            parent[yRoot] = xRoot;\n        } else {\n            parent[yRoot] = xRoot;\n            rank[xRoot]++;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        DSU dsu = new DSU(2 * N);\n\n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            int c = scanner.nextInt();\n            if (c == 0) {\n                dsu.union(a, b);\n                dsu.union(a + N, b + N);\n            } else {\n                dsu.union(a, b + N);\n                dsu.union(a + N, b);\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            if (dsu.find(i) == dsu.find(i + N)) {\n                System.out.println(-1);\n                return;\n            }\n        }\n\n        Set<Integer> groups = new HashSet<>();\n        for (int i = 0; i < N; i++) {\n            groups.add(dsu.find(i));\n        }\n        System.out.println(Math.min(groups.size(), N - groups.size()));\n    }\n}",
    "timestamp": "2025-08-05 22:52:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardGuessingMinCost {\n    public static int minimumCost(int N, List<int[]> conditions) {\n        int[] cards = new int[N];\n        Arrays.fill(cards, -1);\n        \n        // Create graph to represent constraints\n        List<List<Integer>> graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Build constraint graph\n        for (int[] condition : conditions) {\n            int a = condition[0], b = condition[1];\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        \n        int cost = 0;\n        \n        // Try to determine card values using graph constraints\n        for (int i = 0; i < N; i++) {\n            if (cards[i] == -1) {\n                // If first card in component is not determined\n                if (determineCardValue(i, cards, graph)) {\n                    cost++;\n                }\n            }\n        }\n        \n        // If any card still undetermined, reveal directly\n        for (int i = 0; i < N; i++) {\n            if (cards[i] == -1) {\n                cards[i] = 1;  // Arbitrary value\n                cost++;\n            }\n        }\n        \n        return cost;\n    }\n    \n    private static boolean determineCardValue(int start, int[] cards, List<List<Integer>> graph) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        cards[start] = 1;  // Initial guess\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            for (int neighbor : graph.get(current)) {\n                if (cards[neighbor] == -1) {\n                    // Determine neighbor's value based on constraint\n                    cards[neighbor] = 3 - cards[current];\n                    queue.offer(neighbor);\n                } else if (cards[neighbor] == cards[current]) {\n                    // Inconsistent constraint\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int N = 5;\n        List<int[]> conditions = new ArrayList<>();\n        conditions.add(new int[]{0, 1});\n        conditions.add(new int[]{2, 3});\n        \n        System.out.println(minimumCost(N, conditions));\n    }\n}",
    "timestamp": "2025-08-05 22:52:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint N, M;\nvector<pair<int, int>> conditions;\nint card[MAXN];\nbool determined[MAXN];\n\nint solve() {\n    int cost = 0;\n    \n    // First try to determine cards with direct conditions\n    for (auto& [a, b] : conditions) {\n        if (!determined[a] && !determined[b]) {\n            // If both cards are undetermined, try to guess\n            for (int x = 1; x <= 2; x++) {\n                for (int y = 1; y <= 2; y++) {\n                    if ((x + y) % 2 == 0) {\n                        card[a] = x;\n                        card[b] = y;\n                        determined[a] = true;\n                        determined[b] = true;\n                        cost += 2;\n                        break;\n                    }\n                }\n                if (determined[a]) break;\n            }\n        }\n        else if (!determined[a]) {\n            // If one card is known, determine the other\n            for (int x = 1; x <= 2; x++) {\n                if ((x + card[b]) % 2 == 0) {\n                    card[a] = x;\n                    determined[a] = true;\n                    cost++;\n                    break;\n                }\n            }\n        }\n        else if (!determined[b]) {\n            // If one card is known, determine the other\n            for (int y = 1; y <= 2; y++) {\n                if ((card[a] + y) % 2 == 0) {\n                    card[b] = y;\n                    determined[b] = true;\n                    cost++;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Determine remaining undetermined cards\n    for (int i = 1; i <= N; i++) {\n        if (!determined[i]) {\n            card[i] = 1;  // Default to 1\n            determined[i] = true;\n            cost++;\n        }\n    }\n    \n    return cost;\n}\n\nint main() {\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        conditions.push_back({a, b});\n    }\n    \n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_magic_uses(n, m, conditions):\n    parent = list(range(n))\n    parity = [0] * n  # 0 for even, 1 for odd\n\n    def find(x):\n        if parent[x] != x:\n            orig_parent = parent[x]\n            parent[x] = find(parent[x])\n            parity[x] ^= parity[orig_parent]\n        return parent[x]\n\n    def union(x, y, sum_even):\n        rootX = find(x)\n        rootY = find(y)\n        parityXY = parity[x] ^ parity[y]\n        if rootX != rootY:\n            parent[rootX] = rootY\n            parity[rootX] = parityXY ^ sum_even\n\n    # Process each condition\n    for x, y, sum_even in conditions:\n        union(x, y, 1 if sum_even % 2 == 1 else 0)\n\n    component_roots = set(find(i) for i in range(n))\n    return len(component_roots)\n\n# Example usage:\nn = 5\nm = 2\nconditions = [(0, 2, 2), (2, 4, 0)]\nprint(min_magic_uses(n, m, conditions))",
    "timestamp": "2025-08-13 12:47:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CardGame {\n    static int[] cards;\n    static List<int[]> evenConditions;\n    static int N, M;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Input: Number of cards and number of conditions\n        N = scanner.nextInt();\n        M = scanner.nextInt();\n        cards = new int[N];\n        evenConditions = new ArrayList<>();\n\n        // Input: M conditions\n        for (int i = 0; i < M; i++) {\n            int x = scanner.nextInt() - 1;\n            int y = scanner.nextInt() - 1;\n            int b = scanner.nextInt();\n            evenConditions.add(new int[]{x, y, b});\n        }\n\n        int minCost = findMinimumMagicUse();\n        System.out.println(minCost);\n\n        scanner.close();\n    }\n    \n    public static int findMinimumMagicUse() {\n        int cost = 0;\n\n        // Initialize visited array to keep track of card status\n        boolean[] visited = new boolean[N];\n        Arrays.fill(cards, -1);\n\n        for (int[] cond : evenConditions) {\n            int x = cond[0], y = cond[1], b = cond[2];\n\n            if (!visited[x] && !visited[y]) {\n                // If both cards are not revealed\n                cards[x] = 1;\n                cards[y] = (b - 1) % 2 + 1;\n                cost += 2;\n                visited[x] = visited[y] = true;\n            } else if (visited[x] && !visited[y]) {\n                // If only first card is revealed\n                cards[y] = (b - cards[x]) % 2 + 1;\n                cost++;\n                visited[y] = true;\n            } else if (!visited[x] && visited[y]) {\n                // If only second card is revealed\n                cards[x] = (b - cards[y]) % 2 + 1;\n                cost++;\n                visited[x] = true;\n            }\n        }\n\n        // Reveal unrevealed cards\n        for (int i = 0; i < N; i++) {\n            if (!visited[i]) {\n                cards[i] = 1;\n                cost++;\n            }\n        }\n\n        return cost;\n    }\n}",
    "timestamp": "2025-08-13 12:47:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_M 1000\n\ntypedef struct {\n    int card1;\n    int card2;\n} Condition;\n\nint N, M;\nint cards[MAX_N];\nCondition conditions[MAX_M];\nbool revealed[MAX_N];\n\nvoid read_input() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &conditions[i].card1, &conditions[i].card2);\n        conditions[i].card1--; // Zero-based indexing\n        conditions[i].card2--;\n    }\n}\n\nbool is_even(int card1, int card2) {\n    return (cards[card1] + cards[card2]) % 2 == 0;\n}\n\nvoid reveal_card(int index) {\n    if (!revealed[index]) {\n        printf(\"Reveal card %d\\n\", index + 1); // Output the action\n        revealed[index] = true;\n    }\n}\n\nvoid solve() {\n    for (int i = 0; i < N; i++) {\n        cards[i] = 1; // Default guess\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int card1 = conditions[i].card1;\n        int card2 = conditions[i].card2;\n\n        if (!is_even(card1, card2)) {\n            reveal_card(card1);\n            reveal_card(card2);\n            cards[card1] = 1;\n            cards[card2] = 2;\n        }\n    }\n}\n\nint main() {\n    read_input();\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-13 12:47:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass DSU {\n    vector<int> parent, rank;\n\npublic:\n    DSU(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    DSU dsu(N);\n\n    for (int i = 0; i < M; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x--; y--;\n        dsu.unite(x, y);\n    }\n\n    vector<bool> seen(N, false);\n    int components = 0;\n\n    for (int i = 0; i < N; ++i) {\n        int root = dsu.find(i);\n        if (!seen[root]) {\n            components++;\n            seen[root] = true;\n        }\n    }\n\n    cout << components << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:47:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_cards(N, conditions):\n    # Initialize possible values for each card\n    cards = [{1, 2} for _ in range(N)]\n    \n    # Track the cost of revealing cards\n    cost = 0\n    \n    # Process each condition\n    for x, y, s in conditions:\n        x, y = x-1, y-1  # Convert to 0-based indexing\n        \n        # Check if we can narrow down possibilities based on condition\n        possible_pairs = [(1, 1), (2, 2)]\n        if s % 2 == 1:\n            possible_pairs = [(1, 2), (2, 1)]\n        \n        # Narrow down possibilities for cards x and y\n        new_x_vals = set()\n        new_y_vals = set()\n        \n        for val_x in cards[x]:\n            for val_y in cards[y]:\n                if (val_x, val_y) in possible_pairs:\n                    new_x_vals.add(val_x)\n                    new_y_vals.add(val_y)\n        \n        cards[x] = new_x_vals\n        cards[y] = new_y_vals\n    \n    # Resolve any remaining ambiguities\n    for i in range(N):\n        if len(cards[i]) > 1:\n            # Reveal the card\n            cost += 1\n            # Arbitrarily choose the first possibility\n            cards[i] = {list(cards[i])[0]}\n    \n    return cost\n\n# Example usage\nN = 5  # Number of cards\nconditions = [\n    (1, 2, 4),  # Example condition: sum of cards 1 and 2 is even\n    (2, 3, 5),  # Example condition: sum of cards 2 and 3 is odd\n]\n\nprint(solve_cards(N, conditions))",
    "timestamp": "2025-08-13 12:47:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        a = int(input[ptr]) - 1\n        ptr += 1\n        b = int(input[ptr]) - 1\n        ptr += 1\n        s = int(input[ptr])\n        ptr += 1\n        adj[a].append((b, s))\n        adj[b].append((a, s))\n\n    color = [-1] * N\n    total_cost = 0\n    possible = True\n\n    for i in range(N):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            cnt = [0, 0]\n            cnt[0] += 1\n            is_bipartite = True\n\n            while queue and is_bipartite:\n                u = queue.popleft()\n                for (v, s) in adj[u]:\n                    expected_color = color[u] ^ (s % 2)\n                    if color[v] == -1:\n                        color[v] = expected_color\n                        cnt[expected_color] += 1\n                        queue.append(v)\n                    elif color[v] != expected_color:\n                        is_bipartite = False\n                        break\n\n            if not is_bipartite:\n                possible = False\n                break\n            total_cost += min(cnt[0], cnt[1])\n\n    if possible:\n        print(total_cost)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 12:47:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumMagicUses(n, m, conditions) {\n    const cards = Array(n).fill(null);\n    const adjList = Array.from({ length: n }, () => []);\n    const visited = Array(n).fill(false);\n    \n    conditions.forEach(([a, b, sumEven]) => {\n        adjList[a].push([b, sumEven]);\n        adjList[b].push([a, sumEven]);\n    });\n\n    const dfs = (index, value) => {\n        if (visited[index]) return;\n        visited[index] = true;\n        cards[index] = value;\n\n        for (let [next, sumEven] of adjList[index]) {\n            let nextValue = (sumEven === 0) ? value : 3 - value;\n            dfs(next, nextValue);\n        }\n    };\n\n    let magicCount = 0;\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, 1);\n            magicCount++;\n        }\n    }\n    \n    return magicCount;\n}",
    "timestamp": "2025-08-13 12:48:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumCost(N, conditions) {\n    const graph = Array.from({ length: N }, () => []);\n    const degree = new Array(N).fill(0);\n    const even = new Array(N).fill(null);\n\n    for (const [a, b, c] of conditions) {\n        graph[a - 1].push(b - 1);\n        graph[b - 1].push(a - 1);\n        degree[a - 1]++;\n        degree[b - 1]++;\n    }\n\n    function dfs(node) {\n        for (const neighbor of graph[node]) {\n            if (even[neighbor] === null) {\n                even[neighbor] = 1 - even[node];\n                dfs(neighbor);\n            } else if (even[neighbor] === even[node]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    let cost = 0;\n    for (let i = 0; i < N; i++) {\n        if (even[i] === null) {\n            even[i] = 0;\n            if (!dfs(i)) {\n                cost++;\n                even[i] = 1;\n                dfs(i);\n            }\n        }\n    }\n\n    for (const [a, b, c] of conditions) {\n        if ((even[a - 1] + even[b - 1]) % 2 !== c) {\n            return -1;\n        }\n    }\n\n    return cost;\n}",
    "timestamp": "2025-08-13 12:48:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size + 1 }, (_, i) => i);\n        this.rank = Array(size + 1).fill(0);\n    }\n\n    find(u) {\n        if (this.parent[u] !== u) {\n            this.parent[u] = this.find(this.parent[u]);\n        }\n        return this.parent[u];\n    }\n\n    union(u, v) {\n        let rootU = this.find(u);\n        let rootV = this.find(v);\n        if (rootU === rootV) return;\n        if (this.rank[rootU] > this.rank[rootV]) {\n            this.parent[rootV] = rootU;\n        } else if (this.rank[rootU] < this.rank[rootV]) {\n            this.parent[rootU] = rootV;\n        } else {\n            this.parent[rootV] = rootU;\n            this.rank[rootU]++;\n        }\n    }\n}\n\nfunction solve(N, M, conditions) {\n    const uf = new UnionFind(2 * N);\n    for (const [a, b, c] of conditions) {\n        if (c === 0) {\n            uf.union(a, b);\n            uf.union(a + N, b + N);\n        } else {\n            uf.union(a, b + N);\n            uf.union(a + N, b);\n        }\n    }\n\n    for (let i = 1; i <= N; i++) {\n        if (uf.find(i) === uf.find(i + N)) {\n            return -1;\n        }\n    }\n\n    const visited = new Set();\n    let cost = 0;\n    for (let i = 1; i <= N; i++) {\n        if (!visited.has(uf.find(i)) && !visited.has(uf.find(i + N))) {\n            let root1 = uf.find(i);\n            let root2 = uf.find(i + N);\n            let count1 = 0;\n            let count2 = 0;\n            for (let j = 1; j <= N; j++) {\n                if (uf.find(j) === root1) count1++;\n                if (uf.find(j) === root2) count2++;\n            }\n            cost += Math.min(count1, count2);\n            visited.add(root1);\n            visited.add(root2);\n        }\n    }\n    return cost;\n}\n\n// Example usage:\n// const N = 3;\n// const M = 1;\n// const conditions = [[1, 2, 0]];\n// console.log(solve(N, M, conditions));",
    "timestamp": "2025-08-13 12:48:40"
  }
]