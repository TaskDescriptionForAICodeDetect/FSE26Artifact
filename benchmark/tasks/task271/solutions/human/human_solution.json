[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <cassert>\n\nusing namespace std;\n\nconst int MOD = 2011;\n\narray<int, 2011> inv;\n\nvoid init() {\n    for(int i = 0; i < MOD; ++i) {\n        for(int j = 1; j < MOD; ++j) {\n            if(i * j % MOD == 1) {\n                inv[i] = j;\n                break;\n            }\n        }\n    }\n}\n\nvector<string> input;\n\nint base_row(int r, int c, int er, int ec) {\n    for(int i = r; i < er; ++i) {\n        if(input[i][c] != '.') return i;\n    }\n    cerr << \"Empty column: \" << c << endl;\n    assert(false);\n}\n\nvoid skip_white(int r, int &c, int er, int ec) {\n    while(true) {\n        for(int i = r; i < er; ++i) {\n            if(input[i][c] != '.') return;\n        }\n        ++c;\n    }\n}\n\nint term(int r, int &c, int er, int ec);\nint factor(int r, int &c, int er, int ec);\nint powexpr(int r, int &c, int er, int ec);\nint primary(int r, int &c, int er, int ec);\nint fraction(int r, int &c, int er, int ec);\nint digit(int r, int c);\n\nint expr(int r, int &c, int er, int ec) {\n    skip_white(r, c, er, ec);\n    const int base = base_row(r, c, er, ec);\n    int lhs = term(r, c, er, ec);\n    while(c < ec) {\n        while(input[base][c] == '.') ++c;\n        const char op = input[base][c];\n        int rhs;\n        switch(op) {\n            case '+':\n                ++c;\n                rhs = term(r, c, er, ec);\n                lhs += rhs;\n                lhs %= MOD;\n                break;\n            case '-':\n                ++c;\n                rhs = term(r, c, er, ec);\n                lhs -= rhs;\n                while(lhs < 0) lhs += MOD;\n                break;\n            default:\n                return lhs;\n        }\n    }\n    return lhs;\n}\n\nint term(int r, int &c, int er, int ec) {\n    skip_white(r, c, er, ec);\n    const int base = base_row(r, c, er, ec);\n    int lhs = factor(r, c, er, ec);\n    while(c < ec) {\n        while(input[base][c] == '.') ++c;\n        const char op = input[base][c];\n        int rhs;\n        switch(op) {\n            case '*':\n                ++c;\n                rhs = factor(r, c, er, ec);\n                lhs *= rhs;\n                lhs %= MOD;\n                break;\n            default:\n                return lhs;\n        }\n    }\n    return lhs;\n}\n\nint factor(int r, int &c, int er, int ec) {\n    skip_white(r, c, er, ec);\n    const int base = base_row(r, c, er, ec);\n    if(input[base][c] == '-') {\n        if(input[base][c+1] == '.') { // negate\n            c += 2;\n            const int f = factor(r, c, er, ec);\n            //cout << f << ' ' << c << endl;\n            return MOD - f;\n        } else if(input[base][c+1] == '-') { // fraction\n            return fraction(r, c, er, ec);\n        } else {\n            cerr << \"Unknown factor at \" << r << ' ' << c << ' ' << base << endl;\n            assert(false);\n        }\n    } else if(isdigit(input[base][c]) || input[base][c] == '(') { // powexpr\n        return powexpr(r, c, er, ec);\n    } else {\n        cerr << \"Unknown factor at \" << r << ' ' << c << ' ' << base << endl;\n        assert(false);\n    }\n}\n\nint fraction(int r, int &c, int er, int ec) {\n    const int base = base_row(r, c, er, ec);\n    int fec = c;\n    while(fec < ec && input[base][fec] == '-') ++fec;\n    int nc = c+1;\n    const int num = expr(r, nc, base, fec-1);\n    nc = c+1;\n    const int den = expr(base+1, nc, er, fec-1);\n    c = fec;\n    return num * inv[den] % MOD;\n}\n\nint powexpr(int r, int &c, int er, int ec) {\n    const int base = base_row(r, c, er, ec);\n    const int n = primary(r, c, er, ec);\n    if(base > r && c < ec && input[base-1][c] != '.') {\n        const int x = digit(base-1, c);\n        //cerr << n << ' ' << x << ' ' << c << endl;\n        ++c; // skip digit\n        int res = 1;\n        for(int i = 0; i < x; ++i) {\n            res *= n;\n            res %= MOD;\n        }\n        return res;\n    } else {\n        return n;\n    }\n}\n\nint primary(int r, int &c, int er, int ec) {\n    const int base = base_row(r, c, er, ec);\n    if(input[base][c] == '(') { // expr\n        ++c; // skip paren\n        while(input[base][c] == '.') ++c; // skip space\n        const int res = expr(r, c, er, ec);\n        while(input[base][c] == '.') ++c; // skip space\n        ++c; // skip paren\n        return res;\n    } else {\n        const int res = digit(base, c);\n        ++c;\n        return res;\n    }\n}\n\nint digit(int r, int c) {\n    return input[r][c] - '0';\n}\n\nbool solve() {\n    input.clear();\n    int N;\n    if(!(cin >> N)) return false;\n    if(!N) return false;\n\n    input.resize(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> input[i];\n    }\n    int c = 0;\n    cout << expr(0, c, N, input[0].size()) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    init();\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\ntemplate <class T1>\nclass Operators\n{\npublic:\n    template <class T2>\n    const T1 operator+(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        return ans += right;\n    }\n    template <class T2>\n    const T1 operator-(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        return ans -= right;\n    }\n    template <class T2>\n    const T1 operator*(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        return ans *= right;\n    }\n    template <class T2>\n    const T1 operator/(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        return ans /= right;\n    }\n    template <class T2>\n    const T1 operator%(const T2& right) const{\n        T1 ans = static_cast<const T1&>( *this );\n        return ans %= right;\n    }\n    bool operator!=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(left == right);\n    }\n    bool operator>(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return right < left;\n    }\n    bool operator<=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(right < left);\n    }\n    bool operator>=(const T1& right) const{\n        const T1& left = static_cast<const T1&>( *this );\n        return !(left < right);\n    }\n};\n\nclass Mod : public Operators<Mod>\n{\nprivate:\n    static const int MOD = 2011;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = (x % MOD + MOD) % MOD;\n    }\n    Mod& operator+=(const Mod& x){\n        a = (a + x.a) % MOD;\n        return *this;\n    }\n    Mod& operator-=(const Mod& x){\n        a = (a - x.a + MOD) % MOD;\n        return *this;\n    }\n    Mod& operator*=(const Mod& x){\n        a = (a * x.a) % MOD;\n        return *this;\n    }\n    Mod& operator/=(const Mod& x){ // フェルマーの小定理、MODが素数である場合のみ有効\n        int b = MOD - 2;\n        long long c = x.a;\n        while(b > 0){\n            if(b & 1){\n                a *= c;\n                a %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n        return *this;\n    }\n    bool operator==(const Mod& x) const{\n        return a == x.a;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nclass Node{\npublic:\n    char ope;\n    string s;\n    Node *left, *right;\n    Node(){\n        ope = '\\0';\n        left = right = NULL;\n    }\n    ~Node(){\n        delete left;\n        delete right;\n    }\n};\n\n// 数式の構文木を作成する\nclass syntacticAnalysis\n{\nprivate:\n    vector<int> unaryPriority;        // 単項演算子の優先順位（数値が小さいほど優先順位が高い）\n    vector<int> binaryPriority;       // 二項演算子の優先順位（数値が小さいほど優先順位が高い）\n    vector<bool> binaryAssociativity; // 二項演算子の結合規則（trueならば左結合）\n    stack<Node*> stk;\n    void deleteAllNodes()\n    {\n        while(!stk.empty()){\n            delete stk.top();\n            stk.pop();\n        }\n    }\n    bool isValid(const Node* node){\n        return node != NULL && (!node->s.empty() || node->right != NULL);\n    }\n    bool calc(int maxPriority)\n    {\n        Node* right = stk.top();\n        if(!isValid(right))\n            return false;\n        stk.pop();\n        while(stk.top() != NULL){\n            Node* curr = stk.top();\n            if(isValid(curr))\n                break;\n            stk.pop();\n            // 二項演算子\n            if(binaryPriority[curr->ope] != -1 && isValid(stk.top())){\n                if(binaryPriority[curr->ope] > maxPriority ||\n                    (binaryPriority[curr->ope] == maxPriority && !binaryAssociativity[curr->ope]))\n                {\n                    stk.push(curr);\n                    break;\n                }\n                curr->right = right;\n                curr->left = stk.top();\n                stk.pop();\n                right = curr;\n            }\n            // 単項演算子\n            else if(unaryPriority[curr->ope] != -1){\n                if(unaryPriority[curr->ope] > maxPriority){\n                    stk.push(curr);\n                    break;\n                }\n                curr->right = right;\n                right = curr;\n            }\n            else{\n                stk.push(curr);\n                break;\n            }\n        }\n        bool ret = (stk.top() == NULL);\n        stk.push(right);\n        return ret;\n    }\npublic:\n    enum OpeType{\n        BINARY_LEFT,  // 二項演算子（左結合）\n        BINARY_RIGHT, // 二項演算子（右結合）\n        UNARY,        // 単項演算子\n    };\n\n    syntacticAnalysis(const vector<pair<string, OpeType> >& opeRule)\n    {\n        binaryPriority.assign(128, -1);\n        binaryAssociativity.assign(128, false);\n        unaryPriority.assign(128, -1);\n        for(unsigned i=0; i<opeRule.size(); ++i){\n            for(unsigned j=0; j<opeRule[i].first.size(); ++j){\n                if(opeRule[i].second == UNARY){\n                    unaryPriority[opeRule[i].first[j]] = i;\n                }\n                else{\n                    binaryPriority[opeRule[i].first[j]] = i;\n                    binaryAssociativity[opeRule[i].first[j]] = (opeRule[i].second == BINARY_LEFT);\n                }\n            }\n        }\n    }\n    Node* makeTree(const string& s)\n    {\n        int n = s.size();\n        int i = 0;\n        stk.push(NULL);\n        while(i < n){\n            // 括弧の開始\n            if(s[i] == '('){\n                stk.push(NULL);\n                ++ i;\n            }\n            // 括弧の終了\n            else if(s[i] == ')'){\n                // 括弧内の計算結果が不正、もしくは対応する括弧が無ければエラー終了\n                if(!calc(INT_MAX) || stk.size() == 2){\n                    deleteAllNodes();\n                    return NULL;\n                }\n                Node* node = stk.top();\n                stk.pop();\n                stk.pop();\n                stk.push(node);\n                ++ i;\n            }\n            // 演算子\n            else if(binaryPriority[s[i]] != -1 || unaryPriority[s[i]] != -1){\n                // 現在の演算子よりも優先順位の高い演算子の計算を確定させる\n                calc(binaryPriority[s[i]]);\n                Node* node = new Node;\n                node->ope = s[i];\n                stk.push(node);\n                ++ i;\n            }\n            // 被演算子\n            else{\n                Node* node = new Node;\n                while(i < n && s[i] != '(' && s[i] != ')' && binaryPriority[s[i]] == -1 && unaryPriority[s[i]] == -1){\n                    node->s += s[i];\n                    ++ i;\n                }\n                stk.push(node);\n            }\n        }\n\n        // 計算結果が不正だったらエラー終了\n        if(!calc(INT_MAX) || stk.size() != 2){\n            deleteAllNodes();\n            return NULL;\n        }\n\n        Node* ret = stk.top();\n        stk.pop();\n        stk.pop();\n        return ret;\n    }\n};\n\ntemplate <class T>\nT power(T a, long long b)\n{\n    T ret = 1;\n    T tmp = a;\n    while(b > 0){\n        if(b & 1)\n            ret *= tmp;\n        tmp *= tmp;\n        b >>= 1;\n    }\n    return ret;\n}\n\n/******************************************************************/\n\nclass AsciiExpression\n{\nprivate:\n    vector<string> grid;\n    string s;\n\n    void fit(int& y1, int& x1, int& y2, int& x2)\n    {\n        while(grid[y1].substr(x1, x2 - x1) == string(x2 - x1, '.'))\n            ++ y1;\n        while(grid[y2-1].substr(x1, x2 - x1) == string(x2 - x1, '.'))\n            -- y2;\n        for(;;){\n            bool empty = true;\n            for(int y = y1; y < y2; ++y){\n                if(grid[y][x1] != '.')\n                    empty = false;\n            }\n            if(!empty)\n                break;\n            ++ x1;\n        }\n        for(;;){\n            bool empty = true;\n            for(int y = y1; y < y2; ++y){\n                if(grid[y][x2-1] != '.')\n                    empty = false;\n            }\n            if(!empty)\n                break;\n            -- x2;\n        }\n    }\n\n    void convert(int y1, int x1, int y2, int x2)\n    {\n        fit(y1, x1, y2, x2);\n\n        int base = y1;\n        while(grid[base][x1] == '.')\n            ++ base;\n\n        int x = x1;\n        while(x < x2){\n            if(grid[base][x] == '.'){\n                if(base > y1 && grid[base-1][x] != '.'){\n                    s += '^';\n                    s += grid[base-1][x];\n                }\n                ++ x;\n            }\n            else if(grid[base].substr(x, 2) == \"--\"){\n                int x3 = grid[base].find_first_not_of('-', x);\n                if(x3 == string::npos)\n                    x3 = x2;\n                s += '(';\n                convert(y1, x, base, x3);\n                s += \")/(\";\n                convert(base + 1, x, y2, x3);\n                s += ')';\n                x = x3;\n            }\n            else{\n                s += grid[base][x];\n                ++ x;\n            }\n        }\n    }\n\n    Mod calc(const Node* node)\n    {\n        if(node->right == NULL)\n            return stoi(node->s);\n        else if(node->left == NULL)\n            return calc(node->right) * -1;\n\n        Mod a = calc(node->left);\n        Mod b = calc(node->right);\n        if(node->ope == '+')\n            return a + b;\n        else if(node->ope == '-')\n            return a - b;\n        else if(node->ope == '*')\n            return a * b;\n        else if(node->ope == '/')\n            return a / b;\n        else\n            return power(a, b.getValue());\n    }\n\npublic:\n    Mod solve(const vector<string>& grid)\n    {\n        this->grid = grid;\n        s.clear();\n        convert(0, 0, grid.size(), grid[0].size());\n\n        syntacticAnalysis sa({\n            {\"^\", syntacticAnalysis::BINARY_LEFT},\n            {\"-\", syntacticAnalysis::UNARY},\n            {\"*/\", syntacticAnalysis::BINARY_LEFT},\n            {\"+-\", syntacticAnalysis::BINARY_LEFT},\n        });\n\n        auto tmp = sa.makeTree(\"1^-1\");\n\n        Node* node = sa.makeTree(s);\n        Mod ans = calc(node);\n        delete node;\n\n        return ans;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> grid(n);\n        for(int i=0; i<n; ++i)\n            cin >> grid[i];\n\n        AsciiExpression ae;\n        cout << ae.solve(grid).getValue() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\n/*constexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;*/\n\nconstexpr int mod = 2011;\n\nint powmod(int x, int n){\n    int ret = 1;\n    while(n){\n        if(n & 1) (ret *= x) %= mod, --n;\n        else (x *= x) %= mod, n >>= 1;\n    }\n    return ret;\n}\n\nint rev(int x){\n    return powmod(x, mod - 2);\n}\n\nint expr(vector<string> &s, int &i, int u, int d);\nint term(vector<string> &s, int &i, int u, int d);\nint factor(vector<string> &s, int &i, int u, int d);\nint powexpr(vector<string> &s, int &i, int u, int d);\nint primary(vector<string> &s, int &i, int u, int d);\nint fraction(vector<string> &s, int &i, int u, int d);\nint digit(vector<string> &s, int &i, int u, int d);\n\nint get_base(vector<string> &s, int &i, int u, int d){\n    For(x, i, s[0].size()){\n        For(y, u, d)if(s[y][x] != '.') return y;\n        ++i;\n    }\n    return -1;\n}\n\nint expr(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    int ret = term(s, i, u, d);\n    while(i+1 < (int)s[0].size() && (s[base][i+1] == '+' || s[base][i+1] == '-')){\n        ++i;\n        char op = s[base][i];\n        i += 2;\n        int rhs = term(s, i, u, d);\n        if(op == '+') (ret += rhs) %= mod;\n        else (ret += mod - rhs) %= mod;\n    }\n    return ret;\n}\n\nint term(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    int ret = factor(s, i, u, d);\n    while(i+1 < (int)s[0].size() && s[base][i+1] == '*'){\n        i += 3;\n        int rhs = factor(s, i, u, d);\n        (ret *= rhs) %= mod;\n    }\n    return ret;\n}\n\nint factor(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    if(s[base][i] == '-'){\n        if(s[base][i+1] == '.'){\n            i += 2;\n            return mod - factor(s, i, u, d);\n        }\n        else return fraction(s, i, u, d);\n    }\n    else return powexpr(s, i, u, d);\n}\n\nint powexpr(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    int ret = primary(s, i, u, d);\n    if(base > 0 && i < (int)s[0].size() && isdigit(s[base-1][i])){\n        ret = powmod(ret, digit(s, i, base - 1, base));\n    }\n    return ret;\n}\n\nint primary(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    if(isdigit(s[base][i])){\n        int ret = digit(s, i, base, base + 1);\n        return ret;\n    }\n    i += 2;\n    int ret = expr(s, i, u, d);\n    i += 2;\n    return ret;\n}\n\nint fraction(vector<string> &s, int &i, int u, int d){\n    int base = get_base(s, i, u, d);\n    int j = i, k = i;\n    int lhs = expr(s, j, u, base), rhs = expr(s, k, base + 1, d);\n    i = max(j, k) + 1;\n    return (lhs * rev(rhs)) % mod;\n}\n\nint digit(vector<string> &s, int &i, int u, int d){\n    int ret = s[u][i] - '0';\n    ++i;\n    return ret;\n}\n\nint main(){\n    int h;\n    while(scanf(\"%d\", &h) && h){\n        vector<string> s(h);\n        rep(i, h) cin >> s[i];\n        int idx = 0;\n        printf(\"%d\\n\", expr(s, idx, 0, h));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint inv[2011];\nchar str[30][128];\nint mod=2011;\nint a;\nint b;\nint find(int top,int bottom,int left){\n\tfor(int i=top;i<=bottom;i++)if(str[i][left]!='.')return i;\n}\nint find2(int top,int bottom,int left){\n\tfor(int i=left;i<b;i++){\n\t\tfor(int j=top;j<=bottom;j++){\n\t\t\tif(str[j][i]!='.')return i;\n\t\t}\n\t}\n}\npair<int,int>expr(int top,int bottom,int left);\npair<int,int> fraction(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tpair<int,int>bunshi=expr(top,base-1,find2(top,base-1,left));\n\tpair<int,int>bunbo=expr(base+1,bottom,find2(base+1,bottom,left));\n\treturn make_pair(bunshi.first*inv[bunbo.first]%mod,max(bunshi.second,bunbo.second)+1);\n}\npair<int,int> primary(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tint at=left;\n\tif(str[base][at]>='0'&&str[base][at]<='9'){\n\t\treturn make_pair(str[base][at]-'0',at);\n\t}else{\n\t\tpair<int,int>res=expr(top,bottom,left+2);\n\t\tres.second+=2;\n\t\treturn res;\n\t}\n}\npair<int,int> powexpr(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tint at=left;\n\tpair<int,int> val=primary(top,bottom,left);\n\tif(val.second<b-1&&base&&'0'<=str[base-1][val.second+1]&&str[base-1][val.second+1]<='9'){\n\t\tint res=1;\n\t\tfor(int i=0;i<str[base-1][val.second+1]-'0';i++){\n\t\t\tres=res*val.first%mod;\n\t\t}\n\t\treturn make_pair(res,val.second+1);\n\t}else{\n\t\treturn val;\n\t}\n}\npair<int,int> factor(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tint at=left;\n\tif(at<b-1&&str[base][at]=='-'&&str[base][at+1]=='-'){\n\t\treturn fraction(top,bottom,at);\n\t}else if(str[base][at]=='-'){\n\t\tpair<int,int> val=factor(top,bottom,at+2);\n\t\tval.first=2011-val.first;\n\t\treturn val;\n\t}else{\n\t\treturn powexpr(top,bottom,at);\n\t}\n}\npair<int,int> term(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tint val=1;\n\tint at=left;\n\twhile(1){\n\t\tpair<int,int> res=factor(top,bottom,at);\n\t\tat=res.second+2;\n\t\tval=val*res.first%mod;\n\t\tif(at>=b||str[base][at]!='*'){\n\t\t\tif(at>=b)return make_pair(val,at);\n\t\t\telse return make_pair(val,at-2);\n\t\t\tbreak;\n\t\t}\n\t\tat+=2;\n\t}\n}\npair<int,int> expr(int top,int bottom,int left){\n\tint base=find(top,bottom,left);\n\tint val=0;\n\tint at=left;\n\tint P=1;\n\twhile(1){\n\t\tpair<int,int> res=term(top,bottom,at);\n\t\tat=res.second+2;\n\t\tval=(val+P*res.first+mod)%mod;\n\t\tif(at>=b||(str[base][at]!='+'&&str[base][at]!='-')){\n\t\t\tif(at>=b)return make_pair(val,at);\n\t\t\telse return make_pair(val,at-2);\n\t\t}\n\t\tif(str[base][at]=='+')P=1;\n\t\telse P=-1;\n\t\tat+=2;\n\t}\n}\nint main(){\n\tinv[1]=1;\n\tfor(int i=2;i<2011;i++){\n\t\tinv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\t}\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t//\tprintf(\"%s\\n\",str[0]);\n\t\tb=strlen(str[0]);\n\t\tint B=0;\n\t\tfor(int i=0;i<a;i++)if(str[i][0]!='.')B=i;\n\t\tprintf(\"%d\\n\",expr(0,a-1,0).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define var auto\nusing ll = long long;\nconst char newl = '\\n';\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {if(a > b) a = b;}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {if(a < b) a = b;}\nusing namespace std;\n\nint h, w;\nvector<string> expr;\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n    static constexpr T mod = MOD;\n    T v;\n    Mint():v(0){}\n    Mint(signed v):v(v){}\n    Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n    Mint pow(long long k){\n        Mint res(1),tmp(v);\n        while(k){\n            if(k&1) res*=tmp;\n            tmp*=tmp;\n            k>>=1;\n        }\n        return res;\n    }\n\n    static Mint add_identity(){return Mint(0);}\n    static Mint mul_identity(){return Mint(1);}\n\n    Mint inv(){return pow(MOD-2);}\n\n    Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n    Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n    Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n    Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n    Mint operator+(Mint a) const{return Mint(v)+=a;}\n    Mint operator-(Mint a) const{return Mint(v)-=a;}\n    Mint operator*(Mint a) const{return Mint(v)*=a;}\n    Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n    Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n    bool operator==(const Mint a)const{return v==a.v;}\n    bool operator!=(const Mint a)const{return v!=a.v;}\n    bool operator <(const Mint a)const{return v <a.v;}\n\n    static Mint comb(long long n,int k){\n        Mint num(1),dom(1);\n        for(int i=0;i<k;i++){\n            num*=Mint(n-i);\n            dom*=Mint(i+1);\n        }\n        return num/dom;\n    }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\nusing M = Mint<int, 2011>;\n\nbool isBegin = true;\n\npair<M, int> parse(int baseY, int y1, int y2, int x1, int x2){\n    //parse single expr\n    if (baseY != -1){\n        //fraction or unary -\n        if (expr[baseY][x1] == '-'){\n            if (expr[baseY][x1 + 1] == '.'){\n                var afterExpr = parse(baseY, y1, y2, x1 + 2, -1);\n                return make_pair(-afterExpr.first, afterExpr.second);\n            }\n            else{\n                int x;\n                for (x = x1; expr[baseY][x] == '-' && x < w; x++);\n                x--;\n                var resa = parse(-1, y1, baseY - 1, x1 + 1, x - 1).first;\n                var resb = parse(-1, baseY + 1, y2, x1 + 1, x - 1).first;\n                return make_pair(resa / resb, x);\n            }\n        }\n        int x;\n        M res;\n        if (expr[baseY][x1] == '('){\n            int depth = 0;\n            for (x = x1; x < w; x++){\n                depth += (expr[baseY][x] == '(' ? 1 : expr[baseY][x] == ')' ? -1 : 0);\n                if (depth == 0) break;\n            }\n            res = parse(-1, y1, y2, x1 + 2, x - 2).first;\n        }\n        else{\n            res = expr[baseY][x1] - '0';\n            x = x1;\n        }\n\n        if (y1 <= baseY - 1 && x + 1 < w && expr[baseY - 1][x + 1] != '.') {\n            res = res.pow(expr[baseY - 1][x + 1] - '0');\n            x++;\n        }\n        return make_pair(res, x);\n    }\n\n\n    //find baseline\n    while (true){\n        for (int y = y1; y <= y2; y++){\n            var c = expr[y][x1];\n            if (c != '.'){\n                baseY = y;\n                break;\n            }\n        }\n        if (baseY != -1){\n            break;\n        }\n        x1++;\n    }\n\n    vector<M> num{};\n    vector<char> op{};\n\n    int x = x1;\n    while (true){\n        var res = parse(baseY, y1, y2, x, -1);\n        if (!op.empty() && op[op.size() - 1] == '*'){\n            op.pop_back();\n            num[num.size() - 1] *= res.first;\n        }\n        else{\n            num.push_back(res.first);\n        }\n        x = res.second;\n        x += 2;\n        if (x >= x2 || (expr[baseY][x] != '+' && expr[baseY][x] != '-' && expr[baseY][x] != '*')) break;\n        op.push_back(expr[baseY][x]);\n        x += 2;\n    }\n\n    M res = num[0];\n    for (int i = 0; i < op.size(); i++){\n        if (op[i] == '+') res += num[i + 1];\n        else res -= num[i + 1];\n    }\n\n    return make_pair(res, -1);\n}\n\nbool solve(){\n    cin >> h;\n    if (h == 0) return false;\n    expr = vector<string>(h);\n    for (int i = 0; i < h; i++) cin >> expr[i];\n    w = expr[0].size();\n    cout << parse(-1, 0, h - 1, 0, w - 1).first << endl;\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint w,h;\nchar s[25][100]; // half close\n\nvoid err(const char* ers){\n\tprintf(\"onerr %s\\n\",ers);\n}\n\nconst int MOD = 2011;\n\nint modpow(int p,int q){\n\tif(q==0)return 1;\n\tint res = modpow(p,q/2);\n\tres = (res*res)%MOD;\n\tif(q%2==1)res = (res*p)%MOD;\n\treturn res;\n}\n\nint modinv(int p){\n\treturn modpow(p,MOD-2);\n}\n\n/*\n?????¶?????¨???\n????????¨????????????????????????????????¨????????§?????????????????????\n\n?????????????????????...fraction ??¨ expr\n*/\n\n/*\n??????????\n*/\nint expr(int& t,int& b,int& l,int& r);\nint term(int& t,int& b,int& l,int& r);\nint factor(int& t,int& b,int& l,int& r);\nint powexpr(int& t,int& b,int& l,int& r);\nint primary(int& t,int& b,int& l,int& r);\nint fraction(int t,int b,int l,int r);\n\n//#define pospr(is) printf(\"%10s .. t..%2d b..%2d l..%2d r..%2d\\n\",is,t,b,l,r)\n#define pospr(is) ;\n\nint expr(int& t,int& b,int& l,int& r){\n\tpospr(\"expr\");\n\tint res = term(t,b,l,r);\n\t\n\tfor(;;){\n\t\tif(r<l+3)return res; // if l.r\n\t\t\n\t\tbool vd = true;\n\t\tint ind = 0;\n\t\treg(y,t,b){\n\t\t\tif(s[y][l]!='.' || s[y][l+2]!='.'){\n\t\t\t\tvd = false;\n\t\t\t}\n\t\t\tif(s[y][l+1]!='.'){\n\t\t\t\tif(ind!=0)vd = false;\n\t\t\t\telse if(s[y][l+1]=='+')ind = 1;\n\t\t\t\telse if(s[y][l+1]=='-')ind = 2;\n\t\t\t\telse vd = false;\n\t\t\t}\n\t\t}\n\t\tif(ind == 0 || !vd)return res%MOD;\n\t\t\n\t\tl+=3;\n\t\tint nr = term(t,b,l,r);\n\t\t\n\t\tif(ind==1)res=(res+nr)%MOD;\n\t\telse res=(res-nr+MOD)%MOD;\n\t}\n\t\n\t//printf(\"expr res %d\\n\",res);\n\treturn res;\t\n}\n\nint term(int& t,int& b,int& l,int& r){\n\tpospr(\"term\");\n\tint res = factor(t,b,l,r);\n\tif(r<l+3)return res; // if l.r\n\t\n\tbool vd = true;\n\tint ind = 0;\n\treg(y,t,b){\n\t\tif(s[y][l]!='.' || s[y][l+2]!='.'){\n\t\t\tvd = false;\n\t\t}\n\t\tif(s[y][l+1]!='.'){\n\t\t\tif(ind!=0)vd = false;\n\t\t\telse if(s[y][l+1]=='*')ind = 1;\n\t\t\telse vd = false;\n\t\t}\n\t}\n\tif(ind == 0 || !vd)return res;\n\t\n\tl+=3;\n\tres=(res*term(t,b,l,r))%MOD;\n\t//printf(\"term res %d\\n\",res);\n\treturn res;\n}\n\n\nint factor(int& t,int& b,int& l,int& r){\n\tpospr(\"factor\");\n\t//minus\n\t\n\tbool vd = true;\n\tif(r<l+2)vd=false; //if lr\n\telse{\n\t\tint p=0;\n\t\treg(y,t,b){\n\t\t\tif(s[y][l+1]!='.')vd = false;\n\t\t\tif(s[y][l]=='-')p++;\n\t\t\telse if(s[y][l]!='.')vd = false;\n\t\t}\n\t\tif(p!=1)vd = false;\n\t}\n\t\n\tif(vd){\n\t\tl+=2;\n\t\tint res=factor(t,b,l,r);\n\t\treturn (MOD*5-(res%MOD))%MOD;\n\t}\n\t\n\t\n\t//frac\n\t\n\tbool isfrac=true;\n\tint fracy = -1;\n\treg(y,t,b){\n\t\tif(s[y][l]=='-'){\n\t\t\tif(fracy==-1)fracy=y;\n\t\t\telse fracy = -2;\n\t\t}\n\t\telse if(s[y][l]!='.')isfrac=false;\n\t}\n\tif(fracy!=-1 && isfrac){\n\t\tint tl=l;\n\t\treg(x,l,r){\n\t\t\tif(s[fracy][x]!='-')break;\n\t\t\ttl = x;\n\t\t}\n\t\tint res = fraction(t,b,l,tl);\n\t\tl = tl+1;\n\t\treturn res;\n\t}\n\t\n\t//powexpr\n\treturn powexpr(t,b,l,r);\n}\n\n\nint powexpr(int& t,int& b,int& l,int& r){\n\tpospr(\"powexp\");\n\tint res = primary(t,b,l,r);\n\tint pn = -1;\n\treg(y,t,b){\n\t\tchar c = s[y][l];\n\t\tif(c=='.')continue;\n\t\tif('0'<=c && c<='9'){\n\t\t\tpn = c-'0';\n\t\t\tbreak;\n\t\t}\n\t\telse return res;\n\t}\n\tif(pn==-1)return res;\n\tl++;\n\tint nr = res;\n\tres = 1;\n\trep(i,pn){\n\t\tres=(res*nr)%MOD;\n\t}\n\treturn res;\n}\n\n\nint primary(int& t,int& b,int& l,int& r){\n\tpospr(\"primary\");\n\t//kakko\n\tbool isk = false;\n\t\n\treg(y,t,b){\n\t\tchar c = s[y][l];\n\t\tif(c=='.')continue;\n\t\tif(c=='('){\n\t\t\tl+=2;\n\t\t\tint res = expr(t,b,l,r);\n\t\t\tl+=2;\n\t\t\treturn res;\n\t\t}\n\t\tif('0'<=c && c<='9'){\n\t\t\tl++;\n\t\t\treturn c-'0';\n\t\t}\n\t}\n\terr(\"primary\");\n\texit(0);\n}\n\n\nvoid cutside(int& t,int& b,int& l,int& r){\n\tfor(;;){\n\t\tbool bl = false;\n\t\treg(y,t,b){\n\t\t\tif(s[y][l]!='.')bl=true;\n\t\t}\n\t\tif(bl)break;\n\t\tl++;\n\t}\n\t\n\tfor(;;){\n\t\tbool bl = false;\n\t\treg(y,t,b){\n\t\t\tif(s[y][r]!='.')bl=true;\n\t\t}\n\t\tif(bl)break;\n\t\tr--;\n\t}\t\n}\n\nint fraction(int t,int b,int l,int r){\n\tpospr(\"fraction\");\n\tint nt,nb,nl,nr,nv=-1;\n\treg(y,t,b){\n\t\tif(s[y][l]=='-'){\n\t\t\tnv=y;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(nv==-1){\n\t\terr(\"fraction\");\n\t\texit(0);\n\t}\n\t\n\tnt=t; nb=nv-1; nl=l+1; nr=r-1;\n\tcutside(nt,nb,nl,nr);\n\tint divee = expr(nt,nb,nl,nr);\n\n\tnt=nv+1; nb=b; nl=l+1; nr=r-1;\n\tcutside(nt,nb,nl,nr);\n\tint diver = expr(nt,nb,nl,nr);\n\n\treturn (divee*modinv(diver))%MOD;\n}\n\n\n\n\n\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&h);\n\t\tif(h==0)break;\n\t\trep(i,h)scanf(\"%s\",s[i]);\n\t\tw = strlen(s[0]);\n\t\tint t=0,b=h-1,l=0,r=w-1;\n\t\tprintf(\"%d\\n\",expr(t,b,l,r));\n\t}\n\treturn 0;\n}\n\n\n/*\n1\n2.+.3.*.5.-.7.+.9\n\n->19;\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n\n 3 + 4 * - 2\n-------------\n         2\n  - 1 - 2\n\n\n.3.+.4.*.-.2.\n-------------\n..........2..\n...-.1.-.2...\n\n\n........4...2..........\n(.1.-.----.)..*.-.5.+.6\n........2..............\n.......3...............\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <iostream>\n#include <stdexcept>\n#include <string>\n\nusing namespace std;\n\ntemplate <unsigned M>\nclass Mod {\n    private:\n        int x_;\n        int f(int x) {\n            return x < 0? (M - (-x) % M) % M: x % M;\n        }\n    public:\n        Mod(): x_(0) {}\n        Mod(int x): x_(f(x)) {}\n        operator int() const {\n            return x_;\n        }\n        Mod operator+() const {\n            return *this;\n        }\n        Mod operator-() const {\n            return Mod(-x_);\n        }\n        Mod operator+(const Mod &m) const {\n            return Mod(x_ + m.x_);\n        }\n        Mod operator-(const Mod &m) const {\n            return Mod(M - m.x_ + x_);\n        }\n        Mod operator*(const Mod &m) const {\n            return Mod(x_ * m.x_);\n        }\n        Mod operator/(const Mod &m) const {\n            return Mod(x_ * m.inv().x_);\n        }\n        Mod &operator+=(const Mod &m) {\n            x_ = f(x_ + m.x_);\n            return *this;\n        }\n        Mod &operator-=(const Mod &m) {\n            x_ = f(x_ - m.x_);\n            return *this;\n        }\n        Mod &operator*=(const Mod &m) {\n            x_ = f(x_ * m.x_);\n            return *this;\n        }\n        Mod &operator/=(const Mod &m) {\n            x_ = f(x_ * m.inv().x_);\n            return *this;\n        }\n        Mod inv() const {\n            int a[3] = {0, 1, M};\n            int b[3] = {1, 0, x_};\n            while (b[2] > 0) {\n                int r = a[2] / b[2];\n                for (int i = 0; i < 3; ++i) {\n                    a[i] = a[i] - b[i] * r;\n                }\n                swap(a, b);\n            }\n            if (a[2] != 1) {\n                throw logic_error(\"no inverse\");\n            }\n            return Mod(a[0]);\n        }\n        Mod pow(int p) const {\n            Mod x = 1;\n            Mod b = x_;\n            while (p > 0) {\n                if (p % 2 > 0) {\n                    x *= b;\n                }\n                b *= b;\n                p /= 2;\n            }\n            return x;\n        }\n};\n\ntypedef Mod<2011> M;\n\nclass Solver {\n    private:\n        unsigned find_base(unsigned &cur, int begin, int end) {\n            while (cur < str[0].length()) {\n                for (int i = begin; i < end; ++i) {\n                    if (str[i][cur] != '.') {\n                        return i;\n                    }\n                }\n                ++cur;\n            }\n            throw logic_error(\"base is not found\");\n        }\n        M digit(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            ++cur;\n            return M(str[base][cur - 1] - '0');\n        }\n        M fraction(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            unsigned cur1 = cur + 1;\n            unsigned cur2 = cur + 1;\n            M m1 = expr(cur1, begin, find_base(cur1, begin, base), base);\n            M m2 = expr(cur2, base + 1, find_base(cur2, base + 1, end), end);\n            cur = max(cur1, cur2) + 1;\n            return m1 / m2;\n        }\n        M primary(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            M m;\n            if (isdigit(str[base][cur])) {\n                return digit(cur, base, base, base + 1);\n            }\n            cur += 2;\n            m = expr(cur, begin, base, end);\n            cur += 2;\n            return m;\n        }\n        M powexpr(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            M m = primary(cur, begin, base, end);\n            if (base > 0 && isdigit(str[base - 1][cur])) {\n                m = m.pow(digit(cur, base - 1, base - 1, base));\n            }\n            return m;\n        }\n        M factor(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            M m;\n            bool is_negative = false;\n            while (str[base].substr(cur, 2) == \"-.\") {\n                is_negative = !is_negative;\n                cur += 2;\n            }\n            if (str[base][cur] == '-') {\n                m = fraction(cur, begin, base, end);\n            } else {\n                m = powexpr(cur, begin, base, end);\n            }\n            return is_negative? -m: m;\n        }\n        M term(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            M m = factor(cur, begin, base, end);\n            while (true) {\n                string op = str[base].substr(cur, 3);\n                if (op == \".*.\") {\n                    cur += 3;\n                    m *= factor(cur, begin, base, end);\n                } else {\n                    break;\n                }\n            }\n            return m;\n        }\n        M expr(unsigned &cur, const unsigned begin, const unsigned base, const unsigned end) {\n            M m = term(cur, begin, base, end);\n            while (true) {\n                string op = str[base].substr(cur, 3);\n                if (op == \".+.\") {\n                    cur += 3;\n                    m += term(cur, begin, base, end);\n                } else if (op == \".-.\") {\n                    cur += 3;\n                    m -= term(cur, begin, base, end);\n                } else {\n                    break;\n                }\n            }\n            return m;\n        }\n    public:\n        int n;\n        string str[20];\n        int solve() {\n            unsigned cur = 0;\n            return expr(cur, 0, find_base(cur, 0, n), n);\n        }\n};\n\nint main() {\n    Solver s;\n    while (true) {\n        cin >> s.n;\n        if (s.n == 0) {\n            return 0;\n        }\n        for (int i = 0; i < s.n; ++i) {\n            cin >> s.str[i];\n        }\n        cout << s.solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n\nint mod=2011;\n\nint inv[2011];\n\nint ruijo(int x,int n){\n\tint p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\nint n;\nint m;\nvector<string> v;\n\nint expr(int a,int b,int c,int d);\nint term(int a,int b,int c,int d);\nint factor(int a,int b,int c,int d);\nint powexpr(int a,int b,int c,int d);\nint primary(int a,int b,int c,int d);\n\n\nint expr(int a,int b,int c,int d){\n\t//cout << \"expr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn expr(a,b+1,c,d);\n\t}\n\tint x_tmp = -1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][d]!='.')x_tmp=i;\n\t}\n\tif(x_tmp==-1){\n\t\treturn expr(a,b,c,d-1);\n\t}\n\tint y=b;\n\tint yt = -1;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&(v[x][i]=='*'||v[x][i]=='+'||v[x][i]=='-')){\n\t\t\tif(v[x][i]=='+'){\n\t\t\t\ty = i;\n\t\t\t\tyt = i;\n\t\t\t}else if(v[x][i]=='*'){\n\t\t\t\tyt = i;\n\t\t\t}else{\n\t\t\t\tif(i!=d&&i!=0){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'&&v[x][i-1]=='.'){\n\t\t\t\t\t\tif(yt+2==i){\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn term(a,b,c,d);\n\t}else{\n\t\tif(v[x][y]=='-'){\n\t\t\treturn (mod+expr(a,b,c,y-2)-term(a,y+2,c,d))%mod;\n\t\t}else{\n\t\t\treturn (expr(a,b,c,y-2)+term(a,y+2,c,d))%mod;\n\t\t}\n\t}\n}\n\nint term(int a,int b,int c,int d){\n\t//cout << \"term \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn term(a,b+1,c,d);\n\t}\n\tint y=b;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&v[x][i]=='*'){\n\t\t\ty = i;\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn factor(a,b,c,d);\n\t}else{\n\t\treturn (term(a,b,c,y-2)*factor(a,y+2,c,d))%mod;\n\t}\n}\n\nint factor(int a,int b,int c,int d){\n\t//cout << \"factor \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn factor(a,b+1,c,d);\n\t}\n\tif(v[x][b]!='-'){\n\t\treturn powexpr(a,b,c,d);\n\t}\n\tif(v[x][b+1]=='-'){\n\t\treturn (expr(a,b,x-1,d)*inv[expr(x+1,b,c,d)])%mod;\n\t}else{\n\t\treturn (mod - factor(a,b+2,c,d))%mod;\n\t}\n}\n\nint powexpr(int a,int b,int c,int d){\n\t//cout << \"powexpr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn powexpr(a,b+1,c,d);\n\t}\n\tif(v[x][b]=='('){\n\t\tint depth = 0;\n\t\tfor(int i=b;i<=d;i++){\n\t\t\tif(v[x][i]=='('){\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tif(v[x][i]==')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth==0){\n\t\t\t\t\tif(x!=0&&i<d){\n\t\t\t\t\t\tif(v[x-1][i+1]!='.'&&v[x-1][b+1]!='-'){\n\n\t\t\t\t\t\t\treturn ruijo(expr(a,b+1,c,i-1),v[x-1][i+1]-'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn expr(a,b+1,c,i-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(x!=0&&b<d){\n\t\t\tif(v[x-1][b+1]!='.'&&v[x-1][b+1]!='-'){\n\t\t\t\treturn ruijo(v[x][b]-'0',v[x-1][b+1]-'0');\n\t\t\t}\n\t\t}\n\t\treturn v[x][b]-'0';\n\t}\n}\n\nint main(){\n\tfor(int i=1;i<2011;i++){\n\t\tinv[i] = ruijo(i,2009);\n\t}\n\twhile(cin >> n&&n!=0){\n\t\tv.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t\tm = v[0].size();\n\t\tint ans=0; \n\t\tans = expr(0,0,n-1,m-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MOD = 2011;\nint inv[2022];\nchar AA[100][100];\nbool visited[100][100];\n\nclass Result\n{\npublic:\n\tint x,y,v;\n\tResult()\n\t{}\n\n\tResult(int x, int y, int v)\n\t\t:x(x),y(y),v(v)\n\t{}\n};\n\nint findexpr(int x, int y, int d)\n{\n\twhile(1) {\n\t\tif(y < 0 || AA[y][x] == '!') break;\n\t\tif(visited[y][x]) break;\n\t\tif(AA[y][x] !='.') return y;\n\n\t\ty += d;\n\t}\n\n\treturn -1;\n}\n\nResult expr(int x, int y);\nResult term(int x, int y);\nResult factor(int x, int y);\nResult powexpr(int x, int y);\nResult primary(int x, int y);\nResult fraction(int x, int y);\nResult digit(int x, int y);\n\nResult expr(int x, int y)\n{\n\tvisited[y][x] = true;\n\tResult a = term(x,y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '+' || AA[y][x+1] == '-') {\n\t\tvisited[y][x+1] = true;\n\t\tchar op = AA[y][x+1];\n\n\t\tResult b = term(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\t\n\t\tif(op == '+') a.v = (a.v + b.v) % MOD;\n\t\tif(op == '-') a.v = (a.v - b.v + MOD) % MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult term(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a = factor(x, y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '*') {\n\t\tvisited[y][x+1] = true;\n\n\t\tResult b = factor(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\ta.v *= b.v;\n\t\ta.v %= MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult factor(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a;\n\tif(AA[y][x] == '-') {\n\t\tif(AA[y][x+1] == '-') {\n\t\t\ta = fraction(x, y);\n\t\t}\n\t\telse {\n\t\t\ta = factor(x + 2, y);\n\t\t\ta.v = (-a.v + MOD) % MOD;\n\t\t}\n\t}\n\telse {\n\t\ta = powexpr(x, y);\n\t}\n\n\treturn a;\n}\n\nResult powexpr(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a = primary(x,y);\n\tx = a.x; y = a.y;\n\n\tif(y!=0 && isdigit(AA[y-1][x])) {\n\t\tint pw = AA[y-1][x] - '0';\n\t\tint p = a.v;\n\t\tint res = 1;\n\t\tfor(int i=0; i<pw; i++) {\n\t\t\tres *= p;\n\t\t\tres %= MOD;\n\t\t}\n\n\t\ta.v = res % MOD;\n\t\ta.x += 1;\n\t}\n\n\treturn a;\n}\n\nResult primary(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a;\n\tif(isdigit(AA[y][x])) {\n\t\ta.v = AA[y][x] - '0';\n\t\ta.x = x + 1;\n\t\ta.y = y;\n\t}\n\telse {\n\t\ta = expr(x + 2,y);\n\t\ta.x += 2;\n\t}\n\n\treturn a;\n}\n\nResult fraction(int x, int y)\n{\n\tbool findTop=false, findBtm=false;\n\tResult t, b;\n\n\tint tx = x;\n\twhile(AA[y][x] == '-') {\n\t\tvisited[y][x] = true;\n\t\tx++;\n\t}\n\n\tx = tx;\n\twhile(AA[y][x] == '-') {\n\t\tif(!findTop) {\n\t\t\tint ty = findexpr(x,y-1,-1);\n\t\t\tif(ty != -1) {\n\t\t\t\tt = expr(x,ty);\n\t\t\t\tfindTop = true;\n\t\t\t}\n\t\t}\n\t\tif(!findBtm) {\n\t\t\tint by = findexpr(x,y+1,1);\n\t\t\tif(by != -1) {\n\t\t\t\tb = expr(x,by);\n\t\t\t\tfindBtm = true;\n\t\t\t}\n\t\t}\n\n\t\tx++;\n\t}\n\n\tResult res;\n\tres.x = x;\n\tres.y = y;\n\tres.v = t.v * inv[b.v] % MOD;\n\n\treturn res;\n}\n\nint main()\n{\n\tfor(int i=1; i<MOD; i++)\n\tfor(int j=1; j<MOD; j++) \n\t\tif(j * i % MOD == 1) inv[i] = j;\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tfor(int i=0; i<100; i++)\n\t\tfor(int j=0; j<100; j++)\n\t\t\tAA[j][i] = '!';\n\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> AA[i];\n\n\t\tcout << expr(0, findexpr(0,0,1)).v << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int,int> result;\n\nresult expression(int x,int y,int h,vector<string> &s);\n\nresult primary(int x,int y,int h,vector<string> &s) {\n    // find base line\n    int base = y;\n    for(;base < y+h; ++base) if(s[base][x] != '.') break;\n\n    // digit\n    if(s[base][x] <= '9' && '0' <= s[base][x])\n        return result(s[base][x]-'0',x+1);\n\n    // paren\n    if(s[base][x] == '(') {\n        result r = expression(x+2,y,h,s);\n        if(s[base][r.second+1] == ')') {\n            r.second = r.second+2;\n            return r;\n        }\n        assert(false);\n        return r;\n    }\n    assert(false);\n\n    result r;\n    return r;\n}\n\nint powi(int x,int p) {\n    if(p == 0) return 1;\n    int ret = 1;\n    for(int i=0; i<p; ++i) {\n        ret *= x;\n        ret %= 2011;\n    }\n    return ret;\n}\n\nresult powexpr(int x,int y,int h,vector<string> &s) {\n    result r = primary(x,y,h,s);\n    for(int i=y; i<y+h; ++i) {\n        if(s[i][r.second] == '^') {\n            r.first = powi(r.first,s[i-1][r.second]-'0');\n            r.second++;\n            return r;\n        }\n    }\n    return r;\n}\n\nresult factor(int x,int y,int h,vector<string> &s) {\n    int base = y;\n    for(; base <y+h; ++base) if(s[base][x] != '.') break;\n\n    if(s[base][x] == '-' && (x+1 < s[base].length() && s[base][x+1] == '-')) {\n        // fraction\n        result r1 = expression(x,y,base-y,s);\n        result r2 = expression(x,base+1,h-(base-y)-1,s);\n\n        int k=x;\n        while(k < s[0].length() && s[base][k] == '-') k++;\n        \n        for(int i=1; i<2011; ++i)\n            if((r2.first * i)%2011 == 1)\n                return result((r1.first*i)%2011,k);\n    }\n\n    if(s[base][x] == '-') {\n        result r1 = factor(x+2,y,h,s);\n        r1.first *= -1;\n        r1.first += 2011;\n        r1.first %= 2011;\n        return r1;\n    }\n    return powexpr(x,y,h,s);\n}\n\nresult term(int x,int y,int h,vector<string> &s) {\n    result r1 = factor(x,y,h,s);\n\n    int base = y;\n    for(; base<y+h; ++base) if(s[base][x] != '.') break;\n\n    int k = r1.second;\n    int ret = r1.first;\n    while(true) {\n        if(k == s[0].length()) return result(ret,k);\n        if(s[base][k] == '.' && s[base][k+1] == '*') {\n            result r2 = factor(k+3,y,h,s);\n            ret = (ret*r2.first+2011)%2011;\n            k = r2.second;\n            continue;\n        }\n        return result(ret,k);\n    }\n}\n\nresult expression(int x,int y,int h,vector<string> &s) {\n    int base = y;\n    for(; base<y+h; ++base) if(s[base][x] != '.') break;\n    if(base == y+h) return expression(x+1,y,h,s);\n\n    result r1 = term(x,y,h,s);\n    if(r1.second == s[0].length()) return r1;\n\n    int k = r1.second;\n    int ret = r1.first;\n    while(true) {\n        if(k == s[0].length()) return result(ret,k);\n        if(s[base][k] == '.' && s[base][k+1] == '+'\n           && s[base][k+2] == '.') {\n            result r2 = term(k+3,y,h,s);\n            ret += r2.first;\n            k = r2.second;\n        }else if(s[base][k] == '.' && s[base][k+1] == '-') {\n            result r2 = term(k+3,y,h,s);\n            ret -= r2.first;\n            k = r2.second;\n        }else return result(ret,k);\n        ret = (ret+2011)%2011;\n    }\n}\n\nint main() {\n    int n;\n    while(cin>>n, n) {\n        vector<string> input(n, \"\");\n        for(int i=0; i<n; ++i) cin>>input[i];\n\n        // mask power\n        for(int i=1; i<n; ++i) {\n            for(int j=1; j<input[0].length(); ++j) {\n                if(input[i][j-1] != '.' && input[i-1][j] != '.'\n                   && input[i-1][j] != '-' && input[i][j] == '.')\n                    input[i][j] = '^';\n            }\n        }\n\n        result f = expression(0,0,n,input);\n        cout<<f.first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n\nint mod=2011;\n\nint inv[2011];\n\nint ruijo(int x,int n){\n\tint p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\nint n;\nint m;\nvector<string> v;\n\nint expr(int a,int b,int c,int d);\nint term(int a,int b,int c,int d);\nint factor(int a,int b,int c,int d);\nint powexpr(int a,int b,int c,int d);\nint primary(int a,int b,int c,int d);\n\n\nint expr(int a,int b,int c,int d){\n\t//cout << \"expr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn expr(a,b+1,c,d);\n\t}\n\tint x_tmp = -1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][d]!='.')x_tmp=i;\n\t}\n\tif(x_tmp==-1){\n\t\treturn expr(a,b,c,d-1);\n\t}\n\tint y=b;\n\tint yt = -1;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&(v[x][i]=='*'||v[x][i]=='+'||v[x][i]=='-')){\n\t\t\tif(v[x][i]=='+'){\n\t\t\t\ty = i;\n\t\t\t\tyt = i;\n\t\t\t}else if(v[x][i]=='*'){\n\t\t\t\tyt = i;\n\t\t\t}else{\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'){\n\t\t\t\t\t\tyt = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i!=d&&i!=0){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'&&v[x][i-1]=='.'){\n\t\t\t\t\t\tif(yt+2==i){\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn term(a,b,c,d);\n\t}else{\n\t\tif(v[x][y]=='-'){\n\t\t\treturn (mod+expr(a,b,c,y-2)-term(a,y+2,c,d))%mod;\n\t\t}else{\n\t\t\treturn (expr(a,b,c,y-2)+term(a,y+2,c,d))%mod;\n\t\t}\n\t}\n}\n\nint term(int a,int b,int c,int d){\n\tcout << \"term \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn term(a,b+1,c,d);\n\t}\n\tint y=b;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&v[x][i]=='*'){\n\t\t\ty = i;\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn factor(a,b,c,d);\n\t}else{\n\t\treturn (term(a,b,c,y-2)*factor(a,y+2,c,d))%mod;\n\t}\n}\n\nint factor(int a,int b,int c,int d){\n\t//cout << \"factor \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn factor(a,b+1,c,d);\n\t}\n\tif(v[x][b]!='-'){\n\t\treturn powexpr(a,b,c,d);\n\t}\n\tif(v[x][b+1]=='-'){\n\t\treturn (expr(a,b,x-1,d)*inv[expr(x+1,b,c,d)])%mod;\n\t}else{\n\t\treturn (mod - factor(a,b+2,c,d))%mod;\n\t}\n}\n\nint powexpr(int a,int b,int c,int d){\n\t//cout << \"powexpr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn powexpr(a,b+1,c,d);\n\t}\n\tif(v[x][b]=='('){\n\t\tint depth = 0;\n\t\tfor(int i=b;i<=d;i++){\n\t\t\tif(v[x][i]=='('){\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tif(v[x][i]==')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth==0){\n\t\t\t\t\tif(x!=0&&i<d){\n\t\t\t\t\t\tif(v[x-1][i+1]!='.'&&v[x-1][b+1]!='-'){\n\n\t\t\t\t\t\t\treturn ruijo(expr(a,b+1,c,i-1),v[x-1][i+1]-'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn expr(a,b+1,c,i-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(x!=0&&b<d){\n\t\t\tif(v[x-1][b+1]!='.'&&v[x-1][b+1]!='-'){\n\t\t\t\treturn ruijo(v[x][b]-'0',v[x-1][b+1]-'0');\n\t\t\t}\n\t\t}\n\t\treturn v[x][b]-'0';\n\t}\n}\n\nint main(){\n\tfor(int i=1;i<2011;i++){\n\t\tinv[i] = ruijo(i,2009);\n\t}\n\twhile(cin >> n&&n!=0){\n\t\tv.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t\tm = v[0].size();\n\t\tint ans=0; \n\t\tans = expr(0,0,n-1,m-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MOD = 2011;\nint inv[2022];\nchar AA[100][100];\nbool visited[100][100];\n\nclass Result\n{\npublic:\n\tint x,y,v;\n\tResult()\n\t{}\n\n\tResult(int x, int y, int v)\n\t\t:x(x),y(y),v(v)\n\t{}\n};\n\nint findexpr(int x, int y, int d)\n{\n\twhile(1) {\n\t\tif(y < 0 || AA[y][x] == '!') break;\n\t\tif(visited[y][x]) break;\n\t\tif(AA[y][x] !='.') return y;\n\n\t\ty += d;\n\t}\n\n\treturn -1;\n}\n\nResult expr(int x, int y);\nResult term(int x, int y);\nResult factor(int x, int y);\nResult powexpr(int x, int y);\nResult primary(int x, int y);\nResult fraction(int x, int y);\nResult digit(int x, int y);\n\nResult expr(int x, int y)\n{\n\tResult a = term(x,y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '+' || AA[y][x+1] == '-') {\n\t\tchar op = AA[y][x+1];\n\n\t\tResult b = term(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\t\n\t\tif(op == '+') a.v = (a.v + b.v) % MOD;\n\t\tif(op == '-') a.v = (a.v - b.v + MOD) % MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult term(int x, int y)\n{\n\tResult a = factor(x, y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '*') {\n\t\tResult b = factor(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\ta.v *= b.v;\n\t\ta.v %= MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult factor(int x, int y)\n{\n\tResult a;\n\tif(AA[y][x] == '-') {\n\t\tif(AA[y][x+1] == '-') {\n\t\t\ta = fraction(x, y);\n\t\t}\n\t\telse {\n\t\t\ta = factor(x + 2, y);\n\t\t\ta.v = (-a.v + MOD) % MOD;\n\t\t}\n\t}\n\telse {\n\t\ta = powexpr(x, y);\n\t}\n\n\treturn a;\n}\n\nResult powexpr(int x, int y)\n{\n\tResult a = primary(x,y);\n\tx = a.x; y = a.y;\n\n\tif(y!=0 && isdigit(AA[y-1][x])) {\n\t\tint pw = AA[y-1][x] - '0';\n\t\tint p = a.v;\n\t\tint res = 1;\n\t\tfor(int i=0; i<pw; i++)\n\t\t\tres *= p;\n\n\t\ta.v = res % MOD;\n\t\ta.x += 1;\n\t}\n\n\treturn a;\n}\n\nResult primary(int x, int y)\n{\n\tResult a;\n\tif(isdigit(AA[y][x])) {\n\t\ta.v = AA[y][x] - '0';\n\t\ta.x = x + 1;\n\t\ta.y = y;\n\t}\n\telse {\n\t\ta = expr(x + 2,y);\n\t\ta.x += 2;\n\t}\n\n\treturn a;\n}\n\nResult fraction(int x, int y)\n{\n\tbool findTop=false, findBtm=false;\n\tResult t, b;\n\n\tint tx = x;\n\twhile(AA[y][x] == '-') {\n\t\tvisited[y][x] = true;\n\t\tx++;\n\t}\n\n\tx = tx;\n\twhile(AA[y][x] == '-') {\n\t\tif(!findTop) {\n\t\t\tint ty = findexpr(x,y-1,-1);\n\t\t\tif(ty != -1) {\n\t\t\t\tt = expr(x,ty);\n\t\t\t\tfindTop = true;\n\t\t\t}\n\t\t}\n\t\tif(!findBtm) {\n\t\t\tint by = findexpr(x,y+1,1);\n\t\t\tif(by != -1) {\n\t\t\t\tb = expr(x,by);\n\t\t\t\tfindBtm = true;\n\t\t\t}\n\t\t}\n\n\t\tx++;\n\t}\n\n\tResult res;\n\tres.x = x;\n\tres.y = y;\n\tres.v = t.v * inv[b.v] % MOD;\n\n\treturn res;\n}\n\nint main()\n{\n\tfor(int i=1; i<MOD; i++)\n\tfor(int j=1; j<MOD; j++) \n\t\tif(j * i % MOD == 1) inv[i] = j;\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tfor(int i=0; i<100; i++)\n\t\tfor(int j=0; j<100; j++)\n\t\t\tAA[j][i] = '!';\n\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> AA[i];\n\n\t\tcout << expr(0, findexpr(0,0,1)).v << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S[111];\nint id;\nint N;\nint L;\n\n#define MOD (2011)\n\nint Y[2012];\nvoid init(){\n  for(int i=0;i<2011;i++){\n    for(int j=0;j<2011;j++){\n      if( i * j % MOD == 1 ) Y[i] = j;\n    }\n  }\n}\nint expr(int top,int bottom);\nint term(int top,int bottom);\nint factor(int top,int bottom);\nint powexpr(int top,int bottom);\nint primary(int top,int bottom);\nint fraction(int top,int bottom);\nint digit(int top,int bottom);\n\nint mod(int a,int m){\n  //if( abs(a) < m ) return a;\n  int ret = a%m;\n  return ret<0?MOD+ret:ret;\n}\n\nint maxpow(int a,int b){\n  int x = a;\n  int ret = 1;\n  while( b > 0 ){\n    if( b & 1 ) ret = mod(ret*x,MOD);\n    x = mod(x*x,MOD);\n    b>>=1;\n  }\n  return ret;\n}\n\n\n\nint check(int top,int bottom,int index){\n  while( index < L ){\n    id = index;\n    for(int i=top;i<=bottom;i++){\n      if( S[i][index] != '.' ) return i;\n    }\n    ++index;\n  }\n  return -1;\n}\n\nvoid print(string s,int top,int bottom,int base){\n  printf(\"%s top( %d ), bottom( %d ), base( %d ), id ( %d ), S[base][id]= %c \\n\\n\",\n\t s.c_str(),top,bottom,base,id,base==-1?'e':S[base][id]);\n}\n\nint expr(int top,int bottom) {\n  int base = check(top,bottom,id); \n  //print(\"expr\",top,bottom,base);\n    if( base == -1 ) return 2012;\n  int t = term(top,bottom);\n  while(  id < L && S[base][id] == '.' ){\n    int tmp_id = id;\n    id++;\n    if(  id < L && (S[base][id] == '+' || S[base][id] == '-') ){\n      char op = S[base][id];\n      id++;\n      if(  id < L && S[base][id] == '.' ){\n\tid++;\n\tint r = term(top,bottom);\n\t//print(\"expr return\",top,bottom,base);\n\t//printf(\" t = %d , r = %d\\n\",t,r);\n\tif( op == '+' ) t += r;\n\tif( op == '-' ) t -= r;\n\tt = mod(t,MOD);\n      } else {\n\tid = tmp_id;\n\tbreak;\n      }\n    } else {\n      id = tmp_id;\n      break;\n    }\n  }\n  return t;\n}\nint term(int top,int bottom) {\n  int base = check(top,bottom,id);\n  //print(\"term\",top,bottom,base);\n    if( base == -1 ) return 2012;\n  int t = factor(top,bottom);\n  //print(\"term retrun\",top,bottom,base);\n  //printf(\"t = %d\\n\",t);\n  while(  id < L && S[base][id] == '.' ){\n    int tmp_id = id;\n    id++;\n    if( id < L && S[base][id] == '*' ){\n      id++;\n      if(  id < L && S[base][id] == '.' ){\n\tid++;\n\tint r = factor(top,bottom);\n\t//print(\"term multi retrun\",top,bottom,base);\n\t//printf(\"t = %d\\n\",t);\n\tt = mod(t * r , MOD);\n\t//printf(\"r = %d t = %d\\n\",r,t);\n      } else {\n\tid = tmp_id;\n\tbreak;\n      }\n    } else {\n      id = tmp_id;\n      break;\n    }\n  }\n  return t;\n}\n\nint factor(int top,int bottom){\n  int base = check(top,bottom,id);\n //print(\"factor\",top,bottom,base);\n   if( base == -1 ) return 2012;\n  int tmp_id;\n  int t=2012;\n  bool f = false;\n  tmp_id = id;\n  t = powexpr(top,bottom);\n  if( t > 2011 ) {\n    id = tmp_id;\n    t = fraction(top,bottom);\n  }\n  if( t > 2011 ) {\n    id = tmp_id; \n    if( id+1 < L && S[base][id] == '-' && S[base][id+1] == '.'  ) {\n      id +=2;\n      f = true;\n      t = factor(top,bottom);\n    } \n  }\n  if( f ) t *= -1;\n  return mod(t,MOD); \n}\nint powexpr(int top,int bottom){\n  int base = check(top,bottom,id);\n //print(\"powexpr\",top,bottom,base);\n   if( base == -1 ) return 2012;\n  int t = 2012;\n  t = primary(top,bottom);\n  if ( t == 2012 ) return 2012;\n  if( id < L && base >0 && isdigit(S[base-1][id]) ){\n    int r = digit(base-1,base-1);\n    t = maxpow(t,r);\n    //print(\"powexpr return \",top,bottom,base);\n    //printf(\"t = %d\\n\",t);\n  }\n  return t;\n}\n\nint primary(int top,int bottom){\n  int base = check(top,bottom,id);\n //print(\"primary\",top,bottom,base);\n   if( base == -1 ) return 2012;\n  int tmp_id = id;\n  int t = digit(top,bottom);\n  if ( t == 2012 ){\n    id = tmp_id;\n    if( id+1 < L && S[base][id] == '(' && S[base][id+1] == '.' ){\n      id += 2;\n      t = expr(top,bottom);\n      if( t == 2012 ) return 2012;\n      //print(\"primary return\",top,bottom,base);\n      //printf(\"t = %d\\n\",t); \n      id +=2;\n    } else {\n      return t;\n    }\n  }\n  return t;\n}\n\nint fraction(int top,int bottom){\n  int base = check(top,bottom,id);\n //print(\"fraction\",top,bottom,base);\n  if( base == -1 ) return 2012;\n  int t = 2012;\n  if( id+2 < L && S[base][id] == '-' && S[base][id+1] == '-' && S[base][id+2] == '-'  ){\n    id++;\n    int tmp_id = id;\n    int p = expr(top,base-1);\n    id = tmp_id;\n    if( p == 2012 ) return 2012;\n    int q = expr(base+1,bottom);\n    if( q == 2012 ) return 2012;\n    id = max(id,tmp_id);\n    while( id < L && S[base][id] == '-' ) id++;\n    //print(\"fraction return\",top,bottom,base);\n    //printf(\"%d * Y[%d] = %d\\n\",p,q,Y[abs(q)]);\n    t = mod(p*Y[abs(q)]*(q<0?-1:1),MOD);\n  }\n  return t;\n}\nint digit(int top,int bottom){\n  int base = check( top,bottom,id );\n //print(\"digit\",top,bottom,base);\n if( base == -1 ) return 2012;\n  int t=0;\n  bool f = false;\n  while( id < L && isdigit(S[base][id]) ){\n    f = true;\n    t *= 10;\n    t += S[base][id]-'0';\n    id++;\n  }\n  if( f ) return mod(t,MOD);\n  return 2012;\n}\n\n\n\nint main(){\n  init();\n  while( cin >> N && N ){\n    for(int i=0;i<N;i++){\n      cin >> S[i];\n    }\n    id = 0;\n    L = (int)S[0].size();\n    int res = mod(expr(0,N-1),MOD);\n    if( res < 0 ) res = 2011+res;\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <assert.h>\n#define N 90\n#define M 30\n#define MOD 2011\nusing namespace std;\n\nstring str[M];\nint n;\n\nint quickPow(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) res = res * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\treturn res;\n}\n/*\nvoid print(int x1, int y1, int x2, int y2, bool b = 1) {\n\tfor (int i = x1; i <= x2; ++i) {\n\t\tfor (int j = y1; j <= y2; ++j) {\n\t\t\tif (b) cout << str[i][j];\n\t\t\telse cerr << str[i][j];\n\t\t}\n\t\tif (b) cout << endl;\n\t\telse cerr<<endl;\n\t}\n}\n*/\nvoid readString(string &s) {\n\tstatic char str[N];\n\tscanf(\"%s\", str);\n\ts = str;\n}\n\nint getBase(int x1, int x2, int y);\nint getExpr(int x1, int y1, int x2, int y2);\nint getTerm(int x1, int y1, int x2, int y2);\nint getFactor(int x1, int y1, int x2, int y2);\nint getPowexpr(int x1, int y1, int x2, int y2);\nint getPrimary(int x1, int y1, int x2, int y2);\nint getFraction(int x1, int y1, int x2, int y2);\n\nint getBase(int x1, int x2, int y) {\n\tfor (int i = x1; i <= x2; ++i) {\n\t\tif (str[i][y] != '.') {\n\t\t\treturn i;\n\t\t}\n\t}\n\tassert(false);\n}\n/*\nint Debug(int x1, int y1, int x2, int y2, int a, int b, int k) {\n\tcout << \"getExpr: \" << endl;\n\tprint(x1, y1, x2, y2);\n\tcout << \"ans: \" << a << ' ' << b << endl;\n\tswitch (k) {\n\t\tcase 0: return (a + b) % MOD;\n\t\tcase 1: return (a - b + MOD) % MOD;\n\t}\n}\n\nint Debug(int x1, int y1, int x2, int y2, int a) {\n\tcout << \"getExpr: \" << endl;\n\tprint(x1, y1, x2, y2);\n\tcout << \"ans: \" << a << endl;\n\treturn a;\n}\n*/\nint getExpr(int x1, int y1, int x2, int y2) {\n\t//cout << \"getExpr: \" << endl;\n\t//print(x1, y1, x2, y2);\n\tint lBrace = 0;\n\tint bas = getBase(x1, x2, y1);\n\tfor (int i = y2; i >= y1; --i) {\n\t\tif (str[bas][i] == '(') ++lBrace;\n\t\tif (str[bas][i] == ')') --lBrace;\n\t\tif (i > y1 && i < y2 && lBrace == 0 && str[bas][i - 1] == '.' && str[bas][i + 1] == '.') {\n\t\t\tif (str[bas][i] == '+') return (getExpr(x1, y1, x2, i - 2) + getTerm(x1, i + 2, x2, y2)) % MOD;\n\t\t\tif (str[bas][i] == '-') {\n\t\t\t\tif (i == x1 || str[bas][i - 2] == '+' || str[bas][i - 2] == '-' || str[bas][i - 2] == '*') continue;\n\t\t\t\treturn (getExpr(x1, y1, x2, i - 2) - getTerm(x1, i + 2, x2, y2) + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn getTerm(x1, y1, x2, y2);\n}\n\nint getTerm(int x1, int y1, int x2, int y2) {\n\tint bas = getBase(x1, x2, y1);\n\tint lBrace = 0;\n\tfor (int i = y2; i >= y1; --i) {\n\t\tif (str[bas][i] == '(') ++lBrace;\n\t\tif (str[bas][i] == ')') --lBrace;\n\t\tif (i > y1 && i < y2 && lBrace == 0 && str[bas][i - 1] == '.' && str[bas][i + 1] == '.') {\n\t\t\tif (str[bas][i] == '*') return getTerm(x1, y1, x2, i - 2) * getFactor(x1, i + 2, x2, y2) % MOD;\n\t\t}\n\t}\n\treturn getFactor(x1, y1, x2, y2);\n}\n\nint getFactor(int x1, int y1, int x2, int y2) {\n//\tcout << \"getFactor: \" << endl;\n//\tprint(x1, y1, x2, y2);\n\tint bas = getBase(x1, x2, y1);\n\tif (str[bas][y1] == '-') {\n\t\tif (y1 < y2 && str[bas][y1 + 1] == '.') return (MOD - getFactor(x1, y1 + 2, x2, y2)) % MOD;\n\t\telse return getFraction(x1, y1, x2, y2);\n\t}\n\telse return getPowexpr(x1, y1, x2, y2);\n}\n\nint getPowexpr(int x1, int y1, int x2, int y2) {\n//\tcout << \"getPowexpr: \" << endl;\n//\tprint(x1, y1, x2, y2);\n\tint bas = getBase(x1, x2, y1);\n\tif (bas > x1 && str[bas][y2] == '.' && isdigit(str[bas - 1][y2])) {\n\t\tint b = getPrimary(x1, y1, x2, y2 - 1);\n\t\tint m = str[bas - 1][y2] - '0';\n\t\treturn quickPow(b, m);\n\t}\n\treturn getPrimary(x1, y1, x2, y2);\n}\n\nint getPrimary(int x1, int y1, int x2, int y2) {\n//\tcout << \"getPrimary: \" << endl;\n//\tprint(x1, y1, x2, y2);\n\tint bas = getBase(x1, x2, y1);\n\tif (isdigit(str[bas][y1])) return str[bas][y1] - '0';\n\treturn getExpr(x1, y1 + 2, x2,  y2 - 2);\n}\n\nbool isEmpty(int x1, int x2, int y) {\n\tfor (int i = x1; i <= x2; ++i) {\n\t\tif (str[i][y] != '.') return false;\n\t}\n\treturn true;\n}\n\nint getFraction(int x1, int y1, int x2, int y2) {\n//\tcout << \"getFraction: \" << endl;\n//\tprint(x1, y1, x2, y2);\n\tint bas = getBase(x1, x2, y1);\n\tint sl, sr, ml, mr;\n\tfor (int i = y1; i <= y2; ++i) {\n\t\tif (!isEmpty(x1, bas - 1, i)) {\n\t\t\tsl = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y2; i >= y1; --i) {\n\t\tif (!isEmpty(x1, bas - 1, i)) {\n\t\t\tsr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y1; i <= y2; ++i) {\n\t\tif (!isEmpty(bas + 1, x2, i)) {\n\t\t\tml = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y2; i >= y1; --i) {\n\t\tif (!isEmpty(bas + 1, x2, i)) {\n\t\t\tmr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn (getExpr(x1, sl, bas - 1, sr) * quickPow(getExpr(bas + 1, ml, x2, mr), MOD - 2)) % MOD;\n}\n\nvoid solve() {\n\tfor (int i = 0; i < n; ++i) {\n\t\treadString(str[i]);\n\t}\n\tprintf(\"%d\\n\", getExpr(0, 0, n - 1, str[0].length() - 1) % MOD);\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 2011;\n\ntypedef long long int64;\n\nint expr(int, int, int);\n\ninline int64 modPow(int64 x, int64 n)\n{\n  if(n == 0) return (1);\n  int64 ret = modPow(x, n / 2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return (ret);\n}\n\ninline int64 modInv(int64 a)\n{\n  return (modPow(a, mod - 2));\n}\n\nint N, idx, width;\nstring S[20];\n\nint LatteMalta(int top, int bottom)\n{\n  while(idx < width) {\n    for(int i = top; i < bottom; i++) {\n      if(S[i][idx] != '.') return (i);\n    }\n    ++idx;\n  }\n  return (-1);\n}\n\nint primary(int base, int top, int bottom)\n{\n  if(S[base][idx] == '(') {\n    idx += 2;\n    auto get = expr(base, top, bottom);\n    idx += 2;\n    return (get);\n  } else {\n    return (S[base][idx++] - '0');\n  }\n}\n\nint powexpr(int base, int top, int bottom)\n{\n  int ret = primary(base, top, bottom);\n  if(top <= base - 1 && idx < width && isdigit(S[base - 1][idx])) {\n    return (modPow(ret, S[base - 1][idx++] - '0'));\n  } else {\n    return (ret);\n  }\n}\n\nint factor(int base, int top, int bottom)\n{\n  if(S[base][idx] == '-' && S[base][idx + 1] == '.') {\n    idx += 2;\n    return ((mod - factor(base, top, bottom)) % mod);\n  } else if(S[base][idx] == '-') {\n    int latte = idx;\n    auto ue = expr(LatteMalta(top, base), top, base);\n    idx = latte;\n    auto sita = expr(LatteMalta(base + 1, bottom), base + 1, bottom);\n    idx = latte;\n    while(idx < width && S[base][idx] == '-') ++idx;\n    return (ue * modInv(sita) % mod);\n  } else {\n    return (powexpr(base, top, bottom));\n  }\n}\n\nint term(int base, int top, int bottom)\n{\n  int ret = factor(base, top, bottom);\n  while(idx + 2 < width && S[base][idx] == '.' && S[base][idx + 1] == '*') {\n    idx += 3;\n    (ret *= factor(base, top, bottom)) %= mod;\n  }\n  return (ret);\n}\n\nint expr(int base, int top, int bottom)\n{\n  int ret = term(base, top, bottom);\n  while(idx + 2 < width && S[base][idx] == '.' && (S[base][idx + 1] == '+' || S[base][idx + 1] == '-')) {\n    char operation = S[base][idx + 1];\n    idx += 3;\n    auto get = term(base, top, bottom);\n    if(operation == '+') (ret += get) %= mod;\n    else (ret += mod - get) %= mod;\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> S[i];\n    idx = 0;\n    width = (int) S[0].size();\n    cout << expr(LatteMalta(0, N), 0, N) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Int;\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nInt invMod(Int a, Int m) {\n  Int x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\nint mod(int a) {\n  return (a%2011+2011)%2011;\n}\n\nint rec(vector<string> vs) {\n  int h = vs.size();\n  int w = vs[0].size();\n\n  // REP(y, h)\n  //   cout<< vs[y] << endl;\n  // cout << endl;\n  \n  int base;\n  int start;\n  REP(x, w) {\n    REP(y, h) {\n      if (vs[y][x] != '.') {\n        base = y;\n        start = x;\n        goto next;\n      }\n    }\n  }\nnext:;\n  char c = vs[base][start];\n\n  int nest = 0;\n  for (int x=w-1; x>=start; --x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (vs[base][x] == '+' && nest == 0) {\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) + rec(b));\n    }\n    if (x != start && vs[base][x] == '-' && vs[base][x+1] != '-' && vs[base][x-1] != '-' && nest == 0) {\n      if (x>=2 && (vs[base][x-2] =='+' || vs[base][x-2] =='-' || vs[base][x-2] =='*')) continue;\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) - rec(b));\n    }\n  }\n  nest = 0;\n  for (int x=start; x<w; ++x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (vs[base][x] == '*' && nest == 0) {\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) * rec(b));\n    }\n  }\n  \n  if (c == '-' && vs[base][start+1] != '-') {               // unary\n    // cout << \"unary\" << endl;\n    vector<string> a;\n    FOR(it, vs)\n      a.push_back(it->substr(start+2));\n    return mod(-rec(a));\n  }\n\n  if (c == '-' && vs[base][start+1] == '-') {               // fraction\n    vector<string> a,b;\n    REP(y, base) {\n      a.push_back(vs[y]);\n    }\n    for (int y=base+1; y<h; ++y) {\n      b.push_back(vs[y]);\n    }\n    int p = rec(a);\n    int q = rec(b);\n    // cout << p << \" \" << q << \" \" << invMod(q, 2011) << endl;\n    // cout << p*invMod(q, 2011)%2011 << endl;\n    return mod(p*invMod(q, 2011));\n  }\n    \n  nest = 0;\n  for (int x=start; x<w; ++x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (base&&isdigit(vs[base-1][x]) && nest == 0) {\n      vector<string> a;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x));\n      }\n      int res = rec(a);\n      int ans = 1;\n      REP(i, vs[base-1][x]-'0')\n        ans = mod(ans*res);\n      return ans;\n    }\n  }\n  \n  if (c == '(') {\n    nest = 0;\n    for (int x=start; x<w; ++x) {\n      if (vs[base][x] == '(') nest++;\n      if (vs[base][x] == ')') nest--;\n      if (nest == 0) {\n        vector<string> a;\n        FOR(it, vs) {\n          a.push_back(it->substr(start+1, x-start-1));\n        }\n        return rec(a);\n      }\n    }\n  }\n\n  return c - '0';\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<string> input(n);\n    REP(i,n)\n      cin>>input[i];\n    cout << rec(input) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "s[0]: LR[0, 23), TB[0, 4), base:1, prec:0\ns[0]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[0]: LR[0, 23), TB[0, 4), base:1, prec:2\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:0\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:2\nReturns 1\ns[6]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[6]: LR[0, 23), TB[0, 4), base:1, prec:2\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:0\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:1\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:2\nReturns 4\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:0\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:1\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:2\ns[2][8]: 2\n3^2: L83\n3^2\nReturns 9\n9^2009\nReturns 1788\ns[1][11] L57\ns[0][12]: 2\n224^2: L83\n224^2\nReturns 1912\ns[16]: LR[0, 23), TB[0, 4), base:1, prec:2\ns[18]: LR[0, 23), TB[0, 4), base:1, prec:2\nReturns 5\nReturns -5\n-1516\ns[0]: LR[0, 5), TB[0, 3), base:1, prec:0\ns[0]: LR[0, 5), TB[0, 3), base:1, prec:1\ns[0]: LR[0, 5), TB[0, 3), base:1, prec:2\ns[2]: LR[0, 5), TB[0, 3), base:1, prec:2\ns[3]: LR[2, 5), TB[0, 1), base:0, prec:0\ns[3]: LR[2, 5), TB[0, 1), base:0, prec:1\ns[3]: LR[2, 5), TB[0, 1), base:0, prec:2\nReturns 3\ns[3]: LR[2, 5), TB[2, 3), base:2, prec:0\ns[3]: LR[2, 5), TB[2, 3), base:2, prec:1\ns[3]: LR[2, 5), TB[2, 3), base:2, prec:2\nReturns 4\n4^2009\nReturns 1509\nReturns -1509\n-1509\ns[0]: LR[0, 13), TB[0, 4), base:1, prec:0\ns[0]: LR[0, 13), TB[0, 4), base:1, prec:1\ns[0]: LR[0, 13), TB[0, 4), base:1, prec:2\ns[1]: LR[0, 13), TB[0, 1), base:0, prec:0\ns[1]: LR[0, 13), TB[0, 1), base:0, prec:1\ns[1]: LR[0, 13), TB[0, 1), base:0, prec:2\nReturns 3\ns[5]: LR[0, 13), TB[0, 1), base:0, prec:1\ns[5]: LR[0, 13), TB[0, 1), base:0, prec:2\nReturns 4\ns[9]: LR[0, 13), TB[0, 1), base:0, prec:2\ns[11]: LR[0, 13), TB[0, 1), base:0, prec:2\nReturns 2\nReturns -2\ns[3]: LR[0, 13), TB[2, 4), base:3, prec:0\ns[3]: LR[0, 13), TB[2, 4), base:3, prec:1\ns[3]: LR[0, 13), TB[2, 4), base:3, prec:2\ns[5]: LR[0, 13), TB[2, 4), base:3, prec:2\nReturns 1\nReturns -1\n-1^2009\nReturns 5\n5\ns[0]: LR[0, 7), TB[0, 2), base:1, prec:0\ns[0]: LR[0, 7), TB[0, 2), base:1, prec:1\ns[0]: LR[0, 7), TB[0, 2), base:1, prec:2\ns[2]: LR[0, 7), TB[0, 2), base:1, prec:0\ns[2]: LR[0, 7), TB[0, 2), base:1, prec:1\ns[2]: LR[0, 7), TB[0, 2), base:1, prec:2\ns[0][3]: 2\n4^2: L83\n4^2\nReturns 16\ns[1][5] L57\ns[0][6]: 3\n16^3: L83\n16^3\nReturns 74\n74\ns[0]: LR[0, 17), TB[0, 1), base:0, prec:0\ns[0]: LR[0, 17), TB[0, 1), base:0, prec:1\ns[0]: LR[0, 17), TB[0, 1), base:0, prec:2\nReturns 2\ns[4]: LR[0, 17), TB[0, 1), base:0, prec:1\ns[4]: LR[0, 17), TB[0, 1), base:0, prec:2\nReturns 3\ns[8]: LR[0, 17), TB[0, 1), base:0, prec:2\nReturns 5\ns[12]: LR[0, 17), TB[0, 1), base:0, prec:1\ns[12]: LR[0, 17), TB[0, 1), base:0, prec:2\nReturns 7\ns[16]: LR[0, 17), TB[0, 1), base:0, prec:1\ns[16]: LR[0, 17), TB[0, 1), base:0, prec:2\nReturns 9\n19\ns[0]: LR[0, 25), TB[0, 1), base:0, prec:0\ns[0]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[0]: LR[0, 25), TB[0, 1), base:0, prec:2\ns[2]: LR[0, 25), TB[0, 1), base:0, prec:0\ns[2]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[2]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 2\ns[6]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[6]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 3\ns[0][8] L57\nReturns 5\ns[12]: LR[0, 25), TB[0, 1), base:0, prec:2\ns[14]: LR[0, 25), TB[0, 1), base:0, prec:0\ns[14]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[14]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 5\ns[18]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[18]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 7\ns[0][20] L57\nReturns 2009\ns[24]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[24]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 9\n2010\ns[0]: LR[0, 8), TB[0, 3), base:1, prec:0\ns[0]: LR[0, 8), TB[0, 3), base:1, prec:1\ns[0]: LR[0, 8), TB[0, 3), base:1, prec:2\ns[0][1]: 2\n4^2: L83\n4^2\nReturns 16\ns[5]: LR[0, 8), TB[0, 3), base:1, prec:1\ns[5]: LR[0, 8), TB[0, 3), base:1, prec:2\ns[1]: LR[5, 8), TB[0, 1), base:0, prec:0\ns[1]: LR[5, 8), TB[0, 1), base:0, prec:1\ns[1]: LR[5, 8), TB[0, 1), base:0, prec:2\nReturns 2\ns[6]: LR[5, 8), TB[2, 3), base:2, prec:0\ns[6]: LR[5, 8), TB[2, 3), base:2, prec:1\ns[6]: LR[5, 8), TB[2, 3), base:2, prec:2\nReturns 5\n5^2009\nReturns 1207\n1223\ns[0]: LR[0, 14), TB[0, 3), base:1, prec:0\ns[0]: LR[0, 14), TB[0, 3), base:1, prec:1\ns[0]: LR[0, 14), TB[0, 3), base:1, prec:2\ns[0][1]: 2\n4^2: L83\n4^2\nReturns 16\ns[5]: LR[0, 14), TB[0, 3), base:1, prec:1\ns[5]: LR[0, 14), TB[0, 3), base:1, prec:2\ns[7]: LR[0, 14), TB[0, 3), base:1, prec:2\ns[1]: LR[7, 14), TB[0, 1), base:0, prec:0\ns[1]: LR[7, 14), TB[0, 1), base:0, prec:1\ns[1]: LR[7, 14), TB[0, 1), base:0, prec:2\nReturns 2\ns[10]: LR[7, 14), TB[2, 3), base:2, prec:0\ns[10]: LR[7, 14), TB[2, 3), base:2, prec:1\ns[10]: LR[7, 14), TB[2, 3), base:2, prec:2\nReturns 5\n5^2009\nReturns 1207\nReturns -1207\n1223\ns[0]: LR[0, 25), TB[0, 9), base:1, prec:0\ns[0]: LR[0, 25), TB[0, 9), base:1, prec:1\ns[0]: LR[0, 25), TB[0, 9), base:1, prec:2\ns[12]: LR[0, 25), TB[0, 1), base:0, prec:0\ns[12]: LR[0, 25), TB[0, 1), base:0, prec:1\ns[12]: LR[0, 25), TB[0, 1), base:0, prec:2\nReturns 1\ns[1]: LR[0, 25), TB[2, 9), base:3, prec:0\ns[1]: LR[0, 25), TB[2, 9), base:3, prec:1\ns[1]: LR[0, 25), TB[2, 9), base:3, prec:2\nReturns 1\ns[5]: LR[0, 25), TB[2, 9), base:3, prec:1\ns[5]: LR[0, 25), TB[2, 9), base:3, prec:2\ns[14]: LR[5, 24), TB[2, 3), base:2, prec:0\ns[14]: LR[5, 24), TB[2, 3), base:2, prec:1\ns[14]: LR[5, 24), TB[2, 3), base:2, prec:2\nReturns 1\ns[6]: LR[5, 24), TB[4, 9), base:5, prec:0\ns[6]: LR[5, 24), TB[4, 9), base:5, prec:1\ns[6]: LR[5, 24), TB[4, 9), base:5, prec:2\nReturns 1\ns[10]: LR[5, 24), TB[4, 9), base:5, prec:1\ns[10]: LR[5, 24), TB[4, 9), base:5, prec:2\ns[16]: LR[10, 23), TB[4, 5), base:4, prec:0\ns[16]: LR[10, 23), TB[4, 5), base:4, prec:1\ns[16]: LR[10, 23), TB[4, 5), base:4, prec:2\nReturns 1\ns[11]: LR[10, 23), TB[6, 9), base:7, prec:0\ns[11]: LR[10, 23), TB[6, 9), base:7, prec:1\ns[11]: LR[10, 23), TB[6, 9), base:7, prec:2\nReturns 1\ns[15]: LR[10, 23), TB[6, 9), base:7, prec:1\ns[15]: LR[10, 23), TB[6, 9), base:7, prec:2\ns[18]: LR[15, 22), TB[6, 7), base:6, prec:0\ns[18]: LR[15, 22), TB[6, 7), base:6, prec:1\ns[18]: LR[15, 22), TB[6, 7), base:6, prec:2\nReturns 1\ns[16]: LR[15, 22), TB[8, 9), base:8, prec:0\ns[16]: LR[15, 22), TB[8, 9), base:8, prec:1\ns[16]: LR[15, 22), TB[8, 9), base:8, prec:2\nReturns 1\ns[20]: LR[15, 22), TB[8, 9), base:8, prec:1\ns[20]: LR[15, 22), TB[8, 9), base:8, prec:2\nReturns 2\n3^2009\nReturns 1341\n1342^2009\nReturns 1509\n1510^2009\nReturns 1437\n1438^2009\nReturns 1646\n1646\ns[0]: LR[0, 24), TB[0, 15), base:7, prec:0\ns[0]: LR[0, 24), TB[0, 15), base:7, prec:1\ns[0]: LR[0, 24), TB[0, 15), base:7, prec:2\ns[1]: LR[0, 24), TB[0, 7), base:3, prec:0\ns[1]: LR[0, 24), TB[0, 7), base:3, prec:1\ns[1]: LR[0, 24), TB[0, 7), base:3, prec:2\ns[3]: LR[0, 24), TB[0, 7), base:3, prec:0\ns[3]: LR[0, 24), TB[0, 7), base:3, prec:1\ns[3]: LR[0, 24), TB[0, 7), base:3, prec:2\ns[7]: LR[3, 12), TB[0, 3), base:2, prec:0\ns[7]: LR[3, 12), TB[0, 3), base:2, prec:1\ns[7]: LR[3, 12), TB[0, 3), base:2, prec:2\nReturns 2\ns[4]: LR[3, 12), TB[4, 7), base:5, prec:0\ns[4]: LR[3, 12), TB[4, 7), base:5, prec:1\ns[4]: LR[3, 12), TB[4, 7), base:5, prec:2\ns[5]: LR[4, 7), TB[4, 5), base:4, prec:0\ns[5]: LR[4, 7), TB[4, 5), base:4, prec:1\ns[5]: LR[4, 7), TB[4, 5), base:4, prec:2\nReturns 7\ns[5]: LR[4, 7), TB[6, 7), base:6, prec:0\ns[5]: LR[4, 7), TB[6, 7), base:6, prec:1\ns[5]: LR[4, 7), TB[6, 7), base:6, prec:2\nReturns 4\n4^2009\nReturns 1510\ns[10]: LR[3, 12), TB[4, 7), base:5, prec:1\ns[10]: LR[3, 12), TB[4, 7), base:5, prec:2\nReturns 1\n1511^2009\nReturns 732\ns[15]: LR[0, 24), TB[0, 7), base:3, prec:1\ns[15]: LR[0, 24), TB[0, 7), base:3, prec:2\ns[7]: LR[15, 20), TB[0, 3), base:2, prec:0\ns[7]: LR[15, 20), TB[0, 3), base:2, prec:1\ns[7]: LR[15, 20), TB[0, 3), base:2, prec:2\nReturns 2\ns[4]: LR[15, 20), TB[4, 7), base:5, prec:0\ns[4]: LR[15, 20), TB[4, 7), base:5, prec:1\ns[4]: LR[15, 20), TB[4, 7), base:5, prec:2\ns[17]: LR[4, 7), TB[4, 5), base:4, prec:0\ns[17]: LR[4, 7), TB[4, 5), base:4, prec:1\ns[17]: LR[4, 7), TB[4, 5), base:4, prec:2\nReturns 3\ns[24]: LR[4, 7), TB[6, 7), base:6, prec:0\ns[24]: LR[4, 7), TB[6, 7), base:6, prec:1\ns[24]: LR[4, 7), TB[6, 7), base:6, prec:2\na.out: D.cpp:78: intmax_t parse(const std::__debug::vector<std::__cxx11::basic_string<char> >&, size_t&, size_t, size_t, size_t, size_t, size_t, size_t, const std::__debug::vector<std::__cxx11::basic_string<char> >&): Assertion `false' failed.\nAborted (core dumped)\n\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nconstexpr intmax_t MOD=2011;\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return (lhs + rhs) % MOD;\n  case '-': return ((lhs - rhs) % MOD + MOD) % MOD;\n  case '*': return (lhs * rhs) % MOD;\n  }\n  assert(false);\n}\n\nintmax_t modpow(intmax_t base, intmax_t iexp) {\n  fprintf(stderr, \"%jd^%jd\\n\", base, iexp);\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1) (res *= dbl) %= MOD;\n    (dbl *= dbl) %= MOD;\n  }\n  return res;\n}\n\nintmax_t moddiv(intmax_t num, intmax_t den) {\n  intmax_t div=modpow(den, MOD-2);\n  return num*div % MOD;\n}\n\nintmax_t parse(const std::vector<std::string> &s, size_t &i,\n               size_t top, size_t bottom, size_t left, size_t right,\n               size_t preced=0, size_t base=-1,\n               const std::vector<std::string> &ops={\"+-\", \"*\"}) {\n\n  while (base+1 == 0) {\n    for (size_t r=top; r<bottom; ++r) {\n      if (s[r][i] != '.') {\n        base = r;\n        break;\n      }\n    }\n    if (base+1 == 0) ++i;\n  }\n  assert(base+1 != 0);\n  fprintf(stderr, \"s[%zu]: LR[%zu, %zu), TB[%zu, %zu), base:%zu, prec:%zu\\n\",\n          i, left, right, top, bottom, base, preced);\n\n  if (preced == ops.size()) {\n    intmax_t res=114514;\n    if (s[base][i] == '(') {\n      res = parse(s, i+=2, top, bottom, left, right, 0, base);\n      fprintf(stderr, \"s[%zu][%zu] L%d\\n\", base, i, __LINE__);\n      assert(s[base][i] == ')');\n      ++i;\n    } else if (s[base][i] == '-') {\n      if (s[base][i+1] == '-') {\n        size_t vl=i, vr=i+1;\n        while (s[base][++vr] == '-') {}\n\n        size_t j=left+1;\n        intmax_t numer=parse(s, j, top, base, vl, vr, 0);\n        j = left+1;\n        intmax_t denom=parse(s, j, base+1, bottom, vl, vr, 0);\n        res = moddiv(numer, denom);\n        i = vr;\n      } else {\n        res = -parse(s, i+=2, top, bottom, left, right, preced, base);\n      }\n    } else if (isdigit(s[base][i])) {\n      res = s[base][i]-'0';\n      ++i;\n    } else {\n      assert(false);\n    }\n\n    if (i < right && top+1 <= base && isdigit(s[base-1][i])) {\n      fprintf(stderr, \"s[%zu][%zu]: %c\\n\", base-1, i, s[base-1][i]);\n      fprintf(stderr, \"%jd^%jd: L%d\\n\", res, intmax_t(s[base-1][i]-'0'), __LINE__);\n      res = modpow(res, s[base-1][i]-'0');\n      ++i;\n    }\n    ++i;\n    fprintf(stderr, \"Returns %jd\\n\", res);\n    return res;\n  }\n\n  intmax_t lhs=parse(s, i, top, bottom, left, right, preced+1, base);\n  while (i < right) {\n    char op=s[base][i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t rhs=parse(s, i+=2, top, bottom, left, right, preced+1, base);\n    lhs = apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s;\n  for (size_t i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s.emplace_back(buf);\n  }\n\n  size_t i=0;\n  intmax_t res=parse(s, i, 0, s.size(), 0, s[0].length());\n  printf(\"%jd\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstatic const int M = 2011;\n\nint powmod(int a, int n)\n{\n  if (n == 0) {\n    return 1;\n  } else if (n & 1) {\n    return (a * powmod(a, n-1))%M;\n  } else {\n    const int e = powmod(a, n>>1);\n    return (e * e)%M;\n  }\n}\n\nstruct parser\n{\n  int i;\n  vector<string> src;\n  parser() : i(0), src() {}\n\n  int width() const { return src[0].size(); }\n  int height() const { return src.size(); }\n  int find_base(int top, int bot)\n  {\n    for (; i < width(); i++) {\n      for (int k = top; k < bot; k++) {\n        if (src[k][i] != '.') {\n          return k;\n        }\n      }\n    }\n    throw \"find_base\";\n  }\n\n  int parse(int top, int bot)\n  {\n    return expr(find_base(top, bot), top, bot);\n  }\n\n  int expr(int base, int top, int bot)\n  {\n    const string& line = src[base];\n    int r = term(base, top, bot);\n    while (i+2 < width() && line[i] == '.' && (line[i+1] == '+' || line[i+1] == '-') && line[i+2] == '.') {\n      const char op = line[i+1];\n      i += 3;\n      const int t = term(base, top, bot);\n      if (op == '+') {\n        r = (r + t)%M;\n      } else {\n        r = ((r - t)%M + M)%M;\n      }\n    }\n    return r;\n  }\n\n  int term(int base, int top, int bot)\n  {\n    const string& line = src[base];\n    int r = factor(base, top, bot);\n    while (i+2 < width() && line[i] == '.' && line[i+1] == '*' && line[i+2] == '.') {\n      i += 3;\n      const int t = factor(base, top, bot);\n      r = (r * t)%M;\n    }\n    return r;\n  }\n\n  int factor(int base, int top, int bot)\n  {\n    const string& line = src[base];\n    if (line[i] == '-') {\n      if (line[i+1] == '.') {\n        i += 2;\n        const int r = factor(base, top, bot);\n        return (-r + M)%M;\n      } else {\n        const int save = i;\n        const int n = parse(top, base);\n        i = save;\n        const int d = parse(base+1, bot);\n        i = save;\n        while (i < width() && line[i] == '-') {\n          ++i;\n        }\n        return (n * powmod(d, M-2))%M;\n      }\n    } else {\n      return powexpr(base, top, bot);\n    }\n  }\n\n  int powexpr(int base, int top, int bot)\n  {\n    int r = primary(base, top, bot);\n    if (base-1 >= top && i < width() && isdigit(src[base-1][i])) {\n      const int n = src[base-1][i]-'0';\n      i++;\n      return powmod(r, n);\n    } else {\n      return r;\n    }\n  }\n\n  int primary(int base, int top, int bot)\n  {\n    const string& line = src[base];\n    if (line[i] == '(' && line[i+1] == '.') {\n      i += 2;\n      const int r = expr(base, top, bot);\n      i += 2;\n      return r;\n    } else {\n      const int n = line[i]-'0';\n      i++;\n      return n;\n    }\n  }\n};\n\nint main()\n{\n  int N;\n  while (cin >> N && N != 0) {\n    parser p;\n    p.src.resize(N);\n    for (int i = 0; i < N; i++) {\n      cin >> p.src[i];\n    }\n    cout << p.parse(0, N) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int mod = 2011;\nint invtable[2011];\n\nstruct Area{\n    int x[2];\n    int y[2];\n    Area(int x1, int x2, int y1, int y2){\n        x[0]=x1; x[1]=x2; y[0]=y1; y[1]=y2;\n    }\n};\n\nint normalize(int a){\n    a %= mod;\n    return (a+mod) %mod;\n}\n\nArea trim(Area a, vector<string> &s){\n    int diff[2] = {1, -1};\n    for(int i=0; i<2; i++){\n        for(; ; a.x[i]+=diff[i]){\n            bool empty = true;\n            for(int y=a.y[0]; y<=a.y[1]; y++){\n                if(s[y][a.x[i]] != '.') empty = false;\n            }\n            if(!empty) break;\n        }\n        for(; ; a.y[i]+=diff[i]){\n            bool empty = true;\n            for(int x=a.x[0]; x<=a.x[1]; x++){\n                if(s[a.y[0]][x] != '.') empty = false;\n            }\n            if(!empty) break;\n        }\n    }\n    return a;\n}\n\n\nint parse_expr(Area a, vector<string> &s);\nint parse_term(Area a, vector<string> &s);\n\nint parse_expr(Area a, vector<string> &s){\n    int base = -1;\n    for(int y=a.y[0]; y<=a.y[1]; y++){\n        if(s[y][a.x[0]] != '.') base = y;\n    }\n    vector<int> operands;\n    vector<char> operators;\n    int sgn = 1;\n    for(int x=a.x[0], prev=a.x[0], depth=0; x<=a.x[1]+1; x++){\n        if(x==a.x[1]+1){\n            auto ret = parse_term(trim(Area(prev, x-1, a.y[0], a.y[1]), s), s);\n            operands.push_back((sgn*ret +mod) %mod);\n        }else if(depth==0 and (x<=a.x[0] or s[base][x-1]=='.') and (x>=a.x[1] or s[base][x+1]=='.')\n                and (s[base][x]=='+' or s[base][x]=='-' or s[base][x]=='*')){\n            if(x == prev){\n                sgn *= -1;\n            }else{\n                auto ret = parse_term(trim(Area(prev, x-2, a.y[0], a.y[1]), s), s);\n                operands.push_back((sgn*ret +mod) %mod);\n                operators.push_back(s[base][x]);\n                sgn = 1;\n            }\n            prev = x+2;\n        }else if(s[base][x] == '('){\n            depth++;\n        }else if(s[base][x] == ')'){\n            depth--;\n        }\n    }\n    \n    {\n        vector<int> new_operands;\n        vector<char> new_operators;\n        new_operands.push_back(operands[0]);\n        for(int i=0; i<(int)operators.size(); i++){\n            if(operators[i] == '*'){\n                new_operands.back() *= operands[i+1];\n                new_operands.back() %= mod;\n            }else{\n                new_operands.push_back(operands[i+1]);\n                new_operators.push_back(operators[i]);\n            }\n        }\n        swap(operators, new_operators);\n        swap(operands, new_operands);\n    }\n    int res = operands[0];\n    for(int i=0; i<(int)operators.size(); i++){\n        if(operators[i] == '+'){\n            res += operands[i+1];\n        }else{\n            res -= operands[i+1];\n        }\n    }\n    return (res%mod +mod) %mod;\n}\n\nint parse_term(Area a, vector<string> &s){\n    int base = -1;\n    for(int y=a.y[0]; y<=a.y[1]; y++){\n        if(s[y][a.x[0]] != '.') base = y;\n    }\n    if(s[base][a.x[0]] == '-'){\n        int numerator = parse_expr(trim(Area(a.x[0], a.x[1], a.y[0], base-1), s), s);\n        int denominator = parse_expr(trim(Area(a.x[0], a.x[1], base+1, a.y[1]), s), s);\n        return (numerator *invtable[denominator]) %mod;\n    }\n    if(s[base][a.x[1]] == '.'){\n        int p = s[base-1][a.x[1]] -'0';\n        int term = parse_term(trim(Area(a.x[0], a.x[1]-1, a.y[0], a.y[1]), s), s);\n        int res = 1;\n        for(int i=0; i<p; i++){\n            res *= term;\n            res %= mod;\n        }\n        return res;\n    }\n    if(s[base][a.x[0]] == '('){\n        return parse_expr(trim(Area(a.x[0]+1, a.x[1]-1, a.y[0], a.y[1]), s), s);\n    }\n    return s[base][a.x[0]] -'0';\n}\n\nint main(){\n    for(int i=1; i<mod; i++){\n        for(int j=1; j<mod; j++){\n            if(i*j%mod == 1){\n                invtable[i] = j;\n            }\n        }\n    }\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<string> s(n);\n        for(int i=0; i<n; i++){\n            cin >> s[i];\n        }\n        cout << parse_expr(Area(0, (int)s[0].length()-1, 0, n-1), s) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MOD = 2011;\nint inv[2022];\nchar AA[100][100];\nbool visited[100][100];\n\nclass Result\n{\npublic:\n\tint x,y,v;\n\tResult()\n\t{}\n\n\tResult(int x, int y, int v)\n\t\t:x(x),y(y),v(v)\n\t{}\n};\n\nint findexpr(int x, int y, int d)\n{\n\twhile(1) {\n\t\tif(y < 0 || AA[y][x] == '!') break;\n\t\tif(visited[y][x]) break;\n\t\tif(AA[y][x] !='.') return y;\n\n\t\ty += d;\n\t}\n\n\treturn -1;\n}\n\nResult expr(int x, int y);\nResult term(int x, int y);\nResult factor(int x, int y);\nResult powexpr(int x, int y);\nResult primary(int x, int y);\nResult fraction(int x, int y);\nResult digit(int x, int y);\n\nResult expr(int x, int y)\n{\n\tvisited[y][x] = true;\n\tResult a = term(x,y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '+' || AA[y][x+1] == '-') {\n\t\tvisited[y][x+1] = true;\n\t\tchar op = AA[y][x+1];\n\n\t\tResult b = term(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\t\n\t\tif(op == '+') a.v = (a.v + b.v) % MOD;\n\t\tif(op == '-') a.v = (a.v - b.v + MOD) % MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult term(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a = factor(x, y);\n\tx = a.x; y = a.y;\n\n\twhile(AA[y][x+1] == '*') {\n\t\tvisited[y][x+1] = true;\n\n\t\tResult b = factor(x + 3, y);\n\t\tx = b.x; y = b.y;\n\t\ta.v *= b.v;\n\t\ta.v %= MOD;\n\t}\n\n\treturn Result(x,y,a.v);\n}\n\nResult factor(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a;\n\tif(AA[y][x] == '-') {\n\t\tif(AA[y][x+1] == '-') {\n\t\t\ta = fraction(x, y);\n\t\t}\n\t\telse {\n\t\t\ta = factor(x + 2, y);\n\t\t\ta.v = (-a.v + MOD) % MOD;\n\t\t}\n\t}\n\telse {\n\t\ta = powexpr(x, y);\n\t}\n\n\treturn a;\n}\n\nResult powexpr(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a = primary(x,y);\n\tx = a.x; y = a.y;\n\n\tif(y!=0 && isdigit(AA[y-1][x])) {\n\t\tint pw = AA[y-1][x] - '0';\n\t\tint p = a.v;\n\t\tint res = 1;\n\t\tfor(int i=0; i<pw; i++)\n\t\t\tres *= p;\n\n\t\ta.v = res % MOD;\n\t\ta.x += 1;\n\t}\n\n\treturn a;\n}\n\nResult primary(int x, int y)\n{\n\tvisited[y][x] = true;\n\n\tResult a;\n\tif(isdigit(AA[y][x])) {\n\t\ta.v = AA[y][x] - '0';\n\t\ta.x = x + 1;\n\t\ta.y = y;\n\t}\n\telse {\n\t\ta = expr(x + 2,y);\n\t\ta.x += 2;\n\t}\n\n\treturn a;\n}\n\nResult fraction(int x, int y)\n{\n\tbool findTop=false, findBtm=false;\n\tResult t, b;\n\n\tint tx = x;\n\twhile(AA[y][x] == '-') {\n\t\tvisited[y][x] = true;\n\t\tx++;\n\t}\n\n\tx = tx;\n\twhile(AA[y][x] == '-') {\n\t\tif(!findTop) {\n\t\t\tint ty = findexpr(x,y-1,-1);\n\t\t\tif(ty != -1) {\n\t\t\t\tt = expr(x,ty);\n\t\t\t\tfindTop = true;\n\t\t\t}\n\t\t}\n\t\tif(!findBtm) {\n\t\t\tint by = findexpr(x,y+1,1);\n\t\t\tif(by != -1) {\n\t\t\t\tb = expr(x,by);\n\t\t\t\tfindBtm = true;\n\t\t\t}\n\t\t}\n\n\t\tx++;\n\t}\n\n\tResult res;\n\tres.x = x;\n\tres.y = y;\n\tres.v = t.v * inv[b.v] % MOD;\n\n\treturn res;\n}\n\nint main()\n{\n\tfor(int i=1; i<MOD; i++)\n\tfor(int j=1; j<MOD; j++) \n\t\tif(j * i % MOD == 1) inv[i] = j;\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tfor(int i=0; i<100; i++)\n\t\tfor(int j=0; j<100; j++)\n\t\t\tAA[j][i] = '!';\n\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> AA[i];\n\n\t\tcout << expr(0, findexpr(0,0,1)).v << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n//#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define MOD 2011\nint H,W;\nint LEFT;\nstring table[20];\n\nint parse(int top,int bottom);\nint expr(int base,int top,int bottom);\nint find_base(int top,int bottom);\nint term(int base,int top,int bottom);\nint factor(int base,int top,int bottom);\nint powexpr(int base,int top,int bottom);\nint primary(int base,int top,int bottom);\n\nint pow_mod(int A, int N)\n{\n\tif(N == 0){\n\n\t\treturn 1;\n\n\t}else if(N%2 == 1){\n\n\t\treturn (A*pow_mod(A,N-1))%MOD;\n\n\t}else{\n\t\tint tmp = pow_mod(A,N/2);\n\t\treturn (tmp*tmp)%MOD;\n\t}\n}\n\nint primary(int base,int top,int bottom){\n\n\tif(table[base][LEFT] == '(' && table[base][LEFT+1] == '.'){\n\n\t\tLEFT += 2;\n\t\tint ret = expr(base,top,bottom);\n\t\tLEFT += 2;\n\t\treturn ret;\n\n\t}else{\n\t\tint ret = table[base][LEFT]-'0';\n\t\tLEFT += 1;\n\t\treturn ret;\n\t}\n}\n\nbool is_digit(char ch){\n\treturn ch >= '0' && ch <= '9';\n}\n\nint powexpr(int base,int top,int bottom){\n\n\tint ret = primary(base,top,bottom),tmp;\n\n\tif(base-1 >= top && LEFT < W && is_digit(table[base-1][LEFT])){\n\n\t\ttmp = table[base-1][LEFT]-'0';\n\t\tLEFT += 1;\n\t\treturn pow_mod(ret,tmp);\n\n\t}else{\n\t\treturn ret;\n\t}\n}\n\nint factor(int base,int top,int bottom){\n\n\tif(table[base][LEFT] == '-'){\n\t\tif(table[base][LEFT+1] == '.'){\n\n\t\t\tLEFT += 2;\n\t\t\tint ret = factor(base,top,bottom);\n\t\t\treturn (MOD-ret)%MOD;\n\n\t\t}else{\n\n\t\t\tint pre = LEFT;\n\t\t\tint tmp = parse(top,base);\n\t\t\tLEFT = pre;\n\t\t\tint tmp2 = parse(base+1,bottom);\n\t\t\tLEFT = pre;\n\t\t\twhile(LEFT < W && table[base][LEFT] == '-'){\n\t\t\t\tLEFT += 1;\n\t\t\t}\n\t\t\treturn (tmp*pow_mod(tmp2,MOD-2))%MOD;\n\t\t}\n\n\t}else{\n\t\treturn powexpr(base,top,bottom);\n\t}\n}\n\nint term(int base,int top,int bottom){\n\n\tint ret = factor(base,top,bottom),tmp;\n\n\twhile(LEFT+2 < W && table[base][LEFT] == '.' && table[base][LEFT+1] == '*' && table[base][LEFT+2] == '.'){\n\n\t\tLEFT += 3;\n\t\ttmp = factor(base,top,bottom);\n\n\t\tret *= tmp;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nbool is_op(char ch){\n\n\treturn ch == '+' || ch == '-';\n}\n\n\nint expr(int base,int top,int bottom){\n\n\tint ret = term(base,top,bottom),tmp;\n\tchar op;\n\n\twhile(LEFT+2 < W && table[base][LEFT] == '.' && is_op(table[base][LEFT+1]) && table[base][LEFT+2] == '.'){\n\t\top = table[base][LEFT+1];\n\t\tLEFT += 3;\n\t\ttmp = term(base,top,bottom);\n\n\t\tif(op == '+'){\n\t\t\tret += tmp;\n\t\t\tret %= MOD;\n\t\t}else{\n\t\t\tret = (ret-tmp+MOD)%MOD;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint find_base(int top,int bottom){\n\n\t//左端から順に、縦に見ていく\n\tfor(; LEFT < W; LEFT++){\n\t\tfor(int row = top; row < bottom; row++){\n\t\t\tif(table[row][LEFT] != '.'){\n\t\t\t\t\treturn row;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint parse(int top,int bottom){\n\n\treturn expr(find_base(top,bottom),top,bottom);\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tcin >> table[row];\n\t}\n\n\tfor(W = 0; table[0][W] != '\\0'; W++);\n\n\tLEFT = 0;\n\tprintf(\"%d\\n\",parse(0,H));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&H);\n\t\tif(H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) //cout << #x << \" = \" << x << endl;\nint n,mod=2011,inv[2011];\nstring s[20];\nint calcinv(int x){\n\tint ret=1,tmp=mod-2,p=x;\n\trep(i,11){\n\t\tif((tmp>>i)&1) ret=ret*p%mod;\n\t\tp=p*p%mod;\n\t}\n\tinv[x]=ret;\n}\nint expr(int& top,int& bottom,int& base,int& be);\nint frac(int& top,int& bottom,int& base,int& be){\n\t//cout << \"infrac \" << s[base][be] << endl;\n\tint utop=top,ubottom=base-1,ubase=-1,ube=-1;\n\tint dtop=base+1,dbottom=bottom,dbase=-1,dbe=-1;\n\tfor(int x=be+1;;x++){\n\t\tfor(int y=utop;y<=ubottom;y++) if(s[y][x]!='.') ubase=y,ube=x;\n\t\tif(ubase!=-1) break;\n\t}\n\tfor(int x=be+1;;x++){\n\t\tfor(int y=dtop;y<=dbottom;y++) if(s[y][x]!='.') dbase=y,dbe=x;\n\t\tif(dbase!=-1) break;\n\t}\n\tint u=expr(utop,ubottom,ubase,ube),d=expr(dtop,dbottom,dbase,dbe);\n\twhile(s[base][be]=='-') be++;\n\treturn u*inv[d]%mod;\n}\nint primary(int& top,int& bottom,int& base,int& be){\n\t//cout << \"inprimary \" << s[base][be] << endl;\n\tint ret;\n\tif(isdigit(s[base][be])){\n\t\tret=s[base][be]-'0';\n\t\tbe++;\n\t}else{\n\t\t//cout <<\"beforeassert \"<< s[base][be] << endl;\n\t\tassert(s[base][be]=='(');\n\t\tbe+=2;\n\t\tret=expr(top,bottom,base,be);\n\t\tbe+=2;\n\t}\n\t//cout << \"primary \" << ret << endl;\n\treturn ret;\n}\nint powexpr(int& top,int& bottom,int& base,int& be){\n\tint ret=primary(top,bottom,base,be);\n\tif(base>top && isdigit(s[base-1][be])){\n\t\tint ex=s[base-1][be]-'0';\n\t\tint rett=1;\n\t\trep(i,ex) rett=rett*ret%mod;\n\t\tret=rett;\n\t\tbe++;\n\t}\n\t//cout << \"powexpr \" << ret << endl;\n\treturn ret;\n}\nint factor(int& top,int& bottom,int& base,int& be){\n\t//cout << \"infactor \"<<s[base][be]<<endl;\n\tint ret=0;\n\tif(s[base][be]=='-' && s[base][be+1]=='-'){\n\t\tret=frac(top,bottom,base,be);\n\t}else if(s[base][be]=='-'){\n\t\tbe+=2;\n\t\tret=(mod-factor(top,bottom,base,be))%mod;\n\t}else{\n\t\tret=powexpr(top,bottom,base,be);\n\t}\n\treturn ret;\n}\nint term(int& top,int& bottom,int& base,int& be){\n\t//cout << \"interm \" << s[base][be]<<endl;\n\tint ret=factor(top,bottom,base,be);\n\twhile(true){\n\t\tif(s[base][be+1]=='*'){\n\t\t\tbe+=3;\n\t\t\tret*=factor(top,bottom,base,be);\n\t\t\tret%=mod;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint expr(int& top,int& bottom,int& base,int& be){\n\t//cout << \"inexpr \" << s[base][be] << endl;\n\tint ret=term(top,bottom,base,be);\n\twhile(true){\n\t\tif(s[base][be+1]=='+'){\n\t\t\tbe+=3;\n\t\t\tret+=term(top,bottom,base,be);\n\t\t\tret%=mod;\n\t\t}else if(s[base][be+1]=='-'){\n\t\t\tshow(base);\n\t\t\tshow(be);\n\t\t\tbe+=3;\n\t\t\tret-=term(top,bottom,base,be);\n\t\t\tret=(ret+mod)%mod;\n\t\t}else break;\n\t}\n\treturn ret;\n}\nint main(){\n\trep1(i,2010) calcinv(i);\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\trep(i,n){\n\t\t\tcin>>s[i];\n\t\t\ts[i]+=\"$$\";\n\t\t}\n\t\tint top=0,bottom=n-1,base,be=0;\n\t\tfor(int i=top;i<=bottom;i++) if(s[i][be]!='.') base=i;\n\t\tcout << expr(top,bottom,base,be) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cctype>\nusing namespace std;\n\n\n#define M 2011\n\n\nint powmod(int x, int y){\n\tint a = 1;\n\tfor(; y; y >>= 1){\n\t\tif(y & 1) a = a * x % M;\n\t\tx = x * x % M;\n\t}\n\treturn a;\n}\n\nint n;\nstring s[22];\n\nvoid scan(int top, int bottom, int begin, int &y, int &x){\n\tx = y = -1;\n\n\tfor(;; ++begin){\n\t\tfor(int i = top; i <= bottom; ++i){\n\t\t\tif( s[i][begin] != '.' ){\n\t\t\t\ty = i;\n\t\t\t\tx = begin;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint expr(int, int, int, int&);\nint term(int, int, int, int&);\nint factor(int, int, int, int&);\n\n\nint expr(int top, int base, int bottom, int &pos){\n\tint a = term(top, base, bottom, pos);\n\n\twhile(1){\n\t\t++pos;\n\n\t\tif( s[base][pos] == '+' ){\n\t\t\tpos += 2;\n\t\t\ta = (a + term(top, base, bottom, pos)) % M;\n\t\t}\n\t\telse if( s[base][pos] == '-' ){\n\t\t\tpos += 2;\n\t\t\ta = (a - term(top, base, bottom, pos) + M) % M;\n\t\t}\n\t\telse{\n\t\t\t--pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\nint term(int top, int base, int bottom, int &pos){\n\tint a = factor(top, base, bottom, pos);\n\t\n\twhile(1){\n\t\t++pos;\n\t\tif( s[base][pos] == '*' ){\n\t\t\tpos += 2;\n\t\t\ta = a * factor(top, base, bottom, pos) % M;\n\t\t}\n\t\telse{\n\t\t\t--pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}\n\nint factor(int top, int base, int bottom, int &pos){\n\tif( s[base][pos] == '-' ){\n\t\tif( s[base][pos + 1] == '-' ){\n\t\t\tint y, x;\n\t\t\tscan(top, base - 1, pos + 1, y, x);\n\t\t\tint a = expr(top, y, base - 1, x);\n\t\t\t\n\t\t\tscan(base + 1, bottom, pos + 1, y, x);\n\t\t\tint b = expr(base + 1, y, bottom, x);\n\t\t\tint c = powmod(b, M - 2);\n\n\t\t\twhile( s[base][pos] == '-' ){\n\t\t\t\t++pos;\n\t\t\t}\n\n\t\t\treturn (a * c) % M;\n\t\t}\n\t\telse{\n\t\t\tpos += 2;\n\t\t\tint a = factor(top, base, bottom, pos);\n\t\t\treturn (M - a) % M;\n\t\t}\n\t}\n\telse{\n\t\tint a = -1;\n\n\t\tif( s[base][pos] == '(' ){\n\t\t\tpos += 2;\n\t\t\ta = expr(top, base, bottom, pos);\n\t\t\tpos += 2;\n\t\t}\n\t\telse{\n\t\t\tif( !isdigit(s[base][pos]) ){\n\t\t\t\tthrow 1;\n\t\t\t}\n\n\t\t\ta = s[base][pos] - '0';\n\t\t\t++pos;\n\t\t}\n\t\t\n\t\tif( isdigit(s[base - 1][pos]) ){\n\t\t\ta = powmod(a, s[base - 1][pos] - '0');\n\t\t\t++pos;\n\t\t}\n\n\t\treturn a;\n\t}\n}\n\n\nint main(){\n\twhile( cin >> n, n != 0 ){\n\t\tfor(int i = 0; i < 22; ++i) s[i].clear();\n\t\tfor(int i = 1; i <= n; ++i) cin >> s[i];\n\t\tfor(int i = 0; i <= n + 1; ++i) s[i].resize(84, '.');\n\n\t\tint y, x;\n\t\tscan(1, n, 0, y, x);\n\t\tcout << expr(1, y, n, x) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n;\nstring in[20];\nint inv[3000];\n\nvoid normal(int &x1,int &y1,int &x2,int &y2){\n  set<int> x,y;\n  for(int i=x1;i<x2;++i)\n    for(int j=y1;j<y2;++j){\n      if(in[i][j]!='.'){\n        x.insert(i);\n        y.insert(j);\n      }\n    }\n  x1 = *x.begin();\n  x2 = *x.rbegin()+1;\n  y1 = *y.begin();\n  y2 = *y.rbegin()+1;\n}\n\nint expr(int,int,int,int);\nint term(int,int,int,int);\nint factor(int,int,int,int);\nint powexpr(int,int,int,int);\nint primary(int,int,int,int);\n\nint digit(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"digit \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;          \n  int ret=0;\n  while(y1<y2 && isdigit(in[x1][y1]))\n    ret=(ret*10+in[x1][y1++]-'0')%2011;\n  return ret;\n}\n\nint primary(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"primary \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;        \n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  if(in[base][y1]=='(')\n    return expr(x1,y1+1,x2,y2-1);\n  return digit(x1,y1,x2,y2);\n}\n\nint fraction(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int p=expr(base+1,y1,x2,y2);\n  int c=expr(x1,y1,base,y2);\n  return c*inv[p]%2011;\n}\n\nint powexpr(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"powexpr \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;      \n  int base;\n  int base2=-1;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y2-1]!='.') base2=j;\n  //cout << base << ' ' << base2 << endl;\n  if(base2==base) return primary(x1,y1,x2,y2);\n\n  int idx=y2-1;\n  while(idx>=y1 && isdigit(in[base2][idx])) --idx;\n  ++idx;\n  int di=digit(base2,idx,base2+1,y2);\n  int pr=primary(x1,y1,x2,idx);\n  //cout << \"pr di \" << pr << ' ' << di << endl;\n  int ret=1;\n  rep(i,di) ret=(ret*pr)%2011;\n  return ret;\n}\n\nint factor(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"factor \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;    \n  int ret;\n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n\n  if(in[base][y1]=='-' &&\n     y1+1<y2 && in[base][y1+1]=='.')\n    return ((-factor(x1,y1+2,x2,y2))%2011+2011)%2011;\n\n  if(in[base][y1]=='-' &&\n     y1+1<y2 && in[base][y1+1]=='-')\n    return fraction(x1,y1,x2,y2);\n\n  return powexpr(x1,y1,x2,y2);\n}\n\nint term(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int ret;\n  int base;\n  //cout << \"term \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;  \n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int idx=-1;\n  int pa=0;\n  for(int j=y1;j<y2;++j){\n    if(in[base][j]=='(') ++pa;\n    if(in[base][j]==')') --pa;\n    if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n       in[base][j]=='*' &&\n       in[base][j+1]=='.' && pa==0){\n      idx=j;\n      break;      \n    }\n  }\n  \n  if(idx!=-1) ret=factor(x1,y1,x2,idx-1);\n  else return factor(x1,y1,x2,y2);\n  y1 = idx+1;    \n  while(true){\n\n    normal(x1,y1,x2,y2);\n    idx=-1;\n    int pa=0;\n    \n    for(int j=y1;j<y2;++j){\n      if(in[base][j]=='(') ++pa;\n      if(in[base][j]==')') --pa;\n      if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n         in[base][j]=='*' &&\n         in[base][j+1]=='.' && pa==0){\n        idx=j;\n        break;      \n      }\n    }\n    \n    if(idx!=-1){\n      int t=factor(x1,y1,x2,idx-1);\n      ret=(ret*t)%2011;\n    }else{\n      int t=factor(x1,y1,x2,y2);\n      ret=(ret*t)%2011;      \n      return ret;\n    }\n    y1 = idx+1;\n  }\n  return ret;\n}\n\nint expr(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int ret;\n  int base;\n  //cout << \"expr \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int idx=-1;\n  int pa=0;\n  for(int j=y1;j<y2;++j){\n    if(in[base][j]=='(') ++pa;\n    if(in[base][j]==')') --pa;\n    if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n       (in[base][j]=='+' ||\n        (in[base][j]=='-' &&\n         (j-2>=0 && in[base][j-2]!='*' &&\n          in[base][j-2]!='+' && in[base][j-2]!='-'))) &&\n       in[base][j+1]=='.' && pa==0){\n      idx=j;\n      break;\n    }\n  }\n  \n  if(idx!=-1) ret=term(x1,y1,x2,idx-1);\n  else return term(x1,y1,x2,y2);\n  y1 = idx+1;\n  while(true){\n    normal(x1,y1,x2,y2);\n    char op=in[base][idx];\n    idx=-1;\n    int pa=0;\n    for(int j=y1;j<y2;++j){\n      if(in[base][j]=='(') ++pa;\n      if(in[base][j]==')') --pa;\n      if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n         (in[base][j]=='+' ||\n          (in[base][j]=='-' &&\n           (j-2>=0 && in[base][j-2]!='*' &&\n            in[base][j-2]!='+' && in[base][j-2]!='-'))) &&\n         in[base][j+1]=='.' && pa==0){\n        idx=j;\n        break;      \n      }\n    }\n    \n    if(idx!=-1){\n      int t=term(x1,y1,x2,idx-1);\n      if(op=='+') ret=(ret+t)%2011;\n      else ret=((ret-t)%2011+2011)%2011;\n    }\n    else{\n      int t=term(x1,y1,x2,y2);\n      //cout << op << ' ' << t << endl;\n      if(op=='+') ret=(ret+t)%2011;\n      else ret=((ret-t)%2011+2011)%2011;\n      return ret;\n    }\n    y1 = idx+1;    \n  }\n  return ret;\n}\n\nvoid solve(){\n  rep(i, n) cin >> in[i];\n  cout << expr(0,0,n,SZ(in[0])) << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  rep(i,2011)rep(j,2011) if(i*j%2011==1) inv[i]=j;\n  //cout << 4*inv[9] << endl;\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n//a x + b y = gcd(a, b)\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n  long long g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nlong long InvMod(long long a, long long mod) {\n  long long x, y;\n  if (extgcd(a, mod, x, y) == 1) { return (x + mod) % mod; }\n  return 0;\n}\n\nll powmod(ll base, ll power, ll mod) {\n  base %= mod;\n  ll ret = 1;\n  while (power > 0) {\n    if (power & 1) { ret = (ret * base) % mod; }\n    base = (base * base) % mod;\n    power >>= 1;\n  }\n  return ret;\n}\n\n//=============================================\nchar field[100][100];\nconst ll MOD = 2011;\nint expr(int r, int t, int b, int &pos);\n\nvoid skip(int r, int center, int &pos) {\n  while (pos < r && field[center][pos] == '.') { pos++; }\n}\n\nint digit(int center, int &pos) {\n  int lhs = atoi(field[center] + pos) % MOD;\n  while (isdigit(field[center][pos])) { pos++; }\n  return lhs;\n}\n\nint primary(int r, int t, int b, int center, int &pos) {\n  int lhs = -1;\n  if (field[center][pos] != '(') {\n    lhs = digit(center, pos);\n  } else {\n    pos++;\n    skip(r, center, pos);\n    lhs = expr(r, t, b, pos);\n    skip(r, center, pos);\n    assert(field[center][pos] == ')');\n    pos++;\n  }\n  return lhs;\n}\n\nint powexpr(int r, int t, int b, int center, int &pos) {\n  int lhs = primary(r, t, b, center, pos);\n  if (isdigit(field[center - 1][pos])) {\n    int rhs = digit(center - 1, pos);\n    lhs = powmod(lhs, rhs, MOD);\n  }\n  return lhs;\n}\n\nint fraction(int r, int t, int b, int center, int &pos) {\n  int left = pos + 1;\n  while (field[center][pos] == '-') { pos++; }\n  int right = pos - 1;\n  int npos1 = left;\n  int npos2 = left;\n  int lhs = expr(right, t, center, npos1);\n  int rhs = expr(right, center + 1, b, npos2);\n  lhs = (lhs * InvMod(rhs, MOD)) % MOD;\n  return lhs;\n}\n\nint factor(int r, int t, int b, int center, int &pos) {\n  if (field[center][pos] == '-' && field[center][pos + 1] == '-') {\n    return fraction(r, t, b, center, pos);\n  } else if (field[center][pos] == '-') {\n    pos++;\n    skip(r, center, pos);\n    return (MOD - factor(r, t, b, center, pos)) % MOD;\n  } else {\n    return powexpr(r, t, b, center, pos);\n  }\n}\n\nint term(int r, int t, int b, int center, int &pos) {\n  int lhs = factor(r, t, b, center, pos);\n  skip(r, center, pos);\n  while (pos < r && field[center][pos] == '*') {\n    pos++;\n    skip(r, center, pos);\n    int rhs = factor(r, t, b, center, pos);\n    lhs = (lhs * rhs) % MOD;\n    skip(r, center, pos);\n  }\n  return lhs;\n}\n\nint expr(int r, int t, int b, int &pos) {\n  int center = -1;\n  while (center == -1) {\n    FOR(y, t, b) {\n      if (field[y][pos] != '.') { center = y; break; }\n    }\n    if (center == -1) {\n      pos++;\n      assert(pos < r);\n    }\n  }\n  int lhs = term(r, t, b, center, pos);\n  skip(r, center, pos);\n  while (pos < r && (field[center][pos] == '+' || field[center][pos] == '-')) {\n    int s = 0;\n    if (field[center][pos] == '+') { s = 1; }\n    if (field[center][pos] == '-') { s = -1; }\n    pos++;\n    assert(field[center][pos] == '.');\n    pos++;\n    int rhs = term(r, t, b, center, pos);\n    lhs = (lhs + s * rhs + MOD) % MOD;\n    skip(r, center, pos);\n  }\n  return lhs;\n}\n\nint main() {\n  int h;\n  while (scanf(\"%d\", &h), h) {\n    MEMSET(field, '.');\n    REP(y, h) {\n      scanf(\"%s\", field[y + 1]);\n    }\n    int w = strlen(field[0]);\n    REP(y, h) { field[y][w] = '.'; }\n    REP(y, h) { field[y][90] = 0; }\n    w++;\n    h += 2;\n    int pos = 0;\n    int ans = expr(w, 0, h, pos);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nconst int MOD = 2011;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nint extgcd(int a, int b, int &x, int &y) {\n  int d = a;\n  if (b != 0) {\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else {\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint inv_mod(int value) {\n  int x, y;\n  extgcd(value, MOD, x, y);\n  return (x % MOD + MOD) % MOD;\n}\n\nvoid mod_update(int &value) {\n  value %= MOD;\n  value += MOD;\n  value %= MOD;\n}\n\nint H, W;\nvector<string> S;\ntypedef pair<int, int> P;\n\nP expr(int top, int bottom, int left, int right);\nP term(int top, int bottom, int left, int right);\nP factor(int top, int bottom, int left, int right);\nP powexpr(int top, int bottom, int left, int right);\n\nvoid show(int top, int bottom, int left, int right) {\n  for(int i = top; i <= bottom; ++i) {\n    for(int j = left; j <= right; ++j) {\n      cerr << S[i][j];\n    }\n    cerr << endl;\n  }\n}\n\nP expr(int top, int bottom, int left, int right) {\n  // cerr << \"expr(\" << top << \",\" << bottom << \",\" << left << \",\" << right << \");\" << endl;\n  // show(top, bottom, left, right);\n  P res = term(top, bottom, left, right);\n  int ans = res.first;\n  int p = res.second;\n  while(p <= right) {\n    char op = '\\0';\n    for(int i = top; i <= bottom; ++i) {\n      if(S[i][p] == '+') op = '+';\n      if(S[i][p] == '-') op = '-';\n    }\n    if(op == '\\0') break;\n    p += 2;\n    P ret = term(top, bottom, p, right);\n    if(op == '+') {\n      ans += ret.first;\n      mod_update(ans);\n    }\n    if(op == '-') {\n      ans -= ret.first;\n      mod_update(ans);\n    }\n    p = ret.second;\n  }\n  return make_pair(ans, p);\n}\n\nP term(int top, int bottom, int left, int right) {\n  // cerr << \"term(\" << top << \",\" << bottom << \",\" << left << \",\" << right << \");\" << endl;\n  // show(top, bottom, left, right);\n  P res = factor(top, bottom, left, right);\n  int ans = res.first;\n  int p = res.second;\n  while(p <= right) {\n    char op = '\\0';\n    for(int i = top; i <= bottom; ++i) {\n      if(S[i][p] == '*') op = '*';\n    }\n    if(op == '\\0') break;\n    p += 2;\n    P ret = factor(top, bottom, p, right);\n    if(op == '*') {\n      ans *= ret.first;\n      mod_update(ans);\n    }\n    p = ret.second;\n  }\n  return make_pair(ans, p);\n}\n\nP factor(int top, int bottom, int left, int right) {\n  // cerr << \"factor(\" << top << \",\" << bottom << \",\" << left << \",\" << right << \");\" << endl;\n  // show(top, bottom, left, right);\n  char second = '\\0';\n  int baseline;\n  for(int i = top; i <= bottom; ++i) {\n    if(S[i][left] == '-' && S[i][left + 1] == '.') {\n      second = '-';\n    }\n    if(S[i][left] == '-' && S[i][left + 1] == '-') {\n      second = '/';\n      baseline = i;\n    }\n  }\n\n  if(second == '-') {\n    P ret = factor(top, bottom, left + 2, right);\n    ret.first *= -1;\n    mod_update(ret.first);\n    return ret;\n  }\n\n  if(second == '/') {\n    int L = left;\n    int R = left;\n    while(S[baseline][R+1] == '-') R++;\n    int l, r;\n\n    l = L;\n    while(true) {\n      bool f = false;\n      for(int i = top; i <= baseline - 1; ++i) {\n        if(S[i][l] != '.')  f = true;\n      }\n      if(f) break;\n      l++;\n    }\n    r = R;\n    while(true) {\n      bool f = false;\n      for(int i = top; i <= baseline - 1; ++i) {\n        if(S[i][r] != '.')  f = true;\n      }\n      if(f) break;\n      r--;\n    }\n\n    P x = expr(top, baseline - 1, l, r);\n\n    l = L;\n    while(true) {\n      bool f = false;\n      for(int i = baseline + 1; i <= bottom; ++i) {\n        if(S[i][l] != '.')  f = true;\n      }\n      if(f) break;\n      l++;\n    }\n    r = R;\n    while(true) {\n      bool f = false;\n      for(int i = baseline + 1; i <= bottom; ++i) {\n        if(S[i][r] != '.')  f = true;\n      }\n      if(f) break;\n      r--;\n    }\n\n    P y = expr(baseline + 1, bottom, l, r);\n    int ret = x.first * inv_mod(y.first);\n    mod_update(ret);\n    return make_pair(ret, R + 2);\n  }\n\n  return powexpr(top, bottom, left, right);\n}\n\nP powexpr(int top, int bottom, int left, int right) {\n  // cerr << \"powexpr(\" << top << \",\" << bottom << \",\" << left << \",\" << right << \");\" << endl;\n  // show(top, bottom, left, right);\n  P p;\n  int primary;\n  int baseline;\n  char op = '\\0';\n  for(int i = top; i <= bottom; ++i) {\n    if(S[i][left] == '(') {\n      op = '(';\n      baseline = i;\n    }\n    if(isdigit(S[i][left])) {\n      op = S[i][left];\n      baseline = i;\n    }\n  }\n  if(op == '(') {\n    p = expr(top, bottom, left + 2, right);\n    p.second += 1; // skip ' ' ')'\n    primary = p.first;\n  }\n  else {\n    p = make_pair(S[baseline][left] - '0', left + 1);\n    primary = p.first;\n  }\n\n  if(p.second <= right && top <= baseline - 1) {\n    char c = S[baseline - 1][p.second];\n\n    if(isdigit(c)) {\n      int ret = 1;\n      for(int i = 0; i < c - '0'; ++i) {\n        ret *= primary;\n        mod_update(ret);\n      }\n      p = make_pair(ret, p.second + 1);\n    }\n  }\n\n  p.second += 1;\n  return p;\n}\n\nint main() {\n  while(true) {\n    cin >> H;\n    if(H == 0) break;\n    S.resize(H);\n    for(int i = 0; i < H; ++i) {\n      cin >> S[i];\n    }\n    W = S.begin()->size();\n    P ans = expr(0, H - 1, 0, W - 1);\n    cout << ans.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nstruct Indices {\n    int x, y;\n    int lx, ly, rx, ry;\n};\n\nint expr(Indices& idx);\n\nint W, H;\nchar field[20][80];\n\nbool wrap(Indices& idx, int x, int y) {\n    return idx.lx <= x && x <= idx.rx && idx.ly <= y && y <= idx.ry;\n}\n\nbool check2(int x, int y, char c) {\n    if (0 <= x && x < W && 0 <= y && y < H) {\n        if (field[y][x] == c) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid skip(Indices& idx, char c) {\n    assert(field[idx.y][idx.x] == c);\n    idx.x++;\n}\n\nint mod(int n) {\n    return (n + 2011) % 2011;\n}\n\nvoid set_base(Indices& idx) {\n    vi candidate;\n    int ma = 0;\n    FOR(y, idx.ly, idx.ry+1) {\n        int cnt = 0;\n        FOR(x, idx.lx, idx.rx+1) {\n            if (field[y][x] != '.') cnt++;\n        }\n        if (ma < cnt) {\n            ma = cnt;\n            candidate.clear();\n        }\n        if (ma == cnt) {\n            candidate.push_back(y);\n        }\n    }\n    int y = candidate[SZ(candidate)-1];\n    idx.y = y;\n}\n\nint digit(Indices& idx) {\n    assert(isdigit(field[idx.y][idx.x]));\n    int n = field[idx.y][idx.x] - '0';\n    idx.x++;\n    return n;\n}\n\nint fraction(Indices& idx) {\n    int width = 0;\n    FOR(x, idx.x, W) {\n        if (check2(x, idx.y, '-')) {\n            width++;\n        } else {\n            break;\n        }\n    }\n\n    Indices idx_top = idx;\n    idx_top.lx = idx_top.x + 1;\n    idx_top.rx = idx_top.x + width - 1;\n    idx_top.ry = idx.y-1;\n    set_base(idx_top);\n    idx_top.x++;\n    FOR(x, idx_top.x, idx_top.rx+1) {\n        if (field[idx_top.y][x] == '.') {\n            idx_top.x++;\n        } else {\n            break;\n        }\n    }\n    Indices idx_bottom = idx;\n    idx_bottom.lx = idx_bottom.x + 1;\n    idx_bottom.rx = idx_bottom.x + width - 1;\n    idx_bottom.ly = idx.y+1;\n    set_base(idx_bottom);\n    idx_bottom.x++;\n    FOR(x, idx_bottom.x, idx_bottom.rx+1) {\n        if (field[idx_bottom.y][x] == '.') {\n            idx_bottom.x++;\n        } else {\n            break;\n        }\n    }\n\n    idx.x += width;\n\n//    LOG(\"top--> \");\n//    REP(x, idx_top.rx+1) {\n//        if (x < idx_top.lx) {\n//            LOG(\" \");\n//        } else {\n//            LOG(\"%c\", field[idx_top.y][x]);\n//        }\n//    }\n//    LOG(\"\\n\");\n//    LOG(\"btm--> \");\n//    REP(x, idx_bottom.rx+1) {\n//        if (x < idx_bottom.lx) {\n//            LOG(\" \");\n//        } else {\n//            LOG(\"%c\", field[idx_bottom.y][x]);\n//        }\n//    }\n//    LOG(\"\\n\");\n    int x = expr(idx_top);\n    int y = expr(idx_bottom);\n    int inv_y;\n    REP(z, 2011) {\n        if ((z * y) % 2011 == 1) {\n            inv_y = z;\n        }\n    }\n    return mod(x * inv_y);\n}\n\nint primary(Indices& idx) {\n    if (check2(idx.x, idx.y, '(')) {\n        skip(idx, '(');\n        skip(idx, '.');\n        int n = expr(idx);\n        skip(idx, '.');\n        skip(idx, ')');\n        return n;\n    } else {\n        return digit(idx);\n    }\n}\n\nint powexpr(Indices& idx) {\n    int n = primary(idx);\n    int y = idx.y-1;\n    if (wrap(idx, idx.x, y) && isdigit(field[y][idx.x])) {\n        Indices idx_in = idx;\n        idx_in.y = y;\n        int top = digit(idx_in);\n        skip(idx, '.');\n        if (top == 0) {\n            n = 1;\n        } else {\n            int m = n;\n            REP(i, top-1) {\n                n = mod(n*m);\n            }\n        }\n    }\n    return n;\n}\n\nint factor(Indices& idx) {\n    if (check2(idx.x, idx.y, '-')) {\n        if (check2(idx.x+1, idx.y, '-')) {\n            return fraction(idx);\n        } else if (check2(idx.x+1, idx.y, '.')) {\n            skip(idx, '-');\n            skip(idx, '.');\n            return mod(-factor(idx));\n        }\n    }\n    return powexpr(idx);\n}\n\nint term(Indices& idx) {\n    int n = factor(idx);\n    while (1) {\n        if (check2(idx.x+1, idx.y, '*')) {\n            skip(idx, '.');\n            skip(idx, '*');\n            skip(idx, '.');\n            n = mod(n * factor(idx));\n        } else {\n            break;\n        }\n    }\n    return mod(n);\n}\n\nint expr(Indices& idx) {\n    int n = term(idx);\n    while (1) {\n        if (check2(idx.x+1, idx.y, '+')) {\n            skip(idx, '.');\n            skip(idx, '+');\n            skip(idx, '.');\n            n += term(idx);\n        } else if (check2(idx.x+1, idx.y, '-')) {\n            skip(idx, '.');\n            skip(idx, '-');\n            skip(idx, '.');\n            n = mod(n - term(idx));\n        } else {\n            break;\n        }\n    }\n    return mod(n);\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        cin.ignore();\n        string line;\n        REP(y, n) {\n            getline(cin, line);\n            W = line.length();\n            REP(x, W) {\n                field[y][x] = line[x];\n            }\n        }\n        H = n;\n        Indices idx = {0,0,0,0,W-1,H-1};\n        set_base(idx);\n        cout << expr(idx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int mod = 2011;\n\nstruct Mod {\n  int num;\n  Mod () : num(0) {;}\n  Mod (int n) : num(n%mod) {;}\n  operator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\npair<int, int> get_mid(const vector<string> &s, int is, int it, int js, int jt) {\n  for (int j=js; j<jt; ++j)\n    for (int i=is; i<it; ++i)\n      if (s[i][j] != '.')\n        return make_pair(i, j);\n  throw \"bad\";\n}\n\npair<Mod, int> expr(const vector<string> &s, int is, int it, int js, int jt, int mid);\n\npair<Mod, int> primary(const vector<string> &s, int is, int it, int js, int jt, int mid) {\n  //cerr<<\"prim: \"<<is<<' '<<mid<<' '<<js<<endl;\n  if (isdigit(s[mid][js])) {\n    //cerr<<\"qqq\"<<s[mid][js]<<endl;\n    return make_pair(Mod(s[mid][js] - '0'), js + 1);\n  } else {\n    auto res = expr(s, is, it, js+2, jt, mid);\n    res.second += 2;\n    return res;\n  }\n}\n\npair<Mod, int> powexpr(const vector<string> &s, int is, int it, int js, int jt, int mid) {\n  //cerr<<\"powexpr: \"<<is<<' '<<mid<<' '<<js<<endl;\n  Mod res;\n  tie(res, js) = primary(s, is, it, js, jt, mid);\n  if (mid > 0 && js < jt && isdigit(s[mid-1][js])) {\n    res = res ^ (s[mid-1][js] - '0');\n    ++js;\n  }\n  return make_pair(res, js);\n}\n\npair<Mod, int> factor(const vector<string> &s, int is, int it, int js, int jt, int mid) {\n  //cerr<<\"factor: \"<<is<<' '<<mid<<' '<<js<<endl;\n  if (s[mid][js] == '-') {\n    if (s[mid][js+1] == '-') {\n      int ed = js+1;\n      while(ed < jt && s[mid][ed] == '-') ++ed;\n      auto p1 = get_mid(s, is, mid, js, ed);\n      auto p2 = get_mid(s, mid+1, it, js, ed);\n      Mod m1 = expr(s, is, mid, p1.second, ed, p1.first).first;\n      Mod m2 = expr(s, mid+1, it, p2.second, ed, p2.first).first;\n      return make_pair(m1 / m2, ed);\n    } else {\n      auto p = factor(s, is, it, js+2, jt, mid);\n      p.first = (int)mod-(int)p.first;\n      return p;\n    }\n  } else {\n    return powexpr(s, is, it, js, jt, mid);\n  }\n}\n\npair<Mod, int> term(const vector<string> &s, int is, int it, int js, int jt, int mid) {\n  //cerr<<\"term: \"<<is<<' '<<mid<<' '<<js<<endl;\n  Mod res;\n  tie(res, js) = factor(s, is, it, js, jt, mid);\n  while(js+1 < jt && s[mid][js+1] == '*') {\n    ++js;\n    auto rhs = factor(s, is, it, js + 2, jt, mid);\n    res *= rhs.first;\n    js = rhs.second;\n  }\n  return make_pair(res, js);\n}\n\npair<Mod, int> expr(const vector<string> &s, int is, int it, int js, int jt, int mid) {\n  //cerr<<\"expr: \"<<is<<' '<<mid<<' '<<js<<endl;\n  Mod res;\n  tie(res, js) = term(s, is, it, js, jt, mid);\n  while(js+1 < jt && (s[mid][js+1] == '-' || s[mid][js+1] == '+')) {\n    ++js;\n    auto rhs = term(s, is, it, js + 2, jt, mid);\n    if (s[mid][js] == '+') res += rhs.first;\n    else res -= rhs.first;\n    js = rhs.second;\n  }\n  return make_pair(res, js);\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<string> s(n);\n    REP(i,n)cin>>s[i];\n    auto mid = get_mid(s, 0, n, 0, s[0].size());\n    auto res = expr(s, 0, n, mid.second, s[0].size(), mid.first);\n    cout << res.first << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(size_t i=(a);i<(size_t)(b);i++)\nusing namespace std;\n\nconst int mod = 2011;\nvector<string> s;\nvector<int> inv(mod,1);\n\ninline int get_base(size_t l, size_t t, size_t b){\n  FOR(i,t,b)if(s[i][l]!='.')return i;\n  return t;\n}\n\nint expr(size_t &l, size_t &t, size_t &r, size_t &b);\n\nint fraction(size_t &l, size_t &t, size_t &r, size_t &b){\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  size_t ll = l+1;\n  while(++l < r && s[base][l]=='-');\n\n  size_t ul = ll, ur = l-1, dl = ll, dr = l-1;\n  size_t ut = t, ub = base, dt = base+1, db = b;\n  return expr(ul,ut,ur,ub) * inv[expr(dl,dt,dr,db)] % mod;\n}\n\nint primary(size_t &l, size_t &t, size_t &r, size_t &b){\n  size_t base = get_base(l,t,b);\n  if(isdigit(s[base][l]))return s[base][l++]-'0';\n\n  l+=2;\n  int res = expr(l,t,r,b);\n  l+=2;\n  return res;\n}\n\nint powexpr(size_t &l, size_t &t, size_t &r, size_t &b){\n  int res = primary(l,t,r,b);\n  size_t base = get_base(l,t,b);\n\n  if(l<r && isdigit(s[base][l])){\n    int p = s[base][l]-'0';\n    l++;\n    int tmp = res; res = 1;\n    while(p--) (res *= tmp) %= mod;\n  }\n  return res;\n}\n\nint factor(size_t &l, size_t &t, size_t &r, size_t &b){\n  size_t base = get_base(l,t,b);\n\n  if(s[base][l] == '-'){\n    if(s[base][l+1] == '.'){\n      l+=2;\n      return mod - factor(l,t,r,b);\n    }else return fraction(l,t,r,b);\n  }\n  return powexpr(l,t,r,b);\n}\n\nint term(size_t &l, size_t &t, size_t &r, size_t &b){\n  size_t base = get_base(l,t,b);\n\n  int res = factor(l,t,r,b);\n  while(l+1<r && s[base][l+1]=='*'){\n    l+=3;\n    res = (res * factor(l,t,r,b)) % mod;\n  }\n  return res;\n}\n\nint expr(size_t &l, size_t &t, size_t &r, size_t &b){\n  //remove spaces\n  for(bool f=true;l<r;l++){FOR(i,t,b)f &= (s[i][l]=='.');   if(!f)break;}\n  for(bool f=true;l<r;r--){FOR(i,t,b)f &= (s[i][r-1]=='.'); if(!f)break;}\n  for(bool f=true;t<b;t++){FOR(i,l,r)f &= (s[t][i]=='.');   if(!f)break;}\n  for(bool f=true;t<b;b--){FOR(i,l,r)f &= (s[b-1][i]=='.'); if(!f)break;}\n\n  size_t base = get_base(l,t,b);\n\n  int res = term(l,t,r,b);\n  while(l+1<r && (s[base][l+1]=='+' || s[base][l+1]=='-')){\n    l+=3;\n    if(s[base][l-2]=='+')res = (res + term(l,t,r,b)) % mod;\n    else res = (res - term(l,t,r,b) + mod) % mod;\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(); ios::sync_with_stdio(0);\n  FOR(i,2,mod)inv[i] = (mod - mod/i) * inv[mod%i] % mod;\n\n  int n;\n  while(cin>>n,n){\n    s.resize(n);\n    FOR(i,0,n)cin >> s[i];\n\n    size_t l = 0, t = 0, r = s[0].size(), b = n;\n    cout << expr(l,t,r,b) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 2011;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct Result{\n  int x, y, value;\n  Result() {}\n  Result(int v, int x, int y) : x(x), y(y), value(v) {}\n};\nint extgcd(int a, int b, int& x, int& y){\n  int d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\nint inv_mod(int a){\n  int x, y;\n  extgcd(a, MOD, x, y);\n  return (MOD + x % MOD) % MOD;\n}\nint pow_mod(int a, int b) {\n  int res = 1;\n  int exp = a % MOD;\n  while (b) {\n    if (b & 1) res = (res * exp) % MOD;\n    exp = (exp * exp) % MOD;\n    b >>= 1;\n  }\n  return res;\n}\nResult expr(const vector<string>& grid, int x, int y);\nResult term(const vector<string>& grid, int x, int y);\nResult factor(const vector<string>& grid, int x, int y);\nResult powexpr(const vector<string>& grid, int x, int y);\nResult primary(const vector<string>& grid, int x, int y);\nResult fraction(const vector<string>& grid, int x, int y);\nResult expr(const vector<string>& grid, int x, int y){\n  Result r = term(grid, x, y);\n  while(grid[r.y].substr(r.x, 3) == \".+.\" || grid[r.y].substr(r.x, 3) == \".-.\"){\n    Result r_ = term(grid, r.x + 3, r.y);\n    if(grid[r.y][r.x + 1] == '+'){\n      r.value = (r.value + r_.value) % MOD;\n    }else{\n      r.value = (r.value - r_.value + MOD) % MOD;\n    }\n    r.x = r_.x, r.y = r_.y;\n  }\n  return r;\n}\nResult term(const vector<string>& grid, int x, int y){\n  //printf(\"term %d %d\\n\", x, y);\n  Result r = factor(grid, x, y);\n  while(grid[r.y].substr(r.x, 3) == \".*.\"){\n    Result r_ = factor(grid, r.x + 3, r.y);\n    r.value = (r.value * r_.value) % MOD;\n    r.x = r_.x, r.y = r_.y;\n  }\n  return r;\n}\nResult factor(const vector<string>& grid, int x, int y){\n  //printf(\"factor %d %d\\n\", x, y);\n  if(grid[y].substr(x, 2) == \"--\"){\n    //fraction\n    return fraction(grid, x, y);\n  }else if(grid[y].substr(x, 2) == \"-.\"){\n    //unary\n    Result r = factor(grid, x + 2, y);\n    r.value = (MOD - r.value) % MOD;\n    return r;\n  }else{\n    //powexpr\n    return powexpr(grid, x, y);\n  }\n}\nResult powexpr(const vector<string>& grid, int x, int y){\n  //printf(\"powexpr %d %d\\n\", x, y);\n  Result r = primary(grid, x, y);\n  if(r.y - 1 >= 0 && isdigit(grid[r.y - 1][r.x])){\n    //pow\n    int exp = grid[r.y - 1][r.x] - '0';\n    r.value = pow_mod(r.value, exp);\n    r.x++; // need???\n    return r;\n  }else{\n    //primary\n    return r;\n  }\n}\nResult primary(const vector<string>& grid, int x, int y){\n  //printf(\"primary %d %d\\n\", x, y);\n  if(grid[y][x] == '('){\n    Result r = expr(grid, x + 2, y);\n    assert(grid[r.y][r.x] == '.');\n    r.x++;\n    assert(grid[r.y][r.x] == ')');\n    r.x++;\n    return r;\n  }else if(isdigit(grid[y][x])){\n    int v = grid[y][x] - '0';\n    return Result(v, x + 1, y);\n  }else {\n    assert(false);\n  }\n}\nResult fraction(const vector<string>& grid, int x, int y){\n  Result r1, r2;\n  for(int bx = x + 1; bx < (int)grid[0].size(); bx++){\n    for(int by = y - 1; by >= 0; by--){\n      if(grid[by][x] == '-') break;\n      if(grid[by][bx] != '.'){\n        r1 = expr(grid, bx, by);\n        goto L1;\n      }\n    }\n  }\nL1:\n  for(int bx = x + 1; bx < (int)grid[0].size(); bx++){\n    for(int by = y + 1; by < (int)grid.size(); by++){\n      if(grid[by][x] == '-') break;\n      if(grid[by][bx] != '.'){\n        r2 = expr(grid, bx, by);\n        goto L2;\n      }\n    }\n  }\nL2:\n  while(grid[y][x] == '-') x++;\n  int v = (r1.value * inv_mod(r2.value)) % MOD;\n  return Result(v, x, y);\n}\n\nint main(){\n  int H;\n  while(cin >> H && H){\n    vector<string> grid(H);\n    REP(i, H) cin >> grid[i];\n    Result r;\n    REP(y, H)if(grid[y][0] != '.') r = expr(grid, 0, y);\n    cout << r.value << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MOD 2011\nint extgcd(int a,int b,int& x,int& y){\n  int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nint mod_inverse(int a,int m){\n  int x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m)%m;\n}\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint n;\nstring str[30];\nint expr(int top,int bottom,int& p);\nint term(int top,int bottom,int& p);\nint factor(int top,int bottom,int& p);\nint powexpr(int top,int bottom,int& p);\nint primary(int top,int bottom,int& p);\nint fraction(int top,int bottom,int& p);\nint digit(int top,int bottom,int& p);\n\nbool dbg=0;\n\nint expr(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  if(dbg){\n    cout<<\"expr\"<<endl;\n    for(int i=top;i<bottom;i++)\n      cout<<str[i]<<endl;\n    cout<<endl;\n  }\n  int res=term(top,bottom,p);\n  while(p+1<(int)str[base].size()){\n    //cout<<\"p+1:\"<<str[base][p+1]<<endl;\n    if(str[base][p+1]=='+'){\n      p+=3;\n      (res+=term(top,bottom,p))%=MOD;\n      continue;\n    }\n    if(str[base][p+1]=='-'){\n      p+=3;\n      (res+=MOD-term(top,bottom,p))%=MOD;\n      continue;\n    }\n    break;\n  }\n  if(dbg) cout<<\"expr:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\n\nint term(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  int res=factor(top,bottom,p);\n  while(p+1<(int)str[base].size()){\n    if(str[base][p+1]=='*'){\n      p+=3;\n      (res*=factor(top,bottom,p))%=MOD;\n      continue;\n    }\n    break;\n  }\n  if(dbg) cout<<\"term:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\n\nint factor(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  int res;\n  if(str[base][p]=='-'){\n    if(str[base][p+1]=='-'){\n      res=fraction(top,bottom,p);\n    }else if(str[base][p+1]=='.'){\n      p+=2;\n      res=(MOD-factor(top,bottom,p))%MOD;\n    }\n  }else{\n    res=powexpr(top,bottom,p);\n  }\n  if(dbg) cout<<\"factor:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\n\nint powexpr(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  int res=primary(top,bottom,p);\n  if(p<(int)str[0].size()&&base>0){\n    if(isdigit(str[base-1][p])){\n      res=mod_pow(res,str[base-1][p]-'0',MOD);\n      p++;\n    }\n  }\n  if(dbg) cout<<\"powexpr:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\nint primary(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  int res;\n  if(str[base][p]=='('){\n    p+=2;\n    res=expr(top,bottom,p);\n    p+=2;\n  }else{\n    res=str[base][p++]-'0';\n  }\n  if(dbg) cout<<\"primary:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\nint fraction(int top,int bottom,int& p){\n  int base;\n  while(p<(int)str[0].size()){\n    bool f=0;\n    for(int i=top;i<bottom;i++)\n      if(str[i][p]!='.') base=i,f=1;\n    if(!f) p++;\n    else break;\n  }\n  int q=p+1;\n  int res=expr(top,base,q);\n  q=p+1;\n  (res*=mod_inverse(expr(base+1,bottom,q),MOD))%=MOD;\n  while(str[base][p]=='-') p++;\n  if(dbg) cout<<\"fraction:\"<<p<<\" \"<<res<<endl;\n  return res;\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<30;i++) str[i]=\"\";\n    for(int i=0;i<n;i++) cin>>str[i];\n    int p=0;\n    cout<<expr(0,n,p)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief 合同算術用クラス\n * @author えびちゃん\n */\n\n#ifndef H_modint\n#define H_modint\n\n#include <cstdint>\n#include <type_traits>\n#include <utility>\n\ntemplate <intmax_t Modulo>\nclass modint {\npublic:\n  using value_type = intmax_t;\n\nprivate:\n  static constexpr value_type S_cmod = Modulo;  // compile-time\n  static value_type S_rmod;  // runtime\n  value_type M_value = 0;\n\n  static constexpr value_type S_inv(value_type n, value_type m) {\n    value_type x = 0;\n    value_type y = 1;\n    value_type a = n;\n    value_type b = m;\n    for (value_type u = y, v = x; a;) {\n      value_type q = b / a;\n      std::swap(x -= q*u, u);\n      std::swap(y -= q*v, v);\n      std::swap(b -= q*a, a);\n    }\n    if ((x %= m) < 0) x += m;\n    return x;\n  }\n\n  static value_type S_normalize(value_type n, value_type m) {\n    if (n >= m) {\n      n %= m;\n    } else if (n < 0) {\n      if ((n %= m) < 0) n += m;\n    }\n    return n;\n  }\n\npublic:\n  modint() = default;\n  modint(value_type n): M_value(S_normalize(n, get_modulo())) {}\n\n  modint& operator =(value_type n) {\n    M_value = S_normalize(n, get_modulo());\n    return *this;\n  }\n\n  modint& operator +=(modint const& that) {\n    if ((M_value += that.M_value) >= get_modulo()) M_value -= get_modulo();\n    return *this;\n  }\n  modint& operator -=(modint const& that) {\n    if ((M_value -= that.M_value) < 0) M_value += get_modulo();\n    return *this;\n  }\n  modint& operator *=(modint const& that) {\n    (M_value *= that.M_value) %= get_modulo();\n    return *this;\n  }\n  modint& operator /=(modint const& that) {\n    (M_value *= S_inv(that.M_value, get_modulo())) %= get_modulo();\n    return *this;\n  }\n\n  modint operator +(modint const& that) const { return modint(*this) += that; }\n  modint operator -(modint const& that) const { return modint(*this) -= that; }\n  modint operator *(modint const& that) const { return modint(*this) *= that; }\n  modint operator /(modint const& that) const { return modint(*this) /= that; }\n\n  modint operator +() const { return *this; }\n  modint operator -() const {\n    if (M_value == 0) return *this;\n    return modint(get_modulo() - M_value);\n  }\n\n  bool operator ==(modint const& that) const { return M_value == that.M_value; }\n  bool operator !=(modint const& that) const { return !(*this == that); }\n\n  value_type get() const { return M_value; }\n  static value_type get_modulo() { return ((S_cmod > 0)? S_cmod: S_rmod); }\n\n  template <int M = Modulo, typename Tp = typename std::enable_if<(M <= 0)>::type>\n  static Tp set_modulo(value_type m) { S_rmod = m; }\n};\n\ntemplate <typename Tp, intmax_t Modulo>\nmodint<Modulo> operator +(Tp const& lhs, modint<Modulo> const& rhs) {\n  return rhs + lhs;\n}\ntemplate <typename Tp, intmax_t Modulo>\nmodint<Modulo> operator -(Tp const& lhs, modint<Modulo> const& rhs) {\n  return -(rhs - lhs);\n}\ntemplate <typename Tp, intmax_t Modulo>\nmodint<Modulo> operator *(Tp const& lhs, modint<Modulo> const& rhs) {\n  return rhs * lhs;\n}\ntemplate <typename Tp, intmax_t Modulo>\nmodint<Modulo> operator /(Tp const& lhs, modint<Modulo> const& rhs) {\n  return modint<Modulo>(lhs) / rhs;\n}\ntemplate <typename Tp, intmax_t Modulo>\nbool operator ==(Tp const& lhs, modint<Modulo> const& rhs) {\n  return rhs == lhs;\n}\ntemplate <typename Tp, intmax_t Modulo>\nbool operator !=(Tp const& lhs, modint<Modulo> const& rhs) {\n  return !(lhs == rhs);\n}\n\ntemplate <intmax_t N>\nconstexpr intmax_t modint<N>::S_cmod;\ntemplate <intmax_t N>\nintmax_t modint<N>::S_rmod;\n\n#ifndef CALL_FROM_TEST\n// constexpr intmax_t mod = 1000'000'007;\n// constexpr intmax_t mod = 998244353;\n// using mi = modint<mod>;\n#endif\n\n#endif  /* !defined(H_modint) */\n\n/** \n * @brief ビット演算\n * @author えびちゃん\n */\n\n#ifndef H_bit\n#define H_bit\n\n#include <climits>\n#include <type_traits>\n\n// #ifdef __has_builtin\nint clz(unsigned n) { return __builtin_clz(n); }\nint clz(unsigned long n) { return __builtin_clzl(n); }\nint clz(unsigned long long n) { return __builtin_clzll(n); }\nint ctz(unsigned n) { return __builtin_ctz(n); }\nint ctz(unsigned long n) { return __builtin_ctzl(n); }\nint ctz(unsigned long long n) { return __builtin_ctzll(n); }\nint popcount(unsigned n) { return __builtin_popcount(n); }\nint popcount(unsigned long n) { return __builtin_popcountl(n); }\nint popcount(unsigned long long n) { return __builtin_popcountll(n); }\n// #else\n// TODO: implement\n// #endif\n\ntemplate <typename Tp>\nauto clz(Tp n) -> typename std::enable_if<std::is_signed<Tp>::value, int>::type {\n  return clz(static_cast<typename std::make_unsigned<Tp>::type>(n));\n}\ntemplate <typename Tp>\nauto ctz(Tp n) -> typename std::enable_if<std::is_signed<Tp>::value, int>::type {\n  return ctz(static_cast<typename std::make_unsigned<Tp>::type>(n));\n}\ntemplate <typename Tp>\nauto popcount(Tp n) -> typename std::enable_if<std::is_signed<Tp>::value, int>::type {\n  return popcount(static_cast<typename std::make_unsigned<Tp>::type>(n));\n}\n\ntemplate <typename Tp>\nint parity(Tp n) { return popcount(n) & 1; }\ntemplate <typename Tp>\nint ilog2(Tp n) {\n  return (CHAR_BIT * sizeof(Tp) - 1) - clz(static_cast<typename std::make_unsigned<Tp>::type>(n));\n}\ntemplate <typename Tp>\nTp ceil2(Tp n) {\n  if (!(n & (n-1))) return n;\n  return Tp(2) << ilog2(n);\n}\ntemplate <typename Tp>\nTp reverse(Tp n) {\n  static constexpr Tp b1 = static_cast<Tp>(0x5555555555555555);\n  static constexpr Tp b2 = static_cast<Tp>(0x3333333333333333);\n  static constexpr Tp b4 = static_cast<Tp>(0x0F0F0F0F0F0F0F0F);\n  static constexpr Tp b8 = static_cast<Tp>(0x00FF00FF00FF00FF);\n  static constexpr Tp bx = static_cast<Tp>(0x0000FFFF0000FFFF);\n  n = ((n & b1) << 1) | ((n >> 1) & b1);\n  n = ((n & b2) << 2) | ((n >> 2) & b2);\n  n = ((n & b4) << 4) | ((n >> 4) & b4);\n  n = ((n & b8) << 8) | ((n >> 8) & b8);\n  n = ((n & bx) << 16) | ((n >> 16) & bx);\n  if ((sizeof n) > 4) n = (n << 32) | (n >> 32);\n  return n;\n}\n\n#endif  /* !defined(H_bit) */\n\n/**\n * @brief 合同算術の基本演算\n * @author えびちゃん\n */\n\n#ifndef H_mod_operations\n#define H_mod_operations\n\n#ifdef CALL_FROM_TEST\n#include \"integer/bit.cpp\"\n#endif\n\n#include <stdexcept>\n#include <vector>\n\ntemplate <typename ModInt>\nModInt pow(ModInt const& n, intmax_t iexp) {\n  ModInt res(1);\n  for (ModInt dbl = n; iexp; iexp >>= 1) {\n    if (iexp & 1) res *= dbl;\n    dbl *= dbl;\n  }\n  return res;\n}\n\ntemplate <typename ModInt>\nModInt sqrt(ModInt const& n) {\n  if (n == 0) return n;\n\n  using value_type = typename ModInt::value_type;\n\n  intmax_t const p = n.get_modulo();\n  if (p % 4 == 3) {\n    ModInt r = pow(n, (p+1) / 4);\n    if (r * r == n) return r;\n    throw std::logic_error(\"quadratic nonresidue\");\n  }\n\n  value_type s = ctz(p-1);\n  value_type q = (p-1) >> s;\n\n  ModInt z;\n  for (value_type z0 = 2; z0 < p; ++z0) {\n    z = ModInt(z0);\n    if (pow(z, (p-1) / 2) == -1) break;\n  }\n\n  value_type m = s;\n  ModInt c = pow(z, q);\n  ModInt t = pow(n, q);\n  ModInt r = pow(n, (q+1) / 2);\n\n  while (true) {\n    if (t == 0) return 0;\n    if (t == 1) return r;\n\n    value_type i = 0;\n    for (auto tt = t; tt != 1; ++i) tt *= tt;\n    if (i == m) throw std::logic_error(\"quadratic nonresidue\");\n    auto b = c;\n    for (value_type j = 0; j < m-i-1; ++j) b *= b;\n    m = i;\n    c = b * b;\n    t *= c;\n    r *= b;\n  }\n}\n\ntemplate <typename ModInt>\nstd::vector<ModInt> sqrt_all(ModInt const& n) {\n  try {\n    auto r = sqrt(n);\n    if (r == -r) return {r};\n    return {r, -r};\n  } catch (std::logic_error const&) {\n    return {};\n  }\n}\n\ntemplate <typename ModPolynomial>\nModPolynomial log(ModPolynomial const& f) {\n  auto g = f;\n  g.differentiate();\n  g *= f.inverse(f.degree()+1);\n  g.integrate();\n  return g;\n}\n\n#endif  /* !defined(H_mod_operations) */\n\n#include <cstddef>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing mi = modint<2011>;\n\nstd::vector<std::string> ops{\"+-\", \"*\"};\n\nmi parse(std::vector<std::string> const& s, size_t& l, size_t u, size_t b, size_t preced = 0) {\n  size_t base;\n  bool found = false;\n  while (!found) {\n    for (base = u; base < b; ++base) {\n      if (s[base][l] != '.') {\n        found = true;\n        break;\n      }\n    }\n    if (!found) ++l;\n  }\n\n  if (preced == ops.size()) {\n    mi res;\n    if (s[base][l] == '(') {\n      ++l;\n      assert(s[base][l] == '.');\n      res = parse(s, ++l, u, b, 0);\n      assert(s[base][l] == '.');\n      ++l;\n      assert(s[base][l] == ')');\n      ++l;\n    } else if (isdigit(s[base][l])) {\n      res = s[base][l++] - '0';\n    } else if (s[base][l] == '-' && s[base][l+1] == '.') {\n      res = -parse(s, l += 2, u, b, preced);\n    } else if (s[base][l] == '-' && s[base][l+1] == '-') {\n      size_t ln = l;\n      size_t ld = l;\n      res = parse(s, ln, u, base, 0) / parse(s, ld, base+1, b, 0);\n      while (s[base][l] == '-') ++l;\n    }\n    if (base-1 < s.size() && l < s[base-1].length() && isdigit(s[base-1][l]))\n      res = pow(res, s[base-1][l++]-'0');\n\n    return res;\n  }\n\n  mi res = parse(s, l, u, b, preced+1);\n  while (l < s[base].length()) {\n    assert(s[base][l] == '.');\n    char op = s[base][l+1];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    l += 2;\n    assert(s[base][l] == '.');\n    mi cur = parse(s, ++l, u, b, preced+1);\n    if (op == '+') res += cur;\n    if (op == '-') res -= cur;\n    if (op == '*') res *= cur;\n  }\n  return res;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s(n);\n  for (auto& si: s) {\n    char buf[96];\n    scanf(\"%s\", buf);\n    si = buf;\n  }\n\n  size_t l = 0;\n  printf(\"%jd\\n\", parse(s, l, 0, n).get());\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\n// base?????????????????????????????????????????¨??????\n// fraction???????????°???????????????(????§?+1, ??????-1)??§??????????????¨??????\n// powexpr??????top????????°??????????????????????????§base??¨????????¨???????????????????????????\n// ????????´????????????????????????????????????(powexpr)\n\nstruct Indices {\n    int x, y;\n    int lx, ly, rx, ry;\n};\n\nint expr(Indices& idx);\n\nint W, H;\nchar field[20][80];\n\nbool wrap(Indices& idx, int x, int y) {\n    return idx.lx <= x && x <= idx.rx && idx.ly <= y && y <= idx.ry;\n}\n\nbool check2(int x, int y, char c) {\n    if (0 <= x && x < W && 0 <= y && y < H) {\n        if (field[y][x] == c) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid skip(Indices& idx, char c) {\n    assert(field[idx.y][idx.x] == c);\n    idx.x++;\n}\n\nint mod(int n) {\n    return (n + 2011) % 2011;\n}\n\nvoid set_base(Indices& idx) {\n    vi candidate;\n    int ma = 0;\n    FOR(y, idx.ly, idx.ry+1) {\n        int cnt = 0;\n        FOR(x, idx.lx, idx.rx+1) {\n            if (field[y][x] != '.') cnt++;\n        }\n        if (ma < cnt) {\n            ma = cnt;\n            candidate.clear();\n        }\n        if (ma == cnt) {\n            candidate.push_back(y);\n        }\n    }\n    int y = candidate[SZ(candidate)-1];\n    idx.y = y;\n}\n\nint digit(Indices& idx) {\n    assert(isdigit(field[idx.y][idx.x]));\n    int n = field[idx.y][idx.x] - '0';\n    idx.x++;\n    return n;\n}\n\nint fraction(Indices& idx) {\n    int width = 0;\n    FOR(x, idx.x, W) {\n        if (check2(x, idx.y, '-')) {\n            width++;\n        } else {\n            break;\n        }\n    }\n\n    Indices idx_top = idx;\n    idx_top.lx = idx_top.x + 1;\n    idx_top.rx = idx_top.x + width - 1;\n    idx_top.ry = idx.y-1;\n    set_base(idx_top);\n    idx_top.x++;\n    FOR(x, idx_top.x, idx_top.rx+1) {\n        if (field[idx_top.y][x] == '.') {\n            idx_top.x++;\n        } else {\n            break;\n        }\n    }\n    Indices idx_bottom = idx;\n    idx_bottom.lx = idx_bottom.x + 1;\n    idx_bottom.rx = idx_bottom.x + width - 1;\n    idx_bottom.ly = idx.y+1;\n    set_base(idx_bottom);\n    idx_bottom.x++;\n    FOR(x, idx_bottom.x, idx_bottom.rx+1) {\n        if (field[idx_bottom.y][x] == '.') {\n            idx_bottom.x++;\n        } else {\n            break;\n        }\n    }\n\n    idx.x += width;\n\n//    LOG(\"top--> \");\n//    REP(x, idx_top.rx+1) {\n//        if (x < idx_top.lx) {\n//            LOG(\" \");\n//        } else {\n//            LOG(\"%c\", field[idx_top.y][x]);\n//        }\n//    }\n//    LOG(\"\\n\");\n//    LOG(\"btm--> \");\n//    REP(x, idx_bottom.rx+1) {\n//        if (x < idx_bottom.lx) {\n//            LOG(\" \");\n//        } else {\n//            LOG(\"%c\", field[idx_bottom.y][x]);\n//        }\n//    }\n//    LOG(\"\\n\");\n    int x = expr(idx_top);\n    int y = expr(idx_bottom);\n    int inv_y;\n    REP(z, 2011) {\n        if ((z * y) % 2011 == 1) {\n            inv_y = z;\n        }\n    }\n    return mod(x * inv_y);\n}\n\nint primary(Indices& idx) {\n    if (check2(idx.x, idx.y, '(')) {\n        skip(idx, '(');\n        skip(idx, '.');\n        int n = expr(idx);\n        skip(idx, '.');\n        skip(idx, ')');\n        return n;\n    } else {\n        return digit(idx);\n    }\n}\n\nint powexpr(Indices& idx) {\n    int n = primary(idx);\n    int y = idx.y-1;\n    if (wrap(idx, idx.x, y) && isdigit(field[y][idx.x])) {\n        Indices idx_in = idx;\n        idx_in.y = y;\n        n = pow(n, digit(idx_in));\n        skip(idx, '.');\n    }\n    return mod(n);\n}\n\nint factor(Indices& idx) {\n    if (check2(idx.x, idx.y, '-')) {\n        if (check2(idx.x+1, idx.y, '-')) {\n            return fraction(idx);\n        } else if (check2(idx.x+1, idx.y, '.')) {\n            skip(idx, '-');\n            skip(idx, '.');\n            return mod(-factor(idx));\n        }\n    }\n    return powexpr(idx);\n}\n\nint term(Indices& idx) {\n    int n = factor(idx);\n    while (1) {\n        if (check2(idx.x+1, idx.y, '*')) {\n            skip(idx, '.');\n            skip(idx, '*');\n            skip(idx, '.');\n            n *= factor(idx);\n        } else {\n            break;\n        }\n    }\n    return mod(n);\n}\n\nint expr(Indices& idx) {\n    int n = term(idx);\n    while (1) {\n        if (check2(idx.x+1, idx.y, '+')) {\n            skip(idx, '.');\n            skip(idx, '+');\n            skip(idx, '.');\n            n += term(idx);\n        } else if (check2(idx.x+1, idx.y, '-')) {\n            skip(idx, '.');\n            skip(idx, '-');\n            skip(idx, '.');\n            n -= term(idx);\n        } else {\n            break;\n        }\n    }\n    return mod(n);\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        cin.ignore();\n        string line;\n        REP(y, n) {\n            getline(cin, line);\n            W = line.length();\n            REP(x, W) {\n                field[y][x] = line[x];\n            }\n        }\n        H = n;\n        Indices idx = {0,0,0,0,W-1,H-1};\n        set_base(idx);\n        cout << expr(idx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\ntypedef vector<vector<int> > VVI;\nconst int INF = 1e9;\n\nvector<string> S;\nint W, H;\n\nint MOD=2011;\n\n\nint extgcd(int a, int b, int &x, int &y)\n{\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a/b) * x;\n\t} else {\n\t\tx=1; y=0;\n\t}\n\treturn d;\n}\n\nint mod_inverse(int a)\n{\n\tint x, y;\n\textgcd(a, MOD, x, y);\n\treturn (MOD + x%MOD) % MOD;\n}\n\nint pow_mod(int val, int e)\n{\n\tint res = 1;\n\tfor (int i=0; i<e; i++) {\n\t\tres *= val;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\n\nint expr(int &lx, int &ly, int &hx, int &hy);\n\nint find_base(int lx, int ly, int hx, int hy)\n{\n\tint res=-1;\n\tfor (int i=ly; i<hy; i++) {\n\t\tif (S[i][lx] != '.') {\n\t\t\tif (res != -1) return -1;\n\t\t\tres = i;\n\t\t}\n\t}\n\treturn res;\n}\n\nint factor(int &lx, int &ly, int &hx, int &hy)\n{\n\t//printf(\"factor(%d, %d, %d, %d)\\n\", lx, ly, hx, hy);\n\t\n\tint res = 0;\n\tint base = -1;\n\twhile (lx<hx && (base=find_base(lx, ly, hx, hy)) < 0) lx++;\n\t\n\tif (S[base][lx] == '-' && S[base][lx+1] == '.') {\n\t\tlx += 2; // skip \"-.\"\n\t\tres = -factor(lx, ly, hx, hy);\n\t\tres += MOD;\n\t\tres %= MOD;\n\t} else if (S[base][lx] == '-' && S[base][lx+1] == '-') {\n\t\t//cerr << \"fraction expr\" << endl;\n\t\t// fraction a/b\n\t\tint len=0;\n\t\twhile (S[base][lx+len] == '-') len++;\n\t\tint tlx=lx, tly=ly, thx=lx+len, thy=base;\n\t\tint a = expr(tlx, tly, thx, thy);\n\t\ttlx=lx, tly=base+1, thx=lx+len, thy=hy;\n\t\tint b = mod_inverse(expr(tlx, tly, thx, thy));\n\t\tres = a*b;\n\t\tres %= MOD;\n\t\t\n\t\tlx += len;\n\t} else {\n\t\t//cerr << \"pow expr\" << endl;\n\t\t// pow expr\n\t\tint primary;\n\t\tif (S[base][lx] == '(') {\n\t\t\tlx++; // skip \"(.\"\n\t\t\tprimary = expr(lx, ly, hx, hy);\n\t\t\tlx++; // skip \".)\"\n\t\t} else {\n\t\t\tif (!isdigit(S[base][lx])) {\n\t\t\t\tcerr << \"Error at LINE \" << __LINE__ << endl;\n\t\t\t\tcerr << \"expected number, but S[base][lx] = \" << S[base][lx] << endl;\n\t\t\t}\n\t\t\tprimary = S[base][lx] - '0';\n\t\t\tlx++;\n\t\t}\n\t\t\n\t\tif (base != ly && isdigit(S[base-1][lx])) {\n\t\t\tint e = S[base-1][lx]-'0';\n\t\t\tlx++; // skip digit\n\t\t\tres = pow_mod(primary, e);\n\t\t\t//cerr << primary << \"^\" << e << \"=\" << res << endl;\n\t\t} else {\n\t\t\tres = primary;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint term(int &lx, int &ly, int &hx, int &hy)\n{\n\t//printf(\"term(%d, %d, %d, %d)\\n\", lx, ly, hx, hy);\n\twhile (lx<hx && find_base(lx, ly, hx, hy) < 0) lx++;\n\tint res = factor(lx, ly, hx, hy);\n\t\n\twhile (lx < hx && ly < hy) {\n\t\tint base=-1;\n\t\twhile (lx<hx && (base=find_base(lx, ly, hx, hy)) < 0) lx++;\n\t\tif (lx < hx-1 && S[base][lx] == '*' && S[base][lx+1] == '.') {\n\t\t\tlx += 2; // skip \"*.\"\n\t\t\tres *= factor(lx, ly, hx, hy);\n\t\t\tres %= MOD;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint expr(int &lx, int &ly, int &hx, int &hy)\n{\n\t//printf(\"expr(%d, %d, %d, %d)\\n\", lx, ly, hx, hy);\n\twhile (lx<hx && find_base(lx, ly, hx, hy) < 0) lx++;\n\tint res = term(lx, ly, hx, hy);\n\t\n\twhile (lx < hx && ly < hy) {\n\t\tint base=-1;\n\t\twhile (lx<hx && (base=find_base(lx, ly, hx, hy)) < 0) lx++;\n\t\tif (S[base][lx]=='+') {\n\t\t\tlx += 2; // skip \"+.\"\n\t\t\tres += term(lx, ly, hx, hy);\n\t\t\tres %= MOD;\n\t\t} else if (S[base][lx]=='-') {\n\t\t\tlx += 2; // skip \"-.\"\n\t\t\tres -= term(lx, ly, hx, hy);\n\t\t\tres += MOD;\n\t\t\tres %= MOD;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tint N;\n\twhile (cin>>N, N) {\n\t\tcin.ignore();\n\t\tS.clear();\n\t\trep(i, N) {\n\t\t\tstring s; getline(cin, s);\n\t\t\tS.push_back(s);\n\t\t}\n\t\tint lx=0, ly=0, hx=(int)S[0].size(), hy=N;\n\t\tcout << expr(lx, ly, hx, hy) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 2011;\nint pow(int n, int m){\n\tint res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nint inv(int n){\n\treturn pow(n, mod - 2);\n}\n\nint n;\nstring in[20];\nint expr(int&, int&, int&, int&);\n\n\nint f(int y, int x, int Y, int X){\n\tint res = -1;\n\tfor(int i = y; i < Y; i++) if(in[i][x] != '.'){\n\t\tres = res == -1 ? i : -2;\n\t}\n\treturn res;\n}\nint powexpr(int &y, int &x, int &Y, int &X){\n\tint p, res;\n\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\tif(in[p][x] == '('){\n\t\tx++;\n\t\tres = expr(y, x, Y, X);\n\t\tx++;\n\t}\n\telse{\n\t\tres = 0;\n\t\twhile(x < X && isdigit(in[p][x])) res *= 10, res += in[p][x++] - '0';\n\t}\n\tif(x < X){\n\t\tp = f(y, x, Y, X);\n\t\tif(p >= 0){\n\t\t\tint e = 0;\n\t\t\twhile(x < X && isdigit(in[p][x])) e *= 10, e += in[p][x++] - '0';\n\t\t\tres = pow(res, e);\n\t\t}\n\t}\n\treturn res;\n}\nint factor(int &y, int &x, int &Y, int &X){\n\tint p;\n\tbool sign = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(x + 1 < X && in[p][x] == '-' && in[p][x + 1] == '.') sign ^= 1, x += 2;\n\t\telse break;\n\t}\n\tif(x + 1 < X && in[p][x] == '-' && in[p][x + 1] == '-'){\n\t\tint q = x;\n\t\twhile(q < X && in[p][q] == '-') q++;\n\t\t\n\t\tint a = y, b = x + 1, c = p, d = q - 1;\n\t\tint num = expr(a, b, c, d);\n\t\t\n\t\ta = p + 1, b = x + 1, c = Y, d = q - 1;\n\t\tint den = expr(a, b, c, d);\n\t\t\n\t\tnum = num * inv(den) % mod;\n\t\tx = q + 1;\n\t\treturn sign ? (mod - num) % mod : num;\n\t}\n\treturn ((sign ? -1 : 1) * powexpr(y, x, Y, X) % mod + mod) % mod;\n}\nint term(int &y, int &x, int &Y, int &X){\n\tint res = inf, p;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = factor(y, x, Y, X);\n\t\tres = res == inf ? a : (a * res) % mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || x >= X || in[p][x] != '*') break;\n\t\tx++;\n\t}\n\treturn res;\n}\nint expr(int &y, int &x, int &Y, int &X){\n\tint res = 0, p, op = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = term(y, x, Y, X);\n\t\t(res += op ? mod - a : a) %= mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || x >= X || in[p][x] != '+' && in[p][x] != '-') break;\n\t\top = in[p][x] == '-';\n\t\tx++;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> in[i];\n\t\tint y = 0, x = 0, Y = n, X = in[0].size();\n\t\tcout << expr(y, x, Y, X) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nconst int MAX_H = 20;\nconst int MAX_W = 160;\nconst int MOD = 2011;\n\n#ifndef DBG\n#define DBG 0\n#endif\n\nint H, W;\nint d; //ツデツバツッツグツ用\nint inv[MOD];\nchar str[MAX_H][MAX_W+1];\n\nint expr(int y1, int x1, int y2, int x2, int& p);\nint term(int y1, int x1, int y2, int x2, int& p);\nint factor(int y1, int x1, int y2, int x2, int& p);\nint powexp(int y1, int x1, int y2, int x2, int& p);\nint primary(int y1, int x1, int y2, int x2, int& p);\nint fraction(int y1, int x1, int y2, int x2, int& p);\nint digit(int y1, int x1, int y2, int x2, int& p);\n\nint pow_calc(int x, int n){\n\tint ret = 1;\n\tfor(;n;n>>=1){\n\t\tif(n&1){\n\t\t\tret = ret * x % MOD;\n\t\t}\n\t\tx = x * x % MOD;\n\t}\n\t\n\treturn ret;\n}\n\n//ツつキツづ猟づЪy1, y2) * [x1,x2)ツづ個陛つ凝ヲツ甘板づ考ツつヲツづゥ!!!!!!\nint cut(int& y1, int& x1, int& y2, int& x2){\n\n\tint line = -1;\n\t//ツ債カツづーツカツッツト\n\tfor(;;){\n\t\tbool found = false;\n\t\tfor(int i=y1; i<y2; i++){\n\t\t\tif(str[i][x1] != '.'){\n\t\t\t\tfound = true;\n\t\t\t\tline = i;\n\t\t\t}\t\n\t\t}\n\t\tif(!found){\n\t\t\tx1++;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//ツ右ツづーツカツッツト\n\tfor(;;){\n\t\tbool found = false;\n\t\tfor(int i=y1; i<y2; i++){\n\t\t\tif(str[i][x2-1] != '.'){\n\t\t\t\tfound = true;\n\t\t\t}\t\n\t\t}\n\t\tif(!found){\n\t\t\tx2--;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t//ツ湘」ツづーツカツッツト\n\tfor(;;){\n\t\tbool found = false;\n\t\tfor(int i=x1; i<x2; i++){\n\t\t\tif(str[y1][i] != '.'){\n\t\t\t\tfound = true;\n\t\t\t}\t\n\t\t}\n\t\tif(!found){\n\t\t\ty1++;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t//ツ可コツづーツカツッツト\n\tfor(;;){\n\t\tbool found = false;\n\t\tfor(int i=x1; i<x2; i++){\n\t\t\tif(str[y2-1][i] != '.'){\n\t\t\t\tfound = true;\n\t\t\t}\t\n\t\t}\n\t\tif(!found){\n\t\t\ty2--;\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn line;\n}\n\nvoid dbg(const char* s){\n\tif(DBG){\n\t\tfor(int i=0; i<d; i++) putchar(' ');\n\t\tputs(s);\n\t}\n}\n\nint expr(int y1, int  x1, int y2, int x2, int& p){\n\tdbg(\"expr in\"); d++;\n\tint line = cut(y1, x1, y2, x2), ret = -1;\n\tp = x1;\n\t\n\tret = term(y1, x1, y2, x2, p);\n\twhile( p + 3 < x2 && (str[line][p+1]=='+' || str[line][p+1]=='-') ){\n\t\tp += 3;\n\t\tret = (ret + (str[line][p-2]=='+' ? 1 : -1) * term(y1, p, y2, x2, p) + MOD) % MOD;\n\t}\n\t\n\td--; dbg(\"expr out\");\n\treturn ret;\n}\n\nint term(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"term in:\"); d++;\n\tint line = cut(y1, x1, y2, x2);\n\tp = x1;\n\tint ret = factor(y1, x1, y2, x2, p);\n\n\twhile( p + 3 < x2 && str[line][p+1] == '*' ){\n\t\tp += 3;\n\t\tret = ret  * term(y1, p, y2, x2, p) % MOD;\n\t}\n\t\n\td--; dbg(\"term out:\");\n\treturn ret;\n}\n\nint factor(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"factor in:\"); d++;\n\tint line = cut(y1, x1, y2, x2), ret = -1;\n\tp = x1;\n\t\n\tif(x2 - x1 < 2){\n\t\tret = powexp(y1, x1, y2, x2, p);\n\t}\n\telse if(str[line][x1] == '-' && str[line][x1+1] == '-'){\n\t\tret = fraction(y1, x1, y2, x2, p);\n\t}\n\telse if(str[line][x1] == '-'){\n\t\tp = x1 + 2;\n\t\tret = (MOD - factor(y1, p, y2, x2, p)) % MOD;\n\t}\n\telse{\n\t\tret = powexp(y1, x1, y2, x2, p);\n\t}\n\n\td--; dbg(\"factor out:\");\n\treturn ret;\n}\n\nint powexp(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"powexp in:\"); d++;\n\n\tint line = cut(y1, x1, y2, x2);\n\tp = x1;\n\tint ret = primary(y1, x1, y2, x2, p);\n\tif(p < x2 && line-1 >= y1 && isdigit(str[line-1][p]) ){\n\t\tint dig = digit(y1, p, y2, x2, p);\n\t\tret = pow_calc(ret, dig);\n\t}\n\t\n\td--; dbg(\"powexp out:\");\n\treturn ret;\n}\n\nint primary(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"primary in:\"); d++;\n\n\tint line = cut(y1, x1, y2, x2), ret = -1;\n\tp = x1;\t\n\tif(str[line][x1] == '('){\n\t\tp += 2;\n\t\tret = expr(y1, p, y2, x2, p);\n\t\tp += 2;\n\t\t\n\t}\n\telse{\n\t\tret = digit(y1, x1, y2, x2, p);\n\t}\n\t\n\td--;dbg(\"primary out:\");\n\treturn ret;\n}\n\nint fraction(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"fraction in:\"); d++;\n\tint line = cut(y1, x1, y2, x2);\n\tp = x1;\n\n\tint pp = 0;\n\twhile(p < x2 && str[line][p] == '-') p++;\n\tpp = x1;\t\n\tint nume = expr(y1, x1, line, x2, pp);\n\tpp = x1;\n\tint deno = expr(line+1, x1, y2, x2, pp);\n\td--; dbg(\"fraction out:\");\n\treturn nume * inv[deno] % MOD;\n}\n\n\nint digit(int y1, int x1, int y2, int x2, int& p){\n\tdbg(\"digit in:\"); d++;\n\tint line = cut(y1, x1, y2, x2);\n\tp = x1;\n\td--;dbg(\"digit out:\");\n\treturn str[line][p++]&15;\n}\n\n\nbool init(){\n\tscanf(\"%d \", &H);\n\tfor(int i=0; i<H; i++){\n\t\tscanf(\"%s \", str[i]);\n\t}\n\treturn H > 0;\n}\n\nint solve(){\n\td = 0;\n\tint p = 0;\n\tW = strlen(str[0]);\n\treturn expr(0, 0, H, W, p);\n}\n\nvoid pre(){\n\tfor(int i=0; i<MOD; i++){\n\t\tinv[i] = pow_calc(i, MOD-2);\n\t}\n}\n\nint main(){\n\tpre();\n\twhile(init()){\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n// #include<cassert>\nusing namespace std;\n\nconst int rhl = 2011,maxn = 90;\nchar S[maxn][maxn]; int N,M,inv[rhl];\n\ninline int qsm(int a,int b)\n{\n\tint ret = 1;\n\tfor (;b;b >>= 1,(a *= a) %= rhl) if (b&1) (ret *= a) %= rhl;\n\treturn ret;\n}\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1;\n\tdo ch = getchar();while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar();;\n\tdo ret = ret*10+ch-'0',ch = getchar(); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline int get_expr(int,int,int,int);\ninline int get_term(int,int,int,int);\ninline int get_factor(int,int,int,int);\ninline int get_powexpr(int,int,int,int);\ninline int get_frac(int,int,int,int);\n\ninline bool is_minus(int a,int b)\n{\n\tif (S[a][b] != '-') return false;\n\tif (b-1&&S[a][b-1] == '-') return false;\n\tif (b+1 <= M&&S[a][b+1] == '-') return false;\n\tif (a-1&&S[a-1][b] >= '0'&&S[a-1][b] <= '9') return false;\n\treturn true;\n}\n\ninline bool nonex(int a,int Y1,int Y2)\n{\n\tfor (int i = Y1;i <= Y2;++i)\n\t\tif (S[a][i] != '.') return false;\n\treturn true;\n}\ninline bool noney(int X1,int X2,int a)\n{\n\tfor (int i = X1;i <= X2;++i)\n\t\tif (S[i][a] != '.') return false;\n\treturn true;\n}\n\ninline int get_expr(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,loc,pcnt = 0,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\tfor (loc = Y2;loc >= Y1;--loc)\n\t{\n\t\tif (S[base][loc] == ')') ++pcnt;\n\t\telse if (S[base][loc] == '(') --pcnt;\n\t\telse if (!pcnt)\n\t\t{\n\t\t\tif (S[base][loc] == '+') break;\n\t\t\telse if (is_minus(base,loc)&&!(loc-2<Y1||S[base][loc-2] == '*'||is_minus(base,loc-2))) break;\n\t\t}\n\t}\n\tif (loc == Y1-1) ret = get_term(X1,Y1,X2,Y2);\n\telse if (S[base][loc] == '+') ret = get_expr(X1,Y1,X2,loc-2)+get_term(X1,loc+2,X2,Y2);\n\telse ret = get_expr(X1,Y1,X2,loc-2)-get_term(X1,loc+2,X2,Y2);\n\tif (ret >= rhl) ret -= rhl; if (ret < 0) ret += rhl; return ret;\t\n}\n\ninline int get_term(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,loc,pcnt = 0,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\tfor (loc = Y2;loc >= Y1;--loc)\n\t{\n\t\tif (S[base][loc] == ')') ++pcnt;\n\t\telse if (S[base][loc] == '(') --pcnt;\n\t\telse if (!pcnt&&S[base][loc] == '*') break;\n\t}\n\tif (loc == Y1-1) ret = get_factor(X1,Y1,X2,Y2);\n\telse ret = get_term(X1,Y1,X2,loc-2)*get_factor(X1,loc+2,X2,Y2);\n\tif (ret >= rhl) ret %= rhl; return ret;\n}\n\ninline int get_factor(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\tif (S[base][Y1] == '-')\n\t{\n\t\tif (Y2 > Y1&&S[base][Y1+1] == '.')\n\t\t\tret = -get_factor(X1,Y1+2,X2,Y2);\n\t\telse ret = get_frac(X1,Y1,X2,Y2);\n\t}\n\telse ret = get_powexpr(X1,Y1,X2,Y2);\n\tif (ret < 0) ret += rhl; return ret;\t\n}\n\ninline int get_frac(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\tret = get_expr(X1,Y1+1,base-1,Y2-1)*inv[get_expr(base+1,Y1+1,X2,Y2-1)];\n\tif (ret >= rhl) ret %= rhl;\n\treturn ret;\n}\n\ninline int get_powexpr(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1; while (base <= X2&&S[base][Y1] == '.') ++base;\n\tif (S[base][Y1] == '(')\n\t{\n\t\tif (S[base][Y2] == ')') return get_expr(X1,Y1+2,X2,Y2-2);\n\t\telse return qsm(get_expr(X1,Y1+2,X2,Y2-3),S[base-1][Y2]-'0');\n\t}\n\telse\n\t{\n\t\tif (S[base][Y2] == '.') return qsm(S[base][Y1]-'0',S[base-1][Y2]-'0');\n\t\telse return S[base][Y1]-'0';\n\t}\n}\n\nint main()\n{\n\t//freopen(\"H.in\",\"r\",stdin);\n\tinv[1] = 1;\n\tfor (int i = 2;i < rhl;++i)\n\t{\n\t\tinv[i] = -(rhl/i)*inv[rhl%i]%rhl;\n\t\tif (inv[i] < 0) inv[i] += rhl;\n\t}\n\twhile (true)\n\t{\n\t\tN = gi(); if (!N) break;\n\t\tfor (int i = 1;i <= N;++i) scanf(\"%s\",S[i]+1);\n\t\tM = strlen(S[1]+1);\n\t\tprintf(\"%d\\n\",get_expr(1,1,N,M));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <string>\n\n#define fprintf(...) void(0)\n\nconstexpr intmax_t MOD=2011;\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return (lhs + rhs) % MOD;\n  case '-': return ((lhs - rhs) % MOD + MOD) % MOD;\n  case '*': return (lhs * rhs) % MOD;\n  }\n  assert(false);\n}\n\nintmax_t modpow(intmax_t base, intmax_t iexp) {\n  fprintf(stderr, \"%jd^%jd\\n\", base, iexp);\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1) (res *= dbl) %= MOD;\n    (dbl *= dbl) %= MOD;\n  }\n  return res;\n}\n\nintmax_t moddiv(intmax_t num, intmax_t den) {\n  intmax_t div=modpow(den, MOD-2);\n  return num*div % MOD;\n}\n\nintmax_t parse(const std::vector<std::string> &s, size_t &i,\n               size_t top, size_t bottom, size_t left, size_t right,\n               size_t preced=0, size_t base=-1,\n               const std::vector<std::string> &ops={\"+-\", \"*\"}) {\n\n  while (base+1 == 0) {\n    for (size_t r=top; r<bottom; ++r) {\n      if (s[r][i] != '.') {\n        base = r;\n        break;\n      }\n    }\n    if (base+1 == 0) ++i;\n  }\n  assert(base+1 != 0);\n  fprintf(stderr, \"s[%zu][%zu]: LR[%zu, %zu), TB[%zu, %zu), prec:%zu\\n\",\n          base, i, left, right, top, bottom, preced);\n\n  if (preced == ops.size()) {\n    intmax_t res=114514;\n    if (s[base][i] == '(') {\n      res = parse(s, i+=2, top, bottom, left, right, 0, base);\n      fprintf(stderr, \"s[%zu][%zu] L%d\\n\", base, i, __LINE__);\n      assert(s[base][i] == ')');\n      ++i;\n    } else if (s[base][i] == '-') {\n      if (s[base][i+1] == '-') {\n        size_t vl=i, vr=i+1;\n        while (s[base][++vr] == '-') {}\n\n        size_t j=vl+1;\n        intmax_t numer=parse(s, j, top, base, vl, vr, 0);\n        j = vl+1;\n        intmax_t denom=parse(s, j, base+1, bottom, vl, vr, 0);\n        res = moddiv(numer, denom);\n        i = vr;\n      } else {\n        res = MOD-parse(s, i+=2, top, bottom, left, right, preced, base);\n        return res;  // ???\n      }\n    } else if (isdigit(s[base][i])) {\n      res = s[base][i]-'0';\n      ++i;\n    } else {\n      fprintf(stderr, \"s[%zu][%zu] on L%d\\n\", base, i, __LINE__);\n      assert(false);\n    }\n\n    if (i < right && top+1 <= base && isdigit(s[base-1][i])) {\n      fprintf(stderr, \"s[%zu][%zu]: %c\\n\", base-1, i, s[base-1][i]);\n      fprintf(stderr, \"%jd^%jd: L%d\\n\", res, intmax_t(s[base-1][i]-'0'), __LINE__);\n      res = modpow(res, s[base-1][i]-'0');\n      ++i;\n    }\n    ++i;\n    fprintf(stderr, \"s[%zu][%zu]\\n\", base, i);\n    fprintf(stderr, \"Returns %jd\\n\", res);\n    return res;\n  }\n\n  intmax_t lhs=parse(s, i, top, bottom, left, right, preced+1, base);\n  while (i < right) {\n    char op=s[base][i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t rhs=parse(s, i+=2, top, bottom, left, right, preced+1, base);\n    lhs = apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s;\n  for (size_t i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s.emplace_back(buf);\n  }\n\n  size_t i=0;\n  intmax_t res=parse(s, i, 0, s.size(), 0, s[0].length());\n  printf(\"%jd\\n\", res);\n  fprintf(stderr, \"------------------------------\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Int;\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nInt invMod(Int a, Int m) {\n  Int x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\nint mod(int a) {\n  return (a%2011+2011)%2011;\n}\n\nint rec(vector<string> vs) {\n  int h = vs.size();\n  int w = vs[0].size();\n\n  // REP(y, h)\n  //   cout<< vs[y] << endl;\n  // cout << endl;\n  \n  int base;                     \n  int start;\n  REP(x, w) {\n    REP(y, h) {\n      if (vs[y][x] != '.') {\n        base = y;\n        start = x;\n        goto next;\n      }\n    }\n  }\nnext:;\n  char c = vs[base][start];\n\n  int nest = 0;\n  for (int x=w-1; x>=start; --x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (vs[base][x] == '+' && nest == 0) {\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) + rec(b));\n    }\n    if (x != start && vs[base][x] == '-' && vs[base][x+1] != '-' && vs[base][x-1] != '-' && nest == 0) {\n      if ((x>=3 && vs[base][x-3] == '.' || x==2) && (vs[base][x-2] =='+' || vs[base][x-2] =='-' || vs[base][x-2] =='*')) continue;\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) - rec(b));\n    }\n  }\n  nest = 0;\n  for (int x=start; x<w; ++x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (vs[base][x] == '*' && nest == 0) {\n      vector<string> a,b;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x-1));\n        b.push_back(vs[i].substr(x+2));\n      }\n      return mod(rec(a) * rec(b));\n    }\n  }\n  \n  if (c == '-' && vs[base][start+1] != '-') {               // unary\n    // cout << \"unary\" << endl;\n    vector<string> a;\n    FOR(it, vs)\n      a.push_back(it->substr(start+2));\n    return mod(-rec(a));\n  }\n\n  if (c == '-' && vs[base][start+1] == '-') {               // fraction\n    vector<string> a,b;\n    REP(y, base) {\n      a.push_back(vs[y]);\n    }\n    for (int y=base+1; y<h; ++y) {\n      b.push_back(vs[y]);\n    }\n    int p = rec(a);\n    int q = rec(b);\n    // cout << p << \" \" << q << \" \" << invMod(q, 2011) << endl;\n    // cout << p*invMod(q, 2011)%2011 << endl;\n    return mod(p*invMod(q, 2011));\n  }\n    \n  nest = 0;\n  for (int x=start; x<w; ++x) {\n    if (vs[base][x] == '(') nest++;\n    if (vs[base][x] == ')') nest--;\n    if (base&&isdigit(vs[base-1][x]) && nest == 0) {\n      vector<string> a;\n      REP(i, vs.size()) {\n        a.push_back(vs[i].substr(0, x));\n      }\n      int res = rec(a);\n      int ans = 1;\n      REP(i, vs[base-1][x]-'0')\n        ans = mod(ans*res);\n      return ans;\n    }\n  }\n  \n  if (c == '(') {\n    nest = 0;\n    for (int x=start; x<w; ++x) {\n      if (vs[base][x] == '(') nest++;\n      if (vs[base][x] == ')') nest--;\n      if (nest == 0) {\n        vector<string> a;\n        FOR(it, vs) {\n          a.push_back(it->substr(start+1, x-start-1));\n        }\n        return rec(a);\n      }\n    }\n  }\n\n  return c - '0';\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    vector<string> input(n);\n    REP(i,n)\n      cin>>input[i];\n    int res = rec(input);\n\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n\nint mod=2011;\n\nint inv[2011];\n\nint ruijo(int x,int n){\n\tint p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\nint n;\nint m;\nvector<string> v;\n\nint expr(int a,int b,int c,int d);\nint term(int a,int b,int c,int d);\nint factor(int a,int b,int c,int d);\nint powexpr(int a,int b,int c,int d);\nint primary(int a,int b,int c,int d);\n\n\nint expr(int a,int b,int c,int d){\n\t//cout << \"expr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn expr(a,b+1,c,d);\n\t}\n\tint x_tmp = -1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][d]!='.')x_tmp=i;\n\t}\n\tif(x_tmp==-1){\n\t\treturn expr(a,b,c,d-1);\n\t}\n\tint y=b;\n\tint yt = -1;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&(v[x][i]=='*'||v[x][i]=='+'||v[x][i]=='-')){\n\t\t\tif(v[x][i]=='+'){\n\t\t\t\ty = i;\n\t\t\t\tyt = i;\n\t\t\t}else if(v[x][i]=='*'){\n\t\t\t\tyt = i;\n\t\t\t}else{\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'){\n\t\t\t\t\t\tyt = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i!=d&&i!=0){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'&&v[x][i-1]=='.'){\n\t\t\t\t\t\tif(yt+2==i){\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn term(a,b,c,d);\n\t}else{\n\t\tif(v[x][y]=='-'){\n\t\t\treturn (mod+expr(a,b,c,y-2)-term(a,y+2,c,d))%mod;\n\t\t}else{\n\t\t\treturn (expr(a,b,c,y-2)+term(a,y+2,c,d))%mod;\n\t\t}\n\t}\n}\n\nint term(int a,int b,int c,int d){\n\t//cout << \"term \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn term(a,b+1,c,d);\n\t}\n\tint y=b;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&v[x][i]=='*'){\n\t\t\ty = i;\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn factor(a,b,c,d);\n\t}else{\n\t\treturn (term(a,b,c,y-2)*factor(a,y+2,c,d))%mod;\n\t}\n}\n\nint factor(int a,int b,int c,int d){\n\t//cout << \"factor \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn factor(a,b+1,c,d);\n\t}\n\tif(v[x][b]!='-'){\n\t\treturn powexpr(a,b,c,d);\n\t}\n\tif(v[x][b+1]=='-'){\n\t\treturn (expr(a,b,x-1,d)*inv[expr(x+1,b,c,d)])%mod;\n\t}else{\n\t\treturn (mod - factor(a,b+2,c,d))%mod;\n\t}\n}\n\nint powexpr(int a,int b,int c,int d){\n\t//cout << \"powexpr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn powexpr(a,b+1,c,d);\n\t}\n\tif(v[x][b]=='('){\n\t\tint depth = 0;\n\t\tfor(int i=b;i<=d;i++){\n\t\t\tif(v[x][i]=='('){\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tif(v[x][i]==')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth==0){\n\t\t\t\t\tif(x!=0&&i<d){\n\t\t\t\t\t\tif(v[x-1][i+1]!='.'&&v[x-1][b+1]!='-'){\n\n\t\t\t\t\t\t\treturn ruijo(expr(a,b+1,c,i-1),v[x-1][i+1]-'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn expr(a,b+1,c,i-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(x!=0&&b<d){\n\t\t\tif(v[x-1][b+1]!='.'&&v[x-1][b+1]!='-'){\n\t\t\t\treturn ruijo(v[x][b]-'0',v[x-1][b+1]-'0');\n\t\t\t}\n\t\t}\n\t\treturn v[x][b]-'0';\n\t}\n}\n\nint main(){\n\tfor(int i=1;i<2011;i++){\n\t\tinv[i] = ruijo(i,2009);\n\t}\n\twhile(cin >> n&&n!=0){\n\t\tv.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t\tm = v[0].size();\n\t\tint ans=0; \n\t\tans = expr(0,0,n-1,m-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int mod = 2011;\n\nint mod_pow(int x, int n){\n    int ret = 1;\n    while(n){\n        if(n&1) (ret *= x) %= mod;\n        (x *= x) %= mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint mod_inv(int x){\n    return mod_pow(x, mod-2);\n}\n\nint h,w;\nstring s[20];\n\nconst int H = 22, W = 88;\nint vertical_dots[W][H];\nint horizontal_dots[H][W];\n\nvoid CUT(int &ly, int &lx, int &ry, int &rx){\n    int ww = rx-lx+1;\n    while(horizontal_dots[ly][rx+1] - horizontal_dots[ly][lx] == ww) ++ly;\n    while(horizontal_dots[ry][rx+1] - horizontal_dots[ry][lx] == ww) --ry;\n\n    int hh = ry-ly+1;\n    while(vertical_dots[lx][ry+1] - vertical_dots[lx][ly] == hh) ++lx;\n    while(vertical_dots[rx][ry+1] - vertical_dots[rx][ly] == hh) --rx;\n}\n\nint expr(int ly, int lx, int ry, int rx);\n\nint digit(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n    assert(ly==ry && lx==rx);\n    return s[ly][lx] - '0';\n}\n\nint fraction(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n    // printf(\" !!! fraction: (%d %d %d %d) \\n\", ly,lx,ry,rx);\n\n    int base_y = -1;\n    for(int y=ly; y<=ry; ++y){\n        if(s[y][lx] == '-'){\n            base_y = y;\n            break;\n        }\n    }\n    assert(base_y >= 0);\n\n    return (expr(ly,lx,base_y-1,rx) * mod_inv(expr(base_y+1,lx,ry,rx))) % mod;\n}\n\nint primary(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n\n    int brac = -1;\n    for(int y=ly; y<=ry; ++y){\n        if(s[y][lx]=='('){\n            brac = y;\n            break;\n        }\n    }\n\n    if(brac==-1) return digit(ly,lx,ry,rx);\n    else{\n        assert(s[brac][rx] == ')');\n        return expr(ly,lx+2,ry,rx-2);\n    }\n}\n\nint powexpr(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n\n    if(ly==ry && lx==rx) return digit(ly,lx,ry,rx);\n\n    int exp = -1;\n    for(int y=ly; y<=ry; ++y){\n        if( isdigit(s[y][rx]) ) exp = s[y][rx]-'0';\n    }\n\n    if(exp == -1) return primary(ly,lx,ry,rx);\n    return mod_pow(primary(ly,lx,ry,rx-1), exp);\n}\n\nint factor(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n    // printf(\" factor: (%d %d %d %d) \\n\", ly,lx,ry,rx);\n\n    // fraction\n    for(int y=ly; y<=ry; ++y){\n        bool is_frac = true;\n        for(int x=lx; x<=rx; ++x){\n            is_frac &= (s[y][x] == '-');\n        }\n        if(is_frac) return fraction(ly,lx,ry,rx);\n    }\n\n    // - factor\n    for(int y=ly; y<=ry; ++y){\n        if(s[y][lx] == '-'){\n            return (-factor(ly,lx+2,ry,rx) + mod) % mod;\n        }\n    }\n\n    return powexpr(ly,lx,ry,rx);\n}\n\nint term(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n    // printf(\" term: (%d %d %d %d) \\n\", ly,lx,ry,rx);\n\n    int base_y = -1;\n    for(int y=ly; y<=ry; ++y){\n        bool is_frac = true;\n        for(int x=lx; x<=rx; ++x){\n            is_frac &= (s[y][x] == '-');\n\n            if(s[y][x] == '*'){\n                bool ok = true;\n                for(int i:{-1,1}){\n                    int xx = x+i;\n                    if(lx<=xx && xx<=rx){\n                        for(int yy=ly; yy<=ry; ++yy){\n                            ok &= (s[yy][xx]=='.');\n                        }\n                    }\n                }\n\n                if(ok){\n                    base_y = y;\n                    break;\n                }\n            }\n        }\n\n        if(base_y!=-1) break;\n        if(is_frac) return fraction(ly,lx,ry,rx);\n    }\n\n    if(base_y == -1) return factor(ly,lx,ry,rx);\n\n    int sep_x = rx;\n    int brac = 0;\n    while(sep_x>=lx){\n        if(s[base_y][sep_x] == ')') ++brac;\n        if(s[base_y][sep_x] == '(') --brac;\n\n        if(brac==0 && s[base_y][sep_x] == '*') break;\n        --sep_x;\n    }\n\n    if(sep_x<lx) return factor(ly,lx,ry,rx);\n    return (term(ly,lx,ry,sep_x-1) * factor(ly,sep_x+1,ry,rx)) % mod;\n}\n\nint expr(int ly, int lx, int ry, int rx){\n    CUT(ly,lx,ry,rx);\n    // printf(\" expr: (%d %d %d %d) \\n\", ly,lx,ry,rx);\n\n    int base_y = -1;\n    for(int y=ly; y<=ry; ++y){\n        bool is_frac = true;\n        for(int x=lx; x<=rx; ++x){\n            is_frac &= (s[y][x] == '-');\n\n            if(s[y][x] == '+' || s[y][x] == '-'){\n                bool ok = true;\n                for(int i:{-1,1}){\n                    int xx = x+i;\n                    if(lx<=xx && xx<=rx){\n                        for(int yy=ly; yy<=ry; ++yy){\n                            ok &= (s[yy][xx]=='.');\n                        }\n                    }\n                }\n\n                if(ok){\n                    base_y = y;\n                    break;\n                }\n            }\n        }\n\n        if(base_y!=-1) break;\n        if(is_frac) return fraction(ly,lx,ry,rx);\n    }\n\n    if(base_y == -1) return term(ly,lx,ry,rx);\n\n    int sep_x = rx;\n    int brac = 0;\n    while(sep_x>=lx){\n        if(s[base_y][sep_x] == ')') ++brac;\n        if(s[base_y][sep_x] == '(') --brac;\n\n        if(brac==0){\n            if(s[base_y][sep_x] == '+') break;\n            if(s[base_y][sep_x] == '-'){\n                if(lx+2<=sep_x && sep_x+1<=rx){\n                    bool valid = (s[base_y][sep_x-1]=='.' && s[base_y][sep_x+1]=='.');\n                    char ch = s[base_y][sep_x-2];\n                    if(valid){\n                        if(ch == '-'){\n                            // chは分数の線なのでok\n                            if(sep_x-3>=0 && s[base_y][sep_x-3]=='-') break;\n                        }\n                        else{\n                            if(ch != '+' && ch != '*') break;\n                        }\n                    }\n                }\n            }\n        }\n        --sep_x;\n    }\n\n    if(sep_x<lx) return term(ly,lx,ry,rx);\n\n    int mul = 1;\n    if(s[base_y][sep_x] == '-') mul = -1;\n\n    return (expr(ly,lx,ry,sep_x-1) + mul*term(ly,sep_x+1,ry,rx) + mod) % mod;\n}\n\nint main(){\n    while(cin >>h,h){\n        rep(i,h) cin >>s[i];\n        w = s[0].size();\n\n        memset(vertical_dots, 0, sizeof(vertical_dots));\n        rep(i,w){\n            rep(j,h){\n                vertical_dots[i][j+1] = vertical_dots[i][j] + (s[j][i]=='.');\n            }\n        }\n\n        memset(horizontal_dots, 0 ,sizeof(horizontal_dots));\n        rep(i,h){\n            rep(j,w){\n                horizontal_dots[i][j+1] = horizontal_dots[i][j] + (s[i][j]=='.');\n            }\n        }\n\n        cout << expr(0,0,h-1,w-1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint expr(int l,int m,int r);\nint term(int l,int m,int r);\nint factor(int l,int m,int r);\nint powexpr(int l,int m,int r);\nint fraction(int l,int m,int r);\nint primary(int l,int m,int r);\nint digit(int l,int m,int r);\n\nconst int MOD = 2011;\nstring s[100];\nint p,h,w;\n\nint POW(int x,int n){\n    int res=1;\n    for(int i=0;(1<<i)<=n;i++){\n        if((n>>i)&1) res=(res*x)%MOD;\n        x=(x*x)%MOD;\n    }\n    return res;\n}\nint g_A(int l,int m,int r){\n    for(;p<w;p++){\n        for(int i=l;i<r;i++){\n            if(s[i][p]!='.'){\n                return expr(l,i,r);\n            }\n        }\n    }\n}\nint expr(int l,int m,int r){\n    int t=term(l,m,r);\n\n    while(s[m][p]=='+' || s[m][p]=='-'){\n        char tc=s[m][p];\n        p+=2;\n        int res=term(l,m,r);\n        if(tc=='+') t=(t+res)%MOD;\n        if(tc=='-') t=(t-res+MOD)%MOD;\n    }\n\n    return t;\n}\nint term(int l,int m,int r){\n    int t=factor(l,m,r);\n\n    while( s[m][p]=='*' ){\n        p+=2;\n        int res=factor(l,m,r);\n        t=(t*res)%MOD;\n    }\n\n    return t;\n}\nint factor(int l,int m,int r){\n\n    if(s[m][p]=='-'&&s[m][p+1]=='-'){\n        return fraction(l,m,r);\n    }\n\n    else if(s[m][p]=='-'){\n        p+=2;\n        return (MOD - factor(l,m,r)) % MOD;\n    }\n\n    return powexpr(l,m,r);\n\n}\n\nint powexpr(int l,int m,int r){\n    int t=primary(l,m,r);\n    if(s[m][p]=='.'){\n        if(m-1>=l && p && m && isdigit(s[m-1][p-1])){\n            t=POW(t,s[m-1][p-1]-'0');\n            p++;\n        }\n    }\n    return t;\n}\n\nint primary(int l,int m,int r){\n    if(s[m][p]=='('){\n        p+=2;\n        int t=expr(l,m,r);\n        p+=2;\n        return t;\n    }\n    else{\n        int t=digit(l,m,r);\n        p+=2;\n        return t;\n    }\n}\n\nint fraction(int l,int m,int r){\n    int tmp=p;\n    int A=g_A(l,0,m);\n    p=tmp;\n    int B=g_A(m+1,0,r);\n    p=tmp;\n    while(p<w && s[m][p]=='-') p++; p++;\n    return ( A * POW(B,MOD-2) ) % MOD; \n}\n\nint digit(int l,int m,int r){\n    return s[m][p]-'0';\n}\n\nsigned main(){\n    while(cin>>h,h){\n        p=0;\n        for(int i=0;i<h;i++) cin>>s[i] , s[i]+=\"....@@\" ;\n        w=s[0].size()-5;\n        cout<<g_A(0,0,h)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n;\nstring in[20];\nint inv[3000];\n\nvoid normal(int &x1,int &y1,int &x2,int &y2){\n  set<int> x,y;\n  for(int i=x1;i<x2;++i)\n    for(int j=y1;j<y2;++j){\n      if(in[i][j]!='.'){\n        x.insert(i);\n        y.insert(j);\n      }\n    }\n  x1 = *x.begin();\n  x2 = *x.rbegin()+1;\n  y1 = *y.begin();\n  y2 = *y.rbegin()+1;\n}\n\nint expr(int,int,int,int);\nint term(int,int,int,int);\nint factor(int,int,int,int);\nint powexpr(int,int,int,int);\nint primary(int,int,int,int);\n\nint digit(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"digit \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;          \n  int ret=0;\n  while(y1<y2 && isdigit(in[x1][y1]))\n    ret=(ret*10+in[x1][y1++]-'0')%2011;\n  return ret;\n}\n\nint primary(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"primary \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;\n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  if(in[base][y1]=='(')\n    return expr(x1,y1+1,x2,y2-1);\n  return digit(x1,y1,x2,y2);\n}\n\nint fraction(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int p=expr(base+1,y1,x2,y2);\n  int c=expr(x1,y1,base,y2);\n  return c*inv[p]%2011;\n}\n\nint powexpr(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"powexpr \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;\n  int base;\n  int base2=-1;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y2-1]!='.') base2=j;\n  //cout << base << ' ' << base2 << endl;\n  if(base2==base) return primary(x1,y1,x2,y2);\n\n  int idx=y2-1;\n  while(idx>=y1 && isdigit(in[base2][idx])) --idx;\n  ++idx;\n  int di=digit(base2,idx,base2+1,y2);\n  int pr=primary(x1,y1,x2,idx);\n  //cout << \"pr di \" << pr << ' ' << di << endl;\n  int ret=1;\n  rep(i,di) ret=(ret*pr)%2011;\n  return ret;\n}\n\nint factor(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  //cout << \"factor \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;    \n  int ret;\n  int base;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n\n  if(in[base][y1]=='-' &&\n     y1+1<y2 && in[base][y1+1]=='.')\n    return ((-factor(x1,y1+2,x2,y2))%2011+2011)%2011;\n\n  if(in[base][y1]=='-' &&\n     y1+1<y2 && in[base][y1+1]=='-')\n    return fraction(x1,y1,x2,y2);\n\n  return powexpr(x1,y1,x2,y2);\n}\n\nint term(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int ret;\n  int base;\n  //cout << \"term \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int idx=-1;\n  int pa=0;\n  for(int j=y1;j<y2;++j){\n    if(in[base][j]=='(') ++pa;\n    if(in[base][j]==')') --pa;\n    if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n       in[base][j]=='*' &&\n       in[base][j+1]=='.' && pa==0){\n      idx=j;\n      break;      \n    }\n  }\n  \n  if(idx!=-1) ret=factor(x1,y1,x2,idx-1);\n  else return factor(x1,y1,x2,y2);\n  y1 = idx+1;\n  while(true){\n\n    normal(x1,y1,x2,y2);\n    idx=-1;\n    int pa=0;\n    \n    for(int j=y1;j<y2;++j){\n      if(in[base][j]=='(') ++pa;\n      if(in[base][j]==')') --pa;\n      if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n         in[base][j]=='*' &&\n         in[base][j+1]=='.' && pa==0){\n        idx=j;\n        break;\n      }\n    }\n    \n    if(idx!=-1){\n      int t=factor(x1,y1,x2,idx-1);\n      ret=(ret*t)%2011;\n    }else{\n      int t=factor(x1,y1,x2,y2);\n      ret=(ret*t)%2011;\n      return ret;\n    }\n    y1 = idx+1;\n  }\n  return ret;\n}\n\nint expr(int x1,int y1,int x2,int y2){\n  normal(x1,y1,x2,y2);\n  int ret;\n  int base;\n  /*\n  cout << \"expr \" << x1 << ' ' <<  y1 << ' ' << x2 << ' ' << y2 << endl;\n  for(int i=x1;i<x2;++i){\n    for(int j=y1;j<y2;++j) cout << in[i][j];\n    cout << endl;\n  }\n  */\n  for(int j=x1;j<x2;++j)\n    if(in[j][y1]!='.') base=j;\n  int idx=-1;\n  int pa=0;\n  for(int j=y1;j<y2;++j){\n    if(in[base][j]=='(') ++pa;\n    if(in[base][j]==')') --pa;\n    if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n       (in[base][j]=='+' ||\n        (in[base][j]=='-' &&\n         (j-2>=0 && in[base][j-2]!='*' &&\n          in[base][j-2]!='+' &&\n          (in[base][j-2]!='-' || (j-3>=0 && in[base][j-3]=='-'))))) &&\n       in[base][j+1]=='.' && pa==0){\n      idx=j;\n      break;\n    }\n  }\n  \n  if(idx!=-1) ret=term(x1,y1,x2,idx-1);\n  else return term(x1,y1,x2,y2);\n  y1 = idx+1;\n  while(true){\n    normal(x1,y1,x2,y2);\n    char op=in[base][idx];\n    idx=-1;\n    int pa=0;\n    for(int j=y1;j<y2;++j){\n      if(in[base][j]=='(') ++pa;\n      if(in[base][j]==')') --pa;\n      if(j-1>=y1 && j+1<y2 && in[base][j-1]=='.' &&\n         (in[base][j]=='+' ||\n          (in[base][j]=='-' &&\n           (j-2>=0 && in[base][j-2]!='*' &&\n            in[base][j-2]!='+' &&\n            (in[base][j-2]!='-' || (j-3>=0 && in[base][j-3]=='-'))))) &&\n         in[base][j+1]=='.' && pa==0){\n        idx=j;\n        break;      \n      }\n    }\n    \n    if(idx!=-1){\n      int t=term(x1,y1,x2,idx-1);\n      if(op=='+') ret=(ret+t)%2011;\n      else ret=((ret-t)%2011+2011)%2011;\n    }\n    else{\n      int t=term(x1,y1,x2,y2);\n      //cout << op << ' ' << t << endl;\n      if(op=='+') ret=(ret+t)%2011;\n      else ret=((ret-t)%2011+2011)%2011;\n      return ret;\n    }\n    y1 = idx+1;    \n  }\n  return ret;\n}\n\nvoid solve(){\n  rep(i, n) cin >> in[i];\n  //rep(i, n) cout << in[i] << endl;\n  cout << expr(0,0,n,SZ(in[0])) << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  rep(i,2011)rep(j,2011) if(i*j%2011==1) inv[i]=j;\n  //cout << 4*inv[9] << endl;\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int mod = 2011;\n\nint add(int a, int b) {\n    return (a + b) % mod;\n}\nint mul(int a, int b) {\n    return a * b % mod;\n}\nint inv(int n) {\n    int a = n, b = mod, u = 1, v = 0;\n    while(b) {\n        const int t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    (u += mod) %= mod;\n    return u;\n}\n\nint expr(int& x, int y1, int y2, vector<string> const&);\nint term(int& x, int y1, int y2, vector<string> const&);\nint factor(int& x, int y1, int y2, vector<string> const&);\nint primary(int& x, int y1, int y2, vector<string> const& s);\nint powexpr(int& x, int y1, int y2, vector<string> const& s);\n\nint find_base(int& x, int y1, int y2, vector<string> const& s) {\n    int res = -1;\n    while(res == -1) {\n        assert(\"[base] cannot find base\" && x < (int)s[0].size());\n        for(int y = y1; y < y2; ++y) {\n            if(s[y][x] == '.') continue;\n            res = y;\n            break;\n        }\n        x += (res == -1);\n    }\n    return res;\n}\n\nint digit(int& x, int y1, int y2, vector<string> const& s) {\n    const int base_y = find_base(x, y1, y2, s);\n    assert(isdigit(s[base_y][x]));\n    return s[base_y][x++] - '0';\n}\n\nint expr(int& x, int y1, int y2, vector<string> const& s) {\n    // find base\n    const int base_y = find_base(x, y1, y2, s);\n    auto res = term(x, y1, y2, s);\n    while(x + 1 < (int)s[0].size() && (s[base_y][x + 1] == '-' || s[base_y][x + 1] == '+')) {\n        ++x; // space\n        const char op = s[base_y][x];\n        x += 2;\n        const auto r = term(x, y1, y2, s);\n        if(op == '+')      res = add(res, r);\n        else if(op == '-') res = add(res, mod - r);\n        else assert(\"[expr] invalid op\" && false);\n    }\n    return res;\n}\n\nint term(int& x, int y1, int y2, vector<string> const& s) {\n    const int base_y = find_base(x, y1, y2, s);\n    auto res = factor(x, y1, y2, s);\n    while(x + 1 < (int)s[0].size() && s[base_y][x + 1] == '*') {\n        ++x; // space\n        assert(\"[term] invalid op\" && s[base_y][x] == '*');\n        x += 2; // op\n        res = mul(res, factor(x, y1, y2, s));\n    }\n    return res;\n}\n\nint factor(int& x, int y1, int y2, vector<string> const& s) {\n    const int base_y = find_base(x, y1, y2, s);\n    if(s[base_y][x] == '-' && s[base_y][x + 1] == '-') { // fraction\n        int x1 = x + 1, x2 = x + 1;\n        auto a = expr(x1, y1, base_y, s);\n        auto b = expr(x2, base_y + 1, y2, s);\n        x = max(x1, x2) + 1;\n        return mul(a, inv(b));\n    } else if(s[base_y][x] == '-') { // neg\n        x += 2;\n        return mul(factor(x, y1, y2, s), 2010);\n    } else {\n        return powexpr(x, y1, y2, s);\n    }\n}\n\n// primary is in\nint powexpr(int& x, int y1, int y2, vector<string> const& s) {\n    const int base_y = find_base(x, y1, y2, s);\n    int res = 1;\n    if(s[base_y][x] == '(') {\n        x += 2;\n        res = expr(x, y1, y2, s);\n        x += 2; // \".)\"\n    } else {\n        assert(isdigit(s[base_y][x]));\n        res = digit(x, base_y, base_y + 1, s);\n    }\n    if(base_y != 0 && isdigit(s[base_y - 1][x])) { // power\n        int cnt = digit(x, base_y - 1, base_y, s);\n        int t = 1;\n        while(--cnt >= 0) {\n            t = mul(t, res);\n        }\n        res = t;\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> s(n);\n        for(auto& ss : s) cin >> ss;\n        int p = 0;\n        cout << expr(p, 0, n, s) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nconstexpr intmax_t MOD=2011;\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return (lhs + rhs) % MOD;\n  case '-': return ((lhs - rhs) % MOD + MOD) % MOD;\n  case '*': return (lhs * rhs) % MOD;\n  }\n  assert(false);\n}\n\nintmax_t modpow(intmax_t base, intmax_t iexp) {\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1) (res *= dbl) %= MOD;\n    (dbl *= dbl) %= MOD;\n  }\n  return res;\n}\n\nintmax_t moddiv(intmax_t num, intmax_t den) {\n  intmax_t div=modpow(den, MOD-2);\n  return num*div % MOD;\n}\n\nintmax_t parse(const std::vector<std::string> &s, size_t &i,\n               size_t top, size_t bottom, size_t left, size_t right,\n               size_t preced=0, size_t base=-1,\n               const std::vector<std::string> &ops={\"+-\", \"*\"}) {\n\n  while (base+1 == 0) {\n    for (size_t r=top; r<bottom; ++r) {\n      if (s[r][i] != '.') {\n        base = r;\n        break;\n      }\n    }\n    if (base+1 == 0) ++i;\n  }\n  assert(base+1 != 0);\n\n  if (preced == ops.size()) {\n    intmax_t res=114514;\n    if (s[base][i] == '(') {\n      res = parse(s, i+=2, top, bottom, left, right, 0, base);\n      assert(s[base][i] == ')');\n      ++i;\n    } else if (s[base][i] == '-') {\n      if (s[base][i+1] == '-') {\n        size_t vl=i, vr=i+1;\n        while (s[base][++vr] == '-') {}\n\n        size_t j=vl+1;\n        intmax_t numer=parse(s, j, top, base, vl, vr, 0);\n        j = vl+1;\n        intmax_t denom=parse(s, j, base+1, bottom, vl, vr, 0);\n        res = moddiv(numer, denom);\n        i = vr;\n      } else {\n        res = MOD-parse(s, i+=2, top, bottom, left, right, preced, base);\n        return res;\n      }\n    } else if (isdigit(s[base][i])) {\n      res = s[base][i]-'0';\n      ++i;\n    } else {\n      assert(false);\n    }\n\n    if (i < right && top+1 <= base && isdigit(s[base-1][i])) {\n      res = modpow(res, s[base-1][i]-'0');\n      ++i;\n    }\n    ++i;\n    return res;\n  }\n\n  intmax_t lhs=parse(s, i, top, bottom, left, right, preced+1, base);\n  while (i < right) {\n    char op=s[base][i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t rhs=parse(s, i+=2, top, bottom, left, right, preced+1, base);\n    lhs = apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s;\n  for (size_t i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s.emplace_back(buf);\n  }\n\n  size_t i=0;\n  intmax_t res=parse(s, i, 0, s.size(), 0, s[0].length());\n  printf(\"%jd\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstatic int INV[2011] = { 0 };\n\nint mod(int x){\n\twhile(x < 0){ x += 2011; }\n\treturn x % 2011;\n}\n\nstruct Result {\n\tint p, v;\n};\n\n#define PARSER_DECL(name) \\\n\tResult name ( \\\n\t\tconst vector<string> &s, int left, int top, int right, int bottom)\n\nPARSER_DECL(expr);\nPARSER_DECL(term);\nPARSER_DECL(factor);\nPARSER_DECL(powexpr);\nPARSER_DECL(primary);\nPARSER_DECL(fraction);\nPARSER_DECL(digit);\n\nint calculateBase(\n\tconst vector<string> &s, int left, int top, int right, int bottom)\n{\n\tfor(int i = left; i < right; ++i){\n\t\tfor(int j = top; j < bottom; ++j){\n\t\t\tif(s[j][i] != '.'){ return j; }\n\t\t}\n\t}\n\treturn -1;\n}\n\nPARSER_DECL(expr){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tResult r = term(s, left, top, right, bottom);\n\tint next = r.p + 1;\n\twhile(next < right && (s[base][next] == '+' || s[base][next] == '-')){\n\t\tr.p += 3;\n\t\tResult q = term(s, r.p, top, right, bottom);\n\t\tif(s[base][next] == '+'){\n\t\t\tr.v = mod(r.v + q.v);\n\t\t}else{\n\t\t\tr.v = mod(r.v - q.v);\n\t\t}\n\t\tr.p = q.p;\n\t\tnext = q.p + 1;\n\t}\n\treturn r;\n}\nPARSER_DECL(term){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tResult r = factor(s, left, top, right, bottom);\n\tint next = r.p + 1;\n\twhile(next < right && s[base][next] == '*'){\n\t\tr.p += 3;\n\t\tResult q = factor(s, r.p, top, right, bottom);\n\t\tr.v = mod(r.v * q.v);\n\t\tr.p = q.p;\n\t\tnext = q.p + 1;\n\t}\n\treturn r;\n}\nPARSER_DECL(factor){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tint numNeg = 0, p = left;\n\twhile(s[base][p] == '-' && s[base][p + 1] == '.'){\n\t\t++numNeg;\n\t\tp += 2;\n\t}\n\tif(s[base][p] == '-'){\n\t\tResult r = fraction(s, p, top, right, bottom);\n\t\tif(numNeg % 2 == 1){ r.v = mod(-r.v); }\n\t\treturn r;\n\t}else{\n\t\tResult r = powexpr(s, p, top, right, bottom);\n\t\tif(numNeg % 2 == 1){ r.v = mod(-r.v); }\n\t\treturn r;\n\t}\n}\nPARSER_DECL(powexpr){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tResult r = primary(s, left, top, right, bottom);\n\tif(base > 0 && r.p < right && isdigit(s[base - 1][r.p])){\n\t\tResult q = digit(s, r.p, top, right, bottom);\n\t\tint v = 1;\n\t\tfor(int i = 0; i < q.v; ++i){ v = mod(v * r.v); }\n\t\tr.v = v;\n\t\tr.p = q.p;\n\t}\n\treturn r;\n}\nPARSER_DECL(primary){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tif(isdigit(s[base][left])){\n\t\tResult r = digit(s, left, top, right, bottom);\n\t\treturn r;\n\t}else{\n\t\tResult r = expr(s, left + 2, top, right, bottom);\n\t\tr.p += 2;\n\t\treturn r;\n\t}\n}\nPARSER_DECL(fraction){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tint length = 0;\n\tfor(int i = left; i < right; ++i, ++length){\n\t\tif(s[base][i] != '-'){ break; }\n\t}\n\tint upperBegin = left;\n\tfor(int i = 0; i < length; ++i, ++upperBegin){\n\t\tbool flag = false;\n\t\tfor(int j = top; j < base; ++j){\n\t\t\tflag = flag || (s[j][upperBegin] != '.');\n\t\t}\n\t\tif(flag){ break; }\n\t}\n\tint lowerBegin = left;\n\tfor(int i = 0; i < length; ++i, ++lowerBegin){\n\t\tbool flag = false;\n\t\tfor(int j = base + 1; j < bottom; ++j){\n\t\t\tflag = flag || (s[j][lowerBegin] != '.');\n\t\t}\n\t\tif(flag){ break; }\n\t}\n\tResult upper = expr(s, upperBegin, top, right, base);\n\tResult lower = expr(s, lowerBegin, base + 1, right, bottom);\n\tResult r;\n\tr.v = mod(upper.v * INV[lower.v]);\n\tr.p = left + length;\n\treturn r;\n}\nPARSER_DECL(digit){\n\tint base = calculateBase(s, left, top, right, bottom);\n\tResult r;\n\tr.v = s[base][left] - '0';\n\tr.p = left + 1;\n\treturn r;\n}\n\nint main(){\n\tfor(int y = 1; y < 2011; ++y){\n\t\tfor(int z = 1; z < 2011; ++z){\n\t\t\tif(z * y % 2011 == 1){ INV[y] = z; }\n\t\t}\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tvector<string> s(n);\n\t\tfor(int i = 0; i < n; ++i){ cin >> s[i]; }\n\t\tResult r = expr(s, 0, 0, s[0].size(), n);\n\t\tcout << r.v << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(size_t i=(a);i<(size_t)(b);i++)\nusing namespace std;\n\nconst int mod = 2011;\nvector<string> s;\nvector<int> inv(mod,1);\n\ninline void remove_space(size_t &l, size_t &t, size_t &r, size_t &b){\n  for(bool f=true;l<r;l++){FOR(i,t,b)f &= (s[i][l]=='.');   if(!f)break;}\n  for(bool f=true;l<r;r--){FOR(i,t,b)f &= (s[i][r-1]=='.'); if(!f)break;}\n  for(bool f=true;t<b;t++){FOR(i,l,r)f &= (s[t][i]=='.');   if(!f)break;}\n  for(bool f=true;t<b;b--){FOR(i,l,r)f &= (s[b-1][i]=='.'); if(!f)break;}\n}\n\nint expr(size_t &l, size_t &t, size_t &r, size_t &b);\n\nint fraction(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"fraction: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  size_t ll = l+1, rr = l+1;\n  while(++rr < r && s[base][rr]=='-');\n  l = rr; rr--;\n\n  size_t ul = ll, ur = rr, dl = ll, dr = rr;\n  size_t ut = t, ub = base, dt = base+1, db = b;\n  int A = expr(ul,ut,ur,ub), B = expr(dl,dt,dr,db);\n  //cout << A << \" \" << B << endl;\n  int tmp = A * inv[B] % mod; \n  //cout << tmp << endl;\n  return tmp;\n}\n\nint primary(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"primary: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n  if(isdigit(s[base][l]))return s[base][l++]-'0';\n\n  l+=2;\n  int res = expr(l,t,r,b);\n  l+=2;\n  return res;\n}\n\n\nint powexpr(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"powexpr: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  int res = primary(l,t,r,b);\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  if(l<r && isdigit(s[base][l])){\n    int p = s[base][l]-'0';\n    l++;\n    int tmp = res; res = 1;\n    while(p--) (res *= tmp) %= mod;\n  }\n  return res;\n}\n\nint factor(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"factor: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  //remove_space(l,t,r,b);\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  if(s[base][l] == '-'){\n    if(s[base][l+1] == '.'){\n      l+=2;\n      return mod - factor(l,t,r,b);\n    }else return fraction(l,t,r,b);\n  }\n\n  return powexpr(l,t,r,b);\n}\n\nint term(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"term: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  //remove_space(l,t,r,b);\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  int res = factor(l,t,r,b);\n  //cout << \"term \" << l << endl;\n  while(l+1<r && s[base][l+1]=='*'){\n    l+=3;\n    res = (res * factor(l,t,r,b)) % mod;\n    //cout << \"term \" << l << endl;\n  }\n  return res;\n}\n\nint expr(size_t &l, size_t &t, size_t &r, size_t &b){\n  //cout << \"expr: \" <<  l << \" \" << t << \" \" << r << \" \" << b << endl;\n  assert(l<r);\n  remove_space(l,t,r,b);\n  size_t base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  int res = term(l,t,r,b);\n  //cout << l << endl;\n  while(l+1<r && (s[base][l+1]=='+' || s[base][l+1]=='-')){\n    l+=3;\n    if(s[base][l-2]=='+')res = (res + term(l,t,r,b)) % mod;\n    else if(s[base][l-2]=='-')res = (res - term(l,t,r,b) + mod) % mod;\n    //cout << l << endl;\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(); ios::sync_with_stdio(0);\n  FOR(i,2,mod)inv[i] = (mod - mod/i) * inv[mod%i] % mod;\n  //cout << inv[4] << endl;\n\n  int n;\n  while(cin>>n,n){\n    s.resize(n);\n    FOR(i,0,n)cin >> s[i];\n\n    size_t l = 0, t = 0, r = s[0].size(), b = n;\n    cout << expr(l,t,r,b) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#error \"tsurai\"\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nconstexpr intmax_t MOD=2011;\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return (lhs + rhs) % MOD;\n  case '-': return ((lhs - rhs) % MOD + MOD) % MOD;\n  case '*': return (lhs * rhs) % MOD;\n  }\n  assert(false);\n}\n\nintmax_t modpow(intmax_t base, intmax_t iexp) {\n  fprintf(stderr, \"%jd^%jd\\n\", base, iexp);\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1) (res *= dbl) %= MOD;\n    (dbl *= dbl) %= MOD;\n  }\n  return res;\n}\n\nintmax_t moddiv(intmax_t num, intmax_t den) {\n  intmax_t div=modpow(den, MOD-2);\n  return num*div % MOD;\n}\n\nintmax_t parse(const std::vector<std::string> &s, size_t &i,\n               size_t top, size_t bottom, size_t left, size_t right,\n               size_t preced=0, size_t base=-1,\n               const std::vector<std::string> &ops={\"+-\", \"*\"}) {\n\n  while (base+1 == 0) {\n    for (size_t r=top; r<bottom; ++r) {\n      if (s[r][i] != '.') {\n        base = r;\n        break;\n      }\n    }\n    if (base+1 == 0) ++i;\n  }\n  assert(base+1 != 0);\n  fprintf(stderr, \"s[%zu]: LR[%zu, %zu), TB[%zu, %zu), base:%zu, prec:%zu\\n\",\n          i, left, right, top, bottom, base, preced);\n\n  if (preced == ops.size()) {\n    intmax_t res=114514;\n    if (s[base][i] == '(') {\n      res = parse(s, i+=2, top, bottom, left, right, 0, base);\n      assert(s[base][i] == ')');\n      ++i;\n    } else if (s[base][i] == '-') {\n      if (s[base][i+1] == '-') {\n        size_t vl=i, vr=i+1;\n        while (s[base][++vr] == '-') {}\n\n        size_t j=left+1;\n        intmax_t numer=parse(s, j, top, base, vl, vr, 0);\n        j = left+1;\n        intmax_t denom=parse(s, j, base+1, bottom, vl, vr, 0);\n        res = moddiv(numer, denom);\n        i = vr+1;\n      } else {\n        res = -parse(s, i+=2, top, bottom, left, right, preced, base);\n      }\n    } else if (isdigit(s[base][i])) {\n      res = s[base][i]-'0';\n      ++i;\n    }\n\n    if (i+1 < right && top+1 <= base && isdigit(s[base-1][i+1])) {\n      fprintf(stderr, \"s[%zu][%zu]: %c\\n\", base-1, i+1, s[base-1][i+1]);\n      fprintf(stderr, \"%jd^%jd\\n\", res, intmax_t(s[base-1][i+1]-'0'));\n      res = modpow(res, s[base-1][i+1]-'0');\n      ++i;\n    }\n    ++i;\n    fprintf(stderr, \"Returns %jd\\n\", res);\n    return res;\n  }\n\n  intmax_t lhs=parse(s, i, top, bottom, left, right, preced+1, base);\n  while (i < right) {\n    char op=s[base][i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t rhs=parse(s, i+=2, top, bottom, left, right, preced+1, base);\n    lhs = apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s;\n  for (size_t i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s.emplace_back(buf);\n  }\n\n  size_t i=0;\n  intmax_t res=parse(s, i, 0, s.size(), 0, s[0].length());\n  printf(\"%jd\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 2011;\nint pow(int n, int m){\n\tint res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nint inv(int n){\n\treturn pow(n, mod - 2);\n}\n\nint n;\nstring in[20];\nint expr(int&, int&, int&, int&);\n\n\nint f(int y, int x, int Y, int X){\n\tint res = -1;\n\tfor(int i = y; i < Y; i++) if(in[i][x] != '.'){\n\t\tres = res == -1 ? i : -2;\n\t}\n\treturn res;\n}\nint powexpr(int &y, int &x, int &Y, int &X){\n\tint p, res;\n\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\tif(in[p][x] == '('){\n\t\tx++;\n\t\tres = expr(y, x, Y, X);\n\t\tassert(in[p][x] == ')');\n\t\tx++;\n\t}\n\telse{\n\t\tres = 0;\n\t\twhile(x < X && isdigit(in[p][x])) res *= 10, res += in[p][x++] - '0';\n\t}\n\tif(x < X){\n\t\tp = f(y, x, Y, X);\n\t\tif(p >= 0){\n\t\t\tint e = 0;\n\t\t\twhile(x < X && isdigit(in[p][x])) e *= 10, e += in[p][x++] - '0';\n\t\t\tres = pow(res, e);\n\t\t}\n\t}\n\treturn res;\n}\nint factor(int &y, int &x, int &Y, int &X){\n\tint p;\n\tbool sign = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(in[p][x] == '-' && in[p][x + 1] == '.') sign ^= 1, x += 2;\n\t\telse break;\n\t}\n\tif(in[p][x] == '-' && in[p][x + 1] == '-'){\n\t\tint q = x;\n\t\twhile(q < X && in[p][q] == '-') q++;\n\t\t\n\t\tint a = y, b = x + 1, c = p, d = q - 1;\n\t\tint num = expr(a, b, c, d);\n\t\t\n\t\ta = p + 1, b = x + 1, c = Y, d = q - 1;\n\t\tint den = expr(a, b, c, d);\n\t\t\n\t\tnum = num * inv(den) % mod;\n\t\tx = q + 1;\n\t\treturn sign ? (mod - num) % mod : num;\n\t}\n\treturn ((sign ? -1 : 1) * powexpr(y, x, Y, X) % mod + mod) % mod;\n}\nint term(int &y, int &x, int &Y, int &X){\n\tint res = inf, p;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = factor(y, x, Y, X);\n\t\tres = res == inf ? a : (a * res) % mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || in[p][x] != '*') break;\n\t\tx++;\n\t}\n\treturn res;\n}\nint expr(int &y, int &x, int &Y, int &X){\n\tint res = 0, p, op = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = term(y, x, Y, X);\n\t\t(res += op ? mod - a : a) %= mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || in[p][x] != '+' && in[p][x] != '-') break;\n\t\top = in[p][x] == '-';\n\t\tx++;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> in[i];\n\t\tint y = 0, x = 0, Y = n, X = in[0].size();\n\t\tcout << expr(y, x, Y, X) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define REP(i,x,n) for(int i=x;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int mod=2011;\n\npii expr(int,int,int,int);\npii term(int,int,int,int);\npii factor(int,int,int,int);\npii powexpr(int,int,int,int);\npii primary(int,int,int,int);\n\nint H,W;\nchar field[30][100];\n\nll mod_pow(ll num,ll p,ll mod){\n  ll mul=num;\n  ll res=1;\n  while(p){\n    if(p%2)res=(res*mul)%mod;\n    p/=2;\n    mul=(mul*mul)%mod;\n  }\n  return res;\n}\nll div_mod(ll num,ll mod){\n  return mod_pow(num,mod-2,mod);\n}\n\npii expr(int miny,int minx,int maxy,int maxx){\n  for(int x=minx;x<=maxx;x++){\n    bool flg=false;\n    for(int y=miny;y<=maxy;y++){\n      if(field[y][x]!='.'){\n        flg=true;\n      }\n    }\n    if(flg)break;\n    minx++;\n  }\n  pii res=term(miny,minx,maxy,maxx);\n  minx=res.second;\n  if(minx<=maxx){\n    while(minx<=maxx){\n      minx++;\n      bool no=false;\n      for(int y=miny;y<=maxy;y++){\n        if(field[y][minx]=='+'){\n          minx+=2;\n          pii p=term(miny,minx,maxy,maxx);\n          res.first+=p.first;\n          res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(field[y][minx]=='-'&&field[y][minx+1]!='-'){\n          minx+=2;\n          pii p=term(miny,minx,maxy,maxx);\n          res.first-=p.first;\n          res.first+=mod;\n          res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(y==maxy){\n          no=true;\n          break;\n        }\n      }\n      if(no){\n        minx--;\n        break;\n      }\n    }\n  }\n  return pii(res.first,minx);\n}\npii term(int miny,int minx,int maxy,int maxx){\n  pii res=factor(miny,minx,maxy,maxx);\n  minx=res.second;\n  if(minx<=maxx){\n    while(minx<=maxx){\n      minx++;\n      bool no=false;\n      for(int y=miny;y<=maxy;y++){\n        if(field[y][minx]=='*'){\n          minx+=2;\n          pii p=factor(miny,minx,maxy,maxx);\n          res.first*=p.first;res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(y==maxy){\n          no=true;\n          break;\n        }\n      }\n      if(no){\n        minx--;\n        break;\n      }\n    }\n  }\n  return pii(res.first,minx);\n}\npii factor(int miny,int minx,int maxy,int maxx){\n  pii res(1,1);\n  for(int y=miny;y<=maxy;y++){\n    if(field[y][minx]=='-'\n       &&field[y][minx+1]=='.'){\n      minx+=2;\n      pii p=factor(miny,minx,maxy,maxx);\n      p.first*=-1;\n      p.first+=mod;\n      p.first%=mod;\n      minx=p.second;\n      return pii(p.first,minx);\n    }\n  }\n  // fraction\n  for(int y=miny;y<=maxy;y++){\n    // found\n    if(field[y][minx]=='-'&&field[y][minx+1]=='-'){\n      int pos=-1;\n      for(int i=minx;i<=maxx;i++){\n        if(field[y][i]!='-'){\n          pos=i;\n          break;\n          // const int from=minx+1;\n          // const int to=i-2;\n          // pii p1=expr(miny,from,y-1,to);\n          // pii p2=expr(y+1,from,maxy,to);\n          // return pii((p1.first*div_mod(p2.first,mod))%mod,i);\n        }\n      }\n      if(pos==-1)pos=maxx+1;\n      const int from=minx+1;\n      const int to=pos-2;\n      pii p1=expr(miny,from,y-1,to);\n      pii p2=expr(y+1,from,maxy,to);\n      return pii((p1.first*div_mod(p2.first,mod))%mod,pos);\n    }\n  }\n  // powexpr\n  return powexpr(miny,minx,maxy,maxx);\n}\npii powexpr(int miny,int minx,int maxy,int maxx){\n  pii res=primary(miny,minx,maxy,maxx);\n  minx=res.second;\n  int mul=res.first;\n  res.first=1;\n  bool found=false;\n  for(int y=miny;y<=maxy;y++)\n    if(isdigit(field[y][minx])){\n      for(int i=0;i<field[y][minx]-'0';i++){\n        res.first*=mul;\n        res.first%=mod;\n      }\n      minx++;\n      found=true;\n      break;\n    }\n  if(!found)res.first=mul;\n  return pii(res.first,minx);\n}\n\npii primary(int miny,int minx,int maxy,int maxx){\n  pii res;\n  for(int y=miny;y<=maxy;y++)\n    if(isdigit(field[y][minx])){\n      res.first=field[y][minx]-'0';\n      return pii(res.first,minx+1);\n    }\n  // par\n  minx+=2;\n  res=expr(miny,minx,maxy,maxx);\n  minx=res.second+2;\n  return pii(res.first,minx);\n}\n\nint main(){\n  ifstream cin(\"in.txt\");\n  while(cin>>H&&H){\n    rep(i,H){\n      cin>>field[i];\n      W=strlen(field[i]);\n    }\n    cout<<expr(0,0,H-1,W-1).first<<endl;\n    //cout<<(mod-(3*div_mod(4,mod))%mod)%mod<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n// #include<cassert>\nusing namespace std;\n\nconst int rhl = 2011,maxn = 90;\nchar S[maxn][maxn]; int N,M,inv[rhl];\n\ninline void assert(bool sg) { if (!sg) while (true); }\n\ninline int qsm(int a,int b)\n{\n\tassert(b>=0);\n\tint ret = 1;\n\tfor (;b;b >>= 1,(a *= a) %= rhl) if (b&1) (ret *= a) %= rhl;\n\treturn ret;\n}\n\ninline int gi()\n{\n\tchar ch; int ret = 0,f = 1,ts = 0;\n\tdo ch = getchar(),assert(++ts <= 1000);while (!(ch >= '0'&&ch <= '9')&&ch != '-');\n\tif (ch == '-') f = -1,ch = getchar(),assert(++ts <= 1000);;\n\tdo ret = ret*10+ch-'0',ch = getchar(),assert(++ts <= 1000); while (ch >= '0'&&ch <= '9');\n\treturn ret*f;\n}\n\ninline int get_expr(int,int,int,int);\ninline int get_term(int,int,int,int);\ninline int get_factor(int,int,int,int);\ninline int get_powexpr(int,int,int,int);\ninline int get_frac(int,int,int,int);\n\ninline bool is_minus(int a,int b)\n{\n\tif (S[a][b] != '-') return false;\n\tif (b-1&&S[a][b-1] == '-') return false;\n\tif (b+1 <= M&&S[a][b+1] == '-') return false;\n\tif (a-1&&S[a-1][b] >= '0'&&S[a-1][b] <= '9') return false;\n\treturn true;\n}\n\ninline bool nonex(int a,int Y1,int Y2)\n{\n\t// assert(Y1<=Y2);\n\tfor (int i = Y1;i <= Y2;++i)\n\t\tif (S[a][i] != '.') return false;\n\treturn true;\n}\ninline bool noney(int X1,int X2,int a)\n{\n\t// assert(X1<=X2);\n\tfor (int i = X1;i <= X2;++i)\n\t\tif (S[i][a] != '.') return false;\n\treturn true;\n}\n\ninline int get_expr(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\t// assert(X1 <= X2&&Y1 <= Y2);\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,loc,pcnt = 0,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\t// assert(base <= X2);\n\tfor (loc = Y2;loc >= Y1;--loc)\n\t{\n\t\tif (S[base][loc] == ')') ++pcnt;\n\t\telse if (S[base][loc] == '(') --pcnt;\n\t\telse if (!pcnt)\n\t\t{\n\t\t\tif (S[base][loc] == '+') break;\n\t\t\telse if (is_minus(base,loc)&&!(loc-2<Y1||S[base][loc-2] == '*'||S[base][loc-2] == '-')) break;\n\t\t}\n\t}\n\tif (loc == Y1-1) ret = get_term(X1,Y1,X2,Y2);\n\telse if (S[base][loc] == '+') ret = get_expr(X1,Y1,X2,loc-2)+get_term(X1,loc+2,X2,Y2);\n\telse ret = get_expr(X1,Y1,X2,loc-2)-get_term(X1,loc+2,X2,Y2);\n\tif (ret >= rhl) ret -= rhl; if (ret < 0) ret += rhl; return ret;\t\n}\n\ninline int get_term(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tassert(X1 <= X2&&Y1 <= Y2);\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,loc,pcnt = 0,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\t// assert(base <= X2);\n\tfor (loc = Y2;loc >= Y1;--loc)\n\t{\n\t\tif (S[base][loc] == ')') ++pcnt;\n\t\telse if (S[base][loc] == '(') --pcnt;\n\t\telse if (!pcnt&&S[base][loc] == '*') break;\n\t}\n\tif (loc == Y1-1) ret = get_factor(X1,Y1,X2,Y2);\n\telse ret = get_term(X1,Y1,X2,loc-2)*get_factor(X1,loc+2,X2,Y2);\n\tif (ret >= rhl) ret %= rhl; return ret;\n}\n\ninline int get_factor(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tassert(X1 <= X2&&Y1 <= Y2);\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\t// assert(base <= X2);\t\n\tif (S[base][Y1] == '-')\n\t{\n\t\tif (Y2 > Y1&&S[base][Y1+1] == '.')\n\t\t\tret = -get_factor(X1,Y1+2,X2,Y2);\n\t\telse ret = get_frac(X1,Y1,X2,Y2);\n\t}\n\telse ret = get_powexpr(X1,Y1,X2,Y2);\n\tif (ret < 0) ret += rhl; return ret;\t\n}\n\ninline int get_frac(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tassert(X1 <= X2&&Y1 <= Y2);\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1,ret; while (base <= X2&&S[base][Y1] == '.') ++base;\n\t// assert(base <= X2);\n\tret = get_expr(X1,Y1+1,base-1,Y2-1)*inv[get_expr(base+1,Y1+1,X2,Y2-1)];\n\tif (ret >= rhl) ret %= rhl;\n\treturn ret;\n}\n\ninline int get_powexpr(int X1,int Y1,int X2,int Y2)\n{\n\twhile (X1 <= X2&&nonex(X1,Y1,Y2)) ++X1; while (X1 <= X2&&nonex(X2,Y1,Y2)) --X2;\n\twhile (Y1 <= Y2&&noney(X1,X2,Y1)) ++Y1; while (Y1 <= Y2&&noney(X1,X2,Y2)) --Y2;\n\tassert(X1 <= X2&&Y1 <= Y2);\n\tif (X1 > X2||Y1 > Y2) return 0;\n\tint base = X1; while (base <= X2&&S[base][Y1] == '.') ++base;\n\t// assert(base <= X2);\t\n\tif (S[base][Y1] == '(')\n\t{\n\t\tif (S[base][Y2] == ')') return get_expr(X1,Y1+2,X2,Y2-2);\n\t\telse\n\t\t{\n\t\t\tassert(S[base-1][Y2] >= '0'&&S[base-1][Y2] <= '9');\n\t\t\treturn qsm(get_expr(X1,Y1+2,X2,Y2-3),S[base-1][Y2]-'0');\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (S[base][Y2] == '.')\n\t\t{\n\t\t\tassert(S[base][Y1] >= '0'&&S[base][Y1] <= '9');\n\t\t\tassert(S[base-1][Y2] >= '0'&&S[base-1][Y2] <= '9');\n\t\t\treturn qsm(S[base][Y1]-'0',S[base-1][Y2]-'0');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(S[base][Y1] >= '0'&&S[base][Y1] <= '9');\n\t\t\treturn S[base][Y1]-'0';\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinv[1] = 1;\n\tfor (int i = 2;i < rhl;++i)\n\t{\n\t\tinv[i] = -(rhl/i)*inv[rhl%i]%rhl;\n\t\tif (inv[i] < 0) inv[i] += rhl;\n\t}\n\twhile (true)\n\t{\n\t\tN = gi(); if (!N) break;\n\t\tfor (int i = 1;i <= N;++i) scanf(\"%s\",S[i]+1);\n\t\tM = strlen(S[1]+1);\n\t\tprintf(\"%d\\n\",get_expr(1,1,N,M));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 2011;\nint pow(int n, int m){\n\tint res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nint inv(int n){\n\treturn pow(n, mod - 2);\n}\n\nint n;\nstring in[20];\nint expr(int&, int&, int&, int&);\n\n\nint f(int y, int x, int Y, int X){\n\tint res = -1;\n\tfor(int i = y; i < Y; i++) if(in[i][x] != '.'){\n\t\tres = res == -1 ? i : -2;\n\t}\n\treturn res;\n}\nint powexpr(int &y, int &x, int &Y, int &X){\n\tint p, res;\n\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\tif(in[p][x] == '('){\n\t\tx++;\n\t\tres = expr(y, x, Y, X);\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tassert(in[p][x] == ')');\n\t\tx++;\n\t}\n\telse{\n\t\tres = 0;\n\t\twhile(x < X && isdigit(in[p][x])) res *= 10, res += in[p][x++] - '0';\n\t}\n\tif(x < X){\n\t\tp = f(y, x, Y, X);\n\t\tif(p >= 0){\n\t\t\tint e = 0;\n\t\t\twhile(x < X && isdigit(in[p][x])) e *= 10, e += in[p][x++] - '0';\n\t\t\tres = pow(res, e);\n\t\t}\n\t}\n\treturn res;\n}\nint factor(int &y, int &x, int &Y, int &X){\n\tint p;\n\tbool sign = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(in[p][x] == '-' && in[p][x + 1] == '.') sign ^= 1, x += 2;\n\t\telse break;\n\t}\n\tif(in[p][x] == '-' && in[p][x + 1] == '-'){\n\t\tint q = x;\n\t\twhile(q < X && in[p][q] == '-') q++;\n\t\t\n\t\tint a = y, b = x + 1, c = p, d = q - 1;\n\t\tint num = expr(a, b, c, d);\n\t\t\n\t\ta = p + 1, b = x + 1, c = Y, d = q - 1;\n\t\tint den = expr(a, b, c, d);\n\t\t\n\t\tnum = num * inv(den) % mod;\n\t\tx = q + 1;\n\t\treturn sign ? (mod - num) % mod : num;\n\t}\n\treturn ((sign ? -1 : 1) * powexpr(y, x, Y, X) % mod + mod) % mod;\n}\nint term(int &y, int &x, int &Y, int &X){\n\tint res = inf, p;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = factor(y, x, Y, X);\n\t\tres = res == inf ? a : (a * res) % mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || in[p][x] != '*') break;\n\t\tx++;\n\t}\n\treturn res;\n}\nint expr(int &y, int &x, int &Y, int &X){\n\tint res = 0, p, op = 0;\n\twhile(1){\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tint a = term(y, x, Y, X);\n\t\t(res += op ? mod - a : a) %= mod;\n\t\tp = 0;\n\t\twhile(x < X && (p = f(y, x, Y, X)) < 0) x++;\n\t\tif(p < 0 || in[p][x] != '+' && in[p][x] != '-') break;\n\t\top = in[p][x] == '-';\n\t\tx++;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\trep(i, n) cin >> in[i];\n\t\tint y = 0, x = 0, Y = n, X = in[0].size();\n\t\tcout << expr(y, x, Y, X) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\n\n\nconst int mod = 2011;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nvector<string>sts;\nint a;\n\nMod getexpr(const int top, const int bot, const int base, const int left);\nMod getprim(const int top, const int bot, const int base, const int left) {\n\tif (sts[base][left] == '(') {\n\t\ta += 2;\n\t\tMod exp = getexpr(top, bot, base, left + 2);\n\t\tassert(sts[base][a] == ')');\n\t\ta += 2;\n\t\treturn exp;\n\t}\n\telse {\n\t\tMod dig = sts[base][left]-'0';\n\t\ta += 2;\n\t\treturn dig;\n\t}\n}\npair<int, int>getlb(const int top, const int bot, const int left) {\n\tfor (int x = left; x < sts[0].size(); ++x) {\n\t\tbool flag = false;\n\t\tfor (int y = top; y <=bot; ++y) {\n\t\t\tif (sts[y][x] != '.') {\n\t\t\t\treturn make_pair(x, y);\n\t\t\t}\n\t\t}\n\t}\n}\nMod getfrac(const int top, const int bot, const int base, const int left) {\n\tMod bo, si;\n\t{\n\t\tauto p = getlb(top, base - 1, left);\n\t\tint l = p.first;\n\t\tint b = p.second;\n\t\ta = l;\n\t\tsi = getexpr(top, base - 1, b, l);\n\t}\n\t{\n\t\tauto p = getlb(base+1, bot, left);\n\t\tint l = p.first;\n\t\tint b = p.second;\n\t\ta = l;\n\t\tbo = getexpr(base+1,bot, b, l);\n\t}\n\twhile (sts[base][a] == '-')a++;\n\ta++;\n\treturn si / bo;\n}\nMod getpowx(const int top, const int bot, const int base, const int left) {\n\tMod prim(getprim(top, bot, base, left));\n\tif (top != base&&isdigit(sts[base-1][a-1])) {\n\t\tprim = mod_pow(prim, sts[base - 1][a - 1] - '0');\n\t\ta++;\n\t}\n\treturn prim;\n}\nMod getfact(const int top, const int bot, const int base,const int left) {\n\tif (sts[base][left] == '-'&&sts[base][left + 1] == '-') {\n\t\treturn getfrac(top, bot, base, left);\n\t}\n\telse if (sts[base][left] == '-') {\n\t\ta += 2;\n\t\tMod fact = getfact(top, bot, base, a);\n\t\treturn -fact;\n\t}\n\telse {\n\t\treturn getpowx(top, bot, base, left);\n\t}\n}\nMod getterm(const  int top, const  int bot,  int base, int left) {\n\t\n\tMod fact = getfact(top, bot, base,left);\n\twhile (a < sts[base].size()) {\n\t\tchar ch(sts[base][a]);\n\t\tif (ch == ')'||ch=='.')break;\n\t\telse if (ch == '+'||ch=='-') {\n\t\t\tbreak;\n\t\t}\n\t\telse if (ch == '*') {\n\t\t\ta += 2;\n\t\t\tMod next_fact = getfact(top, bot, base, a);\n\t\t\tfact *= next_fact;\n\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn fact;\n}\nMod getexpr(const int top, const int bot, const int base,const int left) {\n\tMod term = getterm(top, bot, base,left);\n\twhile (a <  sts[base].size()) {\n\t\tchar ch(sts[base][a]);\n\t\tif (ch == ')' || ch == '.')break;\n\t\telse if (ch == '+') {\n\t\t\ta += 2;\n\t\t\tMod next_term = getterm(top, bot, base, a);\n\t\t\tterm += next_term;\n\t\t}\n\t\telse if (ch == '-') {\n\t\t\ta += 2;\n\t\t\tMod next_term = getterm(top, bot, base, a);\n\t\t\tterm -= next_term;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn term;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tsts.clear();\n\t\tsts.resize(N);\n\t\tstring st;\n\t\tgetline(cin, st);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tgetline(cin, sts[i]);\n\t\t}\n\t\tauto p = getlb(0, N-1, 0);\n\t\tint l = p.first;\n\t\tint b = p.second;\n\t\ta = l;\n\t\tMod ans = getexpr(0, N - 1, b, l);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 2011;\n\nint parseArea(vector<string> &vs, int top, int bottom, int left, int right);\nint parseExpr(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\nint parseTerm(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\nint parseFactor(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\nint parsePowexpr(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\nint parsePrimary(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\nint parseFraction(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right);\n\nint modpow(int a, int p){\n\tif(p==0) return 1;\n\tint res = modpow(a, p/2);\n\tres = (res*res)%MOD;\n\tif(p%2==1) res = (res*a)%MOD;\n\treturn res;\n}\n\nint inv(int x){\n\treturn modpow(x, MOD-2);\n}\n\nint parseArea(vector<string> &vs, int top, int bottom, int left, int right){\n\tfor( ; ;left++){\n\t\tbool flag = true;\n\t\tfor(int i=top;i<=bottom;i++) if(vs[i][left]!='.') flag = false;\n\t\tif(!flag) break;\n\t}\n\tfor( ; ;right--){\n\t\tbool flag = true;\n\t\tfor(int i=top;i<=bottom;i++) if(vs[i][right]!='.') flag = false;\n\t\tif(!flag) break;\n\t}\n\tfor(int i=top;i<=bottom;i++){\n\t\tint pos = left;\n\t\tif(vs[i][left]!='.') return parseExpr(vs, pos, i, top, bottom, left, right);\n\t}\n\treturn 0;\n}\n\nint parseExpr(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tint res = parseTerm(vs, pos, line, top, bottom, left, right);\n\twhile(pos <= right && (vs[line][pos]=='+' || vs[line][pos]=='-')){\n\t\tbool add = vs[line][pos] == '+';\n\t\tpos += 2;\n\t\tint x = parseTerm(vs, pos, line, top, bottom, left, right);\n\t\tif(add) res = (res+x)%MOD;\n\t\telse    res = (res+MOD-x)%MOD;\n\t}\n\treturn res;\n}\n\nint parseTerm(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tint res = parseFactor(vs, pos, line, top, bottom, left, right);\n\twhile(pos <= right && vs[line][pos]=='*'){\n\t\tpos += 2;\n\t\tint x = parseFactor(vs, pos, line, top, bottom, left, right);\n\t\tres = (res*x)%MOD;\n\t}\n\treturn res;\n}\n\nint parseFactor(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tif(vs[line][pos]!='-') return parsePowexpr(vs, pos, line, top, bottom, left, right);\n\tif(vs[line][pos+1]=='-') return parseFraction(vs, pos, line, top, bottom, left, right);\n\tpos += 2;\n\treturn MOD - parseFactor(vs, pos, line, top, bottom, left, right);\n}\n\nint parsePowexpr(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tint res = parsePrimary(vs, pos, line, top, bottom, left, right);\n\tif(left<=pos-1&&pos-1<=right&&top<=line-1&&line-1<=bottom&&isdigit(vs[line-1][pos-1])){\n\t\tres = modpow(res, vs[line-1][pos-1]-'0');\n\t\tpos++;\n\t}\n\treturn res;\n}\n\nint parsePrimary(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tint res = 0;\n\tif(isdigit(vs[line][pos])){\n\t\tres = vs[line][pos]-'0';\n\t\tpos += 2;\n\t}\n\telse { // if(vs[line][pos] == '(')\n\t\tpos += 2;\n\t\tres = parseExpr(vs, pos, line, top, bottom, left, right);\n\t\tpos += 2;\n\t}\n\treturn res;\n}\n\nint parseFraction(vector<string> &vs, int &pos, int line, int top, int bottom, int left, int right){\n\tint end = pos;\n\twhile(end <= right && vs[line][end]=='-') end++;\n\tint x = parseArea(vs, top, line-1, pos, end-1);\n\tint y = parseArea(vs, line+1, bottom, pos, end-1);\n\tpos = end+1;\n\treturn (x*inv(y))%MOD;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<string> vs(n);\n\t\tfor(int i=0;i<n;i++) cin >> vs[i];\n\t\tcout << parseArea(vs, 0, n-1, 0, vs[0].size()-1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cassert>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint inv[2011];\nchar E[20][81];\n\nint parse(int t,int l,int b,int r);\nint expr(int &idx,int y,int y1,int y2);\nint term(int &idx,int y,int y1,int y2);\nint factor(int &idx,int y,int y1,int y2);\nint powexpr(int &idx,int y,int y1,int y2);\nint primary(int &idx,int y,int y1,int y2);\nint fraction(int &idx,int y,int y1,int y2);\n\nint expr(int &idx,int y,int y1,int y2){\n\tint a=term(idx,y,y1,y2);\n\twhile(1){\n\t\tchar c=E[y][idx];\n\t\tif(c!='+' && c!='-') break;\n\t\tidx+=2;\n\t\tint b=term(idx,y,y1,y2);\n\t\tif(c=='+') a=(a+b)%2011;\n\t\tif(c=='-') a=(a-b+2011)%2011;\n\t}\n\treturn a;\n}\n\nint term(int &idx,int y,int y1,int y2){\n\tint a=factor(idx,y,y1,y2);\n\twhile(1){\n\t\tchar c=E[y][idx];\n\t\tif(c!='*') break;\n\n\t\tidx+=2;\n\t\tint b=factor(idx,y,y1,y2);\n\t\ta=a*b%2011;\n\t}\n\treturn a;\n}\n\nint factor(int &idx,int y,int y1,int y2){\n\tif(E[y][idx]=='-' && E[y][idx+1]!='-'){\n\t\tidx+=2;\n\t\treturn (-factor(idx,y,y1,y2)+2011)%2011;\n\t}\n\n\tif(E[y][idx]=='-' && E[y][idx+1]=='-'){\n\t\treturn fraction(idx,y,y1,y2);\n\t}\n\n\treturn powexpr(idx,y,y1,y2);\n}\n\nint powexpr(int &idx,int y,int y1,int y2){\n\tint a=primary(idx,y,y1,y2);\n\tif(y>0 && isdigit(E[y-1][idx-1])){\n\t\tint b=E[y-1][idx-1]-'0',c=1;\n\t\trep(i,b) c=c*a%2011;\n\t\ta=c;\n\t\tidx++;\n\t}\n\treturn a;\n}\n\nint primary(int &idx,int y,int y1,int y2){\n\tint a;\n\tif(isdigit(E[y][idx])){\n\t\ta=E[y][idx]-'0';\n\t}\n\telse{\n\t\tidx+=2;\n\t\ta=expr(idx,y,y1,y2);\n\t}\n\tidx+=2;\n\treturn a;\n}\n\nint fraction(int &idx,int y,int y1,int y2){\n\tint x1=idx+1;\n\twhile(E[y][idx]=='-') idx++;\n\tint x2=idx-1;\n\tidx++;\n\treturn parse(y1,x1,y,x2)*inv[parse(y+1,x1,y2,x2)]%2011;\n}\n\nint find_base_line(int t,int l,int b,int r){\n\tfor(int j=l;j<r;j++) for(int i=t;i<b;i++) if(E[i][j]!='.') return i;\n\tassert(0);\n}\n\nint parse(int t,int l,int b,int r){\n\tint y=find_base_line(t,l,b,r);\n\tint idx=l;\n\twhile(E[y][idx]=='.') idx++;\n\treturn expr(idx,y,t,b);\n}\n\nint main(){\n\trep(i,2011) rep(j,2011) if(i*j%2011==1) inv[i]=j;\n\n\tfor(int h;scanf(\"%d\",&h),h;){\n\t\trep(i,h){\n\t\t\trep(j,81) E[i][j]='\\0';\n\t\t\tscanf(\"%s\",E[i]);\n\t\t}\n\t\tprintf(\"%d\\n\",parse(0,0,h,strlen(E[0])));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nconst int M=2011;\nint inv[M+1];\nchar g[20][82];\nint cur;\n\nint expr(int,int,int,int);\n\nchar gcic(int c,int t,int b=99){\n  for(;t<b;t++){\n    if(g[t][c]!='.')return g[t][c];\n  }\n  return '.';\n}\n\nint sexpr(int t,int l,int b,int r){\n  while(gcic(l,t,b)=='.'){\n    l++;\n  }\n  cur=l;\n  while(gcic(r-1,t,b)=='.'){\n    r--;\n  }\n  return expr(t,l,b,r);\n}\n\nint factor(int t,int l,int b,int r){\n  if(gcic(l,t)=='-'){\n    if(gcic(l+1,t,b)=='.'){\n      return (M-factor(t,l+2,b,r))%M;\n    }else{\n      int v;\n      for(v=t;g[v][l]!='-';v++);\n      int vr;\n      for(vr=l;g[v][vr]=='-';vr++);\n      int rv=(sexpr(t,l,v,vr)*inv[sexpr(v+1,l,b,vr)])%M;\n      cur=vr;\n      return rv;\n    }\n  }else{\n    char c=gcic(l,t);\n    int prm;\n    if(c=='('){\n      prm=expr(t,l+2,b,r-2);\n      cur+=2;\n    }else{\n      prm=c-'0';\n      cur=l+1;\n    }\n    char pc=gcic(cur,t,b);\n    if(pc=='.'){\n      return prm;\n    }else{\n      int rv=1;\n      int p=pc-'0';\n      cur++;\n      while(p--){\n\trv=rv*prm%M;\n      }\n      return rv;\n    }\n  }\n}\n\nint term(int t,int l,int b,int r){\n  int rv=factor(t,l,b,r);\n  while(gcic(cur+1,t,b)=='*'){\n    rv=(rv*factor(t,cur+3,b,r))%M;\n  }\n  return rv;\n}\n\nint expr(int t,int l,int b,int r){\n  int rv=term(t,l,b,r);\n  for(;;){\n    char op=gcic(cur+1,t,b);\n    if(op!='+'&&op!='-')break;\n    int f=(op=='+')?1:-1;\n    rv=(rv+f*term(t,cur+3,b,r)+M)%M;\n  }\n  return rv;\n}\n\nint main(){\n  for(int i=1;i<=M;i++){\n    for(int j=0;j<=M;j++){\n      if(i*j%M==1){\n\tinv[i]=j;\n      }\n    }\n  }\n  int len;\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>g[i];\n      len=strlen(g[i]);\n      for(int j=len;j<82;j++){\n\tg[i][j]='.';\n      }\n    }\n    cur=0;\n    cout<<expr(0,0,n,len)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define REP(i,x,n) for(int i=x;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nconst int mod=2011;\n\npii expr(int,int,int,int);\npii term(int,int,int,int);\npii factor(int,int,int,int);\npii powexpr(int,int,int,int);\npii primary(int,int,int,int);\n\nint H,W;\nchar field[30][100];\n\nll mod_pow(ll num,ll p,ll mod){\n  ll mul=num;\n  ll res=1;\n  while(p){\n    if(p%2)res=(res*mul)%mod;\n    p/=2;\n    mul=(mul*mul)%mod;\n  }\n  return res;\n}\nll div_mod(ll num,ll mod){\n  return mod_pow(num,mod-2,mod);\n}\n\npii expr(int miny,int minx,int maxy,int maxx){\n  for(int x=minx;x<=maxx;x++){\n    bool flg=false;\n    for(int y=miny;y<=maxy;y++){\n      if(field[y][x]!='.'){\n        flg=true;\n      }\n    }\n    if(flg)break;\n    minx++;\n  }\n  pii res=term(miny,minx,maxy,maxx);\n  minx=res.second;\n  if(minx<=maxx){\n    while(minx<=maxx){\n      minx++;\n      bool no=false;\n      for(int y=miny;y<=maxy;y++){\n        if(field[y][minx]=='+'){\n          minx+=2;\n          pii p=term(miny,minx,maxy,maxx);\n          res.first+=p.first;\n          res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(field[y][minx]=='-'&&field[y][minx+1]!='-'){\n          minx+=2;\n          pii p=term(miny,minx,maxy,maxx);\n          res.first-=p.first;\n          res.first+=mod;\n          res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(y==maxy){\n          no=true;\n          break;\n        }\n      }\n      if(no){\n        minx--;\n        break;\n      }\n    }\n  }\n  return pii(res.first,minx);\n}\npii term(int miny,int minx,int maxy,int maxx){\n  pii res=factor(miny,minx,maxy,maxx);\n  minx=res.second;\n  if(minx<=maxx){\n    while(minx<=maxx){\n      minx++;\n      bool no=false;\n      for(int y=miny;y<=maxy;y++){\n        if(field[y][minx]=='*'){\n          minx+=2;\n          pii p=factor(miny,minx,maxy,maxx);\n          res.first*=p.first;res.first%=mod;\n          minx=p.second;\n          break;\n        }\n        else if(y==maxy){\n          no=true;\n          break;\n        }\n      }\n      if(no){\n        minx--;\n        break;\n      }\n    }\n  }\n  return pii(res.first,minx);\n}\npii factor(int miny,int minx,int maxy,int maxx){\n  pii res(1,1);\n  for(int y=miny;y<=maxy;y++){\n    if(field[y][minx]=='-'\n       &&field[y][minx+1]=='.'){\n      minx+=2;\n      pii p=factor(miny,minx,maxy,maxx);\n      p.first*=-1;\n      p.first+=mod;\n      p.first%=mod;\n      minx=p.second;\n      return pii(p.first,minx);\n    }\n  }\n  // fraction\n  for(int y=miny;y<=maxy;y++){\n    // found\n    if(field[y][minx]=='-'&&field[y][minx+1]=='-'){\n      int pos=-1;\n      for(int i=minx;i<=maxx;i++){\n        if(field[y][i]!='-'){\n          pos=i;\n          break;\n          // const int from=minx+1;\n          // const int to=i-2;\n          // pii p1=expr(miny,from,y-1,to);\n          // pii p2=expr(y+1,from,maxy,to);\n          // return pii((p1.first*div_mod(p2.first,mod))%mod,i);\n        }\n      }\n      if(pos==-1)pos=maxx+1;\n      const int from=minx+1;\n      const int to=pos-2;\n      pii p1=expr(miny,from,y-1,to);\n      pii p2=expr(y+1,from,maxy,to);\n      return pii((p1.first*div_mod(p2.first,mod))%mod,pos);\n    }\n  }\n  // powexpr\n  return powexpr(miny,minx,maxy,maxx);\n}\npii powexpr(int miny,int minx,int maxy,int maxx){\n  pii res=primary(miny,minx,maxy,maxx);\n  minx=res.second;\n  int mul=res.first;\n  res.first=1;\n  bool found=false;\n  for(int y=miny;y<=maxy;y++)\n    if(isdigit(field[y][minx])){\n      for(int i=0;i<field[y][minx]-'0';i++){\n        res.first*=mul;\n        res.first%=mod;\n      }\n      minx++;\n      found=true;\n      break;\n    }\n  if(!found)res.first=mul;\n  return pii(res.first,minx);\n}\n\npii primary(int miny,int minx,int maxy,int maxx){\n  pii res;\n  for(int y=miny;y<=maxy;y++)\n    if(isdigit(field[y][minx])){\n      res.first=field[y][minx]-'0';\n      return pii(res.first,minx+1);\n    }\n  // par\n  minx+=2;\n  res=expr(miny,minx,maxy,maxx);\n  minx=res.second+2;\n  return pii(res.first,minx);\n}\n\nint main(){\n // ifstream cin(\"in.txt\");\n  while(cin>>H&&H){\n    rep(i,H){\n      cin>>field[i];\n      W=strlen(field[i]);\n    }\n    cout<<expr(0,0,H-1,W-1).first<<endl;\n    //cout<<(mod-(3*div_mod(4,mod))%mod)%mod<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n\nint mod=2011;\n\nint inv[2011];\n\nint ruijo(int x,int n){\n\tint p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\nint n;\nint m;\nvector<string> v;\n\nint expr(int a,int b,int c,int d);\nint term(int a,int b,int c,int d);\nint factor(int a,int b,int c,int d);\nint powexpr(int a,int b,int c,int d);\nint primary(int a,int b,int c,int d);\n\n\nint expr(int a,int b,int c,int d){\n\t//cout << \"expr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn expr(a,b+1,c,d);\n\t}\n\tint x_tmp = -1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][d]!='.')x_tmp=i;\n\t}\n\tif(x_tmp==-1){\n\t\treturn expr(a,b,c,d-1);\n\t}\n\tint y=b;\n\tint yt = -1;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&(v[x][i]=='*'||v[x][i]=='+'||v[x][i]=='-')){\n\t\t\tif(v[x][i]=='+'){\n\t\t\t\ty = i;\n\t\t\t\tyt = i;\n\t\t\t}else if(v[x][i]=='*'){\n\t\t\t\tyt = i;\n\t\t\t}else{\n\t\t\t\tif(i!=d){\n\t\t\t\t\tif(v[x][i]=='-'&&v[x][i+1]=='.'&&i<d-1){\n\t\t\t\t\t\tif(yt+2==i){\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tyt = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn term(a,b,c,d);\n\t}else{\n\t\tif(v[x][y]=='-'){\n\t\t\treturn (mod+expr(a,b,c,y-2)-term(a,y+2,c,d))%mod;\n\t\t}else{\n\t\t\treturn (expr(a,b,c,y-2)+term(a,y+2,c,d))%mod;\n\t\t}\n\t}\n}\n\nint term(int a,int b,int c,int d){\n\t//cout << \"term \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn term(a,b+1,c,d);\n\t}\n\tint y=b;\n\tint depth = 0;\n\tfor(int i=b;i<=d;i++){\n\t\tif(v[x][i]=='('){\n\t\t\tdepth++;\n\t\t}else if(v[x][i]==')'){\n\t\t\tdepth--;\n\t\t}else if(depth==0&&v[x][i]=='*'){\n\t\t\ty = i;\n\t\t}\n\t}\n\tif(y==b){\n\t\treturn factor(a,b,c,d);\n\t}else{\n\t\treturn (term(a,b,c,y-2)*factor(a,y+2,c,d))%mod;\n\t}\n}\n\nint factor(int a,int b,int c,int d){\n\t//cout << \"factor \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn factor(a,b+1,c,d);\n\t}\n\tif(v[x][b]!='-'){\n\t\treturn powexpr(a,b,c,d);\n\t}\n\tif(v[x][b+1]=='-'){\n\t\treturn (expr(a,b,x-1,d)*inv[expr(x+1,b,c,d)])%mod;\n\t}else{\n\t\treturn (mod - factor(a,b+2,c,d))%mod;\n\t}\n}\n\nint powexpr(int a,int b,int c,int d){\n\t//cout << \"powexpr \" << a << \" \" << b << \" \" << c << \" \" << d <<endl;\n\t\n\tint x=-1;\n\tfor(int i=a;i<=c;i++){\n\t\tif(v[i][b]!='.')x = i;\n\t}\n\tif(x==-1){\n\t\treturn powexpr(a,b+1,c,d);\n\t}\n\tif(v[x][b]=='('){\n\t\tint depth = 0;\n\t\tfor(int i=b;i<=d;i++){\n\t\t\tif(v[x][i]=='('){\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\tif(v[x][i]==')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth==0){\n\t\t\t\t\tif(x!=0&&i<d){\n\t\t\t\t\t\tif(v[x-1][i+1]!='.'&&v[x-1][b+1]!='-'){\n\n\t\t\t\t\t\t\treturn ruijo(expr(a,b+1,c,i-1),v[x-1][i+1]-'0');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn expr(a,b+1,c,i-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(x!=0&&b<d){\n\t\t\tif(v[x-1][b+1]!='.'&&v[x-1][b+1]!='-'){\n\t\t\t\treturn ruijo(v[x][b]-'0',v[x-1][b+1]-'0');\n\t\t\t}\n\t\t}\n\t\treturn v[x][b]-'0';\n\t}\n}\n\nint main(){\n\tfor(int i=1;i<2011;i++){\n\t\tinv[i] = ruijo(i,2009);\n\t}\n\twhile(cin >> n&&n!=0){\n\t\tv.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tv.push_back(tmp);\n\t\t}\n\t\tm = v[0].size();\n\t\tint ans=0; \n\t\tans = expr(0,0,n-1,m-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#error \"\"\n\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nconstexpr intmax_t MOD=2011;\n\nintmax_t apply(intmax_t lhs, char op, intmax_t rhs) {\n  switch (op) {\n  case '+': return (lhs + rhs) % MOD;\n  case '-': return ((lhs - rhs) % MOD + MOD) % MOD;\n  case '*': return (lhs * rhs) % MOD;\n  }\n  assert(false);\n}\n\nintmax_t modpow(intmax_t base, intmax_t iexp) {\n  fprintf(stderr, \"%jd^%jd\\n\", base, iexp);\n  intmax_t res=1;\n  for (intmax_t dbl=base; iexp; iexp>>=1) {\n    if (iexp & 1) (res *= dbl) %= MOD;\n    (dbl *= dbl) %= MOD;\n  }\n  return res;\n}\n\nintmax_t moddiv(intmax_t num, intmax_t den) {\n  intmax_t div=modpow(den, MOD-2);\n  return num*div % MOD;\n}\n\nintmax_t parse(const std::vector<std::string> &s, size_t &i,\n               size_t top, size_t bottom, size_t left, size_t right,\n               size_t preced=0, size_t base=-1,\n               const std::vector<std::string> &ops={\"+-\", \"*\"}) {\n\n  while (base+1 == 0) {\n    for (size_t r=top; r<bottom; ++r) {\n      if (s[r][i] != '.') {\n        base = r;\n        break;\n      }\n    }\n    if (base+1 == 0) ++i;\n  }\n  assert(base+1 != 0);\n  fprintf(stderr, \"s[%zu]: LR[%zu, %zu), TB[%zu, %zu), base:%zu, prec:%zu\\n\",\n          i, left, right, top, bottom, base, preced);\n\n  if (preced == ops.size()) {\n    intmax_t res=114514;\n    if (s[base][i] == '(') {\n      res = parse(s, i+=2, top, bottom, left, right, 0, base);\n      assert(s[base][i] == ')');\n      ++i;\n    } else if (s[base][i] == '-') {\n      if (s[base][i+1] == '-') {\n        size_t vl=i, vr=i+1;\n        while (s[base][++vr] == '-') {}\n\n        size_t j=left+1;\n        intmax_t numer=parse(s, j, top, base, vl, vr, 0);\n        j = left+1;\n        intmax_t denom=parse(s, j, base+1, bottom, vl, vr, 0);\n        res = moddiv(numer, denom);\n        i = vr+1;\n      } else {\n        res = -parse(s, i+=2, top, bottom, left, right, preced, base);\n      }\n    } else if (isdigit(s[base][i])) {\n      res = s[base][i]-'0';\n      ++i;\n    }\n\n    if (i+1 < right && top+1 <= base && isdigit(s[base-1][i+1])) {\n      fprintf(stderr, \"s[%zu][%zu]: %c\\n\", base-1, i+1, s[base-1][i+1]);\n      fprintf(stderr, \"%jd^%jd\\n\", res, intmax_t(s[base-1][i+1]-'0'));\n      res = modpow(res, s[base-1][i+1]-'0');\n      ++i;\n    }\n    ++i;\n    fprintf(stderr, \"Returns %jd\\n\", res);\n    return res;\n  }\n\n  intmax_t lhs=parse(s, i, top, bottom, left, right, preced+1, base);\n  while (i < right) {\n    char op=s[base][i];\n    if (!std::count(ops[preced].begin(), ops[preced].end(), op)) break;\n    intmax_t rhs=parse(s, i+=2, top, bottom, left, right, preced+1, base);\n    lhs = apply(lhs, op, rhs);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s;\n  for (size_t i=0; i<n; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s.emplace_back(buf);\n  }\n\n  size_t i=0;\n  intmax_t res=parse(s, i, 0, s.size(), 0, s[0].length());\n  printf(\"%jd\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\ns[0]: LR[0, 23), TB[0, 4), base:1, prec:0\ns[0]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[0]: LR[0, 23), TB[0, 4), base:1, prec:2\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:0\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[2]: LR[0, 23), TB[0, 4), base:1, prec:2\nReturns 1\ns[6]: LR[0, 23), TB[0, 4), base:1, prec:1\ns[6]: LR[0, 23), TB[0, 4), base:1, prec:2\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:0\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:1\ns[8]: LR[6, 10), TB[0, 1), base:0, prec:2\nReturns 4\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:0\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:1\ns[7]: LR[6, 10), TB[2, 4), base:3, prec:2\nReturns 3\n3^2009\ns[0][12]: 2\n1342^2: L80\n1342^2\nReturns 1119\na.out: D.cpp:57: intmax_t parse(const std::__debug::vector<std::__cxx11::basic_string<char> >&, size_t&, size_t, size_t, size_t, size_t, size_t, size_t, const std::__debug::vector<std::__cxx11::basic_string<char> >&): Assertion `s[base][i] == ')'' failed.\nAborted (core dumped)\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint power[2011][2011], divis[2011][2011], mod = 2011;\n\nvoid init() {\n\tfor (int i = 0; i < 2011; i++) {\n\t\tpower[i][0] = 1; for (int j = 1; j < 2011; j++) power[i][j] = (power[i][j - 1] * i) % mod;\n\t}\n\tfor (int i = 0; i < 2011 * 2011; i++) divis[i / 2011][i % 2011] = -1;\n\tfor (int i = 0; i < 2011; i++) {\n\t\tfor (int j = 0; j < 2011; j++) {\n\t\t\tif (divis[(i * j) % mod][i] == -1) divis[(i * j) % mod][i] = j;\n\t\t}\n\t}\n}\n\nint modpow(int a, int b) { return power[a][b]; }\nint Div(int a, int b) { return divis[a][b]; }\n\nint solve(vector<string> A) {\n\t/*cout << endl;\n\tfor (int i = 0; i < A.size(); i++) cout << A[i] << endl;\n\tcout << endl;*/\n\n\t// ---------------------------------------- Step 1: 式を圧縮する ---------------------------------\n\tint px = (1 << 30), py = (1 << 30), qx = 0, qy = 0;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tfor (int j = 0; j < A[0].size(); j++) {\n\t\t\tif (A[i][j] == '.') continue;\n\t\t\tpx = min(px, i); py = min(py, j);\n\t\t\tqx = max(qx, i); qy = max(qy, j);\n\t\t}\n\t}\n\n\t// ---------------------------------------- Step 2: パースする -----------------------------------\n\tvector<string>B;\n\tfor (int i = px; i <= qx; i++) B.push_back(A[i].substr(py, qy - py + 1));\n\n\tint BASE = 0, H = B.size(), W = B[0].size();\n\tfor (int i = 0; i < H; i++) {\n\t\tif (B[i][0] != '.') { BASE = i; }\n\t}\n\n\tif (H == 1 && W == 1) return (B[0][0] - '0');\n\n\tvector<pair<int, int>>vec; int depth = 0; bool IsDiv = false;\n\tfor (int i = 0; i < W; i++) {\n\t\tif (B[BASE][i] == '(') depth++;\n\t\tif (B[BASE][i] == ')') depth--;\n\t\tif (depth == 0) {\n\t\t\tif (B[BASE][i] == '+') vec.push_back(make_pair(i, 1));\n\t\t\tif (B[BASE][i] == '-' && (i != W - 1 && B[BASE][i + 1] != '-') && (i != 0 && B[BASE][i - 1] != '-')) {\n\t\t\t\tbool ok = false;\n\t\t\t\tif (i == 0) ok = true;\n\t\t\t\tif (i >= 2) {\n\t\t\t\t\tif (B[BASE][i - 2] == '+') ok = true;\n\t\t\t\t\tif (B[BASE][i - 2] == '*') ok = true;\n\t\t\t\t\tif (B[BASE][i - 2] == '-' && (i == 2 || B[BASE][i - 3] != '-')) ok = true;\n\t\t\t\t}\n\t\t\t\tif (ok == false) vec.push_back(make_pair(i, 2));\n\t\t\t}\n\t\t\tif (B[BASE][i] == '-') IsDiv = true;\n\t\t}\n\t}\n\n\t// ---------------------------------------- Step 3: '+', '-' が存在する場合 ----------------------\n\tif (vec.size() >= 1) {\n\t\tvector<pair<int, int>>vec3;\n\t\tvec3.push_back(make_pair(-1, 1));\n\t\tfor (int i = 0; i < vec.size(); i++) vec3.push_back(vec[i]);\n\t\tvec3.push_back(make_pair(W, 1));\n\n\t\tbool ok = false; int res = 0;\n\t\tfor (int i = 1; i < vec3.size(); i++) {\n\t\t\tif (vec3[i].first - vec3[i - 1].first == 2) {\n\t\t\t\tif (vec3[i].second == 2) ok ^= true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvector<string>A3;\n\t\t\t\tfor (int j = 0; j < H; j++) A3.push_back(B[j].substr(vec3[i - 1].first + 1, (vec3[i].first - 1) - (vec3[i - 1].first + 1) + 1));\n\n\t\t\t\tint rem = solve(A3);\n\t\t\t\tif (ok == false) res += rem; else res -= rem;\n\t\t\t\tres += mod; res %= mod;\n\n\t\t\t\tif (vec3[i].second == 1) ok = false;\n\t\t\t\telse ok = true;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t// ---------------------------------------- Step 3.5: マイナスの処理 -----------------------------\n\tif (B[BASE][0] == '-' && (W >= 2 && B[BASE][1] == '.')) {\n\t\tvector<string>A4;\n\t\tfor (int i = 0; i < H; i++) A4.push_back(B[i].substr(1, W - 1));\n\t\tint p1 = solve(A4);\n\t\treturn (mod - p1) % mod;\n\t}\n\n\t// ---------------------------------------- Step 4: パース 2 個目 --------------------------------\n\tvector<int>vec2; depth = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tif (B[BASE][i] == '(') depth++;\n\t\tif (B[BASE][i] == ')') depth--;\n\t\tif (B[BASE][i] == '*' && depth == 0) vec2.push_back(i);\n\t}\n\n\t// ---------------------------------------- Step 5: '*' が存在する場合 ---------------------------\n\tif (vec2.size() >= 1) {\n\t\tvector<int>vec3; vec3.push_back(-1);\n\t\tfor (int i = 0; i < vec2.size(); i++) vec3.push_back(vec2[i]);\n\t\tvec3.push_back(W);\n\n\t\tint muls = 1;\n\t\tfor (int i = 0; i < vec3.size() - 1; i++) {\n\t\t\tvector<string>A5;\n\t\t\tfor (int j = 0; j < H; j++) A5.push_back(B[j].substr(vec3[i] + 1, (vec3[i + 1] - 1) - (vec3[i] + 1) + 1));\n\t\t\tint ret = solve(A5); muls *= ret; muls %= mod;\n\t\t}\n\t\treturn muls;\n\t}\n\n\t// ---------------------------------------- Step 6: '/' が存在する場合 ---------------------------\n\tif (IsDiv == true) {\n\t\tvector<string>A6a, A6b;\n\t\tfor (int i = 0; i < BASE; i++) A6a.push_back(B[i]);\n\t\tfor (int i = BASE + 1; i < H; i++) A6b.push_back(B[i]);\n\n\t\tint v1 = solve(A6a), v2 = solve(A6b);\n\t\tint rets = Div(v1, v2);\n\t\treturn rets;\n\t}\n\n\t// ---------------------------------------- Step 7: '(' が存在する場合 ---------------------------\n\tif (B[BASE][0] == '(' && B[BASE][W - 1] == ')') {\n\t\tvector<string> A7;\n\t\tfor (int i = 0; i < H; i++) A7.push_back(B[i].substr(1, W - 2));\n\t\treturn solve(A7);\n\t}\n\n\t// ---------------------------------------- Step 8: その他の場合（累乗） -------------------------\n\tint pows = (B[BASE - 1][W - 1] - '0');\n\tvector<string>A8;\n\tfor (int i = 0; i < H; i++) A8.push_back(B[i].substr(0, W - 1));\n\tint C8 = solve(A8);\n\treturn modpow(C8, pows);\n}\n\nint main() {\n\tinit();\n\twhile (true) {\n\t\tint n; cin >> n; if (n == 0) break;\n\t\tvector<string>vec;\n\t\tfor (int i = 0; i < n; i++) { string str; cin >> str; vec.push_back(str); }\n\n\t\tcout << solve(vec) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\nusing namespace std;\n\nconst int mod = 2011;\nvector<string> s;\nvector<int> inv(mod,1);\n\ninline int get_base(int l, int t, int b){\n  FOR(i,t,b)if(s[i][l]!='.')return i;\n  return t;\n}\n\nint expr(int &l, int &t, int &r, int &b);\n\nint fraction(int &l, int &t, int &r, int &b){\n  int base = t;\n  FOR(i,t,b)if(s[i][l]!='.')base = i;\n\n  int ll = l+1;\n  while(++l < r && s[base][l]=='-');\n\n  int ul = ll, ur = l-1, dl = ll, dr = l-1;\n  int ut = t, ub = base, dt = base+1, db = b;\n  return expr(ul,ut,ur,ub) * inv[expr(dl,dt,dr,db)] % mod;\n}\n\nint primary(int &l, int &t, int &r, int &b){\n  int base = get_base(l,t,b);\n  if(isdigit(s[base][l]))return s[base][l++]-'0';\n\n  l+=2;\n  int res = expr(l,t,r,b);\n  l+=2;\n  return res;\n}\n\nint powexpr(int &l, int &t, int &r, int &b){\n  int res = primary(l,t,r,b);\n  int base = get_base(l,t,b);\n\n  if(l<r && isdigit(s[base][l])){\n    int p = s[base][l]-'0';\n    l++;\n    int tmp = res; res = 1;\n    while(p--) (res *= tmp) %= mod;\n  }\n  return res;\n}\n\nint factor(int &l, int &t, int &r, int &b){\n  int base = get_base(l,t,b);\n\n  if(s[base][l] == '-'){\n    if(s[base][l+1] == '.'){\n      l+=2;\n      return mod - factor(l,t,r,b);\n    }else return fraction(l,t,r,b);\n  }\n  return powexpr(l,t,r,b);\n}\n\nint term(int &l, int &t, int &r, int &b){\n  int base = get_base(l,t,b);\n\n  int res = factor(l,t,r,b);\n  while(l+1<r && s[base][l+1]=='*'){\n    l+=3;\n    res = (res * factor(l,t,r,b)) % mod;\n  }\n  return res;\n}\n\nint expr(int &l, int &t, int &r, int &b){\n  //remove spaces\n  for(bool f=true;l<r;l++){FOR(i,t,b)f &= (s[i][l]=='.');   if(!f)break;}\n  for(bool f=true;l<r;r--){FOR(i,t,b)f &= (s[i][r-1]=='.'); if(!f)break;}\n  for(bool f=true;t<b;t++){FOR(i,l,r)f &= (s[t][i]=='.');   if(!f)break;}\n  for(bool f=true;t<b;b--){FOR(i,l,r)f &= (s[b-1][i]=='.'); if(!f)break;}\n\n  int base = get_base(l,t,b);\n\n  int res = term(l,t,r,b);\n  while(l+1<r && (s[base][l+1]=='+' || s[base][l+1]=='-')){\n    l+=3;\n    if(s[base][l-2]=='+')res = (res + term(l,t,r,b)) % mod;\n    else res = (res - term(l,t,r,b) + mod) % mod;\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(); ios::sync_with_stdio(0);\n  FOR(i,2,mod)inv[i] = (mod - mod/i) * inv[mod%i] % mod;\n\n  int n;\n  while(cin>>n,n){\n    s.resize(n);\n    FOR(i,0,n)cin >> s[i];\n\n    int l = 0, t = 0, r = s[0].size(), b = n;\n    cout << expr(l,t,r,b) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(int (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define ALL(v) v.begin(),v.end()\n#define MOD 2011\n\nconst int PLUS = -1;\nconst int MINUS = -2;\nconst int MULTI = -3;\n\nvector<string> mp(20);\n\nint calPolynomial(int y1, int x1, int y2, int x2);\n\nvoid DBGout(int y1, int x1, int y2, int x2){\n    for(int y = y1; y <= y2;y++){\n        for(int x = x1;x <= x2;x++){\n            cerr << mp[y][x];\n        }\n        cerr << endl;\n    }\n    cerr << endl;\n}\n\nint mod_div(int a,int b){\n    int tmp = MOD - 2,c = b,ret = 1;\n    while(tmp > 0){\n        if(tmp & 1){\n            ret *= c;ret %= MOD;\n        }\n        c *= c;c %= MOD;tmp >>= 1;\n    }\n    return a*ret%MOD;\n}\n\nint mod_pow(int a,int b){\n    int ret = 1;\n    int c = a;\n    for(int i = 0;i <= 60;i++){\n        if(b & (1LL << i))ret = (ret * c) % MOD;\n        c = (c * c) % MOD;\n    }\n    return ret;\n}\n\nchar columnChar(int y, int x1, int x2) {\n\tint count = 0;\n\tchar last_c = '.';\n    for(int x = x1;x <= x2;x++){\n        if(mp[y][x] != '.') {\n\t\t\tcount++;\n\t\t\tlast_c = mp[y][x];\n\t\t}\n    }\n\tif(count > 1)last_c = '#';\n    return last_c;\n}\n\nchar rowChar(int y1, int y2, int x) {\n\tint count = 0;\n\tchar last_c = '.';\n    for(int y = y1;y <= y2;y++){\n        if(mp[y][x] != '.') {\n\t\t\tcount++;\n\t\t\tlast_c = mp[y][x];\n\t\t}\n    }\n\tif(count > 1)last_c = '#';\n    return last_c;\n}\n\nvoid packSquare(int &y1, int &x1, int &y2, int &x2) {\n    while(columnChar(y1, x1, x2) == '.')y1++;\n    while(columnChar(y2, x1, x2) == '.')y2--;\n    while(rowChar(y1, y2, x1) == '.')x1++;\n    while(rowChar(y1, y2, x2) == '.')x2--;\n}\n\nint calMonomial(int y1, int x1, int y2, int x2){\n    packSquare(y1, x1, y2, x2);\n    //cerr << \"calMonomial \" << y1 << \" \" << x1 << \" \" << y2 << \" \" << x2 << endl;\n    //DBGout(y1, x1, y2, x2);\n\n    if(y1 == y2 && x1 == x2)return mp[y1][x1] - '0';\n    for(int y = y1;y <= y2;y++){\n        if(mp[y][x1] == '-'){\n            return mod_div(calPolynomial(y1, x1, y-1, x2), calPolynomial(y + 1, x1, y2, x2));\n        }\n    }\n    return mod_pow(mp[y2][x1] - '0', mp[y1][x2] - '0');\n}\n\nvector<int> uniqueNegative(vector<int> v) {\n    vector<int> ret;\n    REV(i, v.size()){\n\t\tif(v[i] == MINUS){\n\t\t\tret.back() = MOD - ret.back();\n\t\t\tcontinue;\n\t\t}\n\t\tif(v[i] >= 0){\n\t\t\tif(!ret.empty() && ret.back() >= 0){\n\t\t\t\tret.PB(PLUS);\n\t\t\t}\n\t\t\tret.PB(v[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tret.PB(v[i]);\n    }\n\treverse(ALL(ret));\n    return ret;\n}\n\nvector<int> multiplication(vector<int> v) {\n    vector<int> ret;\n    ret.PB(v[0]);\n    for(int i = 1;i < v.size();i += 2){\n        if(v[i] == MULTI){\n            ret.back() = ret.back() * v[i+1] % MOD;\n            continue;\n        }\n\n        ret.PB(v[i]);\n        ret.PB(v[i+1]);\n    }\n\n    return ret;\n}\n\nint additionSubtraction(vector<int> v) {\n     int ret = v[0];\n     for(int i = 1;i < v.size();i += 2){\n         if(v[i] == PLUS){\n             ret = (ret + v[i+1]) % MOD;\n         }\n         if(v[i] == MINUS){\n             ret = (ret + MOD - v[i+1]) % MOD;\n         }\n     }\n\n     return ret;\n}\n\nint searchClose(int y1, int x1, int y2, int x2) {\n    int num = 0;\n    for(int x = x1;x <= x2;x++){\n        char now = rowChar(y1, y2, x);\n\n        if(now == '(')num++;\n        if(now == ')')num--;\n\n        if(num == 0){\n            return x;\n        }\n    }\n    return x2;\n}\n\n//　(y1,x1)から(y2,x2)で表される数式の値\nint calPolynomial(int y1, int x1, int y2, int x2){\n    packSquare(y1, x1, y2, x2);\n    //cerr << \"calPolynomial \" << y1 << \" \" << x1 << \" \" << y2 << \" \" << x2 << endl;\n    //DBGout(y1, x1, y2, x2);\n\n    vector<int> v;\n\tint last_x = x1;\n    for(int x = x1;x <= x2;x++){\n\t\tchar now = rowChar(y1, y2, x);\n\n\t\tif(now == '#' || isdigit(now))continue;\n\t\tif(x < x2 && rowChar(y1, y2, x+1) == '#')continue;\n\t\tif(x > x1 && rowChar(y1, y2, x-1) == '#')continue;\n\n\t\tif(now == '.') {\n\t\t\tif(last_x != x){\n                v.PB(calMonomial(y1, last_x, y2, x-1));\n            }\n            last_x = x+1;\n            continue;\n\t\t}\n\n        if(now == '('){\n            int tmp_x = searchClose(y1, x, y2, x2);\n            v.PB(calPolynomial(y1, x + 1, y2, tmp_x - 1));\n            x = tmp_x;\n\t\t\tlast_x = tmp_x + 1;\n\t\t\tif(x == x2)continue;\n\t\t\tchar nxt_c = rowChar(y1, y2, x + 1);\n\t\t\tif(isdigit(nxt_c)){\n\t\t\t\tv.back() = mod_pow(v.back(), nxt_c - '0');\n\t\t\t\tx++;\n\t\t\t\tlast_x++;\n\t\t\t}\n\t\t\tcontinue;\n        }\n\n        if(now == '+'){\n            v.PB(PLUS);\n        }\n        if(now == '-'){\n            v.PB(MINUS);\n        }\n        if(now == '*'){\n            v.PB(MULTI);\n        }\n\n        last_x = x + 1;\n    }\n    if(last_x != x2 + 1)v.PB(calMonomial(y1, last_x, y2, x2));\n\n    v = uniqueNegative(v);\n    v = multiplication(v);\n    return additionSubtraction(v);\n}\n\nint main(){\n    cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n    int n;\n    while(cin >> n, n){\n        REP(i, n){\n            cin >> mp[i];\n        }\n        cout << calPolynomial(0, 0, n-1, mp[0].size() - 1) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <assert.h>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 2011;\n\n\nint n;\nchar s[25][100];\nint inv[2020];\n\nll mod_pow(ll a,ll b){\n\tif(b==0)return 1;\n\tll res=mod_pow((a*a)%MOD,b/2);\n\tif(b&1)res=(res*a)%MOD;\n\treturn res;\n}\n\n\nint expr(int &p, int u, int d, int r);\n\nint primary(int &p, int base, int u, int d, int r){\n\tif(isdigit(s[base][p])){\n\t\treturn s[base][p++] - '0';\n\t}else if(s[base][p] == '('){\n\t\tp+=2;\n\t\tint res = expr(p, u, d, r);\n\t\tif(s[base][p] != '.' || s[base][p+1] != ')') assert(false);\n\t\tp+= 2;\n\t\treturn res;\n\t}else assert(false);\n}\n\nint fact(int &p, int base, int u, int d, int r){\n\tif(s[base][p] == '-'){\n\t\tif(s[base][p+1] == '.'){\n\t\t\tp+=2;\n\t\t\treturn (-fact(p, base, u, d, r) + MOD) % MOD;\n\t\t}else{\n\t\t\tint p1 = p+1, p2 = p+1;\n\t\t\twhile(s[base][p] == '-') ++ p;\n\t\t\treturn expr(p1, u, base, p-1) * inv[expr(p2, base+1, d, p-1)] % MOD;\n\t\t}\n\t}else if(isdigit(s[base][p]) || s[base][p] == '('){\n\t\tint res = primary(p, base, u, d, r);\n\t\tif(base - 1 >= u && isdigit(s[base-1][p]))\n\t\t\tres = mod_pow(res, s[base-1][p++]-'0');\n\t\treturn res;\n\t}\n\tassert(false);\n}\n\nint term(int &p, int base, int u, int d, int r){\n\tint res = fact(p, base, u, d, r);\n\twhile(1){\n\t\tif(p+1 < r && s[base][p+1] == '*'){\n\t\t\tp+=3;\n\t\t\tres = res * fact(p, base, u, d, r) % MOD;\n\t\t}else break;\n\t}\n\treturn res;\n}\n\nint expr(int &p, int u, int d, int r){\n\tint base = -1;\n\twhile(1){\n\t\tfor(int i=u;i<d;i++) if(s[i][p] != '.') base = i;\n\t\tif(base!=-1) break;\n\t\tp ++;\n\t}\n\tint res = term(p, base, u, d, r);\n\twhile(1){\n\t\tif(p+1 < r && s[base][p+1] == '+'){\n\t\t\tp+=3;\n\t\t\tres = (res + term(p, base, u, d, r)) % MOD;\n\t\t}else if(p+1 < r && s[base][p+1] == '-'){\n\t\t\tp+=3;\n\t\t\tres = (MOD + res - term(p, base, u, d, r)) % MOD;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tinv[1]=1;\n\tfor(int i=2;i<MOD;i++) inv[i] = (MOD+((long long)-inv[MOD%i]*(MOD/i))%MOD)%MOD;\n\n\twhile(cin >> n, n){\n\t\tmemset(s, 0, sizeof(s));\n\t\tREP(i, n) cin >> s[i];\n\t\tint p = 0;\n\t\tcout << expr(p, 0, n, strlen(s[0])) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr int MAX_N = 20;\nint n;\nint len;\narray<string, MAX_N> expression;\n\nconstexpr int mod = 2011;\nint inverse[mod];\n\nvoid calc_inverse() {\n\tinverse[1] = 1;\n\tfor(int i = 2; i < mod; ++i) {\n\t\tinverse[i] = inverse[mod % i] * (mod - mod / i) % mod;\n\t}\n}\n\nint find_base(int top, int bottom, int &pos) {\n\tfor(; pos < len; ++pos) {\n\t\tfor(int i = top; i <= bottom; ++i) {\n\t\t\tif(expression[i][pos] != '.') {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n}\n\nint expr(int top, int base, int bottom, int &pos);\nint term(int top, int base, int bottom, int &pos);\nint factor(int top, int base, int bottom, int &pos);\nint powexpr(int top, int base, int bottom, int &pos);\nint primary(int top, int base, int bottom, int &pos);\nint fraction(int top, int base, int bottom, int &pos);\n\nint expr(int top, int base, int bottom, int &pos) {\n\tint res = term(top, base, bottom, pos);\n\twhile(pos + 3 < len && expression[base][pos] == '.'\n\t\t  && (expression[base][pos + 1] == '+'\n\t\t\t  || expression[base][pos + 1] == '-')) {\n\t\tassert(expression[base][pos + 2] == '.');\n\t\tconst bool plus = (expression[base][pos + 1] == '+');\n\t\tpos += 3;\n\t\tif(plus) {\n\t\t\tres = (res + term(top, base, bottom, pos)) % mod;\n\t\t}\n\t\telse {\n\t\t\tres = (res - term(top, base, bottom, pos) + mod) % mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nint term(int top, int base, int bottom, int &pos) {\n\tint res = factor(top, base, bottom, pos);\n\twhile(pos + 3 < len && expression[base][pos + 1] == '*') {\n\t\tassert(expression[base][pos++] == '.');\n\t\tassert(expression[base][pos++] == '*');\n\t\tassert(expression[base][pos++] == '.');\n\t\tres = (res * factor(top, base, bottom, pos)) % mod;\n\t}\n\treturn res;\n}\n\nint factor(int top, int base, int bottom, int &pos) {\n\tif(pos + 2 < len && expression[base][pos] == '-') {\n\t\tif(expression[base][pos + 1] == '-') {\n\t\t\treturn fraction(top, base, bottom, pos);\n\t\t}\n\t\t++pos;\n\t\tassert(expression[base][pos++] == '.');\n\t\treturn mod - factor(top, base, bottom, pos);\n\t}\n\treturn powexpr(top, base, bottom, pos);\n}\n\nint powexpr(int top, int base, int bottom, int &pos) {\n\tint res = primary(top, base, bottom, pos);\n\tif(base > 0 && isdigit(expression[base - 1][pos])) {\n\t\tconst int e = expression[base - 1][pos] - '0';\n\t\t++pos;\n\t\tif(e == 0) {\n\t\t\tres = 1;\n\t\t}\n\t\telse {\n\t\t\tconst int tmp = res;\n\t\t\tfor(int i = 1; i < e; ++i) {\n\t\t\t\tres = (res * tmp) % mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint primary(int top, int base, int bottom, int &pos) {\n\tif(isdigit(expression[base][pos])) return expression[base][pos++] - '0';\n\tassert(expression[base][pos++] == '(');\n\tassert(expression[base][pos++] == '.');\n\tconst int res = expr(top, base, bottom, pos);\n\tassert(expression[base][pos++] == '.');\n\tassert(expression[base][pos++] == ')');\n\n\treturn res;\n}\n\nint fraction(int top, int base, int bottom, int &pos) {\n\tint pos_above = pos, pos_under = pos;\n\tconst int base_above = find_base(top, base - 1, pos_above);\n\tconst int base_under = find_base(base + 1, bottom, pos_under);\n\twhile(expression[base][pos] == '-') ++pos;\n\tconst int numerator  = expr(top, base_above, base - 1, pos_above);\n\tconst int denominator = expr(base + 1, base_under, bottom, pos_under);\n\treturn (numerator * inverse[denominator]) % mod;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcalc_inverse();\n\twhile(cin >> n && n) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> expression[i];\n\t\t}\n\n\t\tlen = expression[0].size();\n\t\tconst int top = 0, bottom = n - 1;\n\t\tint pos = 0;\n\t\tconst int base = find_base(top, bottom, pos);\n\t\tcout << expr(top, base, bottom, pos) << endl;\n\t\tassert(pos == len);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1322 ASCII Expression\n// 2018.3.5 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define M\t2011\nint  n, W;\nchar buf[22][85], *p;\n\nint expr(int bs, int tp, int bm);\n\nint powmod(int a, int n)\n{\n\tint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) ans = (ans * a) % M;\n\t\ta = (a * a) % M;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n\nint parse(int c, int tp, int bm)\n{\n\tint bs;\n\tfor ( ; c < W; c++) {\n\t\tfor (bs = tp; bs < bm; bs++) if (buf[bs][c] != '.') goto done;\n\t}\ndone:\n\tp = buf[bs] + c;\n\treturn expr(bs, tp, bm);\n}\n\nint primary(int bs, int tp, int bm)\n{\n\tint x;\n\tif (*p == '(' && *(p+1) == '.') {\n\t\tp += 2, x = expr(bs, tp, bm), p += 2;\n\t} else x = *p++ & 0xf;\n\treturn x;\n}\n\nint powexpr(int bs, int tp, int bm)\n{\n\tint d;\n\tint x = primary(bs, tp, bm);\n\tif (tp <= bs-1 && *p > ' ' && isdigit(d=buf[bs-1][p-buf[bs]])) {\n\t\tx = powmod(x, d & 0xf), p++;\n\t}\n\treturn x;\n}\n\nint factor(int bs, int tp, int bm)\n{\n\tint x, c, si, bo;\n\tif (*p != '-') x = powexpr(bs, tp, bm);\n\telse {\n\t\tif (*(p+1) == '.') {\n\t\t\tp += 2;\n\t\t\tx = M - factor(bs, tp, bm);\n\t\t\tif (x >= M) x -= M;\n\t\t} else {\n\t\t\tc = p-buf[bs];\n\t\t\tsi = parse(c, tp  , bs);\n\t\t\tbo = parse(c, bs+1, bm);\n\t\t\tp = buf[bs]+c;\n\t\t\twhile (*p == '-') p++;\n\t\t\tx = (si * powmod(bo, M-2)) % M;\n\t\t}\n\t}\n\treturn x;\n}\n\nint term(int bs, int tp, int bm)\n{\n\tint x = factor(bs, tp, bm);\n\twhile (*p == '.' && *(p+1) == '*' && *(p+2) == '.') {\n\t\tp += 3;\n\t\tx = (x * factor(bs, tp, bm)) % M;\n\t}\n\treturn x;\n}\n\nint expr(int bs, int tp, int bm)\n{\n\tchar op;\n\tint x = term(bs, tp, bm), y;\n\twhile (*p == '.' && (*(p+1) == '+' || *(p+1) == '-') && *(p+2) == '.') {\n\t\top = *(p+1), p += 3;\n\t\ty = term(bs, tp, bm);\n\t\tif (op == '+') { x += y; if (x >= M) x -= M; }\n\t\telse           { x -= y; if (x < 0 ) x += M; }\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tint r;\n\n\twhile (fgets(p=buf[0], 10, stdin) && *p != '0') {\n\t\tn = atoi(buf[0]);\n\t\tfor (r = 0; r < n; r++) {\n\t\t\tfgets(buf[r], 85, stdin);\n\t\t\tif (!r) { p = buf[0]; while (*p > ' ') p++; W = p-buf[0]; }\n\t\t}\n\t\tprintf(\"%d\\n\", parse(0, 0, n));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\n\npublic static class P\n{\n    public static void Main()\n    {\n        while (true) Solve();\n    }\n\n    static int h, w;\n    static string[] expr;\n\n    public static void Solve()\n    {\n        h = int.Parse(Console.ReadLine());\n        if (h == 0) Environment.Exit(0);\n        expr = Enumerable.Repeat(0, h).Select(_ => Console.ReadLine()).ToArray();\n        w = expr[0].Length;\n        Console.WriteLine(Eval(0, h - 1, 0, w - 1));\n    }\n\n    static ModInt Eval(int ymin, int ymax, int xmin, int xmax)\n    {\n        int baseY = -1;\n        while (true)\n        {\n            for (int i = ymin; i <= ymax; i++)\n            {\n                if (expr[i][xmin] != '.') baseY = i;\n            }\n            if (baseY != -1) break;\n            xmin++;\n        }\n\n        int x = xmin;\n        List<ModInt> nums = new List<ModInt>() { EvalSingleTerm(baseY, ymin, ymax, ref x) };\n        List<char> ops = new List<char>();\n        while (true)\n        {\n            x += 2;\n            if (x > xmax) break;\n            var op = expr[baseY][x];\n            if (op != '+' && op != '-' && op != '*') break;\n            x += 2;\n            if (x > xmax) break;\n            var num = EvalSingleTerm(baseY, ymin, ymax, ref x);\n            if (op == '*') nums[nums.Count - 1] *= num;\n            else\n            {\n                ops.Add(op);\n                nums.Add(num);\n            }\n        }\n\n        var res = nums[0];\n        for (int i = 1; i < nums.Count; i++)\n        {\n            if (ops[i - 1] == '+') res += nums[i];\n            else res -= nums[i];\n        }\n\n        return res;\n    }\n\n    static ModInt EvalSingleTerm(int baseY, int ymin, int ymax, ref int x)\n    {\n        if (expr[baseY][x] == '-')\n        {\n            if (expr[baseY][x + 1] != '-')\n            {\n                x += 2;\n                return -EvalSingleTerm(baseY, ymin, ymax, ref x);\n            }\n            else\n            {\n                var xmin = x + 1;\n                for (; x + 1 < w && expr[baseY][x + 1] == '-'; x++) ;\n                return Eval(ymin, baseY - 1, xmin, x - 1) / Eval(baseY + 1, ymax, xmin, x - 1);\n            }\n        }\n\n        ModInt res;\n        if (expr[baseY][x] == '(')\n        {\n            var depth = 0;\n            var xmin = x + 2;\n            for (; x < w; x++)\n            {\n                if (expr[baseY][x] == '(') depth++;\n                if (expr[baseY][x] == ')') depth--;\n                if (depth == 0) break;\n            }\n            res = Eval(ymin, ymax, xmin, x - 2);\n        }\n        else res = expr[baseY][x] - '0';\n\n        if (ymin <= baseY - 1 && x + 1 < w && expr[baseY - 1][x + 1] != '.') res = Power(res, expr[baseY - 1][++x] - '0');\n        return res;\n    }\n\n    static ModInt Power(ModInt n, long m)\n    {\n        ModInt pow = n;\n        ModInt res = 1;\n        while (m > 0)\n        {\n            if ((m & 1) == 1) res *= pow;\n            pow *= pow;\n            m >>= 1;\n        }\n        return res;\n    }\n}\n\n\nstruct ModInt\n{\n    public const int Mod = 2011;\n    const long POSITIVIZER = ((long)Mod) << 31;\n    long Data;\n    public ModInt(long data) { if ((Data = data % Mod) < 0) Data += Mod; }\n    public static implicit operator long(ModInt modInt) => modInt.Data;\n    public static implicit operator ModInt(long val) => new ModInt(val);\n    public static ModInt operator +(ModInt a, int b) => new ModInt() { Data = (a.Data + b + POSITIVIZER) % Mod };\n    public static ModInt operator +(ModInt a, long b) => new ModInt(a.Data + b);\n    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res >= Mod ? res - Mod : res }; }\n    public static ModInt operator -(ModInt a, int b) => new ModInt() { Data = (a.Data - b + POSITIVIZER) % Mod };\n    public static ModInt operator -(ModInt a, long b) => new ModInt(a.Data - b);\n    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res < 0 ? res + Mod : res }; }\n    public static ModInt operator *(ModInt a, int b) => new ModInt(a.Data * b);\n    public static ModInt operator *(ModInt a, long b) => a * new ModInt(b);\n    public static ModInt operator *(ModInt a, ModInt b) => new ModInt() { Data = a.Data * b.Data % Mod };\n    public static ModInt operator /(ModInt a, ModInt b) => new ModInt() { Data = a.Data * GetInverse(b) % Mod };\n    public static bool operator ==(ModInt a, ModInt b) => a.Data == b.Data;\n    public static bool operator !=(ModInt a, ModInt b) => a.Data != b.Data;\n    public override string ToString() => Data.ToString();\n    public override bool Equals(object obj) => (ModInt)obj == this;\n    public override int GetHashCode() => (int)Data;\n    static long GetInverse(long a)\n    {\n        long div, p = Mod, x1 = 1, y1 = 0, x2 = 0, y2 = 1;\n        while (true)\n        {\n            if (p == 1) return x2 + Mod; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;\n            if (a == 1) return x1 + Mod; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMOD = 2011\n\n### subroutines\n\ndef get_base(strs, topl, btml)\n  base = nil\n  while base.nil?\n    for y in (topl..btml)\n      if strs[y][$pos] != '.'\n        base = y\n        break\n      end\n    end\n    $pos += 1 if base.nil?\n  end\n  base\nend\n\ndef expr(strs, topl, btml, base = nil)\n  #p [\"expr\", topl, btml, base, $pos]\n\n  base = get_base(strs, topl, btml) if base.nil?\n  \n  v = term(strs, topl, btml, base)\n  op = strs[base][$pos + 1]\n  while op == '+' || op == '-'\n    $pos += 3\n    v0 = term(strs, topl, btml, base)\n    v = (op == '+') ? (v + v0) % MOD : (v - v0) % MOD\n    op = strs[base][$pos + 1]\n  end\n\n  #p [\"  expr\", v, base]\n  v\nend\n\ndef term(strs, topl, btml, base)\n  #p [\"term\", topl, btml, base, $pos]\n\n  v = factor(strs, topl, btml, base)\n  while strs[base][$pos + 1] == '*'\n    $pos += 3\n    v0 = factor(strs, topl, btml, base)\n    v = (v * v0) % MOD\n  end\n\n  #p [\"  term\", v, $pos]\n  v\nend\n\ndef factor(strs, topl, btml, base)\n  #p [\"factor\", topl, btml, base, $pos]\n\n  v = nil\n  if strs[base][$pos, 2] == '--'\n    v = fraction(strs, topl, btml, base)\n  elsif strs[base][$pos, 2] == '-.'\n    $pos += 2\n    v = MOD - factor(strs, topl, btml, base)\n  else\n    v = powexpr(strs, topl, btml, base)\n  end\n\n  #p [\"  factor\", v, $pos]\n  v\nend\n\ndef powexpr(strs, topl, btml, base)\n  #p [\"powexpr\", topl, btml, base, $pos]\n\n  v = primary(strs, topl, btml, base)\n\n  if base > 0 && strs[base - 1][$pos] =~ /[0-9]/\n    n = digit(strs, topl, btml, base - 1)\n\n    pm = 1\n    while n > 0\n      pm = (pm * v) % MOD if (n & 1) == 1\n      v = (v * v) % MOD\n      n >>= 1\n    end\n\n    v = pm\n  end\n\n  #p [\"  powexpr\", v, $pos]\n  v\nend\n\ndef primary(strs, topl, btml, base)\n  #p [\"primary\", topl, btml, base, $pos]\n\n  v = nil\n  if strs[base][$pos] == '('\n    $pos += 2\n    v = expr(strs, topl, btml, base)\n    $pos += 2\n  else\n    v = digit(strs, topl, btml, base)\n  end\n\n  #p [\"  primary\", v, $pos]\n  v\nend\n\ndef fraction(strs, topl, btml, base)\n  #p [\"fraction\", topl, btml, base, $pos]\n\n  pos0 = $pos\n  v0 = expr(strs, topl, base - 1)\n  $pos = pos0\n  v1 = expr(strs, base + 1, btml)\n  $pos = pos0\n  v = (v0 * $invs[v1]) % MOD\n\n  while strs[base][$pos] == '-'\n    $pos += 1\n  end\n\n  #p [\"  fraction\", v, $pos]\n  v\nend\n\ndef digit(strs, topl, btml, base)\n  #p [\"digit\", topl, btml, base, $pos]\n\n  v = strs[base][$pos].to_i\n  $pos += 1\n\n  #p [\"  digit\", v, $pos]\n  v\nend\n\n### main\n\n$invs = Array.new(MOD){0}\nfor y in (1...MOD)\n  for z in (1...MOD)\n    if (y * z) % MOD == 1\n      $invs[y] = z\n      break\n    end\n  end\nend\n#p $invs; exit\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  strs = Array.new(n){gets.strip}\n  #p strs\n\n  $pos = 0\n  p expr(strs, 0, n - 1)\nend"
  },
  {
    "language": "Ruby",
    "code": "$inv = (0..2011).map {0}\n(1..2010).map do |x|\n    (1..2010).each do |y|\n        if x * y % 2011 == 1\n            $inv[x] = y\n            break\n        end\n    end\nend\n\ndef trim(a, i1, i2, j1, j2)\n    i1 += 1 while i1 < i2 && (j1..j2).all? {|j| a[i1][j] == ?.}\n    i2 -= 1 while i1 < i2 && (j1..j2).all? {|j| a[i2][j] == ?.}\n    j1 += 1 while j1 < j2 && (i1..i2).all? {|i| a[i][j1] == ?.}\n    j2 -= 1 while j1 < j2 && (i1..i2).all? {|i| a[i][j2] == ?.}\n    return [a, i1, i2, j1, j2]\nend\n\ndef index_single(a, i1, i2, j, c)\n    x = nil\n    (i1..i2).each do |i|\n        next if a[i][j] == ?.\n        return nil unless a[i][j] === c\n        return nil if x\n        x = i\n    end\n\n    return x\nend\n\ndef exp(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = term(a, i1, i2, j1, j2)\n    return x if x\n\n    (j2-1).downto(j1+1).each do |j|\n        op = (i1..i2).map {|i| a[i][j]} - [?.]\n        next unless op.size == 1\n        next unless op[0] == ?+ || op[0] == ?-\n        next unless (i1..i2).all? {|i| a[i][j+1] == ?.}\n        next unless (i1..i2).all? {|i| a[i][j-1] == ?.}\n        x = exp(a, i1, i2, j1, j-2)\n        next unless x\n        y = term(a, i1, i2, j+2, j2)\n        next unless y\n        if op[0] == ?+\n            return (x + y) % 2011\n        else\n            return (x - y) % 2011\n        end\n    end\n\n    nil\nend\n\ndef term(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = factor(a, i1, i2, j1, j2)\n    return x if x\n\n    (j1+1..j2-1).each do |j|\n        next unless index_single(a, i1, i2, j, ?*)\n        next unless (i1..i2).all? {|i| a[i][j+1] == ?.}\n        next unless (i1..i2).all? {|i| a[i][j-1] == ?.}\n        x = factor(a, i1, i2, j1, j-2)\n        next unless x\n        y = term(a, i1, i2, j+2, j2)\n        next unless y\n        return x * y % 2011\n    end\n\n    nil\nend\n\ndef factor(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = powexpr(a, i1, i2, j1, j2)\n    return x if x\n\n    x = fraction(a, i1, i2, j1, j2)\n    return x if x\n\n    return nil unless index_single(a, i1, i2, j1, ?-)\n    return nil unless (i1..i2).all? {|i| a[i][j1+1] == ?.}\n\n    x = factor(a, i1, i2, j1+2, j2)\n    return -x % 2011 if x\n\n    nil\nend\n\ndef powexpr(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = primary(a, i1, i2, j1, j2)\n    return x if x\n\n    return nil unless (i1..i2).select {|i| a[i][j2] != ?.}.size == 1\n    i = (i1..i2).find {|i| a[i][j2] != ?.}\n    return nil unless a[i][j2] =~ /\\d/\n\n    x = primary(a, i1, i2, j1, j2-1, i+1)\n    return x ** a[i][j2].to_i % 2011 if x\n\n    nil\nend\n\ndef fraction(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n\n    return nil unless (i1..i2).map {|i| a[i][j1]} - [?.] == [?-]\n    return nil unless (i1..i2).map {|i| a[i][j2]} - [?.] == [?-]\n    base_l = (i1..i2).find {|i| a[i][j1] == ?-}\n    base_r = (i1..i2).find {|i| a[i][j2] == ?-}\n    return nil unless base_l == base_r\n    return nil unless (j1..j2).all? {|j| a[base_l][j] == ?-}\n\n    x = exp(a, i1, base_l-1, j1+1, j2-1)\n    return nil unless x\n    y = exp(a, base_l+1, i2, j1+1, j2-1)\n    return nil unless y\n    return nil if y == 0\n\n    x * $inv[y] % 2011\nend\n\ndef primary(a, i1, i2, j1, j2, base = nil)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n\n    if i1 == i2 && j1 == j2\n        if a[i1][j1] =~ /\\d/ && (base == nil || i1 == base)\n            return a[i1][j1].to_i\n        else\n            return nil\n        end\n    end\n\n    l = index_single(a, i1, i2, j1, ?()\n    return nil unless l\n    r = index_single(a, i1, i2, j2, ?))\n    return nil unless r\n    return nil unless l == r\n    return nil unless base == nil || l == base\n\n    return exp(a, i1, i2, j1+1, j2-1)\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    a = (1..n).map { gets.chomp }\n\n    p exp(a, 0, n-1, 0, a[0].size-1)\nend"
  },
  {
    "language": "Ruby",
    "code": "$inv = (0..2011).map {0}\n(1..2010).map do |x|\n    (1..2010).each do |y|\n        if x * y % 2011 == 1\n            $inv[x] = y\n            break\n        end\n    end\nend\n\ndef trim(a, i1, i2, j1, j2)\n    i1 += 1 while i1 < i2 && (j1..j2).all? {|j| a[i1][j] == ?.}\n    i2 -= 1 while i1 < i2 && (j1..j2).all? {|j| a[i2][j] == ?.}\n    j1 += 1 while j1 < j2 && (i1..i2).all? {|i| a[i][j1] == ?.}\n    j2 -= 1 while j1 < j2 && (i1..i2).all? {|i| a[i][j2] == ?.}\n    return [a, i1, i2, j1, j2]\nend\n\ndef exp(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = term(a, i1, i2, j1, j2)\n    return x if x\n\n    (j2-1).downto(j1+1).each do |j|\n        op = (i1..i2).map {|i| a[i][j]} - [?.]\n        next unless op.size == 1\n        next unless op[0] == ?+ || op[0] == ?-\n        x = exp(a, i1, i2, j1, j-1)\n        next unless x\n        y = term(a, i1, i2, j+1, j2)\n        next unless y\n        if op[0] == ?+\n            return (x + y) % 2011\n        else\n            return (x - y) % 2011\n        end\n    end\n\n    nil\nend\n\ndef term(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = factor(a, i1, i2, j1, j2)\n    return x if x\n\n    (j1+1..j2-1).each do |j|\n        op = (i1..i2).map {|i| a[i][j]} - [?.]\n        next unless op == [?*]\n        x = factor(a, i1, i2, j1, j-1)\n        next unless x\n        y = term(a, i1, i2, j+1, j2)\n        next unless y\n        return x * y % 2011\n    end\n\n    nil\nend\n\ndef factor(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = powexpr(a, i1, i2, j1, j2)\n    return x if x\n\n    x = fraction(a, i1, i2, j1, j2)\n    return x if x\n\n    if (i1..i2).map {|i| a[i][j1]} - [?.] == [?-]\n        if (i1..i2).all? {|i| a[i][j1+1] == ?.}\n            x = factor(a, i1, i2, j1+2, j2)\n            return -x % 2011 if x\n        end\n    end\n\n    nil\nend\n\ndef powexpr(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n    x = primary(a, i1, i2, j1, j2)\n    return x if x\n\n    return nil unless (i1..i2).select {|i| a[i][j2] != ?.}.size == 1\n    i = (i1..i2).find {|i| a[i][j2] != ?.}\n    return nil unless a[i][j2] =~ /\\d/\n\n    x = primary(a, i1, i2, j1, j2-1, i+1)\n    return x ** a[i][j2].to_i % 2011 if x\n\n    nil\nend\n\ndef fraction(a, i1, i2, j1, j2)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n\n    return nil unless (i1..i2).map {|i| a[i][j1]} - [?.] == [?-]\n    return nil unless (i1..i2).map {|i| a[i][j2]} - [?.] == [?-]\n    base_l = (i1..i2).find {|i| a[i][j1] == ?-}\n    base_r = (i1..i2).find {|i| a[i][j2] == ?-}\n    return nil unless base_l == base_r\n    return nil unless (j1..j2).all? {|j| a[base_l][j] == ?-}\n\n    x = exp(a, i1, base_l-1, j1+1, j2-1)\n    return nil unless x\n    y = exp(a, base_l+1, i2, j1+1, j2-1)\n    return nil unless y\n    return nil if y == 0\n\n    x * $inv[y] % 2011\nend\n\ndef primary(a, i1, i2, j1, j2, base = nil)\n    return nil if i1 > i2 || j1 > j2\n    a, i1, i2, j1, j2 = trim(a, i1, i2, j1, j2)\n\n    if i1 == i2 && j1 == j2\n        if a[i1][j1] =~ /\\d/ && (base == nil || i1 == base)\n            return a[i1][j1].to_i\n\n        else\n            return nil\n        end\n    end\n\n    return nil unless (i1..i2).map {|i| a[i][j1]} - [?.] == [?(]\n    return nil unless (i1..i2).map {|i| a[i][j2]} - [?.] == [?)]\n\n    return exp(a, i1, i2, j1+1, j2-1)\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    a = (1..n).map { gets.chomp }\n\n    p exp(a, 0, n-1, 0, a[0].size-1)\nend"
  },
  {
    "language": "Python",
    "code": "MOD = 2011\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    S = [input() for i in range(n)]\n    w = len(S[0])\n\n    def parse(bcur, bright, top, bottom):\n        #print(\"parse\", bcur, bright, top, bottom)\n        base = -1\n        for i in range(bcur, bright):\n            for j in range(top, bottom+1):\n                if S[j][i] != '.':\n                    base = j\n                    break\n            if base != -1:\n                break\n        cur = bcur\n        def read():\n            nonlocal cur\n            c = None\n            while 0 <= base < n and cur < bright:\n                #print(\"cur\", base, cur, bright)\n                #print(S[base][cur:])\n                c = S[base][cur]\n                if c != '.':\n                    break\n                cur += 1\n            return c\n        def fraction():\n            nonlocal cur\n            #print(\"fraction\", cur, top, bottom)\n            left = cur\n            while cur < w and S[base][cur] == '-':\n                cur += 1\n            right = cur+1 if cur < w else cur\n            dividend = parse(left, right, top, base-1)\n            divisor = parse(left, right, base+1, bottom)\n            #print(\"deb\", S[base][cur:], dividend, divisor)\n            #print(\"<fraction\", dividend, divisor, (dividend * pow(divisor, MOD-2, MOD)) % MOD)\n            return (dividend * pow(divisor, MOD-2, MOD)) % MOD\n        def primary():\n            nonlocal cur\n            #print(\"primary\", cur, top, bottom)\n            c = read()\n            if c == '(':\n                cur += 1 # '('\n                v = expr()\n                cur += 1 # ')'\n                #print(\"<primary\", v)\n                return v\n            else:\n                cur += 1 # digit\n                #print(\"<primary\", c)\n                return int(c)\n        def powexpr():\n            nonlocal cur\n            #print(\"powexpr\", cur, top, bottom)\n            v = primary()\n            #print(\"<powexpr\", cur, base, v)\n            if 0 < base and cur < bright and S[base-1][cur] in \"0123456789\":\n                #print(\"abc\", v, int(S[base-1][cur]))\n                return pow(v, int(S[base-1][cur]), MOD)\n            return v\n        def factor():\n            nonlocal cur\n            #print(\"factor\", cur, top, bottom)\n            c = read()\n            if c == '-':\n                if S[base][cur+1] == '.':\n                    cur += 1 # '-'\n                    return -factor()\n                else:\n                    return fraction()\n            return powexpr()\n\n        def term():\n            nonlocal cur\n            #print(\"term\", cur, top, bottom)\n            result = 1\n            while 1:\n                v = factor()\n                result *= v\n                result %= MOD\n                c = read()\n                if c != '*':\n                    break\n                cur += 1\n            return result\n\n        def expr():\n            nonlocal cur\n            #print(\"expr\", cur, top, bottom)\n            op = '+'\n            result = 0\n            while 1:\n                v = term()\n                #print(\"<expr\", v)\n                c = read()\n                result += v if op == '+' else MOD-v\n                result %= MOD\n                if not c or c not in '+-':\n                    #print(\"break\", result, v, c, op)\n                    break\n                cur += 1\n                op = c\n            #print(\"<result\", result)\n            return result\n        v = expr()\n        #print(\"<parse\", v)\n        return v\n    print(parse(0, w, 0, n-1))"
  }
]