[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MOD 2011\n\ntypedef struct {\n    char **lines;\n    int line_count;\n    int width;\n} Expression;\n\nint mod_pow(int base, int exp) {\n    int result = 1;\n    base %= MOD;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        exp = exp >> 1;\n        base = (base * base) % MOD;\n    }\n    return result;\n}\n\nint mod_inverse(int a) {\n    a %= MOD;\n    for (int x = 1; x < MOD; x++) {\n        if ((a * x) % MOD == 1) {\n            return x;\n        }\n    }\n    return -1;\n}\n\nint evaluate_expression(Expression *expr, int start_row, int end_row, int start_col, int end_col);\n\nint parse_number(Expression *expr, int row, int *col) {\n    int num = 0;\n    while (*col < expr->width && isdigit(expr->lines[row][*col])) {\n        num = num * 10 + (expr->lines[row][*col] - '0');\n        (*col)++;\n    }\n    return num % MOD;\n}\n\nint evaluate_term(Expression *expr, int start_row, int end_row, int start_col, int end_col) {\n    for (int row = start_row; row <= end_row; row++) {\n        for (int col = start_col; col <= end_col; col++) {\n            if (expr->lines[row][col] == '^') {\n                int base_row = row;\n                while (base_row > start_row && expr->lines[base_row - 1][col] == '|') {\n                    base_row--;\n                }\n                int exp_row = row + 1;\n                while (exp_row < end_row && expr->lines[exp_row][col] == '|') {\n                    exp_row++;\n                }\n                int base = evaluate_expression(expr, base_row, row - 1, start_col, end_col);\n                int exp = evaluate_expression(expr, row + 1, exp_row, start_col, end_col);\n                return mod_pow(base, exp);\n            }\n        }\n    }\n\n    for (int row = start_row; row <= end_row; row++) {\n        for (int col = start_col; col <= end_col; col++) {\n            if (expr->lines[row][col] == '-') {\n                int left_col = col - 1;\n                while (left_col >= start_col && expr->lines[row][left_col] == '-') {\n                    left_col--;\n                }\n                int right_col = col + 1;\n                while (right_col <= end_col && expr->lines[row][right_col] == '-') {\n                    right_col++;\n                }\n                if (left_col >= start_col && right_col <= end_col && expr->lines[row][left_col] == '/' && expr->lines[row][right_col] == '\\\\') {\n                    int numerator = evaluate_expression(expr, start_row, row - 1, start_col, end_col);\n                    int denominator = evaluate_expression(expr, row + 1, end_row, start_col, end_col);\n                    int inv_denominator = mod_inverse(denominator);\n                    if (inv_denominator == -1) return 0;\n                    return (numerator * inv_denominator) % MOD;\n                }\n            }\n        }\n    }\n\n    for (int col = start_col; col <= end_col; col++) {\n        for (int row = start_row; row <= end_row; row++) {\n            if (expr->lines[row][col] == '+' || expr->lines[row][col] == '-' || expr->lines[row][col] == '*') {\n                int left = evaluate_expression(expr, start_row, end_row, start_col, col - 1);\n                int right = evaluate_expression(expr, start_row, end_row, col + 1, end_col);\n                if (expr->lines[row][col] == '+') return (left + right) % MOD;\n                if (expr->lines[row][col] == '-') return (left - right + MOD) % MOD;\n                if (expr->lines[row][col] == '*') return (left * right) % MOD;\n            }\n        }\n    }\n\n    for (int row = start_row; row <= end_row; row++) {\n        for (int col = start_col; col <= end_col; col++) {\n            if (isdigit(expr->lines[row][col])) {\n                int num = 0;\n                while (col <= end_col && isdigit(expr->lines[row][col])) {\n                    num = num * 10 + (expr->lines[row][col] - '0');\n                    col++;\n                }\n                return num % MOD;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint evaluate_expression(Expression *expr, int start_row, int end_row, int start_col, int end_col) {\n    if (start_row > end_row || start_col > end_col) return 0;\n    return evaluate_term(expr, start_row, end_row, start_col, end_col);\n}\n\nExpression read_expression() {\n    Expression expr;\n    expr.line_count = 0;\n    expr.width = 0;\n    expr.lines = NULL;\n    char line[1024];\n\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break;\n        size_t len = strlen(line);\n        if (line[len - 1] == '\\n') line[len - 1] = '\\0';\n        expr.line_count++;\n        expr.lines = realloc(expr.lines, expr.line_count * sizeof(char *));\n        expr.lines[expr.line_count - 1] = strdup(line);\n        if (strlen(line) > expr.width) {\n            expr.width = strlen(line);\n        }\n    }\n\n    return expr;\n}\n\nvoid free_expression(Expression *expr) {\n    for (int i = 0; i < expr->line_count; i++) {\n        free(expr->lines[i]);\n    }\n    free(expr->lines);\n}\n\nint main() {\n    while (1) {\n        Expression expr = read_expression();\n        if (expr.line_count == 0) break;\n        int result = evaluate_expression(&expr, 0, expr.line_count - 1, 0, expr.width - 1);\n        printf(\"%d\\n\", result);\n        free_expression(&expr);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int MOD = 2011;\n\nint mod_pow(int base, int exp) {\n    int result = 1;\n    base %= MOD;\n    while (exp > 0) {\n        if (exp % 2 == 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nint evaluate_fraction(const string &num_str, const string &den_str) {\n    int num = stoi(num_str) % MOD;\n    int den = stoi(den_str) % MOD;\n    if (den == 0) return 0;\n    int inverse_den = mod_pow(den, MOD - 2);\n    return (num * inverse_den) % MOD;\n}\n\nint evaluate_expression(const vector<string> &lines) {\n    stack<int> values;\n    stack<char> ops;\n    string expr;\n    for (const string &line : lines) {\n        expr += line;\n    }\n    expr.erase(remove(expr.begin(), expr.end(), ' '), expr.end());\n\n    for (int i = 0; i < expr.size(); ++i) {\n        if (isdigit(expr[i])) {\n            int num = 0;\n            while (i < expr.size() && isdigit(expr[i])) {\n                num = num * 10 + (expr[i] - '0');\n                ++i;\n            }\n            --i;\n            values.push(num % MOD);\n        } else if (expr[i] == '(') {\n            ops.push(expr[i]);\n        } else if (expr[i] == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                int val2 = values.top(); values.pop();\n                int val1 = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                if (op == '+') values.push((val1 + val2) % MOD);\n                else if (op == '-') values.push((val1 - val2 + MOD) % MOD);\n                else if (op == '*') values.push((val1 * val2) % MOD);\n                else if (op == '^') values.push(mod_pow(val1, val2));\n            }\n            ops.pop();\n        } else {\n            while (!ops.empty() && ops.top() != '(' && \n                   ((expr[i] != '^' && (ops.top() == '*' || ops.top() == '/' || ops.top() == '^')) ||\n                    (expr[i] == '^' && ops.top() == '^'))) {\n                int val2 = values.top(); values.pop();\n                int val1 = values.top(); values.pop();\n                char op = ops.top(); ops.pop();\n                if (op == '+') values.push((val1 + val2) % MOD);\n                else if (op == '-') values.push((val1 - val2 + MOD) % MOD);\n                else if (op == '*') values.push((val1 * val2) % MOD);\n                else if (op == '^') values.push(mod_pow(val1, val2));\n                else if (op == '/') {\n                    if (val2 == 0) values.push(0);\n                    else {\n                        int inv = mod_pow(val2, MOD - 2);\n                        values.push((val1 * inv) % MOD);\n                    }\n                }\n            }\n            ops.push(expr[i]);\n        }\n    }\n\n    while (!ops.empty()) {\n        int val2 = values.top(); values.pop();\n        int val1 = values.top(); values.pop();\n        char op = ops.top(); ops.pop();\n        if (op == '+') values.push((val1 + val2) % MOD);\n        else if (op == '-') values.push((val1 - val2 + MOD) % MOD);\n        else if (op == '*') values.push((val1 * val2) % MOD);\n        else if (op == '^') values.push(mod_pow(val1, val2));\n        else if (op == '/') {\n            if (val2 == 0) values.push(0);\n            else {\n                int inv = mod_pow(val2, MOD - 2);\n                values.push((val1 * inv) % MOD);\n            }\n        }\n    }\n\n    return values.top();\n}\n\nint main() {\n    int T;\n    cin >> T;\n    cin.ignore();\n    while (T--) {\n        vector<string> lines;\n        string line;\n        while (getline(cin, line)) {\n            if (line.empty()) break;\n            lines.push_back(line);\n        }\n        cout << evaluate_expression(lines) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ASCIICalculator {\n    static final int MOD = 2011;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            if (line.trim().isEmpty()) continue;\n            int n = Integer.parseInt(line.trim());\n            if (n == 0) break;\n            List<String> expression = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                expression.add(br.readLine());\n            }\n            int result = evaluateExpression(expression);\n            System.out.println(result);\n        }\n    }\n\n    static int evaluateExpression(List<String> expression) {\n        String flat = flattenExpression(expression);\n        return evaluateFlatExpression(flat);\n    }\n\n    static String flattenExpression(List<String> expression) {\n        StringBuilder sb = new StringBuilder();\n        int maxLen = 0;\n        for (String s : expression) {\n            maxLen = Math.max(maxLen, s.length());\n        }\n        for (int i = 0; i < maxLen; i++) {\n            for (String s : expression) {\n                if (i < s.length()) {\n                    char c = s.charAt(i);\n                    if (c != ' ') {\n                        sb.append(c);\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    static int evaluateFlatExpression(String expr) {\n        expr = expr.replaceAll(\"\\\\s+\", \"\");\n        if (expr.isEmpty()) return 0;\n        Stack<Integer> numbers = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (Character.isDigit(c)) {\n                int num = 0;\n                while (i < expr.length() && Character.isDigit(expr.charAt(i))) {\n                    num = num * 10 + (expr.charAt(i) - '0');\n                    i++;\n                }\n                i--;\n                numbers.push(num % MOD);\n            } else if (c == '(') {\n                ops.push(c);\n            } else if (c == ')') {\n                while (ops.peek() != '(') {\n                    numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n                }\n                ops.pop();\n            } else if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^') {\n                while (!ops.isEmpty() && precedence(ops.peek()) >= precedence(c)) {\n                    numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n                }\n                ops.push(c);\n            }\n        }\n        while (!ops.isEmpty()) {\n            numbers.push(applyOp(ops.pop(), numbers.pop(), numbers.pop()));\n        }\n        return numbers.isEmpty() ? 0 : numbers.pop();\n    }\n\n    static int precedence(char op) {\n        switch (op) {\n            case '^': return 4;\n            case '*':\n            case '/': return 3;\n            case '+':\n            case '-': return 2;\n            default: return 0;\n        }\n    }\n\n    static int applyOp(char op, int b, int a) {\n        switch (op) {\n            case '+': return (a + b) % MOD;\n            case '-': return (a - b + MOD) % MOD;\n            case '*': return (a * b) % MOD;\n            case '/': return (a * modInverse(b)) % MOD;\n            case '^': return pow(a, b);\n            default: return 0;\n        }\n    }\n\n    static int modInverse(int a) {\n        a %= MOD;\n        for (int x = 1; x < MOD; x++) {\n            if ((a * x) % MOD == 1) {\n                return x;\n            }\n        }\n        return 1;\n    }\n\n    static int pow(int a, int b) {\n        if (b == 0) return 1;\n        a %= MOD;\n        if (b == 1) return a;\n        if (b % 2 == 0) {\n            int half = pow(a, b / 2);\n            return (half * half) % MOD;\n        } else {\n            return (a * pow(a, b - 1)) % MOD;\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:53:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ASCIIExpressionEvaluator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int i = 0; i < datasets; i++) {\n            List<String> expression = new ArrayList<>();\n            String line;\n            while (!(line = scanner.nextLine()).isEmpty()) {\n                expression.add(line);\n            }\n            System.out.println(evaluateExpression(expression));\n        }\n    }\n\n    private static int evaluateExpression(List<String> expression) {\n        int height = expression.size();\n        int width = expression.get(0).length();\n        \n        int[][] grid = new int[height][width];\n        boolean[][] visited = new boolean[height][width];\n        \n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                grid[i][j] = expression.get(i).charAt(j) - '0';\n            }\n        }\n        \n        return parseExpression(grid, visited, 0, 0);\n    }\n\n    private static int parseExpression(int[][] grid, boolean[][] visited, int row, int col) {\n        if (row >= grid.length || col >= grid[0].length || visited[row][col]) {\n            return 0;\n        }\n        \n        visited[row][col] = true;\n        \n        if (Character.isDigit(grid[row][col] + '0')) {\n            return grid[row][col];\n        }\n        \n        char operator = (char) (grid[row][col] + '0');\n        int left = findNumber(grid, visited, row, col - 1);\n        int right = findNumber(grid, visited, row, col + 1);\n        \n        switch (operator) {\n            case '+':\n                return (left + right) % 2011;\n            case '-':\n                return (left - right + 2011) % 2011;\n            case '*':\n                return (left * right) % 2011;\n            case '^':\n                return fastPow(left, right);\n            case '/':\n                return (left * modInverse(right, 2011)) % 2011;\n        }\n        \n        return 0;\n    }\n\n    private static int findNumber(int[][] grid, boolean[][] visited, int row, int col) {\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || visited[row][col]) {\n            return 0;\n        }\n        \n        int num = 0;\n        while (col >= 0 && Character.isDigit(grid[row][col] + '0')) {\n            num = num * 10 + grid[row][col];\n            visited[row][col] = true;\n            col--;\n        }\n        \n        return reverseNumber(num);\n    }\n\n    private static int reverseNumber(int num) {\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n        return reversed;\n    }\n\n    private static int fastPow(int base, int exp) {\n        int result = 1;\n        base %= 2011;\n        while (exp > 0) {\n            if ((exp & 1) == 1) {\n                result = (result * base) % 2011;\n            }\n            base = (base * base) % 2011;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    private static int modInverse(int a, int m) {\n        int m0 = m;\n        int y = 0, x = 1;\n\n        if (m == 1) return 0;\n\n        while (a > 1) {\n            int q = a / m;\n            int t = m;\n\n            m = a % m;\n            a = t;\n            t = y;\n\n            y = x - q * y;\n            x = t;\n        }\n\n        if (x < 0) x += m0;\n        return x;\n    }\n}",
    "timestamp": "2025-08-05 20:53:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define MAX_LINES 100\n#define MAX_LINE_LENGTH 1000\n#define MOD 2011\n\nint evaluate_expression(char lines[][MAX_LINE_LENGTH], int num_lines);\nint parse_number(char* line, int* pos);\nint parse_expression(char lines[][MAX_LINE_LENGTH], int num_lines, int* line_idx, int* pos);\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    getchar(); // consume newline\n\n    for (int d = 0; d < datasets; d++) {\n        char lines[MAX_LINES][MAX_LINE_LENGTH];\n        int num_lines = 0;\n        \n        // Read lines until empty line\n        while (1) {\n            fgets(lines[num_lines], MAX_LINE_LENGTH, stdin);\n            if (lines[num_lines][0] == '\\n') break;\n            lines[num_lines][strcspn(lines[num_lines], \"\\n\")] = 0;\n            num_lines++;\n        }\n\n        int result = evaluate_expression(lines, num_lines);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}\n\nint parse_number(char* line, int* pos) {\n    int num = 0;\n    while (isdigit(line[*pos])) {\n        num = num * 10 + (line[*pos] - '0');\n        (*pos)++;\n    }\n    return num;\n}\n\nint power_mod(int base, int exp) {\n    int result = 1;\n    base %= MOD;\n    \n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % MOD;\n        base = (base * base) % MOD;\n        exp >>= 1;\n    }\n    \n    return result;\n}\n\nint parse_expression(char lines[][MAX_LINE_LENGTH], int num_lines, int* line_idx, int* pos) {\n    int value = 0;\n    int sign = 1;\n    \n    while (*line_idx < num_lines) {\n        char* line = lines[*line_idx];\n        \n        while (line[*pos] != '\\0') {\n            if (line[*pos] == ' ') {\n                (*pos)++;\n                continue;\n            }\n            \n            if (line[*pos] == '-') {\n                sign = -1;\n                (*pos)++;\n                continue;\n            }\n            \n            if (line[*pos] == '+') {\n                sign = 1;\n                (*pos)++;\n                continue;\n            }\n            \n            if (isdigit(line[*pos])) {\n                int num = parse_number(line, pos);\n                \n                // Check for exponentiation\n                if (line[*pos] == '^') {\n                    (*pos)++;\n                    int exp = parse_number(line, pos);\n                    num = power_mod(num, exp);\n                }\n                \n                // Check for fraction\n                if (line[*pos] == '/') {\n                    (*pos)++;\n                    int denom = parse_number(line, pos);\n                    \n                    // Modular multiplicative inverse\n                    int inv = power_mod(denom, MOD - 2);\n                    num = (num * inv) % MOD;\n                }\n                \n                value = (value + sign * num + MOD) % MOD;\n                sign = 1;\n            }\n            \n            if (line[*pos] == '\\0') {\n                (*line_idx)++;\n                *pos = 0;\n                break;\n            }\n            \n            (*pos)++;\n        }\n        \n        if (*line_idx >= num_lines) break;\n    }\n    \n    return value;\n}\n\nint evaluate_expression(char lines[][MAX_LINE_LENGTH], int num_lines) {\n    int line_idx = 0;\n    int pos = 0;\n    \n    return parse_expression(lines, num_lines, &line_idx, &pos);\n}",
    "timestamp": "2025-08-05 20:53:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nclass AsciiExpressionEvaluator {\nprivate:\n    int mod = 2011;\n\n    int evaluate(const vector<string>& expression) {\n        int result = 0;\n        bool add = true;\n\n        for (const string& token : expression) {\n            if (token == \"+\") {\n                add = true;\n            } else if (token == \"-\") {\n                add = false;\n            } else {\n                int value = processToken(token);\n                result = add ? (result + value) % mod : (result - value + mod) % mod;\n            }\n        }\n        return result;\n    }\n\n    int processToken(const string& token) {\n        if (token.find('^') != string::npos) {\n            return handleExponent(token);\n        }\n        if (token.find('/') != string::npos) {\n            return handleFraction(token);\n        }\n        return stoi(token);\n    }\n\n    int handleExponent(const string& token) {\n        size_t pos = token.find('^');\n        int base = stoi(token.substr(0, pos));\n        int exp = stoi(token.substr(pos + 1));\n        return powMod(base, exp);\n    }\n\n    int handleFraction(const string& token) {\n        size_t pos = token.find('/');\n        int numerator = stoi(token.substr(0, pos));\n        int denominator = stoi(token.substr(pos + 1));\n        return (numerator * modInverse(denominator)) % mod;\n    }\n\n    int powMod(int base, int exp) {\n        int result = 1;\n        base %= mod;\n        while (exp > 0) {\n            if (exp & 1) {\n                result = (result * base) % mod;\n            }\n            base = (base * base) % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n\n    int modInverse(int a) {\n        return powMod(a, mod - 2);\n    }\n\npublic:\n    int processExpression(const vector<string>& expression) {\n        return evaluate(expression);\n    }\n};\n\nint main() {\n    int T;\n    cin >> T;\n\n    for (int t = 1; t <= T; t++) {\n        string line;\n        vector<string> tokens;\n        \n        while (getline(cin, line) && !line.empty()) {\n            stringstream ss(line);\n            string token;\n            while (ss >> token) {\n                tokens.push_back(token);\n            }\n        }\n\n        AsciiExpressionEvaluator evaluator;\n        int result = evaluator.processExpression(tokens);\n        \n        cout << \"Dataset \" << t << \": \" << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_expression(expression):\n    token_stack = []\n    operator_stack = []\n    precedence = {'+': 1, '-': 1, '*': 2}\n    def apply_operator():\n        right = token_stack.pop()\n        left = token_stack.pop()\n        op = operator_stack.pop()\n        if op == '+':\n            token_stack.append((left + right) % 2011)\n        elif op == '-':\n            token_stack.append((left - right) % 2011)\n        elif op == '*':\n            token_stack.append((left * right) % 2011)\n\n    i = 0\n    while i < len(expression):\n        if expression[i].isdigit():\n            num = 0\n            while i < len(expression) and expression[i].isdigit():\n                num = num * 10 + int(expression[i])\n                i += 1\n            token_stack.append(num % 2011)\n        elif expression[i] in precedence:\n            while (operator_stack and\n                   precedence[operator_stack[-1]] >= precedence[expression[i]]):\n                apply_operator()\n            operator_stack.append(expression[i])\n            i += 1\n        else:\n            i += 1\n\n    while operator_stack:\n        apply_operator()\n\n    return token_stack[0]\n\ndef parse_ascii_expression(ascii_lines):\n    combined_expr = ''.join(line.strip() for line in ascii_lines)\n    return evaluate_expression(combined_expr)\n\ndef process_datasets(datasets):\n    results = []\n    for ascii_expression in datasets:\n        result = parse_ascii_expression(ascii_expression)\n        results.append(result)\n    return results\n\nif __name__ == '__main__':\n    import sys\n    input_data = sys.stdin.readlines()\n    dataset_count = int(input_data[0].strip())\n    current_line = 1\n    expressions = []\n    \n    for _ in range(dataset_count):\n        expression_lines = []\n        while current_line < len(input_data) and input_data[current_line].strip() != \"\":\n            expression_lines.append(input_data[current_line])\n            current_line += 1\n        expressions.append(expression_lines)\n        current_line += 1\n    \n    results = process_datasets(expressions)\n    for result in results:\n        print(result)",
    "timestamp": "2025-08-13 03:53:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AsciiExpressionEvaluator {\n    \n    // Modulus for results\n    private static final int MODULUS = 2011;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> inputLines = new ArrayList<>();\n        String line;\n        \n        while (scanner.hasNextLine()) {\n            line = scanner.nextLine().trim();\n            if (line.isEmpty()) { // Empty line means end of a dataset\n                if (!inputLines.isEmpty()) {\n                    evaluateExpression(inputLines);\n                    inputLines.clear();\n                }\n            } else {\n                inputLines.add(line);\n            }\n        }\n        \n        if (!inputLines.isEmpty()) {\n            evaluateExpression(inputLines);\n        }\n\n        scanner.close();\n    }\n    \n    private static void evaluateExpression(List<String> lines) {\n        // Checking single line input if multiline formatting is not detected\n        if (lines.size() == 1) {\n            processExpression(lines.get(0));\n            return;\n        }\n        \n        // Convert multiline ASCII representation into a single expression\n        int maxWidth = lines.stream().mapToInt(String::length).max().orElse(0);\n        char[][] grid = new char[lines.size()][maxWidth];\n        for (int i = 0; i < lines.size(); i++) {\n            Arrays.fill(grid[i], ' ');\n            for (int j = 0; j < lines.get(i).length(); j++) {\n                grid[i][j] = lines.get(i).charAt(j);\n            }\n        }\n        \n        StringBuilder expressionBuilder = new StringBuilder();\n        for (int j = 0; j < maxWidth; j++) {\n            for (int i = 0; i < lines.size(); i++) {\n                char ch = grid[i][j];\n                if (ch != ' ' && ch != '|') {\n                    expressionBuilder.append(ch);\n                }\n            }\n            if ((j+1) < maxWidth && grid[0][j+1] == '|') {\n                expressionBuilder.append(')').append('(');\n            }\n        }\n        \n        String expression = expressionBuilder.toString().trim();\n        \n        // Parse and evaluate the expression\n        processExpression(expression);\n    }\n    \n    private static void processExpression(String expr) {\n        try {\n            int result = evaluate(expr) % MODULUS;\n            if (result < 0) result += MODULUS;\n            System.out.println(result);\n        } catch (Exception e) {\n            System.out.println(\"ERROR\");\n        }\n    }\n    \n    private static int evaluate(String expr) throws Exception {\n        // Simple evaluator for demonstration of result extraction.\n        // Could be extended with more sophisticated parsing mechanisms\n        // to handle specific ASCII based formatting rules.\n\n        Deque<Integer> values = new ArrayDeque<>();\n        Deque<Character> operators = new ArrayDeque<>();\n        \n        int i = 0;\n        while (i < expr.length()) {\n            char ch = expr.charAt(i);\n            \n            if (Character.isDigit(ch)) {\n                int value = 0;\n                while (i < expr.length() && Character.isDigit(expr.charAt(i))) {\n                    value = (value * 10) + (expr.charAt(i) - '0');\n                    i++;\n                }\n                values.push(value);\n                continue;\n            }\n            \n            if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {\n                while (!operators.isEmpty() && precedence(operators.peek()) >= precedence(ch)) {\n                    values.push(applyOp(operators.pop(), values.pop(), values.pop()));\n                }\n                operators.push(ch);\n            }\n            \n            i++;\n        }\n        \n        while (!operators.isEmpty()) {\n            values.push(applyOp(operators.pop(), values.pop(), values.pop()));\n        }\n        \n        return values.pop();\n    }\n    \n    private static int precedence(char op) {\n        if (op == '+' || op == '-') return 1;\n        if (op == '*' || op == '/') return 2;\n        return 0;\n    }\n    \n    private static int applyOp(char op, int b, int a) {\n        switch (op) {\n            case '+': return a + b;\n            case '-': return a - b;\n            case '*': return a * b;\n            case '/': return a / b; // Assume no division by zero in constraints\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-13 03:53:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <math.h>\n\n#define MODULO 2011\n\nint readExpression(char expression[], int *idx);\nint term(char expression[], int *idx);\nint factor(char expression[], int *idx);\nint number(char expression[], int *idx);\nint power(int base, int exp);\n\nint main() {\n    char expression[1001];\n    int idx;\n    while (fgets(expression, sizeof(expression), stdin) != NULL) {\n        idx = 0;\n        if (expression[0] == '0' && expression[1] == '\\n') // A '0' followed by newline indicates end of input\n            break;\n        int result = readExpression(expression, &idx);\n        if (result < 0) {\n            result = (result % MODULO + MODULO) % MODULO;\n        } else {\n            result = result % MODULO;\n        }\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}\n\nint readExpression(char expression[], int *idx) {\n    int result = term(expression, idx);\n    while (expression[*idx] == '+' || expression[*idx] == '-') {\n        if (expression[*idx] == '+') {\n            (*idx)++;\n            result += term(expression, idx);\n        } else if (expression[*idx] == '-') {\n            (*idx)++;\n            result -= term(expression, idx);\n        }\n        result = (result % MODULO + MODULO) % MODULO;\n    }\n    return result;\n}\n\nint term(char expression[], int *idx) {\n    int result = factor(expression, idx);\n    while (expression[*idx] == '*' || expression[*idx] == '/') {\n        if (expression[*idx] == '*') {\n            (*idx)++;\n            result *= factor(expression, idx);\n            result = (result % MODULO + MODULO) % MODULO;\n        } else if (expression[*idx] == '/') {\n            (*idx)++;\n            int divisor = factor(expression, idx);\n            if (divisor != 0) {\n                // Find modular inverse of divisor modulo MODULO using Fermat's little theorem\n                int inverse = power(divisor, MODULO - 2);\n                result *= inverse;\n                result = (result % MODULO + MODULO) % MODULO;\n            }\n        }\n    }\n    return result;\n}\n\nint factor(char expression[], int *idx) {\n    int result;\n    \n    if (expression[*idx] == '(') {\n        (*idx)++;\n        result = readExpression(expression, idx);\n        if (expression[*idx] == ')') {\n            (*idx)++;\n        }\n        result = (result % MODULO + MODULO) % MODULO;\n    } else {\n        result = number(expression, idx);\n        result = (result % MODULO + MODULO) % MODULO;\n    }\n    \n    if (expression[*idx] == '^') {\n        (*idx)++;\n        int exponent = factor(expression, idx);\n        result = power(result, exponent);\n        result = (result % MODULO + MODULO) % MODULO;\n    }\n    \n    return result;\n}\n\nint number(char expression[], int *idx) {\n    int result = 0;\n    while (isdigit(expression[*idx])) {\n        result = result * 10 + (expression[*idx] - '0');\n        (*idx)++;\n    }\n    result = result % MODULO;\n    return result;\n}\n\nint power(int base, int exp) {\n    int result = 1;\n    base = (base % MODULO + MODULO) % MODULO;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MODULO;\n        }\n        base = (base * base) % MODULO;\n        exp /= 2;\n    }\n    return result;\n}",
    "timestamp": "2025-08-13 03:54:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_ascii_expression(lines):\n    # Remove empty lines and whitespace\n    lines = [line.rstrip() for line in lines if line.strip()]\n    \n    # Function to convert ASCII representation to numeric value\n    def parse_number(num_lines):\n        # Remove leading/trailing whitespace\n        num_lines = [line.strip() for line in num_lines]\n        \n        # Check for negative sign\n        is_negative = num_lines[0].startswith('-')\n        if is_negative:\n            num_lines[0] = num_lines[0][1:]\n        \n        # Determine number of digits/width\n        width = max(len(line) for line in num_lines)\n        \n        # Construct numeric representation\n        digits = []\n        for i in range(width):\n            digit_col = []\n            for line in num_lines:\n                if i < len(line):\n                    digit_col.append(line[i])\n                else:\n                    digit_col.append(' ')\n            \n            # Identify digit based on representation\n            if set(digit_col) == set('|'):\n                digits.append('1')\n            elif set(digit_col) == set('/'):\n                digits.append('7')\n            elif set(digit_col) == set('-'):\n                digits.append('0')\n            elif len(set(digit_col)) > 1:\n                # Complex digits mapping logic\n                if '|' in digit_col and '/' in digit_col:\n                    digits.append('4')\n                elif '-' in digit_col and '|' in digit_col:\n                    digits.append('5')\n                else:\n                    digits.append('?')\n        \n        # Convert to integer\n        num = int(''.join(digits)) if digits else 0\n        return -num if is_negative else num\n\n    # Function to evaluate expression\n    def evaluate(lines):\n        # Split expression lines\n        op_line = lines[-1].strip()\n        num_lines = lines[:-1]\n        \n        # Parse numbers\n        nums = []\n        current_num = []\n        for line in num_lines:\n            if line.strip():\n                current_num.append(line)\n            else:\n                if current_num:\n                    nums.append(parse_number(current_num))\n                    current_num = []\n        \n        if current_num:\n            nums.append(parse_number(current_num))\n        \n        # Evaluate based on operation\n        result = nums[0]\n        for i in range(1, len(nums)):\n            if '+' in op_line:\n                result += nums[i]\n            elif '-' in op_line:\n                result -= nums[i]\n            elif '*' in op_line:\n                result *= nums[i]\n            elif '^' in op_line:\n                result **= nums[i]\n        \n        return result % 2011\n\n    return evaluate(lines)\n\ndef main():\n    # Read number of datasets\n    T = int(input())\n    \n    # Process each dataset\n    for _ in range(T):\n        # Read number of lines in expression\n        N = int(input())\n        \n        # Read expression lines\n        expression = []\n        for __ in range(N):\n            expression.append(input())\n        \n        # Evaluate and print result\n        print(parse_ascii_expression(expression))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:54:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef modinv(a, mod):\n    return pow(a, mod-2, mod)\n\ndef evaluate_expression(expr):\n    mod = 2011\n    # Parse the expression into tokens\n    tokens = []\n    i = 0\n    n = len(expr)\n    while i < n:\n        if expr[i] == ' ':\n            i += 1\n            continue\n        if expr[i] in '+-*/^()':\n            tokens.append(expr[i])\n            i += 1\n        else:\n            num = 0\n            while i < n and expr[i].isdigit():\n                num = num * 10 + int(expr[i])\n                i += 1\n            tokens.append(str(num))\n    \n    # Convert to postfix notation\n    output = []\n    ops = deque()\n    precedence = {'^': 4, '*': 3, '/': 3, '+': 2, '-': 2, '(': 1}\n    for token in tokens:\n        if token.isdigit():\n            output.append(token)\n        elif token == '(':\n            ops.append(token)\n        elif token == ')':\n            while ops[-1] != '(':\n                output.append(ops.pop())\n            ops.pop()  # Remove '('\n        else:\n            while ops and precedence[ops[-1]] >= precedence[token]:\n                output.append(ops.pop())\n            ops.append(token)\n    while ops:\n        output.append(ops.pop())\n    \n    # Evaluate postfix\n    stack = []\n    for token in output:\n        if token.isdigit():\n            stack.append(int(token) % mod)\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                res = (a + b) % mod\n            elif token == '-':\n                res = (a - b) % mod\n            elif token == '*':\n                res = (a * b) % mod\n            elif token == '/':\n                inv_b = modinv(b, mod)\n                res = (a * inv_b) % mod\n            elif token == '^':\n                if b < 0:\n                    b = -b\n                    a = modinv(a, mod)\n                res = pow(a, b, mod)\n            stack.append(res)\n    return stack[0] % mod\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    idx = 0\n    while idx < len(input_lines):\n        line = input_lines[idx].strip()\n        if not line:\n            idx += 1\n            continue\n        expr = []\n        while idx < len(input_lines) and input_lines[idx].strip() != '':\n            expr.append(input_lines[idx].strip())\n            idx += 1\n        full_expr = ' '.join(expr)\n        result = evaluate_expression(full_expr)\n        print(result)\n        idx += 1\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 03:54:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <stack>\n#include <cmath>\n\nconst int MOD = 2011;\n\nint mod(int a, int m) {\n    return ((a % m) + m) % m;\n}\n\nint modInverse(int a, int m) {\n    int m0 = m;\n    int y = 0, x = 1;\n    if (m == 1)\n        return 0;\n    while (a > 1) {\n        int q = a / m;\n        int t = m;\n        m = a % m, a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    return (x < 0) ? x + m0 : x;\n}\n\nint parseNum(const std::string &s, int &i) {\n    int num = 0;\n    while (i < s.size() && isdigit(s[i])) {\n        num = num * 10 + (s[i] - '0');\n        i++;\n    }\n    return mod(num, MOD);\n}\n\nint parseExpression(const std::string &line);\n\nint parseFactor(const std::string &line, int &i) {\n    if (line[i] == '(') {\n        i++;\n        int result = parseExpression(line);\n        i++;\n        return result;\n    } else {\n        return parseNum(line, i);\n    }\n}\n\nint parseExponent(const std::string &line, int &i) {\n    int base = parseFactor(line, i);\n    if (i < line.size() && line[i] == '^') {\n        i++;\n        int exp = parseExponent(line, i);\n        int result = 1;\n        while (exp) {\n            if (exp & 1) {\n                result = mod(result * base, MOD);\n            }\n            base = mod(base * base, MOD);\n            exp >>= 1;\n        }\n        return result;\n    }\n    return base;\n}\n\nint parseTerm(const std::string &line, int &i) {\n    int result = parseExponent(line, i);\n    while (i < line.size()) {\n        if (line[i] == '*') {\n            i++;\n            result = mod(result * parseExponent(line, i), MOD);\n        } else if (line[i] == '/') {\n            i++;\n            result = mod(result * modInverse(parseExponent(line, i), MOD), MOD);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\nint parseExpression(const std::string &line) {\n    int i = 0;\n    int result = parseTerm(line, i);\n    while (i < line.size()) {\n        if (line[i] == '+') {\n            i++;\n            result = mod(result + parseTerm(line, i), MOD);\n        } else if (line[i] == '-') {\n            i++;\n            result = mod(result - parseTerm(line, i), MOD);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        if (line.empty()) {\n            break;\n        }\n        int result = parseExpression(line);\n        std::cout << mod(result, MOD) << std::endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:15:33"
  }
]