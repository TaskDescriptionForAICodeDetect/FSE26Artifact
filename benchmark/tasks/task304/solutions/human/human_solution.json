[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\nstruct State {\n\tint c, x, y, s;\n\texplicit State(int c = 0, int x = 0, int y = 0, int s = 0) :\n\t\tc(c), x(x), y(y), s(s)\n\t{ }\n};\nconst int INF = 1000000000;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\ninline bool between(int a, int b, int c){\n\treturn a <= b && b < c;\n}\n\nint dist[10][10][10][1 << 10];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint h, w, n;\n\tcin >> h >> w >> n;\n\tvector<string> field(h);\n\tfor(int i = 0; i < h; ++i){\n\t\tcin >> field[i];\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tif(islower(field[i][j])){ ++field[i][j]; }\n\t\t\tif(field[i][j] == 'S'){ field[i][j] = 'a'; }\n\t\t\tif(isdigit(field[i][j])){ --field[i][j]; }\n\t\t}\n\t}\n\tint init_s = 0, init_x = 0, init_y = 0;\n\tfor(int i = 0; i < h; ++i){\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tif(field[i][j] == 'a'){ init_x = j; init_y = i; }\n\t\t\tif('b' <= field[i][j] && field[i][j] <= 'f'){\n\t\t\t\tfor(int d = 0; d < 4; ++d){\n\t\t\t\t\tconst int y = i + dy[d], x = j + dx[d];\n\t\t\t\t\tif(!between(0, y, h) || !between(0, x, w)){ continue; }\n\t\t\t\t\tif(field[y][x] == field[i][j] - 1){\n\t\t\t\t\t\tinit_s |= (d << ((field[i][j] - 'b') * 2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> valid_state(1 << 10);\n\tfor(int i = 0; i < (1 << 10); ++i){\n\t\tint bitmap[11][11] = { { 0 } };\n\t\tint x = 5, y = 5, valid = 1;\n\t\tbitmap[y][x] = 1;\n\t\tfor(int j = 4; j >= 0; --j){\n\t\t\tconst int d = (i >> (j * 2)) & 3;\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\tif(bitmap[y][x]){ valid = 0; }\n\t\t\tbitmap[y][x] = 1;\n\t\t}\n\t\tvalid_state[i] = valid;\n\t}\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tfor(int s = 0; s < (1 << 10); ++s){ dist[i][y][x][s] = INF; }\n\t\t\t}\n\t\t}\n\t}\n\tqueue<State> q;\n\tdist[0][init_y][init_x][init_s] = 0;\n\tq.push(State(0, init_x, init_y, init_s));\n\tint answer = INF;\n\twhile(!q.empty()){\n\t\tconst State p = q.front();\n\t\tq.pop();\n\t\tconst int d = dist[p.c][p.y][p.x][p.s];\n\t\tif(p.c == n){\n\t\t\tanswer = d;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\tconst int nx = p.x + dx[dir], ny = p.y + dy[dir];\n\t\t\tif(!between(0, nx, w) || !between(0, ny, h)){ continue; }\n\t\t\tif(field[ny][nx] == '#'){ continue; }\n\t\t\tconst int ns = ((p.s << 2) | dir) & ((1 << 10) - 1);\n\t\t\tconst int nc = p.c + (field[ny][nx] == '0' + p.c ? 1 : 0);\n\t\t\tif(valid_state[ns] && d + 1 < dist[nc][ny][nx][ns]){\n\t\t\t\tdist[nc][ny][nx][ns] = d + 1;\n\t\t\t\tq.push(State(nc, nx, ny, ns));\n\t\t\t}\n\t\t}\n\t}\n\tif(answer >= INF){ answer = -1; }\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <queue>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\n\nusing namespace std;\n\nint dp[10][10][4][4][4][10];\n\nint idOf(pair<int, int> prev, pair<int, int> next){\n  if(prev.first  + 1 == next.first) return 0;\n  if(prev.first  - 1 == next.first) return 1;\n  if(prev.second + 1 == next.second) return 2;\n  if(prev.second - 1 == next.second) return 3;\n  throw 0;\n}\n\npair<int, int> posOf(pair<int, int> prev, int id){\n  if(id == 0){ prev.first  += 1; return prev; }\n  if(id == 1){ prev.first  -= 1; return prev; }\n  if(id == 2){ prev.second += 1; return prev; }\n  if(id == 3){ prev.second -= 1; return prev; }\n  throw 0;\n}\n\nstruct State{\n  int x;\n  int y;\n  int b1;\n  int b2;\n  int b3;\n  int next;\n\n  State(){}\n  State(int x, int y, int b1, int b2, int b3, int next)\n    : x(x), y(y), b1(b1), b2(b2), b3(b3), next(next){\n  }\n\n  int &dp() const{\n    return ::dp[y][x][b1][b2][b3][next];\n  }\n\n  vector<pair<int, int> > pos() const{\n    vector<pair<int, int> > ret;\n    ret.push_back(make_pair(x, y));\n    ret.push_back(posOf(ret.back(), b1));\n    ret.push_back(posOf(ret.back(), b2));\n    ret.push_back(posOf(ret.back(), b3));\n    return ret;\n  }\n};\n\nbool operator < (const State &lhs, const State &rhs){\n  return lhs.next > rhs.next;\n}\n\nchar g[16][16];\n\nint ex[10];\nint ey[10];\n\nint bx[10];\nint by[10];\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint main(){\n  const int h = getInt();\n  const int w = getInt();\n  const int n = getInt();\n\n  REP(i,h) scanf(\"%s\", g[i]);\n  REP(i,h) REP(j,w){\n    if(isdigit(g[i][j])){\n      const int k = g[i][j] - '1';\n      ex[k] = j; ey[k] = i;\n      g[i][j] = '.';\n    }else if(isalpha(g[i][j])){\n      const int k = g[i][j] == 'S' ? 0 : g[i][j] - 'a' + 1;\n      bx[k] = j; by[k] = i;\n      g[i][j] = '.';\n    }\n  }\n\n  State init(bx[0], by[0],\n\t     idOf(make_pair(bx[0], by[0]), make_pair(bx[1], by[1])),\n\t     idOf(make_pair(bx[1], by[1]), make_pair(bx[2], by[2])),\n\t     idOf(make_pair(bx[2], by[2]), make_pair(bx[3], by[3])),\n\t     0);\n\n  typedef pair<int, State> data;\n  priority_queue<data, vector<data>, greater<data> > pq;\n\n  memset(dp, -1, sizeof(dp));\n  pq.push(make_pair(0, init));\n\n  while(pq.size()){\n    const data d = pq.top(); pq.pop();\n    int cost = d.first;\n    State state = d.second;\n\n    if(state.dp() != -1) continue;\n    state.dp() = cost;\n\n    if(state.next == n){\n      printf(\"%d\\n\", cost);\n      return 0;\n    }\n\n    const vector<pair<int, int> > pos = state.pos();\n    REP(k,4){\n      const int x = pos[0].first + _dx[k];\n      const int y = pos[0].second + _dy[k];\n      if(!ISIN(x, y, w, h)) continue;\n      if(g[y][x] == '#') continue;\n\n      const pair<int, int> next = make_pair(x, y);\n      if(next != pos[0] && next != pos[1] && next != pos[2] && next != pos[3]){\n\tint nn = state.next;\n\tif(next.first == ex[state.next] && next.second == ey[state.next]) nn++;\n\n\tState s(next.first, next.second,\n\t\tidOf(next, pos[0]),\n\t\tidOf(pos[0], pos[1]),\n\t\tidOf(pos[1], pos[2]),\n\t\tnn);\n\tif(s.dp() == -1){\n\t  pq.push(make_pair(cost + 1, s));\n\t}\n      }\n    }\n  }\n\n  puts(\"-1\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 5\n\nenum DIR{\n\tNorth,\n\tWest,\n\tEast,\n\tSouth,\n};\n\nstruct LOC{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_last_num,int arg_sum_cost,DIR arg_dir[SIZE],LOC arg_loc[SIZE+1]){\n\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tlast_num = arg_last_num;\n\t\tsum_cost = arg_sum_cost;\n\n\t\tfor(int i = 0; i < SIZE; i++){\n\t\t\tdir[i] = arg_dir[i];\n\t\t}\n\n\t\tfor(int i = 0; i < SIZE+1; i++){\n\n\t\t\tloc[i] = arg_loc[i];\n\t\t}\n\t}\n\n\tint row,col,last_num,sum_cost;\n\tDIR dir[SIZE];\n\tLOC loc[SIZE+1];\n};\n\nint H,W;\nint N;\nint POW[6],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint min_cost[10][10][10][1024];\nLOC start;\nDIR dir_array[4] = {North,West,East,South};\nchar base_map[10][11],sequence[SIZE+1] = {'S','a','b','c','d','e'};\n\n\nbool rangeCheck(int row,int col){\n\n\treturn row >= 0 && row <= H-1 && col >= 0 && col <= W-1;\n}\n\n//体の位置関係をコード化\nint makeCode(DIR dir[SIZE]){\n\n\tint ret = 0;\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tret += dir[i]*POW[i];\n\t}\n\n\treturn ret;\n}\n\n//初期状態での、体の位置および位置関係を調べる\nvoid calc_First(int base_row,int base_col,LOC loc[SIZE+1],DIR dir[SIZE]){\n\n\tloc[0].set(base_row,base_col);\n\n\tfor(int i = 1; i < 6; i++){\n\t\tfor(int a = 0; a < 4; a++){\n\n\t\t\tint adj_row = loc[i-1].row+diff_row[a];\n\t\t\tint adj_col = loc[i-1].col+diff_col[a];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false)continue;\n\n\t\t\tif(base_map[adj_row][adj_col] == sequence[i]){\n\t\t\t\tloc[i].set(adj_row,adj_col);\n\t\t\t\tdir[i-1] = dir_array[a];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//同じマスに2つ以上の部分が乗っていないか調べる\nbool cross_Check(LOC loc[SIZE+1]){\n\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int k = i+1; k < 6; k++){\n\t\t\tif(loc[i].row == loc[k].row && loc[i].col == loc[k].col){\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 6; i++){\n\n\t\tPOW[i] = POW[i-1]*4;\n\t}\n\n\tscanf(\"%d %d %d\",&H,&W,&N);\n\n\tLOC first_loc[SIZE+1];\n\tDIR first_dir[SIZE];\n\n\t//先に全部読み込む\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(base_map[row][col] == 'S'){\n\n\t\t\t\tstart.set(row,col);\n\t\t\t\tcalc_First(row,col,first_loc,first_dir);\n\t\t\t}\n\t\t}\n\t}\n\n\t//dp[row][col][最後の数字][体の位置関係] = 最小コスト\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int num = 0; num <= N; num++){\n\t\t\t\tfor(int state = 0; state < POW[5]; state++){\n\t\t\t\t\tmin_cost[row][col][num][state] = BIG_NUM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tmin_cost[start.row][start.col][0][makeCode(first_dir)] = 0;\n\tQ.push(Info(start.row,start.col,0,0,first_dir,first_loc));\n\n\tint next_last_num,next_cost;\n\tDIR next_dir[SIZE];\n\tLOC next_loc[SIZE+1];\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().sum_cost > min_cost[Q.front().row][Q.front().col][Q.front().last_num][makeCode(Q.front().dir)]){\n\n\t\t\tQ.pop();\n\n\t\t}else if(Q.front().last_num == N){\n\n\t\t\tprintf(\"%d\\n\",Q.front().sum_cost);\n\t\t\treturn 0;\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\tint adj_row = Q.front().row+diff_row[i];\n\t\t\t\tint adj_col = Q.front().col+diff_col[i];\n\n\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] == '#')continue;\n\n\t\t\t\tif(base_map[adj_row][adj_col] >= '1' && base_map[adj_row][adj_col] <= '9' &&\n\t\t\t\t\t\tbase_map[adj_row][adj_col]-'0' == Q.front().last_num+1){\n\n\t\t\t\t\tnext_last_num = base_map[adj_row][adj_col]-'0';\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_last_num = Q.front().last_num;\n\t\t\t\t}\n\n\t\t\t\tnext_cost = Q.front().sum_cost+1;\n\n\t\t\t\t//次の体の位置を計算\n\t\t\t\tfor(int a = 5; a >= 1; a--){\n\t\t\t\t\t//前のパーツがあった場所へ動く\n\t\t\t\t\tnext_loc[a].row = Q.front().loc[a-1].row;\n\t\t\t\t\tnext_loc[a].col = Q.front().loc[a-1].col;\n\t\t\t\t}\n\t\t\t\tnext_loc[0].set(adj_row,adj_col);\n\n\t\t\t\tif(!cross_Check(next_loc))continue;\n\n\t\t\t\t//各パーツの位置関係を計算\n\t\t\t\tfor(int a = 1; a < 6; a++){\n\t\t\t\t\tfor(int b = 0; b < 4; b++){\n\n\t\t\t\t\t\tif(next_loc[a-1].row+diff_row[b] == next_loc[a].row &&\n\t\t\t\t\t\t\t\tnext_loc[a-1].col+diff_col[b] == next_loc[a].col){\n\n\t\t\t\t\t\t\tnext_dir[a-1] = dir_array[b];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint next_code = makeCode(next_dir);\n\n\t\t\t\tif(min_cost[adj_row][adj_col][next_last_num][next_code] > next_cost){\n\n\t\t\t\t\tmin_cost[adj_row][adj_col][next_last_num][next_code] = next_cost;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col,next_last_num,next_cost,next_dir,next_loc));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"-1\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * h.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 10;\nconst int MAX_W = 10;\nconst int MAX_N = 9;\nconst int M = 5;\nconst int DBITS = 1 << (M * 2);\n\nconst int INF = 1 << 30;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\n/* typedef */\n\nstruct Stat {\n  int d, k, x, y, dbits;\n};\n\n/* global variables */\n\nstring flds[MAX_H];\nint xs[M], ys[M];\nint dists[MAX_N][MAX_H][MAX_W][DBITS];\n\n/* subroutines */\n\nbool move(Stat &s, int h, int w, int di) {\n  int x0 = s.x + dxs[di], y0 = s.y + dys[di];\n  if (x0 < 0 || x0 >= w || y0 < 0 || y0 >= h || flds[y0][x0] == '#')\n    return false;\n  for (int i = 0, x = s.x, y = s.y; i < M - 1; i++) {\n    int dii = ((s.dbits >> (i * 2)) & 3);\n    x += dxs[dii], y += dys[dii];\n    if (x0 == x && y0 == y) return false;\n  }\n\n  s.dbits = ((s.dbits << 2) & (DBITS - 1)) | ((di + 2) & 3);\n  s.x = x0, s.y = y0;\n  s.d++;\n  return true;\n}\n\n/* main */\n\nint main() {\n  int h, w, n;\n  cin >> h >> w >> n;\n\n  Stat st;\n  st.d = st.k = st.dbits = 0;\n\n  for (int y = 0; y < h; y++) {\n    cin >> flds[y];\n    for (int x = 0; x < w; x++) {\n      char ch = flds[y][x];\n      if (ch == 'S') st.x = x, st.y = y;\n      else if (ch >= 'a' && ch <= 'e') {\n\tint id = ch - 'a';\n\txs[id] = x, ys[id] = y;\n      }\n    }\n  }\n\n  for (int i = 0, x = st.x, y = st.y; i < M; i++) {\n    int dx = xs[i] - x, dy = ys[i] - y;\n    for (int di = 0; di < 4; di++)\n      if (dx == dxs[di] && dy == dys[di]) {\n\tst.dbits |= (di << (i * 2));\n\tbreak;\n      }\n    x = xs[i], y = ys[i];\n  }\n  \n  for (int i = 0; i < n; i++)\n    for (int y = 0; y < h; y++)\n      for (int x = 0; x < w; x++)\n\tfor (int bits = 0; bits < DBITS; bits++)\n\t  dists[i][y][x][bits] = INF;\n  dists[0][st.y][st.x][st.dbits] = 0;\n\n  queue<Stat> q;\n  q.push(st);\n  int ans = -1;\n  \n  while (! q.empty()) {\n    Stat u = q.front(); q.pop();\n\n    int uch = flds[u.y][u.x];\n    if (uch == '1' + u.k) {\n      if (++u.k >= n) {\n\tans = u.d;\n\tbreak;\n      }\n      dists[u.k][u.y][u.x][u.dbits] = u.d;\n    }\n\n    for (int di = 0; di < 4; di++) {\n      Stat v = u;\n      if (move(v, h, w, di) &&\n\t  dists[v.k][v.y][v.x][v.dbits] > v.d) {\n\tdists[v.k][v.y][v.x][v.dbits] = v.d;\n\tq.push(v);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int y,x,t,b;\n};\n\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int M = (1<<10)-1;\n\nint h,w,n;\nstring s[10];\n\nconst int INF = 19191919;\nint dp[10][10][10][1<<10];\n\nbool IN(int y, int x){\n    return 0<=y && y<h && 0<=x && x<w;\n}\n\nint main(){\n    cin >>h >>w >>n;\n    rep(i,h) cin >>s[i];\n\n    int sy=0,sx=0;\n    int by[5],bx[5];\n    rep(i,h)rep(j,w){\n        if(s[i][j] == 'S'){\n            sy = i;\n            sx = j;\n        }\n        if(islower(s[i][j])){\n            int ID = s[i][j]-'a';\n            by[ID] = i;\n            bx[ID] = j;\n        }\n    }\n\n    int sb = 0;\n    int py = sy, px = sx;\n    rep(i,5){\n        int d = 0;\n        while(d<4){\n            int ny = py+dy[d], nx = px+dx[d];\n            if(ny == by[i] && nx == bx[i]) break;\n            ++d;\n        }\n        sb |= d<<(2*i);\n        py = by[i];\n        px = bx[i];\n    }\n\n    rep(i,10)rep(j,10)rep(k,10)rep(l,1<<10) dp[i][j][k][l] = INF;\n    queue<State> que;\n    dp[sy][sx][0][sb] = 0;\n    que.push({sy,sx,0,sb});\n    while(!que.empty()){\n        State c = que.front();\n        que.pop();\n\n        int D = dp[c.y][c.x][c.t][c.b];\n        // printf(\" %d %d %d %d == %d\\n\", c.y, c.x, c.t, c.b,D);\n\n        int tmask = c.b;\n        py = c.y, px = c.x;\n        by[0] = py;\n        bx[0] = px;\n        rep(i,4){\n            int dir = tmask&3;\n            tmask >>= 2;\n            py += dy[dir];\n            px += dx[dir];\n            by[i+1] = py;\n            bx[i+1] = px;\n        }\n\n        rep(i,4){\n            int ny = c.y+dy[i], nx = c.x+dx[i];\n            if(!IN(ny,nx)) continue;\n            if(s[ny][nx] == '#') continue;\n\n            bool body = false;\n            rep(j,5)if(ny==by[j] && nx==bx[j]) body = true;\n            if(body) continue;\n\n            int nb = c.b;\n            nb <<= 2;\n            nb |= (i^2);\n            nb &= M;\n\n            int nt = c.t;\n            if(s[ny][nx] == '0'+1+c.t) ++nt;\n\n            if(dp[ny][nx][nt][nb] > D+1){\n                dp[ny][nx][nt][nb] = D+1;\n                que.push({ny,nx,nt,nb});\n            }\n        }\n    }\n\n    int ans = INF;\n    rep(i,h)rep(j,w)rep(mask,1<<10) ans = min(ans, dp[i][j][n][mask]);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cassert>\n#include <map>\n#include <vector>\nusing namespace std;\n\nchar c[12][12];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\nint memo[12][12][12][1024];\n\nstruct NODE{\n\tint next;\n\tint x,y,prev;\n\tint cost;\n\tNODE(int x,int y,int prev,int next,int cost) : x(x) , y(y) , prev(prev) , next(next), cost(cost) {}\n};\n\nint dir(pair<int,int> a,pair<int,int> b){\n\tint ddx = a.first - b.first;\n\tint ddy = a.second - b.second;\n\tif( ddx == 0 ) return ddy < 0 ? 3 : 1;\n\telse if( ddy == 0 ) return ddx < 0 ? 0 : 2;\n\telse assert(0);\n}\n\nint atamaga[12][12];\nint main(){\n\tfor(int i = 0 ; i < 12 ; i++)\n\t\tfor(int j = 0 ; j < 12 ; j++)\n\t\t\tc[i][j] = '#';\n\n\tint H,W,N;\n\tcin >> H >> W >> N;\n\tfor(int i = 0 ; i < H ; i++){\n\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\tcin >> c[i+1][j+1];\n\t\t}\n\t}\n\tmap<char,pair<int,int> >tmp;\n\tfor(int i = 1 ; i <= H ; i++){\n\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\ttmp[c[i][j]] = make_pair(j,i);\n\t\t}\n\t}\n\tstring table = \"edcbaS\";\n\tint initdir = 0;\n\tfor(int i = 0 ; i+1 < table.size() ; i++){\n\t\tinitdir = initdir * 4 + dir(tmp[table[i+1]],tmp[table[i]]);\n\t}\n\tfor(int i = 0 ; i < table.size() ; i++){\n\t\tint x = tmp[table[i]].first;\n\t\tint y = tmp[table[i]].second;\n\t\tc[y][x] = '.';\n\t}\n\tfor(int i = 1 ; i <= N ; i++){\n\t\tint x = tmp['0'+i].first;\n\t\tint y = tmp['0'+i].second;\n\t\tatamaga[y][x] = i;\n\t\tc[y][x] = '.';\n\t}\n\tqueue<NODE> Q;\n\tQ.push(NODE(tmp['S'].first,tmp['S'].second,initdir,1,0));\n\twhile(Q.size()){\n\t\tNODE q = Q.front(); Q.pop();\n\t\tif( memo[q.y][q.x][q.next][q.prev]++ ) continue;\n\t\tif( q.next > N ){\n\t\t\tcout << q.cost << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tvector< pair<int,int> > dont;\n\t\tint tx = q.x , ty = q.y;\n\t\tint oo = q.prev;\n\t\tdont.push_back(make_pair(tx,ty));\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\n\t\t\tint dirdir = (oo+2) % 4;\n\t\t\too /= 4;\n\t\t\ttx += dx[dirdir];\n\t\t\tty += dy[dirdir];\n\t\t\tdont.push_back(make_pair(tx,ty));\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint tx = q.x + dx[i] , ty = q.y + dy[i];\n\t\t\tif( c[ty][tx] == '#' ) continue;\n\t\t\tint flag = 1;\n\t\t\tfor(int j = 0 ; j < dont.size() ; j++)\n\t\t\t\tif( dont[j] == make_pair(tx,ty) ){\n\t\t\t\t\tflag = 0; break;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tQ.push(NODE(tx,ty,(q.prev*4+(i))%1024,q.next+(q.next==atamaga[ty][tx]),q.cost+1));\n\t\t}\n\t\t\n\t}\n\tcout << -1 << endl;\n\t\n\t\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nstatic const int dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\nconst char *body = \"Sabcde\";\nchar s[10][11];\nbool vis[10][10][1<<8][10];\nbool bad[10][10];\n\nint main() {\n\tint H, W, N;\n\tscanf(\"%d%d%d\", &H, &W, &N);\n\trep(i, H) scanf(\"%s\", s[i]);\n\tint inithist = 0, sy = -1, sx = -1;\n\trep(i, H) rep(j, W) if(s[i][j] == 'S') {\n\t\tint y = i, x = j;\n\t\trep(k, 4) {\n\t\t\trep(d, 4) {\n\t\t\t\tint yy = y + dy[d], xx = x + dx[d];\n\t\t\t\tif(yy<0||yy>=H||xx<0||xx>=W) continue;\n\t\t\t\tif(s[yy][xx] != body[k+1]) continue;\n\t\t\t\ty = yy, x = xx;\n\t\t\t\tinithist |= d << (k * 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsy = i, sx = j;\n//\t\tcerr << sy << \", \" << sx << endl;\n\t}\n\n\tint t = 0;\n\tmset(vis, 0);\n\tmset(bad, 0);\n\tvector<int> q, next;\n\tvis[sy][sx][inithist][0] = true;\n\tnext.pb(inithist | (sy << 8) | (sx << 12) | (0 << 16));\n\twhile(!next.empty()) {\n\t\tq.swap(next);\n\t\twhile(!q.empty()) {\n\t\t\tint ss = q.back(); q.pop_back();\n\t\t\tint hist = ss & 255;\n\t\t\tint y = ss >> 8 & 15, x = ss >> 12 & 15;\n\t\t\tint num = ss >> 16;\n//\t\t\tcerr << y << \", \" << x << \", \" << hist << \", \" << num << \": \" << t << endl;\n\t\t\tif(num == N) {\n\t\t\t\tprintf(\"%d\\n\", t);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t{\tint yy = y, xx = x;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint d = hist >> (k*2) & 3;\n\t\t\t\t\tyy += dy[d], xx += dx[d];\n\t\t\t\t\tbad[yy][xx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(d, 4) {\n\t\t\t\tint yy = y + dy[d], xx = x + dx[d];\n\t\t\t\tif(yy<0||yy>=H||xx<0||xx>=W) continue;\n\t\t\t\tif(s[yy][xx] == '#' || bad[yy][xx]) continue;\n#define NEXT(y, x, h, n)\\\n\tif(!vis[y][x][h][n]) {\\\n\t\tnext.pb(h | (y << 8) | (x << 12) | (n << 16));\\\n\t\tvis[y][x][h][n] = true;\\\n\t}\n\t\t\t\tint newhist = ((hist << 2) & ~(3 << 8)) | (d ^ 2);\n\t\t\t\tNEXT(yy, xx, newhist, (num + (s[yy][xx] == '1' + num)));\n\t\t\t}\n\t\t\t{\tint yy = y, xx = x;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint d = hist >> (k*2) & 3;\n\t\t\t\t\tyy += dy[d], xx += dx[d];\n\t\t\t\t\tbad[yy][xx] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt ++;\n\t}\n\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\n#define F first\n#define S second\n\nint h, w, a;\nstring in[10];\n\ninline bool ok(const vi &x, const vi& y){\n\trep(i, 6) rep(j, i) if(x[i] == x[j] && y[i] == y[j]) return 0;\n\treturn 1;\n}\n\nint main(){\n\t\n\tcin >> h >> w >> a;\n\t\n\tvi gy(a), gx(a);\n\tvi py(6), px(6);\n\t\n\trep(i, h){\n\t\tcin >> in[i];\n\t\t\n\t\trep(j, w){\n\t\t\tchar c = in[i][j];\n\t\t\t\n\t\t\tif(isalpha(c)){\n\t\t\t\t\n\t\t\t\tif(c == 'S') py[0] = i, px[0] = j;\n\t\t\t\telse py[c - 'a' + 1] = i, px[c - 'a' + 1] = j;\n\t\t\t}\n\t\t\tif(isdigit(c)) gy[c - '1'] = i, gx[c - '1'] = j;\n\t\t}\n\t}\n\t\n\tset<pair<int, pair<vi, vi> > > s; //esa, pos;\n\tqueue<pair<pi, pair<vi, vi> > > q; //cost, esa, pos\n\t\n\ts.insert(mp(0, mp(py, px)));\n\tq.push(mp(mp(0, 0), mp(py, px)));\n\t\n\twhile(!q.empty()){\n\t\t\n\t\tint cost = q.front().F.F;\n\t\tint esa = q.front().F.S;\n\t\tvi ys = q.front().S.F;\n\t\tvi xs = q.front().S.S;\n\t\t\n\t\tq.pop();\n\t\tcost++;\n\t\t\n\t\trep(d, 4){\n\t\t\tconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\n\t\t\tint hy = ys[0] + dy[d], hx = xs[0] + dx[d];\n\t\t\t\n\t\t\tif(hy < 0 || hy >= h || hx < 0 || hx >= w) continue;\n\t\t\tif(in[hy][hx] == '#') continue;\n\t\t\t\n\t\t\tvi ny, nx;\n\t\t\tny.pb(hy); nx.pb(hx);\n\t\t\trep(i, 5) ny.pb(ys[i]), nx.pb(xs[i]);\n\t\t\t\n\t\t\tif(!ok(ny, nx)) continue;\n\t\t\t\n\t\t\tint nesa = esa;\n\t\t\tif(in[hy][hx] == '1' + esa){\n\t\t\t\tif(++nesa == a){\n\t\t\t\t\tcout << cost << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(s.count(mp(nesa, mp(ny, nx)))) continue;\n\t\t\ts.insert(mp(nesa, mp(ny, nx)));\n\t\t\tq.push(mp(mp(cost, nesa), mp(ny, nx)));\n\t\t}\n\t}\n\tcout << -1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint H,W,N;\nchar field[51][51];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\npii esas[11];\nint d[11][11][11][4][4][4][4][4];\n\nint getAng(int cy,int cx,int ny,int nx){\n  if(ny-cy==-1)return 0;\n  else if(nx-cx==-1)return 1;\n  else if(nx-cx==1)return 2;\n  return 3;\n}\n\npii calcNxtPoint(int cy,int cx,int ang){\n  return pii(cy+dy[ang],cx+dx[ang]);\n}\n\nstruct Sit{\n  int cost;\n  int heady,headx;\n  int pos;\n  int ary[5];\n  pii poses[5];\n  Sit(int pos_,int hy,int hx,int a,int b,int c,int d,int e,int cost_){\n    pos=pos_;\n    heady=hy;\n    headx=hx;\n    ary[0]=a;\n    ary[1]=b;\n    ary[2]=c;\n    ary[3]=d;\n    ary[4]=e;\n    cost=cost_;\n  }\n  Sit(){\n    cost=0;\n    pos=0;\n  }\n  void update_ary(){\n    for(int i=0;i<5;i++){\n      if(i==0)ary[i]=getAng(heady,headx,poses[0].first,poses[0].second);\n      else ary[i]=getAng(poses[i-1].first,poses[i-1].second,poses[i].first,poses[i].second);\n    }\n  }\n  bool operator<(const Sit &sit)const{\n    return this->cost>sit.cost;\n  }\n};\n\nint main(){\n\n  cin>>H>>W>>N;\n  Sit start_sit;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>field[i][j];\n      if(field[i][j]=='S'){\n        start_sit.heady=i;\n        start_sit.headx=j;\n        field[i][j]='.';\n      }\n      else if(field[i][j]>='a'&&field[i][j]<='e'){\n        int pos=field[i][j]-'a';\n        start_sit.poses[pos]=pii(i,j);\n        field[i][j]='.';\n      }\n      else if(field[i][j]>='1'&&field[i][j]<='9'){\n        int pos=field[i][j]-'1';\n        esas[pos]=pii(i,j);\n      }\n    }\n  }\n  start_sit.update_ary();\n  // dijkstra\n  queue<Sit> pq;\n  pq.push(start_sit);\n  memset(d,0x7f,sizeof(d));\n  d[start_sit.pos][start_sit.heady][start_sit.headx][start_sit.ary[0]][start_sit.ary[1]][start_sit.ary[2]][start_sit.ary[3]][start_sit.ary[4]]=0;\n  while(pq.size()){\n    Sit csit=pq.front();pq.pop();\n    const int ccost=csit.cost;\n    const int cpos=csit.pos;\n    const int chy=csit.heady;\n    const int chx=csit.headx;\n\n    if(cpos==N){\n      cout<<ccost<<endl;\n      return 0;\n    }\n    \n    int cary[5];\n    for(int i=0;i<5;i++)\n      cary[i]=csit.ary[i];\n    pii bodys[5];\n    // caryの情報から，頭以外の座標を復元\n    for(int i=0;i<5;i++){\n      if(i==0)bodys[i]=calcNxtPoint(chy,chx,cary[i]);\n      else bodys[i]=calcNxtPoint(bodys[i-1].first,bodys[i-1].second,cary[i]);\n    }\n    for(int i=0;i<4;i++){\n      int nhy=chy+dy[i];\n      int nhx=chx+dx[i];\n      // 頭が動けるという条件\n      if(nhy>=0&&nhx>=0&&nhy<H&&nhx<W&&field[nhy][nhx]!='#'){\n        // bodyを次の場所へ動かし、条件を満たすか調べる\n        // 頭の座標とbodyの座標が一致してはいけない\n        pii nbodys[5];\n        nbodys[0]=pii(chy,chx);\n        for(int i=1;i<5;i++)nbodys[i]=bodys[i-1];\n        bool isHead=false;\n        for(int i=0;i<5;i++){\n          if(nbodys[i].first==nhy&&nbodys[i].second==nhx)\n            isHead=true;\n        }\n        if(isHead)continue;\n        // 頭の座標が大丈夫なら，次は頭に餌があるかどうかを調べる\n        int npos=cpos;\n        if(esas[cpos]==pii(nhy,nhx))npos++;\n        int ncost=ccost+1;\n        Sit nsit;\n        nsit.pos=npos;\n        nsit.heady=nhy;\n        nsit.headx=nhx;\n        nsit.cost=ncost;\n        for(int i=0;i<5;i++)\n          nsit.poses[i]=nbodys[i];\n        nsit.update_ary();\n        int nary[5];\n        for(int i=0;i<5;i++)\n          nary[i]=nsit.ary[i];\n        // ここで、コストを更新できるか調べる\n        if(d[npos][nhy][nhx][nary[0]][nary[1]][nary[2]][nary[3]][nary[4]]>ncost){\n          d[npos][nhy][nhx][nary[0]][nary[1]][nary[2]][nary[3]][nary[4]]=ncost;\n          pq.push(nsit);\n        }\n      }\n    }\n  }\n\n  cout<<-1<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\n#ifdef LOCAL\n#include \"local.h\"\n#endif\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n    int h, w, n;\n    cin >> h >> w >> n;\n    char c[16][16];\n    rep(y, h)\n        cin >> c[y];\n\n    vector<pint> start_imo(6);\n    const char* imoimo = \"Sabcde\";\n    rep(y, h) rep(x, w)\n    {\n        if (isalpha(c[y][x]))\n            start_imo[strchr(imoimo, c[y][x]) - imoimo] = pint(x, y);\n    }\n\n    int res = -1;\n    map<pair<int, vector<pint>>, int> dp;\n    queue<pair<int, vector<pint>>> q;\n    q.push(make_pair(0, start_imo));\n    while (!q.empty())\n    {\n        const int esa = q.front().first;\n        const vector<pint> imo = q.front().second;\n        const int ncost = dp[q.front()] + 1;\n        q.pop();\n        assert(imo.size() == 6);\n\n        rep(dir, 4)\n        {\n            int nx = imo[0].first + dx[dir];\n            int ny = imo[0].second + dy[dir];\n            if (in_rect(nx, ny, w, h) && c[ny][nx] != '#' &&\n                count(imo.begin() + 1, imo.begin() + 5, pint(nx, ny)) == 0)\n            {\n                vector<pint> nimo;\n                nimo.push_back(pint(nx, ny));\n                rep(i, 5)\n                    nimo.push_back(imo[i]);\n\n                int nesa = esa;\n                if (c[ny][nx] - '1' == esa)\n                    ++nesa;\n\n                if (nesa == n)\n                {\n                    res = ncost;\n                    goto end;\n                }\n\n                auto next = make_pair(nesa, nimo);\n                if (!dp.count(next))\n                {\n                    dp[next] = ncost;\n                    q.push(next);\n                }\n            }\n        }\n    }\nend:;\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1533: Caterpillar\n// 2019.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n// 数値のハッシュ関数\n#define HASHSIZ 499979\nlong long hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\n\n// 数値をハッシュテーブルに登録。成功からリターン値が1。\nint insert(long long n)\n{\n\tlong long *p = hash + (int)(n % HASHSIZ);\n\twhile (*p) {\n\t\tif (*p == n) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\t*p = n;\n\treturn 1;\n}\n\n#define QMAX 1000000\ntypedef struct { long long p; int s, lv; } Q;\nQ q[QMAX + 2]; int top, end;\nint mv[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\n\nint H, W, N;\nchar map[15][15];\n\nlong long next(int nr, int nc, long long p)\n{\n\tint i, j, r[6], c[6];\n\tr[0] = nr, c[0] = nc;                                    // Sの位置\n\tr[1] = ((p >> 40) >> 4) & 0xf, c[1] = (p >> 40) & 0xf;   // aの位置\n\tr[2] = ((p >> 32) >> 4) & 0xf, c[2] = (p >> 32) & 0xf;   // bの位置\n\tr[3] = ((p >> 24) >> 4) & 0xf, c[3] = (p >> 24) & 0xf;   // cの位置\n\tr[4] = ((p >> 16) >> 4) & 0xf, c[4] = (p >> 16) & 0xf;   // dの位置\n\tr[5] = ((p >>  8) >> 4) & 0xf, c[5] = (p >>  8) & 0xf;   // eの位置\n\n\tfor (i = 0; i < 5; i++) for (j = i + 1; j < 6; j++) {\n\t\tif (r[i] == r[j] && c[i] == c[j]) return 0;\n\t}\n\n\treturn ((long long)((r[0] << 4) | c[0]) << 40) |\n\t\t   ((long long)((r[1] << 4) | c[1]) << 32) |\n\t\t   ((long long)((r[2] << 4) | c[2]) << 24) |\n\t\t   ((long long)((r[3] << 4) | c[3]) << 16) |\n\t\t   ((long long)((r[4] << 4) | c[4]) << 8 ) |\n\t\t   ((long long)((r[5] << 4) | c[5]));\n}\n\nint bfs(long long p)\n{\n\tint i, r, c, rr, cc, s, lv;\n\tlong long pp;\n\n\tq[0].p = p, q[0].s = 0, q[0].lv = 1;\n\ttop = 0, end = 1;\n\twhile (top != end) {\n\t\tp = q[top].p, s = q[top].s, lv = q[top].lv;\n\t\tif (++top == QMAX) top = 0;\n\n\t\tr = ((p >> 40) >> 4) & 0xf, c = (p >> 40) & 0xf;   // 頭の位置\n//\t\tprintf(\"(%d,%d) s=%d, level=%d\\n\", r, c, s, lv);\n\t\tif (map[r][c] == lv+'0') lv++;\n\t\tif (lv > N) return s;\n\t\tif (!insert(p | ((long long)lv << 48))) continue;\n\n\t\ts++;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\trr = r + mv[i][0], cc = c + mv[i][1];\n\t\t\tif (rr < 0 || rr >= H || cc < 0 || cc >= W || map[rr][cc] == '#') continue;\n\t\t\tpp = next(rr, cc, p);\n\t\t\tif (pp == 0) continue;\n\t\t\tq[end].p = pp, q[end].s = s, q[end].lv = lv;\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint r, c;\n\tlong long p;\n\n\tscanf(\"%d%d%d\", &H, &W, &N);\n\tp = 0; for (r = 0; r < H; r++) {\n\t\tscanf(\"%s\", map[r]);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tswitch (map[r][c]) {\n\t\t\tcase 'S': p |= ((long long)((r << 4) | c) << 40); break;\n\t\t\tcase 'a': p |= ((long long)((r << 4) | c) << 32); break;\n\t\t\tcase 'b': p |= ((long long)((r << 4) | c) << 24); break;\n\t\t\tcase 'c': p |= ((long long)((r << 4) | c) << 16); break;\n\t\t\tcase 'd': p |= ((long long)((r << 4) | c) <<  8); break;\n\t\t\tcase 'e': p |= ((long long)((r << 4) | c)      ); break;\n\t\t\t}\n\t\t\tif (isalpha(map[r][c])) map[r][c] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", bfs(p));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1533: Caterpillar\n// 2019.2.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n// 数値のハッシュ関数\n#define HASHSIZ 99991  // 499979\nlong long hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\n\n// 数値をハッシュテーブルに登録。成功からリターン値が1。\nint insert(long long n)\n{\n\tlong long *p = hash + (int)(n % HASHSIZ);\n\twhile (*p) {\n\t\tif (*p == n) return 0;\n\t\tif (++p == hashend) p = hash;\n\t}\n\t*p = n;\n\treturn 1;\n}\n\n#define QMAX 10000\ntypedef struct { long long p; int s, lv; } Q;\nQ q[QMAX + 2]; int top, end;\nint mv[4][2] = { {-1,0},{1,0},{0,-1},{0,1} };\n\nint H, W, N;\nchar map[15][15];\n\nlong long next(int nr, int nc, long long p)\n{\n\tint i, j, r[6], c[6];\n\tr[0] = nr, c[0] = nc;                                    // Sの位置\n\tr[1] = ((p >> 40) >> 4) & 0xf, c[1] = (p >> 40) & 0xf;   // aの位置\n\tr[2] = ((p >> 32) >> 4) & 0xf, c[2] = (p >> 32) & 0xf;   // bの位置\n\tr[3] = ((p >> 24) >> 4) & 0xf, c[3] = (p >> 24) & 0xf;   // cの位置\n\tr[4] = ((p >> 16) >> 4) & 0xf, c[4] = (p >> 16) & 0xf;   // dの位置\n\tr[5] = ((p >>  8) >> 4) & 0xf, c[5] = (p >>  8) & 0xf;   // eの位置\n\n\tfor (i = 0; i < 5; i++) for (j = i + 1; j < 6; j++) {\n\t\tif (r[i] == r[j] && c[i] == c[j]) return 0;\n\t}\n\n\treturn ((long long)((r[0] << 4) | c[0]) << 40) |\n\t\t   ((long long)((r[1] << 4) | c[1]) << 32) |\n\t\t   ((long long)((r[2] << 4) | c[2]) << 24) |\n\t\t   ((long long)((r[3] << 4) | c[3]) << 16) |\n\t\t   ((long long)((r[4] << 4) | c[4]) << 8 ) |\n\t\t   ((long long)((r[5] << 4) | c[5]));\n}\n\nint bfs(long long p)\n{\n\tint i, r, c, rr, cc, s, lv;\n\tlong long pp;\n\n\tq[0].p = p, q[0].s = 0, q[0].lv = 1;\n\ttop = 0, end = 1;\n\twhile (top != end) {\n\t\tp = q[top].p, s = q[top].s, lv = q[top].lv;\n\t\tif (++top == QMAX) top = 0;\n\n\t\tr = ((p >> 40) >> 4) & 0xf, c = (p >> 40) & 0xf;   // 頭の位置\n//\t\tprintf(\"(%d,%d) s=%d, level=%d\\n\", r, c, s, lv);\n\t\tif (map[r][c] == lv+'0') lv++;\n\t\tif (lv > N) return s;\n\t\tif (!insert(p | ((long long)lv << 48))) continue;\n\n\t\ts++;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\trr = r + mv[i][0], cc = c + mv[i][1];\n\t\t\tif (rr < 0 || rr >= H || cc < 0 || cc >= W || map[rr][cc] == '#') continue;\n\t\t\tif (!(pp = next(rr, cc, p))) continue;\n\t\t\tq[end].p = pp, q[end].s = s, q[end].lv = lv;\n\t\t\tif (++end == QMAX) end = 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint r, c;\n\tlong long p;\n\n\tscanf(\"%d%d%d\", &H, &W, &N);\n\tp = 0; for (r = 0; r < H; r++) {\n\t\tscanf(\"%s\", map[r]);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tswitch (map[r][c]) {\n\t\t\tcase 'S': p |= ((long long)((r << 4) | c) << 40); break;\n\t\t\tcase 'a': p |= ((long long)((r << 4) | c) << 32); break;\n\t\t\tcase 'b': p |= ((long long)((r << 4) | c) << 24); break;\n\t\t\tcase 'c': p |= ((long long)((r << 4) | c) << 16); break;\n\t\t\tcase 'd': p |= ((long long)((r << 4) | c) <<  8); break;\n\t\t\tcase 'e': p |= ((long long)((r << 4) | c)      ); break;\n\t\t\t}\n\t\t\tif (isalpha(map[r][c])) map[r][c] = '.';\n\t\t}\n\t}\n\tprintf(\"%d\\n\", bfs(p));\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef main():\n    h, w, n = map(int, input().split())\n    mp = [list(\"#\" * (w + 2))] + [list(\"#\" + input() + \"#\") for _ in range(h)] + [list(\"#\") * (w + 2)]\n    init_body = [None] * 4\n    for y in range(1, h + 1):\n        for x in range(1, w + 1):\n            if mp[y][x] == \"S\":\n                init_head = (x, y)\n                mp[y][x] = \".\"\n            if mp[y][x] == \"e\":\n                mp[y][x] = \".\"\n            if \"a\" <= mp[y][x] <= \"d\":\n                init_body[ord(mp[y][x]) - ord(\"a\")] = (x, y)\n                mp[y][x] = \".\"\n            if \"1\" <= mp[y][x] <= \"9\":\n                mp[y][x] = int(mp[y][x])\n    \n    que = deque()\n    que.append((0, init_head, init_body, 1))\n    mem = {}\n    mem[(init_head, tuple(init_body), 1)] = 0\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    while que:\n        score, head, body, target = que.popleft()\n        if target > n:\n            print(score)\n            break\n        x, y = head\n        for dx, dy in vec:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in body:continue\n            if mp[ny][nx] == \"#\":continue\n            new_target = target\n            if mp[ny][nx] == target:new_target += 1\n            new_body = tuple([head] + list(body)[:-1])\n            if ((nx, ny), new_body, new_target) not in mem:\n                mem[((nx, ny), new_body, new_target)] = True\n                que.append((score + 1, (nx, ny), new_body, new_target))\n    else:\n        print(-1)\n\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "use std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::Sub;\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::BTreeSet;\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nenum Dir {\n    Up, Right, Down, Left\n}\nimpl Dir {\n    fn to_int(&self) -> i32 {\n        match *self {\n            Dir::Up => 0,\n            Dir::Right => 1,\n            Dir::Down => 2,\n            Dir::Left => 3\n        }\n    }\n    fn from_int(value: i32) -> Dir {\n        match value & 3 {\n            0 => Dir::Up,\n            1 => Dir::Right,\n            2 => Dir::Down,\n            3 => Dir::Left,\n            _ => panic!()\n        }\n    }\n    fn reverse(&self) -> Dir {\n        Dir::from_int(self.to_int() + 2)\n    }\n    fn to_coordinate(&self) -> Coordinate {\n        match *self {\n            Dir::Up => Coordinate{x: 0, y: -1},\n            Dir::Right => Coordinate{x: 1, y: 0},\n            Dir::Down => Coordinate{x: 0, y: 1},\n            Dir::Left => Coordinate{x: -1, y: 0}\n        }\n    }\n    fn all() -> Vec<Dir> {\n        vec![Dir::Up, Dir::Right, Dir::Down, Dir::Left]\n    }\n    \n}\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\nstruct Coordinate {\n    x: i32, y: i32\n}\nimpl Coordinate {\n}\nimpl Add for Coordinate {\n    type Output = Coordinate;\n    fn add(self, rhs: Coordinate) -> <Self as std::ops::Add<Coordinate>>::Output { \n        Coordinate{x: self.x + rhs.x, y: self.y + rhs.y}\n     }\n}\n\nfn read_initial_state(state: &Vec<Vec<char>>) -> (Coordinate, i32) {\n    let mut current_pos = (0 .. state.len()).into_iter().flat_map(|y| (0 .. state[y].len()).into_iter().find(|&x| state[y][x] == 'e').map(|x| Coordinate{x: x as i32, y: y as i32})).into_iter().next().unwrap();\n    let mut serial = 0i32;\n    for c in \"dcbaS\".chars() {\n        for dir in Dir::all() {\n            let Coordinate{x: x, y: y} = dir.to_coordinate() + current_pos;\n            if 0 <= y && y < state.len() as i32 && 0 <= x && x < state[y as usize].len() as i32 && state[y as usize][x as usize] == c {\n                current_pos = Coordinate{x: x, y: y};\n                serial <<= 2;\n                serial += dir.to_int();\n                break;\n            }\n        }\n    }\n    (current_pos, serial)\n}\nfn can_move_to(dir: Dir, mut head: Coordinate, mut serial: i32) -> bool {\n    let next = dir.to_coordinate() + head;\n    for _ in 0 .. 4 {\n        head = head + Dir::from_int(serial & 3).reverse().to_coordinate();\n        if next == head {\n            return false;\n        }        \n        serial >>= 2;\n    }\n    true\n}\nfn main() {\n    read!{\n        height: usize, width: usize, n: usize\n    }\n    read! {\n        state: [String; height]\n    }\n    let state = state.into_iter().map(|str| str.chars().collect::<Vec<_>>()).collect::<Vec<_>>();\n    let mut min_step = vec![vec![vec![vec![std::usize::MAX; n + 1]; 1 << 10]; width]; height];\n    let mut queue = VecDeque::new();\n    let (initial_pos, initial_state) = read_initial_state(&state);\n    let mask = 1023;\n    queue.push_back((initial_pos, initial_state, 0));\n    min_step[initial_pos.y as usize][initial_pos.x as usize][initial_state as usize][0] = 0;\n    while let Some((pos, serial, count)) = queue.pop_front() {\n        let step = min_step[pos.y as usize][pos.x as usize][serial as usize][count];\n        for dir in Dir::all() {\n            let Coordinate{x: x, y: y} = pos + dir.to_coordinate();\n            if 0 <= y && y < state.len() as i32 && 0 <= x && x < state[y as usize].len() as i32 && can_move_to(dir, pos, serial) {\n                match state[y as usize][x as usize] {\n                    '#' => continue,\n                    c => {\n                        let new_serial = ((serial << 2) + dir.to_int()) & mask;\n                        let num = if '0' < c && c <= '9' && c as i32 - '0' as i32 == count as i32 + 1 {\n                            count + 1\n                        }else {\n                            count\n                        };\n                        if min_step[y as usize][x as usize][new_serial as usize][num as usize] == std::usize::MAX {\n                            min_step[y as usize][x as usize][new_serial as usize][num as usize] = step + 1;\n                            queue.push_back((Coordinate{x: x, y: y}, new_serial, num));\n                        } \n                    }\n                }\n            }\n        }\n    }\n    let mut result = std::usize::MAX;\n    for i in 0 .. height {\n        for j in 0 .. width {\n            for s in 0 .. 1024 {\n                result = min(result, min_step[i][j][s][n]);\n            }\n        }\n    }\n    if result == std::usize::MAX {\n        println!(\"-1\");\n    }else {\n        println!(\"{}\", result);\n    }\n    \n}\n\n"
  }
]