[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 50\n#define MAX_FOOD 9\n#define DIRS 4\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef struct {\n    Position pos[6]; // head (S) + 5 body parts (a-e)\n    int food_index;\n} State;\n\nint rows, cols, food_count;\nchar grid[MAX_SIZE][MAX_SIZE];\nPosition food_pos[MAX_FOOD];\nint min_steps = INT_MAX;\n\nint dx[DIRS] = {0, 1, 0, -1};\nint dy[DIRS] = {1, 0, -1, 0};\n\nint visited[MAX_SIZE][MAX_SIZE][1 << (MAX_SIZE * MAX_SIZE / 32)]; // Simplified for brevity\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != '#';\n}\n\nint is_body(State *s, int x, int y) {\n    for (int i = 1; i < 6; i++) {\n        if (s->pos[i].x == x && s->pos[i].y == y) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid bfs(State initial) {\n    State queue[MAX_SIZE * MAX_SIZE * 100];\n    int front = 0, rear = 0;\n    int steps[MAX_SIZE * MAX_SIZE * 100] = {0};\n    queue[rear++] = initial;\n\n    while (front < rear) {\n        State current = queue[front];\n        int current_step = steps[front++];\n\n        if (current.food_index == food_count) {\n            if (current_step < min_steps) {\n                min_steps = current_step;\n            }\n            continue;\n        }\n\n        for (int d = 0; d < DIRS; d++) {\n            int nx = current.pos[0].x + dx[d];\n            int ny = current.pos[0].y + dy[d];\n\n            if (!is_valid(nx, ny) || is_body(&current, nx, ny)) {\n                continue;\n            }\n\n            State next = current;\n            for (int i = 5; i > 0; i--) {\n                next.pos[i] = next.pos[i - 1];\n            }\n            next.pos[0].x = nx;\n            next.pos[0].y = ny;\n\n            if (nx == food_pos[next.food_index].x && ny == food_pos[next.food_index].y) {\n                next.food_index++;\n            }\n\n            // Simplified visited check (actual implementation would use a more efficient method)\n            int is_visited = 0;\n            for (int i = 0; i < rear; i++) {\n                if (memcmp(&queue[i], &next, sizeof(State)) == 0) {\n                    is_visited = 1;\n                    break;\n                }\n            }\n            if (!is_visited) {\n                queue[rear] = next;\n                steps[rear] = current_step + 1;\n                rear++;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    State initial;\n    initial.food_index = 0;\n    food_count = 0;\n\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'S') {\n                initial.pos[0].x = i;\n                initial.pos[0].y = j;\n            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'e') {\n                int idx = grid[i][j] - 'a' + 1;\n                initial.pos[idx].x = i;\n                initial.pos[idx].y = j;\n            } else if (grid[i][j] >= '1' && grid[i][j] <= '9') {\n                int idx = grid[i][j] - '1';\n                food_pos[idx].x = i;\n                food_pos[idx].y = j;\n                food_count++;\n            }\n        }\n    }\n\n    bfs(initial);\n    printf(\"%d\\n\", min_steps == INT_MAX ? -1 : min_steps);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x, y;\n    int body[5][2]; // positions of body segments a to e\n    int food_order;\n    int steps;\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n\n    vector<string> grid(H);\n    int start_x = -1, start_y = -1;\n    vector<pair<int, int>> body_pos(5);\n    vector<pair<int, int>> food_pos(N + 1);\n\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            } else if (grid[i][j] >= 'a' && grid[i][j] <= 'e') {\n                int idx = grid[i][j] - 'a';\n                body_pos[idx] = {i, j};\n            } else if (grid[i][j] >= '1' && grid[i][j] <= '9') {\n                int idx = grid[i][j] - '0';\n                food_pos[idx] = {i, j};\n            }\n        }\n    }\n\n    // Initialize visited structure\n    bool visited[H][W][6][4][4][4][4]; // H, W, food_order, body_diffs (simplified for 5 body parts)\n    memset(visited, 0, sizeof(visited));\n\n    queue<State> q;\n    State initial;\n    initial.x = start_x;\n    initial.y = start_y;\n    for (int i = 0; i < 5; ++i) {\n        initial.body[i][0] = body_pos[i].first;\n        initial.body[i][1] = body_pos[i].second;\n    }\n    initial.food_order = 1;\n    initial.steps = 0;\n\n    q.push(initial);\n\n    int result = -1;\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.food_order > N) {\n            result = current.steps;\n            break;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = current.x + dx[d];\n            int ny = current.y + dy[d];\n\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if (grid[nx][ny] == '#') continue;\n\n            // Check if new head position is on any body segment except the last one\n            bool collision = false;\n            for (int i = 0; i < 4; ++i) { // Check first 4 body segments (a-d)\n                if (nx == current.body[i][0] && ny == current.body[i][1]) {\n                    collision = true;\n                    break;\n                }\n            }\n            if (collision) continue;\n\n            State next = current;\n            next.x = nx;\n            next.y = ny;\n\n            // Update body positions\n            for (int i = 4; i > 0; --i) {\n                next.body[i][0] = next.body[i-1][0];\n                next.body[i][1] = next.body[i-1][1];\n            }\n            next.body[0][0] = current.x;\n            next.body[0][1] = current.y;\n\n            next.steps++;\n\n            // Check if current food is eaten\n            if (nx == food_pos[next.food_order].first && ny == food_pos[next.food_order].second) {\n                next.food_order++;\n            }\n\n            // Check visited (simplified for this problem)\n            bool &vis = visited[nx][ny][next.food_order][next.body[0][0]-next.x+1][next.body[0][1]-next.y+1][next.body[1][0]-next.body[0][0]+1][next.body[1][1]-next.body[0][1]+1];\n            if (vis) continue;\n            vis = true;\n\n            q.push(next);\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass State {\n    int x, y;\n    String body;\n    int foodIndex;\n    int steps;\n\n    State(int x, int y, String body, int foodIndex, int steps) {\n        this.x = x;\n        this.y = y;\n        this.body = body;\n        this.foodIndex = foodIndex;\n        this.steps = steps;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        State state = (State) o;\n        return x == state.x && y == state.y && foodIndex == state.foodIndex && body.equals(state.body);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y, body, foodIndex);\n    }\n}\n\npublic class Main {\n    static final int[] dx = {-1, 1, 0, 0};\n    static final int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        sc.nextLine();\n\n        char[][] grid = new char[H][W];\n        int startX = -1, startY = -1;\n        StringBuilder initialBody = new StringBuilder();\n        int maxFood = 0;\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'e') {\n                    initialBody.append(grid[i][j]);\n                } else if (grid[i][j] >= '1' && grid[i][j] <= '9') {\n                    maxFood = Math.max(maxFood, grid[i][j] - '0');\n                }\n            }\n        }\n\n        String targetFoodOrder = \"\";\n        for (int i = 1; i <= maxFood; i++) {\n            targetFoodOrder += (char) ('0' + i);\n        }\n\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n        State initialState = new State(startX, startY, initialBody.toString(), 0, 0);\n        queue.add(initialState);\n        visited.add(initialState);\n\n        int result = -1;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.foodIndex == targetFoodOrder.length()) {\n                result = current.steps;\n                break;\n            }\n\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = current.x + dx[dir];\n                int ny = current.y + dy[dir];\n\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n                if (grid[nx][ny] == '#') continue;\n\n                boolean bodyCollision = false;\n                int bodyX = current.x;\n                int bodyY = current.y;\n                for (int i = 0; i < current.body.length(); i++) {\n                    if (nx == bodyX && ny == bodyY) {\n                        bodyCollision = true;\n                        break;\n                    }\n                    char bodyChar = current.body.charAt(i);\n                    int[] pos = getBodyPos(bodyX, bodyY, bodyChar);\n                    bodyX = pos[0];\n                    bodyY = pos[1];\n                }\n                if (bodyCollision) continue;\n\n                String newBody = \"\";\n                if (current.body.length() > 0) {\n                    newBody = current.x + \"\" + current.y + current.body.substring(0, current.body.length() - 1);\n                }\n\n                int newFoodIndex = current.foodIndex;\n                if (current.foodIndex < targetFoodOrder.length() && grid[nx][ny] == targetFoodOrder.charAt(current.foodIndex)) {\n                    newFoodIndex++;\n                }\n\n                State newState = new State(nx, ny, newBody, newFoodIndex, current.steps + 1);\n                if (!visited.contains(newState)) {\n                    visited.add(newState);\n                    queue.add(newState);\n                }\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    private static int[] getBodyPos(int x, int y, char bodyChar) {\n        switch (bodyChar) {\n            case 'a': return new int[]{x - 1, y};\n            case 'b': return new int[]{x + 1, y};\n            case 'c': return new int[]{x, y - 1};\n            case 'd': return new int[]{x, y + 1};\n            default: return new int[]{x, y};\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:02:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class CaterpillarPath {\n    static int R, C;\n    static char[][] grid;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    static List<int[]> foods;\n    static int[] startHead, startBody;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        R = Integer.parseInt(st.nextToken());\n        C = Integer.parseInt(st.nextToken());\n        \n        grid = new char[R][C];\n        foods = new ArrayList<>();\n        startHead = new int[2];\n        startBody = new int[5][2];\n        \n        for (int i = 0; i < R; i++) {\n            String line = br.readLine();\n            for (int j = 0; j < C; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'S') {\n                    startHead[0] = i;\n                    startHead[1] = j;\n                } else if (grid[i][j] >= '1' && grid[i][j] <= '9') {\n                    foods.add(new int[]{i, j, grid[i][j] - '0'});\n                } else if (grid[i][j] >= 'a' && grid[i][j] <= 'e') {\n                    startBody[grid[i][j] - 'a'][0] = i;\n                    startBody[grid[i][j] - 'a'][1] = j;\n                }\n            }\n        }\n        \n        foods.sort(Comparator.comparingInt(a -> a[2]));\n        \n        int result = bfs();\n        System.out.println(result);\n    }\n    \n    static int bfs() {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State initial = new State(startHead, startBody, 0, 0);\n        queue.offer(initial);\n        visited.add(initial.getKey());\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            if (current.foodIndex == foods.size()) {\n                return current.steps;\n            }\n            \n            for (int d = 0; d < 4; d++) {\n                int[] newHead = {current.head[0] + dx[d], current.head[1] + dy[d]};\n                int[][] newBody = new int[5][2];\n                \n                for (int i = 0; i < 5; i++) {\n                    newBody[i][0] = current.body[i][0] + dx[d];\n                    newBody[i][1] = current.body[i][1] + dy[d];\n                }\n                \n                if (isValidMove(newHead, newBody)) {\n                    int newFoodIndex = current.foodIndex;\n                    if (newHead[0] == foods.get(newFoodIndex)[0] && newHead[1] == foods.get(newFoodIndex)[1]) {\n                        newFoodIndex++;\n                    }\n                    \n                    State newState = new State(newHead, newBody, newFoodIndex, current.steps + 1);\n                    String key = newState.getKey();\n                    \n                    if (!visited.contains(key)) {\n                        queue.offer(newState);\n                        visited.add(key);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    static boolean isValidMove(int[] head, int[][] body) {\n        if (head[0] < 0 || head[0] >= R || head[1] < 0 || head[1] >= C || \n            grid[head[0]][head[1]] == '#') {\n            return false;\n        }\n        \n        for (int[] segment : body) {\n            if (head[0] == segment[0] && head[1] == segment[1]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    static class State {\n        int[] head;\n        int[][] body;\n        int foodIndex;\n        int steps;\n        \n        State(int[] head, int[][] body, int foodIndex, int steps) {\n            this.head = head.clone();\n            this.body = new int[5][2];\n            for (int i = 0; i < 5; i++) {\n                this.body[i] = body[i].clone();\n            }\n            this.foodIndex = foodIndex;\n            this.steps = steps;\n        }\n        \n        String getKey() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(head[0]).append(\",\").append(head[1]).append(\"|\");\n            for (int[] segment : body) {\n                sb.append(segment[0]).append(\",\").append(segment[1]).append(\"|\");\n            }\n            sb.append(foodIndex);\n            return sb.toString();\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:02:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 20\n#define MAX_QUEUE 10000\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point head;\n    Point body[5];\n    int steps;\n    int eaten_food;\n    char grid[MAX_N][MAX_N];\n} State;\n\nint R, C, food_count;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool is_valid_move(State *state, int nx, int ny) {\n    if (nx < 0 || nx >= R || ny < 0 || ny >= C || state->grid[nx][ny] == '#') \n        return false;\n\n    for (int i = 0; i < 5; i++) {\n        if (nx == state->body[i].x && ny == state->body[i].y)\n            return false;\n    }\n    return true;\n}\n\nbool move_caterpillar(State *current, State *next, int dir) {\n    *next = *current;\n    next->steps++;\n\n    int nx = current->head.x + dx[dir];\n    int ny = current->head.y + dy[dir];\n\n    if (!is_valid_move(current, nx, ny)) \n        return false;\n\n    // Move body segments\n    for (int i = 4; i > 0; i--) {\n        next->body[i] = current->body[i-1];\n    }\n    next->body[0] = current->head;\n    next->head.x = nx;\n    next->head.y = ny;\n\n    // Check if eating food\n    if (next->grid[nx][ny] == next->eaten_food + '1') {\n        next->eaten_food++;\n        next->grid[nx][ny] = '.';\n    }\n\n    return true;\n}\n\nint bfs(State *initial_state) {\n    State queue[MAX_QUEUE];\n    bool visited[MAX_N][MAX_N][10];\n    memset(visited, 0, sizeof(visited));\n\n    int front = 0, rear = 0;\n    queue[rear++] = *initial_state;\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (current.eaten_food == food_count)\n            return current.steps;\n\n        for (int dir = 0; dir < 4; dir++) {\n            State next;\n            if (move_caterpillar(&current, &next, dir)) {\n                if (!visited[next.head.x][next.head.y][next.eaten_food]) {\n                    visited[next.head.x][next.head.y][next.eaten_food] = true;\n                    queue[rear++] = next;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &R, &C);\n    State initial_state = {0};\n    food_count = 0;\n\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", initial_state.grid[i]);\n        for (int j = 0; j < C; j++) {\n            if (initial_state.grid[i][j] == 'S')\n                initial_state.head = (Point){i, j};\n            else if (initial_state.grid[i][j] >= '1' && initial_state.grid[i][j] <= '9')\n                food_count++;\n            else if (initial_state.grid[i][j] == 'a')\n                initial_state.body[0] = (Point){i, j};\n            else if (initial_state.grid[i][j] == 'b')\n                initial_state.body[1] = (Point){i, j};\n            else if (initial_state.grid[i][j] == 'c')\n                initial_state.body[2] = (Point){i, j};\n            else if (initial_state.grid[i][j] == 'd')\n                initial_state.body[3] = (Point){i, j};\n            else if (initial_state.grid[i][j] == 'e')\n                initial_state.body[4] = (Point){i, j};\n        }\n    }\n\n    int result = bfs(&initial_state);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nstruct State {\n    vector<pair<int, int>> body;\n    int steps;\n    int eaten;\n    \n    bool operator<(const State& other) const {\n        return steps > other.steps;\n    }\n};\n\nbool is_valid_move(vector<vector<char>>& grid, vector<pair<int, int>>& new_body) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    for (auto& pos : new_body) {\n        int x = pos.first, y = pos.second;\n        if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] == '#') {\n            return false;\n        }\n    }\n    \n    for (int i = 1; i < new_body.size(); i++) {\n        if (new_body[i] == new_body[0]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint solve(vector<vector<char>>& grid, vector<int>& food_order) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    State initial_state;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'S') initial_state.body.push_back({i, j});\n            if (grid[i][j] == 'a') initial_state.body.push_back({i, j});\n            if (grid[i][j] == 'b') initial_state.body.push_back({i, j});\n            if (grid[i][j] == 'c') initial_state.body.push_back({i, j});\n            if (grid[i][j] == 'd') initial_state.body.push_back({i, j});\n            if (grid[i][j] == 'e') initial_state.body.push_back({i, j});\n        }\n    }\n    \n    initial_state.steps = 0;\n    initial_state.eaten = 0;\n    \n    priority_queue<State> pq;\n    pq.push(initial_state);\n    \n    vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(10, false)));\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.eaten == food_order.size()) {\n            return curr.steps;\n        }\n        \n        pair<int, int> head = curr.body[0];\n        \n        for (int dir = 0; dir < 4; dir++) {\n            vector<pair<int, int>> new_body = curr.body;\n            \n            for (int i = new_body.size() - 1; i > 0; i--) {\n                new_body[i] = new_body[i - 1];\n            }\n            \n            new_body[0] = {head.first + dx[dir], head.second + dy[dir]};\n            \n            if (!is_valid_move(grid, new_body)) continue;\n            \n            int x = new_body[0].first, y = new_body[0].second;\n            \n            State next_state = curr;\n            next_state.body = new_body;\n            next_state.steps++;\n            \n            char cell = grid[x][y];\n            \n            if (cell >= '1' && cell <= '9') {\n                int food_num = cell - '0';\n                \n                if (food_num == food_order[curr.eaten]) {\n                    next_state.eaten++;\n                    grid[x][y] = '.';\n                }\n            }\n            \n            if (!visited[x][y][next_state.eaten]) {\n                visited[x][y][next_state.eaten] = true;\n                pq.push(next_state);\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int rows, cols, num_foods;\n    cin >> rows >> cols >> num_foods;\n    \n    vector<vector<char>> grid(rows, vector<char>(cols));\n    vector<int> food_order(num_foods);\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < num_foods; i++) {\n        cin >> food_order[i];\n    }\n    \n    int result = solve(grid, food_order);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef find_start_and_food_positions(grid):\n    start_pos, food_positions = None, {}\n    for r, row in enumerate(grid):\n        for c, char in enumerate(row):\n            if char == 'S':\n                start_pos = (r, c)\n            elif char.isdigit():\n                food_positions[int(char)] = (r, c)\n    return start_pos, [food_positions[i] for i in sorted(food_positions.keys())]\n\ndef is_valid_position(r, c, ROWS, COLS, grid, visited, body_positions):\n    return (0 <= r < ROWS and 0 <= c < COLS and\n            grid[r][c] != '#' and\n            (r, c) not in body_positions and\n            (r, c) not in visited)\n\ndef bfs_min_steps(grid, start_pos, food_positions):\n    ROWS, COLS = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right\n\n    # Initial caterpillar state with head and body positions\n    initial_positions = [start_pos] + [(start_pos[0], start_pos[1] - i) for i in range(1, 6)]\n\n    queue = deque([(initial_positions, 0, 0)])  # body_positions, current food index, steps\n    visited = set()\n    visited.add(tuple(initial_positions))\n\n    while queue:\n        body_positions, food_index, steps = queue.popleft()\n\n        if food_index == len(food_positions):\n            return steps\n\n        head_r, head_c = body_positions[0]\n\n        for dr, dc in directions:\n            new_head_r, new_head_c = head_r + dr, head_c + dc\n            new_body_positions = [(new_head_r, new_head_c)] + body_positions[:-1]\n\n            if is_valid_position(new_head_r, new_head_c, ROWS, COLS, grid, visited, new_body_positions[1:]):\n                if (new_head_r, new_head_c) == food_positions[food_index]:\n                    visited.clear()  # After consuming food, start fresh for visited positions\n                    queue.append((new_body_positions, food_index + 1, steps + 1))\n                else:\n                    if tuple(new_body_positions) not in visited:\n                        visited.add(tuple(new_body_positions))\n                        queue.append((new_body_positions, food_index, steps + 1))\n    \n    return -1\n\ndef caterpillar_min_steps(grid):\n    start_pos, food_positions = find_start_and_food_positions(grid)\n    if not food_positions:  # No food to eat\n        return 0\n    return bfs_min_steps(grid, start_pos, food_positions)\n\n# Example usage\ngrid = [\n    \"S.....\",\n    \".#####\",\n    \".3....\",\n    \".#####\",\n    \".2..1.\",\n]\nprint(caterpillar_min_steps(grid))",
    "timestamp": "2025-08-13 04:31:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Caterpillar {\n\n    static class State {\n        int headX, headY, length, foodEaten;\n        int[] bodyX, bodyY;\n\n        State(int hx, int hy, int len, int fe, int[] bx, int[] by) {\n            headX = hx;\n            headY = hy;\n            length = len;\n            foodEaten = fe;\n            bodyX = bx;\n            bodyY = by;\n        }\n    }\n\n    private static final int[][] DIRECTIONS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    private static boolean isInBounds(int x, int y, int rows, int cols) {\n        return x >= 0 && y >= 0 && x < rows && y < cols;\n    }\n\n    public static int minStepsToEatAllFood(char[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int maxFood = 0;\n        int startX = 0, startY = 0;\n        int[] startBodyX = new int[5];\n        int[] startBodyY = new int[5];\n\n        // Locate starting conditions, including food number and caterpillar's initial position\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                char ch = grid[r][c];\n                if ('1' <= ch && ch <= '9') { maxFood = Math.max(maxFood, ch - '0'); }\n                else if (ch == 'S') { startX = r; startY = c; }\n                else if ('a' <= ch && ch <= 'e') {\n                    startBodyX[ch - 'a'] = r;\n                    startBodyY[ch - 'a'] = c;\n                }\n            }\n        }\n\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State startState = new State(startX, startY, 6, 0, startBodyX, startBodyY);\n        queue.add(startState);\n        visited.add(encodeState(startState));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.foodEaten == maxFood) { return current.length - 6; }\n            \n            for (int[] dir : DIRECTIONS) {\n                int newHeadX = current.headX + dir[0];\n                int newHeadY = current.headY + dir[1];\n\n                if (!isInBounds(newHeadX, newHeadY, rows, cols) || grid[newHeadX][newHeadY] == '#' ||\n                    containsBody(newHeadX, newHeadY, current.bodyX, current.bodyY)) {\n                    continue;\n                }\n\n                // Shift body\n                int[] newBodyX = new int[5];\n                int[] newBodyY = new int[5];\n\n                for (int i = 0; i < 4; i++) {\n                    newBodyX[i + 1] = current.bodyX[i];\n                    newBodyY[i + 1] = current.bodyY[i];\n                }\n                newBodyX[0] = current.headX;\n                newBodyY[0] = current.headY;\n\n                int newFoodEaten = current.foodEaten;\n                if ('1' <= grid[newHeadX][newHeadY] && grid[newHeadX][newHeadY] <= '9') {\n                    int foodNumber = grid[newHeadX][newHeadY] - '0';\n                    if (foodNumber == newFoodEaten + 1) {\n                        newFoodEaten++;\n                    }\n                }\n\n                State newState = new State(newHeadX, newHeadY, current.length + 1, newFoodEaten, newBodyX, newBodyY);\n                String encoded = encodeState(newState);\n\n                if (!visited.contains(encoded)) {\n                    queue.add(newState);\n                    visited.add(encoded);\n                }\n            }\n        }\n        \n        return -1;\n    }\n\n    private static boolean containsBody(int x, int y, int[] bodyX, int[] bodyY) {\n        for (int i = 0; i < 5; i++) {\n            if (x == bodyX[i] && y == bodyY[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static String encodeState(State state) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(state.headX).append(',').append(state.headY).append(',');\n        for (int i = 0; i < 5; i++) {\n            sb.append(state.bodyX[i]).append(',').append(state.bodyY[i]).append(',');\n        }\n        sb.append(state.foodEaten);\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        // Example test case\n        char[][] grid = {\n            {'S', '.', '.', '1'},\n            {'.', '#', '.', '.'},\n            {'.', '2', '#', '.'},\n            {'.', '.', '.', '.'}\n        };\n        System.out.println(minStepsToEatAllFood(grid));\n    }\n}",
    "timestamp": "2025-08-13 04:31:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX 50\n#define INF 100000\n\ntypedef struct {\n    int headX, headY;\n    int bodyX[5], bodyY[5];\n    int steps;\n} Caterpillar;\n\nint R, C;\nchar grid[MAX][MAX];\nint dist[MAX][MAX][MAX][MAX][MAX][MAX][MAX][MAX];\nint foodCount = 0;\nint foodOrder[10][2];\n\nint directions[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < R && y >= 0 && y < C;\n}\n\nbool isFood(char ch) {\n    return ch >= '1' && ch <= '9';\n}\n\nint BFS(Caterpillar start) {\n    memset(dist, INF, sizeof(dist));\n    dist[start.headX][start.headY][start.bodyX[0]][start.bodyY[0]][start.bodyX[1]][start.bodyY[1]][start.bodyX[2]][start.bodyY[2]] = 0;\n\n    Caterpillar queue[MAX * MAX * MAX];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n\n    while(front < rear) {\n        Caterpillar curr = queue[front++];\n        \n        for(int i = 0; i < 4; ++i) {\n            int newHeadX = curr.headX + directions[i][0];\n            int newHeadY = curr.headY + directions[i][1];\n\n            if(!isValid(newHeadX, newHeadY) || grid[newHeadX][newHeadY] == '#' ||\n               (newHeadX == curr.bodyX[0] && newHeadY == curr.bodyY[0]) ||\n               (newHeadX == curr.bodyX[1] && newHeadY == curr.bodyY[1]) ||\n               (newHeadX == curr.bodyX[2] && newHeadY == curr.bodyY[2])) {\n                continue;\n            }\n            \n            Caterpillar next = curr;\n            next.steps++;\n            for(int j = 4; j > 0; --j) {\n                next.bodyX[j] = next.bodyX[j-1];\n                next.bodyY[j] = next.bodyY[j-1];\n            }\n            next.bodyX[0] = curr.headX;\n            next.bodyY[0] = curr.headY;\n            next.headX = newHeadX;\n            next.headY = newHeadY;\n\n            if(dist[next.headX][next.headY][next.bodyX[0]][next.bodyY[0]][next.bodyX[1]][next.bodyY[1]][next.bodyX[2]][next.bodyY[2]] > next.steps) {\n                dist[next.headX][next.headY][next.bodyX[0]][next.bodyY[0]][next.bodyX[1]][next.bodyY[1]][next.bodyX[2]][next.bodyY[2]] = next.steps;\n                queue[rear++] = next;\n            }\n\n            char cell = grid[next.headX][next.headY];\n\n            if(isFood(cell)) {\n                int foodIdx = cell - '1';\n                if(foodIdx == foodCount) {\n                    grid[next.headX][next.headY] = '.';\n                    if(foodIdx + 1 == foodCount) {\n                        return next.steps;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d\", &R, &C);\n    Caterpillar start;\n\n    for(int i = 0; i < R; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    for(int i = 0; i < R; ++i) {\n        for(int j = 0; j < C; ++j) {\n            if(grid[i][j] == 'S') {\n                start.headX = i; start.headY = j;\n            } else if(grid[i][j] == 'a') {\n                start.bodyX[0] = i; start.bodyY[0] = j;\n            } else if(grid[i][j] == 'b') {\n                start.bodyX[1] = i; start.bodyY[1] = j;\n            } else if(grid[i][j] == 'c') {\n                start.bodyX[2] = i; start.bodyY[2] = j;\n            } else if(grid[i][j] == 'd') {\n                start.bodyX[3] = i; start.bodyY[3] = j;\n            } else if(grid[i][j] == 'e') {\n                start.bodyX[4] = i; start.bodyY[4] = j;\n            } else if(isFood(grid[i][j])) {\n                int idx = grid[i][j] - '1';\n                foodOrder[idx][0] = i;\n                foodOrder[idx][1] = j;\n                if(idx + 1 > foodCount) {\n                    foodCount = idx + 1;\n                }\n            }\n        }\n    }\n\n    start.steps = 0;\n    int result = BFS(start);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:32:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport copy\n\ndef find_caterpillar_positions(grid):\n    positions = {'head': None, 'body': []}\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == 'S':\n                positions['head'] = (r, c)\n            elif grid[r][c] in 'abcde':\n                positions['body'].append((r, c))\n    return positions\n\ndef is_valid_move(grid, new_positions):\n    rows, cols = len(grid), len(grid[0])\n    for r, c in new_positions:\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '#' or (grid[r][c] in 'abcde' and (r, c) not in new_positions)):\n            return False\n    return True\n\ndef get_possible_moves(head, body):\n    moves = []\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dr, dc in directions:\n        new_head = (head[0] + dr, head[1] + dc)\n        new_body = [(body[0][0] + dr, body[0][1] + dc)] + body[:-1]\n        moves.append((new_head, new_body))\n    return moves\n\ndef solve_caterpillar_path(grid, order):\n    initial_positions = find_caterpillar_positions(grid)\n    start_head = initial_positions['head']\n    start_body = initial_positions['body']\n    \n    queue = deque([(grid, start_head, start_body, 0, 0)])\n    visited = set()\n    \n    while queue:\n        current_grid, head, body, steps, current_food_index = queue.popleft()\n        \n        state_key = (head, tuple(body), current_food_index)\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        if current_food_index == len(order):\n            return steps\n        \n        target_food = order[current_food_index]\n        \n        for new_head, new_body in get_possible_moves(head, body):\n            new_grid = copy.deepcopy(current_grid)\n            \n            if is_valid_move(new_grid, [new_head] + new_body):\n                # Update grid\n                new_grid[head[0]][head[1]] = '.'\n                new_grid[body[-1][0]][body[-1][1]] = '.'\n                new_grid[new_head[0]][new_head[1]] = 'S'\n                for i, (r, c) in enumerate(new_body):\n                    new_grid[r][c] = chr(ord('a') + i)\n                \n                # Check if food is eaten\n                new_food_index = current_food_index\n                if new_grid[new_head[0]][new_head[1]] == target_food:\n                    new_grid[new_head[0]][new_head[1]] = 'S'\n                    new_food_index += 1\n                \n                queue.append((new_grid, new_head, new_body, steps + 1, new_food_index))\n    \n    return -1\n\ndef main():\n    R, C, K = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(R)]\n    order = list(input().strip())\n    \n    print(solve_caterpillar_path(grid, order))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 04:33:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    h, w = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(h)]\n    \n    # Find initial positions of S, a, b, c, d, e\n    body_pos = {}\n    food_pos = {}\n    food_order = []\n    for i in range(h):\n        for j in range(w):\n            c = grid[i][j]\n            if c == 'S':\n                body_pos['S'] = (i, j)\n            elif c in {'a', 'b', 'c', 'd', 'e'}:\n                body_pos[c] = (i, j)\n            elif c.isdigit():\n                food_pos[int(c)] = (i, j)\n                food_order.append(int(c))\n    \n    # Check if all food orders are present\n    max_food = max(food_order) if food_order else 0\n    for i in range(1, max_food + 1):\n        if i not in food_pos:\n            print(-1)\n            return\n    \n    # The body parts in order: S (head), a, b, c, d, e\n    body_order = ['S', 'a', 'b', 'c', 'd', 'e']\n    \n    # BFS setup\n    # State: (head_row, head_col, body_positions), current_food_index, steps\n    initial_body = [body_pos[p] for p in body_order]\n    q = deque()\n    q.append((body_pos['S'][0], body_pos['S'][1], tuple(initial_body), 0, 0))\n    \n    visited = set()\n    visited.add((body_pos['S'][0], body_pos['S'][1], tuple(initial_body), 0))\n    \n    while q:\n        hr, hc, body, food_idx, steps = q.popleft()\n        \n        if food_idx == len(food_order):\n            print(steps)\n            return\n        \n        # Check if current head is on the next food\n        current_food = food_order[food_idx]\n        if (hr, hc) == food_pos[current_food]:\n            q.append((hr, hc, body, food_idx + 1, steps))\n            visited.add((hr, hc, body, food_idx + 1))\n            continue\n        \n        for dr, dc in directions:\n            new_hr = hr + dr\n            new_hc = hc + dc\n            if 0 <= new_hr < h and 0 <= new_hc < w:\n                # Check if new head position is valid (not obstacle or body except tail)\n                cell = grid[new_hr][new_hc]\n                if cell == '#':\n                    continue\n                \n                # Check if new head position is in body (except tail)\n                body_list = list(body)\n                valid_move = True\n                for i in range(1, len(body_list) - 1):\n                    if (new_hr, new_hc) == body_list[i]:\n                        valid_move = False\n                        break\n                if not valid_move:\n                    continue\n                \n                # New body positions: head moves, each body part follows the previous one\n                new_body = [(new_hr, new_hc)]\n                for i in range(len(body_list) - 1):\n                    new_body.append(body_list[i])\n                new_body_tuple = tuple(new_body)\n                \n                state = (new_hr, new_hc, new_body_tuple, food_idx)\n                if state not in visited:\n                    visited.add(state)\n                    q.append((new_hr, new_hc, new_body_tuple, food_idx, steps + 1))\n    \n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 04:33:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\nstruct State {\n    vector<pair<int, int>> positions;\n    int foodIndex;\n    State(vector<pair<int, int>> p, int f) : positions(p), foodIndex(f) {}\n};\n\nbool isValidMove(const vector<string>& grid, const vector<pair<int, int>>& pos, int nx, int ny) {\n    if (nx < 0 || ny < 0 || nx >= grid.size() || ny >= grid[0].size()) return false;\n    if (grid[nx][ny] == '#') return false;\n    for (int i = 1; i < pos.size(); ++i) {\n        if (pos[i].first == nx && pos[i].second == ny) return false;\n    }\n    return true;\n}\n\nint bfs(vector<string>& grid, vector<pair<int, int>>& startPos, vector<pair<int, int>>& foodPos) {\n    queue<State> q;\n    unordered_map<string, int> visited;\n    q.push(State(startPos, 0));\n    visited[to_string(startPos[0].first) + \",\" + to_string(startPos[0].second)] = 0;\n\n    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    while (!q.empty()) {\n        State current = q.front(); q.pop();\n        vector<pair<int, int>> positions = current.positions;\n        int foodIndex = current.foodIndex;\n\n        if (foodIndex == foodPos.size()) {\n            return visited[to_string(positions[0].first) + \",\" + to_string(positions[0].second)];\n        }\n\n        for (const auto& dir : directions) {\n            int nx = positions[0].first + dir.first;\n            int ny = positions[0].second + dir.second;\n\n            if (isValidMove(grid, positions, nx, ny)) {\n                vector<pair<int, int>> newPositions = {{nx, ny}};\n                for (int i = 0; i < positions.size() - 1; ++i) {\n                    newPositions.push_back(positions[i]);\n                }\n\n                if (foodIndex < foodPos.size() && newPositions[0] == foodPos[foodIndex]) {\n                    foodIndex++;\n                }\n\n                string key = to_string(newPositions[0].first) + \",\" + to_string(newPositions[0].second);\n                if (visited.find(key) == visited.end() || visited[key] > visited[to_string(positions[0].first) + \",\" + to_string(positions[0].second)] + 1) {\n                    visited[key] = visited[to_string(positions[0].first) + \",\" + to_string(positions[0].second)] + 1;\n                    q.push(State(newPositions, foodIndex));\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<pair<int, int>> caterpillarPos(6);\n    vector<pair<int, int>> foodPos;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'S') caterpillarPos[0] = {i, j};\n            else if (grid[i][j] >= '1' && grid[i][j] <= '9') foodPos.push_back({i, j});\n            else if (grid[i][j] == 'a') caterpillarPos[1] = {i, j};\n            else if (grid[i][j] == 'b') caterpillarPos[2] = {i, j};\n            else if (grid[i][j] == 'c') caterpillarPos[3] = {i, j};\n            else if (grid[i][j] == 'd') caterpillarPos[4] = {i, j};\n            else if (grid[i][j] == 'e') caterpillarPos[5] = {i, j};\n        }\n    }\n\n    int result = bfs(grid, caterpillarPos, foodPos);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:05"
  }
]