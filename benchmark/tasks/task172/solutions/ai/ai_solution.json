[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int a, b;\n} Domino;\n\nbool backtrack(Domino* pieces, bool* used, int* arrangement, int pos, int n) {\n    if (pos == n) {\n        return true;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            if (pos == 0 || pieces[i].a == pieces[arrangement[pos-1]].b) {\n                used[i] = true;\n                arrangement[pos] = i;\n                if (backtrack(pieces, used, arrangement, pos + 1, n)) {\n                    return true;\n                }\n                used[i] = false;\n            }\n            if (pos == 0 || pieces[i].b == pieces[arrangement[pos-1]].b) {\n                Domino temp = pieces[i];\n                pieces[i].a = temp.b;\n                pieces[i].b = temp.a;\n                used[i] = true;\n                arrangement[pos] = i;\n                if (backtrack(pieces, used, arrangement, pos + 1, n)) {\n                    return true;\n                }\n                pieces[i] = temp;\n                used[i] = false;\n            }\n        }\n    }\n    return false;\n}\n\nbool canArrangeDominoes(Domino* pieces, int n) {\n    if (n == 0) return true;\n    bool used[n];\n    int arrangement[n];\n    for (int i = 0; i < n; ++i) {\n        used[i] = false;\n    }\n    return backtrack(pieces, used, arrangement, 0, n);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Domino pieces[n];\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d\", &pieces[i].a, &pieces[i].b);\n    }\n    if (canArrangeDominoes(pieces, n)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public boolean canArrangeDominoes(int[][] dominoes) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        \n        // Count frequencies of each number\n        for (int[] domino : dominoes) {\n            frequencyMap.put(domino[0], frequencyMap.getOrDefault(domino[0], 0) + 1);\n            frequencyMap.put(domino[1], frequencyMap.getOrDefault(domino[1], 0) + 1);\n        }\n        \n        // Check if all numbers have even frequencies\n        for (int freq : frequencyMap.values()) {\n            if (freq % 2 != 0) {\n                return false;\n            }\n        }\n        \n        // Create graph representation\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] domino : dominoes) {\n            graph.computeIfAbsent(domino[0], k -> new ArrayList<>()).add(domino[1]);\n            graph.computeIfAbsent(domino[1], k -> new ArrayList<>()).add(domino[0]);\n        }\n        \n        // Check connectivity\n        Set<Integer> visited = new HashSet<>();\n        for (int num : graph.keySet()) {\n            if (!visited.contains(num)) {\n                if (!dfs(graph, num, visited)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    private boolean dfs(Map<Integer, List<Integer>> graph, int start, Set<Integer> visited) {\n        visited.add(start);\n        \n        for (int neighbor : graph.get(start)) {\n            if (!visited.contains(neighbor)) {\n                dfs(graph, neighbor, visited);\n            }\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 18:55:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nbool backtrack(vector<vector<int>>& pieces, vector<bool>& used, int last, int placed, int n) {\n    if (placed == n) return true;\n    for (int i = 0; i < pieces.size(); ++i) {\n        if (!used[i]) {\n            if (pieces[i][0] == last) {\n                used[i] = true;\n                if (backtrack(pieces, used, pieces[i][1], placed + 1, n)) return true;\n                used[i] = false;\n            }\n            if (pieces[i][1] == last) {\n                used[i] = true;\n                if (backtrack(pieces, used, pieces[i][0], placed + 1, n)) return true;\n                used[i] = false;\n            }\n        }\n    }\n    return false;\n}\n\nbool canChain(vector<vector<int>>& pieces) {\n    if (pieces.empty()) return false;\n    int n = pieces.size();\n    vector<bool> used(n, false);\n    used[0] = true;\n    if (backtrack(pieces, used, pieces[0][1], 1, n)) return true;\n    used[0] = false;\n    used[0] = true;\n    if (backtrack(pieces, used, pieces[0][0], 1, n)) return true;\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> pieces(n, vector<int>(2));\n    for (int i = 0; i < n; ++i) {\n        cin >> pieces[i][0] >> pieces[i][1];\n    }\n    cout << (canChain(pieces) ? \"true\" : \"false\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PIECES 50\n\ntypedef struct {\n    int left;\n    int right;\n} Domino;\n\nbool canFormLine(Domino pieces[], int numPieces) {\n    bool used[MAX_PIECES] = {false};\n    \n    for (int start = 0; start < numPieces; start++) {\n        memset(used, false, sizeof(used));\n        used[start] = true;\n        \n        int current = start;\n        int remainingPieces = numPieces - 1;\n        \n        while (remainingPieces > 0) {\n            bool found = false;\n            \n            for (int i = 0; i < numPieces; i++) {\n                if (!used[i]) {\n                    if (pieces[current].right == pieces[i].left) {\n                        current = i;\n                        used[i] = true;\n                        remainingPieces--;\n                        found = true;\n                        break;\n                    }\n                    \n                    if (pieces[current].right == pieces[i].right) {\n                        Domino temp = pieces[i];\n                        pieces[i].left = temp.right;\n                        pieces[i].right = temp.left;\n                        \n                        current = i;\n                        used[i] = true;\n                        remainingPieces--;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            \n            if (!found) break;\n        }\n        \n        if (remainingPieces == 0) return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    Domino pieces[] = {{1,2}, {2,3}, {3,4}, {4,5}};\n    int numPieces = sizeof(pieces) / sizeof(pieces[0]);\n    \n    bool result = canFormLine(pieces, numPieces);\n    printf(\"%s\\n\", result ? \"Can form line\" : \"Cannot form line\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    bool canArrangeDominoes(std::vector<std::vector<int>>& dominoes) {\n        std::unordered_map<int, int> degree;\n        \n        for (const auto& domino : dominoes) {\n            degree[domino[0]]++;\n            degree[domino[1]]++;\n        }\n        \n        int oddCount = 0;\n        for (const auto& entry : degree) {\n            if (entry.second % 2 != 0) {\n                oddCount++;\n            }\n        }\n        \n        return oddCount <= 2;\n    }\n};",
    "timestamp": "2025-08-05 18:55:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DominoChain {\n    public static boolean canChain(List<int[]> dominoes) {\n        if (dominoes.isEmpty()) {\n            return true;\n        }\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int[] d : dominoes) {\n            count.put(d[0], count.getOrDefault(d[0], 0) + 1);\n            count.put(d[1], count.getOrDefault(d[1], 0) + 1);\n        }\n        int odd = 0;\n        for (int v : count.values()) {\n            if (v % 2 != 0) {\n                odd++;\n            }\n        }\n        if (odd != 0 && odd != 2) {\n            return false;\n        }\n        return isConnected(dominoes);\n    }\n\n    private static boolean isConnected(List<int[]> dominoes) {\n        if (dominoes.isEmpty()) {\n            return true;\n        }\n        Set<Integer> visited = new HashSet<>();\n        Map<Integer, List<Integer>> graph = buildGraph(dominoes);\n        dfs(dominoes.get(0)[0], graph, visited);\n        for (int[] d : dominoes) {\n            if (!visited.contains(d[0]) || !visited.contains(d[1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static Map<Integer, List<Integer>> buildGraph(List<int[]> dominoes) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] d : dominoes) {\n            graph.putIfAbsent(d[0], new ArrayList<>());\n            graph.putIfAbsent(d[1], new ArrayList<>());\n            graph.get(d[0]).add(d[1]);\n            graph.get(d[1]).add(d[0]);\n        }\n        return graph;\n    }\n\n    private static void dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited) {\n        visited.add(node);\n        for (int neighbor : graph.getOrDefault(node, Collections.emptyList())) {\n            if (!visited.contains(neighbor)) {\n                dfs(neighbor, graph, visited);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:56:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef can_form_line(dominoes):\n    if not dominoes:\n        return False\n    \n    adjacency_list = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n\n    for x, y in dominoes:\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n        out_degree[x] += 1\n        in_degree[y] += 1\n        out_degree[y] += 1\n        in_degree[x] += 1\n\n    odd_vertices = [v for v in in_degree if in_degree[v] % 2 == 1]\n    \n    if len(odd_vertices) not in [0, 2]:\n        return False\n    \n    def dfs(vertex, visited):\n        stack = [vertex]\n        visited.add(vertex)\n        while stack:\n            current = stack.pop()\n            for neighbor in adjacency_list[current]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n                    visited.add(neighbor)\n\n    start_vertex = dominoes[0][0]\n    visited = set()\n    dfs(start_vertex, visited)\n    \n    if any(len(adjacency_list[v]) > 0 and v not in visited for v in adjacency_list):\n        return False\n    \n    return True\n\n# Example usage:\ndominoes = [(1, 2), (2, 3), (3, 4)]\nprint(can_form_line(dominoes))  # Output: True",
    "timestamp": "2025-08-13 01:29:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Dominoes {\n\n    static class Domino {\n        int left, right;\n\n        Domino(int left, int right) {\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    public static boolean canArrangeDominoes(List<Domino> dominoes) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for (Domino domino : dominoes) {\n            counts.put(domino.left, counts.getOrDefault(domino.left, 0) + 1);\n            counts.put(domino.right, counts.getOrDefault(domino.right, 0) + 1);\n        }\n\n        int oddCount = 0;\n        for (int count : counts.values()) {\n            if (count % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        // At most two numbers can have an odd occurrence\n        // These numbers will be the start and end numbers of the chain\n        if (oddCount > 2) return false;\n\n        Map<Integer, List<Domino>> graph = new HashMap<>();\n        for (Domino d : dominoes) {\n            graph.computeIfAbsent(d.left, k -> new ArrayList<>()).add(d);\n            if (d.left != d.right) {\n                graph.computeIfAbsent(d.right, k -> new ArrayList<>()).add(d);\n            }\n        }\n\n        // Start DFS from any node; could be start/end with an odd count if exists\n        int start = dominoes.get(0).left;\n        for (Integer key : counts.keySet()) {\n            if (counts.get(key) % 2 != 0) {\n                start = key;\n                break;\n            }\n        }\n\n        return dfs(start, new HashSet<>(), dominoes.size(), graph);\n    }\n\n    private static boolean dfs(int current, Set<Domino> visited, int totalDominoes,\n                               Map<Integer, List<Domino>> graph) {\n        if (visited.size() == totalDominoes) {\n            return true;\n        }\n\n        List<Domino> neighbors = graph.getOrDefault(current, new ArrayList<>());\n        for (Domino d : neighbors) {\n            if (!visited.contains(d)) {\n                visited.add(d);\n                int next = (d.left == current) ? d.right : d.left;\n                if (dfs(next, visited, totalDominoes, graph)) {\n                    return true;\n                }\n                visited.remove(d);\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        List<Domino> dominoes = Arrays.asList(new Domino(1, 2),\n                                              new Domino(2, 3),\n                                              new Domino(3, 4),\n                                              new Domino(4, 5));\n        System.out.println(canArrangeDominoes(dominoes)); // Output: true\n\n        List<Domino> dominoes2 = Arrays.asList(new Domino(1, 2),\n                                               new Domino(2, 3),\n                                               new Domino(3, 1),\n                                               new Domino(4, 5));\n        System.out.println(canArrangeDominoes(dominoes2)); // Output: false\n    }\n}",
    "timestamp": "2025-08-13 01:29:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_PIECES 28\n\ntypedef struct {\n    int left;\n    int right;\n} Domino;\n\nDomino pieces[MAX_PIECES];\nbool used[MAX_PIECES];\nint n;\n\nbool canArrange(int current, int required) {\n    if (current == n)\n        return true;\n    \n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            if (pieces[i].left == required) {\n                used[i] = true;\n                if (canArrange(current + 1, pieces[i].right))\n                    return true;\n                used[i] = false;\n            }\n            if (pieces[i].right == required) {\n                used[i] = true;\n                if (canArrange(current + 1, pieces[i].left))\n                    return true;\n                used[i] = false;\n            }\n        }\n    }\n    return false;\n}\n\nbool canFormLine() {\n    for (int i = 0; i < n; i++) {\n        used[i] = true;\n        if (canArrange(1, pieces[i].right) || canArrange(1, pieces[i].left))\n            return true;\n        used[i] = false;\n    }\n    return false;\n}\n\nint main() {\n    // Read number of domino pieces\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &pieces[i].left, &pieces[i].right);\n    }\n    \n    if (canFormLine()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 01:29:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_form_domino_line(dominoes):\n    if not dominoes:\n        return False\n    \n    graph = {}\n    in_degree = {}\n    out_degree = {}\n    \n    for a, b in dominoes:\n        graph.setdefault(a, []).append(b)\n        graph.setdefault(b, [])\n        out_degree[a] = out_degree.get(a, 0) + 1\n        in_degree[b] = in_degree.get(b, 0) + 1\n    \n    start_nodes = [node for node in graph if out_degree.get(node, 0) - in_degree.get(node, 0) == 1]\n    end_nodes = [node for node in graph if in_degree.get(node, 0) - out_degree.get(node, 0) == 1]\n    \n    if len(start_nodes) > 1 or len(end_nodes) > 1:\n        return False\n    \n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n    \n    start = start_nodes[0] if start_nodes else list(graph.keys())[0]\n    visited = set()\n    dfs(start, visited)\n    \n    return len(visited) == len(graph)",
    "timestamp": "2025-08-13 01:30:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_chain(dominoes):\n    if not dominoes:\n        return []\n\n    from collections import defaultdict\n\n    graph = defaultdict(list)\n    counts = defaultdict(int)\n    for a, b in dominoes:\n        graph[a].append(b)\n        graph[b].append(a)\n        counts[a] += 1\n        counts[b] += 1\n\n    start = dominoes[0][0]\n    odd_degree_nodes = [node for node in counts if counts[node] % 2 != 0]\n    if len(odd_degree_nodes) not in (0, 2):\n        return None\n    if odd_degree_nodes:\n        start = odd_degree_nodes[0]\n\n    stack = [start]\n    path = []\n    while stack:\n        current = stack[-1]\n        if graph[current]:\n            next_node = graph[current].pop()\n            graph[next_node].remove(current)\n            stack.append(next_node)\n        else:\n            path.append(stack.pop())\n\n    if len(path) != len(dominoes) + 1:\n        return None\n\n    chain = []\n    for i in range(len(path) - 1):\n        a, b = path[i], path[i + 1]\n        if (a, b) in dominoes:\n            chain.append((a, b))\n            dominoes.remove((a, b))\n        else:\n            chain.append((b, a))\n            dominoes.remove((b, a))\n    return chain",
    "timestamp": "2025-08-13 01:30:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nbool dfs(unordered_map<int, vector<int>>& graph, unordered_set<int>& visited, int current, int end, int count, int n) {\n    if (count == n) return true;\n    if (visited.count(current)) return false;\n\n    visited.insert(current);\n    for (int neighbor : graph[current]) {\n        if (dfs(graph, visited, neighbor, end, count + 1, n)) return true;\n    }\n    visited.erase(current);\n    return false;\n}\n\nbool canArrangeDominos(vector<vector<int>>& dominos) {\n    unordered_map<int, vector<int>> graph;\n    unordered_map<int, int> degrees;\n\n    for (const auto& domino : dominos) {\n        graph[domino[0]].push_back(domino[1]);\n        graph[domino[1]].push_back(domino[0]);\n        \n        degrees[domino[0]]++;\n        degrees[domino[1]]++;\n    }\n\n    int start = -1, end = -1, oddCount = 0;\n    for (const auto& [num, degree] : degrees) {\n        if (degree % 2 != 0) {\n            if (start == -1) start = num;\n            else if (end == -1) end = num;\n            oddCount++;\n            if (oddCount > 2) return false;\n        }\n    }\n\n    unordered_set<int> visited;\n    int initial = (start != -1) ? start : dominos[0][0];\n    return dfs(graph, visited, initial, end, 0, dominos.size());\n}\n\nint main() {\n    vector<vector<int>> dominos = {{1, 2}, {2, 3}, {3, 4}, {4, 1}};\n    if (canArrangeDominos(dominos)) {\n        cout << \"Yes, the dominos can be arranged in a line.\" << endl;\n    } else {\n        cout << \"No, the dominos cannot be arranged in a line.\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:31"
  }
]