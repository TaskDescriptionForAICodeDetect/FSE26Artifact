[
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint n;\nvs d;\nbool visited[1<<28]={};\n\nbool dfs(int used,int cnt,char l,char r){\n\tif(cnt==n){\n\t\treturn true;\n\t}\n\tif(visited[used]){\n\t\treturn false;\n\t}\n\tvisited[used]=true;\n\tREP(i,n){\n\t\tif(!(used&(1<<i))){\n\t\t\tREP(edge,2){\n\t\t\t\tREP(dir,2){\n\t\t\t\t\tif(edge==0){\n\t\t\t\t\t\tif(d[i][dir]==l){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,d[i][(dir+1)%2],r)){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(d[i][dir]==r){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,l,d[i][(dir+1)%2])){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>n,cin){\n\t\tREP(i,n){\n\t\t\tstring dd;\n\t\t\tcin>>dd;\n\t\t\td.push_back(dd);\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,n){\n\t\t\tif(dfs((1<<i),1,d[i][0],d[i][1])){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int i;\n  string s;\n  while(cin>>i){\n    int n[7]={0};\n    for(;i-->0;){\n      cin>>s;\n      n[s[0]-'0']++;\n      n[s[1]-'0']++;\n    }\n    int odd=0,one=0;\n    for(i=0;i<7;i++){\n      odd+=n[i]&1;\n      one+=(n[i]==1);\n    }\n    puts((odd==2||odd==0)&&!one?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++)if(array[i]%2 == 1)num_KI++;\n\n\t\tif(num_KI > 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] > 0 && i == get_boss(i))num_boss++;\n\t\t}\n\t\tif(num_boss > 1){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Yes\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nconst int Size = 7;\nbool checkNum(int *num)\n{\n\tint odds = 0;\n\tfor (int i = 0; i < Size; ++i)\n\t\tif (num[i] & 1)\n\t\t\t++odds;\n\treturn odds == 0 || odds == 2;\n}\nbool isSeqGraph(int* num, bool edge[Size][Size])\n{\n\tbool visited[Size];\n\tfill(visited, visited+Size, false);\n\tfor (int i = 0; i < Size && !(visited[i] = num[i] > 0); ++i)\n\t\t;\n\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (visited[i])\n\t\t{\n\t\t\tfor (int j = 0; j < Size; ++j)\n\t\t\t\tvisited[j] |= edge[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (!visited[i] && num[i] > 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint num[Size];\n\t\tbool edge[Size][Size];\n\t\tmemset(num, 0, sizeof(num));\n\t\tfill((bool*)edge, (bool*)edge + Size*Size, false);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tint a = t / 10;\n\t\t\tint b = t % 10;\n\t\t\t++num[a];\n\t\t\t++num[b];\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\t}\n\t\tif (checkNum(num) && isSeqGraph(num, edge))\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nint dom[32][2];\n\nint main() {\n  while (cin >> N) {\n    for (int i = 0; i < N; ++i) {\n      int v;\n      cin >> v;\n      int x = v/10, y = v%10;\n      dom[i][0] = min(x,y);\n      dom[i][1] = max(x,y);\n    }\n    vector<int> adj(N, 0);\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n\tif (i == j) continue;\n\tint dx = abs(dom[i][0] - dom[j][0]);\n\tint dy = abs(dom[i][1] - dom[j][1]);\n\tif (dx + dy == 1) ++adj[i];\n      }\n    }\n    int odd = 0;\n    for (int i = 0; i < N; ++i) {\n      if (adj[i] % 2 == 1) ++odd;\n    }\n    cout << ((odd == 0 || odd == 2) ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,d[30][2]; bool u[30];\nbool dfs(int prev){\n\tbool f=1;\n\trep(j,n)if(!u[j])f=0;\n\tif(f)return 1;\n\trep(i,n)if(!u[i]&&(d[i][0]==prev||d[i][1]==prev)){\n\t\tu[i]=1;\n\t\tf=dfs(d[i][0]==prev?d[i][1]:d[i][0]);\n\t\tu[i]=0;\n\t\tif(f)return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n){\n\t\tchar b[9];\n\t\trep(i,n)cin>>b,d[i][0]=b[0]-'0',d[i][1]=b[1]-'0',u[i]=0;\n\t\tbool f=0;\n\t\trep(i,n)rep(j,2){\n\t\t\tu[i]=1;\n\t\t\tif(!f&&dfs(d[i][j]))f=1;\n\t\t\tu[i]=0;\n\t\t}\n\t\tcout<<(f?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i]%2 == 1)num_KI++;\n\t\t}\n\n\t\tif(num_KI > 2){ //??????????????°?????????????????????????????¶\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] != 0){\n\t\t\t\tif(boss[i] == get_boss(i))num_boss++;\n\t\t\t}\n\t\t}\n\n\t\tif(num_boss > 1){ //2??°???????????\\????????£????????????\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Yes\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<19][19][2];\nint N;\nstring s[19];\n\nint func( int state, int n, int p )\n{\n  if( state == (1 << N) - 1 ) { //cout << p << endl;\n    return 1;\n  }\n  if( dp[state][n][p] != -1 ) return dp[state][n][p];\n\n  int ret = 0;;\n  for(int i=0; i<N; i++) {\n    if( state & (1 << i) ) continue;\n    if( s[n][p] == s[i][0] ) ret = func( state | (1 << i), i, 1 );\n    if( s[n][p] == s[i][1] ) ret = func( state | (1 << i), i, 0 );\n  }\n\n  return dp[state][n][p] = ret;\n}\n\n\nint main()\n{\n  while( cin >> N ) {\n    for(int i=0; i<N; i++) cin >> s[i];\n    fill_n(**dp, (1<<19)*19*2, -1);\n    int flag = 0;\n    for(int i=0; i<N; i++) {\n      flag = func( 1 << i, i, 0 );\n      flag = func( 1 << i, i, 1 );\n      //cout << flag << endl;\n      if( flag == 1 ) break;\n    }\n    \n    if( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\n\nbool dfs(Domino current_state,int visited, int pos, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),i,dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    for(int i = 0; i < dominos.size(); i++){\n      travel_check |= dfs(dominos[i],(1<<i),i,dominos);\n    }\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <csetjmp>\nusing namespace std;\n\nint n;\npair<int, int> domino[28];\nbool used[28];\njmp_buf env;\n\nvoid dfs(int depth, int num)\n{\n  if (depth == n) {\n    longjmp(env, 1);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    if (used[i]) continue;\n    if (domino[i].first == num) {\n      used[i] = true;\n      dfs(depth + 1, domino[i].second);\n      used[i] = false;\n    } else if (domino[i].second == num) {\n      used[i] = true;\n      dfs(depth + 1, domino[i].first);\n      used[i] = false;\n    }\n  }\n}\n\nint main()\n{\n  while (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n      int k; cin >> k;\n      domino[i].first = k / 10;\n      domino[i].second = k % 10;\n    }\n\n    if (!setjmp(env)) {\n      memset(used, false, sizeof(used));\n      for (int i = 0; i < n; ++i) {\n        used[i] = true;\n        dfs(1, domino[i].first);\n        dfs(1, domino[i].second);\n        used[i] = false;\n      }\n      puts(\"No\");\n    } else {\n      puts(\"Yes\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#define MAX 30\nusing namespace std;\nstruct domino{\n  int a,b;\n  domino():a(0),b(0){}\n  domino(int t):a(t/10),b(t%10){}\n  void swap(){std::swap(a,b);}\n};\nbool dfs(list<domino> now, domino ds[], bool vis[], int n, int num){\n  if( num == n ){\n    /*\nfor(list<domino>::iterator itl = now.begin();\n\titl != now.end(); ++itl){\n      cout << '[' << itl->a << ',' << itl->b << \"] \";\n    }\n    cout << endl;\n    */\n    return true;\n  }\n  /*\n  for(list<domino>::iterator itl = now.begin();\n      itl != now.end(); ++itl){\n    cout << '[' << itl->a << ',' << itl->b << \"] \";\n  }\n  cout << endl;\n  */\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      domino t = ds[i];\n      \n      /*if( t.b == now.front().a ){\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n      }else if( t.a == now.front().a ){\n\tt.swap();\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n\t}else\n      */if( t.b == now.back().b ){\n\tt.swap();\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }else if( t.a == now.back().b ){\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }\n      //return false;\n    }\n  }\n  return false;\n}\nint main()\n{\n  while(true){\n    int n;\n    cin >> n;\n    if(cin.eof())break;\n    bool vis[MAX]={false,};\n    list<domino> init;\n    domino ds[n];\n    for(int i = 0; i < n; ++i){\n      int t;cin>>t;\n      ds[i] = domino(t);\n    }\n    bool ans=false;\n    for(int i = 0; i < n; ++i){\n      vis[i]=true;\n      init.clear();\n      init.push_back(ds[i]);\n      ans = dfs( init, ds, vis, n, 1 );\n      if( !ans ){\n\tds[i].swap();\n\tinit.clear();\n\tinit.push_back(ds[i]);\n\tans = dfs( init, ds, vis, n, 1 );\n      }\n      break;\n      vis[i]=false;\n    }\n    if( ans )puts(\"Yes\");\n    else puts(\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tint a[7] = {0};\n\t\tstring s;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\ta[s[0]-'0']++;\n\t\t\ta[s[1]-'0']++;\n\t\t}\n\n\t\tint odd=0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (a[i]%2)\n\t\t\t\todd++;\n\n\t\tcout << ((odd==0||odd==2) ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint N;\n\twhile (cin >> N, N!=0) {\n\t\tint edge[7];\n\t\tfor (int i=0; i<7; i++)\n\t\t\tedge[i] = 0;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tchar tmp[3];\n\t\t\tcin >> tmp;\n\t\t\tif (tmp[0]==tmp[1]) continue;\n\t\t\tedge[(int)tmp[0]-'0']++;\n\t\t\tedge[(int)tmp[1]-'0']++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (edge[i]%2==1) cnt++;\n\t\tcout << ((cnt==0||cnt==2) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint n;\nbool a[7][7];\nint fn(int p,int q){\n  int i;\n  if(p==n){\n    return 1;\n  }else{\n    for(i=0;i<7;i++){\n      if(a[q][i]){\n\ta[q][i]=a[i][q]=0;\n\tif(fn(p+1,i))\n\t  return 1;\n\ta[q][i]=a[i][q]=1;\n      }\n    }\n  }\n  return 0;\n}\nint main(){\n  int i;\n  while(cin>>n){\n    memset(a,0,7*7);\n    for(i=0;i<n;i++){\n      char s,t;\n      cin>>s>>t;\n      a[s-'0'][t-'0']=a[t-'0'][s-'0']=1;\n    }\n    for(i=0;i<7;i++){\n      if(fn(0,i))\n\tbreak;\n    }\n    if(i==7)\n      cout<<\"No\"<<endl;\n    else\n      cout<<\"Yes\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    int n;\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    vector<int> num;    // O[vÌvf\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n0){ // RXgN^\n        n = n0;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        num.assign(n, 1);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y]){\n                parent[x] = y;\n                num[y] += num[x];\n            }else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n                num[x] += num[y];\n            }\n            -- n;\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int getNum(){ // O[vÌðÔ·\n        return n;\n    }\n    int getNum(int x){ // xÌO[vÌvfðÔ·\n        return num[find(x)];\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        if(!(cin >> n))\n            return 0;\n\n        vector<bitset<7> > bs(n, 0);\n        vector<int> m(7, 0);\n        for(int i=0; i<n; ++i){\n            char a, b;\n            cin >> a >> b;\n            bs[i][a-'0'] = bs[i][b-'0'] = true;\n            ++ m[a-'0'];\n            ++ m[b-'0'];\n        }\n\n        UnionFindTree uft(n);\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<i; ++j){\n                if((bs[i] & bs[j]).any())\n                    uft.unite(i, j);\n            }\n        }\n\n        int odd = 0;\n        for(int i=0; i<7; ++i){\n            if(m[i] % 2 == 1)\n                ++ odd;\n        }\n\n        if(uft.getNum() == 1 && odd <= 2)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nconst int Size = 128;\nbool checkNum(int *num)\n{\n\tint odds = 0;\n\tfor (int i = 0; i < Size; ++i)\n\t\tif (num[i] & 1)\n\t\t\t++odds;\n\treturn odds == 0 || odds == 2;\n}\nbool isSeqGraph(int* num, bool edge[Size][Size])\n{\n\tbool visited[Size];\n\tfill(visited, visited+Size, false);\n\tfor (int i = 0; i < Size && !(visited[i] = num[i] > 0); ++i)\n\t\t;\n\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (visited[i])\n\t\t{\n\t\t\tfor (int j = 0; j < Size; ++j)\n\t\t\t\tvisited[j] |= edge[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (!visited[i] && num[i] > 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint num[Size];\n\t\tbool edge[Size][Size];\n\t\tmemset(num, 0, sizeof(num));\n\t\tfill((bool*)edge, (bool*)edge + Size*Size, false);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tint a = t / 10;\n\t\t\tint b = t % 10;\n\t\t\t++num[a];\n\t\t\t++num[b];\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\t}\n\t\tif (checkNum(num) && isSeqGraph(num, edge))\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nconst int V = 7;\ntypedef vector<int> node;\n\nbool judge(vector<node>& G){\n  bool exist[V] = {};\n  REP(i, V) exist[i] = (G[i].size() > 0);\n  int s = -1;\n  REP(i, V) if(exist[i]) s = i; \n  assert(s != -1);\n  queue<int> que;\n  bool used[V] = {};\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()){\n    int u = que.front(); que.pop();\n    REP(i, G[u].size()){\n      int v = G[u][i];\n      if(used[v]) continue;\n      used[v] = true;\n      que.push(v);\n    }\n  }\n  REP(i, V) if(exist[i] && !used[i]) return false;\n  int odd = 0;\n  REP(i, V) if(G[i].size() % 2 == 1) odd++;\n  return (odd == 2 || odd == 0);\n}\n\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<node> G(7);\n    REP(i, N){\n      string s; cin>>s;\n      int u = s[0] - '0';\n      int v = s[1] - '0';\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    if(judge(G)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dfs(Domino current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check |= dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n};\n\nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\nusing namespace std;\n\ntypedef vector <bool> VB;\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nVPII dominoes;\nVVI connected;\nVB visited;\nint visited_count;\nint n;\nint now;\nint cur; \n\nbool is_match( int t, PII domino )\n{\n\tif ( t == domino.first || t == domino.second ) return true;\n\telse return false;\n}\n\nint get_next( int t, PII domino )\n{\n\tif ( t == domino.first ) return domino.second;\n\telse return domino.first;\n}\n\nbool search( int no, int c )\n{\n\tif ( visited_count == n ) return true;\n\tfor ( VI::iterator it = connected[cur].begin(); it != connected[cur].end(); it++ )\n\t{\n\t\tif ( visited[*it] ) continue;\n\t\tif ( is_match( now, dominoes[*it] ) == false ) continue;\n\t\tnow = get_next( now, dominoes[*it] );\n\t\tcur = *it;\n\t\tvisited[*it] = true;\n\t\tvisited_count++;\n\t\tif ( search( now, cur ) ) return true;\n\t\tnow = no; cur = c;\n\t\tvisited_count--;\n\t\tvisited[*it] = false;\n\t}\n\treturn false;\n}\n\nbool solve()\n{\n\tvisited = VB( n, false );\n\tvisited_count = 0;\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tfor ( int j = 0; j < 2; j++ )\n\t\t{\n\t\t\tnow = j ? dominoes[i].first : dominoes[i].second;\n\t\t\tcur = i;\n\t\t\tvisited[i] = true;\n\t\t\tvisited_count++;\n\t\t\tif ( search( now, cur ) ) return true;\n\t\t\tvisited_count--;\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid input_dominoes( int n )\n{\n\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tchar left, right; cin >> left >> right;\n\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\tdominoes[i] = make_pair( l, r );\n\t}\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tcin >> n;\n\t\tif ( cin.eof() ) break;\n\n\t\tdominoes = VPII( n );\n\t\tinput_dominoes( n );\n\n\t\tconnected = VVI( n );\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tfor ( int j = i+1; j < n; j++ )\n\t\t\t{\n\t\t\t\tif ( i == j ) continue;\n\t\t\t\tif ( is_match( dominoes[i].first, dominoes[j] ) || is_match( dominoes[i].second, dominoes[j] ) )\n\t\t\t\t{\n\t\t\t\t\tconnected[i].push_back( j );\n\t\t\t\t\tconnected[j].push_back( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool result = solve();\n\t\tif ( result ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dp[1<<21][21];\n\nbool dfs(Domino current_state,int visited, int pos, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    if(dp[visited | (1<<i)][i]) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    dp[visited | (1<<i)][i] = true;\n    res |= dfs(next,visited | (1<<i),i,dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    for(int i = 0; i < dominos.size(); i++){\n      memset(dp,false,sizeof(dp));\n      dp[1<<i][i] = true;\n      travel_check |= dfs(dominos[i],(1<<i),i,dominos);\n    }\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n) {\n    string s[n];\n    for(int i=0; i<n; i++) cin >> s[i];\n    int d[10],c[10],f=1;\n    memset(d,0,sizeof(d));\n    memset(c,0,sizeof(c));\n    for(int i=0; i<n; i++){\n      if(s[i][0]==s[i][1]) c[s[i][0]-'0']++;\n      else for(int j=0; j<2; j++) d[s[i][j]-'0']++;\n    }\n    int x=0;\n    for(int i=0; i<10; i++) {\n      if(c[i]&&!d[i]&&n!=1) f=0;\n      if(d[i]%2) x++;\n      if(x>2) f=0;\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N){\n        int cnt[7] = {0};\n        string in;\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            cnt[in[0]-'0']++;\n            cnt[in[1]-'0']++;\n        }\n        if(N == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        int odd = 0;\n        for(int i = 0 ; i < 7 ; i++){\n            if(cnt[i]&1) odd++;\n        }\n        cout << ((odd == 0 || odd == 2) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint main(){\n    int n,a[7],b[7],ans;\n    bool f;\n    char c[2];\n    while(scanf(\"%d\",&n)!=EOF){\n        ans=0;\n        for(int i=0;i<7;i++)a[i]=b[i]=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%s\",c);\n            if(c[0]==c[1]){\n                b[c[0]-'0']++;\n            }\n            a[c[0]-'0']++;\n            a[c[1]-'0']++;\n        }\n        f=true;\n        for(int i=0;i<7&&f;i++){\n            if(b[i]>0){\n                if(a[i]==b[i]*2){\n                    if(a[i]!=n*2){\n                        f=false;\n                        printf(\"No\\n\");\n                    }\n                }\n            }\n            if(a[i]%2==1){\n                ans++;\n            }\n            if(ans>2){\n                f=false;\n                printf(\"No\\n\");\n            }\n        }\n        if(f)printf(\"Yes\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define PRINT(x)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl;\n#define PRINTA(a,first,last)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<(first)<<\", \"<<(last)<<\")\"<<endl;\\\n    for (int i=(first);i<(last);++i){cout<<#a<<\"[\"<<i<<\"] = \"<<(a)[i]<<endl;}\n#else\n#define PRINT(x)\n#define PRINTA(a,first,last)\n#endif\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\ntemplate <class T, class U> void amax(T& x, U y) {if (x < y) x = y;}\ntemplate <class T, class U> void amin(T& x, U y) {if (x > y) x = y;}\n\nint main(void)\n{\n    const int N_MAX = 18;\n    int N;\n    int l[N_MAX];\n    int r[N_MAX];\n    int count[7];\n    while (scanf(\"%d\", &N) != EOF) {\n        REP(i, 7) count[i] = 0;\n        REP(i, N) {\n            char c;\n            cin >> c;\n            l[i] = c - '0';\n            cin >> c;\n            r[i] = c - '0';\n            ++count[l[i]];\n            ++count[r[i]];\n        }\n        PRINTA(l, 0, N);\n        PRINTA(r, 0, N);\n        PRINTA(count, 0, 7);\n        int odd = 0;\n        REP(i, 7) {\n            if (count[i] % 2 == 1) {\n                ++odd;\n            }\n        }\n        if (odd > 2) {\n            cout << \"No\" << endl;\n        } else if (odd == 2) {\n            cout << \"Yes\" << endl;\n        } else {\n            int dbl = 0;\n            int N0 = N;\n            REP(i, N) {\n                if (l[i] == r[i]) {\n                    ++dbl;\n                    if (count[l[i]] > 2) {\n                        --dbl;\n                        --N0;\n                        count[l[i]] -= 2;\n                    }\n                }\n            }\n            if (N0 == 1 || dbl == 0) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <string>\n\n#include <sstream>\n\n#include <vector>\n\n#include <list>\n\n#include <queue>\n\n#include <deque>\n\n#include <stack>\n\n#include <set>\n\n#include <map>\n\n#include <functional>\n\n#include <numeric>\n\n#include <utility>\n\n#include <algorithm>\n\n#include <new>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cstdlib>\n\n#include <cstdio>\n\n#include <cctype>\n\n#include <cstring>\n\n\n\n#define REP(i, n) for(i = 0; i < n; i++)\n\n#define sz(n) n.size()\n\n#define pb(n) push_back(n)\n\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\n\n\nusing namespace std;\n\n\n\nint i, j, n;\n\n\n\nbool match(string a, string b) {\n\n    return a[0] == b[0] || a[0] == b[1] || a[1] == b[0] || a[1] == b[1];\n\n}\n\n\n\nstring valid(vector<string> s) {\n\n    int N = s.size();\n\n    bool memo[N];\n\n    memset(memo, 0, sizeof(memo));\n\n\n\n    deque<string> ss;\n\n\n\n    ss.push_back(s[0]);\n\n\n\n    REP(i, N - 1) {\n\n        REP(j, n) {\n\n            if(i != j && !memo[j]) {\n\n                if(match(s[j], ss[0])) {\n\n                    memo[j] = true;\n\n                    ss.push_front(s[j]);\n\n                } else if(match(s[j], ss[ss.size() - 1])) {\n\n                    memo[j] = true;\n\n                    ss.push_back(s[j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    bool ok = true;\n\n    REP(i, N) {\n\n        if(!memo[i]) ok = false;\n\n    }\n\n    if(ok) return \"Yes\";\n\n    return \"No\";\n\n}\n\n\n\nint main(void) {\n\n\n    while(~scanf(\"%d\", &n)) {\n\n        vector<string> v(n);\n\n        REP(i, n) {\n\n            cin >> v[i];\n\n        }\n\n        cout << valid(v) << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N,cnt[10][10],check[10];\n\nvoid isloop(int start){\n  //cout << start<< endl;\n  for (int i=0;i<10;i++){\n    if (cnt[start][i]){\n      if (check[i]==0){\n\tcheck[i]=1;\n\tisloop(i);\n      }else return;\n    }\n  }\n}\n\nint main(){\n  int a,t,odda=-1,oddb=-1,flg,gu;\n\n  while (cin >> N){\n    for (int i=0;i<10;i++){\n      check[i]=-1;\n      for (int j=0;j<10;j++)\n\tcnt[i][j]=0;\n    }\n    flg=0;\n    odda=-1;\n    oddb=-1;\n    for (int i=0;i<N;i++){\n      cin >>a;\n      cnt[a/10][a%10]++;\n      cnt[a%10][a/10]++;\n      check[a/10]=0;\n      check[a%10]=0;\n      gu=a/10;\n    }\n    for (int i=0;i<10;i++){\n      t=0;\n      for (int j=0;j<10;j++){\n\tif (i==j)continue;\n\tt+=cnt[i][j];\n      }\n      if (t%2){\n\tif (odda==-1){\n\t  odda=i;\n\t}else if (oddb==-1){\n\t  oddb=i;\n\t}else{\n\t  //cout << \"dng1\" << endl;\n\t  cout << \"No\"<<endl;\n\t  flg=1;\n\t  break;\n\t}\n      }\n    }\n    if (flg)break;\n    if (odda!=-1)isloop(odda);\n    else isloop(gu);\n    for (int i=0;i<10;i++){\n      if (check[i]==0){\n\tflg=1;\n\t//cout << \"dng2\" << i << endl;\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n    }\n    if (flg)break;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\nusing namespace std;\n\ntypedef vector <bool> VB;\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nVPII dominoes;\nint n;\nVB visited;\nint now;\nint visited_count;\n\nbool is_match( int now, PII domino )\n{\n\tif ( now == domino.first ) return true;\n\telse if ( now == domino.second ) return true;\n\telse return false;\n}\n\nint get_next( int now, PII domino )\n{\n\tif ( now == domino.first ) return domino.second;\n\telse if ( now == domino.second ) return domino.first;\n\telse return -1;\n}\n\nbool search()\n{\n\tif ( visited_count == n - 1 ) return true;\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tif ( visited[i] ) continue;\n\t\tif ( is_match( now, dominoes[i] ) )\n\t\t{\n\t\t\tint backup = now;\n\t\t\tnow = get_next( now, dominoes[i] );\n\t\t\tvisited[i] = true;\n\t\t\tvisited_count++;\n\t\t\tif ( search() ) return true;\n\t\t\tvisited_count--;\n\t\t\tvisited[i] = false;\n\t\t\tnow = backup;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve()\n{\n\tvisited = VB( n, false );\n\tvisited_count = 0;\n\n\t// ツ全ツづづ個ドツミツノツづ可づつつ「ツづ篠篠つキ\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tfor ( int j = 0; j < 2; j++ )\n\t\t{\n\t\t\tnow = ( j ? dominoes[i].first : dominoes[i].second );\n\t\t\tvisited[i] = true;\n\t\t\tvisited_count = 0;\n\t\t\tif ( search() ) return true; // ツつキツづ猟づづ個ドツミツノツづーツ配ツ置ツづつォツづゥツつゥ\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid input_dominoes( int n )\n{\n\tdominoes = VPII( n );\n\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tchar left, right; cin >> left >> right;\n\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\tdominoes[i] = make_pair( l, r );\n\t}\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tcin >> n;\n\t\tif ( cin.eof() ) break;\n\t\tinput_dominoes( n );\n\n\t\tbool result = solve();\n\t\tif ( result ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint dfs(int p, int a[7][7], int *visited) {\n  if (visited[p]) return 0;\n  visited[p] = 1;\n  int ret = 1;\n  REP(i, 7) if (a[p][i] > 0) ret += dfs(i, a, visited);\n  return ret;\n}\n\nint main() {\n  for (int N; cin >> N; ) {\n      int a[7][7] = {};\n      int x;\n      REP(i, N) {\n          cin >> x;\n          ++a[x / 10][x % 10];\n          ++a[x % 10][x / 10];\n      }\n\n      int all = 0;\n      int odd = 0;\n      REP(i, 7) {\n          int sum = 0;\n          REP(j, 7) sum += a[i][j];\n          if (sum & 1) odd++;\n          if (sum) all++;\n      }\n      bool euler = odd <= 2;\n      int visited[7] = {0};\n      bool connect = all == dfs(x / 10, a, visited);\n\n      if (euler && connect)\n          cout << \"Yes\" << endl;\n      else\n          cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n) {\n    int hoge[7] = {};\n    for (int i=0;i<n;++i) {\n      int a;\n      cin >> a;\n      hoge[a/10]++;\n      hoge[a%10]++;\n    }\n    int cnt = 0;\n    for (int i=0;i<7;++i) {\n      if (hoge[i]%2)\n        cnt++;\n    }\n    if (cnt == 0 || cnt == 2) {\n      cout << \"Yes\" << endl;\n    }else\n      cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dp[1<<22][22];\n\nbool dfs(Domino current_state,int visited, int pos, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    if(dp[visited | (1<<i)][i]) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    dp[visited | (1<<i)][i] = true;\n    res |= dfs(next,visited | (1<<i),i,dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    for(int i = 0; i < dominos.size(); i++){\n      memset(dp,false,sizeof(dp));\n      dp[1<<i][i] = true;\n      travel_check |= dfs(dominos[i],(1<<i),i,dominos);\n    }\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    \n    int n;\n    while(cin >> n){\n        if(n == 1){\n            string hoge; cin >> hoge;\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        vector<pair<int, int> > a(n);\n        vector<int> count(7, 0);\n        vector<bool> par(7, false);\n        for(int i = 0; i < n; i++){\n            string input; cin >> input;\n            a[i].first = (int)(input[0] - '0');\n            a[i].second = (int)(input[1] - '0');\n            //cout << a[i].first << \" \" << a[i].second << endl;\n            count[a[i].first]++;\n            count[a[i].second]++;\n            if(a[i].first == a[i].second) par[a[i].first] = true;\n        }\n\n        int cnt_odd = 0;\n        for(int i = 0; i < 7; i++) cnt_odd += (count[i] % 2 == 1);\n\n        if(cnt_odd != 0 && cnt_odd != 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool ok = true;\n\n        for(int i = 0; i < 7; i++){\n            \n\n\n            if(par[i]){\n\n                bool tmp = false;                \n\n                for(int j = 0; j < n; j++){\n                    if(a[j].first == a[j].second) continue;\n\n                    if(i == a[j].first || i == a[j].second){\n                        tmp = true;\n                    }\n                }\n\n                if(!tmp){\n                    ok = false;\n                    continue;\n                }\n            }\n        }\n\n        //cout << \"wahaha\" << endl;\n        if(ok) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<18][18][2];\nint N;\nstring s[18];\n\nint func( int state, int n, int p )\n{\n  if( state == (1 << N) - 1 ) { //cout << p << endl;\n    return 1;\n  }\n  if( dp[state][n][p] != -1 ) return dp[state][n][p];\n\n  int ret = 0;;\n  for(int i=0; i<N; i++) {\n    if( state & (1 << i) ) continue;\n    if( s[n][p] == s[i][0] ) ret = func( state | (1 << i), i, 1 );\n    if( s[n][p] == s[i][1] ) ret = func( state | (1 << i), i, 0 );\n  }\n\n  return dp[state][n][p] = ret;\n}\n\n\nint main()\n{\n  while( cin >> N ) {\n    for(int i=0; i<N; i++) cin >> s[i];\n    fill_n(**dp, (1<<18)*18*2, -1);\n    int flag = 0;\n    for(int i=0; i<N; i++) {\n      flag = func( 1 << i, i, 0 );\n      flag = func( 1 << i, i, 1 );\n      //cout << flag << endl;\n      if( flag == 1 ) break;\n    }\n    \n    if( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\nusing namespace std;\n\ntypedef vector <bool> VB;\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nVPII dominoes;\nint n;\nVB visited;\nint now;\nint visited_count;\n\nbool is_match( PII domino )\n{\n\tif ( now == domino.first ) return true;\n\telse if ( now == domino.second ) return true;\n\telse return false;\n}\n\nint get_next( PII domino )\n{\n\tif ( now == domino.first ) return domino.second;\n\telse if ( now == domino.second ) return domino.first;\n\telse return -1;\n}\n\nbool search()\n{\n\tif ( visited_count == n - 1 ) return true;\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tif ( visited[i] ) continue;\n\t\tif ( is_match( dominoes[i] ) )\n\t\t{\n\t\t\tint backup = now;\n\t\t\tnow = get_next( dominoes[i] );\n\t\t\tvisited[i] = true;\n\t\t\tvisited_count++;\n\t\t\tif ( search() ) return true;\n\t\t\tvisited_count--;\n\t\t\tvisited[i] = false;\n\t\t\tnow = backup;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve()\n{\n\tvisited = VB( n, false );\n\tvisited_count = 0;\n\n\t// ツ全ツづづ個ドツミツノツづ可づつつ「ツづ篠篠つキ\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tfor ( int j = 0; j < 2; j++ )\n\t\t{\n\t\t\tnow = ( j ? dominoes[i].first : dominoes[i].second );\n\t\t\tvisited[i] = true;\n\t\t\tif ( search() ) return true; // ツつキツづ猟づづ個ドツミツノツづーツ配ツ置ツづつォツづゥツつゥ\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid input_dominoes( int n )\n{\n\tdominoes = VPII( n );\n\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tchar left, right; cin >> left >> right;\n\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\tdominoes[i] = make_pair( l, r );\n\t}\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tcin >> n;\n\t\tif ( cin.eof() ) break;\n\t\tinput_dominoes( n );\n\n\t\tbool result = solve();\n\t\tif ( result ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\n  int n;\n\n  vector<int> data;\n  map<int, int> count;\n\n  while(cin >> n) {\n\n    for(int i = 0;i < n;i++) {\n\n      string temp;\n\n      cin >> temp;\n\n      data.push_back(temp[0]-'0');\n      data.push_back(temp[1]-'0');\n\n    }\n\n    for(int i = 0; i < data.size();i++) {\n\n      count[data[i]]++;\n\n    }\n\n    int odd = 0;\n\n    for(int i = 0;i <= 6;i++) {\n\n      if(count[i] % 2 == 1) {\n\n\todd++;\n\n      }\n\n    }\n\n    if(odd == 0 || odd == 2) {\n\n      cout << \"YES\" << endl;\n\n    }\n    else {\n\n      cout << \"NO\" << endl;\n\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<string> a(n);\n        for(int i=0; i<n; i++){\n            cin >> a[i];\n        }\n        bool dp[1<<18][7];\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<7; i++){\n            dp[0][i] = true;\n        }\n\n        for(int i=0; i<(1<<n); i++){\n            for(int j=0; j<7; j++){\n                if(!dp[i][j]) continue;\n                for(int k=0; k<n; k++){\n                    if((i & 1<<k) != 0) continue;\n                    if(j == a[k][0]-'0'){\n                        dp[i | 1<<k][a[k][1]-'0'] = true;\n                    }\n                    if(j == a[k][1]-'0'){\n                        dp[i | 1<<k][a[k][0]-'0'] = true;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        for(int i=0; i<7; i++){\n            if(dp[(1<<n)-1][i]){\n                ok = true;\n            }\n        }\n\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#define MAX 30\nusing namespace std;\nstruct domino{\n  int a,b;\n  domino():a(0),b(0){}\n  domino(int t):a(t/10),b(t%10){}\n  void swap(){std::swap(a,b);}\n};\nbool dfs(list<domino> now, domino ds[], bool vis[], int n, int num){\n  if( num == n ){\n    /*\nfor(list<domino>::iterator itl = now.begin();\n\titl != now.end(); ++itl){\n      cout << '[' << itl->a << ',' << itl->b << \"] \";\n    }\n    cout << endl;\n    */\n    return true;\n  }\n  /*\n  for(list<domino>::iterator itl = now.begin();\n      itl != now.end(); ++itl){\n    cout << '[' << itl->a << ',' << itl->b << \"] \";\n  }\n  cout << endl;\n  */\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      domino t = ds[i];\n      \n      /*if( t.b == now.front().a ){\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n      }else if( t.a == now.front().a ){\n\tt.swap();\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n\t}else\n      */if( t.b == now.back().b ){\n\tt.swap();\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }else if( t.a == now.back().b ){\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }\n      //return false;\n    }\n  }\n  return false;\n}\nint main()\n{\n  while(true){\n    int n;\n    cin >> n;\n    if(cin.eof())break;\n    bool vis[MAX]={false,};\n    list<domino> init;\n    domino ds[n];\n    for(int i = 0; i < n; ++i){\n      int t;cin>>t;\n      ds[i] = domino(t);\n    }\n    bool ans=false;\n    for(int i = 0; i < n; ++i){\n      vis[i]=true;\n      init.clear();\n      init.push_back(ds[i]);\n      ans = dfs( init, ds, vis, n, 1 );\n      if( !ans ){\n\tds[i].swap();\n\tinit.clear();\n\tinit.push_back(ds[i]);\n\tans = dfs( init, ds, vis, n, 1 );\n      }\n      if(ans)break;\n      vis[i]=false;\n    }\n    if( ans )puts(\"Yes\");\n    else puts(\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\tbool FLG;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\t\tFLG = true;\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i]%2 == 1)num_KI++;\n\t\t\tfor(int k = 0; k < 7; k++){\n\t\t\t\tif(array[i] != 0 && array[k] != 0 && get_boss(i) != get_boss(k)){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)break;\n\t\t}\n\n\t\tif(num_KI > 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(FLG){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass UnionFind {\nprivate:\n  int n;\n  vector<int> a;\npublic:\n  UnionFind(int n) : n(n), a(n, -1) {}\n  int find(int x) {return a[x] < 0 ? x : (a[x] = find(a[x]));}\n  bool equal(int x, int y) {return find(x) == find(y);}\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (a[x] > a[y]) swap(x, y);\n    a[x] += a[y];\n    a[y] = x;\n    --n;\n  }\n  int size() {return n;}\n};\n\nint main() {\n  int n;\n  while (cin >> n) {\n    int cnt[6] = {};\n    UnionFind uf(6);\n    rep (i, n) {\n      string domino;\n      cin >> domino;\n      ++cnt[domino[0] - '0'];\n      ++cnt[domino[1] - '0'];\n      uf.unite(domino[0] - '0', domino[1] - '0');\n    }\n    int c = 0;\n    rep (i, 6) if (cnt[i] % 2) ++c;\n    if (c > 2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    c = 0;\n    rep (i, 6) if (!cnt[i]) ++c;\n    if (uf.size() == c + 1) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N,cnt[10][10],check[10];\n\nvoid isloop(int start){\n  //cout << start<< endl;\n  for (int i=0;i<10;i++){\n    if (cnt[start][i]){\n      if (check[i]==0){\n\tcheck[i]=1;\n\tisloop(i);\n      }else return;\n    }\n  }\n}\n\nint main(){\n  int a,t,odda=-1,oddb=-1,flg,gu;\n\n  while (cin >> N){\n    for (int i=0;i<10;i++){\n      check[i]=-1;\n      for (int j=0;j<10;j++)\n\tcnt[i][j]=0;\n    }\n    flg=0;\n    odda=-1;\n    oddb=-1;\n    for (int i=0;i<N;i++){\n      cin >>a;\n      cnt[a/10][a%10]++;\n      cnt[a%10][a/10]++;\n      check[a/10]=0;\n      check[a%10]=0;\n      gu=a/10;\n    }\n    for (int i=0;i<10;i++){\n      t=0;\n      for (int j=0;j<10;j++){\n\tif (i==j)continue;\n\tt+=cnt[i][j];\n      }\n      if (t%2){\n\tif (odda==-1){\n\t  odda=i;\n\t}else if (oddb==-1){\n\t  oddb=i;\n\t}else{\n\t  //cout << \"dng1\" << endl;\n\t  cout << \"No\"<<endl;\n\t  flg=1;\n\t  break;\n\t}\n      }\n    }\n    if (flg)continue;\n    if (odda!=-1)isloop(odda);\n    else isloop(gu);\n    for (int i=0;i<10;i++){\n      if (check[i]==0){\n\tflg=1;\n\t//cout << \"dng2\" << i << endl;\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n    }\n    if (flg)continue;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<int> freq(7, 0);\n\t\tvector<int> dups(7, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tfreq[t % 10]++;\n\t\t\tfreq[t / 10]++;\n\t\t\tif (t % 10 == t / 10) dups[t / 10]++;\n\t\t}\n\t\tint numOdd = 0;\n\t\tbool hasAloneDup = false;\n\t\tfor (int i = 0; i <= 6; i++) {\n\t\t\tif (freq[i] % 2 == 1) numOdd++;\n\t\t\tif (freq[i] > 0 && freq[i] - dups[i] * 2 == 0) hasAloneDup = true;\n\t\t}\n\t\tcout << (n < 2 || !hasAloneDup && (numOdd == 0 || numOdd == 2) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass UnionFind {\nprivate:\n  int n;\n  vector<int> a;\npublic:\n  UnionFind(int n) : n(n), a(n, -1) {}\n  int find(int x) {return a[x] < 0 ? x : (a[x] = find(a[x]));}\n  bool equal(int x, int y) {return find(x) == find(y);}\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (a[x] > a[y]) swap(x, y);\n    a[x] += a[y];\n    a[y] = x;\n    --n;\n  }\n  int size() {return n;}\n};\n\nint main() {\n  int n;\n  while (cin >> n) {\n    int cnt[7] = {};\n    UnionFind uf(7);\n    rep (i, n) {\n      string domino;\n      cin >> domino;\n      ++cnt[domino[0] - '0'];\n      ++cnt[domino[1] - '0'];\n      uf.unite(domino[0] - '0', domino[1] - '0');\n    }\n    int c = 0;\n    rep (i, 7) if (cnt[i] % 2) ++c;\n    if (c > 2) {\n      cout << \"No\" << endl;\n      continue;\n    }\n    c = 0;\n    rep (i, 7) if (!cnt[i]) ++c;\n    if (uf.size() == c + 1) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define printb(x, a, b) if(x) cout << a << endl; else cout << b << endl\n#define inRange(x, a, b) a <= x && x < b\n\nint dx[4] = {-1,0,0,1};\nint dy[4] = {0,-1,1,0};\n\nint main(){\n    int n;\n    while(cin >> n){\n        bool mat[7][7] = {};\n        int deg[7][7] = {};\n\n        int a, b;\n        for(int i = 0; i < n; i++){\n            cin >> a;\n            b = a/10;\n            a %= 10;\n            mat[max(a,b)][min(a,b)] = true;\n        }\n\n        for(int i = 0; i < 7; i++){\n            for(int j = 0; j <= i; j++){\n                if(mat[i][j]){\n                    for(int k = 0; k < 4; k++){\n                        int ni = i+dx[k];\n                        int nj = j+dy[k];\n                        if(ni <= nj && inRange(ni,0,7) && inRange(nj,0,7) && mat[ni][nj]){\n                            deg[i][j]++;\n                            deg[ni][nj]++;\n                        }\n                    }\n                }\n            }\n        }\n\n        int odd = 0;\n        for(int i = 0; i < 7; i++){\n            for(int j = 0; j <= i; j++){\n                if(deg[i][j]/2) odd += ((deg[i][j]/2) % 2 == 1);\n            }\n        }\n\n        // Eulerian trail\n        printb(odd == 0 || odd == 2, \"Yes\", \"No\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool solve(bitset<18>bs, vector<vector<int>>&dp,const vector<pair<int,int>>&vs,const int now) {\n\tif(dp[now][bs.to_ulong()]!=-1)return dp[now][bs.to_ulong()];\n\n\tbool ok = false;\n\tif(bs.count()==vs.size())ok=true;\n\telse {\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tif (bs[i]) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (vs[i].first == now || now == 7) {\n\t\t\t\t\tbs[i] = true;\n\t\t\t\t\tbool aok = solve(bs, dp, vs, vs[i].second);\n\t\t\t\t\tif (aok)ok = true;\n\t\t\t\t\tbs[i] = false;\n\t\t\t\t}\n\t\t\t\tif (vs[i].second == now || now == 7) {\n\t\t\t\t\tbs[i] = true;\n\t\t\t\t\tbool aok = solve(bs, dp, vs, vs[i].first);\n\t\t\t\t\tif(aok)ok=true;\n\t\t\t\t\tbs[i] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t}\n\treturn dp[now][bs.to_ulong()]=ok;\n}\nint main()\n{\n\tint N;\n\twhile (cin >> N) {\n\t\tvector<pair<int,int>>vs;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st;cin>>st;\n\t\t\tvs.push_back(make_pair(st[0]-'0',st[1]-'0'));\n\t\t}\n\n\t\tvector<vector<int>>dp(8,vector<int>(1<<N,-1));\n\n\t\tbitset<18>bs;\n\t\tint ok=solve(bs,dp,vs,7);\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nchar d[30][3];\nint n;\nbool f[30];\n\nbool solve(int cnt, char prev){\n  if(cnt == n) return true;\n  REP(i,n) if(!f[i]){\n    f[i] = true;\n    if(prev == d[i][0]){\n      if(solve(cnt+1, d[i][1])) return true;\n    }else if(prev == d[i][1]){\n      if(solve(cnt+1, d[i][0])) return true;      \n    }\n    f[i] = false;\n  }\n  return false;\n}\n\nint main(){\n  while(~scanf(\"%d\",&n)){\n    REP(i,n) scanf(\"%s\",d[i]);\n    \n    bool ans = false;\n\n    REP(i,7) if(solve(0, i+'0')){\n      ans = true; break;\n    }\n\n    puts(ans ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstdlib>\nusing namespace std;\n\nmain(){\n  int n,i,j;\n  string a,str;\n  while(cin >> a){\n\n    for(i=0;i<101;i++){\n      if(a[i] == '\\0') break;\n\n      else if(a[i] == '@'){\n\tstr = a[i+1];\n\tn = atoi(str.c_str());\n\tfor(j=0;j<n;j++){\n\t  cout << a[i+2];\n\t}\n\ti+=2;\n      }\n\n      else cout << a[i];\n    }\n\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid sik(int);\nint gr[7][7];\nint ch[7];\nint co[7];\nint main(){\n  while(1){\n    //\n    for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++){\n\tgr[i][j]=0;\n\tch[i]=-1;\n\tco[i]=0;\n      }\n    }\n    int f=0;\n    //\n    int n;\n    cin >> n;\n    if(cin.eof())break;\n    int st;\n    for(int i=0;i<n;i++){\n      int bu;\n      cin >> bu;\n      gr[bu/10][bu%10]=1;\n      gr[bu%10][bu/10]=1;\n      ch[bu%10]=0;\n      ch[bu/10]=0;\n      co[bu/10]++;\n      co[bu%10]++;\n      st=bu%10;\n    }\n    int cok=0;\n    for(int i=0;i<7;i++){\n      if(co[i]%2)cok++;\n    }\n    if(cok>2)f=1;\n    sik(st);\n    for(int i=0;i<7;i++){\n      if(ch[i]==0)f=1;\n    }\n    if(f)cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}\nvoid sik(int a){\n  for(int i=0;i<7;i++){\n    if(gr[a][i]){\n      if(ch[i])break;\n      else{\n\tch[i]=1;\n\tsik(i);\n      }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<bitset>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nint memo[(1<<26)][10];\n\nbool rec(P *G,int used,int prev)\n{\n  if(__builtin_popcount(used) == n)return true;\n  if(__builtin_popcount(used) >= n)return false;\n  if(memo[used][prev] != -1)return memo[used][prev];\n\n  rep(i,n)\n    {\n      if((used>>i)&1)continue;\n      if(prev == G[i].first)if(rec(G,used|(1<<i),G[i].second))\n\t\t\t      {\n\t\t\t\tmemo[used|(1<<i)][G[i].second] = true;\n\t\t\t\treturn true;\n\t\t\t      }\n      if(prev == G[i].second)if(rec(G,used|(1<<i),G[i].first))\n\t\t\t       {\n\t\t\t\t memo[used|(1<<i)][G[i].first] = true;\n\t\t\t\t return true;\n\t\t\t       }\n    }\n  memo[used][prev] = false;\n  return false;\n}\n\nint main()\n{\n  while(cin >> n)\n    {\n      cin.ignore();\n      rep(i,(1<<n))rep(j,10)memo[i][j] = -1;\n      P G[n];\n      rep(i,n)\n\t{\n\t  char a,b,c;\n\t  scanf(\"%c%c%c\",&a,&b,&c);\n\t  G[i].first = a-'0';\n\t  G[i].second = b-'0';\n\t}\n\n      rep(i,n)\n\t{\n\t  if(rec(G,(1<<i),G[i].second) || rec(G,(1<<i),G[i].first))\n\t    {\n\t      cout << \"Yes\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"No\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nconst int V = 7;\ntypedef vector<int> node;\n\nbool judge(vector<node>& G){\n  bool exist[V] = {};\n  REP(i, V) exist[i] = (G[i].size() > 0);\n  int s = -1;\n  REP(i, V) if(exist[i]) s = i; \n  assert(s != -1);\n  queue<int> que;\n  bool used[V] = {};\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()){\n    int u = que.front(); que.pop();\n    REP(i, G[u].size()){\n      int v = G[u][i];\n      if(used[v]) continue;\n      used[v] = true;\n      que.push(v);\n    }\n  }\n  REP(i, V) if(exist[i] && !used[i]) return false;\n  int odd = 0;\n  REP(i, V) if(G[i].size() % 2 == 1) odd++;\n  return (odd == 2 || odd == 0);\n}\n\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<node> G(6);\n    REP(i, N){\n      string s; cin>>s;\n      int u = s[0] - '0';\n      int v = s[1] - '0';\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n    if(judge(G)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<int> freq(7, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tfreq[t % 10]++;\n\t\t\tfreq[t / 10]++;\n\t\t}\n\t\tint numOdd = 0;\n\t\tfor (int i = 1; i <= 6; i++) {\n\t\t\tif (freq[i] % 2 == 1) numOdd++;\n\t\t}\n\t\tcout << (numOdd == 0 || numOdd == 2 ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <new>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\n#define REP(i, n) for(i = 0; i < n; i++)\n#define sz(n) n.size()\n#define pb(n) push_back(n)\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\nusing namespace std;\n\nint i, j, n;\n\nbool match_begin(string& novo, string b) {\n    if(b[0] == novo[1]) {\n        return true;\n    } else if(b[0] == novo[0]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool match_end(string novo, string b) {\n    if(b[1] == novo[0]) {\n        return true;\n    } else if(b[1] == novo[1]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nstring valid(vector<string> s) {\n    int N = s.size();\n    bool memo[N];\n    memset(memo, 0, sizeof(memo));\n\n    deque<string> ss;\n\n    REP(i, N) {\n        REP(j, n) {\n            if(ss.empty() && i != j) {\n                if(match_begin(s[i], s[j])) {\n                    ss.push_front(s[j]);\n                    ss.push_back(s[i]);\n                    memo[i] = memo[j] = true;\n                } else if(match_end(s[i], s[j])) {\n                    ss.push_front(s[i]);\n                    ss.push_back(s[j]);\n                    memo[i] = memo[j] = true;\n                }\n            } else if(!s.empty() && i != j && !memo[j]) {\n                if(match_begin(s[j], ss[0])) {\n                    memo[j] = true;\n                    ss.push_front(s[j]);\n                } else if(match_end(s[j], ss[ss.size() - 1])) {\n                    memo[j] = true;\n                    ss.push_back(s[j]);\n                }\n            }\n        }\n    }\n    bool ok = true;\n    REP(i, N) {\n        if(!memo[i]) ok = false;\n    }\n    if(ok) return \"Yes\";\n    return \"No\";\n}\n\nint main(void) {\n    while(~scanf(\"%d\", &n)) {\n        vector<string> v(n);\n        REP(i, n) {\n            cin >> v[i];\n        }\n        cout << valid(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n\n#define conv(c) ((int)(c-'0'))\n\nusing namespace std;\n\nint n, s, t;\nbool vis[7][7];\nbool d[7][7];\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\n\nbool dfs(int y, int x, int cnt)\n{\n  if(cnt == n) return true;\n\n  for(int i = 0; i < 4; i++){\n    int dx = x+xdir[i], dy = y+ydir[i];\n    if(0 <= dx && dx < 7 && 0 <= dy && dy < 7 && vis[dy][dx] && d[dy][dx]){\n      vis[dy][dx] = false;\n      if(dfs(dy, dx, cnt+1)) return true;\n      vis[dy][dx] = true;\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  string str;\n\n  while(cin>>n){\n    bool f = false;\n    fill(&vis[0][0], &vis[7][0], true);\n    fill(&d[0][0], &d[7][0], false);\n    for(int i = 0; i < n; i++){\n      cin >> str;\n      s = conv(str[0]); t = conv(str[1]);\n      if(s > t) swap(s, t);\n      d[s][t] = true;\n    }\n\n    for(int i = 0; i < 7 && !f; i++)\n      for(int j = 0; j < 7 && !f; j++)\n\tif(d[i][j]){\n\t  f = dfs(i, j, 0);\n\t}\n\n    cout << (f? \"Yes\": \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint N;\n\twhile (cin >> N) {\n\t\tint edge[7];\n\t\tfor (int i=0; i<7; i++)\n\t\t\tedge[i] = 0;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tchar tmp[3];\n\t\t\tcin >> tmp;\n\t\t\tif (tmp[0]==tmp[1]) continue;\n\t\t\tedge[(int)tmp[0]-'0']++;\n\t\t\tedge[(int)tmp[1]-'0']++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (edge[i]%2==1) cnt++;\n\t\tif (cnt==0 || cnt==2)\n\t\t\tcout << \"Yes\\n\";\n\t\telse \n\t\t\tcout << \"No\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nbool g[7][7];\nint t;\n\nbool dfs(int i){\n\trep(j, 7){\n\t\tif(!g[i][j]){\n\t\t\tg[i][j] = g[j][i] = true;\n\t\t\t++t;\n\t\t\tbool r = dfs(j);\n\t\t\tg[i][j] = g[j][i] = false;\n\t\t\t--t;\n\t\t\tif(r){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn t == n;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\trep(i, 7){\n\t\t\tfill(g[i], g[i] + 7, true);\n\t\t}\n\n\t\trep(i, n){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tint a = p / 10;\n\t\t\tint b = p % 10;\n\t\t\tg[a][b] = g[b][a] = false;\n\t\t}\n\n\t\tbool a = false;\n\t\trep(i, 7){\n\t\t\tif(dfs(i)){\n\t\t\t\ta = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (a ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\tbool FLG;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\t\tFLG = true;\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++)if(array[i]%2 == 1)num_KI++;\n\n\t\tif(num_KI > 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] > 0 && boss[i] == get_boss[i])num_boss++;\n\t\t}\n\t\tif(num_boss > 1)FLG = false;\n\n\t\tif(FLG){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <new>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\n#define REP(i, n) for(i = 0; i < n; i++)\n#define sz(n) n.size()\n#define pb(n) push_back(n)\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\nusing namespace std;\n\nint i, j, n;\n\nbool match_begin(string& novo, string b) {\n    if(b[0] == novo[1]) {\n        return true;\n    } else if(b[0] == novo[0]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool match_end(string novo, string b) {\n    if(b[1] == novo[0]) {\n        return true;\n    } else if(b[1] == novo[1]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nstring valid(vector<string> s) {\n    int N = s.size();\n    bool memo[N];\n    memset(memo, 0, sizeof(memo));\n\n    deque<string> ss;\n\n    ss.push_back(s[0]);\n\n    REP(i, N) {\n        REP(j, n) {\n            if(i != j && !memo[j]) {\n                if(match_begin(s[j], ss[0])) {\n                    memo[j] = true;\n                    ss.push_front(s[j]);\n                } else if(match_end(s[j], ss[ss.size() - 1])) {\n                    memo[j] = true;\n                    ss.push_back(s[j]);\n                }\n            }\n        }\n    }\n    bool ok = true;\n    REP(i, N) {\n        if(!memo[i]) ok = false;\n    }\n    if(ok) return \"Yes\";\n    return \"No\";\n}\n\nint main(void) {\n    while(~scanf(\"%d\", &n)) {\n        vector<string> v(n);\n        REP(i, n) {\n            cin >> v[i];\n        }\n        cout << valid(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\n\n\nint main() {\n  int n;\n  while(cin >> n) {\n    vector<int> g[7];\n    int a;\n    set<int> se;\n    for (int i=0;i<n;++i) {\n      cin >> a;\n      g[a/10].push_back(a%10);\n      g[a%10].push_back(a/10);\n      se.insert(a/10);\n      se.insert(a%10);\n    }\n    queue<int> Q;\n    Q.push(a/10);\n    bool visited[7] = {};\n    int ct = 0;\n    while(!Q.empty()) {\n      int now = Q.front();\n      Q.pop();\n      if (visited[now]) continue;\n      visited[now] = 1;\n      ct++;\n      for (int i=0;i<g[now].size(); ++i) {\n        if (!visited[g[now][i]])\n          Q.push(g[now][i]);\n      }\n    }\n    int cnt = 0;\n    for (int i=0;i<7;++i) {\n      if (g[i].size()%2)\n        cnt++;\n    }\n//    cout << cnt << \" \"  << ct << endl;\n    if (ct == se.size() && (cnt == 0 || cnt == 2)) {\n      cout << \"Yes\" << endl;\n    }else\n      cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int INF = 1000000000;\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        int N;\n        while(cin >> N){\n                vector<pii> p(N);\n                for(int i = 0; i < N; ++i){\n                        int x;\n                        cin >> x;\n                        p[i] = pii(x / 10, x % 10);\n                }\n                bool answer = false;\n                for(int begin = 0; !answer && begin < 10; ++begin){\n                        vector< vector<bool> > dp(1 << N, vector<bool>(10));\n                        dp[0][begin] = true;\n                        for(int i = 0; i < (1 << N); ++i){\n                                for(int j = 0; j < 10; ++j){\n                                        if(!dp[i][j]){ continue; }\n                                        for(int k = 0; k < N; ++k){\n                                                if(i & (1 << k)){ continue; }\n                                                int m = i | (1 << k);\n                                                if(p[k].first == j){ dp[m][p[k].second] = true; }\n                                                if(p[k].second == j){ dp[m][p[k].first] = true; }\n                                        }\n                                }\n                        }\n                        for(int i = 0; i < 10; ++i){\n                                if(dp[(1 << N) - 1][i]){ answer = true; }\n                        }\n                }\n                cout << (answer ? \"Yes\" : \"No\") << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nconst int Size = 7;\nbool checkNum(int *num)\n{\n\tint odds = 0;\n\tfor (int i = 0; i < Size; ++i)\n\t\tif (num[i] & 1)\n\t\t\t++odds;\n\treturn odds <= 2;\n}\nbool isSeqGraph(int* num, bool edge[Size][Size])\n{\n\tbool visited[Size];\n\tfill(visited, visited+Size, false);\n\tfor (int i = 0; i < Size && !(visited[i] = num[i] > 0); ++i)\n\t\t;\n\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (visited[i])\n\t\t{\n\t\t\tfor (int j = 0; j < Size; ++j)\n\t\t\t\tvisited[j] |= edge[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (!visited[i] && num[i] > 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint num[Size];\n\t\tbool edge[Size][Size];\n\t\tmemset(num, 0, sizeof(num));\n\t\tfill((bool*)edge, (bool*)edge + Size*Size, false);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tint a = t / 10;\n\t\t\tint b = t % 10;\n\t\t\t++num[a];\n\t\t\t++num[b];\n\t\t\tedge[a][b] = edge[b][a] = true;\n\t\t}\n\t\tif (checkNum(num) && isSeqGraph(num, edge))\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main(){\n    int N;\n    while(cin >> N){\n        int cnt[7] = {0};\n        string in;\n        vector<int> a(N),b(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            a[i] = in[0]-'0';\n            b[i] = in[1]-'0';\n            cnt[a[i]]++;\n            cnt[b[i]]++;\n        }\n        if(N == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        bool check = false;\n        for(int i = 0 ; i < N ; i++){\n            if(a[i] == b[i]){\n                if(cnt[a[i]] == 2){\n                    check = true;\n                    break;\n                }\n            }\n        }\n        if(check){\n            cout << \"No\" << endl;\n            continue;\n        }\n        int odd = 0,even = 0;\n        for(int i = 0 ; i < 7 ; i++){\n            if(cnt[i]&1) odd++;\n            else even++;\n        }\n        cout << ((even == 7 || odd == 2) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint n;\nvs d;\nbool visited[1<<28]={};\n\nbool dfs(int used,int cnt,char l,char r){\n\tif(cnt==n){\n\t\treturn true;\n\t}\n\tif(visited[used]){\n\t\treturn false;\n\t}\n\tvisited[used]=true;\n\tREP(i,n){\n\t\tif(!(used&(1<<i))){\n\t\t\tREP(edge,2){\n\t\t\t\tREP(dir,2){\n\t\t\t\t\tif(edge==0){\n\t\t\t\t\t\tif(d[i][dir]==l){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,d[i][(dir+1)%2],r)){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(d[i][dir]==r){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,l,d[i][(dir+1)%2])){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>n,cin){\n\t\td.clear();\n\t\tREP(i,1<<28){\n\t\t\tvisited[i]=false;\n\t\t}\n\t\tREP(i,n){\n\t\t\tstring dd;\n\t\t\tcin>>dd;\n\t\t\td.push_back(dd);\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,n){\n\t\t\tif(dfs((1<<i),1,d[i][0],d[i][1])){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nclass UnionFind {\n  int _numberOfSet;\n  vector<int> tree, rank, _sizeOfSet;\n\npublic:\n  UnionFind(const int &n) : _numberOfSet(n), tree(n), rank(n), _sizeOfSet(n, 1) { iota(all(tree), 0); }\n\n  int root(const int &x) { return tree[x] == x ? x : tree[x] = root(tree[x]); }\n\n  bool same(const int &a, const int &b) { return root(a) == root(b); }\n\n  bool unite(int a, int b) {\n    a = root(a), b = root(b);\n    if (a == b) return false;\n    if (rank[a] < rank[b]) swap(a, b);\n    tree[b] = a;\n    _sizeOfSet[a] += _sizeOfSet[b];\n    if (rank[a] == rank[b]) rank[a]++;\n    _numberOfSet--;\n    return true;\n  }\n\n  int sizeOfSet(const int &x) { return _sizeOfSet[root(x)]; }\n\n  int numberOfSet() { return _numberOfSet; }\n\n  int size() { return tree.size(); }\n};\n\nsigned main() {\n  constexpr int K = 7;\n  int n;\n  while (cin >> n) {\n    vector<int> a(n);\n    cin >> a;\n    vector<int> d(K);\n    UnionFind uf(K);\n    for (auto &&x : a) {\n      d[x / 10]++, d[x % 10]++;\n      uf.unite(x / 10, x % 10);\n    }\n    int os = 0;\n    for (auto &&x : d) os += odd(x);\n    bool ok = os <= 2;\n    rep(i, K) rep(j, K) ok &= d[i] == 0 || d[j] == 0 || uf.same(i, j);\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m[7];\nchar c;\n\nint main(){\n\twhile(cin>>n){\n\t\tfill(m,m+7,0);\n\t\tn*=2;\n\t\twhile(n--){\n\t\t\tcin>>c;\n\t\t\tm[c-'0']++;\n\t\t}\n\t\tint od=0;\n\t\tfor(int i=0;i<7;i++)if(m[i]%2)od++;\n\t\tif(od<3)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <new>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\n#define REP(i, n) for(i = 0; i < n; i++)\n#define sz(n) n.size()\n#define pb(n) push_back(n)\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\nusing namespace std;\n\nint i, j, n;\n\nbool match_begin(string& novo, string b) {\n    if(b[0] == novo[1]) {\n        return true;\n    } else if(b[0] == novo[0]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool match_end(string& novo, string b) {\n    if(b[1] == novo[0]) {\n        return true;\n    } else if(b[1] == novo[1]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nstring valid(vector<string> s) {\n    int N = s.size();\n    deque<string> ss;\n\n    bool memo[N];\n\n    memset(memo, 0, sizeof(memo));\n\n    ss.push_back(s[0]);\n    memo[0] = true;\n\n    REP(i, N) {\n        REP(j, N) {\n            if(!memo[j] && match_begin(s[j], ss[0])) {\n                memo[j] = true;\n                ss.push_front(s[j]);\n            } else if(!memo[j] && match_end(s[j], ss[ss.size() - 1])) {\n                memo[j] = true;\n                ss.push_back(s[j]);\n            }\n        }\n    }\n\n    if(ss.size() != s.size()) return \"No\";\n\n\n    bool ok = true;\n\n    REP(i, N) {\n        if(!memo[i]) ok = false;\n    }\n    if(ok) return \"Yes\";\n    return \"No\";\n}\n\nint main(void) {\n    while(~scanf(\"%d\", &n)) {\n        vector<string> v(n);\n        REP(i, n) {\n            cin >> v[i];\n        }\n        cout << valid(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nbool check(VI a, VI b){\n    int n = a.size();\n    int m = 7;\n    REP(i,n) cout << a[i] << b[i] << endl;\n    VVI dp(1<<n, VI(m));\n    REP(i,n){\n        dp[1<<i][b[i]] = 1;\n        dp[1<<i][a[i]] = 1;\n    }\n    FOR(i,1,(1<<n)-1) REP(j,m){\n        if (dp[i][j] == 0) continue;\n        REP(k,n){\n            if ((i >> k) & 1) continue;\n            if (a[k] == j) dp[i | (1<<k)][b[k]] = 1;\n            if (b[k] == j) dp[i | (1<<k)][a[k]] = 1;\n        }\n    }\n    REP(j,m){\n        if (dp[(1<<n)-1][j] == 1) return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    while (~scanf(\"%d\", &n)){\n        VI a(n), b(n);\n        REP(i,n){\n            string x;\n            cin >> x;\n            a[i] = x[0] - '0';\n            b[i] = x[1] - '0';\n        }\n\n        cout << (check(a, b) ? \"Yes\" : \"No\") << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin>>n)\n    {\n        vector<int> one(7,0),two(7,0);\n        for(int c=0;c<n;c++)\n        {\n            int z;\n            cin>>z;\n            int g=z%10,d=z/10;\n            if(g==d) two[g]++;\n            else\n            {\n                one[g]++;\n                one[d]++;\n            }\n        }\n        int alone = 0;\n        for(int c=0;c<7;c++)\n        {\n            if(two[c] && !one[c] && n > 1)\n            {\n                cout<<\"No\";\n                goto end;\n            }\n            if(one[c]&1) alone++;\n        }\n        cout<<(alone<=2?\"Yes\":\"No\")<<endl;\n        end:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nchar d[30][3];\nint n;\n\nset<int> ss[7];\n\nbool solve(char prev, int f){\n  if(f == 0) return true;\n  if(ss[prev-'0'].count(f)) return false;\n\n  ss[prev-'0'].insert(f);\n\n  REP(i,n) if(f & (1<<i)){\n    if(prev == d[i][0]){\n      if(solve(d[i][1], f ^ (1<<i))) return true;\n    }else if(prev == d[i][1]){\n      if(solve(d[i][0], f ^ (1<<i))) return true;      \n    }\n  }\n  return false;\n}\n\nint main(){\n  while(~scanf(\"%d\",&n)){\n    REP(i,n) scanf(\"%s\",d[i]);\n    \n    bool ans = false;\n    REP(i,7) ss[i].clear();\n\n    REP(i,7) if(solve(i+'0', (1<<n)-1)){\n      ans = true; break;\n    }\n\n    puts(ans ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//51\n#include<iostream>\n#include<set>\n\n#define T(a,b,c) (a*1000+b*10+c)\n\nusing namespace std;\n\nint p[28];\nint n;\nset<int> s;\n\nbool dfs(int pr,int u,int r){\n  if(r==0){\n    return true;\n  }else if(s.count(T(u,r,pr))){\n    return false;\n  }else{\n    for(int i=0;i<n;i++){\n      if(!(u&1<<i)){\n\tfor(int j=0;j<2;j++){\n\t  p[i]=p[i]/10+p[i]%10*10;\n\t  if(pr==p[i]/10){\n\t    if(dfs(p[i]%10,u|1<<i,r-1))return true;\n\t  }\n\t}\n      }\n    }\n    s.insert(T(u,r,pr));\n    return false;\n  }\n}\n\nint main(){\n  while(cin>>n){\n    s.clear();\n    for(int i=0;i<n;i++){\n      cin>>p[i];\n    }\n    for(int i=0;i<n;i++){\n      if(dfs(p[i]%10,1<<i,n-1)||dfs(p[i]/10,1<<i,n-1)){\n\tcout<<\"Yes\"<<endl;\n\tgoto next;\n      }\n    }\n    cout<<\"No\"<<endl;\n  next:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, cnt[7], in, d[7], i;\n\nmain(){\n  while(cin >> n){\n    for(i=0;i<7;i++) cnt[i] = d[i] = 0;\n    for(i=0;i<n;i++){\n      cin >> in;\n      if(in/10 == in%10) d[in/10] = 1;\n      else{\n        cnt[in/10]++;\n        cnt[in%10]++;\n      }\n    }\n    int f = 1, t = 0;\n    for(i=0;i<7;i++){\n      if(d[i] && !cnt[i] && n > 1) f = 0;\n      if(cnt[i]&1) t++;\n    }\n    if(t > 2) f = 0;\n    cout << (f ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nint is_ok( int now, PII& a )\n{\n\tif ( a.first == now ) return 0;\n\telse if ( a.second == now ) return 1;\n\treturn -1;\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tint n; cin >> n;\n\t\tif ( cin.eof() ) break;\n\n\t\tVPII dominoes( n );\n\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tchar left, right; cin >> left >> right;\n\t\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\t\tdominoes[i] = make_pair( l, r );\n\t\t}\n\n\t\tbool cannot = false;\n\n\t\tif ( cannot == false ){\n\t\t\tVI visited(n,0);\n\t\t\tint now = dominoes[0].first;\n\t\t\tvisited[0] = 1;\n\n\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t{\n\t\t\t\tbool not_found = true;\n\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tnow = ( test == 0 ? dominoes[j].second : dominoes[j].first );\n\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t}\n\t\t}\n\t\tif ( cannot == true ){\n\t\t\tcannot = false;\n\t\t\tVI visited(n,0);\n\t\t\tint now = dominoes[0].second;\n\t\t\tvisited[0] = 1;\n\n\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t{\n\t\t\t\tbool not_found = true;\n\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tnow = ( test == 0 ? dominoes[j].second : dominoes[j].first );\n\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( cannot ) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n};\n\nbool dp[1<<22];\n\nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(dp[visited]) return false;\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n    dp[visited | (1<<i)] = true;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n    memset(dp,false,sizeof(dp));\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint d[128][2];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[i][0] = t / 10;\n\t\t\td[i][1] = t % 10;\n\t\t}\n\t\tbool used[128];\n\t\tfill(used, used+n, false);\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (d[i][0] == d[i][1])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (j != i && (d[j][0] == d[i][0] || d[j][1] == d[i][0]))\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l, r;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tl = d[i][0];\n\t\t\t\tr = d[i][1];\n\t\t\t\tused[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (bool added = true; added; )\n\t\t{\n\t\t\tadded = false;\n\t\t\t\n\t\t\tfor (int i = 0; !added && i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!used[i])\n\t\t\t\t{\n\t\t\t\t\tint a = d[i][0];\n\t\t\t\t\tint b = d[i][1];\n\t\t\t\t\tif (l == a)\n\t\t\t\t\t{\n\t\t\t\t\t\tl = b;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l == b)\n\t\t\t\t\t{\n\t\t\t\t\t\tl = a;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == a)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = b;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == b)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = a;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (added)\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; ok && i < n; ++i)\n\t\t\tok &= used[i];\n\n\t\tif (ok)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N) {\n        vector<string> a(N);\n        for (int i=0; i<N; ++i) cin >> a[i];\n        sort(a.begin(), a.end());\n        a.erase(unique(a.begin(), a.end()), a.end());\n\n        if ((int)a.size() == 1) {\n            cout << \"Yes\" << endl;\n            continue;\n        }\n\n        vector<int> deg(7, 0);\n        vector<bool> has(7, false);\n        for (int i=0; i<(int)a.size(); ++i) {\n            if (a[i][0] != a[i][1]) {\n                deg[a[i][0]-'0'] ++;\n                deg[a[i][1]-'0'] ++;\n            }\n            has[a[i][0]-'0'] = true;\n            has[a[i][1]-'0'] = true;\n        }\n\n        int odd = 0;\n        bool bad = false;\n        for (int i=0; i<7; ++i) {\n            if (deg[i] % 2 == 1) odd ++;\n            if (has[i] && deg[i] == 0) bad = true;\n        }\n        cout << (!bad && (odd == 2 || odd == 0) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N){\n        int cnt[7] = {0};\n        string in;\n        vector<int> a(N),b(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            a[i] = in[0]-'0';\n            b[i] = in[1]-'0';\n            cnt[a[i]]++;\n            cnt[b[i]]++;\n        }\n        if(N == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        bool check = false;\n        for(int i = 0 ; i < N ; i++){\n            int x,y;\n            if(a[i] == b[i]){\n                x = cnt[a[i]]-2;\n                if(x == 0){\n                    check = true;\n                    break;\n                }\n            }else{\n                x = cnt[a[i]]-1;\n                y = cnt[b[i]]-1;\n                if(x == 0 || y == 0){\n                    check = true;\n                    break;\n                }\n            }   \n        }\n        if(check){\n            cout << \"No\" << endl;\n            continue;\n        }\n        int odd = 0,even = 0;\n        for(int i = 0 ; i < 7 ; i++){\n            if(cnt[i]&1) odd++;\n            else even++;\n        }\n        cout << ((even == 7 || odd == 2) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint count,t1;\n\nint adjMatrix[10][10];\nbool visited[10],vi[10];\n\n\nvoid visit(int u){\n  visited[u] = true;\n \n  for(int v=0; v<10; v++){\n    if(!adjMatrix[u][v]) continue;\n    if(!visited[v]) visit(v);\n  }\n\n}\n\n\nint  dfs(){\n  for(int i=0; i<10; i++)  visited[i] = false;\n  \n  visit(t1);\n  for(int i=0;i<10;i++){\n    if(vi[i] == true && visited[i] == false) return 0;\n  }\n  return 1;\n}\n\n\n\n\nint main(){\n\n  int n,a,i,j,table[11],frag,f,ans;\n\n  while(cin >> n){\n    for(i=0 ; i<11; i++)  table[i] = 0;\n\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++) adjMatrix[i][j] = 0;\n    }\n\n  for(i=0; i<n; i++){\n    cin >> a;\n    t1  = a / 10;\n    table[t1]++;\n    a   = a - t1*10;\n    table[a]++;\n    adjMatrix[t1][a] = adjMatrix[a][t1] = 1;\n    vi[a] = vi[t1] = true;\n\n  }\n\n  frag = 0;\n  for(i=0; i<11; i++){\n    if(table[i]%2 != 0) frag++;\n  }\n \n  ans = dfs();\n\n  if(ans == 1 && frag == 2) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int n;cin>>n;){\n\t\tint cs[7]={},d[7][7]={};\n\t\tfor(int i=0;i<7;i++)\n\t\t\td[i][i]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x; cin>>x;\n\t\t\tcs[x/10]++;\n\t\t\tcs[x%10]++;\n\t\t\td[x/10][x%10]=d[x%10][x/10]=1;\n\t\t}\n\t\t\n\t\tfor(int k=0;k<7;k++)\n\t\t\tfor(int i=0;i<7;i++)\n\t\t\t\tfor(int j=0;j<7;j++)\n\t\t\t\t\td[i][j]|=d[i][k]&d[k][j];\n\t\t\n\t\tbool yes=count_if(cs,cs+7,[](int n){return n&1;})<=2;\n\t\tfor(int i=0;i<7;i++)\n\t\t\tfor(int j=0;j<7;j++)\n\t\t\t\tif(cs[i] && cs[j] && !d[i][j])\n\t\t\t\t\tyes=false;\n\t\t\n\t\tputs(yes?\"Yes\":\"No\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector<string> ss;\n\nint done[100];\n\nint dfs(int x){\n\tif( done[x] ) return 0;\n\telse done[x] = 1;\n\tint ans = 1;\n\tfor(int i = 0 ; i < ss.size() ; i++){\n\t\tif( ss[x][0] == ss[i][0] || ss[x][0] == ss[i][1] || ss[x][1] == ss[i][0] || ss[x][1] == ss[i][1]) ans += dfs(i);\n\t}\n\treturn ans;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tfor(int i = 0 ; i < 100 ; i++) done[i] = 0;\n\t\tint t[128]={};\n\t\tint wf[128][128] = {};\n\t\tss.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tt[s[0]]++;\n\t\t\tt[s[1]]++;\n\t\t\twf[s[0]][s[1]] = wf[s[1]][s[0]] = true;\n\t\t\tss.push_back(s);\n\t\t}\n\t\tint odd = 0;\n\t\tfor(int i = '0' ; i <= '9' ; i++){\n\t\t\tif( t[i] % 2 ){\n\t\t\t\todd++;\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tint ok = odd <= 2 && n == dfs(0);\n\t\t\n\t\tcout << (ok?\"Yes\":\"No\") << endl;\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int N;\n    while(cin >> N && !cin.eof()) {\n        vector<vector<int> > v(N, vector<int>(2));\n        for(int i = 0; i < N; ++i) {\n            int n;\n            cin >> n;\n            v[i][0] = n/10;\n            v[i][1] = n%10;\n        }\n\n        int unpaired = N*2;\n        for(int i = 0; i < N; ++i) {\n            for(int k = 0; k < 2; ++k) {\n                if(v[i][k] == -1) continue;\n                for(int j = i+1; j < N; ++j) {\n                    if(v[i][k] == v[j][0]) {\n                        v[i][k] = v[j][0] = -1;\n                        unpaired -= 2;\n                        break;\n                    }\n                    else if(v[i][k] == v[j][1]) {\n                        v[i][k] = v[j][1] = -1;\n                        unpaired -= 2;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if(unpaired <= 2) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nsigned main(void) {\n    int n;\n    while(cin >> n){\n        vi cnt(7),lp(7);\n        rep(i,n){\n            int in;\n            cin >> in;\n            if(in/10 == in%10)lp[in/10]++;\n            else cnt[in/10]++,cnt[in%10]++;\n        }\n        bool ans = true;\n        int t = 0;\n        rep(i,7){\n            if(cnt[i] == 0 && lp[i] && n > 1)ans = false;\n            if(cnt[i]&1)t++;\n        }\n        if(t > 2)ans = false;\n        if(ans)cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        int appear[7] = {};\n        int a;\n\n        for(int i = 0; i < n; i++){\n            cin >> a;\n            appear[a/10]++;\n            appear[a%10]++;\n        }\n\n        int odd = 0;\n        for(int i = 0; i < n; i++){\n            if(appear[i]%2) odd++;\n        }\n\n        if(odd == 0 || odd == 2){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<string> a(n);\n        for(int i=0; i<n; i++){\n            cin >> a[i];\n        }\n        bool dp[1<<18][7];\n        memset(dp, 0, sizeof(dp));\n        for(int i=0; i<n; i++){\n            dp[1<<i][a[i][0]-'0'] = dp[1<<i][a[i][1]-'0'] = true;\n        }\n\n        for(int i=1; i<(1<<n); i++){\n            for(int j=0; j<7; j++){\n                if(!dp[i][j]) continue;\n                for(int k=0; k<n; k++){\n                    if(i>>k & 1) continue;\n                    if(j == a[k][0]){\n                        dp[i | 1<<k][a[k][1]-'0'] = true;\n                    }\n                    if(j == a[k][1]){\n                        dp[i | 1<<k][a[k][0]-'0'] = true;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        for(int i=0; i<7; i++){\n            if(dp[(1<<i)-1][i]){\n                ok = true;\n            }\n        }\n\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<bitset>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nint memo[(1<<25)][10];\n\nbool rec(P *G,int used,int prev)\n{\n  if(__builtin_popcount(used) == n)return true;\n  if(__builtin_popcount(used) >= n)return false;\n  if(memo[used][prev] != -1)return memo[used][prev];\n\n  rep(i,n)\n    {\n      if((used>>i)&1)continue;\n      if(prev == G[i].first)if(rec(G,used|(1<<i),G[i].second))\n\t\t\t      {\n\t\t\t\tmemo[used|(1<<i)][G[i].second] = true;\n\t\t\t\treturn true;\n\t\t\t      }\n      if(prev == G[i].second)if(rec(G,used|(1<<i),G[i].first))\n\t\t\t       {\n\t\t\t\t memo[used|(1<<i)][G[i].first] = true;\n\t\t\t\t return true;\n\t\t\t       }\n    }\n  memo[used][prev] = false;\n  return false;\n}\n\nint main()\n{\n  while(cin >> n)\n    {\n      cin.ignore();\n      rep(i,(1<<n))rep(j,10)memo[i][j] = -1;\n      P G[n];\n      rep(i,n)\n\t{\n\t  char a,b,c;\n\t  scanf(\"%c%c%c\",&a,&b,&c);\n\t  G[i].first = a-'0';\n\t  G[i].second = b-'0';\n\t}\n\n      rep(i,n)\n\t{\n\t  if(rec(G,(1<<i),G[i].second) || rec(G,(1<<i),G[i].first))\n\t    {\n\t      cout << \"Yes\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"No\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\n  \nstatic const double EPS = 1e-8;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nclass Domino {\nprivate:\n  int _head;\n  int _tail;\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n  }\n \n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n \n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n \n  int get_head() const{\n    return _head;\n  }\n \n  int get_tail() const{\n    return _tail;\n  }\n};\n \nbool dp[1<<22];\n \nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(dp[visited]) return false;\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n \n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n \n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n    dp[visited | (1<<i)] = true;\n  }\n  return res;\n}\n \nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n    memset(dp,false,sizeof(dp));\n \n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n \n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n \n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",((same_check && travel_check) || (n == 1)) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint main(){\nint a[7],n,ans;\nchar c;\nwhile(scanf(\"%d\",&n)!=EOF){\nans=0;\nfor(int i=0;i<7;i++)a[i]=0;\nfor(int i=0;i<2*n;i++){\nscanf(\"%c\",&c);\nif(c==' '||c=='\\n')i--;\nelse a[c-'0']++;\n}\nfor(int i=0;i<7;i++){\nif(a[i]%2==1)ans++;\n}\nif(ans>2)printf(\"No\\n\");\nelse printf(\"Yes\\n\");\n}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dfs(Domino current_state,int visited, int pos, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),i,dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check |= dfs(dominos[0],(1<<0),0,dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\nusing namespace std;\n\ntypedef vector <bool> VB;\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nVPII dominoes;\nint n;\nVB visited;\nVB done;\nVVI connected;\nint now;\nint current;\nint visited_count;\n\nbool is_match( PII domino )\n{\n\tif ( now == domino.first ) return true;\n\telse if ( now == domino.second ) return true;\n\telse return false;\n}\n\nint get_next( PII domino )\n{\n\tif ( now == domino.first ) return domino.second;\n\telse if ( now == domino.second ) return domino.first;\n\telse return -1;\n}\n\nbool search()\n{\n\tif ( visited_count == n - 1 ) return true;\n\tif ( done[current] == false )\n\t{\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tif ( is_match( dominoes[i] ) ) connected[current].push_back( i );\n\t\t\tif ( visited[i] ) continue;\n\t\t\tif ( is_match( dominoes[i] ) )\n\t\t\t{\n\t\t\t\tint backup = now;\n\t\t\t\tint backup_current = now;\n\t\t\t\tnow = get_next( dominoes[i] );\n\t\t\t\tcurrent = i;\n\t\t\t\tvisited[i] = true;\n\t\t\t\tvisited_count++;\n\t\t\t\tif ( search() ) return true;\n\t\t\t\tvisited_count--;\n\t\t\t\tvisited[i] = false;\n\t\t\t\tnow = backup;\n\t\t\t\tcurrent = backup_current;\n\t\t\t}\n\t\t}\n\t\tdone[current] = true;\n\t}\n\telse\n\t{\n\t\tfor ( VI::iterator it = connected[current].begin(); it != connected[current].end(); it++ )\n\t\t{\n\t\t\tif ( visited[*it] ) continue;\n\t\t\tif ( is_match( dominoes[*it] ) )\n\t\t\t{\n\t\t\t\tint backup = now;\n\t\t\t\tint backup_current = current;\n\t\t\t\tnow = get_next( dominoes[*it] );\n\t\t\t\tvisited[*it] = true;\n\t\t\t\tvisited_count++;\n\t\t\t\tif ( search() ) return true;\n\t\t\t\tvisited_count--;\n\t\t\t\tvisited[*it] = false;\n\t\t\t\tnow = backup;\n\t\t\t\tcurrent = backup_current;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve()\n{\n\tdone = VB( n, false );\n\tconnected = VVI( n );\n\tvisited = VB( n, false );\n\tvisited_count = 0;\n\n\t// ツ全ツづづ個ドツミツノツづ可づつつ「ツづ篠篠つキ\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tfor ( int j = 0; j < 2; j++ )\n\t\t{\n\t\t\t// now = ( j ? dominoes[i].first : dominoes[i].second );\n\t\t\tnow = dominoes[i].second;\n\t\t\tcurrent = i;\n\t\t\tvisited[i] = true;\n\t\t\tif ( search() ) return true; // ツつキツづ猟づづ個ドツミツノツづーツ配ツ置ツづつォツづゥツつゥ\n\t\t\tvisited[i] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid input_dominoes( int n )\n{\n\tdominoes = VPII( n );\n\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tchar left, right; cin >> left >> right;\n\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\tdominoes[i] = make_pair( l, r );\n\t}\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tcin >> n;\n\t\tif ( cin.eof() ) break;\n\t\tinput_dominoes( n );\n\n\t\tbool result = solve();\n\t\tif ( result ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\t\tstatic int gyes = 0;\n\t\tstatic int gno = 0;\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint d[128][2];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[i][0] = t / 10;\n\t\t\td[i][1] = t % 10;\n\t\t}\n\t\tint c[10];\n\t\tmemset(c, 0, sizeof(c));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (int j = 0; j < 2; ++j)\n\t\t\t\t++c[d[i][j]];\n\n\n\t\tint follow = -1;\n\n\t\tbool usedNum[10];\n\t\tfill(usedNum, usedNum+10, false);\n\t\tbool used[128];\n\t\tfill(used, used+n, false);\n\n\t\t{\n\t\t\tint i;\n\t\t\tfor (i = 0; follow == -1 && i < n; ++i)\n\t\t\t{\n\t\t\t\tif (c[d[i][0]] & 1)\n\t\t\t\t\tfollow = d[i][1];\n\t\t\t\telse if (c[d[i][1]] & 1)\n\t\t\t\t\tfollow = d[i][0];\n\n\t\t\t\tif (follow != -1)\n\t\t\t\t{\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tusedNum[d[i][1]] = usedNum[d[i][0]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (follow == -1)\n\t\t\t{\n\t\t\t\tfollow = d[0][0];\n\t\t\t\tused[0] = true;\n\t\t\t\tusedNum[d[0][0]] = usedNum[d[0][1]] = true;\n\t\t\t}\n\t\t}\n\n\t\tint left = n-1;\n\t\tfor (bool changed = true; changed; )\n\t\t{\n\t\t\tchanged = false;\n\t\t\tfor (int i = 0; !changed && i < n; ++i)\n\t\t\t{\n\t\t\t\tif (used[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (follow == d[i][0])\n\t\t\t\t{\n\t\t\t\t\tfollow = d[i][1];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (follow == d[i][1])\n\t\t\t\t{\n\t\t\t\t\tfollow = d[i][0];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\tif (changed)\n\t\t\t\t{\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tusedNum[d[i][0]] = usedNum[d[i][1]] = true;\n\t\t\t\t\t--left;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (bool changed = true; left && changed; )\n\t\t{\n\t\t\tchanged = false;\n\t\t\tfor (int u = 0; u < 10; ++u)\n\t\t\t{\n\t\t\t\tif (!usedNum[u])\n\t\t\t\t\tcontinue;\n\n\t\t\t\tint _left = left;\n\t\t\t\tbool _used[128];\n\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t_used[i] = used[i];\n\n\t\t\t\tint _follow = -1;\n\t\t\t\tfor (int i = 0; _follow == -1 && i < n; ++i)\n\t\t\t\t{\n\t\t\t\t\tif (_used[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif (d[i][0] == u)\n\t\t\t\t\t\t_follow = d[i][1];\n\t\t\t\t\telse if (d[i][1] == u)\n\t\t\t\t\t\t_follow = d[i][0];\n\t\t\t\t\t\n\t\t\t\t\tif (_follow != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t_used[i] = true;\n\t\t\t\t\t\t--_left;\n\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor (bool _changed = true; _changed; )\n\t\t\t\t{\n\t\t\t\t\t_changed = false;\n\t\t\t\t\tfor (int i = 0; !_changed && i < n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_used[i])\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif (_follow == d[i][0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_follow = d[i][1];\n\t\t\t\t\t\t\t_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (_follow == d[i][1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_follow = d[i][0];\n\t\t\t\t\t\t\t_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_changed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_used[i] = true;\n\t\t\t\t\t\t\t--_left;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_left != left && _follow == u)\n\t\t\t\t{\n\t\t\t\t\tleft = _left;\n\t\t\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!used[i] && _used[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tused[i] = _used[i];\n\t\t\t\t\t\t\tusedNum[d[i][0]] = usedNum[d[i][1]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!left)\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint UF[200];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint deg[100];\nint main(){\n\tint a;\n\twhile(~scanf(\"%d\",&a)){\n\t\tfor(int i=0;i<10;i++)deg[i]=0;\n\t\tfor(int i=0;i<10;i++)UF[i]=-1;\n\t\twhile(a--){\n\t\t\tint b;scanf(\"%d\",&b);\n\t\t\tUNION(b/10,b%10);\n\t\t\tdeg[b/10]++;\n\t\t\tdeg[b%10]++;\n\t\t}\n\t\tbool ok=true;\n\t\tint ki=0;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tif(deg[i]%2)ki++;\n\t\t\tfor(int j=0;j<10;j++)if(deg[i]&&deg[j]&&FIND(i)!=FIND(j))ok=false;\n\t\t}\n\t\tif(ki>2)ok=false;\n\t\tif(ok)printf(\"Yes\\n\");else printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint path[7];\n\nvoid solve(){\n  int odd = 0;\n\n  for(int i = 0; i < 7; i++){\n    if(path[i]%2) odd++;\n  }\n  cout << (odd==2?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  \n  int N;\n  while(cin >> N && N){\n    fill(path,path+7,0);\n    while(N--){\n      int in;\n      cin >> in;\n      path[in/10]++;\n      path[in%10]++;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int i;\n  string s;\n  while(cin>>i){\n    int n[7]={0};\n    for(;i-->0;){\n      cin>>s;\n      n[s[0]-'0']++;\n      n[s[1]-'0']++;\n    }\n    int odd=0,one=0;\n    for(i=0;i<7;i++){\n      odd+=n[i]&1;\n      one+=(n[i]==1);\n    }\n    puts((odd==0||odd==2)&&!one?\"YES\":\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n,n) {\n    int hoge[7] = {};\n    for (int i=0;i<n;++i) {\n      int a;\n      cin >> a;\n      hoge[a/10]++;\n      hoge[a%10]++;\n    }\n    int cnt = 0;\n    for (int i=0;i<7;++i) {\n      if (hoge[i]%2)\n        cnt++;\n    }\n    if (cnt == 0 || cnt == 2) {\n      cout << \"Yes\" << endl;\n    }else\n      cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#include<queue>\n#define MAX 8\nusing namespace std;\nstruct domino{\n  int a,b;\n  domino():a(0),b(0){}\n  domino(int t):a(t/10),b(t%10){}\n  void swap(){std::swap(a,b);}\n};\nbool dfs(list<domino> now, domino ds[], bool vis[], int n, int num){\n  if( num == n ){\n    /*\nfor(list<domino>::iterator itl = now.begin();\n\titl != now.end(); ++itl){\n      cout << '[' << itl->a << ',' << itl->b << \"] \";\n    }\n    cout << endl;\n    */\n    return true;\n  }\n  /*\n  for(list<domino>::iterator itl = now.begin();\n      itl != now.end(); ++itl){\n    cout << '[' << itl->a << ',' << itl->b << \"] \";\n  }\n  cout << endl;\n  */\n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      domino t = ds[i];\n      \n      /*if( t.b == now.front().a ){\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n      }else if( t.a == now.front().a ){\n\tt.swap();\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n\t}else\n      */if( t.b == now.back().b ){\n\tt.swap();\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }else if( t.a == now.back().b ){\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }\n      //return false;\n    }\n  }\n  return false;\n}\n\nbool isConnected(bool adj[][MAX], bool vis[], bool exist[]){\n  int st;\n  bool ret=true;\n  for(int i = 0; i < MAX; ++i){if(exist[i])st=i;vis[i]=false;}\n  queue<int> q;q.push(st);\n  while(!q.empty()){\n    int now=q.front();q.pop();\n    //cout << now << endl;\n    for(int i = 0; i < MAX; ++i){\n      //cout << \"NOW : \" << now << \" to \" << i << \" : \" << adj[now][i] << endl;\n      if(adj[now][i]&&!vis[i]){vis[i]=true;q.push(i);}\n    }\n  }\n  for(int i = 0; i < MAX; ++i){\n    if(exist[i]){\n      //cout << i << \" : \" << vis[i] << endl;\n      if(!vis[i])ret=false;\n    }\n  }\n  //cout << endl;\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    bool ans=false;\n    cin >> n;\n    if(cin.eof())break;\n    int dim[MAX]={0,};\n    bool exist[MAX]={false,};\n    bool vis[MAX];\n    bool adj[MAX][MAX] = {{false,}};\n    for(int i = 0; i < n; ++i){\n      int t;cin>>t;\n      exist[t/10]=exist[t%10]=true;\n      adj[t/10][t%10]=adj[t%10][t/10]=true;\n      dim[t/10]++;dim[t%10]++;\n    }\n    int even=0;\n    int odd=0;\n    for(int i = 0; i < 7; ++i){\n      if( exist[i] ){\n\t//cout << i << \" : \" << dim[i] << endl;\n\tif(dim[i]%2==0)++even;\n\telse odd++;\n      }\n    }\n    if( isConnected(adj,vis,exist) && (odd == 0 || odd == 2) ) ans = true;\n\n    if( ans )puts(\"Yes\");\n    else puts(\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<18][18][2];\nint N;\nstring s[18];\n\nint func( int state, int n, int p )\n{\n  if( state == (1 << N) - 1 ) { //cout << p << endl;\n    return 1;\n  }\n  if( dp[state][n][p] != -1 ) return dp[state][n][p];\n\n  int ret = 0;\n  for(int i=0; i<N; i++) {\n    if( state & (1 << i) ) continue;\n    if( s[n][p] == s[i][0] ) ret = func( state | (1 << i), i, 1 );\n    if( s[n][p] == s[i][1] ) ret = func( state | (1 << i), i, 0 );\n  }\n\n  return dp[state][n][p] = ret;\n}\n\n\nint main()\n{\n  while( cin >> N ) {\n    for(int i=0; i<N; i++) cin >> s[i];\n    int flag = 0;\n    for(int i=0; i<N; i++) {\n      fill_n(**dp, (1<<18)*18*2, -1);\n      flag = func( 1 << i, i, 0 );\n      flag = func( 1 << i, i, 1 );\n      //cout << flag << endl;\n      if( flag == 1 ) break;\n    }\n    \n    if( flag ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dfs(Domino current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//copied from PG111002(UVa10054)\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n\n#define hi(_x) ((_x)>>16)\n#define lo(_x) ((_x)&0xffff)\nusing namespace std;\n#define rotate(v, index) rotate((v).begin(), (v).begin()+(index), (v).end())\n\ninline int unite(vector<int> &u, vector<vector<int>*> &array){\n  int _array, _u, _each;\n  while(array.size()){\n    for(_array=0; _array<array.size(); _array++){//今まで作ったeuler閉路すべてに対しuと結合できるかどうか調べる\n      vector<int> each = *(array[_array]); //eachはeuler閉路を構成すると仮定する\n      for(_u=0; _u<u.size(); _u++){\n        for(_each=0; _each<each.size(); _each++){\n          if(lo(u[_u])==hi(each[_each])){\n            if(_each)rotate(each,_each); //each[_each]が先頭に来るよう頭だし\n            u.insert(u.begin()+_u+1,each.begin(),each.end());\n            delete array[_array];\n            array.erase(array.begin()+_array);\n            goto next;\n          }\n        }\n      }\n    }\n    //fail\n    return 0;\n    next:\n    /*continue*/;\n  }//while\n  return 1;\n}\n\ninline int sort(vector<int>&s,vector<int>&v){\n  int x=hi(v[0]), y=lo(v[0]), i, a=0;\n  v.erase(v.begin());\n  s.push_back((x<<16)+y);\n  while(1){\n    for(i=0; i<v.size(); i++){\n      if(lo(s[a])==hi(v[i])||lo(s[a])==lo(v[i]))goto in;//break;\n    }\n    /*if(i==v.size())*/break;\nin:\n    x=hi(v[i]), y=lo(v[i]);\n    v.erase(v.begin()+i);\n    if(lo(s[a])==y)swap(x,y);\n    s.push_back((x<<16)+y);\n    a++;\n  }//while\n  return hi(s[0])==lo(s[a]);\n}\n\nchar s[99];\nint A[10],a,b;\nint main(){\n  int i=0, k;\n  int n, l, x, y;\n  vector<int> vorig;\n  vector<vector<int>*> varray;\n  vector<int> vunite;\n\n  for(;~scanf(\"%d\",&l);){\n\tmemset(A,0,sizeof(A));\n    for(k=0;k<l;k++){\n      //scanf(\"%d %d\",&x, &y);\n      scanf(\"%s\",s);\n      x=s[0]-48,y=s[strlen(s)-1]-48;\n      vorig.push_back((x<<16)+y);\n\t  A[x]++,A[y]++;\n    }\n\tfor(a=b=-1,k=0;k<10;k++){\n\t\tif(A[k]&1){\n\t\t\tif(a==-1)a=k;\n\t\t\telse if(b==-1)b=k;\n\t\t\telse goto fail;\n\t\t}\n\t}\n\tif(a!=-1)vorig.push_back((a<<16)+b);\n\n    while(vorig.size()){\n      vector<int> *p = new vector<int>;\n      if(!sort(*p,vorig))goto fail;\n      varray.push_back(p);\n    }\n\n    vunite = *(varray[0]);\n    delete varray[0];\n    varray.erase(varray.begin());\n    if(!unite(vunite,varray))goto fail;\n\n    while(vunite.size()){\n      //printf(\"%d %d\\n\",hi(vunite[0]),lo(vunite[0]));\n      vunite.erase(vunite.begin());\n    }\n\tputs(\"Yes\");\n    continue;\n\nfail:\n    while(varray.size()){\n      delete varray[0];\n      varray.erase(varray.begin());\n    }\n    puts(\"No\");\n\tvorig.clear();\n    vunite.clear();\n  }//for\n}//main"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nbool search(const int state, const int last, const std::vector<std::string> &dominos, std::vector<std::vector<char>>& memo) {\n\tif (state == memo[last].size() - 1) return true;\n\tif (memo[last][state] >= 0) return memo[last][state] == 1;\n\tmemo[last][state] = 0;\n\tfor (auto i = 0; i < dominos.size(); ++i) if ((state & (1 << i)) == 0) {\n\t\tif (dominos[i].front() - '0' == last) {\n\t\t\tauto res = search(state | (1 << i), dominos[i].back() - '0', dominos, memo);\n\t\t\tif (res) {\n\t\t\t\tmemo[last][state] = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (dominos[i].back() - '0' == last) {\n\t\t\tauto res = search(state | (1 << i), dominos[i].front() - '0', dominos, memo);\n\t\t\tif (res) {\n\t\t\t\tmemo[last][state] = 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile (std::cin >> n) {\n\t\tstd::vector<std::string> dominos(n); for (auto& domino : dominos) std::cin >> domino;\n\t\tstd::vector<std::vector<char>> can_make(10, std::vector<char>(1 << n, -1));\n\t\tauto can = false;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tif (search(1 << i, dominos[i].back() - '0', dominos, can_make)) {\n\t\t\t\tstd::cout << \"Yes\\n\";\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (search(1 << i, dominos[i].front() - '0', dominos, can_make)) {\n\t\t\t\tstd::cout << \"Yes\\n\";\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!can) std::cout << \"No\\n\";\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)==1){\n\t\tvector<int> args;\n\t\tint mat[7];\n\t\tfor(int x=0;x<7;++x)mat[x]=0;\n\t\tfor(int x=0;x<n;x++){\n\t\t\tint j;scanf(\"%d\",&j);\n\t\t\targs.push_back(j);\n\t\t\tmat[j%10]++;\n\t\t\tmat[j/10]++;\n\t\t}\n\t\tint t = 0;\n\t\tfor(int x=0;x<7;++x){\n\t\t\tif(mat[x]%2!=0)t++;\n\t\t}\n\t\tif(t==0 || t==2){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\t\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 18\nusing namespace std;\n\nbool dp[(1<<N)][N][2];\n\nint main(){\n  \n  int n;\n  \n  while(cin>>n){\n    \n    string num[N];\n\n    for(int i=0;i<n;i++) cin>>num[i];\n    \n    memset(dp,0,sizeof(dp));\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<2;j++) dp[(1<<i)][i][j]=true;\n    \n    for(int i=0;i<(1<<n);i++)\n      \n      for(int j=0;j<n;j++)\n\t\n\tfor(int k=0;k<2;k++){\n\t  \n\t  if(!dp[i][j][k]) continue;\n\n\t  for(int l=0;l<n;l++){\n\n\t    if(i&(1<<l)) continue;\n\t    \n\t    for(int m=0;m<2;m++)\n\t      \n\t      if(num[j][k]==num[l][m]) dp[i|(1<<l)][l][!m]=true;\n\t    \n\t  }\n\t  \n\t}\n\n    bool ans=false;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<2;j++) ans|=dp[(1<<n)-1][i][j];\n\n    cout<<(ans?\"Yes\":\"No\")<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N) {\n        vector<int> deg(7, 0);\n        string a;\n        for (int i=0; i<N; ++i) {\n            cin >> a;\n            deg[a[0]-'0'] ++;\n            deg[a[1]-'0'] ++;\n        }\n        int odd = 0;\n        for (int i=0; i<7; ++i) {\n            if (deg[i] % 2 == 1) odd ++;\n        }\n        cout << ((odd == 2 || odd == 0) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n){\n    \n   int c[7]={},f=0,p;\n\n   for(int i=0;i<n;i++){\n    cin>>p;\n    c[p%10]++;\n    c[(p/10)]++;\n   }\n\n   for(int i=0;i<n;i++)\n    if(c[i]%2)f++;\n\n   cout<<(f>2?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int n;\n  string s[30];\n\n  while(cin >> n){\n    for(int i=0;i<n;i++)cin >> s[i];\n\n    int num[10];\n    bool dual[10];\n    for(int i=0;i<=6;i++){\n      num[i] = 0;\n      dual[i] = false;\n    }\n\n    for(int i=0;i<n;i++){\n      if(s[i][0] == s[i][1])dual[s[i][0] - '0'] = true;\n      num[s[i][0] - '0']++;\n      num[s[i][1] - '0']++;\n    }\n\n    int odd = 0;\n    bool f = true;\n    for(int i=0;i<=6;i++){\n      if(num[i]&1)odd++;\n      else if(dual[i]){\n\tif(num[i]<=2 && n!=1)f = false;\n      }\n    }\n    if(odd>2)f = false;\n\n    if(f)cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N) {\n        vector<int> deg(7, 0);\n        vector<bool> has(7, false);\n        string a;\n        for (int i=0; i<N; ++i) {\n            cin >> a;\n            if (a[0] != a[1]) {\n                deg[a[0]-'0'] ++;\n                deg[a[1]-'0'] ++;\n            }\n            has[a[0]-'0'] = true;\n            has[a[1]-'0'] = true;\n        }\n        int odd = 0;\n        bool bad = false;\n        for (int i=0; i<7; ++i) {\n            if (deg[i] % 2 == 1) odd ++;\n            if (has[i] && deg[i] == 0) bad = true;\n        }\n        cout << (!bad && (odd == 2 || odd == 0) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool solve(int N) {\n  int cnt[10] = {};\n  bool same[10] = {};\n  bool diff[10] = {};\n  set<int> st;\n  rep(i, N) {\n    int x; cin >> x;\n    cnt[x/10]++, cnt[x%10]++;\n    st.insert(x/10), st.insert(x%10);\n    if(x/10==x%10)same[x/10]=1;else diff[x/10]=diff[x%10]=1;\n  }\n  if(st.size() == 1) return true;\n  int oddcnt = 0;\n  rep(i, 10) oddcnt += cnt[i] % 2;\n  if(oddcnt != 0 && oddcnt != 2) return false;\n  rep(i, 10) if(same[i]&&!diff[i]) return false;\n  return true;}int main() {for(int N; cin >> N && N;) cout << (solve(N) ? \"Yes\" : \"No\") << endl;return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N){\n        int cnt[7] = {0};\n        string in;\n        vector<int> a(N),b(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            a[i] = in[0]-'0';\n            b[i] = in[1]-'0';\n            cnt[a[i]]++;\n            cnt[b[i]]++;\n        }\n        if(N == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        bool check = false;\n        for(int i = 0 ; i < N ; i++){\n            if(a[i] == b[i]){\n                if(cnt[a[i]] == 2){\n                    check = true;\n                    break;\n                }\n            }\n        }\n        if(check){\n            cout << \"No\" << endl;\n            continue;\n        }\n        int odd = 0,even = 0;\n        for(int i = 0 ; i < 7 ; i++){\n            if(cnt[i]&1) odd++;\n            else even++;\n        }\n        cout << ((even == 7 || odd == 2) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    \n    int n;\n    while(cin >> n){\n        if(n == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        vector<pair<int, int> > a(n);\n        vector<int> count(7, 0);\n        vector<bool> par(7, false);\n        for(int i = 0; i < n; i++){\n            string input; cin >> input;\n            a[i].first = (int)(input[0] - '0');\n            a[i].second = (int)(input[1] - '0');\n            //cout << a[i].first << \" \" << a[i].second << endl;\n            count[a[i].first]++;\n            count[a[i].second]++;\n            if(a[i].first == a[i].second) par[a[i].first] = true;\n        }\n\n        int cnt_odd = 0;\n        for(int i = 0; i < 7; i++) cnt_odd += (count[i] % 2 == 1);\n\n        if(cnt_odd != 0 && cnt_odd != 2){\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool ok = true;\n\n        for(int i = 0; i < 7; i++){\n            \n\n\n            if(par[i]){\n\n                bool tmp = false;                \n\n                for(int j = 0; j < n; j++){\n                    if(a[j].first == a[j].second) continue;\n\n                    if(i == a[j].first || i == a[j].second){\n                        tmp = true;\n                    }\n                }\n\n                if(!tmp){\n                    ok = false;\n                    continue;\n                }\n            }\n        }\n\n        //cout << \"wahaha\" << endl;\n        if(ok) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nbool check();\nint map[11][11],v[1001],g[7],vis[7],t[7];\nint main()\n{\nint n,x;\n while (cin>>n)   \n    {\n     for (int i=0;i<=6;i++)\n     {\n      g[i]=0;\n      t[i]=0;\n      }\n     for (int i=0;i<=6;i++)\n     for (int j=0;j<=6;j++)\n      map[i][j]=0;\n     for (int i=1;i<=n;i++)\n     {\n       cin>>x; \n       int x1=x/10;\n       int x2=x%10;\n       t[x1]++;\n       t[x2]++;             \n       if (x1!=x2)\n       {\n       g[x1]++;\n       g[x2]++;\n       map[x1][x2]=1;\n       map[x2][x1]=1;\n       }\n     }\n     if (check())\n     {\n     int l=0;\n     for (int i=0;i<=6;i++)\n      if (g[i]%2!=0) l++;\n      if (l==0 || l==2) cout<<\"Yes\"<<endl;\n       else cout<<\"No\"<<endl;\n       }\n      else cout<<\"No\"<<endl;\n    }\n}\n\nbool check()\n{\n int l=1,r=1;\n memset(v,0,sizeof(v));\n memset(vis,0,sizeof(vis));\n  while (g[l]==0) l++;\n  v[1]=l;\n  vis[l]=1;\n   for (int i=0;i<=6;i++)\n    if (map[l][i]==1)\n       {\n          r++;\n          v[r]=i;    \n          vis[i]=1;\n       }\n   int x;\n   while (l<r) \n   {\n    x=v[++l];\n    for (int i=0;i<=6;i++)\n     if (vis[i]==0 && map[x][i]==1)\n       {\n                   vis[i]=1;\n                   v[++r]=i;\n       }\n     }  \n  for (int i=0;i<=6;i++)\n   if (vis[i]==0 && t[i]) return 0;\n  return 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\tbool FLG;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\t\tFLG = true;\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++)if(array[i]%2 == 1)num_KI++;\n\n\t\tif(num_KI > 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] > 0 && i == get_boss(i))num_boss++;\n\t\t}\n\t\tif(num_boss > 1)FLG = false;\n\n\t\tif(FLG){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        int appear[7] = {}, domino[7] = {};\n        int a;\n\n        for(int i = 0; i < n; i++){\n            cin >> a;\n            appear[a/10]++;\n            appear[a%10]++;\n            domino[a/10]++;\n            if(a/10 != a%10)    domino[a%10]++;\n        }\n\n        int odd = 0;\n        for(int i = 0; i < 7; i++){\n            if(appear[i]%2 || (appear[i]%2 == 0 && domino[i] == 1)) odd++;\n        }\n\n        if(n == 1 || odd == 0 || odd == 2){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin >> N){\n        int cnt[7] = {0};\n        string in;\n        for(int i = 0 ; i < N ; i++){\n            cin >> in;\n            cnt[in[0]-'0']++;\n            cnt[in[1]-'0']++;\n        }\n        if(N == 1){\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        int odd = 0;\n        for(int i = 0 ; i < 7 ; i++){\n            if(cnt[i]&1) odd++;\n        }\n        cout << (odd == 2 ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    \n    int n;\n    while(cin >> n){\n        vector<pair<int, int> > a(n);\n        vector<int> count(7, 0);\n        vector<bool> par(7, false);\n        for(int i = 0; i < n; i++){\n            string input; cin >> input;\n            a[i].first = (int)(input[0] - '0');\n            a[i].second = (int)(input[1] - '0');\n            //cout << a[i].first << \" \" << a[i].second << endl;\n            count[a[i].first]++;\n            count[a[i].second]++;\n            if(a[i].first == a[i].second) par[a[i].first] = true;\n        }\n\n        int cnt_odd = 0;\n        for(int i = 0; i < 7; i++) cnt_odd += (count[i] % 2 == 1);\n\n        if(cnt_odd != 0 && cnt_odd != 2){\n            cout << \"No\" << endl;\n            break;\n        }\n\n        bool ok = true;\n\n        for(int i = 0; i < 7; i++){\n            \n\n\n            if(par[i]){\n\n                bool tmp = false;                \n\n                for(int j = 0; j < n; j++){\n                    if(a[j].first == a[j].second) continue;\n\n                    if(i == a[j].first || i == a[j].second){\n                        tmp = true;\n                    }\n                }\n\n                if(!tmp){\n                    ok = false;\n                    break;\n                }\n            }\n        }\n\n        //cout << \"wahaha\" << endl;\n        if(ok) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dp[1<<20][20];\n\nbool dfs(Domino current_state,int visited, int pos, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    if(dp[visited | (1<<i)][i]) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    dp[visited | (1<<i)][i] = true;\n    res |= dfs(next,visited | (1<<i),i,dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    for(int i = 0; i < dominos.size(); i++){\n      memset(dp,false,sizeof(dp));\n      dp[1<<i][i] = true;\n      travel_check |= dfs(dominos[i],(1<<i),i,dominos);\n    }\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N,cnt[10][10],check[10];\n\nvoid isloop(int start){\n  for (int i=0;i<10;i++){\n    if (cnt[start][i]){\n      if (check[i]==0){\n\tcheck[i]=1;\n\tisloop(i);\n      }else return;\n    }\n  }\n}\n\nint main(){\n  int a,t,odda=-1,oddb=-1,flg;\n\n  while (cin >> N){\n    for (int i=0;i<10;i++){\n      check[i]=-1;\n      for (int j=0;j<10;j++)\n\tcnt[i][j]=0;\n    }\n    flg=0;\n    for (int i=0;i<N;i++){\n      cin >>a;\n      cnt[a/10][a%10]++;\n      cnt[a%10][a/10]++;\n      check[a/10]=0;\n      check[a%10]=0;\n    }\n    for (int i=0;i<10;i++){\n      t=0;\n      for (int j=0;j<10;j++){\n\tif (i==j)continue;\n\tt+=cnt[i][j];\n      }\n      if (t%2){\n\tif (odda==-1){\n\t  odda=i;\n\t}else if (oddb==-1){\n\t  oddb=i;\n\t}else{\n\t  cout << \"No\"<<endl;\n\t  flg=1;\n\t  break;\n\t}\n      }\n    }\n    if (flg)break;\n    isloop(odda);\n    for (int i=0;i<10;i++){\n      if (check[i]==0){\n\tflg=1;\n\tcout << \"No\" << endl;\n\tbreak;\n      }\n    }\n    if (flg)break;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdlib>\n\n#define conv(c) ((int)(c-'0'))\n\nusing namespace std;\n\nint n, s, t;\nbool vis[7][7];\nbool d[7][7];\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\n\nbool dfs(int y, int x, int cnt)\n{\n  if(cnt == n && y == s && x == t) return true;\n  if((y == s && x == t && cnt != 0) || cnt == n) return false;\n\n  for(int i = 0; i < 4; i++){\n    int dx = x+xdir[i], dy = y+ydir[i];\n    if(0 <= dx && dx < 7 && 0 <= dy && dy < 7 && vis[dy][dx] && d[dy][dx]){\n      vis[dy][dx] = false;\n      if(dfs(dy, dx, cnt+1)) return true;\n      vis[dy][dx] = true;\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  string str;\n\n  while(cin>>n){\n    bool f = false;\n    fill(&vis[0][0], &vis[7][0], true);\n    fill(&d[0][0], &d[7][0], false);\n    for(int i = 0; i < n; i++){\n      cin >> str;\n      s = conv(str[0]); t = conv(str[1]);\n      if(s > t) swap(s, t);\n      d[s][t] = true;\n    }\n\n    for(int i = 0; i < 7 && !f; i++)\n      for(int j = 0; j < 7 && !f; j++)\n\tif(d[i][j]){\n\t  s = i; t = j;\n\t  f = dfs(i, j, 0);\n\t}\n\n    cout << (f? \"Yes\": \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, cnt[7], in;\nbool d[7];\n\nmain(){\n  while(cin >> n){\n    for(int i=0;i<7;i++) cnt[i] = d[i] = 0;\n    for(int i=0;i<n;i++){\n      cin >> in;\n      if(in/10 == in%10) d[in/10] = true;\n      else{\n        cnt[in/10]++;\n        cnt[in%10]++;\n      }\n    }\n    bool f = true;\n    int t = 0;\n    for(int i=0;i<7;i++){\n      if(d[i] && !cnt[i]) f = false;\n      if(cnt[i]&1) t++;\n    }\n    if(t > 2) f = false;\n    cout << (f ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\n  bool _can_connect_head;\n  bool _can_connect_tail;\n\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n    _can_connect_head = true;\n    _can_connect_tail = true;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head\n       && d.can_connect_head() && can_connect_head()){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail\n       && d.can_connect_head() && can_connect_tail()){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head\n       && d.can_connect_tail() && can_connect_head()){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail\n       && d.can_connect_tail() && can_connect_tail()){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n\n  bool can_connect_head() const{\n    return _can_connect_head;\n  }\n\n  bool can_connect_tail() const{\n    return _can_connect_tail;\n  }\n\n};\n\nbool dfs(Domino current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    int degree[8];\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check |= dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    \n    int n;\n    while(cin >> n){\n        vector<pair<int, int> > a(n);\n        vector<int> count(7, 0);\n        vector<bool> par(7, false);\n        for(int i = 0; i < n; i++){\n            string input; cin >> input;\n            a[i].first = (int)(input[0] - '0');\n            a[i].second = (int)(input[1] - '0');\n            //cout << a[i].first << \" \" << a[i].second << endl;\n            count[a[i].first]++;\n            count[a[i].second]++;\n            if(a[i].first == a[i].second) par[a[i].first] = true;\n        }\n\n        int cnt_odd = 0;\n        for(int i = 0; i < 7; i++) cnt_odd += (count[i] % 2 == 1);\n\n        if(cnt_odd != 0 && cnt_odd != 2){\n            cout << \"No\" << endl;\n            break;\n        }\n\n        bool ok = true;\n\n        for(int i = 0; i < 7; i++){\n            \n\n\n            if(par[i]){\n\n                bool tmp = false;                \n\n                for(int j = 0; j < n; j++){\n                    if(a[j].first == a[j].second) continue;\n\n                    if(i == a[j].first || i == a[j].second){\n                        tmp = true;\n                    }\n                }\n\n                if(!tmp){\n                    ok = false;\n                    continue;\n                }\n            }\n        }\n\n        //cout << \"wahaha\" << endl;\n        if(ok) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a;\nint t[7],u[2];\n\nbool v[7][7];\nbool ud[7],vd[7];\n\nvoid dfs(int pos){\n  if(vd[pos]==true)return;\n  vd[pos]=true;\n  for(int i=0;i<7;i++){\n    if(v[pos][i]==false)continue;\n    dfs(i);\n  }\n}\n\nbool check(){\n  for(int i=0;i<7;i++)vd[i]=false;\n  for(int i=0;i<7;i++)if(t[i]>0){dfs(i);break;}\n  for(int i=0;i<7;i++){\n    if(t[i]>0&&vd[i]==false)return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin>>n){\n    for(int i=0;i<7;i++)t[i]=0;\n    for(int i=0;i<7;i++)for(int j=0;j<7;j++)v[i][j]=false;\n\n    u[0]=u[1]=0;\n    for(int i=0;i<n;i++){\n      cin>>a;\n      t[a/10]++;\n      t[a%10]++;\n      v[a/10][a%10]=v[a%10][a/10]=true;\n    }\n\n    for(int i=0;i<7;i++)if(t[i]>0)u[t[i]%2]++;    \n    \n    if((u[1]==2||u[1]==0)&&check())cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\nvector<int> d[10001];\nbool passed[10001];\n\nvoid dfs(int s){\n\tif(passed[s])\n\t\treturn;\n\tpassed[s]=true;\n\tfor(int i = 0; i < d[s].size(); i++){\n\t\tint to=d[s][i];\n\t\tdfs(to);\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n){\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\td[i].clear();\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tint cnt[10001];\n\t\tfill(cnt,cnt+10001,0);\n\t\tvector<pii> v;\n\t\tint ss;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpii p;\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tp.first=str[0]-'0';\n\t\t\tp.second=str[1]-'0';\n\t\t\tv.push_back(p);\n\t\t\tcnt[p.first]++;\n\t\t\tcnt[p.second]++;\n\t\t\tss=p.first;\n\t\t\td[p.first].push_back(p.second);\n\t\t\td[p.second].push_back(p.first);\n\t\t}\n\n\t\tdfs(ss);\n\t\tbool f=false;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(cnt[i]==0||passed[i])\n\t\t\t\tcontinue;\n\t\t\telse{\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint cc=0;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(cnt[i]%2!=0){\n\t\t\t\tcc++;\n\t\t\t}\n\t\t}\n\t\tif(cc==2){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse if(cc==0)\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a;\nint t[7],u[2];\nint main(){\n  while(cin>>n){\n    for(int i=0;i<7;i++)t[i]=0;\n    u[0]=u[1]=0;\n    for(int i=0;i<n;i++){\n      cin>>a;\n      t[a/10]++;\n      t[a%10]++;\n    }\n    for(int i=0;i<7;i++)u[t[i]%2]++;\n    if(u[1]==2)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<set>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nchar d[30][3];\nint n;\n\nset<int> ss[7];\n\nbool solve(int cnt, char prev, int f){\n  if(cnt == n) return true;\n  if(ss[prev-'0'].count(f)) return false;\n\n  ss[prev-'0'].insert(f);\n\n  REP(i,n) if(f & (1<<i)){\n    if(prev == d[i][0]){\n      if(solve(cnt+1, d[i][1], f ^ (1<<i))) return true;\n    }else if(prev == d[i][1]){\n      if(solve(cnt+1, d[i][0], f ^ (1<<i))) return true;      \n    }\n  }\n  return false;\n}\n\nint main(){\n  while(~scanf(\"%d\",&n)){\n    REP(i,n) scanf(\"%s\",d[i]);\n    \n    bool ans = false;\n    REP(i,7) ss[i].clear();\n\n    REP(i,7) if(solve(0, i+'0', (1<<n)-1)){\n      ans = true; break;\n    }\n\n    puts(ans ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\nint index(char c){\n\treturn (int)c - '0';\n}\n\nint get_num(string s){\n\tint count = 0;\n\tcount += index(s[0]) * 10;\n\tcount += index(s[1]);\n\treturn count;\n}\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tmap<int, int> mp;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring num;\n\t\t\tcin >> num;\n\t\t\tint a = get_num(num);\n\t\t\tmp[a / 10]++;\n\t\t\tmp[a % 10]++;\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tif(mp[i] % 2 == 1) count++;\n\t\t}\n\t\tif(count > 2) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <list>\n\nusing namespace std;\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    list<int> ls;\n    for (int i = 0; i < n; i++) {\n      int x;\n      scanf(\"%d\", &x);\n      ls.push_back(x);\n    }\n    bool f = false;\n    for (;;) {\n      if (ls.size() == 1) {\n        f = true;\n        break;\n      }\n      int a = ls.front(), b = a % 10, x = -1;\n      a /= 10;\n      ls.pop_front();\n      for (list<int>::iterator l = ls.begin(); l != ls.end(); ++l)\n        if (*l / 10 == a) {\n          ls.erase(l);\n          x = b * 10 + *l % 10;\n          break;\n        } else if (*l % 10 == a) {\n          ls.erase(l);\n          x = b * 10 + *l / 10;\n          break;\n        } else if (*l / 10 == b) {\n          ls.erase(l);\n          x = a * 10 + *l % 10;\n          break;\n        } else if (*l % 10 == b) {\n          ls.erase(l);\n          x = a * 10 + *l / 10;\n          break;\n        }\n      if (x < 0)\n        break;\n      ls.push_back(x);\n    }\n    puts(f ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<string> a(n);\n        for(int i=0; i<n; i++){\n            cin >> a[i];\n        }\n        sort(a.begin(), a.end());\n        bool ok = false;\n        do{\n            for(int d=0; d<2; d++){\n                char next = a[0][d];\n                for(int i=1; i<n; i++){\n                    if(a[i][0] == next){\n                        next = a[i][1];\n                    }else if(a[i][1] == next){\n                        next = a[i][0];\n                    }else{\n                        break;\n                    }\n                    if(i == n-1){\n                        ok = true;\n                    }\n                }\n            }\n        }while(!ok && next_permutation(a.begin(), a.end()));\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nint G[10][10];\n\nvoid dfs(int i,int j){\n  int r,ni,nj;\n  G[i][j] = 0;\n  int di[4] = {0,-1,0,1};\n  int dj[4] = {1,0,-1,0};\n  for(r=0;r<4;r++){\n    ni = i + di[r];\n    nj = i + dj[r];\n    if(ni > 0 && ni < 10 && nj > 0 && nj < 10 &&G[ni][nj] == 1) dfs(ni,nj);\n  }\n} \n\nint main(){\n\n  int n,a,i,j,table[11],t1,frag,f;\n\n  while(cin >> n){\n    for(i=0 ; i<11; i++)  table[i] = 0;\n\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++) G[i][j] = 0;\n    }\n\n  for(i=0; i<n; i++){\n    cin >> a;\n    t1  = a / 10;\n    table[t1]++;\n    a   = a - t1*10;\n    table[a]++;\n\n    G[t1][a] = 1;\n\n  }\n\n  dfs(t1,a);\n\n  f = 1;\n  for(i=0;i<10;i++){\n    for(j=0;j<10;j++){\n      if(G[i][j] == 1) f    = 0;\n    }\n  }\n\n  frag = 0;\n  for(i=0; i<11; i++){\n    if(table[i]%2 != 0) frag++;\n  }\n \n  if(frag == 2 && f == 0) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <string>\n\n#include <sstream>\n\n#include <vector>\n\n#include <list>\n\n#include <queue>\n\n#include <deque>\n\n#include <stack>\n\n#include <set>\n\n#include <map>\n\n#include <functional>\n\n#include <numeric>\n\n#include <utility>\n\n#include <algorithm>\n\n#include <new>\n\n#include <cmath>\n\n#include <climits>\n\n#include <cstdlib>\n\n#include <cstdio>\n\n#include <cctype>\n\n#include <cstring>\n\n\n\n#define REP(i, n) for(i = 0; i < n; i++)\n\n#define sz(n) n.size()\n\n#define pb(n) push_back(n)\n\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\n\n\nusing namespace std;\n\n\n\nint i, j, n;\n\n\n\nbool match(string a, string b) {\n\n    return a[0] == b[0] || a[0] == b[1] || a[1] == b[0] || a[1] == b[1];\n\n}\n\n\n\nstring valid(vector<string> s) {\n\n    int N = s.size();\n\n    bool memo[N];\n\n    memset(memo, 0, sizeof(memo));\n\n\n\n    deque<string> ss;\n\n\n\n    ss.push_back(s[0]);\n\n\n\n    REP(i, N - 1) {\n\n        REP(j, n) {\n\n            if(i != j && !memo[j]) {\n\n                if(match(s[j], ss[0])) {\n\n                    memo[j] = true;\n\n                    ss.push_front(s[j]);\n\n                } else if(match(s[j], ss[ss.size() - 1])) {\n\n                    memo[j] = true;\n\n                    ss.push_back(s[j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n    bool ok = true;\n\n    REP(i, N) {\n\n        if(!memo[i]) ok = false;\n\n    }\n\n    if(ok) return \"Yes\";\n\n    return \"No\";\n\n}\n\n\n\nint main(void) {\n\n    freopen(\"i.in\", \"r\", stdin);\n\n    while(~scanf(\"%d\", &n)) {\n\n        vector<string> v(n);\n\n        REP(i, n) {\n\n            cin >> v[i];\n\n        }\n\n        cout << valid(v) << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid rec(int map[7][7], bool visited[7][7], int x, int y) {\n  static int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  visited[y][x] = true;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if(nx < 0) continue;\n    if(nx >= 7) continue;\n    if(ny < 0) continue;\n    if(ny >= 7) continue;\n\n    if(!visited[ny][nx] && map[ny][nx] == 1) rec(map, visited, nx, ny);\n  }\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    int map[7][7];\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tmap[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      int temp;\n      cin >> temp;\n      int a, b;\n      a = temp / 10;\n      b = temp % 10;\n      if(a > b) {\n\ttemp = a;\n\ta = b;\n\tb = temp;\n      }\n      map[b][a] = 1;\n    }\n\n    bool visited[7][7];\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tvisited[i][j] = false;\n      }\n    }\n\n    int sima = 0;\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tif(!visited[i][j] && map[i][j] == 1) {\n\t  sima++;\n\t  rec(map, visited, j, i);\n\t}\n      }\n    }\n\n    int kisu = 0;\n    if(sima > 1) {\n      kisu = 99999;\n    } else {\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tif(map[i][j] == 0) continue;\n\tint count = 0;\n\tfor(int k = 0; k < 4; k++) {\n\t  int nx = j + d[k][0];\n\t  int ny = i + d[k][1];\n\t  if(nx < 0) continue;\n\t  if(nx >= 7) continue;\n\t  if(ny < 0) continue;\n\t  if(ny >= 7) continue;\n\n\t  if(map[ny][nx] == 1) count++;\n\t}\n\tif(count % 2 != 0) kisu++;\n      }\n    }\n    }\n    if(kisu == 2) cout << \"Yes\" << endl;\n    else          cout << \"No\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n    int N;\n    while (cin >> N) {\n        if (N == 1) {\n            cout << \"Yes\" << endl;\n            continue;\n        }\n        vector<int> deg(7, 0);\n        vector<bool> has(7, false);\n        string a;\n        for (int i=0; i<N; ++i) {\n            cin >> a;\n            if (a[0] != a[1]) {\n                deg[a[0]-'0'] ++;\n                deg[a[1]-'0'] ++;\n            }\n            has[a[0]-'0'] = true;\n            has[a[1]-'0'] = true;\n        }\n        int odd = 0;\n        bool bad = false;\n        for (int i=0; i<7; ++i) {\n            if (deg[i] % 2 == 1) odd ++;\n            if (has[i] && deg[i] == 0) bad = true;\n        }\n        cout << (!bad && (odd == 2 || odd == 0) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nconst int Size = 10;\nbool checkNum(int *num)\n{\n\tint odds = 0;\n\tfor (int i = 0; i < Size; ++i)\n\t\tif (num[i] & 1)\n\t\t\t++odds;\n\treturn odds == 0 || odds == 2;\n}\nbool isConnectedGraph(int* num, bool edge[Size][Size])\n{\n\tbool visited[Size];\n\tfill(visited, visited+Size, false);\n\tfor (int i = 0; i < Size && !(visited[i] = num[i] > 0); ++i)\n\t\t;\n\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (visited[i])\n\t\t{\n\t\t\tfor (int j = 0; j < Size; ++j)\n\t\t\t\tvisited[j] |= edge[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < Size; ++i)\n\t{\n\t\tif (!visited[i] && num[i] > 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n//int main()\n//{\n//\tint n;\n//\twhile (scanf(\"%d\", &n) != EOF)\n//\t{\n//\t\tint num[Size];\n//\t\tbool edge[Size][Size];\n//\t\tmemset(num, 0, sizeof(num));\n//\t\tfill((bool*)edge, (bool*)edge + Size*Size, false);\n//\t\tfor (int i = 0; i < n; ++i)\n//\t\t{\n//\t\t\tint t;\n//\t\t\tscanf(\"%d\", &t);\n//\t\t\tint a = t / 10;\n//\t\t\tint b = t % 10;\n//\t\t\t++num[a];\n//\t\t\t++num[b];\n//\t\t\tedge[a][b] = edge[b][a] = true;\n//\t\t}\n//\t\tif (checkNum(num) && isConnectedGraph(num, edge))\n//\t\t\tputs(\"Yes\");\n//\t\telse\n//\t\t\tputs(\"No\");\n//\t}\n//\n//\treturn 0;\n//}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tint d[128][2];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[i][0] = t / 10;\n\t\t\td[i][1] = t % 10;\n\t\t}\n\t\tbool used[128];\n\t\tfill(used, used+n, false);\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (d[i][0] == d[i][1])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (j != i && (d[j][0] == d[i][0] || d[j][1] == d[i][0]))\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l, r;\n\t\tl = d[0][0];\n\t\tr = d[0][1];\n\t\tused[0] = true;\n\t\tfor (bool added = true; added; )\n\t\t{\n\t\t\tadded = false;\n\t\t\t\n\t\t\tfor (int i = 0; !added && i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!used[i])\n\t\t\t\t{\n\t\t\t\t\tint a = d[i][0];\n\t\t\t\t\tint b = d[i][1];\n\t\t\t\t\tif (l == a)\n\t\t\t\t\t{\n\t\t\t\t\t\tl = b;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l == b)\n\t\t\t\t\t{\n\t\t\t\t\t\tl = a;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == a)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = b;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (r == b)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = a;\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (added)\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; ok && i < n; ++i)\n\t\t\tok &= used[i];\n\n\t\tif (ok)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\tbool FLG;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\t\tFLG = true;\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++)if(array[i]%2 == 1)num_KI++;\n\n\t\tif(num_KI > 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] > 0 && boss[i] == get_boss(i))num_boss++;\n\t\t}\n\t\tif(num_boss > 1)FLG = false;\n\n\t\tif(FLG){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t}\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\n\tint row,col;\n};\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 6 && col >=0 && col <= 6)\treturn true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint N;\n\tchar buf[3];\n\tbool check[7][7];\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tfor(int row = 0; row <= 6;row++){\n\t\t\tfor(int col = 0; col <= 6;col++)check[row][col] = false;\n\t\t}\n\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\tcheck[buf[0]-'0'][buf[1]-'0'] = true;\n\t\t}\n\n\t\tint num_KI = 0,tmp,next_row,next_col;\n\n\t\tfor(int row = 0; row <= 6; row++){\n\t\t\tfor(int col = 0; col <= 6;col++){\n\t\t\t\tif(check[row][col]){\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tnext_row = row+diff_row[i];\n\t\t\t\t\t\tnext_col = col+diff_col[i];\n\n\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == true)tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp%2 == 1)num_KI++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(num_KI == 0 || num_KI == 2){\n\n\t\t\tbool FLG = false;\n\n\t\t\tfor(int row = 0; row <= 6; row++){\n\t\t\t\tfor(int col = 0; col <= 6; col++){\n\t\t\t\t\tif(check[row][col]){\n\n\t\t\t\t\t\tcheck[row][col] = false;\n\n\t\t\t\t\t\tInfo first;\n\t\t\t\t\t\tfirst.row = row;\n\t\t\t\t\t\tfirst.col = col;\n\n\t\t\t\t\t\tqueue<Info> Q;\n\n\t\t\t\t\t\tQ.push(first);\n\n\t\t\t\t\t\twhile(!Q.empty()){\n\n\t\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\t\tnext_row = Q.front().row+diff_row[i];\n\t\t\t\t\t\t\t\tnext_col = Q.front().col+diff_col[i];\n\t\t\t\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && check[next_row][next_col] == true){\n\t\t\t\t\t\t\t\t\tcheck[next_row][next_col] = false;\n\t\t\t\t\t\t\t\t\tQ.push(Info(next_row,next_col));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor(int i = 0; i <= 6; i++){\n\t\t\t\t\t\t\tfor(int k = 0; k <= 6; k++){\n\t\t\t\t\t\t\t\tif(check[i][k]){\n\t\t\t\t\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(FLG)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(FLG)break;\n\n\t\t\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG)break;\n\t\t\t}\n\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(void)\n{\n    const int N_MAX = 18;\n    int N;\n    int l[N_MAX];\n    int r[N_MAX];\n    int count[7];\n    while (scanf(\"%d\", &N) != EOF) {\n        REP(i, 7) count[i] = 0;\n        REP(i, N) {\n            char c;\n            cin >> c;\n            l[i] = c - '0';\n            cin >> c;\n            r[i] = c - '0';\n            ++count[l[i]];\n            ++count[r[i]];\n        }\n        int odd = 0;\n        REP(i, 7) {\n            if (count[i] % 2 == 1) {\n                ++odd;\n            }\n        }\n        if (odd > 2) {\n            cout << \"No\" << endl;\n        } else {\n            int dbl = 0;\n            int N0 = N;\n            REP(i, N) {\n                if (l[i] == r[i]) {\n                    ++dbl;\n                    if (count[l[i]] > 2) {\n                        --dbl;\n                        --N0;\n                        count[l[i]] -= 2;\n                    }\n                }\n            }\n            if (N0 == 1 || dbl == 0) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint main(){\n\n  int n,a,i,table[11],t1,frag;\n\n  while(cin >> n){\n    for(i=0 ; i<11; i++)  table[i] = 0;\n\n  for(i=0; i<n; i++){\n    cin >> a;\n    t1  = a / 10;\n    table[t1]++;\n    a   = a - t1*10;\n    table[a]++;\n  }\n  frag = 0;\n  for(i=0; i<11; i++){\n    if(table[i]%2 != 0) frag++;\n  }\n \n  if(frag == 2) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t{\n\t\tbool used[128];\n\t\tfill(used, used+n, false);\n\t\tint c[10];\n\t\tmemset(c, 0, sizeof(c));\n\t\tint d[128][2];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\td[i][0] = t / 10;\n\t\t\td[i][1] = t % 10;\n\t\t\t++c[d[i][0]];\n\t\t\t++c[d[i][1]];\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (d[i][0] == d[i][1])\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (j != i && (d[j][0] == d[i][0] || d[j][1] == d[i][0]))\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint follow = -1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tif (c[d[i][0]] & 1)\n\t\t\t\t{\n\t\t\t\t\tfollow = d[i][1];\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (c[d[i][1]] & 1)\n\t\t\t\t{\n\t\t\t\t\tfollow = d[i][0];\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (follow == -1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!used[i])\n\t\t\t\t{\n\t\t\t\t\tfollow = d[i][0];\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (bool added = true; added; )\n\t\t{\n\t\t\tadded = false;\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (!used[i])\n\t\t\t\t{\n\t\t\t\t\tif (d[i][0] == follow)\n\t\t\t\t\t{\n\t\t\t\t\t\tfollow = d[i][1];\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (d[i][1] == follow)\n\t\t\t\t\t{\n\t\t\t\t\t\tfollow = d[i][0];\n\t\t\t\t\t\tadded = true;\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; ok && i < n; ++i)\n\t\t\tok = used[i];\n\n\t\tif (ok)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nstruct Domino\n{\n  int id;\n  int op;\n  Domino(int _id, int _op) { id = _id; op = _op; }\n};\n\nvector<pair<int,int> > Dominos;\nvector<Domino> graph[7];\nbool visited[28];\nint n;\n\nbool dfs(int num, int d)\n{\n  if (d == n) { return true; }\n  if (d > n) return false;\n  if (graph[num].empty()) { return false; }\n  for (int i=0;i<graph[num].size();i++)\n  {\n    int nextid = graph[num][i].id;\n    int nextop = graph[num][i].op;\n    if (!visited[nextid])\n    {\n      visited[nextid] = true;\n      bool res = dfs(nextop, d+1);\n      if (res) { return true; }\n      else { visited[nextid] = false; }\n    }\n  }\n  return false;\n}\n\n\nint main()\n{\n  while (cin >> n)\n  {\n    for (int i=0;i<7;i++) graph[i].clear();\n    Dominos.clear();\n    bool found = false;\n\n    for (int i=0;i<n;i++)\n    {\n      int m, x, y;\n      cin >> m;\n      x = m / 10; y = m % 10;\n      Dominos.push_back(make_pair(x, y));\n\n      Domino dx(i, y), dy(i, x);\n      if (x == y) graph[x].push_back(dx);\n      else\n      {\n        graph[x].push_back(dx);\n        graph[y].push_back(dy);\n      }\n    }\n\n    for (int id=0;id<n;id++)\n    {\n      for (int i=0;i<n;i++) visited[i] = false;\n      int x = Dominos[id].first;\n      int y = Dominos[id].second;\n      visited[id] = true;\n      if (dfs(x, 1)) { found = true; break; }\n      if (x != y) if (dfs(y, 1)) { found = true; break; }\n    }\n    if (found) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a;\nint t[7],u[2];\n\nbool v[7][7];\nbool ud[7],vd[7];\n\nvoid dfs(int pos){\n  if(vd[pos]==true)return;\n  vd[pos]=true;\n  for(int i=0;i<7;i++){\n    if(v[pos][i]==false)continue;\n    dfs(i);\n  }\n}\n\nbool check(){\n  for(int i=0;i<7;i++)vd[i]=false;\n  for(int i=0;i<7;i++)if(t[i]>0)dfs(i);\n  for(int i=0;i<7;i++){\n    if(t[i]>0&&vd[i]==false)return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin>>n){\n    for(int i=0;i<7;i++)t[i]=0;\n    for(int i=0;i<7;i++)for(int j=0;j<7;j++)v[i][j]=false;\n\n    u[0]=u[1]=0;\n    for(int i=0;i<n;i++){\n      cin>>a;\n      t[a/10]++;\n      t[a%10]++;\n      v[a/10][a%10]=v[a%10][a/10]=true;\n    }\n\n    for(int i=0;i<7;i++)if(t[i]>0)u[t[i]%2]++;    \n    \n    if((u[1]==2||u[1]==0)&&check())cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid sik(int);\nint gr[7][7];\nint ch[7];\nint co[7];\nint main(){\n  while(1){\n    //\n    for(int i=0;i<7;i++){\n      for(int j=0;j<7;j++){\n\tgr[i][j]=0;\n\tch[i]=-1;\n\tco[i]=0;\n      }\n    }\n    int f=0;\n    //\n    int n;\n    cin >> n;\n    if(cin.eof())break;\n    int st;\n    for(int i=0;i<n;i++){\n      int bu;\n      cin >> bu;\n      gr[bu/10][bu%10]=1;\n      gr[bu%10][bu/10]=1;\n      ch[bu%10]=0;\n      ch[bu/10]=0;\n      co[bu/10]++;\n      co[bu%10]++;\n      st=bu%10;\n    }\n    int cok=0;\n    for(int i=0;i<7;i++){\n      if(co[i]%2)cok++;\n    }\n    if(cok>2)f=1;\n    sik(st);\n    for(int i=0;i<7;i++){\n      // cout << ch[i] << endl;\n      if(ch[i]==0)f=1;      \n    }\n    if(f)cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}\nvoid sik(int a){\n  for(int i=0;i<7;i++){\n    if(gr[a][i]){\n      if(ch[i])continue;\n      else{\n\tch[i]=1;\n\tsik(i);\n      }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint count,t1;\n\nint adjMatrix[10][10];\nbool visited[10],use[10];\n\n\nvoid visit(int u){\n  visited[u] = true;\n \n  for(int v=0; v<10; v++){\n    if(adjMatrix[u][v] == 0) continue;\n    if(!visited[v]) visit(v);\n  }\n\n}\n\n\nvoid  dfs(){\n  for(int i=0; i<10; i++)  visited[i] = false;\n  \n  visit(t1);\n\n}\n\n\n\n\nint main(){\n\n  int n,a,i,j,table[10],frag,f,ans;\n\n  while(cin >> n){\n    for(i=0 ; i<10; i++){\n      table[i] = 0;\n      use[i] = false;\n    }\n\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++) adjMatrix[i][j] = 0;\n    }\n    \n    for(i=0; i<n; i++){\n      cin >> a;\n      t1  = a / 10;\n      table[t1]++;\n      a   = a - t1*10;\n      table[a]++;\n      adjMatrix[t1][a] = adjMatrix[a][t1] = 1;\n      use[a] = use[t1] = true;\n      \n    }\n    \n    frag = 0;\n    for(i=0; i<10; i++){\n      if(table[i]%2 != 0) frag++;\n    }\n    \n    dfs();\n\n    ans = 1;\n    for(i=0;i<10;i++){\n      if(use[i] == true && visited[i] == false) ans = 0;\n    }\n    \n    if(ans == 1 && frag == 2) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  int name;\n  vector<int> edges;\n};\n\nset<int> search(vector<Node> g) {\n\n  int now;\n  for(int i=0; i<=6; i++)\n    if(!g[i].edges.empty())\n      now = i;\n\n  stack<int> q;\n  set<int> s;\n  q.push(now);\n\n  while(!q.empty()) {\n    now = q.top();\n    s.insert(now);\n    q.pop();\n\n    for(int i=0; i<g[now].edges.size(); i++)\n      if( s.find(g[now].edges[i])==s.end() )\n\tq.push( g[now].edges[i] );\n  }\n  return s;\n}\n\nint main() {\n\n  int d,c;\n  while(cin>>d) {\n    string s;\n    vector<Node> graph;\n\n    for(int i=0; i<=6; i++) {\n      Node n;\n      n.name = i;\n      graph.push_back(n);\n    }\n\n    for(int i=0; i<d; i++) {\n      cin>>s;\n      graph[s[0]-'0'].edges.push_back(s[1]-'0');\n      graph[s[1]-'0'].edges.push_back(s[0]-'0');\n    }\n\n    set<int> con = search(graph);\n\n    for(int i=0; i<graph.size(); i++)\n      if(con.find(i)==con.end() && !graph[i].edges.empty() ) {\n\tcout<<\"No\"<<endl;\n\tgoto NEXT;\n      }\n\n    c=0;\n    for(int i=0; i<graph.size(); i++)\n      if(graph[i].edges.size()%2==1)\n\tc++;\n\n    if(c==0||c==2) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nvector<int> g[7];\nbool u[28];\n\nint edge_index(int a, int b){\n\tint p = min(a, b);\n\tint q = max(a, b);\n\treturn q * (q + 1) / 2 + p;\n}\n\nbool srch(int i){\n\tfor(auto& v: g[i]){\n\t\tint e = edge_index(i, v);\n\t\tif(!u[e]){\n\t\t\tu[e] = true;\n\t\t\tif(srch(v)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tu[e] = false;\n\t\t}\n\t}\n\n\trep(i, 7){\n\t\tfor(auto& v: g[i]){\n\t\t\tif(!u[edge_index(i, v)]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tint a = t / 10;\n\t\t\tint b = t % 10;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tbool b = false;\n\t\trep(i, 28){\n\t\t\tfill(u, u + 28, false);\n\t\t\tif(srch(i)){\n\t\t\t\tb = true;\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!b){\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int n;~scanf(\"%d\",&n);){\n\t\tint deg[7]={},node;\n\t\tbool wf[7][7]={};\n\t\trep(u,7)\twf[u][u]=true;\n\t\trep(i,n){\n\t\t\tint domi;\tscanf(\"%d\",&domi);\n\t\t\tint u=domi/10,v=domi%10;\n\t\t\tdeg[u]++,deg[v]++;\n\t\t\twf[u][v]=wf[v][u]=true;\n\t\t\tnode=u;\n\t\t}\n\n\t\trep(k,7)rep(i,7)rep(j,7)\twf[i][j]|=wf[i][k]&wf[k][j];\n\t\tbool ok=true;\n\t\trep(u,7) if(deg[u]>0 && !wf[node][u]) ok=false;\n\t\tif(!ok){ puts(\"No\"); continue; }\n\n\t\tint cnt=0;\n\t\trep(u,7)if(deg[u]%2==1) cnt++;\n\t\tputs(cnt<=2?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid rec(int map[7][7], bool visited[7][7], int x, int y) {\n  static int d[8][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1}};\n  visited[y][x] = true;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if(nx < 0) continue;\n    if(nx >= 7) continue;\n    if(ny < 0) continue;\n    if(ny >= 7) continue;\n\n    if(!visited[ny][nx] && map[ny][nx] == 1) rec(map, visited, nx, ny);\n  }\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    int map[7][7];\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tmap[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      int temp;\n      cin >> temp;\n      int a, b;\n      a = temp / 10;\n      b = temp % 10;\n      if(a > b) {\n\ttemp = a;\n\ta = b;\n\tb = temp;\n      }\n      map[b][a] = 1;\n    }\n\n    bool visited[7][7];\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tvisited[i][j] = false;\n      }\n    }\n\n    int sima = 0;\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tif(!visited[i][j] && map[i][j] == 1) {\n\t  sima++;\n\t  rec(map, visited, j, i);\n\t}\n      }\n    }\n\n    int kisu = 0;\n    if(sima > 1) {\n      kisu = 99999;\n    } else {\n      int d[8][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,1},{-1,-1},{1,-1}};\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tif(map[i][j] == 0) continue;\n\tint count = 0;\n\tfor(int k = 0; k < 4; k++) {\n\t  int nx = j + d[k][0];\n\t  int ny = i + d[k][1];\n\t  if(nx < 0) continue;\n\t  if(nx >= 7) continue;\n\t  if(ny < 0) continue;\n\t  if(ny >= 7) continue;\n\n\t  if(map[ny][nx] == 1) count++;\n\t}\n\tif(count % 2 != 0) kisu++;\n      }\n    }\n    }\n    if(kisu == 2) cout << \"Yes\" << endl;\n    else          cout << \"No\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<bitset>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\n\nbool rec(P *G,int used,int prev)\n{\n  if(__builtin_popcount(used) == n)return true;\n  if(__builtin_popcount(used) >= n)return false;\n\n  rep(i,n)\n    {\n      if((used>>i)&1)continue;\n      if(prev == G[i].first)if(rec(G,used|(1<<i),G[i].second))return true;\n      if(prev == G[i].second)if(rec(G,used|(1<<i),G[i].first))return true;\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> n)\n    {\n      cin.ignore();\n      P G[n];\n      rep(i,n)\n\t{\n\t  char a,b,c;\n\t  scanf(\"%c%c%c\",&a,&b,&c);\n\t  G[i].first = a-'0';\n\t  G[i].second = b-'0';\n\t}\n\n      rep(i,n)\n\t{\n\t  if(rec(G,(1<<i),G[i].second) || rec(G,(1<<i),G[i].first))\n\t    {\n\t      cout << \"Yes\" << endl;\n\t      goto F;\n\t    }\n\t}\n      cout << \"No\" << endl;\n    F:;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n){\n        int appear[7] = {}, domino[7] = {};\n        bool hasDup[7] = {};\n        int a;\n\n        for(int i = 0; i < n; i++){\n            cin >> a;\n            appear[a/10]++;\n            appear[a%10]++;\n            domino[a/10]++;\n            if(a/10 != a%10)    domino[a%10]++;\n            else                hasDup[a/10] = true;\n        }\n\n        int odd = 0;\n        for(int i = 0; i < 7; i++){\n            if(appear[i]%2) odd++;\n        }\n\n        bool judge = true;\n        for(int i = 0; i < 7; i++){\n            if(hasDup[i] && domino[i] == 1) judge = false;\n        }\n\n        bool rule1 = (odd == 0 || odd == 2);\n        bool rule2 = (judge || n == 1);\n        \n        if(rule1 && rule2){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n  int N;\n  while (cin >> N) {\n    bool g[7][7] = {};\n    bool wf[7][7] = {};\n    for (int i = 0; i < N; ++i) {\n      int v;\n      cin >> v;\n      int x = v/10, y = v%10;\n      g[x][y] = wf[x][y] = true;\n      g[y][x] = wf[y][x] = true;\n    }\n    for (int k = 0; k < 7; ++k)\n      for (int i = 0; i < 7; ++i)\n\tfor (int j = 0; j < 7; ++j)\n\t  if (wf[i][k] && wf[k][j])\n\t    wf[i][j] = true;\n\n    int cnt[7] = {};\n    int odd = 0;\n    int use = 0;\n    for (int i = 0; i < 7; ++i) {\n      int adj = 0;\n      for (int j = 0; j < 7; ++j) {\n\tif (i != j && g[i][j]) ++adj;\n\tif (wf[i][j]) ++cnt[i];\n      }\n      if (adj % 2 == 1) ++odd;\n      if (adj > 0 || g[i][i]) ++use;\n    }\n    bool res = (odd == 0 || odd == 2);\n    for (int i = 0; i < 7; ++i) {\n      if (cnt[i] > 0 && cnt[i] != use) res = false;\n    }\n    cout << (res ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\nusing namespace std;\n\nstruct Node{\n  int name;\n  vector<int> edges;\n  bool done;\n};\n\nset<int> search(vector<Node> g) {\n\n  int now;\n  for(int i=0; i<=6; i++)\n    if(!g[i].edges.empty())\n      now = i;\n\n  stack<int> q;\n  set<int> done;\n  done.insert(now);\n  q.push(now);\n\n  while(!q.empty()) {\n    now = q.top();\n    done.insert(now);\n    q.pop();\n\n    for(int i=0; i<g[now].edges.size(); i++)\n      if( done.find(g[now].edges[i])==done.end() ) {\n\tq.push( g[now].edges[i] );\n\t//cout<<\"edge\"<<now<<endl;\n      }\n  }\n  return done;\n}\n\nint main() {\n\n  int d,count;\n  while(cin>>d) {\n    string s;\n    set<int> used;\n    map<int,int> edge;\n\n    vector<Node> graph;\n    for(int i=0; i<=6; i++) {\n      Node l;\n      l.name = i;\n      l.done = false;\n      graph.push_back(l);\n    }\n\n    for(int i=0; i<d; i++) {\n      cin>>s;\n      for(int j=0; j<2; j++) {\n\tused.insert(s.at(j)-'0');\n\tif(edge.find(s.at(j)-'0')!=edge.end())\n\t  edge[s.at(j)-'0']++;\n\telse\n\t  edge[s.at(j)-'0']=1;\n      }\n      graph[s.at(0)-'0'].edges.push_back(s.at(1)-'0');\n      graph[s.at(1)-'0'].edges.push_back(s.at(0)-'0');\n    }\n\n    set<int> con;\n    con = search(graph);\n\n    /*\n    for(set<int>::iterator it=con.begin(); it!=con.end(); it++)\n      cout<<\"Set \"<<(*it)<<endl;\n    */\n\n    for(int i=0; i<graph.size(); i++)\n      if(con.find(i)==con.end() && !graph[i].edges.empty() ) {\n\t//cout<<i<<endl;\n\tcout<<\"No\"<<endl;\n\tgoto NEXT;\n      }\n\n    count=0;\n    for(int i=0; i<graph.size(); i++) {\n      if(graph[i].edges.size()%2==1) {\n\tcount++;\n\t//cout<<i<<endl;\n      }\n    }\n\n    if(count==0 || count==2) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tvector<int> freq(7, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tfreq[t % 10]++;\n\t\t\tfreq[t / 10]++;\n\t\t}\n\t\tint numOdd = 0;\n\t\tfor (int i = 0; i <= 6; i++) {\n\t\t\tif (freq[i] % 2 == 1) numOdd++;\n\t\t}\n\t\tcout << (numOdd == 0 || numOdd == 2 ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nint a[7][7];\nint b[7];\nint F(int x)\n{\n\tint f[7]={0},i,j,y;\n\tstd::queue<int>q;\n\tq.push(x);\n\twhile(!q.empty())\n\t{\n\t\tx=q.front();q.pop();\n\t\tif(f[x]++)continue;\n\t\tfor(i=0;i<7;++i)if(a[i][x])q.push(i);\n\t}\n\tfor(i=0;i<7;++i)if(b[i]&&!f[i])return 0;\n\tfor(x=i=0;i<7;++i)\n\t{\n\t\tfor(y=j=0;j<7;++j)y+=a[i][j];\n\t\tif(y&1)++x;\n\t}\n\treturn x<3;\n}\nint main()\n{\n\tint n,u,v;\n\twhile(scanf(\"%d\",&n)>0)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(b,0,sizeof(b));\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d\",&u);\n\t\t\tu-=(v=u/10)*10;\n\t\t\t++a[u][v],++a[v][u];\n\t\t\tb[u]=b[v]=1;\n\t\t}\n\t\tputs(F(u)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nint is_ok( int now, PII& a )\n{\n\tif ( a.first == now ) return 0;\n\telse if ( a.second == now ) return 1;\n\treturn -1;\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tint n; cin >> n;\n\t\tif ( cin.eof() ) break;\n\n\t\tVPII dominoes( n );\n\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tchar left, right; cin >> left >> right;\n\t\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\t\tdominoes[i] = make_pair( l, r );\n\t\t}\n\t\tif ( cin.eof() ) break;\n\n\t\tbool ok = false;\n\t\tfor ( int k = 0; k < n; k++ )\n\t\t{\n\t\t\tfor ( int turn = 0; turn < 2; turn++ )\n\t\t\t{\n\t\t\t\tbool cannot = false;\n\t\t\t\tVI visited(n,0);\n\t\t\t\tint now = turn ? dominoes[k].second : dominoes[k].first;\n\t\t\t\tvisited[k] = 1;\n\n\t\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t\t{\n\t\t\t\t\tbool not_found = true;\n\t\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnow = ( test == 0 ? dominoes[j].second : dominoes[j].first );\n\t\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t\t}\n\t\t\t\tif ( cannot == false ) ok = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( ok ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <set>\nusing namespace std;\n\ntypedef vector <bool> VB;\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nVPII dominoes;\nint n;\nVB visited;\nint now;\nint visited_count;\n\nbool is_match( PII domino )\n{\n\tif ( now == domino.first ) return true;\n\telse if ( now == domino.second ) return true;\n\telse return false;\n}\n\nint get_next( PII domino )\n{\n\tif ( now == domino.first ) return domino.second;\n\telse if ( now == domino.second ) return domino.first;\n\telse return -1;\n}\n\nbool search()\n{\n\tif ( visited_count == n - 1 ) return true;\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tif ( visited[i] ) continue;\n\t\tif ( is_match( dominoes[i] ) )\n\t\t{\n\t\t\tint backup = now;\n\t\t\tnow = get_next( dominoes[i] );\n\t\t\tvisited[i] = true;\n\t\t\tvisited_count++;\n\t\t\tif ( search() ) return true;\n\t\t\tvisited_count--;\n\t\t\tvisited[i] = false;\n\t\t\tnow = backup;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool solve()\n{\n\tvisited = VB( n, false );\n\tvisited_count = 0;\n\n\t// ツ全ツづづ個ドツミツノツづ可づつつ「ツづ篠篠つキ\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\t// for ( int j = 0; j < 2; j++ )\n\t\t// {\n\t\t\t// now = ( j ? dominoes[i].first : dominoes[i].second );\n\t\t\tnow = dominoes[i].second;\n\t\t\tvisited[i] = true;\n\t\t\tif ( search() ) return true; // ツつキツづ猟づづ個ドツミツノツづーツ配ツ置ツづつォツづゥツつゥ\n\t\t\tvisited[i] = false;\n\t\t// }\n\t}\n\treturn false;\n}\n\nvoid input_dominoes( int n )\n{\n\tdominoes = VPII( n );\n\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tchar left, right; cin >> left >> right;\n\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\tdominoes[i] = make_pair( l, r );\n\t}\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tcin >> n;\n\t\tif ( cin.eof() ) break;\n\t\tinput_dominoes( n );\n\n\t\tbool result = solve();\n\t\tif ( result ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n,m[7],s[7];\nchar c,cc;\n\nint main(){\n\twhile(cin>>n){\n\t\tfill(m,m+7,0);\n\t\tfill(s,s+7,0);\n\t\tint nn=n;\n\t\twhile(nn--){\n\t\t\tcin>>c>>cc;\n\t\t\tif(c!=cc){m[c-'0']++;m[cc-'0']++;}\n\t\t\telse s[c-'0']++;\n\t\t}\n\t\tif(n==1){cout<<\"Yes\"<<endl;continue;}\n\t\tint od=0,f=1;\n\t\tfor(int i=0;i<7;i++)if(m[i]%2)od++;\n\t\tif(od>2){cout<<\"No\"<<endl;continue;}\n\t\tfor(int i=0;i<7;i++)if(s[i]&&!m[i]){cout<<\"No\"<<endl;f=0;break;}\n\t\tif(f)cout<<\"Yes\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint N;\n\twhile (cin >> N, N!=0) {\n\t\tint edge[7];\n\t\tint n = N;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tedge[i] = 0;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tchar tmp[3];\n\t\t\tcin >> tmp;\n\t\t\tif (tmp[0]==tmp[1]) { N--;  continue; }\n\t\t\tedge[(int) tmp[0] - '0']++;\n\t\t\tedge[(int) tmp[1] - '0']++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (edge[i]%2==1) cnt++;\n\t\tcout << (cnt==2 ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nint is_ok( int now, PII& a )\n{\n\tif ( a.first == now ) return a.second;\n\telse if ( a.second == now ) return a.first;\n\treturn -1;\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tint n; cin >> n;\n\t\tif ( cin.eof() ) break;\n\n\t\tVPII dominoes( n );\n\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tchar left, right; cin >> left >> right;\n\t\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\t\tdominoes[i] = make_pair( l, r );\n\t\t}\n\t\tif ( cin.eof() ) break;\n\n\t\tbool clear = true;\n\t\tfor ( int k = 0; k < n; k++ )\n\t\t{\n\t\t\tbool ok = false;\n\t\t\tfor ( int turn = 0; turn < 2; turn++ )\n\t\t\t{\n\t\t\t\tbool cannot = false;\n\t\t\t\tVI visited(n,0);\n\t\t\t\tint now = turn ? dominoes[k].second : dominoes[k].first;\n\t\t\t\tvisited[k] = 1;\n\n\t\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t\t{\n\t\t\t\t\tbool not_found = true;\n\t\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnow = test;\n\t\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t\t}\n\t\t\t\tif ( cannot == false ) ok = true;\n\t\t\t}\n\t\t\tif ( ok == false ) clear = false;\n\t\t}\n\n\t\tif ( clear ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#include <bitset>\nint n;\nvs d;\nbitset<1<<28 > visited;\n\nbool dfs(int used,int cnt,char l,char r){\n\tif(cnt==n){\n\t\treturn true;\n\t}\n\tif(visited[used]){\n\t\treturn false;\n\t}\n\tvisited[used]=true;\n\tREP(i,n){\n\t\tif(!(used&(1<<i))){\n\t\t\tREP(edge,2){\n\t\t\t\tREP(dir,2){\n\t\t\t\t\tif(edge==0){\n\t\t\t\t\t\tif(d[i][dir]==l){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,d[i][(dir+1)%2],r)){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(d[i][dir]==r){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,l,d[i][(dir+1)%2])){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>n,cin){\n\t\td.clear();\n\t\tvisited.reset();\n\t\tREP(i,n){\n\t\t\tstring dd;\n\t\t\tcin>>dd;\n\t\t\td.push_back(dd);\n\t\t}\n\t\tbool ok=false;\n\t\tREP(i,n){\n\t\t\tif(dfs((1<<i),1,d[i][0],d[i][1])){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,d[30][2]; bool u[30];\nbool dfs(int prev){\n\trep(i,n)if(!u[i]&&(d[i][0]==prev||d[i][1]==prev)){\n\t\tu[i]=1; bool f=1;\n\t\trep(j,n)if(!u[j])f=0;\n\t\tf=f||dfs(d[i][0]==prev?d[i][1]:d[i][0]);\n\t\tu[i]=0;\n\t\tif(f)return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>n){\n\t\tchar b[9];\n\t\trep(i,n)cin>>b,d[i][0]=b[0]-'0',d[i][1]=b[1]-'0',u[i]=0;\n\t\tbool f=0;\n\t\trep(i,n)rep(j,2){\n\t\t\tu[i]=1;\n\t\t\tif(!f&&dfs(d[i][j]))f=1;\n\t\t\tu[i]=0;\n\t\t}\n\t\tcout<<(f?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi field;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nbool dfs(int x,int y,int a){\n\tif(a==0){\n\t\treturn true;\n\t}\n\tfield[x][y]=0;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=7||ny>=7||field[nx][ny]==0)continue;\n\t\tif(dfs(nx,ny,a-1))return true;\n\t}\n\tfield[x][y]=1;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tfield=vvi(7,vi(7));\n\t\trep(i,n){\n\t\t\tint a;cin>>a;\n\t\t\tfield[a/10][a%10]=1;\n\t\t}\n\t\tbool h=false;\n\t\trep(i,7)rep(j,7)if(field[i][j]&&dfs(i,j,n-1)){\n\t\t\th=true;\n\t\t\tgoto end;\n\t\t}\n\t\tend:;\n\t\tif(h)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\nint index(char c){\n\treturn (int)c - '0';\n}\n\nint get_num(string s){\n\tint count = 0;\n\tcount += index(s[0]) * 10;\n\tcount += index(s[1]);\n\treturn count;\n}\nint main(){\n\tint n;\n\twhile(cin >> n){\n\t\tmap<int, int> mp;\n\t\tint u[] = {\n\t\t\t1,1,1,1,1,1,1\n\t\t};\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstring num;\n\t\t\tcin >> num;\n\t\t\tint a = get_num(num);\n\t\t\tif(a / 10 == a % 10){\n\t\t\t\tu[a / 10] = 0;\n\t\t\t}else{\n\t\t\t\tmp[a / 10]++;\n\t\t\t\tmp[a % 10]++;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(mp[i] % 2 == 1) count++;\n\t\t\tif(u[i] == 0 && mp[i] == 0) count += 2;\n\t\t}\n\t\tif(count > 2) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\nvector<int> d[10001];\nbool passed[10001];\n\nvoid dfs(int s){\n\tif(passed[s])\n\t\treturn;\n\tpassed[s]=true;\n\tfor(int i = 0; i < d[s].size(); i++){\n\t\tint to=d[s][i];\n\t\tdfs(to);\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n){\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\td[i].clear();\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tint cnt[10001];\n\t\tfill(cnt,cnt+10001,0);\n\t\tvector<pii> v;\n\t\tint ss;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpii p;\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tp.first=str[0]-'0';\n\t\t\tp.second=str[1]-'0';\n\t\t\tv.push_back(p);\n\t\t\tcnt[p.first]++;\n\t\t\tcnt[p.second]++;\n\t\t\tss=p.first;\n\t\t\td[p.first].push_back(p.second);\n\t\t\td[p.second].push_back(p.first);\n\t\t}\n\n\t\tdfs(ss);\n\t\tbool f=false;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(cnt[i]==0||passed[i])\n\t\t\t\tcontinue;\n\t\t\telse{\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint cc=0;\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif(cnt[i]%2!=0){\n\t\t\t\tcc++;\n\t\t\t}\n\t\t}\n\t\tif(cc==2){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse if(cc==0)\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nint count,t1;\n\nint adjMatrix[10][10];\nbool visited[10],vi[10];\n\n\nvoid visit(int u){\n  visited[u] = true;\n \n  for(int v=0; v<10; v++){\n    if(!adjMatrix[u][v]) continue;\n    if(!visited[v]) visit(v);\n  }\n\n}\n\n\nint  dfs(){\n  for(int i=0; i<10; i++)  visited[i] = false;\n  \n  visit(t1);\n  for(int i=0;i<10;i++){\n    if(vi[i] == true && visited[i] == false) return 0;\n  }\n  return 1;\n}\n\n\n\n\nint main(){\n\n  int n,a,i,j,table[11],frag,f,ans;\n\n  while(cin >> n){\n    for(i=0 ; i<11; i++)  table[i] = 0;\n\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++) adjMatrix[i][j] = 0;\n    }\n\n  for(i=0; i<n; i++){\n    cin >> a;\n    t1  = a / 10;\n    table[t1]++;\n    a   = a - t1*10;\n    table[a]++;\n    adjMatrix[t1][a] = adjMatrix[a][t1] = 1;\n    vi[a] = vi[t1] = true;\n\n  }\n\n  frag = 0;\n  for(i=0; i<11; i++){\n    if(table[i]%2 != 0) frag++;\n  }\n \n  if(dfs() == 1 && frag == 2) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\t/*if(N == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n*/\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i]%2 == 1)num_KI++;\n\t\t}\n\n\t\tif(num_KI != 0 && num_KI != 2){ //??????????????°?????????????????????????????¶\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] != 0){\n\t\t\t\tif(boss[i] == get_boss(i))num_boss++;\n\t\t\t}\n\t\t}\n\n\t\tif(num_boss > 1){ //2??°???????????\\????????£????????????\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Yes\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int n;\n    while(cin>>n)\n    {\n        vector<int> one(7,0),two(7,0);\n        for(int c=0;c<n;c++)\n        {\n            int z;\n            cin>>z;\n            int g=z%10,d=z/10;\n            if(g==d) two[g]++;\n            else\n            {\n                one[g]++;\n                one[d]++;\n            }\n        }\n        int alone = 0;\n        for(int c=0;c<7;c++)\n        {\n            if(two[c] && !one[c] && n > 1)\n            {\n                cout<<\"No\"<<endl;\n                goto end;\n            }\n            if(one[c]&1) alone++;\n        }\n        cout<<(alone<=2?\"Yes\":\"No\")<<endl;\n        end:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 6 && col >= 0 && col <= 6)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint N,tmp_row,tmp_col,tmp;\n\tchar buf[3];\n\tbool table[7][7];\n\n\tstack<int> S;\n\n\tint num_GU,num_KI,num_ZERO;\n\tint adj_row,adj_col;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tfor(int row = 0; row <= 6; row++){\n\t\t\tfor(int col = 0; col <=6; col++)table[row][col] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ttmp_row = buf[0]-'0';\n\t\t\ttmp_col = buf[1]-'0';\n\t\t\ttable[tmp_row][tmp_col] = true;\n\t\t}\n\n\t\tif(N == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_GU = num_KI = num_ZERO = 0;\n\n\t\tfor(int row = 0; row <= 6; row++){\n\t\t\tfor(int col = 0; col <= 6; col++){\n\t\t\t\tif(table[row][col]){\n\t\t\t\t\ttmp = 0;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tadj_row = row + diff_row[i];\n\t\t\t\t\t\tadj_col = col + diff_col[i];\n\n\t\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\t\tif(table[adj_row][adj_col])\ttmp++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmp == 0){\n\t\t\t\t\t\tnum_ZERO++;\n\t\t\t\t\t}else if(tmp%2 == 0){\n\t\t\t\t\t\tnum_GU++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnum_KI++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(num_ZERO > 0){\n\t\t\tprintf(\"No\\n\");\n\t\t}else{\n\t\t\tif(num_KI == 0 || num_KI == 2){\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\nint dp[1 << 18][10];\nint main() {\n  int N;\n  while(cin >> N) {\n    vector< pair<int, int> > dominoes(N);\n    for(int i=0; i<N; i++) {\n      int val; cin >> val;\n      int A = val / 10, B = val % 10;\n      dominoes[i] = make_pair(A, B);\n    }\n\n    fill(dp[0], dp[1 << N], false);\n    dp[0][0] = true;\n    for(int bit=0; bit<(1<<N); bit++) {\n      for(int pre=0; pre<10; pre++) {\n        if(dp[bit][pre] == false) continue;\n        for(int i=0; i<N; i++) {\n          if(bit >> i & 1) continue;\n\n          for(int k=0; k<2; k++) {\n            if(bit != 0 and pre != dominoes[i].first) {\n              swap(dominoes[i].first, dominoes[i].second);\n              continue;\n            }\n\n            int nbit = bit | (1 << i);\n            int npre = dominoes[i].second;\n            dp[nbit][npre] |= dp[bit][pre];\n            swap(dominoes[i].first, dominoes[i].second);\n          }\n        }\n      }\n    }\n\n    /*\n    for(int bit=0; bit<(1<<N); bit++) {\n      bool ok = false;\n      for(int pre=0; pre<10; pre++) {\n        ok |= dp[bit][pre];\n      }\n      if(ok) {\n        cout << bitset<10>(bit).to_string();\n        cout << \":\";\n        for(int pre=0; pre<10; pre++) {\n          if(dp[bit][pre]) cout << \" \" << pre;\n        }\n        cout << endl;\n      }\n    }\n    */\n\n    bool ans = false;\n    for(int i=0; i<10; i++) ans |= dp[(1<<N)-1][i];\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//51\n#include<iostream>\n\nusing namespace std;\n\nint p[28];\nint n;\n\nbool dfs(int pr,int u,int r){\n  if(r==0){\n    return true;\n  }else{\n    for(int i=0;i<n;i++){\n      if(!(u&1<<i)){\n\tfor(int j=0;j<2;j++){\n\t  p[i]=p[i]/10+p[i]%10*10;\n\t  if(pr==p[i]/10){\n\t    if(dfs(p[i]%10,u|1<<i,r-1))return true;\n\t  }\n\t}\n      }\n    }\n    return false;\n  }\n}\n\nint main(){\n  while(cin>>n){\n    for(int i=0;i<n;i++){\n      cin>>p[i];\n    }\n    for(int i=0;i<n;i++){\n      if(dfs(p[i]%10,1<<i,n-1)||dfs(p[i]/10,1<<i,n-1)){\n\tcout<<\"Yes\"<<endl;\n\tgoto next;\n      }\n    }\n    cout<<\"No\"<<endl;\n  next:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n};\n\nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",(same_check && travel_check) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        int N;\n        while(cin >> N){\n                vector<pii> p(N);\n                bool found[10] = { false };\n                for(int i = 0; i < N; ++i){\n                        int x;\n                        cin >> x;\n                        p[i] = pii(x / 10, x % 10);\n                        found[p[i].first] = found[p[i].second] = true;\n                }\n                bool answer = false;\n                vector<int> dp(1 << N);\n                for(int begin = 0; !answer && begin < 10; ++begin){\n                        if(!found[begin]){ continue; }\n                        fill(dp.begin(), dp.end(), 0);\n                        dp[0] |= (1 << begin);\n                        for(int i = 0; i < (1 << N); ++i){\n                                for(int j = 0; j < 10; ++j){\n                                        if(!(dp[i] & (1 << j))){ continue; }\n                                        for(int k = 0; k < N; ++k){\n                                                if(i & (1 << k)){ continue; }\n                                                int m = i | (1 << k);\n                                                if(p[k].first == j){ dp[m] |= (1 << p[k].second); }\n                                                if(p[k].second == j){ dp[m] |= (1 << p[k].first); }\n                                        }\n                                }\n                        }\n                        if(dp[(1 << N) - 1]){ answer = true; }\n                }\n                cout << (answer ? \"Yes\" : \"No\") << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#define MAX 30\nusing namespace std;\nstruct domino{\n  int a,b;\n  domino():a(0),b(0){}\n  domino(int t):a(t/10),b(t%10){}\n  void swap(){std::swap(a,b);}\n};\nbool dfs(list<domino> now, domino ds[], bool vis[], int n, int num){\n  if( num == n ){\n    /*\nfor(list<domino>::iterator itl = now.begin();\n\titl != now.end(); ++itl){\n      cout << '[' << itl->a << ',' << itl->b << \"] \";\n    }\n    cout << endl;\n    */\n    return true;\n  }\n  \n  for(int i = 0; i < n; ++i){\n    if( !vis[i] ){\n      domino t = ds[i];\n\n      if( t.b == now.front().a ){\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n      }else if( t.a == now.front().a ){\n\tt.swap();\n\tnow.push_front( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_front();\n      }else if( t.b == now.back().b ){\n\tt.swap();\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }else if( t.a == now.back().b ){\n\tnow.push_back( t );\n\tvis[i] = true;\n\tif( dfs( now, ds, vis, n, num+1 ) ) return true;\n\tvis[i] = false;\n\tnow.pop_back();\n      }\n      \n    }\n  }\n\n  return false;\n}\nint main()\n{\n  while(true){\n    int n;\n    cin >> n;\n    if(cin.eof())break;\n    bool vis[MAX]={false,};\n    list<domino> init;\n    domino ds[n];\n    for(int i = 0; i < n; ++i){\n      int t;cin>>t;\n      ds[i] = domino(t);\n    }\n    init.push_back(ds[0]);\n    vis[0]=true;\n    if( dfs( init, ds, vis, n, 1 ) ){\n      puts(\"Yes\");\n    }else{\n      puts(\"No\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a;\nint t[7],u[2];\n\nbool v[7][7];\nbool ud[7],vd[7];\n\nvoid dfs(int pos){\n  if(vd[pos]==true)return;\n  vd[pos]=true;\n  for(int i=0;i<7;i++){\n    if(v[pos][i]==false)continue;\n    dfs(i);\n  }\n}\n\nbool check(){\n  for(int i=0;i<7;i++)vd[i]=false;\n  for(int i=0;i<7;i++)if(t[i]>0)dfs(i);\n  for(int i=0;i<7;i++){\n    if(t[i]>0&&vd[i]==false)return false;\n  }\n  return true;\n}\n\nint main(){\n  while(cin>>n){\n    for(int i=0;i<7;i++)t[i]=0;\n    for(int i=0;i<7;i++)for(int j=0;j<7;j++)v[i][j]=false;\n\n    u[0]=u[1]=0;\n    for(int i=0;i<n;i++){\n      cin>>a;\n      t[a/10]++;\n      t[a%10]++;\n      v[a/10][a%10]=v[a%10][a/10]=true;\n    }\n\n    for(int i=0;i<7;i++)if(t[i]>0)u[t[i]%2]++;    \n    \n    if((u[1]==2)&&check())cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\nvector<int> d[10001];\nbool passed[10001];\n\nvoid dfs(int s){\n\tif(passed[s])\n\t\treturn;\n\tpassed[s]=true;\n\tfor(int i = 0; i < d[s].size(); i++){\n\t\tint to=d[s][i];\n\t\tdfs(to);\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(cin>>n){\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\td[i].clear();\n\t\t\tpassed[i]=false;\n\t\t}\n\t\tint cnt[10001];\n\t\tfill(cnt,cnt+10001,0);\n\t\tvector<pii> v;\n\t\tint ss;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpii p;\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tp.first=str[0]-'0';\n\t\t\tp.second=str[1]-'0';\n\t\t\tv.push_back(p);\n\t\t\tcnt[p.first]++;\n\t\t\tcnt[p.second]++;\n\t\t\tss=p.first;\n\t\t\td[p.first].push_back(p.second);\n\t\t\td[p.second].push_back(p.first);\n\t\t}\n\n\t\tdfs(ss);\n\t\tbool f=false;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(cnt[i]==0||passed[i])\n\t\t\t\tcontinue;\n\t\t\telse{\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\tif(f){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint cc=0;\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tif(cnt[i]%2!=0){\n\t\t\t\tcc++;\n\t\t\t}\n\t\t}\n\t\tif(cc==2){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t}\n\t\telse if(cc==0)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nbool V[7];\nbool A[7][7];\nbool visited[7];\nint dfs(int v)\n{\n  int a = 0;\n  for (int j=0;j<7;j++)\n  {\n    if (A[v][j] && !visited[j] && (v != j))\n    {\n      visited[j] = true;\n      a += dfs(j);\n    }\n  }\n  return a + 1;\n}\n\nint main()\n{\n  int degree[7];\n  int n;\n  while (cin >> n)\n  {\n    for (int i=0;i<7;i++)\n    {\n      V[i] = false;\n      degree[i] = 0;\n      for (int j=0;j<7;j++) A[i][j] = false;\n    }\n    for (int i=0;i<n;i++)\n    {\n      int m, x, y;\n      cin >> m;\n      x = m / 10; y = m % 10;\n      V[x] = V[y] = true;\n      A[x][y] = A[y][x] = true;\n      degree[x]++;\n      degree[y]++;\n    }\n    int od = 0;\n    for (int i=0;i<7;i++) if (degree[i]%2) od++;\n    if (od > 2) cout << \"No\" << endl;\n    else\n    {\n      int order = 0;\n      int start = 0;\n      for (int i=0;i<7;i++)\n      {\n        visited[i]=false;\n        if (V[i]) { order++; start=i; }\n      }\n      visited[start] = true;\n      if (order == dfs(start)) cout << \"Yes\" << endl;\n      else cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tif(N == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i]%2 == 1)num_KI++;\n\t\t}\n\n\t\tif(num_KI != 0 && num_KI != 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] != 0){\n\t\t\t\tif(boss[i] == get_boss(i))num_boss++;\n\t\t\t}\n\t\t}\n\n\t\tif(num_boss > 1){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Yes\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstring A[20];\n\nint n;\nbool used[1<<18][10][10],mem[1<<18][10][10];\nbool dfs(int bit,int l,int r){\n  if(bit == (1<<n)-1) return 1;\n  if(used[bit][l][r])return mem[bit][l][r];\n  used[bit][l][r] = 1;\n  \n  bool res = 0;\n  for(int i=0;i<n;i++){\n    if(bit>>i&1) continue;\n    int nbit = bit | (1<<i);\n    \n    if(l == A[i][0]-'0') res |= dfs(nbit,A[i][1]-'0',r);\n    if(l == A[i][1]-'0') res |= dfs(nbit,A[i][0]-'0',r);\n    if(r == A[i][0]-'0') res |= dfs(nbit,l,A[i][1]-'0');\n    if(r == A[i][1]-'0') res |= dfs(nbit,l,A[i][0]-'0');\n    if(res) break;\n  }\n  return mem[bit][l][r] = res; \n}\n\nsigned main(){\n\n  while(cin>>n){\n    for(int i=0;i<n;i++) cin>>A[i];\n    memset(used,0,sizeof(used));\n    memset(mem,0,sizeof(mem));\n    bool ans = dfs(1,A[0][0]-'0',A[0][1]-'0');\n    cout<<(ans? \"Yes\":\"No\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvvi field;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nbool dfs(int x,int y,int a){\n\tif(a==0){\n\t\treturn true;\n\t}\n\tfield[x][y]=0;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=7||ny>=7||field[nx][ny]==0)continue;\n\t\tif(dfs(nx,ny,a-1))return true;\n\t}\n\tfield[x][y]=1;\n\treturn false;\n}\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tfield=vvi(7,vi(7));\n\t\trep(i,n){\n\t\t\tint q;cin>>q;\n\t\t\tint a=q/10,b=q%10;\n\t\t\tif(a>b)swap(a,b);\n\t\t\tfield[a][b]=1;\n\t\t}\n\t\tbool h=false;\n\t\trep(i,7)rep(j,7)if(field[i][j]&&dfs(i,j,n-1)){\n\t\t\th=true;\n\t\t\tgoto end;\n\t\t}\n\t\tend:;\n\t\tif(h)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nconst int max=7;\nint con[max][max];\nint n;\nbool allMoveOK;\n\nvoid saiki(int now,int deep){\nif(deep==n){\n\tallMoveOK=true;\n\treturn;\n}\nfor(int i=0;i<max;i++){\n\tif(con[now][i]>0){\n\t\tcon[now][i]--;\n\t\tcon[i][now]--;\n\t\tsaiki(i,deep+1);\n\t\tif(allMoveOK==true) return;\n\t\tcon[now][i]++;\n\t\tcon[i][now]++;\n\t}\n}\n}\nvoid setData(){\nchar in[3];\nmemset(con,0,sizeof(con));\nallMoveOK=false;\t\nfor(int i=0;i<n;i++){\n\tscanf(\"%s\",in);\n\tin[0]-='0';\n\tin[1]-='0';\n\tcon[in[0]][in[1]]++;\n\tcon[in[1]][in[0]]++;\n}\nfor(int i=0;i<max;i++){\n\tsaiki(i,0);\n\tif(allMoveOK==true)break;\n}\nprintf(\"%s\\n\",allMoveOK?\"Yes\":\"No\");\n}\nint main(){\nwhile(scanf(\"%d\",&n)!=EOF){\n\tsetData();\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint N;\n\twhile (cin >> N) {\n\t\tif (N==0) break;\n\t\tint edge[7];\n\t\tfor (int i=0; i<7; i++)\n\t\t\tedge[i] = 0;\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tchar tmp[3];\n\t\t\tcin >> tmp;\n\t\t\tif (tmp[0]==tmp[1]) continue;\n\t\t\tedge[(int)tmp[0]-'0']++;\n\t\t\tedge[(int)tmp[1]-'0']++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (edge[i]%2==1) cnt++;\n\t\tif (cnt==0 || cnt==2)\n\t\t\tcout << \"Yes\\n\";\n\t\telse \n\t\t\tcout << \"No\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint path[7];\n\nvoid solve(){\n  int odd = 0;\n\n  for(int i = 0; i < 7; i++){\n    if(path[i]%2) odd++;\n  }\n  cout << (odd==2 || odd==0?\"Yes\":\"No\") << endl;\n}\n\nint main(){\n  \n  int N;\n  while(cin >> N){\n    fill(path,path+7,0);\n    while(N--){\n      int in;\n      cin >> in;\n      path[in/10]++;\n      path[in%10]++;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 6 && col >= 0 && col <= 6)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint N,tmp_row,tmp_col,tmp;\n\tchar buf[3];\n\tbool table[7][7];\n\n\tstack<int> S;\n\n\tint num_GU,num_KI,num_ZERO;\n\tint adj_row,adj_col;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tfor(int row = 0; row <= 6; row++){\n\t\t\tfor(int col = 0; col <=6; col++)table[row][col] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ttmp_row = buf[0]-'0';\n\t\t\ttmp_col = buf[1]-'0';\n\t\t\ttable[tmp_row][tmp_col] = true;\n\t\t}\n\n\t\t/*for(int row = 0; row <= 6; row++){\n\t\t\t\t\tfor(int col = 0; col <=6; col++){\n\t\t\t\t\t\tif(table[row][col]){\n\t\t\t\t\t\t\tprintf(\"*\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tprintf(\".\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}*/\n\n\t\tif(N == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//??????????????£??\\???????????????????????????????????°?????°??????\n\t\tnum_GU = num_KI = num_ZERO = 0;\n\n\t\tfor(int row = 0; row <= 6; row++){\n\t\t\tfor(int col = 0; col <= 6; col++){\n\t\t\t\tif(table[row][col]){\n\t\t\t\t\ttmp = 0;\n\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tadj_row = row + diff_row[i];\n\t\t\t\t\t\tadj_col = col + diff_col[i];\n\n\t\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\t\tif(table[adj_row][adj_col])\ttmp++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmp == 0){\n\t\t\t\t\t\tnum_ZERO++;\n\t\t\t\t\t}else if(tmp%2 == 0){\n\t\t\t\t\t\tnum_GU++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnum_KI++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(num_ZERO > 0){ //N???2??\\?????§?????????????????????????????£????????????\n\t\t\tprintf(\"No\\n\");\n\t\t}else{\n\t\t\tif(num_KI < 2){ //???????????????????????????????????¶\n\t\t\t\tprintf(\"Yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n) {\n    int map[7][7];\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tmap[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      int temp;\n      cin >> temp;\n      int a, b;\n      a = temp / 10;\n      b = temp % 10;\n      if(a > b) {\n\ttemp = a;\n\ta = b;\n\tb = temp;\n      }\n      map[b][a] = 1;\n    }\n\n    int kisu = 0;\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n    for(int i = 0; i < 7; i++) {\n      for(int j = 0; j < 7; j++) {\n\tif(map[i][j] == 0) continue;\n\tint count = 0;\n\tfor(int k = 0; k < 4; k++) {\n\t  int nx = j + d[k][0];\n\t  int ny = i + d[k][1];\n\t  if(nx < 0) continue;\n\t  if(nx >= 7) continue;\n\t  if(ny < 0) continue;\n\t  if(ny >= 7) continue;\n\n\t  if(map[ny][nx] == 1) count++;\n\t}\n\tif(count % 2 != 0) kisu++;\n      }\n    }\n    if(kisu == 2) cout << \"Yes\" << endl;\n    else          cout << \"No\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, cnt[7], in;\nbool d[7];\n\nmain(){\n  while(cin >> n){\n    for(int i=0;i<7;i++) cnt[i] = d[i] = 0;\n    for(int i=0;i<n;i++){\n      cin >> in;\n      if(in/10 == in%10) d[in/10] = true;\n      else{\n        cnt[in/10]++;\n        cnt[in%10]++;\n      }\n    }\n    bool f = true;\n    int t = 0;\n    for(int i=0;i<7;i++){\n      if(d[i] && !cnt[i] && n > 1) f = false;\n      if(cnt[i]&1) t++;\n    }\n    if(t > 2) f = false;\n    cout << (f ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <new>\n#include <cmath>\n#include <climits>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\n#define REP(i, n) for(i = 0; i < n; i++)\n#define sz(n) n.size()\n#define pb(n) push_back(n)\n#define FOR(i, a, n) for(i = (a); i < (n); i++)\n#define FORR(i, a, n) for(i = (a); i <= (n); i++)\n\nusing namespace std;\n\nint i, j, n;\n\nbool match_begin(string& novo, string b) {\n    if(b[0] == novo[1]) {\n        return true;\n    } else if(b[0] == novo[0]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool match_end(string novo, string b) {\n    if(b[1] == novo[0]) {\n        return true;\n    } else if(b[1] == novo[1]) {\n        reverse(novo.begin(), novo.end());\n        return true;\n    } else {\n        return false;\n    }\n}\n\nstring valid(vector<string> s) {\n    int N = s.size();\n    bool memo[N];\n    memset(memo, 0, sizeof(memo));\n\n    deque<string> ss;\n\n    ss.push_back(s[0]);\n    memo[0] = true;\n\n    REP(i, N) {\n        REP(j, n) {\n            if(!memo[j] && match_begin(s[j], ss[0])) {\n                ss.push_front(s[j]);\n                memo[j] = true;\n            } else if(!memo[j] && match_end(s[j], ss[ss.size() - 1])) {\n                ss.push_back(s[j]);\n                memo[j] = true;\n            }\n        }\n    }\n    bool ok = true;\n    REP(i, N) {\n        if(!memo[i] ) ok = false;\n    }\n    if(ok) return \"Yes\";\n    return \"No\";\n}\n\nint main(void) {\n    while(~scanf(\"%d\", &n)) {\n        vector<string> v(n);\n        REP(i, n) {\n            cin >> v[i];\n        }\n        cout << valid(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef pair <int,int> PII;\ntypedef vector <PII> VPII;\n\nint is_ok( int now, PII& a )\n{\n\tif ( a.first == now ) return 0;\n\telse if ( a.second == now ) return 1;\n\treturn -1;\n}\n\nint main( void )\n{\n\twhile ( cin.eof() == false )\n\t{\n\t\tint n; cin >> n;\n\t\tif ( cin.eof() ) break;\n\n\t\tVPII dominoes( n );\n\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tchar left, right; cin >> left >> right;\n\t\t\tint l = (int)(left - '0'), r = (int)(right - '0');\n\t\t\tdominoes[i] = make_pair( l, r );\n\t\t}\n\t\tif ( cin.eof() ) break;\n\n\t\tbool ok = false;\n\t\tif ( ok == false ){\n\t\t\tbool cannot = false;\n\t\t\tVI visited(n,0);\n\t\t\tint now = dominoes[0].first;\n\t\t\tvisited[0] = 1;\n\n\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t{\n\t\t\t\tbool not_found = true;\n\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tnow = ( test == 0 ? dominoes[j].second : dominoes[j].first );\n\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t}\n\n\t\t\tif ( cannot == false ) ok = true;\n\t\t}\n\t\tif ( ok == false ){\n\t\t\tbool cannot = false;\n\t\t\tVI visited(n,0);\n\t\t\tint now = dominoes[0].second;\n\t\t\tvisited[0] = 1;\n\n\t\t\tfor ( int i = 1; cannot == false && i < n; i++ )\n\t\t\t{\n\t\t\t\tbool not_found = true;\n\t\t\t\tfor ( int j = 0; not_found && j < n; j++ )\n\t\t\t\t{\n\t\t\t\t\tif ( visited[j] ) continue;\n\t\t\t\t\tint test = is_ok( now, dominoes[j] );\n\t\t\t\t\tif ( test != -1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tnow = ( test == 0 ? dominoes[j].second : dominoes[j].first );\n\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t\tnot_found = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( not_found ) cannot = true;\n\t\t\t}\n\t\t\tif ( cannot == false ) ok = true;\n\t\t}\n\n\t\tif ( ok ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t\t/*\n\t\t// check\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tPII& domino = dominoes[i];\n\t\t\tcout << domino.first << \"-\" << domino.second << \" \";\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[7],height[7];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < 7; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint main(){\n\n\tint array[7],num,num_KI,num_boss;\n\n\tchar buf[3];\n\tint a,b;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\n\t\tinit();\n\t\tfor(int i = 0; i < 7; i++)array[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%s\",buf);\n\t\t\ta = buf[0] - '0';\n\t\t\tb = buf[1] - '0';\n\t\t\tarray[a]++;\n\t\t\tarray[b]++;\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tif(N == 1){\n\t\t\tprintf(\"Yes\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_KI = 0;\n\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i]%2 == 1)num_KI++;\n\t\t}\n\n\t\tif(num_KI != 0 && num_KI != 2){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_boss = 0;\n\t\tfor(int i = 0; i < 7; i++){\n\t\t\tif(array[i] != 0){\n\t\t\t\tif(boss[i] == get_boss[i])num_boss++;\n\t\t\t}\n\t\t}\n\n\t\tif(num_boss > 1){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Yes\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int INF = 1000000000;\n\nint main(){\n        ios_base::sync_with_stdio(false);\n        int N;\n        while(cin >> N){\n                vector<pii> p(N);\n                for(int i = 0; i < N; ++i){\n                        int x;\n                        cin >> x;\n                        p[i] = pii(x / 10, x % 10);\n                }\n                int begin = p[0].first;\n                vector< vector<bool> > dp(1 << N, vector<bool>(10));\n                dp[0][begin] = true;\n                for(int i = 0; i < (1 << N); ++i){\n                        for(int j = 0; j < 10; ++j){\n                                if(!dp[i][j]){ continue; }\n                                for(int k = 0; k < N; ++k){\n                                        if(i & (1 << k)){ continue; }\n                                        int m = i | (1 << k);\n                                        if(p[k].first == j){ dp[m][p[k].second] = true; }\n                                        if(p[k].second == j){ dp[m][p[k].first] = true; }\n                                }\n                        }\n                }\n                bool answer = false;\n                for(int i = 0; i < 10; ++i){\n                        if(dp[(1 << N) - 1][i]){ answer = true; }\n                }\n                cout << (answer ? \"Yes\" : \"No\") << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nbool solve(vector<int> args,int a,int b){\n\tif(args.size()==0)return true;\n\tbool state = false;\n\tfor(int x=0;x<args.size();++x){\n\t\tint i = args[x]/10,j=args[x]%10;\n\t\tvector<int> eg = args;\n\t\teg.erase(eg.begin()+x);\n\t\tif(i==a){\n\t\t\tstate = state || solve(eg,j,b);\n\t\t}else if(i==b){\n\t\t\tstate = state || solve(eg,a,j);\n\t\t}else if(j==a){\n\t\t\tstate = state || solve(eg,i,b);\n\t\t}else if(j==b){\n\t\t\tstate = state || solve(eg,a,i);\n\t\t}\n\t}\n\treturn state;\n}\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)==1){\n\t\tvector<int> args;\n\t\tfor(int x=0;x<n;x++){\n\t\t\tint j;scanf(\"%d\",&j);\n\t\t\targs.push_back(j);\n\t\t}\n\t\tint a = args[0]/10, b = args[0]%10;\n\t\targs.erase(args.begin());\n\t\tif(solve(args,a,b)){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\t\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint n;\nvs d;\nbool visited[1<<28]={};\n\nbool dfs(int used,int cnt,char l,char r){\n\tif(cnt==n){\n\t\treturn true;\n\t}\n\tif(visited[used]){\n\t\treturn false;\n\t}\n\tvisited[used]=true;\n\tREP(i,n){\n\t\tif(!(used&(1<<i))){\n\t\t\tREP(edge,2){\n\t\t\t\tREP(dir,2){\n\t\t\t\t\tif(edge==0){\n\t\t\t\t\t\tif(d[i][dir]==l){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,d[i][(dir+1)%2],r)){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(d[i][dir]==r){\n\t\t\t\t\t\t\tint newUsed=used;\n\t\t\t\t\t\t\tnewUsed|=(1<<i);\n\t\t\t\t\t\t\tif(dfs(newUsed,cnt+1,l,d[i][(dir+1)%2])){\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>n;\n\tREP(i,n){\n\t\tstring dd;\n\t\tcin>>dd;\n\t\td.push_back(dd);\n\t}\n\tbool ok=false;\n\tREP(i,n){\n\t\tif(dfs((1<<i),1,d[i][0],d[i][1])){\n\t\t\tok=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<(ok?\"Yes\":\"No\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Domino {\nprivate:\n  int _head;\n  int _tail;\npublic:\n  Domino(int head, int tail) {\n    _head = head;\n    _tail = tail;\n  }\n\n  int detect_connect_pattern(Domino d) {\n    int res = 0;\n    if(d.get_head() == _head){\n      return (res | (1<<0));\n    }\n    if(d.get_head() == _tail){\n      return (res | (1<<1));\n    }\n    if(d.get_tail() == _head){\n      return (res | (1<<2));\n    }\n    if(d.get_tail() == _tail){\n      return (res | (1<<3));\n    }\n    return res;\n  }\n\n  Domino connect(Domino d,int pattern){\n    if(pattern == (1<<0)){\n      return Domino(d.get_tail(),_tail);\n    }\n    if(pattern == (1<<1)){\n      return Domino(d.get_tail(),_head);\n    }\n    if(pattern == (1<<2)){\n      return Domino(d.get_head(),_tail);\n    }\n    if(pattern == (1<<3)){\n      return Domino(d.get_head(),_head);\n    }\n    return *this;\n  }\n\n  int get_head() const{\n    return _head;\n  }\n\n  int get_tail() const{\n    return _tail;\n  }\n};\n\nbool dp[1<<22];\n\nbool dfs(Domino& current_state,int visited, const vector<Domino>& dominos){\n  if(dp[visited]) return false;\n  if(visited == (1<<dominos.size()) - 1){\n    return true;\n  }\n\n  int res = false;\n  for(int i = 0; i < dominos.size(); i++){\n\n    if(visited & (1<<i)) continue;\n    int pattern;\n    if((pattern = current_state.detect_connect_pattern(dominos[i])) == 0) continue;\n    Domino next = current_state.connect(dominos[i],pattern);\n    res |= dfs(next,visited | (1<<i),dominos);\n    dp[visited | (1<<i)] = true;\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(~scanf(\"%d\",&n)){\n    vector<Domino> dominos;\n    memset(dp,false,sizeof(dp));\n\n    int same_head_tail = 0;\n    for(int i = 0; i < n; i++){\n      char domino[8];\n      scanf(\"%s\",domino);\n      if(domino[0] - '0' == domino[1] - '0'){\n        same_head_tail |= (1 << (domino[1] - '0'));\n        continue;\n      }\n      dominos.push_back(Domino(domino[0] - '0',domino[1] - '0'));\n    }\n\n    bool same_check = true;\n    for(int num = 0; num <= 6; num++){\n      if(same_head_tail & (1 << num)){\n        bool isok = false;\n        for(int i = 0; i < dominos.size(); i++){\n          if(dominos[i].get_tail() == num\n             || dominos[i].get_head() == num){\n            isok = true;\n          }\n        }\n        if(!isok){\n          same_check = false;\n          break;\n        }\n      }\n    }\n\n    bool travel_check = false;\n    travel_check = dfs(dominos[0],(1<<0),dominos);\n    printf(\"%s\\n\",((same_check && travel_check) || (n == 1)) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\n--import qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\nimport System.IO\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\ntoDomino [x,y] = (digitToInt x, digitToInt y)\n\nf ds = length ds == 1 || all ((>0) . (degs!)) loops && (oddcount == 0 || oddcount == 2)\n  where\n    (es, loops) = fmap (map fst) $ partition (uncurry (/=)) ds\n    degs = array (0,6) $ ([(x,0) | x <- [0..6]]++) $ map (fnTuple (head, length)) $ group $ sort $ concat [[x, y] | (x,y) <- es] :: Array Int Int\n    oddcount = length $ filter odd $ elems degs\n\nmain = do\n    eof <- isEOF\n    unless eof $ do\n        n <- getInt\n        ds <- map toDomino . words <$> getLine\n        putStrLn $ cond \"Yes\" \"No\" $ f ds\n        main\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\n--import qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\nimport System.IO\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\ntoDomino [x,y] = (digitToInt x, digitToInt y)\n\nf ds = all ((>0) . (degs!)) loops && (oddcount == 0 || oddcount == 2)\n  where\n    (es, loops) = fmap (map fst) $ partition (uncurry (/=)) ds\n    degs = array (0,6) $ ([(x,0) | x <- [0..6]]++) $ map (fnTuple (head, length)) $ group $ sort $ concat [[x, y] | (x,y) <- es] :: Array Int Int\n    oddcount = length $ filter odd $ elems degs\n\nmain = do\n    eof <- isEOF\n    unless eof $ do\n        n <- getInt\n        ds <- map toDomino . words <$> getLine\n        putStrLn $ cond \"Yes\" \"No\" $ f ds\n        main\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1010\nTitle Domino Arrangement\n*/\n#include <stdio.h>\n#include <setjmp.h>\n\nint domino[28];\nint flag[28];\nint N;\njmp_buf env;\nint State;\n//\nint can_connect(int s1,int n)\n{\n  int i,t1,t2;\n#ifdef DEBUG\n\tprintf(\"(%d)\\n\",n);\n#endif\n  if(n==0)\n    {\n      State=-1;\n      longjmp(env,1);\n    }\n\n  for(i=0;i<28;i++)\n    if(flag[i])\n      {\n\tt1=domino[i] / 10;t2=domino[i] % 10;\n#ifdef DEBUG\n\tprintf(\"t1s1s2=%d %d %d(%d)\\n\",t1,t2,s1,n);\n#endif\n\tif(s1 == -1)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t1,n-1);\n\t    can_connect(t2,n-1);\n\t    flag[i]=-1;\n\t   }\n\telse if(s1 == t1)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t2,n-1);\n\t    flag[i]=-1;\n\t   }\n\telse if(s1 == t2)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t1,n-1);\n\t    flag[i]=-1;\n\t   }\n\n      }\n  return;\n}\nvoid clearflag()\n{\n  int i;\n  for(i=0;i<N;i++)\n    flag[i]=-1;\n}\nmain()\n{\n  int i;\n  while(EOF!=scanf(\"%d\",&N) && N)\n    {\n      for(i=0;i<N;i++)\n\tscanf(\"%d \",&domino[i]);\n      clearflag();\n      State=0;\n      if(setjmp(env)==0)\n\t{\n\t  can_connect(-1,N);\n\t}\n      printf(\"%s\\n\",State?\"Yes\":\"No\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1010\nTitle Domino Arrangement\nWA\n*/\n#include <stdio.h>\n#include <setjmp.h>\n\nint domino[28];\nint flag[28];\nint N;\njmp_buf env;\nint State;\n//\nint can_connect(int s1,int n)\n{\n  int i,t1,t2;\n#ifdef DEBUG\n\tprintf(\"(%d)\\n\",n);\n#endif\n  if(n==0)\n    {\n      State=-1;\n      longjmp(env,1);\n    }\n\n  for(i=0;i<28;i++)\n    if(flag[i])\n      {\n\tt1=domino[i] / 10;t2=domino[i] % 10;\n#ifdef DEBUG\n\tprintf(\"t1s1s2=%d %d %d(%d)\\n\",t1,t2,s1,n);\n#endif\n\tif(s1 == -1)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t1,n-1);\n\t    can_connect(t2,n-1);\n\t    flag[i]=-1;\n\t   }\n\telse if(s1 == t1)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t2,n-1);\n\t    flag[i]=-1;\n\t   }\n\telse if(s1 == t2)\n\t  {\n\t    flag[i]=0;\n\t    can_connect(t1,n-1);\n\t    flag[i]=-1;\n\t   }\n\n      }\n  return;\n}\nvoid clearflag()\n{\n  int i;\n  for(i=0;i<28;i++)\n    flag[i]=0;\n  for(i=0;i<N;i++)\n    flag[i]=-1;\n}\nmain()\n{\n  int i;\n  while(EOF!=scanf(\"%d\",&N) && N)\n    {\n      for(i=0;i<N;i++)\n\tscanf(\"%d \",&domino[i]);\n      clearflag();\n      State=0;\n      if(setjmp(env)==0)\n\t{\n\t  can_connect(-1,N);\n\t}\n      printf(\"%s\\n\",State?\"Yes\":\"No\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "n,e[28],s[7],b;C(d,i){for(i=s[d]?s[d]=0,n:0;i--;e[i]%10-d||C(e[i]/10))e[i]/10-d||C(e[i]%10);}main(i,d){for(;~scanf(\"%d\",&n);b=!puts(!b&&d<3&&d-1?\"Yes\":\"No\")){for(i=n;i--;e[i]=d)scanf(\"%d\",&d),b^=1<<d/10^1<<d%10,s[d/10]=s[d%10]=1;C(*e/10);for(d=0;b;d++)b&=b-1;for(i=7;i--;s[i]=0)b|=s[i];}}"
  },
  {
    "language": "C",
    "code": "// AOJ 1010: Dominoes Arrangement\n// 2017.12.15 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar f['7'], g['7'];\n\nint main()\n{\n\tint n, i, k, ans;\n\tchar buf[60], *p;\n\n\twhile (fgets(buf, 6, stdin) != NULL) {\n\t\tn = atoi(buf);\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfgets(p=buf, 60, stdin);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (*p == *(p+1)) g[*p] = 1;\n\t\t\telse f[*p]++, f[*(p+1)]++;\n\t\t}\n\t\tans = 0;\n\t\tif (n == 1) { ans = 1; goto done; }\n\t\tfor (i = '0'; i <= '6'; i++) if (g[i] && !f[i]) goto done;\n\t\tk = 0; for (i = '0'; i <= '6'; i++) if (f[i] & 1) k++;\n\t\tans = !k || k == 2;\ndone:\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,i,c;\n  char w,a,b;\n  while(scanf(\"%d\",&n)!=EOF){\n    int d[10][2]={0};\n    for(i=0;i<n;i++){\n      scanf(\"%c%c%c\",&w,&a,&b);\n      if(a==b)d[a-'0'][1]=1;\n      else{\n\td[a-'0'][0]++;\n\td[b-'0'][0]++;\n      }\n    }\n    c=0;\n    for(i=0;i<10;i++){\n      if(d[i][0]%2)c++;\n      if(!d[i][0]&&d[i][1])c=3;\n    }\n    if(c<3)printf(\"Yes\\n\");\n    else   printf(\"No\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nbool check(VI a, VI b){\n    int n = a.size();\n    int m = 7;\n    REP(i,n) cout << a[i] << b[i] << endl;\n    VVI dp(1<<n, VI(m));\n    REP(i,n){\n        dp[1<<i][b[i]] = 1;\n        dp[1<<i][a[i]] = 1;\n    }\n    FOR(i,1,(1<<n)-1) REP(j,m){\n        if (dp[i][j] == 0) continue;\n        REP(k,n){\n            if ((i >> k) & 1) continue;\n            if (a[k] == j) dp[i | (1<<k)][b[k]] = 1;\n            if (b[k] == j) dp[i | (1<<k)][a[k]] = 1;\n        }\n    }\n    REP(j,m){\n        if (dp[(1<<n)-1][j] == 1) return true;\n    }\n    return false;\n}\n\nint main(){\n    int n;\n    while (scanf(\"%d\", &n)){\n        VI a(n), b(n);\n        REP(i,n){\n            string x;\n            cin >> x;\n            a[i] = x[0] - '0';\n            b[i] = x[1] - '0';\n        }\n\n        cout << (check(a, b) ? \"Yes\" : \"No\") << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1010: Dominoes Arrangement\n// 2017.12.15 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar f['7'], g['7'];\n\nint main()\n{\n\tint n, i, k, ans;\n\tchar buf[60], *p;\n\n\twhile (fgets(buf, 6, stdin) != NULL) {\n\t\tn = atoi(buf);\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfgets(p=buf, 60, stdin);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (*p == *(p+1)) g[*p] = 1;\n\t\t\telse f[*p]++, f[*(p+1)]++;\n\t\t}\n\t\tans = 0;\n\t\tif (n == 1) { ans = 1; goto done; }\n\t\tfor (i = '0'; i <= '6'; i++) if (g[i] && !f[i]) goto done;\n\t\tk = 0; for (i = '0'; i <= '6'; i++) if (f[i] & 1) k++;\n\t\tans = !k > 0 || k == 2;\ndone:\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n,e[28],s[7],b;C(d,i){for(i=s[d]?s[d]=0,n:0;i--;e[i]%10-d||C(e[i]/10))e[i]/10-d||C(e[i]%10);}main(i,d){for(;~scanf(\"%d\",&n);puts(!b&&d<3&&d-1?\"Yes\":\"No\")){for(i=n;i--;e[i]=d)scanf(\"%d\",&d),b^=1<<d/10^1<<d%10,s[d/10]=s[d%10]=1;C(*e/10);for(d=0;b;d++)b&=b-1;for(i=7;i--;s[i]=0)b|=s[i];}}"
  },
  {
    "language": "C",
    "code": "n,e[28],sep[7];\nconnect(d){\n\tint i,x;\n\tsep[d]=0;\n\tfor(i=0;i<n;i++){\n\t\tif(e[i]/10==d){\n\t\t\tx=e[i]%10;\n\t\t\tif(sep[x])\n\t\t\t\tconnect(x);\n\t\t}\n\t\tif(e[i]%10==d){\n\t\t\tx=e[i]/10;\n\t\t\tif(sep[x])\n\t\t\t\tconnect(x);\n\t\t}\n\t}\n}\nmain(){\n\tint i,b,d,ng;\n\tfor(;~scanf(\"%d\",&n);){\n\t\tb=0;\n\t\tmemset(sep,0,sizeof(sep));\n\t\tfor(i=n;i--;){\n\t\t\tscanf(\"%d\",&d);\n\t\t\te[i]=d;\n\t\t\tb^=1<<d/10;\n\t\t\tb^=1<<d%10;\n\t\t\tsep[d/10]=sep[d%10]=1;\n\t\t}\n\t\tconnect(e[0]/10);\n\t\tng=0;\n\t\tfor(i=0;i<7;i++)\n\t\t\tng|=sep[i];\n\t\tfor(d=0;b;d++)\n\t\t\tb&=b-1;\n\t\tputs(!ng&&(d==0||d==2)?\"Yes\":\"No\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define UNION_FIND_MAX 10\n\nint uf_table[UNION_FIND_MAX];\n\nvoid uf_init(void) {\n\tint i;\n\tfor(i=0;i<UNION_FIND_MAX;i++)uf_table[i]=0;\n}\n\nvoid uf_merge(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\tif(a!=b)uf_table[a]=b+1;\n}\n\nint uf_issame(int a,int b) {\n\tint next;\n\twhile(uf_table[a]>0) {\n\t\tnext=uf_table[a]-1;\n\t\tif(uf_table[next]>0)uf_table[a]=uf_table[next];\n\t\ta=next;\n\t}\n\twhile(uf_table[b]>0) {\n\t\tnext=uf_table[b]-1;\n\t\tif(uf_table[next]>0)uf_table[b]=uf_table[next];\n\t\tb=next;\n\t}\n\treturn a==b;\n}\n\nint main(void) {\n\tint connections[7];\n\tint input[28];\n\tint n,i;\n\tint kiten_num,first;\n\twhile(scanf(\"%d\",&n)==1) {\n\t\tfor(i=0;i<n;i++)scanf(\"%d\",&input[i]);\n\t\tfor(i=0;i<7;i++)connections[i]=0;\n\t\tuf_init();\n\t\tfor(i=0;i<n;i++) {\n\t\t\tconnections[input[i]/10]++;\n\t\t\tconnections[input[i]%10]++;\n\t\t\tuf_merge(input[i]/10,input[i]%10);\n\t\t}\n\t\tkiten_num=0;\n\t\tfirst=-1;\n\t\tfor(i=0;i<7;i++) {\n\t\t\tif(connections[i]>0) {\n\t\t\t\tif(first<0)first=i;\n\t\t\t\tif(!uf_issame(first,i))kiten_num=100;\n\t\t\t}\n\t\t\tif(connections[i]%2)kiten_num++;\n\t\t}\n\t\tputs(kiten_num<=2?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 7\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n  int i;\n\n  while ( scanf ( \" %d\", &n ) == 1 )\n  {\n    int d[ N ] = { 0 };\n    int oc = 0;\n\n    for ( i = 0; i < n; ++i )\n    {\n      char s[ 8 ];\n\n      scanf ( \" %s\", s );\n      ++d[ s[ 0 ] - '0' ];\n      ++d[ s[ 1 ] - '0' ];\n    }\n\n    for ( i = 0; i < N; ++i )\n    {\n      oc += !!( d[ i ] % 2 );\n    }\n\n    puts ( oc > 2 ? \"No\" : \"Yes\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1010: Dominoes Arrangement\n// 2017.12.15 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar f['7'], g['7'];\n\nint main()\n{\n\tint n, i, k, ans;\n\tchar buf[60], *p;\n\n\twhile (fgets(buf, 6, stdin) != NULL) {\n\t\tn = atoi(buf);\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(g, 0, sizeof(g));\n\n\t\tfgets(p=buf, 60, stdin);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (*p == *(p+1)) g[*p] = 1;\n\t\t\telse f[*p]++, f[*(p+1)]++;\n\t\t\tp+=3;\n\t\t}\n\n\t\tans = 0;\n\t\tif (n == 1) { ans = 1; goto done; }\n\t\tfor (i = '0'; i <= '6'; i++) if (g[i] && !f[i]) goto done;\n\t\tk = 0; for (i = '0'; i <= '6'; i++) if (f[i] & 1) k++;\n\t\tans = !k || k == 2;\ndone:\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 7\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int n;\n  int i;\n\n  while ( scanf ( \" %d\", &n ) == 1 )\n  {\n    int d[ N ] = { 0 };\n    int oc = 0;\n\n    for ( i = 0; i < n; ++i )\n    {\n      char s[ 8 ];\n\n      scanf ( \" %s\", s );\n      ++d[ s[ 0 ] - '0' ];\n      ++d[ s[ 1 ] - '0' ];\n    }\n\n    for ( i = 0; i < N; ++i )\n    {\n      oc += !!( d[ i ] % 2 );\n    }\n\n    puts ( oc > 2 ? \"no\" : \"yes \" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tint a[7] = {0};\n\t\tstring s;\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> s;\n\t\t\ta[s[0]-'0']++;\n\t\t\ta[s[1]-'0']++;\n\t\t}\n\n\t\tint odd=0;\n\t\tfor (int i=0; i<7; i++)\n\t\t\tif (a[i]%2)\n\t\t\t\todd++;\n\n\t\tcout << ((odd==0||odd==2) ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "b,d;\nmain(n){\n\tfor(;~scanf(\"%d\",&n);){\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tb^=1<<d/10;\n\t\t\tb^=1<<d%10;\n\t\t}\n\t\tfor(d=0;b;d++)\n\t\t\tb&=b-1;\n\t\tputs(d==0||d==2?\"Yes\":\"No\");\n\t\tb=0;\n\t}\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>):Unit {\n    while(true){\n        val n = (readLine() ?: return).toInt()\n        val dominos = Array(n){Dominos(it)}\n        val str = readLine()!!.trim().split(' ').zip(dominos)\n        str.forEach {(string, domino) ->\n            str.filter{it.second.id != domino.id}.forEach { (s, d) ->\n                if (string[0] == s[0]){\n                    domino.backward().addEdge(d.forward())\n                }\n                if (string[0] == s[1]){\n                    domino.backward().addEdge(d.backward())\n                }\n                if (string[1] == s[0]){\n                    domino.forward().addEdge(d.forward())\n                }\n                if (string[1] == s[1]){\n                    domino.forward().addEdge(d.backward())\n                }\n            }\n        }\n        val memo = Array(n){Array(1 shl n){-1}.toIntArray()}\n        if (dominos.any{search(it.forward(), Flag(0) + it.id, memo) || search(it.backward(), Flag(0) + it.id, memo)})\n            println(\"Yes\")\n        else\n            println(\"No\")\n    }\n}\nfun search(current:Domino, flag:Flag, memo:Array<IntArray>, depth:Int = 1):Boolean{\n    if (depth == memo.size) return true\n    if (memo[current.id][flag.value] >= 0) return memo[current.id][flag.value] > 0\n    memo[current.id][flag.value] = if (current.edges().any{\n        !flag.isSet(it.id) && search(it, flag + it.id, memo, depth + 1)\n    }) 1 else 0\n    return memo[current.id][flag.value] > 0\n}\n\ndata class Flag(val value:Int){\n    operator fun plus(flag:Int):Flag {\n        return Flag(value or (1 shl flag))\n    }\n    fun isSet(flag:Int):Boolean = ((1 shl flag) and value) != 0\n}\ndata class Domino(val id:Int){\n    private val mEdge: Stack<Domino> = Stack()\n    fun addEdge(domino:Domino):Unit {\n        mEdge.add(domino)\n    }\n    fun edges():Iterable<Domino> = mEdge\n}\ndata class Dominos(val id:Int){\n    private val mForward:Domino = Domino(id)\n    private val mBackward:Domino = Domino(id)\n    fun forward():Domino = mForward\n    fun backward():Domino = mBackward\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n        try {\n        \tString line;\n        \twhile((line=r.readLine())!=null){\n                /* input from here */\n        \t\tint n = Integer.parseInt(line);\n        \t\tString[] in = r.readLine().split(\" \");\n        \t\tboolean[][] b = new boolean[7][7];\n        \t\tboolean res = false;\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tArrays.fill(b[i], false);\n        \t\t}\n        \t\tfor(String s : in){\n        \t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n        \t\t}\n        \t\tint count = in.length;\n                /* input till here */\n\n        \t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tfor(int j=0;j<7;j++){\n        \t\t\t\ttemp[i][j] = b[i][j];\n        \t\t\t}\n        \t\t}\n                /* processing from here */\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tfor(int j=i;j<7;j++){\n        \t\t\t\tif(b[i][j]){\n        \t\t\t\t\tSystem.out.println(\"start: \" + i + \" \" + j);\n        \t        \t\tif(res = solve(temp,i,j,count,1)){\n        \t        \t\t\tbreak;\n        \t        \t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tif(res){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n                /* processing till here */\n                /* output */\n        \t\tif(res){\n        \t\t\tSystem.out.println(\"Yes\");\n        \t\t} else {\n        \t\t\tSystem.out.println(\"No\");\n        \t\t}\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n    \tboolean res = false;\n    \tSystem.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n    \tif(count==1){\n    \t\treturn true;\n    \t} else {\t\t\t\n    \t\tboolean[][] temp = new boolean[7][7]; \n    \t\tfor(int i=0;i<7;i++){\n    \t\t\tfor(int j=0;j<7;j++){\n    \t\t\t\ttemp[i][j] = b[i][j];\n    \t\t\t}\n    \t\t}\n    \t\t \n    \t\tfor(int column=0;column<7;column++){\n    \t\t\t if(column==sc){\n    \t\t\t\t continue;\n    \t\t\t }\n    \t\t\t if(b[sr][column]&&open<2){\n    \t\t\t\t temp[sr][sc] = false;\n    \t\t\t\t res = solve(temp,sr,column,count-1,2);\n    \t\t\t }\n    \t\t\t if(res){\n    \t\t\t\t break;\n    \t\t\t }\n    \t\t }\n    \t\t for(int row=0;row<7;row++){\n    \t\t\t if(res){\n    \t\t\t\t break;\n    \t\t\t }\n    \t\t\t if(row==sr){\n    \t\t\t\t continue;\n    \t\t\t }\n    \t\t\t if(b[row][sc]&&open>0){\n    \t\t\t\t temp[sr][sc] = false;\n    \t\t\t\t res = solve(temp,row,sc,count-1,0);\n    \t\t\t }\n    \t\t }\n    \t\t \n    \t\t if(res){\n    \t\t\t return true;\n    \t\t } else {\n    \t\t\t return false;\n    \t\t }\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n    int n;\n    int[][] ns;\n    boolean[] used;\n    String[] lines;\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.read();\n        for (int i = 0; i < m.lines.length; i += 2) {\n            m.read(i);\n            m.solve();\n        }\n    }\n\n    private void read(int y) {\n        String x = lines[y];\n        String s = lines[y+1];\n        this.n = Integer.parseInt(x);\n        String[] ss = s.split(\" \");\n        ns = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            ns[i][0] = ss[i].charAt(0) - '0';\n            ns[i][1] = ss[i].charAt(1) - '0';\n        }\n        used = new boolean[n];\n    }\n    private void read() {\n        try (BufferedReader br =\n                     new BufferedReader(new InputStreamReader(System.in))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null &&\n                    !line.equals(\"\")) {\n                sb.append(line);\n                sb.append(\"\\n\");\n            }\n            lines = sb.toString().split(\"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() {\n        boolean ans = false;\n        for (int i = 0; i < ns.length; i++) {\n            used[i] = true;\n            ans |= dfs(0, ns[i][1]);\n        }\n        if (ans)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n\n    private boolean dfs(int depth, int current) {\n//        System.out.printf(\"depth = %d, curr = %d\\n\", depth, current);\n        if (depth == n - 1)\n            return true;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                if (ns[i][0] == current) {\n                    used[i] = true;\n                    boolean b = dfs(depth+1, ns[i][1]);\n                    if (b)\n                        return true;\n                    used[i] = false;\n                }\n                if (ns[i][1] == current) {\n                    used[i] = true;\n                    if(dfs(depth+1, ns[i][0]))\n                        return true;\n                    used[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().dominoesArrangement();\n    }\n    Map<String, Integer> dominoMasterMap;\n    String oddLine;\n    String evenLine;\n    String[] dominoArray;\n    List<Integer> sortNoList;\n\n    public void dominoesArrangement() throws IOException {\n        //create domino master\n        dominoMasterMap = new HashMap<>();\n        int sortNo = 0;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j <= i; j++) {\n                dominoMasterMap.put(String.valueOf(j) + i, sortNo++);\n            }\n        }\n\n        //read input file\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while ((oddLine = br.readLine()) != null) {\n            evenLine = br.readLine();\n            dominoArray = evenLine.split(\" \");\n            for (int i = 0; i < Integer.parseInt(oddLine); i++) {\n                //change input no to diamond master\n                sortNoList.add(dominoMasterMap.get(dominoArray[i]));\n            }\n\n            boolean sortFlg = false;\n            Integer pastNo = null;\n            for (Integer no : sortNoList) {\n                if (no == null) {\n                    pastNo = no;\n                    continue;\n                }\n                if (pastNo > no) {\n                    sortFlg = true;\n                    break;\n                }\n                pastNo = no;\n            }\n\n            //judge is sort no right\n            if (sortFlg) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\ttemp[i][j] = false;\n\t\t\t\t\t\t\tif(res = solve(temp,i,j,count,i)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if(res = solve(temp,i,j,count,j)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemp[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count + \" open: \" + open);\n\t\tif(count==1){\n\t\t\t//System.out.println(s);\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\tif(column==sc){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b[open][column]){\n\t\t\t\t\tb[open][column] = false;\n\t\t\t\t\tres = solve(b,open,column,count-1,column);\n\t\t\t\t\tb[open][column] = true;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int row=0;row<=6;row++){\n\t\t\t\tif(row==sr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(b[row][open]){\n\t\t\t\t\tb[row][open] = false;\n\t\t\t\t\tres = solve(b,row,open,count-1,row);\n\t\t\t\t\tb[row][open] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"FAIL\");\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Map;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().dominoesArrangement();\n    }\n    Map<String, Integer> dominoMasterMap;\n    String oddLine;\n    String evenLine;\n    String[] dominoArray;\n    List<Integer> sortNoList;\n\n    public void dominoesArrangement() throws IOException {\n        //create domino master\n        int sortNo = 0;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j <= i; j++) {\n                dominoMasterMap.put(String.valueOf(j) + i, sortNo++);\n            }\n        }\n\n        //read input file\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while ((oddLine = br.readLine()) != null) {\n            evenLine = br.readLine();\n            dominoArray = evenLine.split(\" \");\n            for (int i = 0; i < Integer.parseInt(oddLine); i++) {\n                //change input no to diamond master\n                sortNoList.add(dominoMasterMap.get(dominoArray[i]));\n            }\n\n            boolean sortFlg = false;\n            Integer pastNo = null;\n            for (Integer no : sortNoList) {\n                if (no == null) {\n                    pastNo = no;\n                    continue;\n                }\n                if (pastNo > no) {\n                    sortFlg = true;\n                    break;\n                }\n                pastNo = no;\n            }\n\n            //judge is sort no right\n            if (sortFlg) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic boolean[][] domino = new boolean[7][7];\n\tstatic int[] count = new int[7];\n\tstatic int N;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (sc.hasNext()) {\n\t\t\tN = sc.nextInt();\n\t\t\tfor (boolean[] a : domino) {\n\t\t\t\tArrays.fill(a, false);\n\t\t\t}\n\t\t\tArrays.fill(count, 0);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString v = sc.next();\n\t\t\t\tint f = v.charAt(0) - '0';\n\t\t\t\tint s = v.charAt(1) - '0';\n\t\t\t\tdomino[f][s] = true;\n\t\t\t\t++count[f];\n\t\t\t\t++count[s];\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\tif (solve(i, 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean solve(int first, int depth) {\n\t\tif (depth == N) return true;\n\t\tif (count[first] == 0) return false;\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\tif (count[i] % 2 != 0) ++odd;\n\t\t}\n\t\tif (!(odd == 0 || (odd == 2 && count[first] % 2 != 0))) return false;\n\t\tfor (int i = 0; i < 7; ++i) {\n\t\t\tint r = Math.min(i, first);\n\t\t\tint c = Math.max(i, first);\n\t\t\tif (domino[r][c]) {\n\t\t\t\tdomino[r][c] = false;\n\t\t\t\t--count[r];\n\t\t\t\t--count[c];\n//\t\t\t\tSystem.out.println(r + \" \" + c + \" \" + depth);\n\t\t\t\tif (solve(i, depth + 1)) return true;\n\t\t\t\t++count[c];\n\t\t\t\t++count[r];\n\t\t\t\tdomino[r][c] = true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n        try {\n        \tString line;\n        \twhile((line=r.readLine())!=null){\n                /* input from here */\n        \t\tint n = Integer.parseInt(line);\n        \t\tString[] in = r.readLine().split(\" \");\n        \t\tboolean[][] b = new boolean[6][6];\n        \t\tboolean res = false;\n        \t\tfor(int i=0;i<6;i++){\n        \t\t\tArrays.fill(b[i], false);\n        \t\t}\n        \t\tfor(String s : in){\n        \t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n        \t\t}\n        \t\tint count = in.length;\n                /* input till here */\n                /* processing from here */\n        \t\tfor(int i=0;i<6;i++){\n        \t\t\tfor(int j=i;j<6;j++){\n        \t\t\t\tif(b[i][j]){\n        \t        \t\tif(res = solve(b,i,j,count)){\n        \t        \t\t\tbreak;\n        \t        \t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tif(res){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n                /* processing till here */\n                /* output */\n    \t\t\tSystem.out.println(res);        \t\t\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static boolean solve(boolean[][] b, int sr,int sc, int count){\n    \tif(count==1){\n    \t\treturn true;\n    \t} else {\n    \t\t boolean[][] temp = b;\n    \t\t if(sc<5&&b[sr][sc+1]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr,sc+1,count-1);\n    \t\t }\n    \t\t if(sr<5&&b[sr+1][sc]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr+1,sc,count-1);\n    \t\t }\n    \t\t if(sc>0&&b[sr][sc-1]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr,sc-1,count-1);\n    \t\t }\n    \t\t if(sr>0&&b[sr-1][sc]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr-1,sc,count-1);\n    \t\t }\n    \t\t return false;\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n\n                        int[][] num = new int[n][2];\n\n                        int[] count = new int[l];\n                        boolean[] p = new boolean[l];\n                        Arrays.fill(p,false);\n                        boolean[] use = new boolean[n];\n                        Arrays.fill(use,true);\n\n                        ia = in.readLine().split(\" \");\n                        for(int i = 0;i < n; ++i){\n                                int s = Integer.parseInt(ia[i]);\n                                num[i][0] = (int) (Math.floor(s/10)+0.01);\n                                num[i][1] = s%10;\n                                if(num[i][0] == num[i][1]){\n                                        p[num[i][0]] = true;\n                                        use[i] = false;\n                                }\n                                ++count[num[i][0]];\n                                ++count[num[i][1]];\n                        }\n\n                        int c = 0;\n                        for(int i = 0;i < l; ++i){\n                                if(count[i]%2 == 1){\n                                        ++c;\n                                }\n                        }\n                        if(c != 2 && c != 0){\n                                System.out.println(\"No\");\n                                continue;\n                        }\n                        if(n == 1){\n                                System.out.println(\"Yes\");\n                                continue;\n                        }\n                        for(int i = 0;i < l; ++i){\n                                if(count[i] == 2 && p[i]){\n                                        System.out.println(\"No\");\n                                }\n                        }\n\n                        if(c == 2){\n                                int[] a = new int[2];\n                                int b = 0;\n                                for(int i = 0;i < l; ++i){\n                                        if(count[i]%2 == 1){\n                                                a[b] = i;\n                                                ++b;\n                                        }\n                                }\n\n                                for(int i = 0;i < n; ++i){\n                                        if(num[i][0] == a[0] || num[i][1] == a[0] ||\n                                           num[i][0] == a[1] || num[i][1] == a[1]){\n                                                if(mfs(num,use,i)){\n                                                        System.out.println(\"Yes\");\n                                                        break;\n                                                }\n                                        }\n                                }\n                        } else if(mfs(num,use)){\n                                System.out.println(\"Yes\");\n                        } else {\n                                System.out.println(\"No\");\n                        }\n                }\n        }\n        static boolean mfs(int[][] num, boolean[] use){\n                return mfs(num,use,-1);\n        }\n        static boolean mfs(int[][] num, boolean[] yet, int x){\n                int s,e;\n                if(x == -1){\n                        s = 0;  e = num.length;\n                } else {\n                        s = x;  e = x+1;\n                }\n                for(int i = s;i < e; ++i){\n                        if(mfw(num,yet,i,num[i][0])){\n                                return true;\n                        }\n                        if(mfw(num,yet,i,num[i][1])){\n                                return true;\n                        }\n                }\n                return false;\n\n        }\n        static boolean mfw(int[][] num, boolean[] yet, int n, int s){\n                yet[n] = false;\n                if(!chk(yet)){\n                        return true;\n                }\n                for(int i = 0;i < num.length; ++i){\n                        if(yet[i]){\n                                if(num[i][0] == s){\n                                        if(mfw(num,yet,i,num[i][1])){\n                                                return true;\n                                        }\n                                }\n                                if(num[i][1] == s){\n                                        if(mfw(num,yet,i,num[i][0])){\n                                                return true;\n                                        }\n                                }\n                        }\n                }\n                yet[n] = true;\n                return false;\n        }\n        static boolean chk(boolean[] p){\n                for(int i = 0;i < p.length; ++i){\n                        if(p[i]){\n                                return true;\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n        try {\n        \tString line;\n        \twhile((line=r.readLine())!=null){\n                /* input from here */\n        \t\tint n = Integer.parseInt(line);\n        \t\tString[] in = r.readLine().split(\" \");\n        \t\tboolean[][] b = new boolean[7][7];\n        \t\tboolean res = false;\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tArrays.fill(b[i], false);\n        \t\t}\n        \t\tfor(String s : in){\n        \t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n        \t\t}\n        \t\tint count = in.length;\n                /* input till here */\n\n        \t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tfor(int j=0;j<7;j++){\n        \t\t\t\ttemp[i][j] = b[i][j];\n        \t\t\t}\n        \t\t}\n                /* processing from here */\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tfor(int j=i;j<7;j++){\n        \t\t\t\tif(b[i][j]){\n        \t\t\t\t\tSystem.out.println(\"start: \" + i + \" \" + j);\n        \t        \t\tif(res = solve(temp,i,j,count,1)){\n        \t        \t\t\tbreak;\n        \t        \t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tif(res){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n                /* processing till here */\n                /* output */\n        \t\tif(res){\n        \t\t\tSystem.out.println(\"Yes\");\n        \t\t} else {\n        \t\t\tSystem.out.println(\"No\");\n        \t\t}\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n    \tboolean res = false;\n    \tSystem.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n    \tif(count==1){\n    \t\treturn true;\n    \t} else {\t\t\t\n    \t\tboolean[][] temp = new boolean[7][7]; \n    \t\tfor(int i=0;i<7;i++){\n    \t\t\tfor(int j=0;j<7;j++){\n    \t\t\t\ttemp[i][j] = b[i][j];\n    \t\t\t}\n    \t\t}\n    \t\t \n    \t\tfor(int column=sc+1;column<7;column++){\n    \t\t\t if(b[sr][column]&&open<2){\n    \t\t\t\t temp[sr][sc] = false;\n    \t\t\t\t res = solve(temp,sr,column,count-1,2);\n    \t\t\t }\n    \t\t\t if(res){\n    \t\t\t\t break;\n    \t\t\t }\n    \t\t }\n    \t\t for(int row=sr+1;row<7;row++){\n    \t\t\t if(res){\n    \t\t\t\t break;\n    \t\t\t }\n    \t\t\t if(b[row][sc]&&open>0){\n    \t\t\t\t temp[sr][sc] = false;\n    \t\t\t\t res = solve(temp,row,sc,count-1,0);\n    \t\t\t }\n    \t\t }\n    \t\t \n    \t\t if(res){\n    \t\t\t return true;\n    \t\t } else {\n    \t\t\t return false;\n    \t\t }\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        int num,a,b,count,temp;\n        count=0;\n        boolean[] odd = new boolean[7];\n        String str;\n        Scanner sc = new Scanner(System.in);\n        num = sc.nextInt();\n        sc.reset();\n        ArrayList<Integer> list = new ArrayList<Integer>(7){{\n            add(0);add(0);add(0);add(0);add(0);add(0);add(0);\n        }};\n        for(int i = 0 ; i < num ; i++){\n            str = sc.next();\n            a = Integer.parseInt(str.substring(0,1));\n            b = Integer.parseInt(str.substring(1,2));\n            if(a!=b) {\n                temp = list.get(a);\n                list.set(a, temp + 1);\n                temp = list.get(b);\n                list.set(b, temp + 1);\n            }\n        }\n        for(int i=0 ; i<7; i++){\n            if(list.get(i)%2!=0){\n                odd[i] = true;\n                count++;\n            }else{\n                odd[i] = false;\n            }\n\n        }\n        if(count==0 || count==2){\n            System.out.println(\"Yes\");\n        }else{\n            System.out.println(\"No\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    int n;\n    int[][] ns;\n    boolean[] used;\n    Scanner sc;\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        boolean f = m.read();\n        while (f) {\n            m.solve();\n            m.read();\n        }\n    }\n\n    private boolean read() {\n        if (sc == null)\n             sc = new Scanner(System.in);\n        if (!sc.hasNext())\n            return false;\n        n = sc.nextInt();\n        sc.nextLine();\n        String[] ss = sc.nextLine().split(\" \");\n        ns = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            ns[i][0] = ss[i].charAt(0) - '0';\n            ns[i][1] = ss[i].charAt(1) - '0';\n        }\n        used = new boolean[n];\n        return true;\n    }\n\n    private void solve() {\n        used[0] = true;\n        boolean ans = dfs(0, ns[0][1]);\n        if (ans)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n\n    private boolean dfs(int depth, int current) {\n//        System.out.printf(\"depth = %d, curr = %d\\n\", depth, current);\n        if (depth == n - 1)\n            return true;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                if (ns[i][0] == current) {\n                    used[i] = true;\n                    boolean b = dfs(depth+1, ns[i][1]);\n                    if (b)\n                        return true;\n                    used[i] = false;\n                }\n                if (ns[i][1] == current) {\n                    used[i] = true;\n                    if(dfs(depth+1, ns[i][0]))\n                        return true;\n                    used[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n\n                        int[][] num = new int[n][2];\n                        int[] count = new int[l];\n\n                        ia = in.readLine().split(\" \");\n                        for(int i = 0;i < n; ++i){\n                                int s = Integer.parseInt(ia[i]);\n                                num[i][0] = (int) (Math.floor(s/10)+0.01);\n                                num[i][1] = s%10;\n                                ++count[num[i][0]];\n                                ++count[num[i][1]];\n                        }   \n\n                        int c = 0;\n                        for(int i = 0;i < l; ++i){\n                                if(count[i]%2 == 1){ \n                                        ++c;\n                                }   \n                        }   \n                        if(c != 2 && c != 0){ \n                                System.out.println(\"No\");\n                                continue;\n                        }\n\n                        boolean[] next = new boolean[n];\n                        Arrays.fill(next,true);\n                        boolean yet = true;\n\n                        if(c == 2){\n                                int[] a = new int[2];\n                                int b = 0;\n                                for(int i = 0;i < l; ++i){\n                                        if(count[i]%2 == 1){\n                                                a[b] = i;\n                                                ++b;\n                                        }\n                                }\n                                for(int i = 0;i < n; ++i){\n                                        if(num[i][0] == a[0] || num[i][1] == a[0] ||\n                                           num[i][0] == a[1] || num[i][1] == a[1]){\n                                                if(mfs(num,i)){\n                                                        System.out.println(\"Yes\");\n                                                        yet = false;\n                                                        break;\n                                                }\n                                                next[i] = false;\n                                        }\n                                }\n                        }\n                        if(!yet){\n                                continue;\n                        }\n                        for(int i = 0;i < n; ++i){\n                                if(next[i] && mfs(num)){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }\n                        }\n\n                }\n        }\n        static boolean mfs(int[][] num){\n                return mfs(num,9);\n        }\n        static boolean mfs(int[][] num, int x){\n                boolean[] yet = new boolean[num.length];\n                Arrays.fill(yet,true);\n                int s,e;\n                if(x == 9){\n                        s = 0;\n                        e = num.length;\n                } else {\n                        s = x;\n                        e = x+1;\n                }\n                for(int i = s;i < e; ++i){\n                        if(mfw(num,yet,i,num[i][0])){\n                                return true;\n                        }\n                        if(mfw(num,yet,i,num[i][1])){\n                                return true;\n                        }\n                }\n                return false;\n        }\n\n        static boolean mfw(int[][] num, boolean[] yet, int n, int s){\n                yet[n] = false;\n                if(!chk(yet)){\n                        return true;\n                }\n                for(int i = 0;i < num.length; ++i){\n                        if(yet[i]){\n                                if(num[i][0] == s){\n                                        if(mfw(num,yet,i,num[i][1])){\n                                                return true;\n                                        }\n                                }\n                                if(num[i][1] == s){\n                                        if(mfw(num,yet,i,num[i][0])){\n                                                return true;\n                                        }\n                                }\n                        }\n                }\n                yet[n] = true;\n                return false;\n        }\n        static boolean chk(boolean[] p){\n                for(int i = 0;i < p.length; ++i){\n                        if(p[i]){\n                                return true;\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Dominoes Arrangement\npublic class Main{\n\n\tpublic static class N{\n\t\tpublic List<N> adj;\n\t\tpublic boolean visited;\n\t\tpublic N() {\n\t\t\tadj = new ArrayList<N>();\n\t\t}\n\t\tpublic void f(){\n\t\t\tif(visited)return;\n\t\t\tvisited = true;\n\t\t\tfor(N n:adj)n.f();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tN[] v = new N[14];\n\t\t\tfor(int i=0;i<14;i++)v[i]=new N();\n\t\t\twhile(n--!=0){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tint a = s[0]-'0';\n\t\t\t\tint b = s[1]-'0';\n\t\t\t\tif(b < a){\n\t\t\t\t\tint tmp = a;\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = tmp;\n\t\t\t\t}\n\t\t\t\tv[a].adj.add(v[b+7]);\n\t\t\t\tv[b+7].adj.add(v[a]);\n\t\t\t}\n\t\t\tint odd = 0;\n\t\t\tfor(int i=0;i<14;i++)odd+=v[i].adj.size()%2==1?1:0;\n\t\t\tif(!(odd==0||odd==2)){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<14;i++){\n\t\t\t\tif(!v[i].adj.isEmpty()){\n\t\t\t\t\tv[i].f();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<14;i++){\n\t\t\t\tif(!v[i].adj.isEmpty()&&!v[i].visited){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(f?\"Yes\":\"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        int num,a,b,c,count,temp;\n        count=0;\n        boolean[] odd = new boolean[7];\n        String str,str2;\n        Scanner sc = new Scanner(System.in);\n        num = sc.nextInt();\n        sc.reset();\n        ArrayList<Integer> list = new ArrayList<Integer>(7){{\n            add(0);add(0);add(0);add(0);add(0);add(0);add(0);\n        }};\n        for(int i = 0 ; i < num ; i++){\n            str = sc.next();\n            a = Integer.parseInt(str.substring(0,1));\n            b = Integer.parseInt(str.substring(1,2));\n            if(a!=b) {\n                temp = list.get(a);\n                list.set(a, temp + 1);\n                temp = list.get(b);\n                list.set(b, temp + 1);\n            }\n        }\n        for(int i=0 ; i<7; i++){\n            if(list.get(i)%2!=0){\n                odd[i]=true;\n                count++;\n            }else{\n                odd[i]=false;\n            }\n\n        }\n        if(count==2){\n            c=0;\n            str2 = \"\";\n            for(boolean t: odd){\n                if(t){\n                    str2 += Integer.toString(c);\n                }\n                c++;\n            }\n            if(list.contains(Integer.parseInt(str2))){\n                System.out.println(\"No\");\n            }else{\n                System.out.println(\"Yes\");\n            }\n        }else{\n            System.out.println(\"No\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\t//System.out.println(\"start: \" + i + \" \" + j);\n\t\t\t\t\t\t\tres = solve(temp,i,j,count,1);\n\t\t\t\t\t\t\tif(res)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open<2){\n\t\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\t\tif(column==sc){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[sr][column]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,sr,column,count-1,2);\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open>0){\n\t\t\t\tfor(int row=0;row<7;row++){\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(row==sr){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[row][sc]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,row,sc,count-1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n    int n;\n    int[][] ns;\n    boolean[] used;\n    String[] lines;\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.read();\n        for (int i = 0; i < m.lines.length; i += 2) {\n            m.read(i);\n            m.solve();\n        }\n    }\n\n    private void read(int y) {\n        String x = lines[y];\n        String s = lines[y+1];\n        this.n = Integer.parseInt(x);\n        String[] ss = s.split(\" \");\n        ns = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            ns[i][0] = ss[i].charAt(0) - '0';\n            ns[i][1] = ss[i].charAt(1) - '0';\n        }\n        used = new boolean[n];\n    }\n    private void read() {\n        try (BufferedReader br =\n                     new BufferedReader(new InputStreamReader(System.in))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null &&\n                    !line.equals(\"\")) {\n                sb.append(line);\n                sb.append(\"\\n\");\n            }\n            lines = sb.toString().split(\"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() {\n        used[0] = true;\n        boolean ans = dfs(0, ns[0][1]);\n        if (ans)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n\n    private boolean dfs(int depth, int current) {\n//        System.out.printf(\"depth = %d, curr = %d\\n\", depth, current);\n        if (depth == n - 1)\n            return true;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                if (ns[i][0] == current) {\n                    used[i] = true;\n                    boolean b = dfs(depth+1, ns[i][1]);\n                    if (b)\n                        return true;\n                    used[i] = false;\n                }\n                if (ns[i][1] == current) {\n                    used[i] = true;\n                    if(dfs(depth+1, ns[i][0]))\n                        return true;\n                    used[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().dominoesArrangement();\n    }\n    Map<String, Integer> dominoMasterMap;\n    String oddLine;\n    String evenLine;\n    String[] dominoArray;\n    List<Integer> sortNoList;\n\n    public void dominoesArrangement() throws IOException {\n        //create domino master\n        dominoMasterMap = new HashMap<String, Integer>();\n        int sortNo = 0;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j <= i; j++) {\n                dominoMasterMap.put(String.valueOf(j) + i, sortNo++);\n            }\n        }\n\n        //read input file\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while ((oddLine = br.readLine()) != null) {\n            evenLine = br.readLine();\n            dominoArray = evenLine.split(\" \");\n            for (int i = 0; i < Integer.parseInt(oddLine); i++) {\n                //change input no to diamond master\n                sortNoList.add(dominoMasterMap.get(dominoArray[i]));\n            }\n\n            boolean sortFlg = false;\n            Integer pastNo = null;\n            for (Integer no : sortNoList) {\n                if (no == null) {\n                    pastNo = no;\n                    continue;\n                }\n                if (pastNo > no) {\n                    sortFlg = true;\n                    break;\n                }\n                pastNo = no;\n            }\n\n            //judge is sort no right\n            if (sortFlg) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dominoes Arrangement\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] c = new int[7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tc[s[0]-'0']++;\n\t\t\t\tc[s[1]-'0']++;\n\t\t\t}\n\t\t\tint o = 0;\n\t\t\tfor(int i=0;i<7;i++)if(c[i]%2==1)o++;\n\t\t\tSystem.out.println(o==0||o==2?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\tSystem.out.println(\"start: \" + i + \" \" + j);\n\t\t\t\t\t\t\tres = solve(temp,i,j,count,1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open<2){\n\t\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\t\tif(column==sc){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[sr][column]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,sr,column,count-1,2);\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open>0){\n\t\t\t\tfor(int row=0;row<7;row++){\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(row==sr){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[row][sc]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,row,sc,count-1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    int n;\n    int[][] ns;\n    boolean[] used;\n    String[] lines;\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.read();\n        for (int i = 0; i < m.lines.length; i += 2) {\n            m.read(i);\n            m.solve();\n        }\n    }\n\n    private void read(int y) {\n        String x = lines[y];\n        String s = lines[y+1];\n        this.n = Integer.parseInt(x);\n        String[] ss = s.split(\" \");\n        ns = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            ns[i][0] = ss[i].charAt(0) - '0';\n            ns[i][1] = ss[i].charAt(1) - '0';\n        }\n        used = new boolean[n];\n    }\n    private void read() {\n        try (BufferedReader br =\n                     new BufferedReader(new InputStreamReader(System.in))) {\n            StringBuilder sb = new StringBuilder();\n            String line;\n            while ((line = br.readLine()) != null &&\n                    !line.equals(\"\")) {\n                sb.append(line);\n                sb.append(\"\\n\");\n            }\n            lines = sb.toString().split(\"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() {\n        boolean ans = false;\n        for (int i = 0; i < ns.length; i++) {\n            Arrays.fill(used, false);\n            used[i] = true;\n            ans |= dfs(0, ns[i][1]);\n        }\n        if (ans)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n    }\n\n    private boolean dfs(int depth, int current) {\n//        System.out.printf(\"depth = %d, curr = %d\\n\", depth, current);\n        if (depth == n - 1)\n            return true;\n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                if (ns[i][0] == current) {\n                    used[i] = true;\n                    boolean b = dfs(depth+1, ns[i][1]);\n                    if (b)\n                        return true;\n                    used[i] = false;\n                }\n                if (ns[i][1] == current) {\n                    used[i] = true;\n                    if(dfs(depth+1, ns[i][0]))\n                        return true;\n                    used[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dominoes Arrangement\npublic class Main{\n\n\tvoid f(int k){\n\t\tu[k] = true;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(!u[i]&&r[k][i])f(i);\n\t\t}\n\t}\n\t\n\tboolean[][] r;\n\tboolean[] u;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] c = new int[7];\n\t\t\tr = new boolean[7][7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tint a = s[0]-'0';\n\t\t\t\tint b = s[1]-'0';\n\t\t\t\tc[a]++;\n\t\t\t\tc[b]++;\n\t\t\t\tr[a][b] = r[b][a] = true;\n\t\t\t}\n\t\t\tu = new boolean[7];\n\t\t\tf(0);\n\t\t\tboolean ok = true;\n\t\t\tfor(int i=0;i<7;i++)if(!u[i])ok = false;\n\t\t\tint o = 0;\n\t\t\tfor(int i=0;i<7;i++)if(c[i]%2==1)o++;\n\t\t\tSystem.out.println((o==0||o==2)&&ok?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\t//System.out.println(\"start: \" + i + \" \" + j);\n\t\t\t\t\t\t\tres = solve(temp,i,j,count,1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open<2){\n\t\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\t\tif(column==sc){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[sr][column]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,sr,column,count-1,2);\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open>0){\n\t\t\t\tfor(int row=0;row<7;row++){\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(row==sr){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[row][sc]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,row,sc,count-1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[n][n];\n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        for(int i = 0;i < n; ++i){\n                                Arrays.fill(p[i],false);\n                                s[i] = Integer.parseInt(ia[i]);\n                        }   \n                        for(int i = 0;i < n; ++i){\n                                p[s[i]%10][(int)(Math.floor(s[i]/10))] = true;\n                        }   \n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, n, s[i]%10, (int)(Math.floor(s[i]/10)))){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }   \n                        }   \n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        }\n        static boolean mfs(boolean[][] p, int n, int x, int y){ \n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }   \n                if(p[x][y] == false){\n                        return false;\n                }   \n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }\n                boolean a =\n                        mfs(p,n,x-1,y) ||\n                        mfs(p,n,x+1,y) ||\n                        mfs(p,n,x,y-1) ||\n                        mfs(p,n,x,y+1);\n                if(a){\n                        return true;\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// 最初はドミノの数が入力される\n\t\t\t\tint n = Integer.parseInt(str);\n\n\t\t\t\t// 次にはドミノが入力される\n\t\t\t\tint inputedDominoCount = 0;\n\t\t\t\tint valuesCount[] = new int[7];\n\t\t\t\twhile(inputedDominoCount < n){\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tint nowInputValuesCount[] = calcDomino(str);\n\t\t\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\t\t\tvaluesCount[i] += nowInputValuesCount[i];\n\t\t\t\t\t}\n\t\t\t\t\tinputedDominoCount += nowInputValuesCount[7];\n\t\t\t\t\t//System.out.println(\"inputedDominoCount: \" + inputedDominoCount);\n\t\t\t\t}\n\t\t\t\t//printArray(valuesCount);\n\n\t\t\t\t// 値のチェック\n\t\t\t\tint oddCount = 0;\n\t\t\t\tfor(int i = 0; i < valuesCount.length; i++){\n\t\t\t\t\tif(valuesCount[i] % 2 == 1){\n\t\t\t\t\t\toddCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(oddCount <= 2){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\t//System.err.println(e);\n\t\t}\n\t}\n\n\tstatic int[] calcDomino(String inputStr){\n\t\tint result[] = new int[8];\n\t\tfor(int i = 0; i < inputStr.length(); i++){\n\t\t\tchar pointingChar = inputStr.charAt(i);\n\t\t\tif(pointingChar == ' '){\n\t\t\t}else{\n\t\t\t\tresult[Integer.parseInt(\"\" + pointingChar)]++;\n\t\t\t\tresult[7]++;\n\t\t\t}\n\t\t}\n\t\tresult[7] = result[7] / 2;\n\t\treturn result;\n\t}\n\n\tstatic void printArray(int[] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.println(i + \": \" + array[i]);\n\t\t}\n\t}\n\n\tstatic int[][] parseDomino(String inputStr){\n\t\tint result[][] = new int[(inputStr.length() + 1)/3][2];\n\t\tfor(int i = 0; i < inputStr.length(); i += 3){\n\t\t\tint x = Integer.parseInt(\"\" + inputStr.charAt(i));\n\t\t\tint y = Integer.parseInt(\"\" + inputStr.charAt(i+1));\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\tif(res = solve(temp,i,j,count,i))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if(res = solve(temp,i,j,count,j)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count + \" open: \" + open);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int column=open;column<7;column++){\n\t\t\t\tif(column==sc){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(temp[open][column]){\n\t\t\t\t\ttemp[open][column] = false;\n\t\t\t\t\tres = solve(temp,open,column,count-1,column);\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int row=0;row<open;row++){\n\t\t\t\tif(row==sr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(temp[row][open]){\n\t\t\t\t\ttemp[row][open] = false;\n\t\t\t\t\tres = solve(temp,row,open,count-1,row);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[l][l];\n                        for(int i = 0;i < l; ++i){\n                                Arrays.fill(p[i],false);\n                        }\n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        for(int i = 0;i < n; ++i){\n                                s[i] = Integer.parseInt(ia[i]);\n                                p[(int)(Math.floor(s[i]/10)+0.1)][s[i]%10] = true;\n                        //      System.out.printf(\"%2d,%2d,%2d\\n\",s[i],(int)(Math.floor(s[i]/10)+0.1),s[i]%10);\n                        }\n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, l, (int)(Math.floor(s[i]/10)+0.1), s[i]%10, 0)){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }\n                        }\n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        }\n        static boolean mfs(boolean[][] p, int n, int x, int y, int f){\n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }   \n                if(p[x][y] == false){\n                        return false;\n                }   \n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }   \n                if(x == y){ \n                        f = 0;\n                }   \n                if(f != 1){ \n                        for(int i = y;i < n; ++i){\n                                if(mfs(p,n,y,i,2)){\n                                        return true;\n                                }\n                        }\n                        for(int i = 0;i <= y; ++i){\n                                if(mfs(p,n,i,y,1)){\n                                        return true;\n                                }\n                        }\n                }\n                if(f != 2){\n                        for(int i = 0;i <=x; ++i){\n                                if(mfs(p,n,i,x,1)){\n                                        return true;\n                                }\n                        }\n                        for(int i = x;i < n; ++i){\n                                if(mfs(p,n,x,i,2)){\n                                        return true;\n                                }\n                        }\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        int num,a,b,count,temp;\n        count=0;\n        boolean[] odd = new boolean[7];\n        boolean[] repdigit = new boolean[7];\n        boolean apart = false;\n        String str;\n        Scanner sc = new Scanner(System.in);\n        num = sc.nextInt();\n        sc.reset();\n        ArrayList<Integer> list = new ArrayList<Integer>(7){{\n            add(0);add(0);add(0);add(0);add(0);add(0);add(0);\n        }};\n        for(int i = 0 ; i < num ; i++){\n            str = sc.next();\n            a = Integer.parseInt(str.substring(0,1));\n            b = Integer.parseInt(str.substring(1,2));\n            if(a!=b) {\n                temp = list.get(a);\n                list.set(a, temp + 1);\n                temp = list.get(b);\n                list.set(b, temp + 1);\n            }else {\n                repdigit[a] = true;\n            }\n        }\n        for(int i=0 ; i<7; i++){\n            if(list.get(i)==0 && repdigit[i]){\n                apart = true;\n            }\n            if(list.get(i)%2!=0){\n                odd[i] = true;\n                count++;\n            }else{\n                odd[i] = false;\n            }\n        }\n        if((count==0 || count==2) && !apart){\n            System.out.println(\"Yes\");\n        }else{\n            System.out.println(\"No\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[l][l];\n                        for(int i = 0;i < l; ++i){\n                                Arrays.fill(p[i],false);\n                        }   \n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        for(int i = 0;i < n; ++i){\n                                s[i] = Integer.parseInt(ia[i]);\n                                p[s[i]%10][(int)(Math.floor(s[i]/10))] = true;\n                        }   \n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, l, s[i]%10, (int)(Math.floor(s[i]/10)))){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }   \n                        }   \n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        }\n        static boolean mfs(boolean[][] p, int n, int x, int y){ \n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }   \n                if(p[x][y] == false){\n                        return false;\n                }   \n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }   \n                boolean a = \n                        mfs(p,n,x-1,y) ||\n                        mfs(p,n,x+1,y) ||\n                        mfs(p,n,x,y-1) ||\n                        mfs(p,n,x,y+1);\n                if(a){\n                        return true;\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n        try {\n        \tString line;\n        \twhile((line=r.readLine())!=null){\n                /* input from here */\n        \t\tint n = Integer.parseInt(line);\n        \t\tString[] in = r.readLine().split(\" \");\n        \t\tboolean[][] b = new boolean[7][7];\n        \t\tboolean res = false;\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tArrays.fill(b[i], false);\n        \t\t}\n        \t\tfor(String s : in){\n        \t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n        \t\t}\n        \t\tint count = in.length;\n                /* input till here */\n                /* processing from here */\n        \t\tfor(int i=0;i<7;i++){\n        \t\t\tfor(int j=i;j<7;j++){\n        \t\t\t\tif(b[i][j]){\n        \t        \t\tif(res = solve(b,i,j,count)){\n        \t        \t\t\tbreak;\n        \t        \t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t\tif(res){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n                /* processing till here */\n                /* output */\n        \t\tif(res){\n        \t\t\tSystem.out.println(\"Yes\");\n        \t\t} else {\n        \t\t\tSystem.out.println(\"No\");\n        \t\t}\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static boolean solve(boolean[][] b, int sr,int sc, int count){\n    \tif(count==1){\n    \t\treturn true;\n    \t} else {\n    \t\t boolean[][] temp = b;\n    \t\t if(sc<6&&b[sr][sc+1]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr,sc+1,count-1);\n    \t\t }\n    \t\t if(sr<6&&b[sr+1][sc]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr+1,sc,count-1);\n    \t\t }\n    \t\t if(sc>0&&b[sr][sc-1]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr,sc-1,count-1);\n    \t\t }\n    \t\t if(sr>0&&b[sr-1][sc]){\n    \t\t\t temp[sr][sc] = false;\n    \t\t\t return solve(temp,sr-1,sc,count-1);\n    \t\t }\n    \t\t return false;\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is;\n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[l][l];\n                        for(int i = 0;i < l; ++i){\n                                Arrays.fill(p[i],false);\n                        }\n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        for(int i = 0;i < n; ++i){\n                                s[i] = Integer.parseInt(ia[i]);\n                                p[(int)(Math.floor(s[i]/10)+0.1)][s[i]%10] = true;\n                        //      System.out.printf(\"%2d,%2d,%2d\\n\",s[i],(int)(Math.floor(s[i]/10)+0.1),s[i]%10);\n                        }\n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, l, (int)(Math.floor(s[i]/10)+0.1), s[i]%10, 0)){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }\n                        }\n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        }\n        static boolean mfs(boolean[][] p, int n, int x, int y, int f){\n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }   \n                if(p[x][y] == false){\n                        return false;\n                }   \n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }   \n                if(x == y){ \n                        f = 0;\n                }   \n                if(f != 1){ \n                        for(int i = x;i < n; ++i){\n                                if(mfs(p,n,y,i,2)){\n                                        return true;\n                                }\n                        }\n                        for(int i = 0;i <= y; ++i){\n                                if(mfs(p,n,i,y,1)){\n                                        return true;\n                                }\n                        }\n                }\n                if(f != 2){\n                        for(int i = 0;i <=x; ++i){\n                                if(mfs(p,n,i,x,1)){\n                                        return true;\n                                }\n                        }\n                        for(int i = x;i < n; ++i){\n                                if(mfs(p,n,x,i,2)){\n                                        return true;\n                                }\n                        }\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\ttemp[i][i] = false;\n\t\t\t\t\t\t\tif(res = solve(temp,i,j,count,i))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if(res = solve(temp,i,j,count,j)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count + \" open: \" + open);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int column=open;column<7;column++){\n\t\t\t\tif(column==sc){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(temp[open][column]){\n\t\t\t\t\ttemp[open][column] = false;\n\t\t\t\t\tres = solve(temp,open,column,count-1,column);\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int row=0;row<=open;row++){\n\t\t\t\tif(row==sr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(temp[row][open]){\n\t\t\t\t\ttemp[row][open] = false;\n\t\t\t\t\tres = solve(temp,row,open,count-1,row);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"FAIL\");\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static int N;\n    public static int[] arr;\n    \n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(System.in);\n        \n        while (in.hasNextInt()) {\n            N = in.nextInt();\n            \n            arr = new int[N];\n            boolean[] visited = new boolean[N];\n            \n            for (int i = 0; i < N; i++) {\n                arr[i] = in.nextInt();\n            }\n            \n            boolean found = false;\n            for (int i = 0; i < N && !found; i++) {\n                visited[i] = true;\n                found = found || recursive(0, arr[i] % 10, visited, 1)\n                    || recursive(0, arr[i] / 10, visited, 1);\n                visited[i] = false;\n            }\n            \n            if (found) {\n                System.out.println(\"Yes\");\n            } else {\n                System.out.println(\"No\");\n            }\n        }\n    }\n    \n    public static boolean recursive(int pos, int n, boolean[] visited, int len) {\n        if (len == N) return true;\n        if (pos == N) return false;\n        \n        boolean ret = false;\n        int a = arr[pos] % 10;\n        int b = arr[pos] / 10;\n        int newNum = a == n ? b : a;\n        \n        if (visited[pos]) return recursive(pos+1, n, visited, len);\n        if (a != n && b != n) return recursive(pos+1, n, visited, len);\n        \n        visited[pos] = true;\n        ret = ret || recursive(0, newNum, visited, len+1);\n        visited[pos] = false;\n        ret = ret || recursive(pos+1, n, visited, len);\n        \n        return ret;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n\n                        int[][] num = new int[n][2];\n\n                        int[] count = new int[l];\n                        boolean[] p = new boolean[l];\n                        Arrays.fill(p,false);\n                        boolean[] use = new boolean[n];\n                        Arrays.fill(use,true);\n\n                        ia = in.readLine().split(\" \");\n                        for(int i = 0;i < n; ++i){\n                                int s = Integer.parseInt(ia[i]);\n                                num[i][0] = (int) (Math.floor(s/10)+0.01);\n                                num[i][1] = s%10;\n                                if(num[i][0] == num[i][1]){\n                                        p[num[i][0]] = true;\n                                        use[i] = false;\n                                }   \n                                ++count[num[i][0]];\n                                ++count[num[i][1]];\n                        }   \n\n                        int c = 0;\n                        for(int i = 0;i < l; ++i){\n                                if(count[i]%2 == 1){ \n                                        ++c;\n                                }   \n                        }   \n                        if(c != 2 && c != 0){ \n                                System.out.println(\"No\");\n                                continue;\n                        }   \n                        if(n == 1){ \n                                System.out.println(\"Yes\");\n                                continue;\n                        }   \n                        for(int i = 0;i < l; ++i){\n                                if(count[i] == 2 && p[i]){\n                                        System.out.println(\"No\");\n                                }   \n                        }   \n\n                        boolean yet = true;\n                        if(c == 2){ \n                                int[] a = new int[2];\n                                int b = 0;\n                                for(int i = 0;i < l; ++i){\n                                        if(count[i]%2 == 1){ \n                                                a[b] = i;\n                                                ++b;\n                                        }   \n                                }   \n                                for(int i = 0;i < n; ++i){\n                                        if(num[i][0] == a[0] || num[i][1] == a[0] ||\n                                           num[i][0] == a[1] || num[i][1] == a[1]){\n                                                if(mfs(num,use,i)){\n                                                        System.out.println(\"Yes\");\n                                                        yet = false;\n                                                        break;\n                                                }\n                                        }\n                                }\n                        } else if(mfs(num,use)){\n                                System.out.println(\"Yes\");\n                        }\n                        if(yet){\n                                System.out.println(\"No\");\n                        }\n                }\n        }\n        static boolean mfs(int[][] num, boolean[] use){\n                return mfs(num,use,-1);\n        }\n        static boolean mfs(int[][] num, boolean[] yet, int x){\n                int s,e;\n                if(x == -1){\n                        s = 0;  e = num.length;\n                } else {\n                        s = x;  e = x+1;\n                }\n                for(int i = s;i < e; ++i){\n                        if(mfw(num,yet,i,num[i][0])){\n                                return true;\n                        }\n                        if(mfw(num,yet,i,num[i][1])){\n                                return true;\n                        }\n                }\n                return false;\n        }\n        static boolean mfw(int[][] num, boolean[] yet, int n, int s){\n                yet[n] = false;\n                if(!chk(yet)){\n                        return true;\n                }\n                for(int i = 0;i < num.length; ++i){\n                        if(yet[i]){\n                                if(num[i][0] == s){\n                                        if(mfw(num,yet,i,num[i][1])){\n                                                return true;\n                                        }\n                                }\n                                if(num[i][1] == s){\n                                        if(mfw(num,yet,i,num[i][0])){\n                                                return true;\n                                        }\n                                }\n                        }\n                }\n                yet[n] = true;\n                return false;\n        }\n        static boolean chk(boolean[] p){\n                for(int i = 0;i < p.length; ++i){\n                        if(p[i]){\n                                return true;\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\ttemp[i][j] = false;\n\t\t\t\t\t\t\tif(res = solve(temp,i,j,count,i,\"\" + j + i)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if(res = solve(temp,i,j,count,j,\"\" + i + j)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemp[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open, String s){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count + \" open: \" + open);\n\t\tif(count==1){\n\t\t\ts.concat(\" \" + sr + sc);\n\t\t\t//System.out.println(s);\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\tif(column==sc){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b[open][column]){\n\t\t\t\t\tb[open][column] = false;\n\t\t\t\t\tres = solve(b,open,column,count-1,column,s+open+column);\n\t\t\t\t\tb[open][column] = true;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int row=0;row<=6;row++){\n\t\t\t\tif(row==sr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(b[row][open]){\n\t\t\t\t\tb[row][open] = false;\n\t\t\t\t\tres = solve(b,row,open,count-1,row,s+open+row);\n\t\t\t\t\tb[row][open] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"FAIL\");\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[l][l];\n                        for(int i = 0;i < l; ++i){\n                                Arrays.fill(p[i],false);\n                        }   \n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        for(int i = 0;i < n; ++i){\n                                s[i] = Integer.parseInt(ia[i]);\n                                p[(int)(Math.floor(s[i]/10))][s[i]%10] = true;\n                        }   \n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, l, (int)(Math.floor(s[i]/10)), s[i]%10, 0)){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }   \n                        }   \n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        }\n        static boolean mfs(boolean[][] p, int n, int x, int y, int f){ \n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }   \n                if(p[x][y] == false){\n                        return false;\n                }   \n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }   \n                if(f != 1){ \n                        for(int i = 0;i <= y; ++i){\n                                if(mfs(p,n,i,y,1)){\n                                        return true;\n                                }   \n                        }   \n                }   \n                if(f != 2){\n                        for(int i = x;i < n; ++i){\n                                if(mfs(p,n,x,i,2)){\n                                        return true;\n                                }\n                        }\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Dominoes Arrangement\npublic class Main{\n\n\tvoid f(int k){\n\t\tu[k] = true;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(!u[i]&&r[k][i])f(i);\n\t\t}\n\t}\n\t\n\tboolean[][] r;\n\tboolean[] u;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] c = new int[7];\n\t\t\tr = new boolean[7][7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tint a = s[0]-'0';\n\t\t\t\tint b = s[1]-'0';\n//\t\t\t\tif(a==b)continue;\n\t\t\t\tc[a]++;\n\t\t\t\tc[b]++;\n\t\t\t\tr[a][b] = r[b][a] = true;\n\t\t\t}\n\t\t\tu = new boolean[7];\n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tif(c[i]>0){\n\t\t\t\t\tf(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tfor(int i=0;i<7;i++)if(!u[i]&&c[i]>0)ok = false;\n\t\t\tint o = 0;\n\t\t\tfor(int i=0;i<7;i++)if(c[i]%2==1)o++;\n\t\t\tSystem.out.println((o==0||o==2)&&ok?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args){\n        int num,a,b,c,count,temp;\n        count=0;\n        boolean[] odd = new boolean[7];\n        String str;\n        Scanner sc = new Scanner(System.in);\n        num = sc.nextInt();\n        sc.reset();\n        ArrayList<Integer> list = new ArrayList<>(Arrays.asList(0,0,0,0,0,0,0));\n\n        //[0-6]がそれぞれいくつあるか数える\n        for(int i = 0 ; i < num ; i++){\n            str = sc.next();\n            a = Integer.parseInt(str.substring(0,1));\n            b = Integer.parseInt(str.substring(1,2));\n            if(a!=b) {\n                temp = list.get(a);\n                list.set(a, temp + 1);\n                temp = list.get(b);\n                list.set(b, temp + 1);\n            }\n        }\n        //それぞれ数えて奇数個あればその数字が分かるようにする\n        for(int i=0 ; i<7; i++){\n            if(list.get(i)%2!=0){\n                odd[i]=true;\n                count++;\n            }else{\n                odd[i]=false;\n            }\n\n        }\n        //奇数個の数字が2種類あり、かつその2数を持つドミノが存在しなければ、整列させることができる（多分）\n        if(count==2){\n            c=0;\n            str = \"\";\n            for(boolean t: odd){\n                if(t){\n                    str = str + Integer.toString(c);\n                }\n                c++;\n            }\n            if(list.contains(Integer.parseInt(str))){\n                System.out.println(\"No\");\n            }else{\n                System.out.println(\"Yes\");\n            }\n        }else{\n            System.out.println(\"No\");\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Math.min(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))][Math.max(Integer.parseInt(s.substring(0,1)),Integer.parseInt(s.substring(1)))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\ttemp[i][j] = false;\n\t\t\t\t\t\t\tif(res = solve(temp,i,j,count,i))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if(res = solve(temp,i,j,count,j)){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count + \" open: \" + open);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int column=open;column<7;column++){\n\t\t\t\tif(column==sc){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(temp[open][column]){\n\t\t\t\t\ttemp[open][column] = false;\n\t\t\t\t\tres = solve(temp,open,column,count-1,column);\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int row=0;row<open;row++){\n\t\t\t\tif(row==sr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(res){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(temp[row][open]){\n\t\t\t\t\ttemp[row][open] = false;\n\t\t\t\t\tres = solve(temp,row,open,count-1,row);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(sc.hasNextInt()){\n\t\t\tint n = sc.nextInt();\n\n\t\t\tboolean[][] map = new boolean[7][7];\n\t\t\tint start = -1;\n\t\t\tboolean[] nodeFlg = new boolean[7];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tint from = s.charAt(0) - '0';\n\t\t\t\tint to = s.charAt(1) - '0';\n\n\t\t\t\tnodeFlg[from] = nodeFlg[to] = true;\n\t\t\t\tif(from != to){\n\t\t\t\t\tmap[from][to] = map[to][from] = true;\n\t\t\t\t\tstart = from;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nodeCount = 0;\n\t\t\tfor(int i=0;i<7;i++) if(nodeFlg[i]) nodeCount++;\n\n\t\t\tif(start == -1){\n\t\t\t\tSystem.out.println(nodeCount==1 ? \"Yes\" : \"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(reachableCount(start,map,new boolean[7]) != nodeCount){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSystem.out.println(isEulerGraph(map,nodeCount) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate static int reachableCount(int from,boolean[][] map,boolean[] flg){\n\t\tint res = 1;\n\n\t\tflg[from] = true;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(map[from][i] && !flg[i]){\n\t\t\t\tres += reachableCount(i,map,flg);\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static boolean isEulerGraph(boolean[][] map,int nodeCount){\n\t\tint n = map.length;\n\t\tint evenCount = 0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i != j && map[i][j]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count != 0 && count % 2 == 0) evenCount++;\n\t\t}\n\t\tif(evenCount == nodeCount || evenCount == nodeCount-2) return true;\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// 最初はドミノの数が入力される\n\t\t\t\tint n = Integer.parseInt(str);\n\n\t\t\t\t// 次にはドミノが入力される\n\t\t\t\tint inputedDominoCount = 0;\n\t\t\t\tint valuesCount[] = new int[7];\n\t\t\t\twhile(inputedDominoCount < n){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\t}catch(Exception e){}\n\t\t\t\t\tint nowInputValuesCount[] = calcDomino(str);\n\t\t\t\t\tfor(int i = 0; i < 7; i++){\n\t\t\t\t\t\tvaluesCount[i] += nowInputValuesCount[i];\n\t\t\t\t\t}\n\t\t\t\t\tinputedDominoCount += nowInputValuesCount[7];\n\t\t\t\t\t//System.out.println(\"inputedDominoCount: \" + inputedDominoCount);\n\t\t\t\t}\n\t\t\t\t//printArray(valuesCount);\n\n\t\t\t\t// 値のチェック\n\t\t\t\tint oddCount = 0;\n\t\t\t\tfor(int i = 0; i < valuesCount.length; i++){\n\t\t\t\t\tif(valuesCount[i] % 2 == 1){\n\t\t\t\t\t\toddCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(oddCount <= 2){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\t//System.err.println(e);\n\t\t}\n\t}\n\n\tstatic int[] calcDomino(String inputStr){\n\t\tint result[] = new int[8];\n\t\tfor(int i = 0; i < inputStr.length(); i++){\n\t\t\tchar pointingChar = inputStr.charAt(i);\n\t\t\tif(pointingChar == ' '){\n\t\t\t}else{\n\t\t\t\tresult[Integer.parseInt(\"\" + pointingChar)]++;\n\t\t\t\tresult[7]++;\n\t\t\t}\n\t\t}\n\t\tresult[7] = result[7] / 2;\n\t\treturn result;\n\t}\n\n\tstatic void printArray(int[] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.println(i + \": \" + array[i]);\n\t\t}\n\t}\n\n\tstatic int[][] parseDomino(String inputStr){\n\t\tint result[][] = new int[(inputStr.length() + 1)/3][2];\n\t\tfor(int i = 0; i < inputStr.length(); i += 3){\n\t\t\tint x = Integer.parseInt(\"\" + inputStr.charAt(i));\n\t\t\tint y = Integer.parseInt(\"\" + inputStr.charAt(i+1));\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\t/* input from here */\n\t\t\t\tint n = Integer.parseInt(line);\n\t\t\t\tString[] in = r.readLine().split(\" \");\n\t\t\t\tboolean[][] b = new boolean[7][7];\n\t\t\t\tboolean res = false;\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tArrays.fill(b[i], false);\n\t\t\t\t}\n\t\t\t\tfor(String s : in){\n\t\t\t\t\tb[Integer.parseInt(s.substring(0,1))][Integer.parseInt(s.substring(1))] = true;\n\t\t\t\t}\n\t\t\t\tint count = in.length;\n\t\t\t\t/* input till here */\n\n\t\t\t\tboolean[][] temp = new boolean[7][7];        \t\t\t\t\t\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing from here */\n\t\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\t\tfor(int j=i;j<7;j++){\n\t\t\t\t\t\tif(b[i][j]){\n\t\t\t\t\t\t\t//System.out.println(\"start: \" + i + \" \" + j);\n\t\t\t\t\t\t\tres = solve(temp,i,j,count,1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing till here */\n\t\t\t\t/* output */\n\t\t\t\tif(res){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static boolean solve(boolean[][] b, int sr,int sc, int count,int open){\n\t\tboolean res = false;\n\t\t//System.out.println(\"current: \" + sr + \" \" + sc + \" count:\" + count);\n\t\tif(count==1){\n\t\t\treturn true;\n\t\t} else {\t\t\t\n\t\t\tboolean[][] temp = new boolean[7][7]; \n\t\t\tfor(int i=0;i<7;i++){\n\t\t\t\tfor(int j=0;j<7;j++){\n\t\t\t\t\ttemp[i][j] = b[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open<2){\n\t\t\t\tfor(int column=0;column<7;column++){\n\t\t\t\t\tif(column==sc){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[sr][column]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,sr,column,count-1,2);\n\t\t\t\t\t}\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open>0){\n\t\t\t\tfor(int row=0;row<7;row++){\n\t\t\t\t\tif(res){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(row==sr){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(b[row][sc]){\n\t\t\t\t\t\ttemp[sr][sc] = false;\n\t\t\t\t\t\tres = solve(temp,row,sc,count-1,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(res){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nclass Main{\n\tpublic static void main(String args[]){\n\t\tnew Main().dominoesArrangement();\n\t}\n\n\tint values[];\n\tint inputedDominoCount;\n\tint maxDominoCount;\n\tint maxValue;\n\tint minValue;\n\tboolean isExistDomino[][];\n\tboolean isConnected[];\n\n\tpublic void dominoesArrangement(){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// 最初はドミノの数が入力される\n\t\t\t\tmaxDominoCount = Integer.parseInt(str);\n\n\t\t\t\t// 初期化\n\t\t\t\tvalues = new int[7];\n\t\t\t\tinputedDominoCount = 0;\n\t\t\t\tisExistDomino = new boolean[7][7];\n\t\t\t\tisConnected = new boolean[7];\n\n\t\t\t\twhile(inputedDominoCount < maxDominoCount){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\t}catch(Exception e){}\n\t\t\t\t\tparseDomino(str);\n\t\t\t\t\t//System.out.println(\"inputedDominoCount: \" + inputedDominoCount);\n\t\t\t\t}\n\t\t\t\t//printArray(values);\n\t\t\t\t//printArray(isExistDomino);\n\n\n\t\t\t\t// 最小値を求める\n\t\t\t\tfor(minValue = 0; minValue < values.length; minValue++){\n\t\t\t\t\tif(values[minValue] != 0) break;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"最小値:\" + minValue);\n\n\t\t\t\t// ノードの偶奇チェック\n\t\t\t\t// ついでに最小値も求める\n\t\t\t\tint oddCount = 0;\n\t\t\t\tfor(int i = minValue; i < values.length; i++){\n\t\t\t\t\tif(values[i] % 2 == 1) oddCount++;\n\t\t\t\t}\n\t\t\t\t// 奇数のノードが2より多かったらまず無理\n\t\t\t\tif(oddCount > 2){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// 最小値から深さ優先探索\n\t\t\t\tserch(minValue);\n\t\t\t\t//printArray(isConnected);\n\n\t\t\t\t// 行きたいノードがちゃんと全部接続されているか\n\t\t\t\tboolean noFlag = false;\n\t\t\t\tfor(int i = minValue; i < values.length; i++){\n\t\t\t\t\tif(values[i] != 0){\n\t\t\t\t\t\t//System.out.println(i + \": 値が0でない\");\n\t\t\t\t\t\tif(!isConnected[i]){\n\t\t\t\t\t\t\tnoFlag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(noFlag){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\t//System.err.println(e);\n\t\t}\n\t}\n\n\tvoid parseDomino(String inputStr){\n\t\tfor(int i = 0; i < inputStr.length(); i++){\n\t\t\tint counter = 0;\n\t\t\tif(inputStr.charAt(i) == ' '){\n\t\t\t\t// 空白はスルー\n\t\t\t}else{\n\t\t\t\tint x = Integer.parseInt(\"\" + inputStr.charAt(i));\n\t\t\t\tint y = Integer.parseInt(\"\" + inputStr.charAt(i+1));\n\t\t\t\ti++;\n\t\t\t\tvalues[x]++;\n\t\t\t\tvalues[y]++;\n\t\t\t\tisExistDomino[x][y] = true;\n\t\t\t\tisExistDomino[y][x] = true;\n\t\t\t\tinputedDominoCount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid printArray(int[] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.println(i + \": \" + array[i]);\n\t\t}\n\t}\n\n\tvoid printArray(boolean[] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.println(i + \": \" + array[i]);\n\t\t}\n\t}\n\n\tvoid printArray(boolean[][] array){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tfor(int j = 0; j < array[i].length; j++){\n\t\t\t\tSystem.out.print(array[i][j] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tvoid serch(int n){\n\t\tif(isConnected[n]) return;\n\t\t// System.out.println(n + \"を探索\");\n\t\tisConnected[n] = true;\n\t\tfor(int i = 0; i <= 6; i++){\n\t\t\tif(i == n) continue;\n\t\t\tif(isExistDomino[n][i])\n\t\t\t\tserch(i);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        new Main().dominoesArrangement();\n    }\n    Map<String, Integer> dominoMasterMap;\n    String oddLine;\n    String evenLine;\n    String[] dominoArray;\n    List<Integer> sortNoList;\n\n    public void dominoesArrangement() throws IOException {\n        //create domino master\n        dominoMasterMap = new HashMap<String, Integer>();\n        int sortNo = 0;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j <= i; j++) {\n                dominoMasterMap.put(String.valueOf(j) + i, sortNo++);\n            }\n        }\n\n        //read input file\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        do {\n            oddLine = br.readLine();\n            if (oddLine != null) {\n                evenLine = br.readLine();\n            }\n            dominoArray = evenLine.split(\" \");\n            for (int i = 0; i < Integer.parseInt(oddLine); i++) {\n                //change input no to diamond master\n                sortNoList.add(dominoMasterMap.get(dominoArray[i]));\n            }\n\n            boolean sortFlg = false;\n            Integer pastNo = null;\n            for (Integer no : sortNoList) {\n                if (no == null) {\n                    pastNo = no;\n                    continue;\n                }\n                if (pastNo > no) {\n                    sortFlg = true;\n                    break;\n                }\n                pastNo = no;\n            }\n\n            //judge is sort no right\n            if (sortFlg) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"No\");\n            }\n        } while (oddLine != null);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                String is; \n                String ia[];\n                while((is = in.readLine()) != null){\n                        int l = 7;\n                        int n = Integer.parseInt(is);\n                        boolean[][] p = new boolean[l][l];\n                        for(int i = 0;i < l; ++i){\n                                Arrays.fill(p[i],false);\n                        }   \n                        ia = in.readLine().split(\" \");\n                        int[] s = new int[n];\n                        int[] tmp = new int[l];\n                        for(int i = 0;i < n; ++i){\n                                s[i] = Integer.parseInt(ia[i]);\n                                int a = (int)(Math.floor(s[i]/10)+0.1);\n                                ++tmp[a];\n                                int b = s[i]%10;\n                                ++tmp[b];\n                                p[a][b]= true;\n                        }   \n                        int c = 0;\n                        for(int i = 0;i < l; ++i){\n                                if(tmp[i]%2 == 1){ \n                                        ++c;\n                                }   \n                        }   \n                        if(c != 2){ \n                                System.out.println(\"No\");\n                                continue;\n                        }   \n                        boolean yet = true;\n                        for(int i = 0;i < n; ++i){\n                                if(mfs(p, l, (int)(Math.floor(s[i]/10)+0.1), s[i]%10, 0)){\n                                        System.out.println(\"Yes\");\n                                        yet = false;\n                                        break;\n                                }   \n                        }   \n                        if(yet){\n                                System.out.println(\"No\");\n                        }   \n                }   \n        } \n        static boolean mfs(boolean[][] p, int n, int x, int y, int f){ \n                if(x < 0 || n <= x || y < 0 || n <= y){ \n                        return false;\n                }\n                if(p[x][y] == false){\n                        return false;\n                }\n                p[x][y] = false;\n                if(!chk(p,n)){\n                        return true;\n                }\n                if(f != 1){\n                        for(int i = 0;i <= y; ++i){\n                                if(mfs(p,n,i,y,1)){\n                                        return true;\n                                }\n                        }\n                        for(int i = y;i < n; ++i){\n                                if(mfs(p,n,y,i,2)){\n                                        return true;\n                                }\n                        }\n                }\n                if(f != 2){\n                        for(int i = 0;i <=x; ++i){\n                                if(mfs(p,n,i,x,1)){\n                                        return true;\n                                }\n                        }\n                        for(int i = x;i < n; ++i){\n                                if(mfs(p,n,x,i,2)){\n                                        return true;\n                                }\n                        }\n                }\n                p[x][y] = true;\n                return false;\n        }\n        static boolean chk(boolean[][] p, int n){\n                for(int i = 0;i < n; ++i){\n                        for(int j = 0;j < n; ++j){\n                                if(p[i][j]){\n                                        return true;\n                                }\n                        }\n                }\n                return false;\n        }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine();\n\t\t\tif(s==null)break;\n\t\t\tSol mySol = new Sol(int.Parse(s));\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\tbool[,] ARR_ADJ;\n\t\n\tint Ndomino;\n\tpublic Sol(int d){\n\t\tNdomino=d;\n\t\tARR_ADJ=new bool[7,7];\n\t\tfor(int i=0;i<7;i++)for(int j=0;j<7;j++)ARR_ADJ[i,j]=false;\n\t\t\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tfor(int i=0;i<d;i++){\n\t\t\tARR_ADJ[s[i][0]-'0',s[i][1]-'0']=true;\n\t\t\tARR_ADJ[s[i][1]-'0',s[i][0]-'0']=true;\n\t\t}\n\t\t\n\t\tint maxlen=cal_maxlen();\n\t\tif(maxlen==d)ans=\"Yes\";\n\t\tif(maxlen!=d)ans=\"No\";\n\t}\n\t\n\tint cal_maxlen(){\n\t\tint len;\n\t\tdfs_lenmax=0;//DFS(,)のstatic local変数(として使っている)をリセット。。。\n\t\tfor(int i=0;i<7;i++){\n\t\t\tlen=0;\n\t\t\tDFS(i,len);\n\t\t}\n\t\treturn dfs_lenmax;\n\t}\n\t\n\t\n\tint dfs_lenmax;//Cで言うstatic local変数(として使っている)\n\tvoid DFS(int now,int length){\n\t\t//Stop check;\n\t\tint chk=0;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i])chk++;\n\t\t}\n\t\tif(chk==0){\n\t\t\tif(dfs_lenmax<length)dfs_lenmax=length;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//search(depth-first)\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i]){\n\t\t\t\tARR_ADJ[now,i]=false;\n\t\t\t\tARR_ADJ[i,now]=false;\n\t\t\t\tDFS(i,length+1);\n\t\t\t\tARR_ADJ[now,i]=true;\n\t\t\t\tARR_ADJ[i,now]=true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine();\n\t\t\tif(s==null)break;\n\t\t\tSol mySol = new Sol(int.Parse(s));\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\tbool[,] ARR_ADJ;\n\t\n\tint Ndomino;\n\tpublic Sol(int d){\n\t\tNdomino=d;\n\t\tARR_ADJ=new bool[7,7];\n\t\tfor(int i=0;i<7;i++)for(int j=0;j<7;j++)ARR_ADJ[i,j]=false;\n\t\t\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tfor(int i=0;i<d;i++){\n\t\t\tARR_ADJ[s[i][0]-'0',s[i][1]-'0']=true;\n\t\t\tARR_ADJ[s[i][1]-'0',s[i][0]-'0']=true;\n\t\t}\n\t\t\n\t\tint maxlen=cal_maxlen();\n\t\tif(maxlen==Ndomino)ans=\"Yes\";\n\t\tif(maxlen!=Ndomino)ans=\"No\";\n\t}\n\t\n\tint cal_maxlen(){\n\t\tint len;\n\t\tdfs_lenmax=0;//DFS(,)のstatic local変数(として使っている)をリセット。。。\n\t\tfor(int i=0;i<7;i++){\n\t\t\tlen=0;\n\t\t\tDFS(i,len);\n\t\t}\n\t\treturn dfs_lenmax;\n\t}\n\t\n\t\n\tint dfs_lenmax;//Cで言うstatic local変数(として使っている)\n\tvoid DFS(int now,int length){\n\t\t//Stop check;\n\t\tif(dfs_lenmax==Ndomino)return;\n\t\tint chk=0;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i])chk++;\n\t\t}\n\t\tif(chk==0){\n\t\t\tif(dfs_lenmax<length)dfs_lenmax=length;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//search(depth-first)\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i]){\n\t\t\t\tARR_ADJ[now,i]=false;\n\t\t\t\tARR_ADJ[i,now]=false;\n\t\t\t\tDFS(i,length+1);\n\t\t\t\tARR_ADJ[now,i]=true;\n\t\t\t\tARR_ADJ[i,now]=true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar s=Console.ReadLine();\n\t\t\tif(s==null)break;\n\t\t\tSol mySol = new Sol(int.Parse(s));\n\t\t\tConsole.WriteLine(mySol.Ans);\n\t\t}\n\t}\n}\n\nclass Sol{\n\tString ans;\n\tpublic String Ans{\n\t\tget{return ans;}\n\t}\n\t\n\tbool[,] ARR_ADJ;\n\t\n\tint Ndomino;\n\tpublic Sol(int d){\n\t\tNdomino=d;\n\t\tARR_ADJ=new bool[7,7];\n\t\tfor(int i=0;i<7;i++)for(int j=0;j<7;j++)ARR_ADJ[i,j]=false;\n\t\t\n\t\tvar s=Console.ReadLine().Split(' ');\n\t\tfor(int i=0;i<d;i++){\n\t\t\tARR_ADJ[s[i][0]-'0',s[i][1]-'0']=true;\n\t\t\tARR_ADJ[s[i][1]-'0',s[i][0]-'0']=true;\n\t\t}\n\t\t\n\t\tint maxlen=cal_maxlen();\n\t\tif(maxlen==Ndomino)ans=\"Yes\";\n\t\tif(maxlen!=Ndomino)ans=\"No\";\n\t}\n\t\n\tint cal_maxlen(){\n\t\tint len;\n\t\tdfs_lenmax=0;//DFS(,)のstatic local変数(として使っている)をリセット。。。\n\t\tfor(int i=0;i<7;i++){\n\t\t\tlen=0;\n\t\t\tDFS(i,len);\n\t\t}\n\t\treturn dfs_lenmax;\n\t}\n\t\n\t\n\tint dfs_lenmax;//Cで言うstatic local変数(として使っている)\n\tvoid DFS(int now,int length){\n\t\t//Stop check;\n\t\tint chk=0;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i])chk++;\n\t\t}\n\t\tif(chk==0){\n\t\t\tif(dfs_lenmax<length)dfs_lenmax=length;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//search(depth-first)\n\t\tfor(int i=0;i<7;i++){\n\t\t\tif(ARR_ADJ[now,i]){\n\t\t\t\tARR_ADJ[now,i]=false;\n\t\t\t\tARR_ADJ[i,now]=false;\n\t\t\t\tDFS(i,length+1);\n\t\t\t\tARR_ADJ[now,i]=true;\n\t\t\t\tARR_ADJ[i,now]=true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  STDIN.readline\n\n  parity = [0, 0, 0, 0, 0, 0, 0]\n\n  line = STDIN.readline.chomp\n\n  line.each_char do |c|\n    next if c == \" \"\n    parity[c.to_i] ^= 1\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n\n  if [0, 2].include? odd_numbers\n    puts \"Yes\"\n  else\n    puts \"No\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n  def initialize\n    @parent = Hash.new\n    @rank = Hash.new\n  end\n  def make(x)\n    @parent[x] = x\n    @rank[x] = 0\n  end\n  def union(a, b)\n    x, y = find(a), find(b)\n    x, y = y, x if @rank[x] < @rank[y]\n    @parent[y] = x\n    @rank[x] += 1 if @rank[x] == @rank[y]\n  end\n  def find(x)\n    @parent[x] == x ? x : @parent[x] = find(@parent[x])\n  end\n  def size\n    @parent.keys.map{|k| find(k)}.sort.uniq.size\n  end\nend\n\nwhile gets\n  subset = gets.split.map{|d| d.chars.map(&:to_i)}\n  disjoint_set = UnionFind.new\n  degree = Hash.new{0}\n\n  subset.flatten.sort.uniq.each do |d|\n    disjoint_set.make(d)\n  end\n\n  subset.each do |d|\n    degree[d.first] += 1\n    degree[d.last] += 1\n    disjoint_set.union(*d)\n  end\n\n  puts disjoint_set.size == 1 && degree.select{|k, v| v.odd?}.size <= 2 ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "YES, NO = 0, 1\n@memo = Hash.new\ndef dfs(subset, last = nil)\n  return @memo[[subset, last]] = YES if subset.empty?\n  return @memo[[subset, last]] if @memo[[subset, last]]\n\n  subset.each do |domino|\n    if !last || last == domino[0]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[1]) == YES\n    end\n    if !last || last == domino[1]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[0]) == YES\n    end\n  end\n\n  @memo[[subset, last]] = NO\nend\n\nwhile gets\n  subset = gets.split.sort.map{|d| d.chars.map(&:to_i)}\n  count = Array.new(7){0}\n  subset.each do |domino|\n    domino.each do |n| count[n] += 1 end\n  end\n  single = count.select{|n| n == 1}\n\n  if single.size == 1\n    puts \"No\"\n    next\n  end\n\n  puts dfs(subset) == YES ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def hantei(dominoes)\n  return \"Yes\" if dominoes.size == 1\n\n  parity = []\n  domino_exists = []\n  same_domino_exists = []\n  7.times do\n    parity << 0\n    domino_exists << false\n    same_domino_exists << false\n  end\n\n  dominoes.each do |domino|\n    if domino[0] == domino[1]\n      same_domino_exists[domino[0].to_i] = true\n      next\n    end\n\n    domino.each_char do |num|\n      parity[num.to_i] ^= 1\n      domino_exists[num.to_i] = true\n    end\n  end\n\n  7.times do |i|\n    if same_domino_exists[i] && !domino_exists[i]\n      return \"No\"\n    end\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n  if [0, 2].include? odd_numbers\n    return \"Yes\"\n  else\n    return \"No\"\n  end\nend\n\nloop do\n  STDIN.readline rescue break\n\n  dominoes = STDIN.readline.chomp.split(\" \")\n  puts hantei(dominoes)\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  STDIN.readline rescue break\n\n  parity = [0, 0, 0, 0, 0, 0, 0]\n\n  dominoes = STDIN.readline.chomp.split(\" \")\n  dominoes.each do |domino|\n    next if domino[0] == domino[1]\n\n    domino.each do |num|\n      parity[num.to_i] ^= 1\n    end\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n\n  if [0, 2].include? odd_numbers\n    puts \"Yes\"\n  else\n    puts \"No\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "YES, NO = 0, 1\n@memo = Hash.new\ndef dfs(subset, last = nil)\n  return @memo[[subset, last]] = YES if subset.empty?\n  return @memo[[subset, last]] if @memo[[subset, last]]\n\n  subset.each do |domino|\n    if !last || last == domino[0]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[1]) == YES\n    end\n    if !last || last == domino[1]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[0]) == YES\n    end\n  end\n\n  @memo[[subset, last]] = NO\nend\n\nwhile gets\n  subset = gets.split.sort.map{|d| d.chars.map(&:to_i)}\n  count = Array.new(7){0}\n  subset.each do |domino|\n    domino.each do |n| count[n] += 1 end\n  end\n  single = count.select{|n| n == 1}\n\n  if single.size > 2\n    puts \"No\"\n    next\n  end\n\n  puts dfs(subset) == YES ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "YES, NO = 0, 1\n@memo = Hash.new\ndef dfs(subset, last = nil)\n  return @memo[[subset, last]] = YES if subset.empty?\n  return @memo[[subset, last]] if @memo[[subset, last]]\n\n  subset.each do |domino|\n    if !last || last == domino[0]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[1]) == YES\n    end\n    if !last || last == domino[1]\n      return @memo[[subset, last]] = YES if dfs(subset - [domino], domino[0]) == YES\n    end\n  end\n\n  @memo[[subset, last]] = NO\nend\n\nputs dfs(gets.split.sort) == YES ? \"Yes\" : \"No\" while gets"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_N = 7\n\n### main\n\nwhile line = gets\n  n = line.strip.to_i\n\n  nodes = MAX_N.times.map{false}\n  nbrs = MAX_N.times.map{[]}\n  start = nil\n\n  for dmn in gets.strip.split(' ')\n    ai = dmn[0].to_i\n    bi = dmn[1].to_i\n\n    start = ai\n    nodes[ai] = nodes[bi] = true\n\n    if ai != bi\n      nbrs[ai] << bi\n      nbrs[bi] << ai\n    end\n  end\n\n  reached = MAX_N.times.map{false}\n  reached[start] = true\n\n  q = [start]\n\n  while ! q.empty?\n    u = q.shift\n\n    for v in nbrs[u]\n      if ! reached[v]\n        reached[v] = true\n        q << v\n      end\n    end\n  end\n\n  ok = true\n  odd_n = 0\n\n  for i in (0...MAX_N)\n    if nodes[i] && ! reached[i]\n      ok = false\n      break\n    end\n    if (nbrs[i].length & 1) == 1\n      odd_n += 1\n    end\n  end\n\n  ok = false if odd_n > 2\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "def hantei(dominoes)\n  parity = []\n  domino_exists = []\n  same_domino_exists = []\n  7.times do\n    parity << 0\n    domino_exists << false\n    same_domino_exists << false\n  end\n\n  dominoes.each do |domino|\n    if domino[0] == domino[1]\n      same_domino_exists[domino[0].to_i] = true\n      next\n    end\n\n    domino.each_char do |num|\n      parity[num.to_i] ^= 1\n      domino_exists[num.to_i] = true\n    end\n  end\n\n  7.times do |i|\n    if same_domino_exists[i] && !domino_exists[i]\n      return \"No\"\n    end\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n  if [0, 2].include? odd_numbers\n    return \"Yes\"\n  else\n    return \"No\"\n  end\nend\n\nloop do\n  STDIN.readline rescue break\n\n  dominoes = STDIN.readline.chomp.split(\" \")\n  puts hantei(dominoes)\nend"
  },
  {
    "language": "Ruby",
    "code": "def hantei(dominoes)\n  return \"Yes\" if dominoes.size == 1\n\n  parity = []\n  domino_exists = []\n  same_domino_exists = []\n  7.times do\n    parity << 0\n    domino_exists << false\n    same_domino_exists << false\n  end\n\n  dominoes.each do |domino|\n    if domino[0] == domino[1]\n      same_domino_exists[domino[0].to_i] = true\n      next\n    end\n\n    domino.each_char do |num|\n      parity[num.to_i] ^= 1\n      domino_exists[num.to_i] = true\n    end\n  end\n\n  7.times do |i|\n    if same_domino_exists[i] && !domino_exists[i]\n      return \"No\"\n    end\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n  if [0, 2].include? odd_numbers\n    return \"Yes\"\n  else\n    return \"No\"\n  end\nend\n\nloop do\n  STDIN.readline rescue break\n\n  dominoes = STDIN.readline.chomp.split(\" \")\n  puts hantei(dominoes)\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  break unless STDIN.readline\n\n  parity = [0, 0, 0, 0, 0, 0, 0]\n\n  line = STDIN.readline.chomp\n\n  line.each_char do |c|\n    next if c == \" \"\n    parity[c.to_i] ^= 1\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n\n  if [0, 2].include? odd_numbers\n    puts \"Yes\"\n  else\n    puts \"No\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n  def initialize\n    @parent = Hash.new\n    @rank = Hash.new\n  end\n  def make(x)\n    @parent[x] = x\n    @rank[x] = 0\n  end\n  def union(x, y)\n    a = find(x)\n    b = find(y)\n    if @rank[a] > @rank[b]\n      @parent[b] = a\n    elsif @rank[a] < @rank[b]\n      @parent[a] = b\n    elsif a != b\n      @parent[b] = a\n      @rank[a] = @rank[a] + 1\n    end\n  end\n  def find(x)\n    @parent[x] == x ? x : @parent[x] = find(@parent[x])\n  end\n  def size\n    @parent.keys.map{|k| find(k)}.sort.uniq.size\n  end\nend\n\nwhile gets\n  subset = gets.split.map{|d| d.chars.map(&:to_i)}\n  disjoint_set = UnionFind.new\n  degree = Hash.new{0}\n\n  subset.flatten.sort.uniq.each do |d|\n    disjoint_set.make(d)\n  end\n\n  subset.each do |d|\n    degree[d.first] += 1\n    degree[d.last] += 1\n    disjoint_set.union(*d)\n  end\n\n  puts disjoint_set.size == 1 && degree.select{|k, v| v.odd?}.size <= 2 ? \"Yes\" : \"No\"\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  STDIN.readline rescue break\n\n  parity = [0, 0, 0, 0, 0, 0, 0]\n\n  line = STDIN.readline.chomp\n\n  line.each_char do |c|\n    next if c == \" \"\n    parity[c.to_i] ^= 1\n  end\n\n  odd_numbers = parity.select { |p| p == 1 }.size\n\n  if [0, 2].include? odd_numbers\n    puts \"Yes\"\n  else\n    puts \"No\"\n  end\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    string[] A;\n    \n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (stdin.eof) return false;\n        A = readln.chomp.split(\" \").array;\n        \n        bool[] del = new bool[N];\n        foreach (i; 0 .. N) {\n            if (A[i][0] == A[i][1]) {\n                char c = A[i][0];\n                foreach (j; 0 .. N) {\n                    if (i == j) continue;\n                    if (A[j][0] == c || A[j][1] == c) {\n                        del[i] = true;\n                    }\n                }\n            }\n        }\n        int nN; string[] nA;\n        foreach (i; 0 .. N) {\n            if (!del[i]) {\n                nN++;\n                nA ~= A[i];\n            }\n        }\n        N = nN;\n        A = nA;\n        return true;\n    }\n\n    auto memo = new byte[][](21, 1 << 21);\n\n    bool hasEdge(int last, in string s) {\n        char l = cast(char)(last + '0');\n        foreach (i; 0 .. 2) {\n            if (l == s[i]) return true;\n        }\n        return false;\n    }\n\n    void solve() {\n        //writeln(A);\n        foreach (i; 0 .. N) memo[i][] = -1;\n        bool dfs(int last, int bit) {\n            if (bit == (1 << N) - 1) return 1;\n            if (memo[last][bit] >= 0) return memo[last][bit] == 1;\n            foreach (i; 0 .. N) {\n                if (bit & (1 << i)) continue;\n                char l = cast(char)(last + '0');\n                if (l == A[i][0] || l == A[i][1]) {\n                    int nlast = (l == A[i][0] ? A[i][1] : A[i][0]) - '0'; \n                    if (dfs(nlast, bit | (1 << i))) {\n                        memo[last][bit] = 1;\n                        //writeln(i);\n                        return true;\n                    }\n                }\n            }\n            memo[last][bit] = 0;\n            return false;\n        }\n\n        bool Ans = false;\n        foreach (i; 0 .. N) {\n            int l = A[i][0] - '0';\n            Ans |= dfs(l, 1 << i);\n            l = A[i][1] - '0';\n            Ans |= dfs(l, 1 << i);\n        }\n        writeln(Ans ? \"Yes\" : \"No\");\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N;\n    string[] A;\n    \n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (stdin.eof) return false;\n        A = readln.chomp.split(\" \").array;\n        \n        bool[] del = new bool[N];\n        foreach (i; 0 .. N) {\n            if (A[i][0] == A[i][1]) {\n                char c = A[i][0];\n                foreach (j; 0 .. N) {\n                    if (i == j) continue;\n                    if (A[j][0] == c || A[j][1] == c) {\n                        del[i] = true;\n                    }\n                }\n            }\n        }\n        int nN; string[] nA;\n        foreach (i; 0 .. N) {\n            if (!del[i]) {\n                nN++;\n                nA ~= A[i];\n            }\n        }\n        N = nN;\n        A = nA;\n        return true;\n    }\n\n    auto memo = new byte[][](7, 1 << 21);\n\n    bool hasEdge(int last, in string s) {\n        char l = cast(char)(last + '0');\n        foreach (i; 0 .. 2) {\n            if (l == s[i]) return true;\n        }\n        return false;\n    }\n\n    void solve() {\n        //writeln(A);\n        foreach (i; 0 .. 7) memo[i][] = -1;\n        bool dfs(int last, int bit) {\n            if (bit == (1 << N) - 1) return 1;\n            if (memo[last][bit] >= 0) return memo[last][bit] == 1;\n            foreach (i; 0 .. N) {\n                if (bit & (1 << i)) continue;\n                char l = cast(char)(last + '0');\n                if (l == A[i][0] || l == A[i][1]) {\n                    int nlast = (l == A[i][0] ? A[i][1] : A[i][0]) - '0'; \n                    if (dfs(nlast, bit | (1 << i))) {\n                        memo[last][bit] = 1;\n                        //writeln(i);\n                        return true;\n                    }\n                }\n            }\n            memo[last][bit] = 0;\n            return false;\n        }\n\n        bool Ans = false;\n        foreach (i; 0 .. N) {\n            int l = A[i][0] - '0';\n            Ans |= dfs(l, 1 << i);\n            l = A[i][1] - '0';\n            Ans |= dfs(l, 1 << i);\n        }\n        writeln(Ans ? \"Yes\" : \"No\");\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = list(set(reduce(lambda x, y: x + y, xy)))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] + b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(1, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        #print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            #print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    return len(zz[zz == 0]) == 0\n     \n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    print(\"digits=\", digits)\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    print(\"zz=\", zz)\n    return len(zz[zz == 0]) == 0\n    #return True #(len(z[0][z == 0]) == 0)\n     \n        \nf = open(\"python\\input_1010.txt\")\nlno = 0\nfor line in f:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if [x, y] in xy or [y, x] in xy else 0 for x in range(0, 7)] for y in range(0, 7)]  \n    #print(dominos)\n    return (dominos)\n\nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n        dominos = np.zeros((7, 7))\n    else:\n        dominos = subset(line)\n        order = np.sum(dominos, axis = 0)\n        #print(order)\n        order = order % 2\n        if np.all(order == 0):\n            print(\"Yes\")\n        elif len(order[order == 1]) <= 2:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    return len(zz[zz == 0]) == 0\n\nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if [x, y] in xy or [y, x] in xy else 0 for x in range(0, 7)] for y in range(0, 7)]  \n    #print(dominos)\n    return (dominos)\n\nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n        dominos = np.zeros((7, 7))\n    else:\n        dominos = subset(line)\n        order = np.sum(dominos, axis = 0)\n        #print(order)\n        order = order % 2\n        if np.all(order == 0):\n            print(\"Yes\")\n        elif len(order[order == 1]) <= 2:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]\n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    return len(zz[zz == 0]) == 0\n\nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    return len(zz[zz == 0]) == 0\n     \n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1010: Dominoes Arrangement\n# Python3 2018.7.5 bal4u\n\nwhile True:\n\ttry: n = int(input())\n\texcept: break\n\tf, g = [0]*7, [0]*7\n\tp = list(input().split())\n\tfor x in p:\n\t\tif x[0] == x[1]: g[int(x[0])] = 1\n\t\telse:\n\t\t\tf[int(x[0])] += 1\n\t\t\tf[int(x[1])] += 1\n\tif n == 1:\n\t\tprint(\"Yes\")\n\t\tcontinue\n\tans = 1\n\tfor i in range(7):\n\t\tif g[i] and f[i] == 0:\n\t\t\tans = 0\n\t\t\tbreak\n\tif ans: \n\t\tk = 0\n\t\tfor i in range(7): \n\t\t\tif f[i] & 1: k += 1\n\t\tans = (k == 0 or k == 2)\n\tprint(\"Yes\" if ans else \"No\")\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]\n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = [sum(dominos[i]) for i in range(0, 7)]\n            odd = 0\n            for i in digits:\n                if order[i] % 2 != 0:\n                    odd += 1\n            if odd <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    print(\"digits=\", digits)\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    print(\"zz=\", zz)\n    return len(zz[zz == 0]) == 0\n    #return True #(len(z[0][z == 0]) == 0)\n     \n        \nf = open(\"python\\input_1010.txt\")\nlno = 0\nfor line in f:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef checkSorted(List):\n    dicts = {}\n    for data in List:\n        dicts[data % 10] = 0\n    for data in List:\n        dicts[data % 10] += 1\n    if max(dicts,key = dicts.get) != min(dicts,key = dicts.get):\n        return \"NO\"\n    return \"YES\"\n        \n\nList = []\nfor i in sys.stdin:\n    List.append(i)\n\nfor i in range(1,len(List),2):\n    List[i] = List[i].split()\n    for j in range(len(List[i])):\n        List[i][j] = int(List[i][j])\n    print(checkSorted(List[i]))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    print(\"digits=\", digits)\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    print(\"zz=\", zz)\n    return len(zz[zz == 0]) == 0\n\nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]\n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        #print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            #print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    #print(xy)\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = list(set(reduce(lambda x, y: x + y, xy)))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] + b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    #print(\"zz=\", zz)\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        #print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            #print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]\n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = [sum(dominos[i]) for i in range(0, 7)]\n            odd = 0\n            for i in digits:\n                if order[i] % 2 != 0:\n                    odd += 1\n            if odd <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]\n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = np.unique(np.sort(reduce(lambda x, y: x + y, xy)))\n    return digits, dominos\n\ndef is_connected(d, g):\n    a = np.array(g)\n    z = np.zeros_like(a)\n    b = a\n    for i in range(1, z.shape[0]):\n        z += b\n        b = b.dot(a)\n    zz = z[d[0]][d]\n    return len(zz[zz == 0]) == 0\n     \n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    try:\n        n = int(input())\n    except EOFError:\n        break\n    tree = UnionFind(7)\n    nums = [0] * 7\n    for dominoes in input().split():\n        x, y = divmod(int(dominoes), 10)\n        tree.unite(x, y)\n        nums[x] += 1\n        nums[y] += 1\n    if all(tree.same(x, i) for i in range(1, 7) if nums[i]) and \\\n       sum(1 for x in nums if x % 2) <= 2:\n        print('Yes')\n    else:\n        print('No')"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nwhile True:\n    try:\n        n = input()\n    except:\n        break\n    A = raw_input().split()\n    E = [[] for i in range(7)]\n    for s in A:\n        u = int(s[0])\n        v = int(s[1])\n        E[u].append(v)\n        E[v].append(u)\n    cnt = 0\n    for i in range(7):\n        if len(E[i]) % 2 == 1:\n            cnt += 1\n    if cnt > 2:\n        print \"No\"\n        continue\n    used = [len(E[i]) == 0 for i in range(7)]\n    def func(num):\n        if used[num]:\n            return\n        used[num] = True\n        for u in E[num]:\n            func(u)\n    for i in range(7):\n        if len(E[i]) > 0:\n            func(i)\n            break\n    if False in used:\n        print \"No\"\n    else:\n        print \"Yes\"\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[2 if [x, y] in xy and x == y else \\\n                1 if [x, y] in xy else \\\n                1 if [y, x] in xy else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)] \n    digits = []\n    for i in xy:\n        digits.extend(i)\n    digits = list(set(digits))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] * b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = [sum(dominos[i]) for i in range(0, 7)]\n            odd = 0\n            for i in digits:\n                if order[i] % 2 != 0:\n                    odd += 1\n            if odd <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom functools import reduce\n\ndef subset(line):\n    l = line.strip().split(\" \")\n    a = list(map(int, l))\n    xy = list(map(lambda x: [x // 10, x % 10], a))\n    dominos = [[1 if x != y and ([x, y] in xy or [y, x] in xy) else 0 \\\n                for x in range(0, 7)] for y in range(0, 7)]  \n    digits = list(set(reduce(lambda x, y: x + y, xy)))\n    digits.sort()\n    return digits, dominos\n\ndef add_matrix(a, b):\n    c = [[a[j][i] + b[j][i] for i in range(0, 7)] for j in range(0, 7)]\n    return c\n\ndef mul_matrix(a, b):\n    c = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    for j in range(0, 7):\n        for i in range(0, 7):\n            for k in range(0, 7):\n                c[j][i] += a[j][k] + b[k][i]\n    return c\n                \ndef is_connected(d, g):\n    a = g[:]\n    z = [[0 for i in range(0, 7)] for j in range(0, 7)]\n    b = a\n    for i in range(0, 7):\n        z = add_matrix(z, b)\n        b = mul_matrix(b, a)\n    zeros = 0\n    for i in d:\n        if z[d[0]][i] == 0:\n            zeros += 1\n    return zeros == 0\n        \nlno = 0\nfor line in sys.stdin:\n    lno += 1\n    if lno == 1:\n        n = int(line)\n    else:\n        digits, dominos = subset(line)\n        #print(\"line=\", line)\n        if not is_connected(digits, dominos):\n            print(\"No\")\n        else:\n            order = np.sum(dominos, axis = 0)\n            #print(\"order=\", order)\n            order = order % 2\n            if np.all(order == 0):\n                print(\"Yes\")\n            elif len(order[order == 1]) <= 2:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        lno = 0\n"
  },
  {
    "language": "Python",
    "code": "\n# find_pair\ndef find_pair(target_val, nums):\n    if len(nums) == 0:\n        print(\"YES\")\n        return\n\n    cand_tup = [n for n in nums if n[0] == target_val or n[1] == target_val]\n\n    if len(cand_tup) == 0:\n        print(\"NO\")\n        return\n\n    next_tup = cand_tup[0]\n\n    next_val = next_tup[0] if next_tup[1] == target_val else next_tup[1]\n    nums.remove(next_tup)\n    find_pair(next_val, nums)\n\nwhile True:\n    n = int(input())\n    nums = [(int(a), int(b)) for a,b in input().split() ]\n\n    dd = {}\n\n    for t in nums:\n        dd[t[0]] = dd[t[0]] + 1 if t[0] in dd else 1\n        dd[t[1]] = dd[t[1]] + 1 if t[1] in dd else 1\n\n    odd_num = [k for k, v in dd.items() if v % 2 != 0]\n\n\n    if not(len(odd_num) == 0 or len(odd_num) == 2):\n        print(\"NO\")\n        quit()\n\n    start = odd_num[0] if len(odd_num) == 2 else nums[0][0]\n\n    find_pair(start, nums)"
  }
]