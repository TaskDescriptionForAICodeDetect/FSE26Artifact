[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 50\n\nint N;\nint C[MAX_N][MAX_N];\n\nint countMatrices() {\n    int total = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            int possibilities = 0;\n            for (int a = 0; a < 2; a++) {\n                for (int b = 0; b < 2; b++) {\n                    int match = 1;\n                    for (int k = 0; k < N; k++) {\n                        if (((a * b) % 2) != C[i][j]) {\n                            match = 0;\n                            break;\n                        }\n                    }\n                    if (match) possibilities++;\n                }\n            }\n            total = ((long long)total * possibilities) % MOD;\n        }\n    }\n    return total;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &C[i][j]);\n        }\n    }\n    printf(\"%d\\n\", countMatrices());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 300\n\ntypedef long long ll;\n\nint N;\nint C[MAX_N][MAX_N];\nint basis[MAX_N][MAX_N]; // Basis for the row space of A\nint rank;\n\nll mod_pow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid gaussian_elimination() {\n    rank = 0;\n    for (int col = 0; col < N; ++col) {\n        int pivot = -1;\n        for (int row = rank; row < N; ++row) {\n            if (C[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        \n        // Swap rows\n        for (int c = 0; c < N; ++c) {\n            int temp = C[rank][c];\n            C[rank][c] = C[pivot][c];\n            C[pivot][c] = temp;\n        }\n        \n        // Eliminate other rows\n        for (int row = 0; row < N; ++row) {\n            if (row != rank && C[row][col]) {\n                for (int c = 0; c < N; ++c) {\n                    C[row][c] ^= C[rank][c];\n                }\n            }\n        }\n        rank++;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            scanf(\"%d\", &C[i][j]);\n        }\n    }\n    \n    gaussian_elimination();\n    \n    int free_vars = N * N - rank * N;\n    ll ans = mod_pow(2, free_vars);\n    \n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> C(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> C[i][j];\n        }\n    }\n\n    // The number of free variables is the key to the solution.\n    // The number of solutions is 2^{r_A * (N - r_B) + (N - r_A) * r_B + (N - r_A) * (N - r_C)}}\n    // where r_A is the rank of A, r_B is the rank of B, and r_C is the rank of C.\n    // However, the problem is equivalent to counting the number of A such that AB = C for some B.\n    // The number of such A is 2^{(N - rank(C)) * N}, and for each A, the number of B is 2^{N^2 - rank(A) * N}.\n\n    // So the total is sum_{rank_A} [number of A with rank = rank_A] * 2^{N^2 - rank_A * N}.\n    // The number of A with rank = k is product_{i=0}^{k-1} (2^N - 2^i)^2 / (2^k - 2^i).\n\n    // But it's complex, so we can use the fact that the number of solutions is 2^{(N - rank(C)) * N} * 2^{(N - rank(A)) * N} for any A that satisfies AB = C.\n\n    // The correct approach is to realize that the number of solutions is 2^{(N - rank(C)) * N} * 2^{(N - rank(A)) * N} where A is any matrix that can produce C.\n\n    // However, the correct formula is the number of A with AB = C for some B is 2^{(N - rank(C)) * N}, and for each A, the number of B is 2^{N * (N - rank(A))}.\n\n    // The total is sum_{A: AB = C for some B} 2^{N * (N - rank(A))}.\n\n    // But calculating this directly is hard, so we use the fact that the total is 2^{N^2 - rank(C)}.\n\n    // So the answer is 2^{(N^2 - rank(C))}.\n\n    // Now, compute the rank of C modulo 2.\n\n    vector<vector<int>> mat = C;\n    int rank = 0;\n    for (int col = 0; col < N && rank < N; ++col) {\n        int pivot = -1;\n        for (int row = rank; row < N; ++row) {\n            if (mat[row][col] == 1) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(mat[rank], mat[pivot]);\n        for (int row = rank + 1; row < N; ++row) {\n            if (mat[row][col] == 1) {\n                for (int c = col; c < N; ++c) {\n                    mat[row][c] ^= mat[rank][c];\n                }\n            }\n        }\n        ++rank;\n    }\n\n    long long ans = 1;\n    long long power = (long long)N * N - rank;\n    long long base = 2;\n    while (power > 0) {\n        if (power % 2 == 1) {\n            ans = ans * base % MOD;\n        }\n        base = base * base % MOD;\n        power /= 2;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] C = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                C[i][j] = sc.nextInt();\n            }\n        }\n\n        long result = 1;\n        for (int j = 0; j < N; j++) {\n            // Construct the system of equations for column j of B and row i of A\n            int rank = 0;\n            boolean[] pivot = new boolean[N];\n            for (int i = 0; i < N; i++) {\n                // Find a row with a pivot in column i\n                int pivotRow = -1;\n                for (int k = 0; k < N; k++) {\n                    if (!pivot[k] && C[k][j] == 1) {\n                        pivotRow = k;\n                        break;\n                    }\n                }\n                if (pivotRow == -1) {\n                    break;\n                }\n                pivot[pivotRow] = true;\n                rank++;\n                // Eliminate other rows\n                for (int k = 0; k < N; k++) {\n                    if (!pivot[k] && C[k][j] == 1) {\n                        for (int l = 0; l < N; l++) {\n                            C[k][l] ^= C[pivotRow][l];\n                        }\n                    }\n                }\n            }\n            int freeVariables = N - rank;\n            long ways = 1;\n            for (int k = 0; k < freeVariables; k++) {\n                ways = (ways * 2) % MOD;\n            }\n            result = (result * ways) % MOD;\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:30:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n    \n    public static int countMatrixPairs(int N) {\n        List<int[][]> possibleAs = generatePossibleMatrices(N);\n        List<int[][]> possibleBs = generatePossibleMatrices(N);\n        \n        int count = 0;\n        int[][][] C = new int[1 << (N * N)][N][N];\n        \n        for (int[][] A : possibleAs) {\n            for (int[][] B : possibleBs) {\n                int[][] product = multiplyMatrices(A, B, N);\n                \n                boolean valid = true;\n                for (int i = 0; i < N; i++) {\n                    for (int j = 0; j < N; j++) {\n                        if (product[i][j] != 0 && product[i][j] != 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (!valid) break;\n                }\n                \n                if (valid) {\n                    count = (count + 1) % MOD;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    static List<int[][]> generatePossibleMatrices(int N) {\n        List<int[][]> matrices = new ArrayList<>();\n        int totalMatrices = 1 << (N * N);\n        \n        for (int mask = 0; mask < totalMatrices; mask++) {\n            int[][] matrix = new int[N][N];\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    matrix[i][j] = (mask >> (i * N + j)) & 1;\n                }\n            }\n            matrices.add(matrix);\n        }\n        \n        return matrices;\n    }\n    \n    static int[][] multiplyMatrices(int[][] A, int[][] B, int N) {\n        int[][] result = new int[N][N];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    result[i][j] ^= A[i][k] & B[k][j];\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        System.out.println(countMatrixPairs(N));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:30:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAXN = 50;\n\nint N;\nint C[MAXN][MAXN];\n\nint countPossibleMatrices() {\n    vector<vector<int>> possible_rows(N);\n    \n    for (int row = 0; row < N; row++) {\n        for (int mask = 0; mask < (1 << N); mask++) {\n            bool valid = true;\n            for (int col = 0; col < N; col++) {\n                int dot_product = 0;\n                for (int k = 0; k < N; k++) {\n                    dot_product ^= ((mask >> k) & 1);\n                }\n                if (dot_product != C[row][col]) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) {\n                possible_rows[row].push_back(mask);\n            }\n        }\n    }\n    \n    vector<long long> dp(1 << N, 0);\n    dp[0] = 1;\n    \n    for (int row = 0; row < N; row++) {\n        vector<long long> new_dp(1 << N, 0);\n        for (int prev_mask = 0; prev_mask < (1 << N); prev_mask++) {\n            for (int curr_row : possible_rows[row]) {\n                new_dp[prev_mask ^ curr_row] = (new_dp[prev_mask ^ curr_row] + dp[prev_mask]) % MOD;\n            }\n        }\n        dp = new_dp;\n    }\n    \n    return dp[0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> C[i][j];\n        }\n    }\n    \n    cout << countPossibleMatrices() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_possible_pairs(N, C):\n    MOD = 10**9 + 7\n    \n    def check_matrix_compatible(A, B, C):\n        for i in range(N):\n            for j in range(N):\n                if C[i][j] != sum(A[i][k] * B[k][j] for k in range(N)) % 2:\n                    return False\n        return True\n\n    def dfs(r, A, B, C):\n        if r == N:\n            return 1 if check_matrix_compatible(A, B, C) else 0\n            \n        result = 0\n        \n        for i in range(1 << N):\n            for j in range(1 << N):\n                for k in range(N):\n                    A[r][k] = (i >> k) & 1\n                    B[k][r] = (j >> k) & 1\n                result += dfs(r + 1, A, B, C)\n                result %= MOD\n        \n        return result\n\n    A = [[0] * N for _ in range(N)]\n    B = [[0] * N for _ in range(N)]\n    return dfs(0, A, B, C)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    \n    data = input().split()\n    \n    N = int(data[0])\n    C = []\n    index = 1\n    for i in range(N):\n        C.append([int(c) for c in data[index:index+N]])\n        index += N\n    \n    result = count_possible_pairs(N, C)\n    print(result)\n\nmain()",
    "timestamp": "2025-08-13 15:34:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MatrixPairCount {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        \n        int[][] C = new int[n][n];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                C[i][j] = scanner.nextInt();\n        \n        System.out.println(countMatrixPairs(n, C));\n        \n        scanner.close();\n    }\n\n    private static long countMatrixPairs(int n, int[][] C) {\n        long[][] dp = new long[n + 1][1 << n];\n        dp[0][0] = 1;\n        \n        for (int i = 0; i < n; i++) {\n            for (int mask = 0; mask < (1 << n); mask++) {\n                if (dp[i][mask] != 0) {\n                    for (int nextMask = 0; nextMask < (1 << n); nextMask++) {\n                        if (isValidMask(n, C, i, mask, nextMask)) {\n                            dp[i + 1][nextMask] = (dp[i + 1][nextMask] + dp[i][mask]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[n][0];\n    }\n\n    private static boolean isValidMask(int n, int[][] C, int row, int mask, int nextMask) {\n        for (int j = 0; j < n; j++) {\n            int sum = 0;\n            for (int k = 0; k < n; k++) {\n                if (((nextMask >> k) & 1) == 1 && ((mask >> k) & 1) == 1) {\n                    sum++;\n                }\n            }\n            if ((sum % 2) != C[row][j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 15:35:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nint n;\nint C[10][10];\n\n// Helper function to calculate 2^x % MOD\nlong long power2(int x) {\n    long long result = 1;\n    long long base = 2;\n    while (x > 0) {\n        if (x & 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        x >>= 1;\n    }\n    return result;\n}\n\n// Gaussian elimination to determine the rank of the matrix\nint gauss(int aug_matrix[][20], int rows, int columns) {\n    int rank = 0;\n    for (int col = 0; col < columns; ++col) {\n        int pivot = rank;\n        while (pivot < rows && aug_matrix[pivot][col] == 0) {\n            pivot++;\n        }\n        if (pivot < rows) {\n            for (int c = col; c <= columns; ++c) {\n                int temp = aug_matrix[rank][c];\n                aug_matrix[rank][c] = aug_matrix[pivot][c];\n                aug_matrix[pivot][c] = temp;\n            }\n            for (int r = 0; r < rows; ++r) {\n                if (r != rank && aug_matrix[r][col]) {\n                    for (int c = col; c <= columns; ++c) {\n                        aug_matrix[r][c] ^= aug_matrix[rank][c];\n                    }\n                }\n            }\n            rank++;\n        }\n    }\n    return rank;\n}\n\n// Function to calculate the number of pairs (A, B)\nlong long count_pairs() {\n    int aug_matrix[20][20];\n    for (int r = 0; r < n; ++r) {\n        for (int c = 0; c < n; ++c) {\n            aug_matrix[r][c] = C[r][c];\n        }\n    }\n    int rank = gauss(aug_matrix, n, n);\n    \n    return power2(n * n - rank);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            scanf(\"%d\", &C[i][j]);\n        }\n    }\n    \n    printf(\"%lld\\n\", count_pairs());\n    return 0;\n}",
    "timestamp": "2025-08-13 15:35:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvoid increment(int& val, int increment) {\n    val = (val + increment) % MOD;\n}\n\nvector<vector<int>> getPossibleAB(int N, vector<vector<int>>& C) {\n    vector<vector<int>> possibilities(N, vector<int>(N, 0));\n    for (int row = 0; row < N; ++row) {\n        int columnChoice = (1 << N) - 1;\n        for (int column = 0; column < N; ++column) {\n            if (C[row][column] == 0) {\n                columnChoice &= ~(1 << column);\n            }\n        }\n        for (int aChoice = 0; aChoice < (1 << N); ++aChoice) {\n            int validBCount = 0;\n            for (int bChoice = 0; bChoice < (1 << N); ++bChoice) {\n                int result = 0;\n                for (int k = 0; k < N; ++k) {\n                    if ((aChoice & (1 << k)) && (bChoice & (1 << k))) {\n                        result ^= 1;\n                    }\n                }\n                if (result == C[row][column]) {\n                    validBCount++;\n                }\n            }\n            increment(possibilities[row][column], validBCount);\n        }\n    }\n    return possibilities;\n}\n\nint countPairs(int N, vector<vector<int>>& possibilities) {\n    int totalCount = 1;\n    for (int row = 0; row < N; ++row) {\n        for (int column = 0; column < N; ++column) {\n            increment(totalCount, possibilities[row][column]);\n        }\n    }\n    return totalCount;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> C(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> C[i][j];\n        }\n    }\n    vector<vector<int>> possibilities = getPossibleAB(N, C);\n    cout << countPairs(N, possibilities) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:35:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_matrix_pairs(N, C):\n    MOD = 10**9 + 7\n    \n    def count_possible_matrices(C):\n        def gaussian_elimination(matrix):\n            rows, cols = len(matrix), len(matrix[0])\n            rank = 0\n            for col in range(cols):\n                for row in range(rank, rows):\n                    if matrix[row][col] == 1:\n                        matrix[rank], matrix[row] = matrix[row], matrix[rank]\n                        break\n                else:\n                    continue\n                \n                for r in range(rows):\n                    if r != rank and matrix[r][col] == 1:\n                        for c in range(col, cols):\n                            matrix[r][c] ^= matrix[rank][c]\n                \n                rank += 1\n            return rank\n        \n        return 2 ** (N * N - gaussian_elimination(C))\n    \n    return count_possible_matrices(C) % MOD\n\n# Input parsing\nN = int(input())\nC = [list(map(int, input().strip())) for _ in range(N)]\n\n# Output result\nprint(count_matrix_pairs(N, C))",
    "timestamp": "2025-08-13 15:35:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    C = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    \n    # The problem reduces to counting the number of A and B such that AB ≡ C mod 2.\n    # The solution involves linear algebra over GF(2).\n    \n    # We need to find the rank of C and the dimensions of the solution space.\n    # The answer is (2^((2N - rank(C)) * N)) mod MOD.\n    \n    # First, perform Gaussian elimination to find the rank of C.\n    rank = 0\n    for col in range(N):\n        pivot = -1\n        for row in range(rank, N):\n            if C[row][col] == 1:\n                pivot = row\n                break\n        if pivot == -1:\n            continue\n        C[rank], C[pivot] = C[pivot], C[rank]\n        for row in range(N):\n            if row != rank and C[row][col] == 1:\n                for c in range(col, N):\n                    C[row][c] ^= C[rank][c]\n        rank += 1\n    \n    # The number of solutions is 2^{(2N - rank) * N}\n    exponent = (2 * N - rank) * N\n    ans = pow(2, exponent, MOD)\n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 15:37:00"
  }
]