[
  {
    "language": "Fortran",
    "code": "program main\n  implicit none\n  integer(16) dp(0:300,0:300),a(0:300,0:300)\n  integer(16) N\n  integer(16) r,ret,i,j,k\n  integer(16) pw(0:300)\n  integer(16)::mo=1000000007\n  read*,N\n  pw(0)=1_16\n  do i=1,n+1\n    pw(i)=mod(pw(i-1)*2_16,mo)\n  end do\n  dp=0_16\n  dp(0,0)=1_16\n  do j=0,n-1 \n    do k=0,j\n  \t  dp(j+1,k+1)=mod(dp(j+1,k+1)+mod(dp(j,k)*(pw(n)-pw(k)),mo),mo)\n  \t  dp(j+1,k)=mod(dp(j+1,k)+mod(dp(j,k)*pw(k),mo),mo)\n\tend do\n  end do\n  a=0\n  do i=0,n-1\n    read*,a(i,0:N-1)\n  end do\n  r=gauss(a,N)\n  ret=0\n  do i= r,n\n    ret=mod(ret+mod(dp(n,i)*dp(i,r),mo)*powmod(2_16,n*n-i*n,mo),mo)\n  end do\n  ret=mod(ret*powmod(dp(n,r),mo-2_16,mo),mo)\n  \n  print\"(i0)\",ret\n  \ncontains\nfunction powmod(aa,b,mo)\n  implicit none\n  integer(16) aa,b,mo,ak,bk\n  integer(16) powmod\n  powmod=1_16\n  bk=b\n  ak=mod(aa,mo)\n  do while(bk/=0_16)\n    if(mod(bk,2)==1)then\n      powmod=mod(powmod*ak,mo)\n    endif\n    ak=mod(ak*ak,mo)\n    bk=bk/2_16\n  end do\nend function\n\nfunction gauss(a,N)\n  implicit none\n  integer(16) N,a(0:300,0:300)\n  integer(16) gauss\n  integer(16) p,i,j,k\n  integer(16) fg\n  p=0\n  do i=0,n-1\n\tfg=0\n\tdo j=p,n-1 \n      if (a(j,i)>0)then\t\n        do k=0,n-1 \n          call swap(a(p,k),a(j,k))\n        end do\n        fg=1\n\t\texit\n      endif\n    end do\n\tif (fg==0) cycle\n    do j=p+1,n-1 \n      if (a(j,i)>0)then\n\t    do k=0,n-1 \n          a(j,k) = xor(a(j,k),a(p,k))\n        end do\n\t  endif\n    end do\n\tp=p+1\n  end do\n  gauss=p\nend function\n\nsubroutine swap(a,b)\n  implicit none\n  integer(16) a,b\n  a=xor(a,b)\n  b=xor(a,b)\n  a=xor(a,b)\nend subroutine\nend"
  },
  {
    "language": "Fortran",
    "code": "program main\n  implicit none\n  integer(16) dp(0:300,0:300),a(0:300,0:300)\n  integer(16) N\n  integer(16) r,ret,i,j,k\n  integer(16) pw(0:300)\n  integer(16)::mo=1000000007\n  read*,N\n  pw(0)=1_16\n  do i=1,n+1\n    pw(i)=mod(pw(i-1)*2_16,mo)\n  end do\n  dp=0_16\n  dp(0,0)=1_16\n  do j=0,n-1 \n    do k=0,j\n  \t  dp(j+1,k+1)=mod(dp(j+1,k+1)+mod(dp(j,k)*(pw(n)-pw(k)),mo),mo)\n  \t  dp(j+1,k)=mod(dp(j+1,k)+mod(dp(j,k)*pw(k),mo),mo)\n\tend do\n  end do\n  a=0\n  do i=0,n-1\n    read*,a(i,0:N-1)\n  end do\n  r=gauss(a,N)\n  ret=0\n  do i= r,n\n    ret=mod(ret+mod(dp(n,i)*dp(i,r),mo)*powmod(2_16,n*n-i*n,mo),mo)\n  end do\n  ret=mod(ret*powmod(dp(n,r),mo-2_16,mo),mo)\n  \n  print*,powmod(dp(n,r),mo-2_16,mo)\n  \ncontains\nfunction powmod(aa,b,mo)\n  implicit none\n  integer(16) aa,b,mo\n  integer(16) powmod\n  powmod=1_16\n  aa=mod(aa,mo)\n  do while(b/=0_16)\n    if(mod(b,2)==1)then\n      powmod=mod(powmod*aa,mo)\n    endif\n    aa=mod(aa*aa,mo)\n    b=b/2_16\n  end do\nend function\n\nfunction gauss(a,N)\n  implicit none\n  integer(16) N,a(0:300,0:300)\n  integer(16) gauss\n  integer(16) p,i,j,k\n  integer(16) fg\n  p=0\n  do i=0,n-1\n\tfg=0\n\tdo j=p,n-1 \n      if (a(j,i)>0)then\t\n        do k=0,n-1 \n          call swap(a(p,k),a(j,k))\n        end do\n        fg=1\n\t\texit\n      endif\n    end do\n\tif (fg==0) cycle\n    do j=p+1,n-1 \n      if (a(j,i)>0)then\n\t    do k=0,n-1 \n          a(j,k) = xor(a(j,k),a(p,k))\n        end do\n\t  endif\n    end do\n\tp=p+1\n  end do\n  gauss=p\nend function\n\nsubroutine swap(a,b)\n  implicit none\n  integer(16) a,b\n  a=xor(a,b)\n  b=xor(a,b)\n  a=xor(a,b)\nend subroutine\nend"
  },
  {
    "language": "Fortran",
    "code": "program main\n  implicit none\n  integer(16) dp(0:300,0:300),a(0:300,0:300)\n  integer(16) N\n  integer(16) r,ret,i,j,k\n  integer(16) pw(0:300)\n  integer(16)::mo=1000000007\n  read*,N\n  pw(0)=1_16\n  do i=1,n+1\n    pw(i)=mod(pw(i-1)*2_16,mo)\n  end do\n  dp=0_16\n  dp(0,0)=1_16\n  do j=0,n-1 \n    do k=0,j\n  \t  dp(j+1,k+1)=mod(dp(j+1,k+1)+mod(dp(j,k)*(pw(n)-pw(k)),mo),mo)\n  \t  dp(j+1,k)=mod(dp(j+1,k)+mod(dp(j,k)*pw(k),mo),mo)\n\tend do\n  end do\n  a=0\n  do i=0,n-1\n    read*,a(i,0:N-1)\n  end do\n  r=gauss(a,N)\n  ret=0\n  do i= r,n\n    ret=mod(ret+mod(dp(n,i)*dp(i,r),mo)*powmod(2_16,n*n-i*n,mo),mo)\n  end do\n  ret=mod(ret*powmod(dp(n,r),mo-2_16,mo),mo)\n  \n  if(ret<=0)ret=ret+mo\n  print\"(i0)\",ret\n  \ncontains\nfunction powmod(aa,b,mo)\n  implicit none\n  integer(16) aa,b,mo,ak,bk\n  integer(16) powmod\n  powmod=1_16\n  bk=b\n  ak=mod(aa,mo)\n  do while(bk/=0_16)\n    if(mod(bk,2)==1)then\n      powmod=mod(powmod*ak,mo)\n    endif\n    ak=mod(ak*ak,mo)\n    bk=bk/2_16\n  end do\nend function\n\nfunction gauss(a,N)\n  implicit none\n  integer(16) N,a(0:300,0:300)\n  integer(16) gauss\n  integer(16) p,i,j,k\n  integer(16) fg\n  p=0\n  do i=0,n-1\n\tfg=0\n\tdo j=p,n-1 \n      if (a(j,i)>0)then\t\n        do k=0,n-1 \n          call swap(a(p,k),a(j,k))\n        end do\n        fg=1\n\t\texit\n      endif\n    end do\n\tif (fg==0) cycle\n    do j=p+1,n-1 \n      if (a(j,i)>0)then\n\t    do k=0,n-1 \n          a(j,k) = xor(a(j,k),a(p,k))\n        end do\n\t  endif\n    end do\n\tp=p+1\n  end do\n  gauss=p\nend function\n\nsubroutine swap(a,b)\n  implicit none\n  integer(16) a,b\n  a=xor(a,b)\n  b=xor(a,b)\n  a=xor(a,b)\nend subroutine\nend"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint dp[310][310],a[310][310],n;\nll pw[310];\n\nint gauss() {\n\tint p=0;\n\trep(i,0,n) {\n\t\tint fg=0;\n\t\trep(j,p,n) if (a[j][i]) {\n\t\t\trep(k,0,n) swap(a[p][k],a[j][k]); fg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) continue;\n\t\trep(j,p+1,n) if (a[j][i]) {\n\t\t\trep(k,0,n) a[j][k]^=a[p][k];\n\t\t}\n\t\t++p;\n\t}\n\treturn p;\n}\nint main() {\n\tscanf(\"%d\",&n); pw[0]=1;\n\trep(i,1,n+1) pw[i]=pw[i-1]*2%mod;\n\tdp[0][0]=1;\n\trep(j,0,n) rep(k,0,j+1) {\n\t\tdp[j+1][k+1]=(dp[j+1][k+1]+dp[j][k]*(pw[n]-pw[k]))%mod;\n\t\tdp[j+1][k]=(dp[j+1][k]+dp[j][k]*pw[k])%mod;\n\t}\n\trep(i,0,n) rep(j,0,n) scanf(\"%d\",&a[i][j]);\n\tint r=gauss(),ret=0;\n\trep(i,r,n+1) {\n\t\tret=(ret+dp[n][i]*dp[i][r]%mod*powmod(2,n*n-i*n))%mod;\n\t}\n\tprintf(\"%lld\\n\",ret*powmod(dp[n][r],mod-2)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve(true);\n        ++testNumber;\n        //++timer;\n    }\n\n    /*while (true) {\n        solve(false);\n    }*/\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n#define int li\n\nconst int mod = 1000000007;\n\nint dp[310][310][310];\n\nvoid add(int& cur, int add) {\n    cur += add;\n    if (cur >= mod) {\n        cur -= mod;\n    }\n}\n\nvector<vector<int>> get_from_mask(int mask, int n) {\n    vector<vector<int>> res(n, vector<int>(n));\n    for (int  i= 0; i < n; ++i) {\n        for (int j = 0 ;j < n; ++j) {\n            res[i][j] = (mask & 1);\n            mask >>= 1;\n        }\n    }\n    return res;\n}\n\nvector<vector<int>> mult(vector<vector<int>> a, vector<vector<int>> b, int n) {\n    vector<vector<int>> res(n, vector<int>(n));\n    for (int  i= 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k) {\n                res[j][i] ^= (a[i][k] * b[k][j]);\n            }\n        }\n    }\n    return res;\n}\n\nvoid solve(bool read) {\n    int n;\n    if (read) {\n        cin >> n;\n    }\n    else {\n        n = 2;\n    }\n    vector<vector<int>> matrix(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (read) {\n                cin >> matrix[j][i];\n            }\n            else {\n                matrix[i][j] = rand() % 2;\n            }\n        }\n    }\n\n    auto old = matrix;\n\n    vector<int> nums;\n    vector<int> first_bit;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < nums.size(); ++j) {\n            if (matrix[i][first_bit[j]]) {\n                for (int r = 0; r < n; ++r) {\n                    matrix[i][r] ^= matrix[nums[j]][r];\n                }\n            }\n        }\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j]) {\n                nums.push_back(i);\n                first_bit.push_back(j);\n                break;\n            }\n        }\n    }\n\n    vector<int> new_rank(n, 0);\n    for (int x : nums) {\n        new_rank[x] = 1;\n    }\n\n    vector<int> powers(n + 1, 1);\n    for (int i = 1; i < powers.size(); ++i) {\n        powers[i] = powers[i - 1] * 2 % mod;\n    }\n\n    memset(dp, 0, sizeof dp);\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int r = 0; r <= i; ++r) {\n            for (int rem = 0; rem + r <= i; ++rem) {\n                if (new_rank[i]) {\n                    add(dp[i + 1][r + 1][rem], dp[i][r][rem] * (powers[n] - powers[r + rem]) % mod);\n                    continue;\n                }\n                add(dp[i + 1][r][rem], dp[i][r][rem] * powers[rem] % mod);\n                add(dp[i + 1][r][rem + 1], dp[i][r][rem] * (powers[n] - powers[rem + r]) % mod);\n            }\n        }\n    }\n\n    int res = 0;\n    for (int r = 0; r <= n; ++r) {\n        for (int rem = 0; rem + r <= n; ++rem) {\n            res += dp[n][r][rem] * binpow(powers[n - rem - r], n, mod) % mod;\n            //cout << r << ' ' << rem << ' ' << dp[n][r][rem] << endl;\n            res %= mod;\n        }\n    }\n    cout << res << endl;\n\n\n   /* int stupid_res = 0;\n    for (int mask = 0; mask < (1 << (n * n)); ++mask) {\n        auto a = get_from_mask(mask, n);\n        for (int mask1 = 0; mask1 < (1 << (n * n)); ++mask1) {\n            auto b = get_from_mask(mask1, n);\n            if (mult(a, b, n) == old) {\n                ++stupid_res;\n            }\n            else {\n\n            }\n        }\n    }\n\n    if (stupid_res != res) {\n        cout << res << ' ' << stupid_res << endl;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cout << old[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        exit(0);\n    }*/\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\n\nint N;\nint C[311][311];\nMint dp[311][311][311];\nMint pow2[311];\n\nvoid MAIN() {\n    pow2[0] = 1;\n    REP (i, 310) pow2[i+1] = pow2[i] + pow2[i];\n\n\n    scanf(\"%d\", &N);\n    REP (i, N) REP (j, N) scanf(\"%d\", &C[i][j]);\n\n    int r = 0, c = 0;\n    for (; c<N;) {\n\tint p = -1;\n\tfor (int i=r; i<N; i++) if (C[i][c]) {\n\t    p = i;\n\t    break;\n\t}\n\tif (p == -1) {\n\t    c++;\n\t    continue;\n\t}\n\tif (p != r) {\n\t    REP (j, N) swap(C[r][j], C[p][j]);\n\t}\n\tREP (i, N) if (i != r && C[i][c]) {\n\t    REP (j, N) if (C[r][j]) C[i][j] ^= 1;\n\t}\n\tr++;\n\tc++;\n    }\n\n    eprintf(\"%d\\n\", r);\n\n    dp[0][0][0] = 1;\n    REP (i, N) REP (j, i+1) REP (k, min(j, r)+1) if (dp[i][j][k].x) {\n\tdp[i+1][j][k] += dp[i][j][k] * pow2[j];\n\n\tMint b = pow2[N] - pow2[r-k+j];\n\tdp[i+1][j+1][k] += dp[i][j][k] * b;\n\n\tMint a = pow2[r-k+j] - pow2[j];\n\tdp[i+1][j+1][k+1] += dp[i][j][k] * a;\n    }\n    Mint ans = 0;\n    REP (j, N+2) ans += dp[N][j][r] * Mint(2).pow(N * (N-j));\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mod=1000000007;\nint n;\ninline int getrank(bitset<300> c[300])\n{\n\tint ans=0,i,j;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=ans;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tswap(c[j],c[ans]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j==n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=ans+1;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tc[j]^=c[ans];\n\t\t\t}\n\t\t}\n\t\t++ans;\n\t}\n\treturn ans;\n}\nint p2[90001];\ninline void init(void)\n{\n\tint i;\n\tp2[0]=1;\n\tfor(i=1;i<=90000;++i)\n\t{\n\t\tp2[i]=(p2[i-1]<<1)%mod;\n\t}\n\treturn;\n}\ninline void clear(long long (*dp)[301])\n{\n\tint i;\n\tfor(i=0;i<=n;++i)\n\t{\n\t\tmemset(dp[i],0,sizeof(long long)*(n+1));\n\t}\n\treturn;\n}\nlong long dp1[301][301],dp2[301][301];\nlong long (*dp)[301]=dp1,(*dpt)[301]=dp2;\nint main()\n{\n\tinit();\n\tint i,j,k,x,r;\n\tbitset<300> c[300];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tc[i][j]=x;\n\t\t}\n\t}\n\tr=getrank(c);\n//\tprintf(\"%d\\n\",r);\n\t\n\tclear(dp);\n\tdp[0][0]=1;\n\tfor(i=1;i<=n;++i)//放第几列 \n\t{\n\t\tclear(dpt);\n\t\tfor(j=0;j<=n;++j)//已有维数 \n\t\t{\n\t\t\tfor(k=0;k<=r;++k)//已包含c的维数 \n\t\t\t{\n\t\t\t\tdpt[j][k]+=(dp[j][k]*p2[j])%mod;\n\t\t\t\tif(j<n)\n\t\t\t\t{\n\t\t\t\t\tif(k<r)\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[r-k+j]))%mod;\n\t\t\t\t\t\tdpt[j+1][k+1]+=(dp[j][k]*(p2[r-k]-1))%mod*p2[j]%mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[j]))%mod;;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp,dpt);\n\t}\n\tlong long ans=0;\n\tfor(i=r;i<=n;++i)\n\t{\n\t\tans=(ans+dp[i][r]*p2[n*(n-i)])%mod;\n\t}\n\tprintf(\"%I64d\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n/*\n2\n0 1\n1 0\n\n6\n*/\n/*\n10\n1 0 0 1 1 1 0 0 1 0\n0 0 0 1 1 0 0 0 1 0\n0 0 1 1 1 1 1 1 1 1\n0 1 0 1 0 0 0 1 1 0\n0 0 1 0 1 1 1 1 1 1\n1 0 0 0 0 1 0 0 0 0\n1 1 1 0 1 0 0 0 0 1\n0 0 0 1 0 0 1 0 1 0\n0 0 0 1 1 1 0 0 0 0\n1 0 1 0 0 1 1 1 1 1\n\n741992411\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,R;\n\nconst int MAT=402;\nint mat[402][402];\nll dp[303][303][303];\nll p2[101010];\nll mo=1000000007;\n\nint gf2_rank(int A[MAT][MAT],int n) { /* input */\n\tint i,j,k;\n\tFOR(i,n) {\n\t\tint be=i,mi=n+1;\n\t\tfor(j=i;j<n;j++) {\n\t\t\tFOR(k,n) if(A[j][k]) break;\n\t\t\tif(k<mi) be=j,mi=k;\n\t\t}\n\t\tif(mi>=n) break;\n\t\tFOR(j,n) swap(A[i][j],A[be][j]);\n\t\t\n\t\tFOR(j,n) if(i!=j&&A[j][mi]) {\n\t\t\tFOR(k,n) A[j][k] ^= A[i][k];\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tp2[0]=1;\n\tFOR(i,101000) p2[i+1]=p2[i]*2%mo;\n\t\n\tcin>>N;\n\tFOR(y,N) FOR(x,N) cin>>mat[y][x];\n\tR=gf2_rank(mat,N);\n\tdp[0][0][0]=1;\n\tFOR(i,N) {\n\t\tFOR(x,R+1) FOR(y,N-R+1) if(dp[i][x][y]) {\n\t\t\tll v=dp[i][x][y]*p2[x+y]%mo;\n\t\t\t// no new rank\n\t\t\t(dp[i+1][x][y]+=v)%=mo;\n\t\t\t// common rank\n\t\t\tif(x<R) (dp[i+1][x+1][y]+=v*(p2[R-x]+mo-1))%=mo;\n\t\t\t// single rank\n\t\t\tif(y<N-R) (dp[i+1][x][y+1]+=v*(p2[N-x-y]-p2[R-x]+mo))%=mo;\n\t\t}\n\t}\n\t\n\t//FOR(x,R+1) FOR(y,N-R+1) cout<<x<<\" \"<<y<<\" \"<<dp[N][x][y]<<endl;\n\t\n\tll ret=0;\n\tFOR(y,N-R+1) (ret+=dp[N][R][y]*p2[N*(N-R-y)])%=mo;\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\n//const int INF=5e8;\nint n;\nint c[305][305];\n\nInt dp[305][305][305];\n\nInt pw2[605*305];\nint main(){\n  cin>>n;\n  REP(i,n) REP(j,n) cin>>c[i][j];\n\n  pw2[0]=1;\n  REP(i,n*2*n) pw2[i+1]=pw2[i]*2;\n\n  int R=0;\n  REP(i,n){\n    bool found=false;\n    REPN(j,n,R) if(c[j][i]){\n      if(j>R) REP(k,n) swap(c[j][k],c[R][k]);\n      found=true;\n      break;\n    }\n    if(!found) continue;\n    ++R;\n    REPN(j,n,R) if(c[j][i]){\n      REP(k,n) c[j][k]^=c[i][k];\n    }\n  }\n  REP(i,n) debug(c[i],c[i]+n);\n\n  dp[0][0][0]=1;\n  REP(i,n) REP(j,n) REP(k,n) if(dp[i][j][k].x){\n    Int val=dp[i][j][k];\n    dp[i+1][j][k]+=val*pw2[j];\n    if(j+R-k>=0) dp[i+1][j+1][k]+=val*(pw2[n]-pw2[j+R-k]);\n    if(j+R-k>=0) dp[i+1][j+1][k+1]+=val*(pw2[j+R-k]-pw2[j]);\n  }\n\n  Int res=0;\n  REP(j,n+1) res+=dp[n][j][R]*pw2[n*(n-j)];\n\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int maxn = 305, mod = (int) 1e9 + 7;\nint n;\nint c[maxn][maxn];\nint p2[maxn * maxn];\nint bas[maxn][maxn];\nint cnt[maxn][maxn];\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\npair<int, int> gcd(int a, int b) {\n  if (!b) {\n    return make_pair(1, 0);\n  }\n  pair<int, int> p = gcd(b, a % b);\n  return make_pair(p.second, p.first - (a / b) * p.second);\n}\n\nint inv(int x) {\n  int res = gcd(x, mod).first;\n  if (res < 0) {\n    res += mod;\n  }\n  return res;\n}\n\nvoid precalc() {\n  p2[0] = 1;\n  for (int i = 1; i < maxn * maxn; i++) {\n    p2[i] = mul(p2[i - 1], 2);\n  }\n  for (int n = 0; n < maxn; n++) {\n    bas[n][0] = 1;\n    for (int k = 1; k <= n; k++) {\n      int tomul = p2[n];\n      add(tomul, mod - p2[k - 1]);\n      bas[n][k] = mul(bas[n][k - 1], tomul);\n    }\n  }\n  for (int n = 0; n < maxn; n++) {\n    for (int k = 0; k < maxn; k++) {\n      if (k > n) {\n        cnt[n][k] = 0;\n        continue;\n      }\n      if (k == 0) {\n        cnt[n][k] = 1;\n        continue;\n      }\n      cnt[n][k] = mul(cnt[n - 1][k], p2[k]);\n      int tomul = p2[k];\n      add(tomul, mod - 1);\n      add(cnt[n][k], mul(cnt[n - 1][k - 1], mul(tomul, p2[k - 1])));\n    }\n  }\n}\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n  return true;\n}\n\nint getRank() {\n  for (int i = 0; i < n; i++) {\n    int x = -1, y = -1;\n    for (int j = i; j < n; j++) {\n      for (int k = i; k < n; k++) {\n        if (c[j][k]) {\n          x = j;\n          y = k;\n        }\n      }\n    }\n    if (x == -1) {\n      return i;\n    }\n    for (int j = i; j < n; j++) {\n      swap(c[i][j], c[x][j]);\n    }\n    for (int j = i; j < n; j++) {\n      swap(c[j][i], c[j][y]);\n    }\n    for (int j = i + 1; j < n; j++) {\n      if (!c[j][i]) {\n        continue;\n      }\n      for (int k = i; k < n; k++) {\n        c[j][k] ^= c[i][k];\n      }\n    }\n    for (int j = i + 1; j < n; j++) {\n      c[i][j] = 0;\n    }\n  }\n  return n;\n}\n\nvoid solve() {\n  int k = getRank();\n  eprintf(\"k = %d\\n\", k);\n  int res = 0;\n  for (int l = 0; l <= n - k; l++) {\n    int cur = cnt[n - k][l];\n    cur = mul(mul(cur, mul(bas[n][k + l], inv(bas[l][l]))), p2[n * (n - k - l)]);\n    add(res, cur);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = 310;\n\nint n;\nint a[maxn][maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      scanf(\"%d\", a[i] + j);\n    }\n  }\n  return 1;\n}\n\ntypedef unsigned long long type;\nconst int maxk = (maxn + 63) / 64;\n\ntype b[maxn][maxk];\n\nint used[maxn];\n\nint dp[maxn][maxn];\nint two[maxn];\n\n\nvoid solve() {\n  two[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    two[i] = two[i - 1];\n    add(two[i], two[i]);\n  }\n  memset(dp, 0, sizeof(dp));\n  for (int a = 0; a <= n; ++a) {\n    dp[a][0] = 1;\n    for (int take = 0; take < n; ++take) {\n      for (int r = min(take, a); r >= 0; --r) {\n        int &cur = dp[a][r];\n        if (cur) {\n          int k0 = two[n - a + r];\n          int k1 = two[n];\n          add(k1, mod - k0);\n          add(dp[a][r + 1], mult(cur, k1));\n          cur = mult(cur, k0);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    used[i] = 0;\n  }\n\n  int k = (n + 63) / 64;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0, p = 0; j < k; ++j) {\n      auto &cur = b[i][j];\n      cur = 0;\n      for (int iter = 0; iter < 64 && p < n; ++iter) {\n        cur ^= ((type) a[i][p++] << iter);\n      }\n    }\n  }\n  int rank = 0;\n  for (int c = 0; c < n; ++c) {\n    int r = -1;\n    for (int i = 0; i < n; ++i) {\n      if (used[i] || !(b[i][c >> 6] & ((type) 1 << (c & 63)))) {\n        continue;\n      }\n      r = i;\n      break;\n    }\n    if (r == -1) {\n      continue;\n    }\n    ++rank;\n    used[r] = 1;\n    for (int i = 0; i < n; ++i) {\n      if (i == r) {\n        continue;\n      }\n      if (b[i][c >> 6] & ((type) 1 << (c & 63))) {\n        for (int j = 0; j < k; ++j) {\n          b[i][j] ^= b[r][j];\n        }\n      }\n    }\n  }\n  eprintf(\"rank = %d\\n\", rank);\n  int res = 0;\n  for (int a = 0; a <= n; ++a) {\n    add(res, mult(mult(dp[a][rank], dp[n][a]), myPower(dp[n][rank], mod - 2)));\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nint get_rank(VV<int> A) { //mod 2\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(A[pivot], A[r]);\n\t\tif (A[r][i] == 0) continue;\n\t\tfor (int j = r+1; j < n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tfor (int k = i; k < m; ++k) {\n\t\t\t\t\tA[j][k] ^= A[r][k];\n\t\t\t\t}       \n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\treturn r;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int maxn = 310;\n\nll powmod(ll x, ll k) {\n    ll res = 1;\n    for (; k; k /= 2, x = x * x % MOD) {\n        if (k & 1) {\n            res = res * x % MOD;\n        }\n    }\n    return res;\n}\n\nll a[maxn], b[maxn], c[maxn][maxn], d[maxn][maxn], f[maxn][maxn], g[maxn][maxn];\nll p2[maxn];\n\nvoid precalc(int N) {\n\tp2[0] = 1;\n\trep(i, maxn - 1) {\n\t\tp2[i+1] = p2[i] * 2 % MOD;\n\t}\n\n\trep(i, maxn) {\n\t\tg[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tg[i][j] = g[i][j-1] * (p2[i] - p2[j-1] + MOD) % MOD;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\td[i][j] = g[i][j] * powmod(g[j][j], MOD - 2) % MOD;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tf[i][j] = g[j][j] * d[i][i-j] % MOD;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tc[i][j] = d[N][j] * f[i][j] % MOD * powmod(2, N*(N-i)) % MOD;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tb[i] = d[N][i] * f[N][i] % MOD;\n\t}\n\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = i; j <= N; ++j) {\n\t\t\ta[i] = (a[i] + b[j] * c[j][i]) % MOD;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tVV<int> C(N, V<int>(N));\n\trep(i, N) rep(j, N) cin >> C[i][j];\n\n\tprecalc(N);\n\n\tint R = get_rank(C);\n\n\tcout << a[R] * powmod(b[R], MOD - 2) % MOD << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nvoid debug(vector<int> &v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << v[i];\n\t}\n\tcout << endl;\n}\n\nll mod_pow(ll a, ll n,ll m=mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1<<18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n//Vnからr個の基底をとる\nmodint calc_comb(int n, int r) {\n\tmodint res = 1;\n\trep(i, r) {\n\t\tmodint c = mod_pow(2, n) - mod_pow(2, i);\n\t\tres = res * c;\n\t}\n\treturn res;\n}\n//Vnから次元rの部分空間を取る\nmodint calc_s(int n,int r) {\n\treturn calc_comb(n, r) / calc_comb(r, r);\n}\n//Vn->Vr全射準同型の個数\nmodint calc_smp(int n,int r) {\n\treturn calc_comb(r, r)*calc_s(n,n-r);\n}\n\n\nint Gaussian_elimination(vector<vector<int>> &A) {\n\tint n = A.size(); int m = A[0].size();\n\tint le = 0;\n\trep(j, m) {\n\t\tRep(i, le, n) {\n\t\t\tif (A[i][j]) {\n\t\t\t\tswap(A[le], A[i]);\n\t\t\t\tRep(i2, le + 1, n) {\n\t\t\t\t\tif (A[i2][j]) {\n\t\t\t\t\t\trep(k, m) {\n\t\t\t\t\t\t\tA[i2][k] ^= A[le][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tle++; break;\n\t\t\t}\n\t\t}\n\t}\n\treturn le;\n}\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<int>> b(n);\n\trep(i, n) {\n\t\tb[i].resize(n);\n\t\trep(j, n) {\n\t\t\tint t; cin >> t;\n\t\t\tb[i][j] = t;\n\t\t}\n\t}\n\n\tint r = Gaussian_elimination(b);\n\n\t\n\n\t//次元rの行列の数\n\tmodint ca = calc_s(n, r)*calc_smp(n,r);\n\n\t//A*Bが次元rになる\n\tmodint cb = 0;\n\tfor (int db = r; db <= n; db++) {\n\t\t//dimB=db\n\t\tmodint rb = calc_smp(n, db)*calc_s(n, db);\n\n\t\tmodint ext = mod_pow(mod_pow(2, n), n - db);\n\t\tmodint ra = calc_s(n, r)*calc_smp(db,r)*ext;\n\t\tcb += ra * rb;\n\t}\n\t//cout << cb << \" \" << ca << endl;\n\tmodint ans = cb / ca;\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\tinit_f(); //init();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\t//while(cin>>w>>h,w)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#ifdef DEBUG\n//#define _GLIBCXX_DEBUG\n//#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = 305;\ntypedef bitset < maxN > bs;\nbs f[maxN];\nint val[maxN][maxN];\nint pw2[maxN];\nint tot[maxN][maxN];\nint ways[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    pw2[0] = 1;\n    for (int i = 1; i <= n; i++) pw2[i] = mult(pw2[i - 1], 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int c;\n            cin >> c;\n            f[i][j] = c;\n        }\n    }\n    int rng = 0;\n    vector<bool> used(n);\n    for (int col = 0; col < n; col++) {\n        int who = -1;\n        for (int row = 0; row < n; row++) {\n            if (f[row][col] && !used[row]) who = row;\n        }\n        if (who == -1) continue;\n        used[who] = true;\n        rng++;\n        for (int row = 0; row < n; row++) {\n            if (!used[row]) {\n                if (f[row][col]) f[row] ^= f[who];\n            }\n        }\n    }\n    for (int i = n; i >= 0; i--) {\n        val[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            val[i][j] = val[i][j - 1];\n            val[i][j] = mult(val[i][j], sub(pw2[i], pw2[j - 1]));\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            tot[i][j] = mult(val[i][j], pw(val[j][j], mod - 2));\n        }\n    }\n    ways[0][0] = 1;\n    for (int i = 0; i < n; i++) {\n        for (int rng = 0; rng <= n; rng++) {\n            ways[i + 1][rng] = sum(ways[i + 1][rng], mult(ways[i][rng], pw2[rng]));\n            if (rng + 1 <= n) ways[i + 1][rng + 1] = sum(ways[i + 1][rng + 1], \n                                                    mult(ways[i][rng], sub(pw2[n], pw2[rng])));\n        }\n    }\n    /*int g = 0;\n    for (int a = 0; a < (1 << (n * n)); a++) {\n        for (int b = 0; b < (1 << (n * n)); b++) {\n            bool ok = true;\n            for (int x = 0; x < n; x++) {\n                for (int y = 0; y < n; y++) {\n                    int t = 0;\n                    for (int z = 0; z < n; z++) {\n                        if (a & (1 << (x * n + z))) {\n                            if (b & (1 << (z * n + y))) {\n                                t ^= 1;\n                            }\n                        }\n                    }\n                    if (t != f[x][y]) ok =false;\n                }\n            }\n            if (ok) g++;\n        }\n    }*/\n    int ans = 0;\n    for (int our_rng = rng; our_rng <= n; our_rng++) {\n        int coef = pw(2, n * (n - our_rng));\n        coef = mult(coef, ways[n][our_rng]);\n        coef = mult(coef, pw(tot[n][our_rng], mod - 2));\n        coef = mult(coef, tot[n][our_rng]);\n        coef = mult(coef, tot[our_rng][rng]);\n        coef = mult(coef, pw(tot[n][rng], mod - 2));\n        ans = sum(ans, coef);\n    }\n    cout << ans << endl;\n    return 0;\n} "
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 303 , P = 1e9 + 7;\nint n , a[N][N] , f[N][N] , pw2[N * N];\nint Pow(int x,int t) {int r=1;for(;t;t>>=1,x=ll(x)*x%P)if(t&1)r=ll(r)*x%P;return r;}\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b) {return ll(a)*b%P;}\n\nint main(){\n  rep(i,0,N*N) pw2[i] = i ? pw2[i-1] * 2 % P : 1;\n  scanf(\"%d\",&n);\n  rep(i,0,n) rep(j,0,n) scanf(\"%d\",a[i]+j);\n  int rank = 0;\n  rep(j,0,n) {\n    int id = -1;\n    rep(i,rank,n) if(a[i][j]) {\n      id = i;\n      break;\n    }\n    if(id == -1) continue;\n    rep(k,0,n) swap(a[rank][k] , a[id][k]);\n    rep(i,rank+1,n) if(a[i][j]) {\n      rep(k,0,n) a[i][k] ^= a[rank][k];\n    }\n    rank++;\n  }\n  f[0][0] = 1;\n  rep(i,0,n) rep(j,0,i+1) if(f[i][j]) {\n    pp(f[i+1][j] , mul(f[i][j] , pw2[j]));\n    pp(f[i+1][j+1] , mul(f[i][j] , (pw2[n] - pw2[j] + P) % P));\n  }\n  int ans = 0;\n  rep(i,rank,n+1) pp(ans , mul(f[n][i] , mul(f[i][rank] , pw2[n*(n-i)])));\n  ans = mul(ans , Pow(f[n][rank] , P - 2));\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int M = 305;\nconst ll p = 1e9+7;\n\nint c[M][M], n, r;\nll p2[M*M], dp[M][M];\n\nll ans = 0;\n\nint compr() {\n\tfor (int i = 0; i < n; ++i) {\n\t\tint ind = -1, m = n;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tif (c[j][k] == 1) {\n\t\t\t\t\tif (k < m)\n\t\t\t\t\t\tm = k, ind = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (ind == -1)\n\t\t\treturn i;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tswap(c[i][j], c[ind][j]);\n\t\tfor (int j = i+1; j < n; ++j)\n\t\t\tif (c[j][m] == 1)\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tc[j][k] ^= c[i][k];\n\t}\n\n\treturn n;\n}\n\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < M*M; ++i)\n\t\tp2[i] = 2*p2[i-1]%p;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcin >> c[i][j];\n\n\tr = compr(); // cout << r << endl;\n\tdp[r][r] = 1;\n\n\tfor (int i = 1; i <= r; ++i)\n\t\tdp[r][r] = dp[r][r]*(p2[n]-p2[i-1])%p;\n\n\tfor (int i = r; i <= n-1; ++i)\n\t\tfor (int j = r; j <= n-1; ++j) {\n\t\t\tdp[i+1][j] += dp[i][j]*p2[j-r];\n\t\t\tdp[i+1][j] %= p;\n\t\t\tdp[i+1][j+1] += dp[i][j]*(p+p2[n]-p2[j]);\n\t\t\tdp[i+1][j+1] %= p;\n\t\t}\n\n\tfor (int i = 0; i <= n; ++i) {\n\t\tans += dp[n][i]*p2[n*(n-i)];\n\t\tans %= p;\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint dp[310][310],a[310][310],n;\nll pw[310];\n\nint gauss() {\n\tint p=0;\n\trep(i,0,n) {\n\t\tint fg=0;\n\t\trep(j,p,n) if (a[j][i]) {\n\t\t\trep(k,0,n) swap(a[p][k],a[j][k]); fg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) continue;\n\t\trep(j,p+1,n) if (a[j][i]) {\n\t\t\trep(k,0,n) a[j][k]^=a[p][k];\n\t\t}\n\t\t++p;\n\t}\n\treturn p;\n}\nint main() {\n\tscanf(\"%d\",&n); pw[0]=1;\n\trep(i,1,n+1) pw[i]=pw[i-1]*2%mod;\n\tdp[0][0]=1;\n\trep(j,0,n) rep(k,0,j+1) {\n\t\tdp[j+1][k+1]=(dp[j+1][k+1]+dp[j][k]*(pw[n]-pw[k]))%mod;\n\t\tdp[j+1][k]=(dp[j+1][k]+dp[j][k]*pw[k])%mod;\n\t}\n\trep(i,0,n) rep(j,0,n) scanf(\"%d\",&a[i][j]);\n\tint r=gauss(),ret=0;\n\trep(i,r,n+1) ret=(ret+(ll)dp[n][i]*dp[i][r]%mod*powmod(2,n*n-i*n))%mod;\n\tret=ret*powmod(dp[n][r],mod-2)%mod;\n\tif (ret<0) ret+=mod;\n\tprintf(\"%lld\\n\",ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <cassert>\n#include <cstring>\n\nuint32_t N, RK;\nuint32_t C[300][300];\nuint64_t pows[301];\nbool zero[300];\nconst uint64_t MOD = 1000000007;\n\nuint64_t memo[301][301];\n\nuint64_t solve(int r, int rank) {\n  if (memo[r][rank] != -1) {\n    return memo[r][rank];\n  }\n\n  if (r == N) {\n    uint64_t ans = 1;\n    for (int i = rank + 1; i <= N; ++i) {\n      ans = (ans * pows[N]) % MOD;\n    }\n    return memo[r][rank] = ans;\n  } else {\n    uint64_t a = (pows[N] - pows[rank] + MOD) % MOD;\n\n    uint64_t indep = (a * solve(r + 1, rank + 1)) % MOD;\n    uint64_t depen = 0;\n\n    int nz = 0;\n    if (zero[r]) {\n      for (int i = 0; i < r; ++i) {\n        if (zero[i]) {\n          ++nz;\n        }\n      }\n      depen = pows[nz - r + rank] * solve(r + 1, rank) % MOD;\n    }\n\n#ifdef DEBUG\n    std::cout << \"f(\" << r << \", \" << rank << \") = \" << (indep + depen) << \" = \" << a << \" * f(\" << (r + 1) << \", \" << (rank + 1) << \")\";\n    if (zero[r]) {\n      std::cout << \" + \" << pows[nz] << \" * f(\" << (r + 1) << \", \" << rank << \")\" << std::endl;\n    } else {\n      std::cout << std::endl;\n    }\n#endif\n\n    return memo[r][rank] = (indep + depen) % MOD;\n  }\n}\n\nint main() {\n  memset(memo, -1, sizeof memo);\n\n  std::cin >> N;\n  RK = N;\n\n  pows[0] = 1;\n  for (int i = 0; i <= N; ++i) {\n    pows[i + 1] = (2 * pows[i]) % MOD;\n  }\n\n  for (int r = 0; r < N; ++r) {\n    for (int c = 0; c < N; ++c) {\n      std::cin >> C[r][c];\n    }\n  }\n\n  for (int c = 0; c < N; ++c) {\n    int r = 0;\n    for (; r < N; ++r) {\n      int t = 0;\n      for (; t < c && C[r][t] == 0; ++t);\n      if (t == c && C[r][t] == 1) {\n        break;\n      }\n    }\n    if (r == N) {\n      zero[c] = 1;\n      --RK;\n    } else {\n      std::swap(C[r], C[c]);\n      for (int r2 = c + 1; r2 < N; ++r2) {\n        if (C[r2][c] == 1) {\n          for (int c2 = 0; c2 < N; ++c2) {\n            if (c2 < c) {\n              assert(C[r2][c2] == 0);\n            } else {\n              C[r2][c2] ^= C[c][c2];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  std::cout << solve(0, 0) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n};\ntypedef ModInt<1000000007> mint;\ntemplate<int... Sizes>\nstruct MultidimensionalIndex;\ntemplate<>\nstruct MultidimensionalIndex<> {\n\tMultidimensionalIndex() {}\n\tint getTotalSize() const { return 1; }\n\tint getIndexAcc(int acc) const { return acc; }\n};\ntemplate<int Head, int... Tail>\nstruct MultidimensionalIndex<Head, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tenum { size = Head };\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(TailT... tail) : Base(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\ntemplate<int... Tail>\nstruct MultidimensionalIndex<0, Tail...> : MultidimensionalIndex<Tail...> {\n\tusing Base = MultidimensionalIndex<Tail...>;\n\tconst int size;\n\ttemplate<typename... TailT>\n\tMultidimensionalIndex(int head, TailT... tail) : size(head), MultidimensionalIndex<Tail...>(tail...) {}\n\tint getTotalSize() const { return size * Base::getTotalSize(); }\n\ttemplate<typename... TailT>\n\tint getIndexAcc(int acc, int head, TailT... tail) const { return Base::getIndexAcc(acc * size + head, tail...); }\n};\n\ntemplate<typename Val, int... Sizes>\nstruct DP : MultidimensionalIndex<Sizes...> {\n\tusing Base = MultidimensionalIndex<Sizes...>;\n\tstd::vector<Val> dp;\n\ttemplate<typename... SizesT>\n\tDP(SizesT... sizes) : Base(sizes...) {}\n\tvoid init(Val val) { dp.assign(Base::getTotalSize(), val); }\n\tvoid init() { dp.assign(Base::getTotalSize(), Val()); }\n\ttemplate<typename... SizesT>\n\tVal &operator()(SizesT... indices) { return dp[Base::getIndexAcc(0, indices...)]; }\n\ttemplate<typename... SizesT>\n\tVal operator()(SizesT... indices) const { return dp[Base::getIndexAcc(0, indices...)]; }\n\tvoid swap(DP &that) { dp.swap(that.dp); }\n};\n\ntypedef bitset<300> BitSet;\nint getRank(vector<BitSet> v, int B) {\n\tint n = (int)v.size(), rank = 0, used = 0;\n\tfor(int j = B - 1; j >= 0; j --) {\n\t\tint i = used;\n\t\twhile(i < n && !v[i][j]) i ++;\n\t\tif(i < n) {\n\t\t\tBitSet x = v[i];\n\t\t\tswap(v[i], v[used ++]);\n\t\t\t++ rank;\n\t\t\tfor(i = used; i < n; i ++)\n\t\t\t\tif(v[i][j])\n\t\t\t\t\tv[i] ^= x;\n\t\t}\n\t}\n\treturn rank;\n}\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<BitSet> C(N);\n\t\tfor(int i = 0; i < N; ++ i) {\n\t\t\tBitSet row;\n\t\t\trep(j, N) {\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\trow[j] = c != 0;\n\t\t\t}\n\t\t\tC[i] = row;\n\t\t}\n\t\tint rank = getRank(C, N);\n\t\tvector<mint> two(N * N + 1);\n\t\ttwo[0] = 1;\n\t\trer(n, 1, N * N)\n\t\t\ttwo[n] = two[n - 1] + two[n - 1];\n\t\tDP<mint, 0, 0> dp(N + 1, rank + 1), ndp = dp;\n\t\tndp.init();\n\t\tndp(0, 0) = 1;\n\t\trep(i, N) {\n\t\t\tdp.swap(ndp);\n\t\t\tndp.init();\n\t\t\trer(j, 0, i) rer(k, 0, min(j, rank)) {\n\t\t\t\tmint x = dp(j, k);\n\t\t\t\tif(x.x == 0) continue;\n\t\t\t\tndp(j, k) += x * two[j];\n\t\t\t\tndp(j + 1, k) += x * (two[N] - two[j + rank - k]);\n\t\t\t\tif(k < rank)\n\t\t\t\t\tndp(j + 1, k + 1) += x * (two[j + rank - k] - two[j]);\n\t\t\t}\n\t\t}\n\t\tmint ans;\n\t\trer(j, rank, N)\n\t\t\tans += ndp(j, rank) * two[N * (N - j)];\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int M = 305;\nconst ll p = 1e9+7;\n\nint c[M][M], n, r;\nll p2[M*M], dp[M][M];\n\nll ans = 0;\n\nint compr() {\n\tfor (int i = 0; i < n; ++i) {\n\t\tint ind = -1, m = n;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\tif (c[j][k] == 1) {\n\t\t\t\t\tif (k < m)\n\t\t\t\t\t\tm = k, ind = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (ind == -1)\n\t\t\treturn i;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tswap(c[i][j], c[ind][j]);\n\t\tfor (int j = i+1; j < n; ++j)\n\t\t\tif (c[j][m] == 1)\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tc[j][k] ^= c[i][k];\n\t}\n\n\treturn n;\n}\n\nint main() {\n\tp2[0] = 1;\n\tfor (int i = 1; i < M*M; ++i)\n\t\tp2[i] = 2*p2[i-1]%p;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tcin >> c[i][j];\n\n\tr = compr(); // cout << r << endl;\n\tdp[r][r] = 1;\n\n\tfor (int i = 1; i <= r; ++i)\n\t\tdp[r][r] = dp[r][r]*(p+p2[n]-p2[i-1])%p;\n\n\tfor (int i = r; i <= n-1; ++i)\n\t\tfor (int j = r; j <= n-1; ++j) {\n\t\t\tdp[i+1][j] += dp[i][j]*p2[j-r];\n\t\t\tdp[i+1][j] %= p;\n\t\t\tdp[i+1][j+1] += dp[i][j]*(p+p2[n]-p2[j]);\n\t\t\tdp[i+1][j+1] %= p;\n\t\t}\n\n\tfor (int i = 0; i <= n; ++i) {\n\t\tans += dp[n][i]*p2[n*(n-i)];\n\t\tans %= p;\n\t}\n\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mod=1000000007;\nint n;\ninline int getrank(bitset<300> c[300])\n{\n\tint ans=0,i,j;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=ans;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tswap(c[j],c[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j==n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=ans+1;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tc[j]^=c[ans];\n\t\t\t}\n\t\t}\n\t\t++ans;\n\t}\n\treturn ans;\n}\nint p2[90001];\ninline void init(void)\n{\n\tint i;\n\tp2[0]=1;\n\tfor(i=1;i<=90000;++i)\n\t{\n\t\tp2[i]=(p2[i-1]<<1)%mod;\n\t}\n\treturn;\n}\ninline void clear(long long (*dp)[301])\n{\n\tint i;\n\tfor(i=0;i<=n;++i)\n\t{\n\t\tmemset(dp[i],0,sizeof(long long)*(n+1));\n\t}\n\treturn;\n}\nlong long dp1[301][301],dp2[301][301];\nlong long (*dp)[301]=dp1,(*dpt)[301]=dp2;\nint main()\n{\n\tinit();\n\tint i,j,k,x,r;\n\tbitset<300> c[300];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i)\n\t{\n\t\tc[i].reset();\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tc[i][j]=x;\n\t\t}\n\t}\n\tr=getrank(c);\n//\tprintf(\"%d\\n\",r);\n\t\n\tclear(dp);\n\tdp[0][0]=1;\n\tfor(i=1;i<=n;++i)//放第几列 \n\t{\n\t\tclear(dpt);\n\t\tfor(j=0;j<=n;++j)//已有维数 \n\t\t{\n\t\t\tfor(k=0;k<=r;++k)//已包含c的维数 \n\t\t\t{\n\t\t\t\tdpt[j][k]+=(dp[j][k]*p2[j])%mod;\n\t\t\t\tif(j<n)\n\t\t\t\t{\n\t\t\t\t\tif(k<r)\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[r-k+j]))%mod;\n\t\t\t\t\t\tdpt[j+1][k+1]+=(dp[j][k]*(p2[r-k]-1))%mod*p2[j]%mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[j]))%mod;;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp,dpt);\n\t}\n\tlong long ans=0;\n\tfor(i=r;i<=n;++i)\n\t{\n\t\tans=(ans+dp[i][r]*p2[n*(n-i)])%mod;\n\t}\n\tprintf(\"%I64d\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n/*\n2\n0 1\n1 0\n\n6\n*/\n/*\n10\n1 0 0 1 1 1 0 0 1 0\n0 0 0 1 1 0 0 0 1 0\n0 0 1 1 1 1 1 1 1 1\n0 1 0 1 0 0 0 1 1 0\n0 0 1 0 1 1 1 1 1 1\n1 0 0 0 0 1 0 0 0 0\n1 1 1 0 1 0 0 0 0 1\n0 0 0 1 0 0 1 0 1 0\n0 0 0 1 1 1 0 0 0 0\n1 0 1 0 0 1 1 1 1 1\n\n741992411\n*/\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = MOD;\nconst int maxn = 310;\nint rk, n;\nint arr[maxn][maxn];\nll dp[2][maxn][maxn];\nll mi[maxn];\n\nint gauss() {\n\tint have = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint no = -1;\n\t\tfor(int j = have; j < n; j++) if(arr[j][i])\n\t\t\tno = j;\n\t\tif(no == -1) continue;\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tswap(arr[have][j], arr[no][j]);\n\t\tfor(int j = 0; j < n; j++) if(j != have && arr[j][i]) {\n\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\tarr[j][k] ^= arr[have][k];\n\t\t}\n\t\thave++;\n\t}\n//\tfor(int i = 0; i < n; i++) {\n//\t\tfor(int j = 0; j < n; j++) cerr << arr[i][j] << ' ';\n//\t\tcerr << endl;\n//\t}\n\treturn have;\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tscanf(\"%d\", arr[i] + j);\n\n\trk = gauss();\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0] = 1;\n\tmi[0] = 1;\n\tfor(int j = 1; j < maxn; j++) {\n\t\tmi[j] = mi[j - 1]\t * 2 % mod;\n\t}\n\tint now = 0, nxt = 1;\n\tfor(int i = 0; i < n; i++) {\n\t\tmemset(dp[nxt], 0, sizeof(dp[nxt]));\n\t\tfor(int j = 0; j <= i; j++) for(int k = j; k <= i; k++) if(dp[now][j][k]) {\n\t\t\tadd(dp[nxt][j + 1][k + 1], dp[now][j][k] * (mi[rk] - mi[j]) % mod * mi[k - j] % mod);\n\t\t\tadd(dp[nxt][j][k + 1], dp[now][j][k] * (mi[n] - mi[k] - (mi[rk] - mi[j]) * mi[k - j] % mod) % mod);\n\t\t\tadd(dp[nxt][j][k], dp[now][j][k] * mi[k]);\n\t\t}\n\t\tswap(now, nxt);\n\t}\n\n\tint ans = 0;\n\tfor(int i = rk; i <= n; i++)\n\t\tadd(ans, dp[now][rk][i] * pow(mi[n - i], n, mod) % mod);\n\n\tcout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint dp[310][310],a[310][310],n;\nll pw[310];\n\nint gauss() {\n\tint p=0;\n\trep(i,0,n) {\n\t\tint fg=0;\n\t\trep(j,p,n) if (a[j][i]) {\n\t\t\trep(k,0,n) swap(a[p][k],a[j][k]); fg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) continue;\n\t\trep(j,p+1,n) if (a[j][i]) {\n\t\t\trep(k,0,n) a[j][k]^=a[p][k];\n\t\t}\n\t\t++p;\n\t}\n\treturn p;\n}\nint main() {\n\tscanf(\"%d\",&n); pw[0]=1;\n\trep(i,1,n+1) pw[i]=pw[i-1]*2%mod;\n\tdp[0][0]=1;\n\trep(j,0,n) rep(k,0,j+1) {\n\t\tdp[j+1][k+1]=(dp[j+1][k+1]+dp[j][k]*(pw[n]-pw[k]))%mod;\n\t\tdp[j+1][k]=(dp[j+1][k]+dp[j][k]*pw[k])%mod;\n\t}\n\trep(i,0,n) rep(j,0,n) scanf(\"%d\",&a[i][j]);\n\tint r=gauss(),ret=0;\n\trep(i,r,n+1) {\n\t\tret=(ret+(ll)dp[n][i]*dp[i][r]%mod*powmod(2,n*n-i*n))%mod;\n\t}\n\tprintf(\"%lld\\n\",ret*powmod(dp[n][r],mod-2)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst llint mod = 1e9 + 7;\nconst int MAXN = 321;\n\nllint pot2[MAXN];\nint dp[MAXN][MAXN][MAXN]; // rows, columns, rank\n\nllint indep_vects(int dim, int k) {\n  llint ans = 1;\n  REP(i, k) {\n    ans *= (pot2[dim] - pot2[i] + mod) % mod;\n    ans %= mod;\n  }\n  return ans;\n}\n\nllint power_mod(llint b, llint e) {\n  llint ans = 1;\n  llint p2 = b;\n  for (; e; e >>= 1) {\n    if (e&1) ans = ans*p2 % mod;\n    p2 = p2*p2 % mod;\n  }\n  return ans;\n}\n\nllint mod_inv(llint x) {\n  return power_mod(x, mod-2);\n}\n\nllint k_subspaces(int dim, int k) {\n  return (llint)dp[dim][dim][dim-k] * mod_inv( indep_vects(dim, dim-k) ) % mod;\n}\n\nint get_matrix_rank(int C[][MAXN], int n) {\n  int rank = 0;\n\n  REP(j, n) {\n    int tmp_row = -1;\n    FOR(i, rank, n) if (C[i][j] != 0) { tmp_row = i; break; }\n    if (tmp_row == -1) {\n      \n    } else {\n      REP(k, n) swap(C[rank][k], C[tmp_row][k]);\n      assert(C[rank][j] == 1);\n\n      REP(r2, n) if (r2 != rank)\n        if (C[r2][j])\n          REP(k, n)\n            C[r2][k] ^= C[rank][k];\n            \n      ++rank;\n    }\n  }\n\n  return rank;\n}\n\nint main(void) {\n  pot2[0] = 1;\n  for (int i = 1; i < MAXN; ++i) pot2[i] = (pot2[i-1] * 2) % mod;\n\n  int n;\n  static int C[MAXN][MAXN];\n  scanf(\"%d\", &n);\n  REP(i, n) REP(j, n) scanf(\"%d\", C[i]+j);\n\n  //  TRACE(n);\n  //  TRACE(pot2[0] _ pot2[10]);\n  \n  //  TRACE(power_mod(2, 0));\n  //  TRACE(power_mod(2, 1));\n  //  TRACE(power_mod(2, 2));\n  //  TRACE(power_mod(2, 3));\n\n  //  TRACE(indep_vects(n, 0));\n  //  TRACE(indep_vects(n, 1));\n  //  TRACE(indep_vects(n, 2));\n  //  TRACE(indep_vects(n, 3));\n\n  //  TRACE(mod_inv(5) _ 5 * mod_inv(5) % mod);\n\n  memset(dp, 0, sizeof dp);\n  REP(rows, MAXN-1) {\n    dp[rows][0][0] = 1;\n\n    REP(c, MAXN-1) REP(r, MAXN-1) {\n      if (dp[rows][c][r] == 0) continue;\n\n      dp[rows][c+1][r+1] += (pot2[rows] - pot2[r] + mod) % mod * (llint)dp[rows][c][r] % mod;\n      dp[rows][c+1][r+1] %= mod;\n\n      dp[rows][c+1][r] += pot2[r] * (llint)dp[rows][c][r] % mod;\n      dp[rows][c+1][r] %= mod;\n    }\n  }\n\n  int rankC = get_matrix_rank(C, n);\n  //  TRACE(rankC);\n  //  TRACE(dp[n][n][n]);\n\n  //  TRACE(k_subspaces(n, 0));\n  //  TRACE(k_subspaces(n, 1));\n  //  TRACE(k_subspaces(n, 2));\n  //  TRACE(k_subspaces(n, 3));\n\n  int kerC = n - rankC;\n  llint ans = 0;\n  FOR(kerB, 0, kerC+1) {\n    llint val = k_subspaces(kerC, kerB);\n    val = val*indep_vects(n, n-kerB) % mod;\n    val = val*power_mod(pot2[n], kerB) % mod;\n    ans = (ans + val) % mod;\n\n    //    TRACE(kerB _ val);\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\n//int timer = 1;\n\nint testNumber = 1;\n\nbool todo = true;\n\nint main() {\n#ifdef AIM\n    freopen(\"/home/alexandero/ClionProjects/ACM/input.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n#else\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cerr << testNum << endl;\n        //cout << \"Case #\" << testNum++ << \": \";\n        solve(true);\n        ++testNumber;\n        //++timer;\n    }\n\n    /*while (true) {\n        solve(false);\n    }*/\n\n#ifdef AIM\n    cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n\n    return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\nvoid precalc() {\n\n}\n\n#define int li\n\nconst int mod = 1000000007;\n\nint dp[310][310][310];\n\nvoid add(int& cur, int add) {\n    cur += add;\n    if (cur >= mod) {\n        cur -= mod;\n    }\n}\n\nvector<vector<int>> get_from_mask(int mask, int n) {\n    vector<vector<int>> res(n, vector<int>(n));\n    for (int  i= 0; i < n; ++i) {\n        for (int j = 0 ;j < n; ++j) {\n            res[i][j] = (mask & 1);\n            mask >>= 1;\n        }\n    }\n    return res;\n}\n\nvector<vector<int>> mult(vector<vector<int>> a, vector<vector<int>> b, int n) {\n    vector<vector<int>> res(n, vector<int>(n));\n    for (int  i= 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < n; ++k) {\n                res[j][i] ^= (a[i][k] * b[k][j]);\n            }\n        }\n    }\n    return res;\n}\n\nvoid solve(bool read) {\n    int n;\n    if (read) {\n        cin >> n;\n    }\n    else {\n        n = 2;\n    }\n    vector<vector<int>> matrix(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (read) {\n                cin >> matrix[j][i];\n            }\n            else {\n                matrix[i][j] = rand() % 2;\n            }\n        }\n    }\n\n    auto old = matrix;\n\n    vector<int> nums;\n    vector<int> first_bit;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < nums.size(); ++j) {\n            if (matrix[i][first_bit[j]]) {\n                for (int r = 0; r < n; ++r) {\n                    matrix[i][r] ^= matrix[nums[j]][r];\n                }\n            }\n        }\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j]) {\n                nums.push_back(i);\n                first_bit.push_back(j);\n                break;\n            }\n        }\n    }\n\n    vector<int> new_rank(n, 0);\n    for (int x : nums) {\n        new_rank[x] = 1;\n    }\n\n    vector<int> powers(n + 1, 1);\n    for (int i = 1; i < powers.size(); ++i) {\n        powers[i] = powers[i - 1] * 2 % mod;\n    }\n\n    memset(dp, 0, sizeof dp);\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int r = 0; r <= i; ++r) {\n            for (int rem = 0; rem + r <= i; ++rem) {\n                if (new_rank[i]) {\n                    add(dp[i + 1][r + 1][rem], dp[i][r][rem] * (powers[n] - powers[r + rem]) % mod);\n                    continue;\n                }\n                add(dp[i + 1][r][rem], dp[i][r][rem] * powers[rem] % mod);\n                add(dp[i + 1][r][rem + 1], dp[i][r][rem] * (powers[n] - powers[rem + r]) % mod);\n            }\n        }\n    }\n\n    int res = 0;\n    for (int r = 0; r <= n; ++r) {\n        for (int rem = 0; rem + r <= n; ++rem) {\n            res += dp[n][r][rem] * binpow(powers[n - rem - r], n, mod) % mod;\n            //cout << r << ' ' << rem << ' ' << dp[n][r][rem] << endl;\n            res %= mod;\n        }\n    }\n\n    if (res < 0) {\n        res += mod;\n    }\n    cout << res << endl;\n\n\n   /* int stupid_res = 0;\n    for (int mask = 0; mask < (1 << (n * n)); ++mask) {\n        auto a = get_from_mask(mask, n);\n        for (int mask1 = 0; mask1 < (1 << (n * n)); ++mask1) {\n            auto b = get_from_mask(mask1, n);\n            if (mult(a, b, n) == old) {\n                ++stupid_res;\n            }\n            else {\n\n            }\n        }\n    }\n\n    if (stupid_res != res) {\n        cout << res << ' ' << stupid_res << endl;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cout << old[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        exit(0);\n    }*/\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n\ntemplate<lint mod>\nstruct Int_{\n  unsigned x;\n  unsigned mpow(Int_ a,unsigned k){\n    Int_ res=1;\n    while(k){\n      if(k&1) res=res*a;\n      a=a*a;\n      k>>=1;\n    }\n    return res.x;\n  }\n  unsigned inverse(Int_ a){\n    return mpow(a,mod-2);\n  }\n  Int_(): x(0) { }\n  Int_(long long sig) {\n    int sigt=sig%mod;\n    if(sigt<0) sigt+=mod;\n    x=sigt;\n  }\n  unsigned get() const { return (unsigned)x; }\n  \n  Int_ &operator+=(Int_ that) { if((x += that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator-=(Int_ that) { if((x += mod - that.x) >= mod) x -= mod; return *this; }\n  Int_ &operator*=(Int_ that) { x = (unsigned long long)x * that.x % mod; return *this; }\n  Int_ &operator=(Int_ that) { x=that.x; return *this;}\n  Int_ &operator/=(Int_ that) { x=(unsigned long long) x * inverse(that.x)%mod; return *this;}\n  bool operator==(Int_ that) const { return x==that.x; }\n  bool operator!=(Int_ that) const { return x!=that.x; }\n\n  Int_ operator-() const { return Int_(0)-Int_(*this);}\n  Int_ operator+(Int_ that) const { return Int_(*this) += that; }\n  Int_ operator-(Int_ that) const { return Int_(*this) -= that; }\n  Int_ operator*(Int_ that) const { return Int_(*this) *= that; }\n  Int_ operator/(Int_ that) const { return Int_(*this) /= that; }\n\n};\n\nnamespace std{\n  template<lint mod>\n  ostream &operator <<(ostream& out,const Int_<mod>& a){\n    out<<a.get();\n    return out;\n  }\n  template<lint mod>\n  istream &operator >>(istream& in,Int_<mod>& a){\n    in>>a.x;\n    return in;\n  }\n};\n\ntypedef Int_<1000000007> Int;\n\n//const int INF=5e8;\nint n;\nint c[305][305];\n\nInt dp[305][305][305];\n\nInt pw2[605*305];\nint main(){\n  cin>>n;\n  REP(i,n) REP(j,n) cin>>c[i][j];\n\n  pw2[0]=1;\n  REP(i,n*2*n) pw2[i+1]=pw2[i]*2;\n\n  int R=0;\n  REP(i,n){\n    bool found=false;\n    REPN(j,n,R) if(c[j][i]){\n      if(j>R) REP(k,n) swap(c[j][k],c[R][k]);\n      found=true;\n      break;\n    }\n    if(!found) continue;\n    REPN(j,n,R+1) if(c[j][i]){\n      REP(k,n) c[j][k]^=c[R][k];\n    }\n    ++R;\n  }\n\n  dp[0][0][0]=1;\n  REP(i,n) REP(j,n) REP(k,n) if(dp[i][j][k].x){\n    Int val=dp[i][j][k];\n    dp[i+1][j][k]+=val*pw2[j];\n    if(j+R-k>=0) dp[i+1][j+1][k]+=val*(pw2[n]-pw2[j+R-k]);\n    if(j+R-k>=0) dp[i+1][j+1][k+1]+=val*(pw2[j+R-k]-pw2[j]);\n  }\n\n  Int res=0;\n  REP(j,n+1) res+=dp[n][j][R]*pw2[n*(n-j)];\n\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = MOD;\nconst int maxn = 310;\nint rk, n;\nint arr[maxn][maxn];\nll dp[2][maxn][maxn];\nll mi[maxn];\n\nint gauss() {\n\tint have = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint no = -1;\n\t\tfor(int j = have; j < n; j++) if(arr[j][i])\n\t\t\tno = j;\n\t\tif(no == -1) continue;\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tswap(arr[have][j], arr[no][j]);\n\t\tfor(int j = 0; j < n; j++) if(j != have && arr[j][i]) {\n\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\tarr[j][k] ^= arr[have][k];\n\t\t}\n\t\thave++;\n\t}\n\treturn have;\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tscanf(\"%d\", arr[i] + j);\n\n\trk = gauss();\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0] = 1;\n\tmi[0] = 1;\n\tfor(int j = 1; j < maxn; j++) {\n\t\tmi[j] = mi[j - 1]\t * 2 % mod;\n\t}\n\tint now = 0, nxt = 1;\n\tfor(int i = 0; i < n; i++) {\n\t\tmemset(dp[nxt], 0, sizeof(dp[nxt]));\n\t\tfor(int j = 0; j <= min(rk, i); j++) for(int k = j; k <= i; k++) if(dp[now][j][k]) {\n\t\t\tadd(dp[nxt][j + 1][k + 1], dp[now][j][k] * (mi[rk] - mi[j]) % mod * mi[k - j] % mod);\n\t\t\tadd(dp[nxt][j][k + 1], dp[now][j][k] * (mi[n] - mi[k] - (mi[rk] - mi[j]) * mi[k - j] % mod) % mod);\n\t\t\tadd(dp[nxt][j][k], dp[now][j][k] * mi[k] % mod);\n\t\t}\n\t\tswap(now, nxt);\n\t}\n\n\tint ans = 0;\n\tfor(int i = rk; i <= n; i++)\n\t\tadd(ans, dp[now][rk][i] * pow(mi[n - i], n, mod) % mod);\n\n\tcout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint t[310][310];\nlong long g[310][3];\nlong long dp[310][310];\nint main(){\n\tinit_C(1000);\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tscanf(\"%d\",&t[i][j]);\n\t\t}\n\t}\n\tint R=0;\n\tfor(int i=0;i<a;i++){\n\t\tint at=-1;\n\t\tfor(int j=R;j<a;j++){\n\t\t\tif(t[j][i])at=j;\n\t\t}\n\t\tif(at!=-1){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tswap(t[at][j],t[R][j]);\n\t\t\t}\n\t\t\tfor(int j=R+1;j<a;j++){\n\t\t\t\tif(t[j][i]){\n\t\t\t\t\tfor(int k=0;k<a;k++)t[j][k]^=t[R][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tR++;\n\t\t}\n\t}\n\tfor(int i=0;i<=a;i++){\n\t\tfor(int j=1;j<=i;j+=2){\n\t\t\tg[i][0]=(g[i][0]+Comb(i,j)*pw(3,i-j))%mod;\n\t\t}\n\t\tg[i][2]=(mod+pw(2,2*a)+(mod+1-pw(2,a-i+1))*pw(2,2*i))%mod;\n\t\tg[i][1]=(pw(2,2*a)+mod-(g[i][0]+g[i][2])%mod)%mod;\n\t\t//printf(\"%lld %lld %lld\\n\",g[i][0],g[i][1],g[i][2]);\n\t}\n\n\tdp[0][R]=1;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<=a;j++){\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tif(j+k-1>=0&&j+k-1<=a){\n\t\t\t\t\tdp[i+1][j+k-1]=(dp[i+1][j+k-1]+dp[i][j]*g[j][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[a][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst llint mod = 1e9 + 7;\nconst int MAXN = 321;\n\nllint pot2[MAXN];\nllint dp[MAXN][MAXN][MAXN]; // columns, rank\n\nllint indep_vects(int dim, int k) {\n  llint ans = 1;\n  REP(i, k) {\n    ans *= (pot2[dim] - pot2[i] + mod) % mod;\n    ans %= mod;\n  }\n  return ans;\n}\n\nllint power_mod(llint b, llint e) {\n  llint ans = 1;\n  llint p2 = b;\n  for (; e; e >>= 1) {\n    if (e&1) ans = ans*p2 % mod;\n    p2 = p2*p2 % mod;\n  }\n  return ans;\n}\n\nllint mod_inv(llint x) {\n  return power_mod(x, mod-2);\n}\n\nllint k_subspaces(int dim, int k) {\n  return dp[dim][dim][dim-k] * mod_inv( indep_vects(dim, dim-k) ) % mod;\n}\n\nint get_matrix_rank(int C[][MAXN], int n) {\n  int rank = 0;\n\n  REP(j, n) {\n    int tmp_row = -1;\n    FOR(i, rank, n) if (C[i][j] != 0) { tmp_row = i; break; }\n    if (tmp_row == -1) {\n      \n    } else {\n      REP(k, n) swap(C[rank][k], C[tmp_row][k]);\n      assert(C[rank][j] == 1);\n\n      REP(r2, n) if (r2 != rank)\n        if (C[r2][j])\n          REP(k, n)\n            C[r2][k] ^= C[rank][k];\n            \n      ++rank;\n    }\n  }\n\n  return rank;\n}\n\nint main(void) {\n  pot2[0] = 1;\n  for (int i = 1; i < MAXN; ++i) pot2[i] = (pot2[i-1] * 2) % mod;\n\n  int n;\n  static int C[MAXN][MAXN];\n  scanf(\"%d\", &n);\n  REP(i, n) REP(j, n) scanf(\"%d\", C[i]+j);\n\n  //  TRACE(n);\n  //  TRACE(pot2[0] _ pot2[10]);\n  \n  //  TRACE(power_mod(2, 0));\n  //  TRACE(power_mod(2, 1));\n  //  TRACE(power_mod(2, 2));\n  //  TRACE(power_mod(2, 3));\n\n  //  TRACE(indep_vects(n, 0));\n  //  TRACE(indep_vects(n, 1));\n  //  TRACE(indep_vects(n, 2));\n  //  TRACE(indep_vects(n, 3));\n\n  //  TRACE(mod_inv(5) _ 5 * mod_inv(5) % mod);\n\n  memset(dp, 0, sizeof dp);\n  REP(rows, MAXN-1) {\n    dp[rows][0][0] = 1;\n\n    REP(c, MAXN-1) REP(r, MAXN-1) {\n      if (dp[rows][c][r] == 0) continue;\n\n      dp[rows][c+1][r+1] += (pot2[rows] - pot2[r] + mod) % mod * dp[rows][c][r] % mod;\n      dp[rows][c+1][r+1] %= mod;\n\n      dp[rows][c+1][r] += pot2[r] * dp[rows][c][r] % mod;\n      dp[rows][c+1][r] %= mod;\n    }\n  }\n\n  int rankC = get_matrix_rank(C, n);\n  //  TRACE(rankC);\n  //  TRACE(dp[n][n][n]);\n\n  //  TRACE(k_subspaces(n, 0));\n  //  TRACE(k_subspaces(n, 1));\n  //  TRACE(k_subspaces(n, 2));\n  //  TRACE(k_subspaces(n, 3));\n\n  int kerC = n - rankC;\n  llint ans = 0;\n  FOR(kerB, 0, kerC+1) {\n    llint val = k_subspaces(kerC, kerB);\n    val = val*indep_vects(n, n-kerB) % mod;\n    val = val*power_mod(pot2[n], kerB) % mod;\n    ans = (ans + val) % mod;\n\n    //    TRACE(kerB _ val);\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 303;\nconst int mod = 1e9 + 7;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nint c[MAX][MAX];\nint f[MAX][MAX][MAX];\nint pw[MAX*MAX];\n\nint main(void) {\n  int N;\n  scanf(\"%d\", &N);\n  REP(i, N) REP(j, N) scanf(\"%d\", &c[i][j]);\n\n\n  int r = 0;\n  REP(i, N) {\n    int k = -1;\n    FOR(j, r, N)\n      if (c[j][i]) { k = j; break; }\n    if (k == -1) continue;\n      \n    REP(j, N) swap(c[r][j], c[k][j]);\n    REP(j, N)\n      if (j != r && c[j][i])\n        REP(k, N) c[j][k] ^= c[r][k];\n    r++;\n  }\n\n  pw[0] = 1;\n  FOR(i, 1, MAX*MAX) pw[i] = mul(pw[i-1], 2);\n  \n  f[0][0][0] = 1;\n  REP(i, N) REP(rc, min(i+1, r+1)) REP(rn, min(i+1-rc, N-r+1)) {\n    f[i+1][rc][rn] = add(f[i+1][rc][rn], mul(pw[rc+rn], f[i][rc][rn]));\n    if (rc < r) {\n      f[i+1][rc+1][rn] = add(f[i+1][rc+1][rn], mul(sub(pw[r+rn], pw[rc+rn]), f[i][rc][rn]));\n    }\n    if (rn < N-r) {\n      f[i+1][rc][rn+1] = add(f[i+1][rc][rn+1], mul(sub(pw[N], pw[r+rn]), f[i][rc][rn]));\n    }\n  }\n\n  int ans = 0;\n  REP(rn, N-r+1) ans = add(ans, mul(pw[N*(N-rn-r)], f[N][r][rn]));\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nconst long long mod = 1000000007;\n\nlong long fpow(long long a, long long p)\n{\n\tlong long r = 1;\n\twhile (p){\n\t\tif (p & 1) r = r * a % mod;\n\t\ta = a * a % mod;\n\t\tp /= 2;\n\t}\n\treturn r;\n}\n\nint N, b[303][303];\nlong long first[303], mul[303];\nlong long cnt[303][303][303];\n\nlong long go(int n, int m, int r)\n{\n\tif (r < 0) return 0;\n\tif (n == 0 || m == 0) return r == 0;\n\tif (cnt[n][m][r] != -1) return cnt[n][m][r];\n\tlong long &res = cnt[n][m][r]; res = 0;\n\tres = go(n, m - 1, r-1);\n\tres = (res + go(n - 1, m - 1, r) * (fpow(2, n) - 1) % mod * fpow(2, m - 1)) % mod;\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++) scanf(\"%d\", &b[i][j]);\n\n\tfor (int i = 0; i <= N; i++) for (int j = 0; j <= N; j++) for (int k = 0; k <= N; k++) cnt[i][j][k] = -1;\n\n\tint rank = 0;\n\tfor (int i = 0, s = 0; i < N; i++, s++){\n\t\tbool g = 0;\n\t\tfor (int j = i; j < N; j++) if (b[j][s]){\n\t\t\tif (i != j) for (int k = 0; k < N; k++) swap(b[i][k], b[j][k]);\n\t\t\tg = 1;\n\t\t}\n\t\tif (!g){\n\t\t\trank++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i + 1; j < N; j++) if (b[j][s]){\n\t\t\tfor (int k = 0; k < N; k++) b[j][k] ^= b[i][k];\n\t\t}\n\t}\n\n\tfirst[1] = 1;\n\tmul[0] = 3;\n\tfor (int i = 2; i <= N; i++){\n\t\tfirst[i] = first[i - 1] * fpow(2, i - 1) % mod * (fpow(2, i) - 1) % mod;\n\t\tlong long sum = 0, now = first[i];\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tsum = (sum + now * go(i, i, j)) % mod;\n\t\t\tif (j < i-1) now = now * mul[j] % mod;\n\t\t}\n\t\tmul[i-1] = (fpow(2,i*i*2) - sum + mod)* fpow(now, mod - 2) % mod;\n\t}\n\tlong long ans = first[N];\n\tfor (int i = 0; i < rank; i++) ans = ans * mul[i] % mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define MOD 1000000007LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<ll> polymul(vector<ll> f, vector<ll> g){\n\tint m=f.size(), n=g.size();\n\tvector<ll> h;\n\tfor(int k=0; k<m+n-1; k++){\n\t\th.push_back(0);\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\th[i+j]+=(f[i]*g[j]);\n\t\t\th[i+j]%=MOD;\n\t\t}\n\t}\n\treturn h;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tll p2[90001];\n\tp2[0]=1;\n\tfor(int i=1; i<=n*n; i++){\n\t\tp2[i]=p2[i-1]*2%MOD;\n\t}\n\tint c[300][300];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>c[i][j];\n\t\t}\n\t}\n\tint r=0;\n\tfor(int j=0; j<n; j++){\n\t\tint i0=-1;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(c[i][j]==1){\n\t\t\t\ti0=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i0==-1) continue;\n\t\tfor(int i=i0+1; i<n; i++){\n\t\t\tif(c[i][j]==0) continue;\n\t\t\tc[i][j]=0;\n\t\t\tfor(int k=j+1; k<n; k++){\n\t\t\t\tif(c[i0][k]==1) c[i][k]=1-c[i][k];\n\t\t\t}\n\t\t}\n\t\tfor(int k=j+1; k<n; k++){\n\t\t\tc[i0][k]=0;\n\t\t}\n\t\tr++;\n\t}\n\tll ans=0;\n\tfor(int s=r; s<=n; s++){\n\t\tif(s==0){\n\t\t\tans+=p2[n*n];\n\t\t\tcontinue;\n\t\t}\n\t\tll ans1=1;\n\t\tfor(int i=0; i<s; i++){\n\t\t\tans1*=(p2[n]+MOD-p2[i]);\n\t\t\tans1%=MOD;\n\t\t}\n\t\tll dp[301][301];\n      for(int j=0; j<=n-s; j++){\n        dp[0][j]=1;\n      }\n      for(int i=1; i<=s-r; i++){\n        dp[i][0]=1;\n      }\n      for(int i=1; i<=s-r; i++){\n        for(int j=1; j<=n-s; j++){\n          dp[i][j]=(dp[i][j-1]*p2[i]%MOD+dp[i-1][j])%MOD;\n        }\n      }\n\t\tans1*=dp[s-r][n-s];\n\t\tans1%=MOD;\n\t\tans1*=p2[n*(n-s)];\n\t\tans1%=MOD;\n\t\tans+=ans1;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define MOD 1000000007LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<ll> polymul(vector<ll> f, vector<ll> g){\n\tint m=f.size(), n=g.size();\n\tvector<ll> h;\n\tfor(int k=0; k<m+n-1; k++){\n\t\th.push_back(0);\n\t}\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\th[i+j]+=(f[i]*g[j]);\n\t\t\th[i+j]%=MOD;\n\t\t}\n\t}\n\treturn h;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tll p2[90001];\n\tp2[0]=1;\n\tfor(int i=1; i<=n*n; i++){\n\t\tp2[i]=p2[i-1]*2%MOD;\n\t}\n\tint c[300][300];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>c[i][j];\n\t\t}\n\t}\n\tint r=0;\n\tfor(int j=0; j<n; j++){\n\t\tint i0=-1;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(c[i][j]==1){\n\t\t\t\ti0=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i0==-1) continue;\n\t\tfor(int i=i0+1; i<n; i++){\n\t\t\tif(c[i][j]==0) continue;\n\t\t\tc[i][j]=0;\n\t\t\tfor(int k=j+1; k<n; k++){\n\t\t\t\tif(c[i0][k]==1) c[i][k]=1-c[i][k];\n\t\t\t}\n\t\t}\n\t\tfor(int k=j+1; k<n; k++){\n\t\t\tc[i0][k]=0;\n\t\t}\n\t\tr++;\n\t}\n\tll ans=0;\n\tfor(int s=r; s<=n; s++){\n\t\tif(s==0){\n\t\t\tans+=p2[n*n];\n\t\t\tcontinue;\n\t\t}\n\t\tll ans1=1;\n\t\tfor(int i=0; i<s; i++){\n\t\t\tans1*=(p2[n]+MOD-p2[i]);\n\t\t\tans1%=MOD;\n\t\t}\n\t\tvector<ll> p;\n\t\tp.push_back(1);\n\t\tfor(int i=0; i<=s-r; i++){\n\t\t\tvector<ll> q;\n\t\t\tfor(int j=0; j<=n-s; j++){\n\t\t\t\tq.push_back(p2[i*j]);\n\t\t\t}\n\t\t\tp=polymul(p, q);\n\t\t\tp.resize(n-s+1);\n\t\t}\n\t\tans1*=p[n-s];\n\t\tans1%=MOD;\n\t\tans1*=p2[n*(n-s)];\n\t\tans1%=MOD;\n\t\tans+=ans1;\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mod=1000000007;\nint n;\ninline int getrank(bitset<300> c[300])\n{\n\tint ans=0,i,j;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=ans;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tswap(c[j],c[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j==n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=ans+1;j<n;++j)\n\t\t{\n\t\t\tif(c[j][i])\n\t\t\t{\n\t\t\t\tc[j]^=c[ans];\n\t\t\t}\n\t\t}\n\t\t++ans;\n\t}\n\treturn ans;\n}\nint p2[90001];\ninline void init(void)\n{\n\tint i;\n\tp2[0]=1;\n\tfor(i=1;i<=90000;++i)\n\t{\n\t\tp2[i]=(p2[i-1]<<1)%mod;\n\t}\n\treturn;\n}\ninline void clear(long long (*dp)[301])\n{\n\tint i;\n\tfor(i=0;i<=n;++i)\n\t{\n\t\tmemset(dp[i],0,sizeof(long long)*(n+1));\n\t}\n\treturn;\n}\nlong long dp1[301][301],dp2[301][301];\nlong long (*dp)[301]=dp1,(*dpt)[301]=dp2;\nint main()\n{\n\tinit();\n\tint i,j,k,x,r;\n\tbitset<300> c[300];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tc[i][j]=x;\n\t\t}\n\t}\n\tr=getrank(c);\n//\tprintf(\"%d\\n\",r);\n\t\n\tclear(dp);\n\tdp[0][0]=1;\n\tfor(i=1;i<=n;++i)//放第几列 \n\t{\n\t\tclear(dpt);\n\t\tfor(j=0;j<=n;++j)//已有维数 \n\t\t{\n\t\t\tfor(k=0;k<=r;++k)//已包含c的维数 \n\t\t\t{\n\t\t\t\tdpt[j][k]+=(dp[j][k]*p2[j])%mod;\n\t\t\t\tif(j<n)\n\t\t\t\t{\n\t\t\t\t\tif(k<r)\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[r-k+j]))%mod;\n\t\t\t\t\t\tdpt[j+1][k+1]+=(dp[j][k]*(p2[r-k]-1))%mod*p2[j]%mod;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdpt[j+1][k]+=(dp[j][k]*(p2[n]-p2[j]))%mod;;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp,dpt);\n\t}\n\tlong long ans=0;\n\tfor(i=r;i<=n;++i)\n\t{\n\t\tans=(ans+dp[i][r]*p2[n*(n-i)])%mod;\n\t}\n\tprintf(\"%I64d\",(ans%mod+mod)%mod);\n\treturn 0;\n}\n/*\n2\n0 1\n1 0\n\n6\n*/\n/*\n10\n1 0 0 1 1 1 0 0 1 0\n0 0 0 1 1 0 0 0 1 0\n0 0 1 1 1 1 1 1 1 1\n0 1 0 1 0 0 0 1 1 0\n0 0 1 0 1 1 1 1 1 1\n1 0 0 0 0 1 0 0 0 0\n1 1 1 0 1 0 0 0 0 1\n0 0 0 1 0 0 1 0 1 0\n0 0 0 1 1 1 0 0 0 0\n1 0 1 0 0 1 1 1 1 1\n\n741992411\n*/\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null frac[N_MAX], invf[N_MAX];\null dp[900][900], dq[900][900];\null ncr (ull n, ull r) {\n\tif (n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tull rank;\n\tfor (rank = 0; rank < n; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < n; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < n) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[rank][ki] ^= table[i][ki];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tif (!table[rank][ki]) continue;\n\t\t\tfor (li = rank; li < n; li++) {\n\t\t\t\ttable[li][ki] ^= table[li][rank];\n\t\t\t}\n\t\t}\n\t\tfor (li = rank + 1; li < n; li++) {\n\t\t\ttable[li][rank] ^= table[rank][rank];\n\t\t}\n\t}\n\t// printf(\"%llu\\n\", rank);\n\n\tdp[0][n - rank] = 1;\n\tfor (i = 1; i <= n - rank; i++) {\n\t\tfor (j = 0; j < n - rank; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t\tfor (ki = j + 1; ki <= n - rank; ki++) {\n\t\t\t\tdp[i][j] += dp[i - 1][ki] * ncr(ki, ki - j) % MOD;\n\t\t\t}\n\t\t\tdp[i][j] %= MOD;\n\t\t\t// printf(\"%llu %llu: %llu\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tdq[0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j <= i; j++) {\n\t\t\tdq[i][j] = (j ? dq[i - 1][j - 1] : 0) + bitpow(2, j, MOD) * dq[i - 1][j] % MOD;\n\t\t\t// printf(\"%llu %llu; %llu\\n\", i, j, dq[i][j]);\n\t\t}\n\t}\n\n\tresult = 0;\n\tfor (i = rank; i <= n; i++) {\n\t\tull item1 = dq[n][i] * invf[i - rank] % MOD;\n\t\tull item2 = 0;\n\t\tull item3 = 1;\n\t\tfor (j = 0; j <= n - rank; j++) {\n\t\t\titem2 += dp[i - rank][j];\n\t\t}\n\t\titem2 %= MOD;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\titem3 *= (MOD + bitpow(2, i, MOD) - bitpow(2, j, MOD));\n\t\t\titem3 %= MOD;\n\t\t}\n\t\tresult += ((item1 * item2 % MOD) * item3 % MOD) * bitpow(2, (n - i) * n, MOD) % MOD;\n\t}\n\tresult %= MOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tn = 3;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\t// for (i = 1; i <= n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &c[i], &a[i], &b[i]);\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null frac[N_MAX], invf[N_MAX];\null dp[900][900], dq[900][900];\null ncr (ull n, ull r) {\n\tif (n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % MOD) % MOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tull rank;\n\tfor (rank = 0; rank < n; rank++) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < n; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < n) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (j > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[ki][rank] ^= table[ki][j];\n\t\t\t}\n\t\t}\n\t\tif (i > rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\ttable[rank][ki] ^= table[i][ki];\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tif (!table[rank][ki]) continue;\n\t\t\tfor (li = rank; li < n; li++) {\n\t\t\t\ttable[li][ki] ^= table[li][rank];\n\t\t\t}\n\t\t}\n\t\tfor (li = rank + 1; li < n; li++) {\n\t\t\ttable[li][rank] ^= table[rank][rank];\n\t\t}\n\t}\n\t// printf(\"%llu\\n\", rank);\n\n\tdp[0][n - rank] = 1;\n\tfor (i = 1; i <= n - rank; i++) {\n\t\tfor (j = 0; j < n - rank; j++) {\n\t\t\tdp[i][j] = 0;\n\t\t\tfor (ki = j + 1; ki <= n - rank; ki++) {\n\t\t\t\tdp[i][j] += dp[i - 1][ki] * ncr(ki, ki - j) % MOD;\n\t\t\t}\n\t\t\tdp[i][j] %= MOD;\n\t\t\t// printf(\"%llu %llu: %llu\\n\", i, j, dp[i][j]);\n\t\t}\n\t}\n\tdq[0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j <= i; j++) {\n\t\t\tdq[i][j] = ((j ? dq[i - 1][j - 1] : 0) + bitpow(2, j, MOD) * dq[i - 1][j] % MOD) % MOD;\n\t\t\t// printf(\"%llu %llu; %llu\\n\", i, j, dq[i][j]);\n\t\t}\n\t}\n\n\tresult = 0;\n\tfor (i = rank; i <= n; i++) {\n\t\tull item1 = dq[n][i] * invf[i - rank] % MOD;\n\t\tull item2 = 0;\n\t\tull item3 = 1;\n\t\tfor (j = 0; j <= n - rank; j++) {\n\t\t\titem2 += dp[i - rank][j];\n\t\t}\n\t\titem2 %= MOD;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\titem3 *= (MOD + bitpow(2, i, MOD) - bitpow(2, j, MOD));\n\t\t\titem3 %= MOD;\n\t\t}\n\t\tresult += ((item1 * item2 % MOD) * item3 % MOD) * bitpow(2, (n - i) * n, MOD) % MOD;\n\t}\n\tresult %= MOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tn = 3;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\t// for (i = 1; i <= n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &c[i], &a[i], &b[i]);\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint rank(int **A, int N){\n\tint i, j, k, l, *tmp;\n\tfor(i = 0, j = 0; j < N; j++){\n//\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\tfor(k = i; k < N && A[k][j] == 0; k++);\n//\t\tprintf(\"k = %lld\\n\", k);\n\t\tif(k == N){\n\t\t\tcontinue;\n\t\t}\n\t\ttmp = A[i];\n\t\tA[i] = A[k];\n\t\tA[k] = tmp;\n\t\tfor(k = 0; k < N; k++){\n\t\t\tif(i == k || A[k][j] == 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(l = j; l < N; l++){\n\t\t\t\tA[k][l] ^= A[i][l];\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}\n\nsigned main(){\n\tint N, R, i, j, k;\n\tscanf(\"%lld\", &N);\n\tint **C = (int **)malloc(sizeof(int *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tC[i] = (int *)malloc(sizeof(int) * N);\n\t\tfor(j = 0; j < N; j++){\n\t\t\tscanf(\"%lld\", &C[i][j]);\n\t\t}\n\t}\n\tR = rank(C, N);\n//\tprintf(\"R = %lld\\n\", R);\n\n\tint *pow2 = (int *)malloc(sizeof(int) * (N * N + 1));\n\tpow2[0] = 1;\n\tfor(i = 1; i <= N * N; i++){\n\t\tpow2[i] = MOD(pow2[i - 1] * 2);\n\t}\n\n\tint ***dp = (int ***)malloc(sizeof(int **) * (N + 1));\n\tfor(i = 0; i <= N; i++){\n\t\tdp[i] = (int **)malloc(sizeof(int *) * (N + 2));\n\t\tfor(j = 0; j <= N + 1; j++){\n\t\t\tdp[i][j] = (int *)malloc(sizeof(int) * (N + 2));\n\t\t\tfor(k = 0; k <= N + 1; k++){\n\t\t\t\tdp[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor(i = 0; i < N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tfor(k = 0; k <= N; k++){\n\t\t\t\tif(k > R || j < k){\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i + 1][j][k] = MOD(dp[i + 1][j][k] + pow2[j] * dp[i][j][k]);\n\t\t\t\t\tdp[i + 1][j + 1][k] = MOD(dp[i + 1][j + 1][k] + MOD(pow2[N] - pow2[R - k + j]) * dp[i][j][k]);\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] = MOD(dp[i + 1][j + 1][k + 1] + MOD(pow2[R - k + j] - pow2[j]) * dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i = 0; i <= N; i++){\n\t\tfor(j = 0; j <= N; j++){\n\t\t\tfor(k = 0; k <= N; k++){\n\t\t\t\tprintf(\"dp[%lld][%lld][%lld] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\tint ans = 0;\n\tfor(j = 0; j <= N; j++){\n\t\tans = MOD(ans + pow2[N * (N - j)] * dp[N][j][R]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dp[3005][3005], dq[3005][3005], howto[3005];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tull rank = 0;\n\twhile (true) {\n\t\tfor (i = rank; i < n; i++) {\n\t\t\tfor (j = rank; j < n; j++) {\n\t\t\t\tif (table[i][j]) break;\n\t\t\t}\n\t\t\tif (j < n) break;\n\t\t}\n\t\tif (i == n) break;\n\n\t\tif (i != rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\tsw(&table[i][ki], &table[rank][ki]);\n\t\t\t}\n\t\t}\n\t\tif (j != rank) {\n\t\t\tfor (ki = rank; ki < n; ki++) {\n\t\t\t\tsw(&table[ki][j], &table[ki][rank]);\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\tif (table[ki][rank]) {\n\t\t\t\tfor (li = rank; li < n; li++) {\n\t\t\t\t\ttable[ki][li] ^= table[rank][li];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (ki = rank + 1; ki < n; ki++) {\n\t\t\ttable[rank][ki] = 0;\n\t\t}\n\n\t\trank++;\n\t}\n\t// printf(\"rank: %llu\\n\", rank);\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= n * 3; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tinvf[i] = divide(invf[i - 1], i, MOD);\n\t}\n\n\tdq[rank][rank] = 1;\n\tfor (i = rank + 1; i <= n; i++) {\n\t\tfor (j = i; j <= n; j++) {\n\t\t\tfor (ki = i - 1; ki < j; ki++) {\n\t\t\t\tdq[i][j] += dq[i - 1][ki] * ncr(n - ki, j - ki, MOD);\n\t\t\t}\n\t\t\tdq[i][j] %= MOD;\n\t\t}\n\t}\n\n\n\tfor (i = rank; i <= n; i++) {\n\t\tdp[0][0] = 1;\n\t\tfor (ki = 1; ki <= n; ki++) {\n\t\t\tfor (li = 0; li <= n; li++) {\n\t\t\t\tdp[ki][li] = (\n\t\t\t\t\tdp[ki - 1][li] * bitpow(2, li, MOD)\n\t\t\t\t\t+ (ki ? dp[ki - 1][li - 1] * (MOD + bitpow(2, i, MOD) - bitpow(2, li - 1, MOD)) : 0)\n\t\t\t\t) % MOD;\n\t\t\t}\n\t\t}\n\n\n\t\thowto[i] = 0;\n\t\tfor (j = i; j <= n; j++) howto[i] += dq[i][j];\n\t\thowto[i] %= MOD;\n\t\thowto[i] = divide(howto[i], frac[i - rank], MOD) % MOD;\n\n\t\tmaybe = dp[n][i] * howto[i] % MOD;\n\t\tmaybe = maybe * bitpow(2, n * (n - i), MOD) % MOD;\n\t\tresult += maybe;\n\t\t// printf(\"%llu * %llu\\n\", dp[n][i], howto[i]);\n\t}\n\tresult %= MOD;\n\n\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 4;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \tscanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tscanf(\"%lld\", &table[i][j]);\n\t\t\t// table[i][j]--;\n\t\t}\n\t}\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN = int(readline())\nC = np.array([line.split() for line in readlines()],np.int8)\n\ndef rank(A):\n    if (A==0).all():\n        return 0\n    i = np.nonzero(A[:,0])[0]\n    if len(i) == 0:\n        return rank(A[:,1:])\n    i = i[0]\n    temp = A[i].copy()\n    A[i] = A[0]\n    A[0] = temp\n    A[1:] ^= A[1:,0][:,None] * A[0][None,:]\n    return 1 + rank(A[1:,1:])\n\nr = rank(C)\n\npow2 = np.ones(301,dtype=np.int64)\nfor n in range(1,301):\n    pow2[n] = pow2[n-1]*2%MOD\n\n# N次元空間から、M本のベクトルを選んで、D次元部分空間を生成する方法の個数\ndp = np.zeros((301,301,301),dtype=np.int64)\ndp[:,0,0] = 1\nfor M in range(1,301):\n    dp[:,M,:M] += dp[:,M-1,:M] * pow2[:M] % MOD\n    dp[:,M,1:M+1] += dp[:,M-1,0:M] * (pow2[:,None]-pow2[None,0:M]) % MOD\n    dp[:,M,:] %= MOD\n\n# C=ABのrankがrとなる方法の総数\nx = 0\nfor n in range(r,N+1):\n    x += dp[N,N,n] * dp[N,n,r] % MOD * pow(2,N*(N-n),MOD) % MOD\nx %= MOD\n\nanswer = x * pow(int(dp[N,N,r]),MOD-2,MOD) % MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN = int(readline())\nC = np.array([line.split() for line in readlines()],np.int8)\n\ndef rank(A):\n    if (A==0).all():\n        return 0\n    i = np.nonzero(A[:,0])[0]\n    if len(i) == 0:\n        return rank(A[:,1:])\n    i = i[0]\n    temp = A[i].copy()\n    A[i] = A[0]\n    A[0] = temp\n    A[1:] ^= A[1:,0][:,None] * A[0][None,:]\n    return 1 + rank(A[1:,1:])\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef power_mod(a,n,MOD):\n    if n == 0:\n        return 1\n    x = power_mod(a,n//2,MOD)\n    x *= x\n    x %= MOD\n    return (a*x)%MOD if n&1 else x\n\nr = rank(C)\n\nx = np.full(N*N+100,2,np.int64); x[0] = 1\npow2 = cumprod(x,MOD)\n\nG = np.zeros((N+1,N+1),np.int64)\nfor n in range(N+1):\n    G[n,1:] = pow2[n] - pow2[:N]\nG[:,0] = 1\nfor n in range(1,N+1):\n    G[:,n] *= G[:,n-1]; G[:,n] %= MOD\n\nGd = np.diagonal(G)\n\nD = G * power_mod(Gd,MOD-2,MOD)[None,:] % MOD\nF = np.zeros((N+1,N+1),np.int64)\nfor n in range(N+1):\n    F[n,:n+1] = Gd[:n+1] * D[n,n::-1] % MOD\n\nB = D[N] * F[N] % MOD\n\nC = D[N,r] * F[:,r] % MOD * pow2[N*N::-N] % MOD\n\nA = (B[r:N+1] * C[r:N+1] % MOD).sum() % MOD\n\nanswer = A * pow(int(B[r]),MOD-2,MOD) % MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from numpy import *\nP=10**9+7\nN=int(input())\nC=array([input().split() for _ in range(N)],int8)\nr=linalg.matrix_rank(C)\np=ones(N+1,int64)\nfor n in range(1,N+1):p[n]=p[n-1]*2%P\nd=zeros((N+1,N+1,N+1),int64);d[:,0,0]=1\nfor M in range(1,N+1):\n  d[:,M,:M]+=d[:,M-1,:M]*p[:M]%P\n  d[:,M,1:M+1]+=d[:,M-1,0:M]*(p[:,None]-p[None,0:M])%P\n  d[:,M,:]%=P\nprint(sum(d[N,N,n]*d[N,n,r]%P*pow(2,N*(N-n),P)%P for n in range(r,N+1))%P*pow(int(d[N,N,r]),P-2,P)%P)"
  },
  {
    "language": "Python",
    "code": "from numpy import *\nP=10**9+7\nN=int(input())\nC=array([input().split() for _ in range(N)],int8)\ndef r(A):\n  if(A==0).all():return 0\n  i=A[:,0].nonzero()[0]\n  if len(i) == 0:return r(A[:,1:])\n  t=A[i[0]].copy();A[i[0]]=A[0];A[0]=t\n  A[1:]^= A[1:,0][:,None]*A[0][None,:]\n  return 1+r(A[1:,1:])\nr=r(C)\np=ones(N+1,int64)\nfor n in range(1,N+1):p[n]=p[n-1]*2%P\nd=zeros((N+1,N+1,N+1),int64);d[:,0,0]=1\nfor M in range(1,N+1):\n  d[:,M,:M]+=d[:,M-1,:M]*p[:M]%P\n  d[:,M,1:M+1]+=d[:,M-1,0:M]*(p[:,None]-p[None,0:M])%P\n  d[:,M,:]%=P\nprint(sum(d[N,N,n]*d[N,n,r]%P*pow(2,N*(N-n),P)%P for n in range(r,N+1))%P*pow(int(d[N,N,r]),P-2,P)%P)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN = int(readline())\nC = np.array([line.split() for line in readlines()],np.int8)\n\ndef rank(A):\n    if (A==0).all():\n        return 0\n    i = np.nonzero(A[:,0])[0]\n    if len(i) == 0:\n        return rank(A[:,1:])\n    i = i[0]\n    temp = A[i].copy()\n    A[i] = A[0]\n    A[0] = temp\n    A[1:] ^= A[1:,0][:,None] * A[0][None,:]\n    return 1 + rank(A[1:,1:])\n\nr = rank(C)\n\npow2 = np.ones(301,dtype=np.int64)\nfor n in range(1,301):\n    pow2[n] = pow2[n-1]*2%MOD\n\n# N次元空間から、M本のベクトルを選んで、D次元部分空間を生成する方法の個数\ndp = np.zeros((301,301,301),dtype=np.int64)\ndp[:,0,0] = 1\nfor M in range(1,301):\n    dp[:,M,:M] += dp[:,M-1,:M] * pow2[:M] % MOD\n    dp[:,M,1:M+1] += dp[:,M-1,0:M] * (pow2[:,None]-pow2[None,0:M]) % MOD\n    dp[:,M,:] %= MOD\n\n# C=ABのrankがrとなる方法の総数\nx = 0\nfor n in range(r,N+1):\n    x += dp[N,N,n] * dp[N,n,r] % MOD * pow(2,N*(N-n),MOD) % MOD\n\nanswer = x * pow(int(dp[N,N,r]),MOD-2,MOD) % MOD\nprint(answer)\n\n"
  }
]