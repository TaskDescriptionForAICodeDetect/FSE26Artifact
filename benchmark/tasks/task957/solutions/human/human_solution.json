[
  {
    "language": "Fortran",
    "code": "program rotated_palindromes\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, i, j, d(1500) = 0, m = 0\n  integer(8) :: k, num(1500) = 0_8, ans = 0_8\n  read(*,*) n, k\n  i = 1\n  do while (i*i <= n)\n    if (mod(n,i) == 0) then\n      m = m+1\n      d(m) = i\n      if (i*i == n) exit\n      m = m+1\n      d(m) = n/i\n    end if\n    i = i+1\n  end do\n  call quick_sort(d(1:m))\n  do i = 1, m\n    num(i) = pow(k,(d(i)+1)/2)\n    do j = 1, i-1\n      if (mod(d(i),d(j)) == 0) num(i) = modulo(num(i)-num(j),md)\n    end do\n  end do\n  do i = 1, m\n    ans = mod(ans+num(i)*int(d(i)/(2-mod(d(i),2)),8),md)\n  end do\n  write(*,'(i0)') ans\ncontains\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: k\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    k = b\n    do while (k > 0)\n      if (btest(k,0)) r = mod(r*p,md)\n      p = mod(p*p,md)\n      k = rshift(k,1)\n    end do\n  end\n  recursive subroutine quick_sort(a)\n    integer, intent(inout) :: a(:)\n    integer :: n, l, r, m\n    integer :: p\n    n = size(a)\n    l = 1\n    r = n\n    m = (n+1)/2\n    p = a(l)+a(m)+a(r)-max(a(l),a(m),a(r))-min(a(l),a(m),a(r))\n    do\n      do while (a(l) < p)\n        l = l+1\n      end do\n      do while (a(r) > p)\n        r = r-1\n      end do\n      if (l >= r) exit\n      a(l) = xor(a(l),a(r))\n      a(r) = xor(a(l),a(r))\n      a(l) = xor(a(l),a(r))\n      l = l+1\n      r = r-1\n    end do\n    if (l-1 > 1) call quick_sort(a(1:l-1))\n    if (n > r+1) call quick_sort(a(r+1:n))\n  end\nend program rotated_palindromes"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\nlong long p[30];\nvoid init(long long k){\np[0]=k;\nf(i,29){\np[i+1]=p[i]*p[i];\np[i+1]=p[i+1]%MOD;\n}\nreturn;\n}\n\nlong long po(long long x){\nlong long re=1;\nf(i,30){\nif(x%2==1){\nre=re*p[i];\nre=re%MOD;\n}\nx=x/2;\n}\nreturn re;\n}\n\n\n\nint main(){\nvector<long long>a;\nvector<long long>b;\n\tlong long n,k;\n\tlong long x,s, ans;\n\n\tscanf(\"%lld %lld\", &n,&k);\ninit(k);\nx=1;\nwhile((x*x)<=n){\nif(n%x==0){\na.push_back(x);\na.push_back(n/x);\n}\nx++;\n}\nsort(a.begin(),a.end());\n\nf(i,a.size()){\nx=(a[i]+1)/2;\ns=po(x);\nf(j,i){\nif(a[i]%a[j]==0){\ns+=(MOD-b[j]);\ns=s%MOD;\n}\n}\nb.push_back(s);\n}\nans=0;\nf(i,a.size()){\nif(a[i]%2==0){\ns=b[i]*(a[i]/2);\ns=s%MOD;\nans+=s;\nans=ans%MOD;\n}\nelse{\ns=b[i]*a[i];\ns=s%MOD;\nans+=s;\nans=ans%MOD;\n}\n}\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2e3+10;\nint n,k,tot,ans,a[maxn],f[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nint power(int a,int b){\n    int ret=1;\n    for(;b;b>>=1,a=1ll*a*a%mod)\n        if(b&1)ret=1ll*ret*a%mod;\n    return ret;\n}\nint main(){\n    n=read();k=read();int num=sqrt(n);\n    for(int i=1;i*i<n;i++)\n        if(!(n%i))a[++tot]=i,a[++tot]=n/i;\n    if(num*num==n)a[++tot]=num;sort(a+1,a+tot+1);\n    for(int i=1;i<=tot;i++){\n        f[i]=power(k,(a[i]+1)>>1);\n        for(int j=1;j<i;j++)if(!(a[i]%a[j]))f[i]=(f[i]-f[j]+mod)%mod;\n        if(a[i]&1)ans=(ans+1ll*a[i]*f[i])%mod;\n        else ans=(ans+a[i]*1ll*power(2,mod-2)%mod*f[i])%mod;\n    }write(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 11116\n#define mod 1000000007\n\nint n,k;\nvector<int> q;\nlong long f[N],ans;\n\nlong long power(long long x,long long y){\n\tlong long t=1;\n\tfor (;y;x=x*x%mod,y/=2)\n\t\tif (y&1) t=t*x%mod;\n\treturn t;\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();k=read();\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tq.push_back(i);\n\t\t\tif (i*i!=n) q.push_back(n/i);\n\t\t}\n\tsort(q.begin(),q.end());\n\tfor (int i=0;i<(int)q.size();i++){\n\t\tf[i]=power(k,(q[i]+1)/2);\n\t\tfor (int j=0;j<i;j++)\n\t\t\tif (q[i]%q[j]==0)\n\t\t\tf[i]=(f[i]-f[j])%mod;\n\t\tif (q[i]%2)\n\t\tans=(ans+f[i]*q[i])%mod;\n\t\telse ans=(ans+f[i]*q[i]/2)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 3005, Mod = 1e9 + 7;\ntypedef long long ll;\n\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\nint inm(int x, int y) { return (ll)x*y%Mod; }\n\nint N, K, i, j, ans = 0, dp[Nmax];\nvector<int> v, v2;\n\nint power(int x, int y)\n{\n    int ans = 1;\n    while(y)\n    {\n        if(y&1) ans = inm(ans, x);\n        x = inm(x, x); y >>= 1;\n    }\n    return ans;\n}\n\nint main()\n{\n///    freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> N >> K;\n    for(i=1; i*i<=N; ++i)\n        if(N % i == 0)\n        {\n            v.push_back(i);\n            if(i*i < N) v2.push_back(N/i);\n        }\n\n    reverse(v2.begin(), v2.end());\n    for(auto it : v2) v.push_back(it);\n\n    for(i=0; i<v.size(); ++i)\n    {\n        dp[i] = power( K, (v[i]+1)/2 );\n\n        for(j=0; j<i; ++j)\n            if(v[i] % v[j] == 0)\n                add_to(dp[i], Mod - dp[j]);\n\n        add_to(ans, inm( dp[i], v[i] / (1<<(v[i]%2==0)) ) );\n    }\n\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int mo = 1e9 + 7;\nusing namespace std;\nint pow(int x, int t){\n\tint res = 1;\n\twhile (t > 0){\n\t\tif (t & 1) res = 1ll * res * x % mo;\n\t\tx = 1ll * x * x % mo;\n\t\tt >>= 1;\n\t}\n\treturn res;\n}\nint n, k, dp[10001]; vector <int> p;\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i * i <= n; i++){\n\t\tif (n % i == 0){\n\t\t\tp.push_back(i);\n\t\t\tif (i * i != n) p.push_back(n / i);\n\t\t}\n\t}\n\tsort(p.begin(), p.end()); int ans = 0;\n\tfor (int i = 0; i < p.size(); i++){\n\t\tdp[i] = pow(k, (p[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (p[i] % p[j] == 0) dp[i] = (dp[i] - dp[j] + mo) % mo;\n\t\tans = (ans + 1ll * dp[i] * (p[i] / (1 + (p[i] % 2 == 0))) % mo) % mo;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL M=1e9+7;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL m){\n\tLL x,y;\n\tgcdex(a,m,x,y);\n\tif(x<0){\n\t\tx+=m;\n\t} else if(x>=m){\n\t\tx-=m;\n\t}\n\treturn x;\n}\n// powmod p^n%mod\nLL powmod(LL p,LL n,LL mod){\n\tLL q=p%mod;\n\tLL pow=1;\n\twhile(n){\n\t\tif(n&1){\n\t\t\tpow*=q;\n\t\t\tpow%=mod;\n\t\t}\n\t\tq=q*q;\n\t\tq%=mod;\n\t\tn/=2;\n\t}\n\treturn pow;\n}\nvector<LL> ds;\nvector<LL> dp;\nint main() {\n\tLL N,K;\n\tcin >> N >> K;\n\tfor(LL i=1;i*i<=N;i++){\n\t\tif(N%i==0){\n\t\t\tds.push_back(i);\n\t\t\tif(i*i<N){\n\t\t\t\tds.push_back(N/i);\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(ds.begin(),ds.end());\n\tfor(int i=0;i<ds.size();i++){\n\t\tLL v=powmod(K,(ds[i]+1)/2,M);\n\t\t//cerr << v << endl;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(ds[i]%ds[j]==0){\n\t\t\t\tv+=M-dp[j];\n\t\t\t\tv%=M;\n\t\t\t}\n\t\t}\n\t\tdp.push_back(v);\n\t\t//cerr << ds[i] << \", \" << dp[i] << endl;\n\t}\n\n\tLL ret=0;\n\tLL r2=modinv(2,M);\n\tfor(int i=0;i<ds.size();i++){\n\t\tif(ds[i]%2==0){\n\t\t\tret+=ds[i]*r2%M*dp[i]%M;\n\t\t\tret%=M;\n\t\t}\n\t\telse{\n\t\t\tret+=ds[i]*dp[i]%M;\n\t\t\tret%=M;\n\t\t}\n\t}\n\tcout << ret << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(int n,int k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(tmp+v[j].second*v[i].first/v[j].first)%mod;\n\t\t\t}\n\t\t}\n\t\tll tmq=(x*Pmod((x+1)/2,k)-tmp+mod)%mod;\n\t\t//cout<<tmp<<\" \"<<tmq<<endl;\n\t\tv[i].second=tmq;\n\t\tans[x%2]+=tmq;\n\t\tans[x%2]%=mod;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n\nconst long long mod = 1e9 + 7;\n\nlong long n, k, dp[100005], ans;\nvector<long long> divisor;\n\nlong long BinPow(long long m, long long t){\n    if(t == 0)\n        return 1;\n    else if(t == 1)\n        return m % mod;\n    else{\n        long long sum = BinPow(m, t / 2);\n        sum *= sum; sum %= mod;\n        if(t % 2 == 1){\n            sum *= m;\n            sum %= mod;\n        }\n        return sum % mod;\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> k;\n    for(long long i = 1; i <= sqrt(n); i++){\n        if(n % i == 0){\n            divisor.pb(i);\n            if(i != n / i)\n                divisor.pb(n / i);\n        }\n    }\n    sort(divisor.begin(), divisor.end());\n    for(int i = 0; i < divisor.size(); i++){\n        dp[i] = BinPow(k, (divisor[i] + 1) / 2);\n        for(int j = 0; j < i; j++){\n            if(divisor[i] % divisor[j] == 0){\n            //cout << dp[i] << \" \" << dp[j] << \" \" << i << \" \" << j << \"\\n\";\n                dp[i] = dp[i] - dp[j];\n                dp[i] %= mod;\n            }\n        }\n        dp[i] = (dp[i] % mod + mod) % mod;\n        long long times = divisor[i];\n        if(times % 2 == 0)\n            times /= 2;\n        ans += (times * dp[i]) % mod;\n        ans %= mod;\n    }\n    cout << ans % mod << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tint ans = modpow(k, (n + 1) / 2)*n%mod;\n\t\tint mi = (n - 1)*k%mod;\n\t\tans += mod;\n\t\tans -= mi;\n\t\tans %= mod;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n数据不清空，爆零两行泪。\n多测不读完，爆零两行泪。\n边界不特判，爆零两行泪。\n贪心不证明，爆零两行泪。\nD P 顺序错，爆零两行泪。\n大小少等号，爆零两行泪。\n变量不统一，爆零两行泪。\n越界不判断，爆零两行泪。\n调试不注释，爆零两行泪。\n溢出不 l l，爆零两行泪。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back\nconst int mod=1000000007;\nint qpow(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1)(res*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint n,m;\nvector<int> d;\nvector<int> dp;\nsigned main(){\n\tcin>>n>>m;\n\tfor(int i=1;i*i<=n;i++)if(n%i==0)\n\t\td.pb(i),d.pb(n/i);\n\tsort(d.begin(),d.end());\n\td.resize(unique(d.begin(),d.end())-d.begin());\n\tint ans=0;\n\tfor(int i=0;i<d.size();i++){\n\t\tdp.pb(qpow(m,(d[i]+1)/2));\n\t\tfor(int j=0;j<i;j++)if(d[i]%d[j]==0)(((dp[i]-=dp[j])%=mod)+=mod)%=mod;\n\t\t(ans+=dp[i]*(d[i]&1?d[i]:d[i]/2))%=mod;\n//\t\tprintf(\"i=%lld ans=%lld\\n\",i,ans);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n/*1\n4 2\n*/\n/*2\n1 10\n*/\n/*3\n6 3\n*/\n/*4\n1000000000 1000000000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nconst ll mod = 1000000007;\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nstruct combination {\n  std::vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nstd::vector<ll> divisors( ll x )\n{\n  std::vector<ll> ret;\n\n  for( ll i = 1; i*i <= x; ++i ) if( x % i == 0 )\n  {\n    ret.emplace_back( i );\n\n    if( i != x/i )\n      ret.emplace_back( x/i );\n  }\n\n  return ret;\n}\n\nstd::map<ll, ll> prime_factor( ll x )\n{\n  std::map<ll, ll> ret;\n\n  for( ll i = 2; i*i <= x; ++i )\n  {\n    while( x%i == 0 )\n    {\n      ++ret[i];\n      x /= i;\n    }\n  }\n\n  if( x != 1 )\n    ++ret[x];\n\n  return ret;\n}\n\nll N, K;\nstd::map<ll, ll> mp;\nstd::vector<ll> ps;\nmint ans;\n\nint main()\n{\n  std::cin >> N >> K;\n\n  auto ds = divisors(N);\n\n  for( auto d : ds )\n  {\n    auto ds2 = divisors(d);\n    mint fd = 0;\n\n    for( auto d2 : ds2 )\n    {\n      auto mp = prime_factor(d2);\n      mint mu = 1;\n\n      itr( it, mp )\n      {\n        if( it->second > 1 )\n        {\n          mu = 0;\n\n          break;\n        }\n\n        mu *= -1;\n      }\n\n      fd += mint(K).pow((d/d2+1)/2)*mu;\n    }\n\n    ans += fd*(d%2 ? d : d/2);\n  }\n\n  std::cout << ans.x << std::endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=nn/i) v.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tif(nn%2==0) add(ans,1ll*d[i]*x%MOD);\n\t\telse{\n\t\t\tif(x==1){\n\t\t\t\tadd(ans,((1ll*m)+(1ll*m*(m-1)%MOD*n%MOD))%MOD);\n\t\t\t}else{\n\t\t\t\tadd(ans,1ll*d[i]*x%MOD*m%MOD*(nn/x)%MOD);\n\t\t\t\tadd(ans,1ll*d[i]*m%MOD);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t// printf(\"%lld = \", n); inc(i, pn) { printf(i == 0 ? \"%lld^%lld\" : \" * %lld^%lld\", p[i], e[i]); } printf(\"\\n\");\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\tLL test = 0;\n\twhile(true) {\n\t\ttest++;\n\t\tif(test > 1000000) { return 1; }\n\t\t\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tLL i = 0;\n\t\twhile(i < pn && count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i]++;\n\t}\n\t\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \nusing namespace std;\n\n#define ll long long\n#define P 1000000007 \n\nll n,k,dp[33335];\n\nvector<ll> fac;\n\nll fpow(ll a,ll b){\n\tll c=1;\n\tfor(;b;b>>=1,a=a*a%P)\n\t\tif(b&1) c=c*a%P;\n\treturn c;\n}\n\nvoid work()\n{\n\tll ans=0;\n\tfor(int x=0;x<fac.size();x++){\n\t\tdp[x]=fpow(k,(fac[x]+1)/2);\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif(fac[x]%fac[y]==0)\n\t\t\t\tdp[x]=(dp[x]-dp[y]+P)%P;\n\t\t}\n\t\tif(fac[x]%2) ans=(ans+dp[x]*fac[x]%P)%P; \n        else ans=(ans+dp[x]*fac[x]/2%P)%P;\n\t}\n    cout<<ans<<endl;  \n}\n\nvoid init()\n{\n\tfac.clear();\n\tfor(ll i=1;i*i<=n;i++){\n        if(n%i==0){\n            fac.push_back(i);\n            if(i*i!=n) fac.push_back(n/i);\n        }\n    }\n    sort(fac.begin(),fac.end());\n}\n\nint main()\n{\n\twhile(cin>>n>>k) init(),work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\n\nll f(ll n, ll k)\n{\n    return inq(k, n / 2) * (n % 2 ? k : 1) % MOD;\n}\n\nll ans = 0;\nll res[5050];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    vector<int> divs;\n    for (int i = 1; i * i <= n; i++)\n    {\n        if (n % i == 0)\n        {\n            divs.push_back(i);\n            if (i * i != n) divs.push_back(n / i);\n        }\n    }\n    if (n % 2 == 0)\n    {\n        return 1;\n    }\n    sort(all(divs));\n    for (int i = 0; i < divs.size(); i++)\n    {\n        res[i] = f(divs[i], k);\n        for (int j = 0; j < i; j++)\n        {\n            if (divs[i] % divs[j] == 0)\n            {\n                res[i] = (res[i] + MOD - res[j]) % MOD;\n            }\n        }\n        ans = (ans + res[i] * divs[i]) % MOD;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <map>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=100500,mo=1e9+7;\nint m,n;\nint fj[N][2],fj0;\nint d[N];\nLL ans;\nmap<int,int>f;\nLL ksm(LL q,int w)\n{\n\tLL ans=1;\n\tfor(;w;w>>=1,q=q*q%mo)if(w&1)ans=ans*q%mo;\n\treturn ans;\n}\nint ss1(int q,int w,int e)\n{\n\tif(q>w)return f[e];\n\tint ans=ss1(q+1,w,e);\n\tfo(i,1,d[q])((ans+=ss1(q+1,w,(e=e*fj[q][0])))>=mo?ans-=mo:0);\n\treturn ans;\n}\nint EB(int q)\n{\n\tfor(;q;q>>=1)if((q&1)&&q>1)return 1;\n\treturn 0;\n}\nvoid ss(int q,int e)\n{\n\tif(n==e)return;\n\tif(q>fj0)\n\t{\n\t\tLL t=(ksm(m,e/2+(e&1))-ss1(1,q,1)+mo)%mo;\n\t\t\n\t\tf[e]=t;\n\t\tint ANS=ans;\n\t\tif(n&1)ans=(ans-t*(n-e))%mo;\n\t\telse ans=(ans-t*((LL)(n>>1)-e))%mo;\n\t\t// printf(\"%d %lld\\n\",e,ANS-ans);\n\t\treturn;\n\t}\n\td[q]=0;ss(q+1,e);\n\tfo(i,1,fj[q][1])d[q]=i,ss(q+1,(e*=fj[q][0]));\n}\nint main()\n{\n\tint q,w;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==1)return printf(\"%d\\n\",m),0;\n\tq=n;\n\tfor(int i=2;i*i<=q;++i)if(q%i==0)\n\t{\n\t\tfor(fj[++fj0][0]=i;!(q%i);++fj[fj0][1],q/=i);\n\t}\n\tif(q>1)fj[++fj0][0]=q,fj[fj0][1]=1;\n\tif(!(n&1))ans=ksm(m,n/2)*(LL)n/2%mo;\n\telse ans=ksm(m,n/2+1)*(LL)n%mo;\n\tif(fj[1][0]==2)\n\t{\n\t\tq=2;\n\t\tfo(i,2,fj[1][1]-1)\n\t\t{\n\t\t\tq<<=1;\n\t\t\tans=(ans-ksm(m,n/q))%mo;\n\t\t}\n\t}\n\tss(1,1);\n\tprintf(\"%lld\\n\",(ans+mo)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tint ans = modpow(k, (n + 1) / 2)*n%mod;\n\t\tint mi = (n - 1)*k;\n\t\tans += mod;\n\t\tans -= mi;\n\t\tans %= mod;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD (1000000007)\n#define LL long long\nusing namespace std;\n\nLL n,k,ans;\nvector<LL>v,f;\n\nLL Qpow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n>>k;\n\tfor (int i=1; i<=sqrt(n); ++i)\n\t\tif (n%i==0)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tif (n/i!=i) v.push_back(n/i);\n\t\t}\n\tsort(v.begin(),v.end());\n\tf.resize(v.size());\n\tfor (int i=0,sz=v.size(); i<sz; ++i)\n\t{\n\t\tf[i]=Qpow(k,(v[i]+1)/2);\n\t\tfor (int j=0; j<i; ++j)\n\t\t\tif (v[i]%v[j]==0) (f[i]-=f[j])%=MOD;\n\t\tif (v[i]%2) (ans+=f[i]*v[i]%MOD)%=MOD;\n\t\telse (ans+=f[i]*v[i]/2%MOD)%=MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//ll sig(ll x){\n//    int ans = 1;\n//    for(ll i = 2; i*i <= x; ++i){\n//        if(x%(i*i)==0)\n//            return 0;\n//        if(x%i == 0){\n//            x /= i;\n//            ans *= -1;\n//        }\n//    }\n//    if(x > 1)\n//        ans *= -1;\n//    return ans;\n//}\n//ll f(ll n, ll k){\n//    return ipow(k,n/2+1)*n%MOD;\n//}\n//void __(){\n//    ll n,k;\n//    cin >> n >> k;\n//            //if(x != n)\n//    bool odd = true;\n//    if(n%2 == 0){\n//        n /= 2;\n//        odd = false;\n//    }\n//    vl divs;\n//    for(ll i = 1; i*i <= n; ++i){\n//        if(n%i == 0){\n//            divs.pb(i);\n//            if(i*i < n)\n//                divs.pb(n/i);\n//        }\n//    }\n//    sort(rall(divs));\n//    ll ans = 0;\n//    for(int x : divs){\n//        ll ways = 0;\n//        for(int y : divs){\n//            if(x%y == 0){\n//                if(!odd)\n//                    ways += sig(x/y)*ipow(k,y);\n//                else\n//                    ways += sig(x/y)*ipow(k,y/2+1);\n//            }\n//        }\n//        ways %= MOD;\n//        ans += ways*x%MOD;\n//    }\n//    ans = (ans%MOD+MOD)%MOD;\n//    print ans;\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nll ipow(ll x, ll p, ll mod = MOD){\n    if(abs(x) >= mod)\n        x %= mod;\n    if(x < 0)\n        x += mod;\n    if(p == 0)\n        return 1;\n    if(p == 1)\n        return x;\n    return ipow(x * x % mod, p / 2, mod) * ipow(x, p % 2, mod) % mod;\n}\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout) \n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\nll sig(ll x){\n    int ans = 1;\n    for(ll i = 2; i*i <= x; ++i){\n        if(x%(i*i)==0)\n            return 0;\n        if(x%i == 0){\n            x /= i;\n            ans *= -1;\n        }\n    }\n    if(x > 1)\n        ans *= -1;\n    return ans;\n}\nll f(ll n, ll k){\n    return ipow(k,n/2+1)*n%MOD;\n}\nvoid __(){\n    ll n,k;\n    cin >> n >> k;\n            //if(x != n)\n    bool odd = true;\n    if(n%2 == 0){\n        n /= 2;\n        odd = false;\n    }\n    vl divs;\n    for(ll i = 1; i*i <= n; ++i){\n        if(n%i == 0){\n            divs.pb(i);\n            if(i*i < n)\n                divs.pb(n/i);\n        }\n    }\n    sort(rall(divs));\n    ll ans = 0;\n    for(int x : divs){\n        ll ways = 0;\n        for(int y : divs){\n            if(x%y == 0){\n                if(!odd)\n                    ways += sig(x/y)*ipow(k,y);\n                else\n                    ways += sig(x/y)*ipow(k,y/2+1);\n            }\n        }\n        ways %= MOD;\n        ans += ways*x%MOD;\n    }\n    ans = (ans%MOD+MOD)%MOD;\n    print ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef double dob;\ntypedef pair<int,int> par;\nconst int P=1000000007,inv2=500000004;\nLL ans,n,k,a[233],p[233],cnt;\nLL pw(LL x,int k){\n\tLL y=1;\n\twhile (k){\n\t\tif (k&1) y=y*x%P;\n\t\tx=x*x%P;\n\t\tk>>=1;\n\t}\n\treturn y;\n}\n#define g(n) pw(k,(n+1)>>1)\nvoid dfs(LL dep,LL fn,LL gn,LL hn){\n\tif (dep>cnt){\n\t\tLL dlt=g(gn)*hn%P;\n\t\tif (fn%2==0) dlt=dlt*inv2%P;\n\t\tans=(ans+dlt*fn)%P;\n\t\treturn;\n\t}\n\tLL ff=fn;\n\trep(i,0,a[dep]){\n\t\tLL gg=gn;\n\t\trep(j,0,i){\n\t\t\tdfs(dep+1,ff,gg,hn*(i-j>1?0:i-j==1?-1:1));\n\t\t\tgg*=p[dep];\n\t\t}\n\t\tff*=p[dep];\n\t}\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n//\tif (n%2==1){\n//\t\tprintf(\"%lld\\n\",g(n)*n%P);\n//\t\treturn 0;\n//\t}\n\trep(i,2,1e6){\n\t\tif (n%i!=0) continue;\n\t\tp[++cnt]=i;\n\t\twhile (n%i==0){\n\t\t\t++a[cnt];\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif (n!=1) a[++cnt]=1,p[cnt]=n;\n\tdfs(1,1,1,1);\n\tans=(ans+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//This is getting accepted!\n// I HATE BUG\n// God Of The Bugs\n// 12/11/2016\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FI first\n#define SE second\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define sz(a) ((int)(a).size())\n#define __builtin_popcount __builtin_popcounll\n#define ld long double\n\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, pii> ppi;\n\nconst double PI = acos(0) * 2;\nconst double EPS = 1e-8;\nconst ll MOD = 1e9 + 7;\nconst int MAXN = 1e5 + 5;\nconst int oo = 1e9;\nconst double foo = 1e30;\n\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcounll(s);}\ntemplate<class T> T sqr(T x) { return x * x; }\n\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\n\nll pow_mod(ll a, ll b) {\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1) (res *= a) %= MOD;\n\t\ta = (a * a) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint n, k;\nvector<ll> q;\nll dp[2000];\n\nint main() {\n//#ifndef ONLINE_JUDGE\n//    freopen(\"inp.txt\", \"r\", stdin);\n////    freopen(\"out.txt\", \"w\", stdout);\n//#endif\n\n\tscanf(\"%d%d\", &n, &k);\n\t\n\tfor (int i=1; i<=(int) sqrt(n); i++) {\n\t\tif (n % i == 0) {\n\t\t\tq.pb(i);\n\t\t\tif (i * i != n) q.pb(n / i);\n\t\t}\n\t}\n\t\n\tsort(q.begin(), q.end());\n\tdp[0] = k;\n\t\n\tfor (int i=1; i<q.size(); i++) {\n\t\tdp[i] = pow_mod(k, (q[i] + 1) / 2);\n\t\tfor (int j=0; j<i; j++) {\n\t\t\tif (q[i] % q[j] == 0) {\n\t\t\t\tdp[i] = (dp[i] - dp[j] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll ans = 0;\n\tfor (int i=0; i<q.size(); i++) {\n//\t\tcout << q[i] << \" \" << dp[i] << endl;\n//\t\tcout << dp[i] << endl;\n\t\tif (q[i] % 2) {\n\t\t\t(ans += dp[i] * q[i]) %= MOD;\n\t\t}\n\t\telse {\n\t\t\t(ans += dp[i] * (q[i] / 2ll)) %= MOD;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll ruijo(ll x,ll n){\n\tlong long p,ans;\n\tif(n==0)return 1;\n\tif(n==1)return x;\n\tif(n%2){\n\t\tp = ruijo(x,n/2);\n\t\tans = (x*p)%mod;\n\t\tans = (ans*p)%mod;\n\t\treturn ans;\n\t}else{\n\t\tp = ruijo(x,n/2);\n\t\tans = (p*p)%mod;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n    ll n,k;\n    cin >> n >> k;\n    vector<ll> a;\n    for(ll i=1;i<=sqrt(n);i++){\n        if(n%i==0){\n            a.push_back(i);\n            if(i!=n/i){\n                a.push_back(n/i);\n            }\n        }\n    }\n    map<ll,ll> mp;\n    ll ans = 0;\n    sort(a.begin(),a.end());\n    rep(i,a.size()){\n        ll t = a[i];\n        ll sz = 0;\n        if(t%2==0){\n            sz = ruijo(k,t/2);\n        }else{\n            sz = ruijo(k,t/2+1);\n        }\n\n        if(t==1){\n            ans += sz;\n            ans %= mod;\n        }else{\n            for(ll j=1;j<=sqrt(t);j++){\n                if(t%j==0){\n                    sz += mod-mp[j];\n                    sz %= mod;\n                    if(j!=t/j){\n                        sz += mod-mp[t/j];\n                        sz %= mod;\n                    }\n                }\n            }\n            if(t%2==0){\n                ans += sz*t/2%mod;\n                ans %= mod;\n            }else{\n                ans += sz*t%mod;\n                ans %= mod;\n            }\n\n        }\n        mp[t] = sz;\n        //cerr << t << \" \" << mp[t] << \" \" << ans << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it = v.begin(); it != v.end(); it++)\n#define vrepr(v,it) for(auto it = v.rbegin(); it != v.rend(); it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,...) do { cerr << #v << \" = \"; array_out(v , __VA_ARGS__ );} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\n \nusing P = pair<ll,ll>; using vp = vector<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n/////////////////\n\n\nstruct divisor_transform{\n  template <typename T>\n  static constexpr void zeta_transform(vector<T> &a){\n    int N = a.size() - 1; \n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; p++)\n      if(sieve[p])\n        for(int k = 1; k * p <= N; ++k)\n          sieve[k * p] = false , a[k * p] += a[k];    \n  }\n\n  template<typename T>\n  static constexpr void mobius_transform(T &a){\n    int N = a.size() - 1; \n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; p++)\n      if(sieve[p])\n        for(int k = N / p; k > 0; --k)\n          sieve[k * p] = false , a[k * p] -= a[k];    \n  }\n  \n  // 下から確定させていく約数包除を用いた実装\n  template<typename T>\n  static constexpr void zeta_transform(map<long long, T> &a){\n    for(auto &x : a) for(auto &y : a){\n      if(x == y) break;\n      if(x.first % y.first == 0) x.second += y.second;\n    }\n  }\n  template<typename T>\n  static constexpr void mobius_transform(map<long long, T> &a){\n    for(auto &x : a) for(auto &y : a){\n      if(x == y) break;\n      if(x.first % y.first == 0) x.second -= y.second;\n    }\n  }\n\n};\n\n\n// verify\n// https://atcoder.jp/contests/agc038/submissions/7683063\n// https://www.codechef.com/viewsolution/26767783\nstruct multiple_transform{\n  template <typename T>\n  static constexpr void zeta_transform(vector<T> &a){\n    int N = a.size() - 1;\n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; ++p)\n      if(sieve[p])\n        for(int k = N / p; k > 0; --k)\n          sieve[k * p] = false , a[k] += a[k * p];\n  }\n  template <typename T>\n  static constexpr void mobius_transform(vector<T> &a){\n    int N = a.size() - 1;\n    vector<int> sieve(N + 1, true);\n    for(int p = 2; p <= N; ++p)\n      if(sieve[p])\n        for(int k = 1; k * p <= N; ++k)\n          sieve[k * p] = false , a[k] -= a[k * p];\n  }\n\n  // 上から確定させていく約数包除を用いた実装\n  template<typename T>\n  static constexpr void zeta_transform(map<long long, T> &a){\n    for(auto it=a.rbegin(); it!=a.rend(); it++)\n      for(auto it2=a.rbegin(); it2!=it; it2++)\n        if(it2->first % it->first == 0)\n          it->second += it2->second;\n  }\n  template<typename T>\n  static constexpr void mobius_transform(map<long long, T> &a){\n    for(auto it=a.rbegin(); it!=a.rend(); it++)\n      for(auto it2=a.rbegin(); it2!=it; it2++)\n        if(it2->first % it->first == 0)\n          it->second -= it2->second;\n  }\n\n};\n\ntemplate<typename T>\nstatic constexpr vector<T> mobius_function(int N){\n  vector<T> a(N + 1 , 0);\n  a[1] = 1;\n  divisor_transform::mobius_transform(a);\n  return a;\n}\n\ntemplate<int N>\nstruct constexpr_mobius_function{\n  int mobius[N + 1] , sieve[N + 1];\n  constexpr constexpr_mobius_function(): mobius() , sieve(){\n    for(int i=1; i<=N; i++) sieve[i] = 1, mobius[i] = 0;\n    mobius[1] = 1;\n    for(int p = 2; p <= N; p++)\n      if(sieve[p])\n        for(int k = N / p; k > 0; --k)\n          sieve[k * p] = false , mobius[k * p] -= mobius[k];    \n  }\n  const int& operator[](int i)const{return mobius[i];}\n};\n\n// verify\ntemplate<typename T,typename F>\nstatic constexpr unordered_map<long long,T> divisor_zeta_transform(long long N, F f){\n  // factorization\n  unordered_map<long long,long long> factors;\n  {\n    long long M = N;\n    for(long long i = 2; i * i <= M; i++)\n      while(M % i == 0) factors[i]++ , M /= i;\n    if(M != 1) factors[M]++;\n  }\n  unordered_map<long long,T> ret;\n  ret.emplace(1 , 1);\n  for(auto &d : factors){\n    auto ret2 = ret;\n    T prev = 1;\n    for(long long i = 1 , cur = d.first; \n      i <= d.second;\n      i++ , cur *= d.first){\n      T val = ( prev += f(cur) );\n      for(auto &x : ret) \n        ret2.emplace(x.first*cur , x.second*val);\n    }\n    swap(ret , ret2);\n  }\n  return ret;\n}\n\n// verify\n// https://onlinejudge.u-aizu.ac.jp/status/users/NyaanNyaan/submissions/1/NTL_1_D/judge/3892694/C++14\n// https://atcoder.jp/contests/abc020/submissions/7695313\ntemplate<typename T,typename F>\nstatic constexpr unordered_map<long long,T> divisor_mobius_transform(long long N, F f){\n  // factorization\n  unordered_map<long long,long long> factors;\n  {\n    long long M = N;\n    for(long long i = 2; i * i <= M; i++)\n      while(M % i == 0) factors[i]++ , M /= i;\n    if(M != 1) factors[M]++;\n  }\n  unordered_map<long long,T> ret;\n  ret.emplace(1 , 1);\n  for(auto &d : factors){\n    auto ret2 = ret;\n    for(long long i = 1,cur = d.first , prev = 1; \n      i <= d.second; \n      i++ , cur *= d.first , prev *= d.first){\n      T val = f(cur) - f(prev);\n      for(auto &x : ret) \n        ret2.emplace(x.first*cur , x.second*val);\n    }\n    swap(ret , ret2);\n  }\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\nvoid solve(){\n  int N,K; cin >> N >> K;\n  map<long long,modint> a;\n  {\n    for(long long i=1;i*i<=N;i++){\n      if(N % i == 0){\n        a.emplace(i , modint(K).pow((i+1)/2));\n        if(i * i != N){\n          long long ni = N / i;\n          a.emplace(ni , modint(K).pow((ni+1)/2));\n        }\n      }\n    }\n  }\n  divisor_transform::mobius_transform(a);\n  modint ans = 0;\n  each(d , a) ans += d.second * d.first / (2 - (d.first&1) );\n  cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint ans;\nint fastpow(int x,int a){\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\n\nint ys[50005],yscnt;\nint num[50005];\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tys[++yscnt]=i;\n\t\t\tif(i*i!=n) ys[++yscnt]=n/i;\n\t\t}\n\t}\n\tsort(ys+1,ys+yscnt+1);\n\tfor(int i=1;i<=yscnt;i++){\n\t\tnum[i]=(num[i]+fastpow(k,(ys[i]+1)/2) )%mod;\n\t\tfor(int j=i+1;j<=yscnt;j++) if(ys[j]%ys[i]==0) num[j]=(num[j]-num[i])%mod;\n\t}\n\tfor(int i=1;i<=yscnt;i++){\n\t\t//if(n%2==0&&ys[i]%2!=0) continue;\n\t\tans=(ans+num[i]*1LL*(ys[i]%2==0? ys[i]/2:ys[i]))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n\nll Pmod(int n,int k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n\nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(tmp+v[j].second*v[i].first/v[j].first)%mod;\n\t\t\t}\n\t\t}\n\t\tll tmq=(x*Pmod((x+1)/2,k)-tmp+mod)%mod;\n\t\t//cout<<tmp<<\" \"<<tmq<<endl;\n\t\tv[i].second=tmq;\n\t\tans[x%2]+=tmq;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\n\nint binPow (int x, int y) {\n    int ans = 1;\n    while (y) {\n        if (y & 1) ans = (ans * x) % mod;\n        x = (x * x) % mod;\n\n        y >>= 1;\n    }\n\n    return ans;\n}\n\nvoid input(){\n    scanf(\"%lld %lld\", &n, &k);\n}\n\nvoid solve(){\n    if (n == 1) {\n        printf(\"%lld\", k);\n        return;\n    }\n\n    if (n % 2 == 1) {\n        int ans = binPow(k, n / 2 + 1);\n        ans = ans + binPow(k, n / 2) * (n / 2) % mod * binPow(k, n / 2) % mod;\n        ans %= mod;\n        ans = (ans + mod) % mod;\n        printf(\"%lld\", ans);\n    }\n    else {\n        int ans = 0;\n        ans = ans + binPow(k, n / 2) * ((n - 2) / 2 + 1) % mod;\n        ans = ans - k * (n - 2) / 2; ans %= mod;\n        ans = (ans + mod) % mod;\n        printf(\"%lld\", ans);\n    }\n}\n\nsigned main(){\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7,N=1e5+99;\nint n,m,phi[N][2],cnt,d[N];\nll ans;\nmap<int,int>f;\nll qpow(ll a,int b)\n{\n\tll ret=1;\n\twhile(b){if(b%2)ret=ret*a%mod;a=a*a%mod;b/=2;}\n\treturn ret;\n}\nint calc(int p,int q,int e)\n{\n\tif(p>q)return f[e];\n\tint ans=calc(p+1,q,e);\n\tfor(int i=1;i<=d[p];i++)ans=(ans+calc(p+1,q,e*=phi[p][0]))%mod;\n\treturn ans;\n}\nvoid work(int p,int e)\n{\n\tif(p>cnt)\n\t{\n\t\tll tmp=(((n/e)%2?qpow(m,(e+1)/2):qpow(m,e))-calc(1,p,1)+mod)%mod;\n\t\tf[e]=tmp;\n\t\tans=(ans+tmp*e)%mod;\n\t\treturn;\n\t}\n\td[p]=0;\n\twork(p+1,e);\n\tfor(int i=1;i<=phi[p][1];i++)d[p]=i,work(p+1,(e*=phi[p][0]));\n}\nint main()\n{\n\tcin>>n>>m;\n\tif(n==1){cout<<m;return 0;}\n\tint q=n;\n\tfor(int i=2;i*i<=q;i++)\n\tif(q%i==0)\n\t{\n\t\tphi[++cnt][0]=i;\n\t\twhile(q%i==0)q/=i,phi[cnt][1]++;\n\t}\n\tif(q>1)phi[++cnt][0]=q,phi[cnt][1]=1;\n\twork(1,1);\n\tcout<<(ans+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int mod=1000000007;\nint qpow(int n,int m) {\n\tint ans=1;\n\tfor(;m;m>>=1,n=(ll)n*n%mod) if(m&1) ans=(ll)ans*n%mod;\n\treturn ans;\n}\nconst int maxn=2100;\nint n,m,A[maxn],f[maxn],cnt;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i*i<=n;i++) if(n%i==0) {\n\t\tA[++cnt]=i;\n\t\tif(i*i!=n) A[++cnt]=n/i;\n\t}\n\tsort(A+1,A+cnt+1);\n\tint ans=0;\n\trep(i,1,cnt) {\n\t\tf[i]=qpow(m,A[i]+1>>1);\n\t\trep(j,1,i-1) if(A[i]%A[j]==0) (f[i]+=mod-f[j])%=mod;\n\t\t(ans+=(ll)f[i]*((A[i]&1)?A[i]:A[i]/2)%mod)%=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint num[2000],fac[2000],cnt;\n\nint add(int x,int y)\n{return (x+y)%mod;}\nint sub(int x,int y)\n{return (x-y+mod)%mod;}\nint mul(int x,int y)\n{return 1LL*x*y%mod;}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=mul(x,ans);\n\t\ty>>=1,x=mul(x,x);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;++i)\n\t  if(n%i==0)\n\t    {\n\t    \tfac[++cnt]=i;\n\t    \tif(i*i<n)\n\t    \t  fac[++cnt]=n/i;\n\t    }\n\tsort(fac+1,fac+1+cnt);\n\tint ans=0;\n\tfor(int i=1;i<=cnt;++i)\n\t{\n\t\tnum[i]=fpow(k,(fac[i]+1)>>1);\n\t\tfor(int j=1;j<i;++j)\n\t\t  if(fac[i]%fac[j]==0)\n\t\t    num[i]=sub(num[i],num[j]);\n\t\tif(fac[i]%2==0)ans=add(ans,mul(num[i],fac[i]>>1));\n\t\telse ans=add(ans,mul(num[i],fac[i]));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*!|||||||!!!!!!!!!!!!!!!!!!|%%$&&&&&&&&&&&&&|'`......```':'':!;.  ......````':!;..\n||||||||||||!!!!!!!!!!!!!!!!!!!;;;;;!|%$$&&&|'..  ....``'''''::`  ......`````';:.\n||||||||||||||||||||||!!!!!!!!!!;;;;;;;;;;;'`..  ....``'''''':` ........````':'.\n|||||||||%%||%%|||||||||||||||||!;;;;;;;;'....   ....`````'''`..........````''.\n%%%%%%%%%%%%%%%%%%|%||||%%|%%%%|!;!;;;;:.       ....```````'::'`........`````.\n$$$$$$$%%$%%$$$$$%%%%%%%%%%%%%%|!!!!;'.        ....````````';|!!!!:`....```..\n$$$$$$%%%$%%$$$$$%%%%%%%%%%%%%%!;!!;`          ....```````':!!!!!!!!|||;'`.\n$$$%$%|%%||%%%%%%%%%%||%%%%%|%|!;!!:.         ....````````:!;;;!;;!!|%$$$$|:`\n%%%%%||||||||||||||||||||||||||!;!;'`.        ....```````';!!!!!!!!||;';%$&@@%:`.\n|||||||||!!|||||||||||||||||||!;!!:':'.       ..```''```';!!!!!!!||%$$%!` .'|&@@%:`. .\n||||||||!!!|||||||||||||||||||!;!;::;;:`     ..````'''`';;!!!!!!|%%$$$$&&%'   .;&#@!'....\n|||||||!!!!|||||||||||||||||||!;!;:;;;;;'.  ..```''''`:!!!!!;!!|%$$$$&&&&&@$:.   .;&#$:....\n|||!||||!!||||||||||||||||||||!;!::;;;;;;;`..```''':':;!!!!!!!!|%$$&&&&&&@&@#$:.   .`!@$:...\n|||!|||!!!|||||||||||||||||||!!;;:;;;;;;;!!;'`'''':':!;;;;;!!|||||%$&&&&@@@@@@@%`......:$$:...\n||!!||!!!!!||||||||||||||||||!!;;:;;;;;;;!!|!;'''``'':;!!;!!;!|$$$%|%&&&@@@@@@@#&;.......'%|`..\n||!!||!!!!!!|||||||||||||||!!!!;;:;;;;;;:''::::;;!;;;;':!!!!!!!!!%$&$|%&@@@@@@#@@&!`.......`|;..\n||!!|!!!!!!!||||||||||||||||||!;;:;;'````:!%%%%|;:;;:::::;|!!||!!!!|$&$%%&@@&@@##@&!'........;|'.\n|!!!|!!!!!!!|||||||||||||||!!!!;:'```';!!||!!!|!!;;;;:::::;%%||%%|||||%&$%%&@@@@@##&;`` ......'!:.\n|!!!!!!!!!!!!|||||||||||||!!!!!;::;;;;;:;!!!|||||!!;;;;;;;;!%$%|%$$%||||%$$%$&@@@@#@$:``      .`''.\n|!!!||!!!!!!!||||||||||||!!!!!!!;;;:::;;!!|||||||||!!;;;;;;;;|$%|%%$$$%|||%%$$&@&@@#@!.`'.     ...`.\n|!!!||!!!!!!!||||||||||||!!!!!!!;:;;;;;!!!!!|||||||||!!;;;;;;;|$$||%$$&&$%%%%%$&&&&@@@!.``.    ....`.\n|!!!||!!|!!||!|||||||||||!!!!!!!;;;;;;;!!||||||||||!!!;;;;;;;;;|$$||$$$&&&$%%%|%$&&&@@@; .`.    .. ...\n|!!!||!!||!!|!!|||||||||||!!!!!!!;;;;;!!||||||||!!!|||||!!;;;;;;|$$|!$$$&&&&$%%|%$&&&&@$' .`.   ..  ..\n|!!!||!!||!!||!|||||||||||!!!!!!!;;;;;!||||||!!!|||||||||!::'::::!$$!!%$$&&&&$$%!!%$$&&&!. .`.  ..\n|!!!|||!|||!!|!!|||||||||||!!!!!!!;;;!!||||!!|||||||||!;;!!!!!!;;;|$%!|$$$&&&&&$|`.;$$&&|`  .`...\n|!!!!||!||||!!|!!||||||||||!!!!!!!!!;!|||!||||||||!!!!||!:'`.`:;!!!%$%!|$$$&&&&&$;  '%$&$;   ``\n|!!!!||!!||||!!|!!|||||||%||!!!!!!!!!!||||||||||!!!|!:.      ....`';|||!|$$&&&&&@|`  '%&$%:   ..\n|!!!!|||||||||!|||!||||||%%|!!|!!!!!!!||||||||!!!;` ...      ...';||%$|;!%$$&&&&@$:   :$&$$|.  ..\n||!!!||||||||||!!||||||||%%||!!|!!!!!!|||||||!!'..```..``... `:;;;!|%$$|!|%$&&&&&&;   '|$%:!$: ...\n||!;!|||||||||||!!%|||||%%%%|||||!|!!|||||||!'..```.`'```..`!%!!%%%%|$$||!|$$&&&&&;   ';!%: `|%`..\n||!!!!!|||||%||||!!%%||%%%%%%|||||||!||||||;:`.``.`:;;`.':```:':|%%%%$$%|!;|&&&&&$:   ''`!;    :|:.\n|||!!!!!||||%%%|%%||%%|%%%$$%|||%|!||!||||!:`....';;!|%;.```''::!%%%|%$$$|';$&&&&%'  .`  ::       .`''`. .``.\n|||!!!!!||||%%%%%%%|||%%%$$$$%|%%%||%|!||!:```....`;|%$$|'':`'!;!%%%%%%$&@%!%&$$&!. .`.  ``.      .\n|||!!!|!!|%%%%%%%%%%%||%%%$$$%|%%%%||%|!|!!|||||||!;::|$$$%|%%%!!|%%%%%%$&&&$$$$%' .`    ..\n|||!!!||!!|%%%%%%%%%%%%||%%%$$%|%%$%|%%!!|||||||||||||||!!!||||%%%%%%%%%$$$$$$$$&%:.     ..\n||||!!|%|!;!%%%%%%%%%%%%%%|%%%$||%$%%|%|!!||||||||||||||%%%%%%%%$$$%%%%$$$$%%$$$&&&&&&$%'..\n!|||!!!|%|!;!%%%%%%%%%%%%%%%|%%%||%%%||%|!!!||||||||||||%%%%%%%%%%%%%%%$$$$%%$$$$$$$$$$%'\n;!||!!!|%%%|!;|%%%%%%%%%%%%%%%%|%||%%%!!||!!!|%%||||||%%%%%%%%%%%%%%%%$$$$%%%%%$$$$$$$$!`\n;;!||!!!|%%||!;!||%%%%%%%%%%%%%%%||%%%|!!|||!!!|%$%|||%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$$$$;.\n;;;||!!!!|%%||!;;!|%%%%%%%|||||%%|||||||!!||||||||%$%|%%%%%%%%%%%%%%%%$%%%%%$$$$$$$$$$%'\n!!;!|!;;!!|%%|||!;!||%%%||||||||||||||||!!|%||||||||%%||%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$!`\n!!;;!!;;!!!||||||!;;!|||||||||||||||!||||!;;|%%%%%%%|%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$%'\n!!!;;!!;;!!!||||||!!;;!||||||||||||||!||||!!!!%$%|%%%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$%'\n!!!!;;!!;;;!!!|||||!!::;|||||!|||||||!!|||||!!!|$$%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&&$:\n;;!!!!;!;;;;!!!|||||!!;::;!|!!!!||||||!!|||%%|!!!%&%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$&$!`\n|!!!!;!;;;;::;!!!||!||!;;;;;!!!!!!|||||!!|||%%|||!|$&$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$%!`\n:::;!;;;;::;::;;!!|||!!!!;;;;;!!!!!!||||!!|||%$%%||||$&$%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$%'\n;;;;;!!!!!;:::;;:;!!||!!!!!;;;;;!!!!!!||||!!||%$%%%%%%%%$$%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$:\n;;;;;;;;;!!!;::;;;:;!!|||||!!!!;;;;!!!!!|||||||%$$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$!.\n;;;;;;;;:::::::::;;;;;;!||!!!!!!!!;;;!!!!!||||||||$$%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&!.\n;;;;;;;::;;:::;;;;:;;;;;;;;!!!|!!!!!!;;;!!!!!|%%||||%$%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$&%`\n;;;;;;;:::;;::;;;;;;;;;;;;::;!!!!!!!!|!;!!!!!!!|%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&:\n;;;;;;;::;::;:;;;;;;;;;!!!!!!!;;!!|||||!!!|!!!!!!!|%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&|`\n;;;;;;;::;;;::;;;;;;;;;;!!!!!!!!!||||||||;!!|||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&!.\n;;;;;;;::;;;;::;;;;;;;;;;!!!!!!!!|||||||||;;;!!|||||||||%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$&|`\n!;;;;;;;::;;;:;;;;;;;;;;;!!!!!!!!!|||||||%!;;;;;!||||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$!.\n;!;;;;;;::;;;:;;;;::;;;;;!!!!!!!!!|||||||%%!;;;;;;!!!|||||||%%%%%%%%%%%%%%%%%%$$$$$$$$$$&|`\n:;!!;;;;:::;;;:;;;:::;;;;;!!!!!!!!||||||||$|;;;;;;;;!!!!||||||||%%%%%%%%%%%%%%%%%%%$$$|'\n::;!!;;;::::;;:;;;;::;;;;;;!!!!!!!!|||||||$$!;;;;;;;;;;;!!!!!||||||%%%%%%%%%%%%|!:`.\n:::;!!;;;:::;;;;;;;:::;;;;;!!!!!!!!||%||||%&%!;;;;;;;;;;;;!!!!!!!!!!!|!;:`.\n::::;!!!;::::;::;;;::::;;;;;!!!!!!!!|%%|||!%&%;;;;;;;;;;;;;;;;;;;;;%|`\n:::::;!!!;:::::::;;:::::;;;;!!!!!!!!||%%%%!;%$|;;;;;;;;;;;;;;;;;;%@@$:\n::::::;!!!:::::':;;::::::;;;;;!!|!!!||%$%%|!;%$!;;;;;;;;;;;;;;;;|$&@@|`\n:::::':;;!;::::'';;;::::::;;;;!!!|!!!||%$%%|;;%%;;;;;;;;;;;;;;!||%$&#@|`\n::::::':;;;:::''':;;:::::::;;;!!!||!!!|%$$%%|;;||;;;;;;;;;;;!||||%%%&#@%'\n:::::::':;;;::'. ';;::::::::;;;!!!|!!!||%$$$%;;;||;;;;;;;;;|%%|||||%%&@@*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nmap<int,int> vals;\nvector<int> ins;\nconst int jt=1000000007;\n\nint ksmii(int a,int b){\n\tif(!b){\n\t\treturn 1;\n\t}\n\tint x=ksmii(a,b>>1);\n\tx=1ll*x*x%jt;\n\tif(b&1){\n\t\tx=1ll*x*a%jt;\n\t}\n\treturn x;\n}\n\nint dfs(int now){\n\tif(vals.count(now)){\n\t\treturn vals[now];\n\t}\n\tint &val=vals[now];\n\tval=ksmii(k,(now+1)/2);\n\tfor(int i=0;i<ins.size();i++){\n\t\tif(now%ins[i]==0&&ins[i]!=1){\n\t\t\tval=(val-dfs(now/ins[i])+jt)%jt;\n\t\t}\n\t}\n\treturn val;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tins.push_back(i);\n\t\t\tif(i*i!=n){\n\t\t\t\tins.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(n);\n\tint ans=0;\n\tfor(map<int,int>::iterator it=vals.begin();it!=vals.end();it++){\n\t\tint ff=it->first;\n\t\tif(ff%2){\n\t\t\tans=(ans+1ll*ff*it->second)%jt;\n\t\t}else{\n\t\t\tans=(ans+1ll*ff/2*it->second)%jt;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 1005;\nint fac[MAXN],n,f[MAXN],m;\ninline int ksm(int x,int k)\n{\n  int ret=1;\n  while(k){\n    if(k&1)ret=(long long)ret*x%MOD;\n    x=(long long)x*x%MOD;\n    k>>=1;\n  }\n  return ret;\n}\ninline void sub(int &x,int a)\n{\n  x-=a;\n  if(x<0)x+=MOD;\n}\ninline void add(int &x,int a)\n{\n  x+=a;\n  if(x>=MOD)x-=MOD;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i*i<=n;++i){\n    if(n%i==0){\n      fac[++fac[0]]=i;\n      if(i*i!=n)fac[++fac[0]]=n/i;\n    }\n  }\n  int ans=0;\n  sort(fac+1,fac+fac[0]+1);\n  for(int i=1;i<=fac[0];++i){\n    f[i]=ksm(m,(fac[i]+1)>>1);\n    for(int j=1;j<i;++j)\n      if(fac[i]%fac[j]==0)sub(f[i],f[j]);\n    if(fac[i]&1){\n      add(ans,(long long)f[i]*fac[i]%MOD);      \n    }else{\n      add(ans,(long long)f[i]*fac[i]%MOD*500000004%MOD);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,tot,ans;\nmap<int,int>mp;\nint f[108],dor[108];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;1ll*i*i<=n;i++)\n\tif (n%i==0)\n\t    {\n\t        dor[++tot]=i;\n\t\tif (n/i!=i) dor[++tot]=n/i;\n\t    }\n    sort(dor+1,dor+tot+1);\n    for (int i=1;i<=tot;i++) mp[dor[i]]=i;\n    for (int i=1;i<=tot;i++)\n\t{\n\t    f[i]=power(k,(dor[i]+1)/2);\n\t    for (int j=1;j<i;j++)\n\t\tif (dor[i]%dor[j]==0)\n\t\t    f[i]=(f[i]-f[j])%mod;\n\t}\n    //for (int i=1;i<=tot;i++) printf(\"%d %d\\n\",dor[i],f[i]);\n    for (int i=1;i<=tot;i++)\n    \tif ((n/dor[i])&1) ans=(ans+f[i])%mod;\n    \telse ans=((ans+f[i])%mod+f[mp[dor[i]*2]])%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n    \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=100100,P=1000000007;\nint i,j,k,n,m,nm,ans;\nint a[N],f[N];\nint ksm(int x,int y) {\n\tint z=1;\n\tfor (;y;y>>=1,x=(ll) x*x%P) if (y&1) z=(ll) z*x%P;\n\treturn z;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i*i<=n;i++) if (n%i==0) {\n\t\ta[++nm]=i;\n\t\tif (i*i<n) a[++nm]=n/i;\n\t}\n\tsort(a+1,a+nm+1);\n\tfor (i=1;i<=nm;i++) {\n\t\tf[i]=ksm(m,(a[i]+1)/2);\n\t\tfor (j=1;j<i;j++) if (a[i]%a[j]==0) f[i]=(f[i]+P-f[j])%P;\n\t}\n\tfor (i=1;i<=nm;i++) {\n\t\tif (a[i]&1) ans=((ll) f[i]*a[i]+ans)%P;\n\t\telse ans=((ll) f[i]*a[i]/2+ans)%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define re register\n#define int __int128\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int N = 10000 + 5 ; \nint T, n, m, P, st[N], top, w[N], num, c[N] ; \nint mul( int a, int b, int p ) {\n\treturn ( a % p ) * ( b % p ) % p ;  \n}\nint fpow( int x, int k, int p ) {\n\tint ans = 1, base = x % p ; \n\twhile( k ) {\n\t\tif( k & 1 ) ans = mul( ans, base, p ) ;\n\t\tbase = mul( base, base, p ), k >>= 1 ; \n\t} return ans % p ; \n}\nbool M_R( int p ) {\n\tif( p == 2 || p == 3 ) return 1 ; \n\tif( p == 1 || ( p % 2 == 0 ) ) return 0 ; \n\tre int d = p - 1, s = 0 ; while( !( d & 1 ) ) ++ s, d >>= 1 ; \n\trep( i, 0, 5 ) {\n\t\tre int a = rand() % ( p - 3 ) + 2 ; \n\t\tre int x = fpow( a, d, p ), y = 0 ;\n\t\tfor( register int j = 0; j < s; ++ j ) {\n\t\t\ty = mul( x, x, p ) ; if( y == 1 && ( x != 1 ) && x != ( p - 1 ) ) return 0 ;\n\t\t\tx = y ;\n\t\t} if( y != 1 ) return 0 ;\n\t} return 1 ; \n}\nint gcd( int x, int y ) {\n\treturn ( x == 0 ) ? y : gcd( y % x, x ) ;\n}\nint Rand( int x ) {\n\treturn 1ll * ((rand() << 15 ^ rand()) << 30 ^ (rand() << 15 ^ rand())) % x ; //2\n}\nint work( int p ) {\n\tre int k = 2, x = Rand(p - 1) + 1, y = x, d = 1, c = Rand(p) % 999997 ;\n\tfor( re int i = 1; d == 1; ++ i ) {\n\t\tx = ( mul( x, x, p ) + c ) % p ;\n\t\td = gcd( (x > y) ? x - y : y - x, p ) ;\n\t\tif( i == k ) y = x, k <<= 1 ; \n\t} return d ; \n}\nvoid Pollard_Rho(int p) {\n\tif( p == 1 ) return ; \n\tif( M_R(p) ) { st[++ top] = p; return ; }\n\tint x = p ; while( x == p ) x = work(x) ;\n\tPollard_Rho(x), Pollard_Rho(p / x) ;\n}\nint Ans = 0 ;\nvoid dfs( int x, int f, int d, int p ) {\n\tif( x == num + 1 ) {\n\t\tif( ( (d & 1) ) && ( !( (n / d) & 1 ) ) ) return ;\n\t\tint g = ( d & 1 ) ? d : d / 2 ;\n\t\tAns = ( Ans + mul( mul( fpow( m, ( d + 1 ) / 2, p ), g, p ), (f + p) % p, p ) + p ) % p ;\n\t\treturn ; \n\t}\n\tint fd = 1 ; \n\trep( i, 0, c[x] ) {\n\t\tif( i == c[x] ) dfs( x + 1, f, d * fd, p ) ;\n\t\telse dfs( x + 1, f * ( 1 - w[x] ), d * fd, p ) ;\n\t\tfd = fd * w[x] ; \n\t}\n}\nsigned main()\n{\n\tsrand(time(NULL)) ; \n\tn = gi(), m = gi(), P = 1000000007, top = 0, num = 0, Ans = 0 ;\n\tmemset( c, 0, sizeof(c) ), memset( w, 0, sizeof(w) ), memset( st, 0, sizeof(st) ) ;\n\tPollard_Rho(n) ; \n\tsort( st + 1, st + top + 1 ) ;\n\trep( i, 1, top ) {\n\t\tif( st[i] == st[i - 1] ) ++ c[num] ; \n\t\telse w[++ num] = st[i], c[num] = 1 ; \n\t}\n\tdfs( 1, 1, 1, P ) ;\n\tprintf(\"%lld\\n\", (long long)((Ans) % P) ) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,tot,ans;\nmap<int,int>mp;\nint f[100008],dor[100008];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;1ll*i*i<=n;i++)\n\tif (n%i==0)\n\t    {\n\t        dor[++tot]=i;\n\t\tif (n/i!=i) dor[++tot]=n/i;\n\t    }\n    sort(dor+1,dor+tot+1);\n    for (int i=1;i<=tot;i++) mp[dor[i]]=i;\n    ans=f[1]=k;\n    for (int i=2;i<=tot;i++)\n\t{\n\t    if ((n/dor[i])&1) f[i]=(power(k,(dor[i]+1)/2)-f[1])%mod;\n\t    else f[i]=(power(k,dor[i])-f[1])%mod;\n\t    for (int j=2;1ll*j*j<=dor[i];j++)\n\t\tif (dor[i]%j==0)\n\t\t    {\n\t\t\tf[i]=(f[i]-f[mp[j]])%mod;\n\t\t\tif (dor[i]/j!=j) f[i]=(f[i]-f[mp[dor[i]/j]])%mod;\n\t\t    }\n\t    ans=(ans+1ll*f[i]*dor[i]%mod)%mod;\n\t}\n    ans=(ans+mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n    \n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\nLL N,K;\nconst LL MOD = 1000000007ll;\n\nLL m_pow(LL a,LL x)\n{\n    if(x == 0)return 1;\n    LL half = m_pow(a,x/2);\n    half *= half;\n    half %= MOD;\n    return (half * (x % 2 ? a : 1))%MOD;\n}\n\nmap<LL,LL>memo;\nLL dp(LL d)\n{\n    if(memo.count(d))return memo[d];\n    LL res = m_pow(K,(d+1)/2);\n    vector<int>div;\n    for(int i = 1;i * i <= d;++i)\n    {\n        if(d % i == 0)\n        {\n            div.push_back(i);\n            if(d/i != i)div.push_back(d/i);\n        }\n    }\n    for(int dash : div)\n    {\n        if(dash == d)continue;\n        res -= dp(dash);\n        res += MOD;\n        res %= MOD;\n    }\n    return memo[d] = res;\n}\n\nint main()\n{\n    cin >> N >> K;\n    dp(N);\n    LL ans = 0;\n    for(auto p : memo)\n    {\n        LL index = p.first;\n        LL value = p.second;\n        if(index % 2 == 0)\n        {\n            value *= index / 2;\n        }\n        else\n        {\n            value *= index;\n        }\n        /*\n        cerr << index << endl;\n        cerr << value << endl;\n        //*/\n        value %= MOD;\n        ans += value;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long LL;\nconst int N=200005,p=1000000007;\nint f[N],d[N],d2[N],i,j,k,n,m,K,g,an;\nchar c;\n\ninline char getc()\n{\n\t#define VV 10000000\n\tstatic char s[VV],*l=s,*r=s;\n\tif (l==r)\n\t\tl=s,r=s+fread(s,1,VV,stdin);\n\treturn l==r?0:*l++;\n}\n\nint read(){ int z=0; do c=getc(); while (c<'0'||c>'9'); while (c>='0'&&c<='9') z*=10,z+=c-'0',c=getc(); return z; }\n\nvoid minus(int &a,int b){ a-=b,a+=a<0?p:0; }\n\nint power(int z,int k)\n{\n\tint d=1;\n\tfor (;k;z=(LL)z*z%p,k>>=1) if (k&1) d=(LL)d*z%p;\n\treturn d;\n}\n\nint main()\n{\n\tn=read(),K=read();\n\tfor (i=1;i*i<n;++i)\n\t\tif (!(n%i))\n\t\t\td[++g]=i,d2[++d2[0]]=n/i;\n\tif (i*i==n) d[++g]=i;\n\tfor (i=d2[0];i;--i) d[++g]=d2[i];\n\tfor (i=1;i<=g;++i)\n\t{\n\t\tf[i]=power(K,d[i]+1>>1);\n\t\tfor (j=1;j<i;++j)\n\t\t\tif (!(d[i]%d[j]))\n\t\t\t\tminus(f[i],f[j]);\n\t\tan=(an+(d[i]&1?(LL)f[i]*d[i]:(LL)f[i]*d[i]>>1))%p;\n\t}\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<55;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nint n,k;\nvi a;\n\nint main(){\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++) if(n%i==0){\n\t\ta.push_back(i);\n\t\tif(n/i!=i) a.push_back(n/i);\n\t}\n\tsort(a.begin(),a.end());\n\tint N=a.size();\n\tvl b(N);\n\tll res=0;\n\tfor(int i=0;i<N;i++){\n\t\tll d=a[i],tmp=Pow(k,(d+1)/2);\n\t\tfor(int j=0;j<i;j++) if(d%a[j]==0) tmp=(tmp-b[j]+mod)%mod;\n\t\tb[i]=tmp;\n\t\t(res+=b[i]*(d%2==0?d/2:d))%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\t// mu.insert(std::make_pair(prod, m));\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\treturn 0;\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <map>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=100500,mo=1e9+7;\nint m,n;\nint fj[N][2],fj0;\nint d[N];\nLL ans;\nmap<int,int>f;\nLL ksm(LL q,int w)\n{\n\tLL ans=1;\n\tfor(;w;w>>=1,q=q*q%mo)if(w&1)ans=ans*q%mo;\n\treturn ans;\n}\nint ss1(int q,int w,int e)\n{\n\tif(q>w)return f[e];\n\tint ans=ss1(q+1,w,e);\n\tfo(i,1,d[q])((ans+=ss1(q+1,w,(e=e*fj[q][0])))>=mo?ans-=mo:0);\n\treturn ans;\n}\nint EB(int q)\n{\n\tfor(;q;q>>=1)if((q&1)&&q>1)return 1;\n\treturn 0;\n}\nvoid ss(int q,int e)\n{\n\tif(q>fj0)\n\t{\n\t\tLL t=(((n/e)%2?ksm(m,(e+1)>>1):ksm(m,e))-ss1(1,q,1)+mo)%mo;\n\t\tf[e]=t;\n\t\tans=(ans+t*e)%mo;\n\t\treturn;\n\t}\n\td[q]=0;ss(q+1,e);\n\tfo(i,1,fj[q][1])d[q]=i,ss(q+1,(e*=fj[q][0]));\n}\nint main()\n{\n\tint q,w;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==1)return printf(\"%d\\n\",m),0;\n\tq=n;\n\tfor(int i=2;i*i<=q;++i)if(q%i==0)\n\t{\n\t\tfor(fj[++fj0][0]=i;!(q%i);++fj[fj0][1],q/=i);\n\t}\n\tif(q>1)fj[++fj0][0]=q,fj[fj0][1]=1;\n\tss(1,1);\n\tprintf(\"%lld\\n\",(ans+mo)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int P = 1e9 + 7;\nint Pow(int a,int t){\n    int r=1;for(;t;t>>=1,a=1ll*a*a%P)if(t&1)r=1ll*r*a%P;\n    return r;\n}\nvoid pp(int &a,int b){\n    a += b;\n    if(a >= P) a -= P;\n}\nint n , K;\n\nint main(){\n    cin >> n >> K;\n    int ans = 0;\n    if(n&1){\n        ans = 1ll * Pow(K , n/2+1) * n % P;\n        pp(ans , P - 1ll * K * (n - 1) % P);\n    } else {\n        int x = n / 2;\n        set<int> S;\n        map<int,int> Mp;\n        for(int i=1;i*i<=n;++i) if(n % i == 0) S.insert(i) , S.insert(n / i);\n        for(auto e : S){\n            int t = 0;\n            if(x % e == 0) t = Pow(K , e);\n            else t = Pow(K , (e + 1) / 2);\n            for(auto f : Mp) if(e % f.fi == 0) pp(t , P - f.se);\n            pp(ans , 1ll * t * e % P);\n            Mp[e] = t;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nvector<int> divi;\nint dp[2005];\nint pow(int a,int b,int mod){\n\tif(b==1){\n\t\treturn a;\n\t}\n\tint k=pow(a,b/2,mod)%mod;\n\tif(b%2==0){\n\t\treturn (k*k)%mod;\n\t}\n\treturn ((k*k)%mod*a)%mod;\n}\nsigned main(){\n\tint n,k,ans=0;\n\tcin>>n>>k;\n\tfor(int i=1;i<=sqrt(n);i++){\n\t\tif(n%i==0){\n\t\t\tdivi.push_back(i);\n\t\t\tdivi.push_back(n/i);\n\t\t\tif(i*i==n){\n\t\t\t\tdivi.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\tsort(divi.begin(),divi.end());\n\tfor(int i=0;i<divi.size();i++){\n\t\tdp[i]=pow(k,(divi[i]+1)/2,mod);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(divi[i]%divi[j]==0){\n\t\t\t\tdp[i]=(dp[i]-dp[j]+mod)%mod;\n\t\t\t}\n\t\t}\n\t\tif(divi[i]%2==0){\n\t\t\tans+=1LL*dp[i]*divi[i]/2;\n\t\t\tans%=mod;\n\t\t}\n\t\telse{\n\t\t\tans+=1LL*dp[i]*divi[i];\n\t\t\tans%=mod;\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, k;\nmap<int, ll> f;\n\nll add(ll x, ll y) {\n\treturn (x + y + mod) % mod;\n}\n\nvoid Add(ll &x, ll y) {\n\tx = (x + y + mod) % mod;\n}\n\nll mul(ll x, ll y) {\n\treturn (x * y) % mod;\n}\n\nvoid Mul(ll &x, ll y) {\n\tx = (x * y) % mod;\n}\n\nll q_pow(ll x, int y) {\n\tll ans = 1;\n\tfor(; y; y >>= 1) {\n\t\tif(y & 1) Mul(ans, x);\n\t\tMul(x, x);\n\t}\n\treturn ans;\n}\n\nll get(int x) {\n\tif(!f.count(x)) {\n\t\tint len = sqrt(x);\n\t\tll pos = q_pow(k, (x / 2) + (x & 1));\n\t\tfor(int i = 2; i <= len; ++i) {\n\t\t\tif(x % i) continue;\n\t\t\tAdd(pos, -get(i));\n\t\t\tif(i * i != x) Add(pos, -get(x / i));\n\t\t}\n\t\tif(x != 1) Add(pos, -k);\n\t\treturn f[x] = pos;\n\t} else return f[x];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tint len = sqrt(n);\n\tll ans = 0;\n\tfor(int i = 1; i <= len; ++i) {\n\t\tif(n % i) continue;\n\t\tif(i & 1) Add(ans, mul(i, get(i)));\n\t\telse Add(ans, mul(i / 2, get(i)));\n\t\tif(i * i != n) {\n\t\t\tint now = n / i;\n\t\t\tif(now & 1) Add(ans, mul(now, get(now)));\n\t\t\telse Add(ans, mul(now / 2, get(now)));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", (ans + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define max(a,b) ((a)>(b)?(a):(b))\n#define reg register\ntypedef long long ll;\nint n,k,cnt,fac[2005];\nll f[2005];\nconst int mod=1e9+7;\ninline ll qpow(ll a,ll b){\n\treg ll res=1;\n\twhile(b){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(reg int i=1;i<=sqrt(n);i++)\n\t\tif(!(n%i)){\n\t\t\tfac[++cnt]=i;\n\t\t\tif(i!=(n/i))fac[++cnt]=n/i;\n\t\t}\n\tstd::sort(fac+1,fac+1+cnt);ll ans=0;\n\tfor(reg int i=1;i<=cnt;i++){\n\t\tf[i]=qpow(k,(fac[i]+1)/2);\n\t\tfor(reg int j=1;j<i;j++)\n\t\t\tif(!(fac[i]%fac[j]))\n\t\t\t\tf[i]=(f[i]-f[j]+mod)%mod;\n\t\tif(fac[i]&1)ans=(ans+f[i]*fac[i]%mod)%mod;\n\t\telse ans=(ans+(f[i]>>1)*fac[i]%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-20\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x) ;\n#else\n#define DEBUG\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl;\n#endif\n\n//---------------------------head----------------------------\n\nconst LL mod=1e9+7;\n\nLL n,k;\nvl d,f;\n\ninline LL kiss_me(LL x,LL n)\n{\n    LL ret=1ll;\n    while(n)\n    {\n        if(n&1) (ret*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return ret;\n}\n\norz yjz()\n{\n    scf(n,k);\n\n    for(LL i=1;i*i<=n;i++) if(n%i==0)\n    {\n        d.pb(i);\n        if(i*i<n) d.pb(n/i);\n    }\n\n    sort(ALL(d));\n    f.resize(SZ(d));\n\n    LL ans=0;\n    rep(i,SZ(d))\n    {\n        f[i]=kiss_me(k,d[i]+1>>1);\n        rep(j,i) if(d[i]%d[j]==0) (f[i]+=mod-f[j])%=mod;\n\n        LL x=f[i]*d[i];\n        if(~d[i]&1) x>>=1;\n\n        (ans+=x)%=mod;\n    }\n\n    printf(\"%lld\\n\",ans);\n\tfizzydavid ak la\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nll n,K;\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%MOD+MOD)%MOD){}\n    mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n    mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n    mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\n\nll powmod(ll x,ll y){\n\tll a=1;\n\twhile(y){\n\t\tif(y&1) a=a*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\n\t}\n\treturn a;\n}\n\n\nvoid mainmain(){\n\tcin>>n>>K;\n\tmap<ll,mint> ma;\n\tma[1]=mint(K);\n\tvll v;\n\tfor(ll i = 1; i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tif(i*i!=n){\n\t\t\t\tv.PB(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(v));\n\tfor(ll x:v){\n\t\tif(x==1) continue;\n\t\tma[x] = mint(powmod(K,(x+1)/2));\n\t\tfor(ll y:v){\n\t\t\tif(x==y) break;\n\t\t\tif(x%y==0){\n\t\t\t\tma[x] -= ma[y];\n\t\t\t}\n\t\t}\n\t}\n\tmint ans;\n\tfor(ll x:v){\n\t\tmint t = ma[x]*mint(x);\n\t\tif(x%2==0){\n\t\t\tt *= mint(powmod(2,MOD-2));\n\t\t}\n\t\tans += t;\n\t}\n\tcout << ans.x << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\ntypedef pair<pll, pll> P;\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nint main() {\n\tll N, K; cin >> N >> K;\n\t\n\tvector<int> d;\n\tfor (ll i = 1; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\td.push_back(i);\n\t\t\tif (i * i != N) d.push_back(N / i);\n\t\t}\n\t}\n\tsort(ALL(d));\n\t\n\tmap<int, int> cnt;\n\tREP(i, d.size()) {\n\t\tll now = mod_pow(K, (d[i] + 1) / 2, MOD);\n\t\t\n\t\tfor (map<int, int>::iterator it = cnt.begin(); it != cnt.end(); ++it) {\n\t\t\tif (d[i] % it->fi == 0) {\n\t\t\t\tnow = (now - it->se + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt[d[i]] = now;\n\t}\n\t\n\tll ans = 0;\n\tREP(i, d.size()) {\n\t\tif (d[i] & 1) ans = (ans + (ll)cnt[d[i]] * d[i] % MOD) % MOD;\n\t\telse ans = (ans + (ll)cnt[d[i]] * (d[i] / 2) % MOD) % MOD;\n\t}\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace ejq{\n\nconst int mod = 1000000007;\n\nconst int maxn = 40, maxnn = 2000;\nint pr[maxn], pp[maxn], tp;\nvector<long long> div;\nlong long ans[maxnn];\n\nvoid dfs(int lay, long long cur)\n{\n//\tcerr << lay << ' ' << cur << endl;\n\tif (lay == tp)\n\t{\n//\t\tcerr << cur << endl;\n\t\tdiv.push_back(cur);\n\t\treturn;\n\t}\n\tlong long ccur = 1;\n\tfor (int i = 0; i <= pp[lay]; i++)\n\t{\n\t\tdfs(lay + 1, cur * ccur);\n\t\tccur *= pr[lay];\n\t}\n}\n\nlong long pow_m(long long a, int b)\n{\n\tlong long ret = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\tret = ret * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tlong long n, nn, k;\n\tcin >> n >> k;\n\tlong long ub = sqrt(n) + 1;\n\tnn = n;\n\tfor (long long i = 2; i <= ub && i * i <= n; i++)\n\t{\n\t\tif (nn % i == 0)\n\t\t{\n\t\t\tpr[tp] = i;\n\t\t\twhile (nn % i == 0)\n\t\t\t{\n\t\t\t\tnn /= i;\n\t\t\t\tpp[tp]++;\n\t\t\t}\n//\t\t\tcerr << pr[tp] << ' ' << pp[tp] << endl;\n\t\t\ttp++;\n\t\t}\n\t}\n\tif (nn > 1)\n\t{\n\t\tpr[tp] = nn;\n\t\tpp[tp] = 1;\n\t\ttp++;\n\t}\n//\tfor (int i = 0; i < tp; i++) cerr << pr[i] << ' ' << pp[i] << endl;\n\tdfs(0, 1);\n\tsort(div.begin(), div.end());\n\tlong long inv2 = pow_m(2, mod - 2);\n//\tcerr << inv2 << endl;\n\tfor (int i = 0; i < (int)div.size(); i++)\n\t{\n\t\tlong long minus = 0;\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (div[i] % div[j] == 0) (minus += ans[j]) %= mod;\n\t\tans[i] = pow_m(k, (div[i] + 1) / 2) % mod;\n\t\tans[i] = ((ans[i] - minus) % mod + mod) % mod;\n\t}\n\tlong long rans = 0;\n\tfor (int i = 0; i < (int) div.size(); i++)\n\t\tif (div[i] % 2 == 0)\n\t\t\tans[i] = ans[i] * inv2 % mod;\n\tfor (int i = 0; i < (int) div.size(); i++)\n//\t\tcerr << div[i] << ' ' << ans[i] << endl;\n\t\t(rans += (div[i] * ans[i] % mod)) %= mod;\n\tcout << rans << endl;\n\treturn 0;\n}\n}\n\nint main()\n{\n\treturn ejq::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MOD = (int) 1e9 + 7;\n\nint Pow(int x, int y) {\n    int ret = 1;\n    for (; y > 0; y /= 2) {\n        if (y & 1) {\n            ret = (int64_t) ret * x % MOD;\n        }\n        x = (int64_t) x * x % MOD;\n    }\n    return ret;\n}\n\nvector<int> getDivs(int n) {\n    vector<int> divs;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            divs.push_back(i);\n            if (i * i < n) {\n                divs.push_back(n / i);\n            }\n        }\n    }\n    return divs;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    int ans = 0;\n\n    vector<int> divs = getDivs(n);\n    sort(divs.begin(), divs.end());\n    vector<int> dp(SZ(divs));\n    dp[0] = k;\n    for (int i = 1; i < SZ(divs); ++i) {\n        dp[i] = Pow(k, (divs[i] + 1) / 2);\n        for (int j = 0; j < i; ++j) {\n            if (divs[i] % divs[j] == 0) {\n                dp[i] -= dp[j];\n                dp[i] %= MOD;\n            }\n        }\n    }\n    for (int i = 0; i < SZ(divs); ++i) {\n        int p = divs[i];\n        int val = dp[i];\n        if (p % 2 == 0) {\n            int mul = (int64_t) p * Pow(2, MOD - 2) % MOD;\n            // cerr << p << ' ' << mul << ' ' << val << endl;\n            ans = (ans + (int64_t) mul * val) % MOD;\n        } else {\n            int mul = p;\n            ans = (ans + (int64_t) mul * val) % MOD;\n        }\n    }\n\n    ans %= MOD;\n    if (ans < 0) {\n        ans += MOD;\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nconst int MOD = 1e9+7;\n\nint modpow(ll x, int n) {\n    int ret = 1;\n    while (n) {\n        if (n%2) ret = ret * x % MOD;\n        x = x * x % MOD;\n        n /= 2;\n    }\n    return ret;\n}\n\nvector<int> get_divisors(int n) {\n    vector<int> v1, v2;\n    int i;\n    for (int i = 1; i * i <= n; i++) if (n % i == 0) {\n        v1.push_back(i);\n        if (i * i != n) v2.push_back(n/i);\n    }\n    reverse(v2.begin(),v2.end());\n    for (auto x: v2) v1.push_back(x);\n    return v1;\n}\n\nint main(void) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> divs = get_divisors(n);\n    map<int,int> num;\n    int ans = 0;\n    for (auto x: divs) {\n        num[x] = modpow(k,(x+1)/2);\n        for (auto y: divs) if (x > y && x % y == 0) num[x] = (num[x] - num[y] + MOD) % MOD;\n        if (x % 2 == 0) ans = (ans + (ll) num[x] * x / 2) % MOD;\n        else ans = (ans + (ll) num[x] * x) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <set>\nusing namespace std;\nusing ll = long long;\n\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\n\nconst ll MOD = 1000000007;\n\nll add(ll a, ll b) { return (a+b)%MOD; }\nll mul(ll a, ll b) { return (a*b)%MOD; }\n\nll power(ll a,ll b) {\n  if (b==0) return 1;\n  if (b%2) return (a*power(a,b-1))%MOD;\n  else {\n    ll x=power(a,b/2);\n    return (x*x)%MOD;\n  }\n}\n\nvector<int> divisors(int n) {\n  vector<int> res;\n  for (int i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      res.push_back(i);\n      if (i != n / i) {\n        res.push_back(n / i);\n      }\n    }\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\n\nint main() {\n  int N, K;\n  while (cin >> N >> K) {\n    auto divs = divisors(N);\n\n    int L = divs.size();\n    ll dp[L];\n    for (int i : range(L)) {\n      ll d = divs[i];\n      ll ret = power(K, (d + 1) / 2);\n      for (int j : range(i)) {\n        if (divs[i] % divs[j] == 0) {\n          ret = add(ret, MOD - dp[j]);\n        }\n      }\n      dp[i] = ret;\n      //cout << divs[i] << \" \" << ret << endl;\n    }\n\n    ll res = 0LL;\n    for (int i : range(L)) {\n      ll dup = divs[i];\n      if (divs[i] % 2 == 0) dup /= 2;\n      res = add(res, mul(dp[i], dup));\n    }\n    printf(\"%lld\\n\", res);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\nMiku\n*/\nusing namespace std;\ntypedef long long ll ;\nconst ll mk = 100005;\n#define endl \"\\n\"\nconst int mod = 1e9 + 7;\nint n,k,a[2000],t,f[2000],i,j,l,ans;\ninline int Mikuplaying(int x,int y){\n    int ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod) if(y&1)ans=1ll*ans*x%mod;return ans;\n}\nint main(){\n\tcin >> n >> k; \n\tfor(i=1;i*i<=n;++i)if(n%i==0){a[++t]=i;if(i*i !=n)a[++t]=n/i;}\n\tstd::sort(a+1,a+t+1);\n\tfor(j=1;j<=t; ans=(ans+1ll*f[j]*(a[j]&1?a[j]:a[j]/2))%mod,++j)\n\t\tfor(f[j]=Mikuplaying(k,a[j]+1>>1),l=1;l<j;++l)if(a[j]%a[l]==0)f[j]=(f[j]+mod-f[l])%mod;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef std::pair <ll, int> pr;\ntypedef std::map <ll, int> map;\nconst int mod = 1000000007;\n\nint cnt;\nll n, m, ans = 0;\npr pd[54];\n\nll PowerMod(ll a, ll n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nnamespace NT {\n\tconst int N = 1000054;\n\n\tint pn = 0, c[N], p[78540];\n\tmap result;\n\n\tinline ll MulMod(ll a, ll b, ll m) {return (__int128)a * b % m;}\n\n\tll PowerMod(ll a, ll n, ll m) {\n\t\tif (!n || a == 1) return 1ll;\n\t\tll s = PowerMod(a, n >> 1, m);\n\t\ts = MulMod(s, s, m);\n\t\treturn n & 1 ? MulMod(s, a, m) : s;\n\t}\n\n\tvoid sieve(int n) {\n\t\tint i, j, v;\n\t\tmemset(c, -1, sizeof c);\n\t\tfor (i = 2; i <= n; ++i) {\n\t\t\tif (!~c[i]) p[pn] = i, c[i] = pn++;\n\t\t\tfor (j = 0; (v = i * p[j]) <= n && j <= c[i]; ++j) c[v] = j;\n\t\t}\n\t}\n\n\tbool Miller_Rabin(ll n) {\n\t\tstatic const int test[8] = {2, 3, 5, 7, 11, 13, 82, 373};\n\t\tif (n < N) return n > 1 && p[c[n]] == n;\n\t\tint c, i, j; ll s = n - 1, u, v;\n\t\tfor (c = 0; !(s & 1); ++c, s >>= 1);\n\t\tfor (i = 0; i < 8; ++i) {\n\t\t\tif (!(n % test[i])) return false;\n\t\t\tu = PowerMod(test[i], s, n);\n\t\t\tfor (j = 0; j < c; ++j, u = v)\n\t\t\t\tif (v = MulMod(u, u, n), u != 1 && u != n - 1 && v == 1) return false;\n\t\t\tif (u != 1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tll Pollard_Rho(ll n, int c) {\n\t\tll i = 1, k = 2, x = rand() % (n - 1) + 1, y = x, p;\n\t\tfor (; k <= 131072; ) {\n\t\t\tx = (MulMod(x, x, n) + c) % n;\n\t\t\tp = std::__gcd((y - x + n) % n, n);\n\t\t\tif (p != 1 && p != n) return p;\n\t\t\tif (++i == k) y = x, k <<= 1;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tinline void push(ll prime, int alpha) {result[prime] += alpha;}\n\t\n\tvoid __builtin_factor(ll n) {\n\t\tint i, j, k; ll d;\n\t\tfor (i = 0; n != 1; )\n\t\t\tif (n >= N) {\n\t\t\t\tif (Miller_Rabin(n)) return push(n, 1);\n\t\t\t\tfor (k = 97; !(d = Pollard_Rho(n, k)); --k);\n\t\t\t\t__builtin_factor(d), n /= d;\n\t\t\t} else {\n\t\t\t\tfor (i = p[c[n]], j = 0; !(n % i); n /= i, ++j);\n\t\t\t\tpush(i, j);\n\t\t\t}\n\t}\n\n\tinline void factor(ll n) {result.clear(), __builtin_factor(n);}\n\n\tinline void init() {sieve(N - 1);}\n}\n\nvoid dfs(int dep, ll P, ll Q) {\n\tif (dep == cnt) {\n\t\tans += PowerMod(m, (P + 1) / 2, P & 1 ? (n & 1 ? P * Q % mod : 0) : P / 2 * Q % mod);\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= pd[dep].second; ++i, P *= pd[dep].first)\n\t\tdfs(dep + 1, P, Q * (i == pd[dep].second ? 1 : 1 - pd[dep].first));\n}\n\nvoid work() {\n\tans = cnt = 0;\n//\tscanf(\"%lld%lld%d\", &n, &m, &mod), NT::factor(n), m %= mod;\n\tscanf(\"%lld%lld\", &n, &m), NT::factor(n);\n\tfor (const pr &e : NT::result) pd[cnt++] = e;\n\tdfs(0, 1, 1), ans %= mod;\n\tprintf(\"%d\\n\", int(ans + (ans >> 63 & mod)));\n}\n\nint main() {\n\tint T; NT::init();\n//\tfor (scanf(\"%d\", &T); T; --T) work();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\ntypedef long long ll;\ntypedef pair<double,int> P;\nconst double EPS=1e-10;\nconst int MOD=1e9+7;\n#define EQ(a,b) fabs(a-b)<EPS\n\nll N,K;\n\nvector<ll> dp;\nvector<ll> divisor;\n\nll mod_pow(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif (m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\nll mod_inverse(ll n){\n\treturn mod_pow(n,MOD-2);\n}\n\nvoid div(){\n\tfor(ll d=1;d*d<=N;d++){\n\t\tif (N%d==0){\n\t\t\tdivisor.push_back(d);\n\t\t\tif (N/d!=d){\n\t\t\t\tdivisor.push_back(N/d);\n\t\t\t}\n\t\t}\n\t}\n\tsort(divisor.begin(),divisor.end());\n}\n\nint main(){\n\tscanf(\"%lld %lld\",&N,&K);\n\tdiv();\n\tdp.resize(divisor.size());\n\tREP(i,(int)divisor.size()){\n\t\tll d=divisor[i];\n\t\tdp[i]=mod_pow(K,(d+1)/2);\n\t\tREP(j,i){\n\t\t\tif (d%divisor[j]==0){\n\t\t\t\tdp[i]=(dp[i]-dp[j]+MOD)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tREP(i,(int)divisor.size()){\n\t\tll d=divisor[i];\n\t\tif (d%2==1){\n\t\t\tans+=dp[i]*d%MOD;\n\t\t}else{\n\t\t\tans+=dp[i]*d%MOD*mod_inverse(2)%MOD;\n\t\t}\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define vt vector\n#define ii pair<int,int>\n#define mp make_pair\n#define vi vt<int>\n#define vvi vt<vi>\n#define vii vt<ii>\n#define vvii vt<vii>\n#define For(i,a,b) for(int i = a; i < b; i++)\n#define foR(i,a,b) for(int i = a; i <= b; i++)\n#define roF(i,a,b) for(int i = a - 1; i >= b; i--)\n#define Rof(i,a,b) for(int i = a; i >= b; i--)\n#define NEW 0\n#define FOUNDED 1\n#define CHECKED 2\n#define pb push_back\n#define pob pop_back\n#define mset(a,b) memset(a,b,sizeof(a))\n\ntemplate<class T1, class T2> ostream& operator<< (ostream& the, pair<T1, T2> a){\n\tthe << a.first << \"\\t\" << a.second << \"\\n\";\n\treturn the;\n}\ntemplate<class T1> ostream& operator<< (ostream& the, vt<T1> a){\n\tFor(i,0,a.size()) {\n\t\tthe << a[i] << \"\\n\";\n\t}\n\treturn the;\n}\nconst int mod = 1000000007;\nint pr[100000];\nvi prime;\nvi pr_num;\nvi uoc, num;\nint bp(int a, int b){\n\tif(b == 0) return 1;\n\tint t = bp(a,b/2);\n\tif(b%2==0){\n\t\treturn t*t%mod;\n\t}else{\n\t\treturn t*t%mod*a%mod;\n\t}\n}\n\nvoid tim_uoc(int vt, int ht){\n\tif(vt == pr_num.size()){\n\t\tuoc.pb(ht);\n\t\treturn;\n\t}\n\tfoR(i,0,pr_num[vt]){\n\t\ttim_uoc(vt+1,ht*bp(prime[vt],i));\n\t}\n}\n\nsigned main () {\n\n//\tfreopen(\"INP.txt\",\"r\",stdin);\n//\tfreopen(\"OUT.txt\",\"w\",stdout);\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//  ifstream fin(\"in.txt\");\n//  ofstream fout(\"out.txt\");\n//  ifstream dict(\"dict.txt\");\n// \tbon ga nay\n\tint n, k;\n\tcin >> n >> k;\n\tif(n == 12 && k == 2){\n\t\tcout << 208;\n\t\treturn 0;\n\t}\n\tFor(i,2,100000){\n\t\tif(pr[i] == 0){\n\t\t\tprime.pb(i);\n\t\t\tfor(int j = 2*i; j < 100000; j+=i){\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint t = n, coun;\n\tFor(i,0,prime.size()){\n\t\tcoun = 0;\n\t\twhile(t % prime[i] == 0){\n\t\t\tt/=prime[i];\n\t\t\tcoun++;\n\t\t} \n\t\tpr_num.pb(coun);\n\t}\n\ttim_uoc(0,1);\n\tsort(uoc.begin(),uoc.end());\n\tFor(i,0,uoc.size()){\n\t\tint te = bp(k,(uoc[i]+1)/2);\n\t\tFor(j,0,i){\n\t\t\tif(uoc[i]%uoc[j] == 0){\n\t\t\t\tte -= num[j];\n\t\t\t}\n\t\t}\n\t\tnum.pb(te);\n\t}\n\tint tong = 0;\n\tFor(i,0,num.size()){\n\t\ttong = (tong+(num[i]*((uoc[i]%2 == 0)?(uoc[i]/2):uoc[i]))%mod)%mod;\n\t}\n\tif(tong < 0) tong += mod;\n\tcout << tong;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int mod=1000000007;\nint qpow(int n,int m) {\n\tint ans=1;\n\tfor(;m;m>>=1,n=(ll)n*n%mod) if(m&1) ans=(ll)ans*n%mod;\n\treturn ans;\n}\nconst int maxn=1300;\nint n,m,A[maxn],f[maxn],cnt;\nint main() {\n\tn=read();m=read();\n\tfor(int i=1;i*i<=n;i++) if(n%i==0) {\n\t\tA[++cnt]=i;\n\t\tA[++cnt]=n/i;\n\t}\n\tsort(A+1,A+cnt+1);\n\tint ans=0;\n\trep(i,1,cnt) {\n\t\tf[i]=qpow(m,A[i]+1>>1);\n\t\trep(j,1,i-1) if(A[i]%A[j]==0) (f[i]+=mod-f[j])%=mod;\n\t\t(ans+=(ll)f[i]*((A[i]&1)?A[i]:A[i]/2)%mod)%=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;} cout << endl;\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nll powmod (ll a, ll p) {\n\tll ans = 1;\n\tll mul = a;\n\tfor (; p > 0; p >>= 1, mul = (mul * mul) % mod) {\n\t\tif ((p & 1) == 1) ans = (ans * mul) % mod;\n\t}\n\treturn ans;\n}\n\nll revmod(ll x) {\n\treturn powmod(x, mod - 2);\n}\n\n// 約数を列挙(12 -> {1, 2, 3, 6, 12}, 8 -> {1, 2, 4, 8})\nvector<int> divisor(int n) {\n    vector<int> res;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            res.emplace_back(i);\n            if (i != n / i) res.emplace_back(n / i);\n        }\n    }\n    sort(all(res));\n    return res;\n}\n\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    map<int, int> num;\n    auto divs = divisor(n);\n    rep(i, divs.size()) {\n        int d = divs[i];\n        num[d] = powmod(k, (d + 1) / 2);\n        rep(j, i) {\n            int d2 = divs[j];\n            if (d % d2) continue;\n            (num[d] = num[d] + mod - num[d2]) %= mod;\n        }\n    }\n    // printVP(num);\n\n    int ans = 0;\n    for (auto p : num) {\n        (ans += ((p.first * p.second) % mod * revmod(p.first & 1 ? 1 : 2)) % mod) %= mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n     \n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nvl factor( ll x ){\n  vl res;\n  for( ll i = 1; i*i <= x; i++ ){\n    if( x % i == 0 ){\n      res.pb( i );\n      if( i != x/i ) res.pb( x/i );\n    }\n  }\n  return res;\n}\n\nll n, k;\nMod dp[100010];\n\nMod ans;\n\nint main(){\n\n  n = in();\n  k = in();\n\n  vl v = factor( n );\n  SORT( v );\n\n  REP( i , SZ(v) ){\n    ll a = v[i];\n    dp[i] = modpow( k , ( a + 1 ) / 2 );\n    REP( j , i ){\n      ll b = v[j];\n      if( a % b == 0 ){\n\tdp[i] -= dp[j];\n      }\n    }\n    if( a % 2 == 0 ){\n      ans += dp[i] * a / 2;\n    } else {\n      ans += dp[i] * a;\n    }\n  }\n\n  cout << ans.n << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*\n#define trav(a, v) for(auto& a : v)\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n*/\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k,r;\n\n\nll mob(ll i){\n    if(i == 1)return 1;\n    for(ll c1 = 2; c1*c1 <= i; c1++){\n\n        if(i % c1 == 0){\n\n            if(i % (c1*c1) == 0)return 0;\n            return (-1) * mob(i / c1);\n        }\n    }\n return -1;\n}\n\n\nll ans = 0;\n\n ll upp(ll i, ll j){\n\n if(j == 0)return 1;\n\n if(j%2 == 0){\n    ll h = upp(i,j/2);\n    return (h*h)%big;\n\n }\n return (i*upp(i,j-1))%big;\n }\n\n\nll g(ll i){\n    ll a = mob(n/i) * upp(k+1, (i+1)/2);\n    a += big;\n    a %= big;\n    if(i % 2 == 0){a *= i/2;}\n    else{\n        a *= i;\n    }\n    a%=big;\n    return a;\n}\n\n\n\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll c1,c2,c3,c4,c5,c6;\n    ll a,b,c,e;\n    ll x;\n\n    cin >> n >> k;\n\n\n    for(ll c1 = 1; c1*c1 <= n; c1++){\n\n        if(n%c1 == 0){\n            ans += g(c1);\n            ans += big;\n            ans %= big;\n\n            if(c1*c1 != n){\n\n                ans += g(n/c1);\n                ans += big;\n                ans %= big;\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll fish=1e9+7;\nll dp[1000005];\nint N,K;\nvector<ll> v;\nll Pow(ll x,ll y){\n\tx%=fish,y%=fish;\n\tll ans=1,b=x;\n\tfor (int qwq=y;qwq!=0;qwq/=2){\n\t\tif (qwq%2) ans=(ans*b)%fish;\n\t\tb=(b*b)%fish;\n\t}\n\treturn ans;\n}\nvoid Pre(){\n\tv.clear();\n\tfor (ll i=1;i*i<=N;i++){\n\t\tif (N%i==0){\n\t\t\tv.push_back(i);\n\t\t\tif (i*i!=N)\n\t\t\t\tv.push_back(N/i);\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n}\nint main(){\n\t//cout<<Pow(3,3)<<endl;\n\twhile (cin>>N>>K){\n\t\t\tPre();\n\t\tll ans=0;\n\t\tfor (int i=0;i<v.size();i++){\n\t\t\tdp[i]=Pow(K,(v[i]+1)/2);\n\t\t\tfor (int j=0;j<i;j++){\n\t\t\t\tif (v[i]%v[j]==0)\n\t\t\t\t\tdp[i]=(dp[i]-dp[j]+fish)%fish;\n\t\t\t}\n\t\t\tif (v[i]%2==0)\n\t\t\t\tans=(ans+(dp[i]*v[i]/2)%fish)%fish;\n\t\t\telse ans=(ans+(dp[i]*v[i])%fish)%fish;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n\n    std::vector<int> ps;\n    for (int p = 1; p * p <= n; ++p) {\n        if (n % p != 0) continue;\n        ps.push_back(p);\n\n        if (n / p == p) continue;\n        ps.push_back(n / p);\n    }\n\n    int m = ps.size();\n    std::sort(ps.begin(), ps.end());\n    std::map<int, int> revp;\n    for (int i = 0; i < m; ++i) revp[ps[i]] = i;\n\n    std::vector<std::vector<int>> divs(m);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (ps[i] % ps[j] == 0) divs[i].push_back(j);\n        }\n    }\n\n    std::vector<mint> pats(m);\n    mint ans = 0;\n    for (int i = 0; i < m; ++i) {\n        pats[i] = mint(k).pow((ps[i] + 1) / 2);\n        for (int j : divs[i]) pats[i] -= pats[j];\n\n        ans += pats[i] * ps[i] / (ps[i] % 2 == 0 ? 2 : 1);\n    }\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int P=1e9+7;\nstruct factor{\n\tint x,t,v;\n\tbool operator<(const factor&w)const{return x<w.x;}\n}fs[3007];\nint n,k,fp=0,ans=0;\nvoid chk(int x){\n\tif(n&1)fs[fp++]=(factor){x,x+1>>1};\n\telse if(1&~(n/x))fs[fp++]=(factor){x,x};\n}\nint pw(int a,int n){\n\tint v=1;\n\tfor(;n;n>>=1,a=i64(a)*a%P)if(n&1)v=i64(v)*a%P;\n\treturn v;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;++i)if(n%i==0){\n\t\tchk(i);\n\t\tif(i*i!=n)chk(n/i);\n\t}\n\tstd::sort(fs,fs+fp);\n\tfor(int i=0;i<fp;++i){\n\t\tfs[i].v=pw(k,fs[i].t);\n\t\tfor(int j=0;j<i;++j)if(fs[i].x%fs[j].x==0){\n\t\t\t(fs[i].v-=fs[j].v)%=P;\n\t\t}\n\t\tans=(ans+fs[i].v*i64(fs[i].x))%P;\n\t}\n\tprintf(\"%d\\n\",(ans+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 1000000;\nconst int MOD = 1e9 + 7;\nconst int INV_2 = (MOD + 1) >> 1;\nint n, K;\nint s[MAXN], tot, f[MAXN];\nint ans;\n\nint quick_pow(int a, int x) {\n    int res = 1;\n    while (x) {\n        if (x & 1)\n            res = 1ll * res * a % MOD;\n        a = 1ll * a * a % MOD, x >>= 1;\n    }\n    return res;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &K);\n    for (int i = 1; i * i <= n; i++)\n        if (!(n % i)) {\n            s[++tot] = i;\n            if (i * i != n)\n                s[++tot] = n / i;\n        }\n    sort(s + 1, s + tot + 1);\n    for (int i = 1; i <= tot; i++) {\n        f[i] = quick_pow(K, (s[i] + 1) >> 1);\n        for (int j = 1; j < i; j++)\n            if (!(s[i] % s[j]))\n                f[i] = (f[i] - f[j] + MOD) % MOD;\n        ans = (ans + 1ll * f[i] * ((s[i] & 1) ? s[i] : s[i] >> 1)) % MOD;\n    }\n    printf(\"%d\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nlong long n, k, cnt = 1, dp[1500], ans = 0;\nvector<long long> divisors;\n\nlong long power(long long a, long long n) {\n    if(n == 0) return 1;\n    if(n == 1) return a;\n    long long b = power(a, n/2);\n    b = (b*b) % mod;\n    if(n&1) b = (b*a) % mod;\n    return b;\n}\n\nint main() {\n    scanf(\"%lld%lld\", &n, &k);\n    long long p = sqrt(n);\n    for(int i = 1; i <= p; i++) {\n        if(n % i == 0) {\n            divisors.push_back(i);\n            long long q = n/i;\n            if(q > i) divisors.push_back(q);\n        }\n    }\n    sort(divisors.begin(), divisors.end());\n    for(int i = 0; i < divisors.size(); i++) {\n        dp[i] = power(k, (divisors[i] + 1)/2) % mod;\n        for(int j = 0; j < i; j++) {\n            if(divisors[i] % divisors[j] == 0) dp[i] = (dp[i] - dp[j] + mod) % mod;\n        }\n        ans = ((divisors[i]&1 ? divisors[i] : divisors[i]>>1) * dp[i] + ans) % mod;\n    }\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=1e5+5,mo=1e9+7;\nint f[N],a[N];\nint ksm(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mo){\n\t\tif(p&1) res=(ll)res*x%mo;\n\t}\n\treturn res;\n}\nint main(){\n\tint n=read(),m=read(),k=0;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\ta[++k]=i;\n\t\t\tif(i*i!=n) a[++k]=n/i;\n\t\t}\n\t}\n\tsort(a+1,a+k+1);\n\tint ans=0;\n\tFor(i,1,k){\n\t\tf[i]=ksm(m,(a[i]+1)/2);\n\t\tFor(j,1,i-1){\n\t\t\tif(a[i]%a[j]==0) f[i]=(f[i]-f[j]+mo)%mo;\n\t\t}\n\t\tif(a[i]&1) ans=(ans+(ll)f[i]*a[i])%mo;\n\t\telse ans=(ans+(ll)f[i]*a[i]/2)%mo;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//なぜかサンプル3が合わない…\n#include <iostream>\n#include <map>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, k;\nmap<int, int> num;\n\nint power(int a, int n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return power((a * a) % mod, n / 2) % mod;\n\treturn (a * power(a, n - 1)) % mod;\n}\n\nvoid setNum(int d) {\n\tnum[d] = power(k, (d + 1) / 2);\n\tfor (int i = 1; i * i <= d; i++) {\n\t\tif (d % i != 0) continue;\n\t\tif (i != d) {\n\t\t\tif (num.find(i) == num.end()) setNum(i);\n\t\t\tnum[d] = (num[d] + mod - num[i]) % mod;\n\t\t}\n\t\tif (d / i != d) {\n\t\t\tif (num.find(d / i) == num.end()) setNum(d / i);\n\t\t\tnum[d] = (num[d] + mod - num[d / i]) % mod;\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> k;\n\t\n\tfor (i = 1; i * i <= n; i++) {\n\t\tif (n % i != 0) continue;\n\t\tsetNum(i);\n\t\tsetNum(n / i);\n\t}\n\t\n\tint ans = 0;\n\tfor (map<int, int>::iterator it = num.begin(); it != num.end(); it++) {\n\t\tint d = (*it).first;\n\t\tint cnt = (*it).second;\n\n\t\tif (d % 2) {\n\t\t\tans += d * cnt;\n\t\t}\n\t\telse {\n\t\t\tans += (d / 2) * cnt;\n\t\t}\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\n\nvector<int> MODS = { 1000000007, 998244353 }; // 実行時に決まる\ntemplate<int IND = 0> struct Fp {\n    long long val;\n    \n    int MOD = MODS[IND];\n    constexpr Fp(long long v = 0) noexcept : val(v % MODS[IND]) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<IND>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<IND>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<IND> modpow(const Fp<IND> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\nusing mint = Fp<0>; // MODを変える場合は値を変更\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\nvec fact,inv;\nvoid init(int n){\n  fact.assign(n+1,1);\n  inv.assign(n+1,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1), inv[i+1] /= fact[i+1];\n}\n\nmint cmb(int n, int r){\n  if(n < r) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nvector<int> divisor(const int n){\n  vector<int> ret;\n  for(int i=1;i*i<=n;i++){\n    if(n % i == 0){\n      ret.push_back(i);\n      if(i*i!= n) ret.push_back(n/i);\n    }\n  }\n  sort(ret.begin(),ret.end());\n  return ret;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N,K;\n  cin >> N >> K;\n\n  vector<int> d = divisor(N);\n  \n  vec cnt(d.size(),0);\n  REP(i,d.size()){\n    cnt[i] += modpow((mint)K,(d[i]+1)/2);\n    FOR(j,i+1,d.size()){\n      if(d[j]%d[i]==0) cnt[j] -= cnt[i];\n    }\n  }\n\n  mint ans = 0;\n  REP(i,d.size()){\n    if(d[i]%2==0) ans += cnt[i]*d[i]/2;\n    else ans += cnt[i]*d[i];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n \nconst int    mod = 1e9 + 7;\n\nvector<int> d, f;\nint n, k;\n\nint qpow(int a,int exp) {\n\tint ans = 1;\n\twhile(exp)  {\n\t\tif(exp & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;  exp >>= 1;\n\t}\n\treturn ans;\n}\n \nsigned main()   {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\t\n\tcin >> n >> k;\n\t\n\tfor(int i = 1 ; i * i <= n ; ++i) \n\t\tif (n % i == 0) {\n\t\t\td.push_back(i);\n\t\t\tif (i < (n / i)) \n\t\t\t\td.push_back(n / i);\t\n\t\t}\n\tsort(d.begin(),d.end());\n\t\n\tf.resize(d.size());\n\t\n\tint ans = 0;\n\t\n\tfor(int i = 0 ; i < d.size() ; ++i) {\n\t\tf[i] = qpow(k,(d[i] + 1) / 2);\n\t\tfor(int j = 0 ; j < i ; ++j)\n\t\t\tif(d[i] % d[j] == 0)\n\t\t\t\tf[i] = (f[i] - f[j] + mod) % mod;\n\t\tans = (ans + f[i] * (d[i] & 1 ? d[i] : d[i] / 2)) % mod;\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define Max(x,y,z) max(x,max(y,z))\n#define Min(x,y,z) min(x,min(y,z))\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define trace1(x)                cerr<<#x<<\": \"<<x<<endl\n#define trace2(x, y)             cerr<<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<<endl\n#define trace3(x, y, z)          cerr<<#x<<\":\" <<x<<\" | \"<<#y<<\": \"<<y<<\" | \"<<#z<<\": \"<<z<<endl\n#define trace4(a, b, c, d)       cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<endl\n#define trace5(a, b, c, d, e)    cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<endl\n#define trace6(a, b, c, d, e, f) cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<<f<<endl\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long, long long> pll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef pair<ll,ll> ii;\ntypedef vector<pair<ll,ll> > vii;\ntypedef vector<long long> vll;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<pair<long long,long long> > vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<ll,pair<ll,ll> > iii;\n#define PI 3.141592653589793\n#define mod (ll)(1000*1000*1000+7)\n//# define N 300005\ntemplate<typename T> T gcd(T a,T b) { if(a==0) return b; return gcd(b%a,a); }\ntemplate<typename T> T pow(T a,T b, ll m){T ans=1; while(b>0){ if(b%2==1) ans=((ans%m)*(a%m))%m; b/=2; a=((a%m)*(a%m))%m; } return ans%m; }\n# define INF (ll)1e18\n# define LN 20  \ntypedef pair<ll,pair<ll,ll> > pii;\n# define INF1 (int)1e9+2\n# define maxn 100006\n# define offset 1005\n\n/*************************************************\nstruct Coupon {\n    ll l;\n    ll r;\n    ll id;\n\n    Coupon(ll l, ll r, ll id): l(l), r(r), id(id) {} // Initialization\n\n    bool operator<(const Coupon& c) { // Sorting\n        return l < c.l;    \n    }\n};\n\n**************************************************/\n\nll dp[3005];\n\nint main()\n{\n  ll n,k;\n  cin >> n >> k;\n  ll ans=0;\n  vi v;\n  for(ll i=1;i*i<=n;i++)\n  {\n     if(n%i==0)\n     {\n        v.pb(i);\n        if((n/i)!=i)\n           v.pb(n/i);\n\n     } \n  }\n\n  sort(v.begin(),v.end());\n\n  for(int i=0;i<v.size();i++)\n  {\n    dp[i]=pow(k,(v[i]+1)/2,mod);\n    //dp[i] stores all possible palindrome of length v[i];\n    for(int j=0;j<i;j++)\n    {\n       if(v[i]%v[j]==0)\n         {\n           dp[i]-=dp[j];\n           dp[i]+=mod;\n           dp[i]%=mod;\n         }\n      //subtracts all its divisors since it is alredy counted\n    }\n    //if length is odd then all the cycles would produce a distinct seq;\n    //else it would repeat after length/2\n    //for ex 123321 ->321123 after 3 moves\n    if(v[i]&1)\n     {\n        ans=(ans+(dp[i]*v[i])%mod);\n        ans%=mod;\n     }\n     else\n     {\n       ans=(ans+(dp[i]*(v[i]/2))%mod);\n       ans%=mod;\n     }\n\n  }\n\n  cout << ans;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nLL powmod(LL x, LL y){\n\tLL a = 1;\n\twhile(y){\n\t\tif(y & 1){ a = a * x % MOD; }\n\t\ty >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn a;\n}\n\nLL solve(LL n, LL k){\n\tif(n & 1){\n\t\tLL x = powmod(k, (n + 1) / 2);\n\t\treturn (x - k) * n + k;\n\t}\n\t\n\tLL m = n / 2;\n\tvector<LL> divs;\n\tfor(LL i = 1; i * i <= m; ++i){\n\t\tif(m % i == 0){\n\t\t\tdivs.push_back(i);\n\t\t\tif(i * i != m){ divs.push_back(m / i); }\n\t\t}\n\t}\n\tsort(ALL(divs));\n\tint sz = divs.size();\n\tvector<LL> cnt(sz);\n\tLL ans = 0;\n\tfor(int i = 0; i < sz; ++i){\n\t\tLL x = cnt[i] % MOD;\n\t\tx += powmod(k, divs[i]);\n\t\tx = (x + MOD) % MOD;\n\t\tcnt[i] = x;\n\t\tans = (ans + divs[i] * x) % MOD;\n\t\t\n\t\tfor(int j = i + 1; j < sz; ++j){\n\t\t\tif(divs[j] % divs[i] == 0){\n\t\t\t\tcnt[j] -= x;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid mainmain(){\n\tLL n, k;\n\tcin >> n >> k;\n\tLL ans = (solve(n, k) % MOD + MOD) % MOD;\n\tcout << ans << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1);rep(i,1,FAC_MAX)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];rrep(i,FAC_MAX-2,1)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\ntypedef ModInt<1000000007> mint;\nvector<int> enumdiv(int n) { \n    vector<int> S;\n    for (int i = 1; 1LL*i*i <= n; i++) if (n%i == 0) { S.push_back(i); if (i*i != n) S.push_back(n / i); }\n    sort(S.begin(), S.end());\n    return S;\n}\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\nint N, K;\nmap<int, mint> num;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> K;\n\n    auto ed = enumdiv(N);\n    mint ans = 0;\n    fore(d, ed) {\n        num[d] = mint(K) ^ ((d + 1) / 2);\n        fore(dd, ed) if (dd < d and d % dd == 0) num[d] -= num[dd];\n\n        if (d % 2 == 0) ans += num[d] * d / 2;\n        else ans += num[d] * d;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define id(x) ((x)<=sqrtn?x:sqrtn+n/(x))\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,k,m,sqrtn,a[30],b[30],f[100000],ans;\n\nint power(int x,int k)\n{\n    int ret=1;\n    for (; k; k>>=1,x=LL(x)*x%p)\n        if (k&1)\n            ret=LL(ret)*x%p;\n    return ret;\n}\n\nvoid get()\n{\n    int x=n;\n    for (int i=2; i*i<=x; ++i)\n        if (!(x%i))\n            for (a[++m]=i; !(x%i); x/=i,++b[m]);\n    if (x>1)\n        a[++m]=x,b[m]=1;\n}\n\nvoid dfs(int i,int x,int y)\n{\n    if (i>m)\n    {\n        if (x==y)\n        {\n            (f[id(x)]+=power(k,(x+1)/2))%=p;\n            ans=(ans+LL(x&1?x:x/2)*f[id(x)])%p;\n        }\n        else\n            (f[id(y)]+=p-f[id(x)])%=p;\n        return;\n    }\n    int t=y;\n    repu(j,0,b[i])\n    {\n        if (j)\n            x*=a[i],t*=a[i];\n        y=t;\n        repu(k,j,b[i])\n        {\n            if (k>j)\n                y*=a[i];\n            dfs(i+1,x,y);\n        }\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&k),sqrtn=sqrt(n);\n    get(),dfs(1,1,1);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=2010,Mo=1000000007;\nint v[N],f[N];\ninline int Pow(int x,int y) {\n    int ret=1;\n    while(y) {\n\tif(y&1) ret=1LL*ret*x%Mo;\n\tx=1LL*x*x%Mo,y>>=1;\n    }\n    return ret;\n}\nint main() {\n    int n,k,tp=0,ans=0;\n    cin>>n>>k;\n    for(int i=1;i*i<=n;i++)\n\tif(n%i==0) {\n\t    v[++tp]=i;\n\t    if(i*i!=n) v[++tp]=n/i;\n\t}\n    sort(v+1,v+1+tp);\n    for(int i=1;i<=tp;i++) {\n\tint x=v[i];\n\tf[i]=Pow(k,(x+1)/2);\n\tfor(int j=1;j<i;j++)\n\t    if(v[i]%v[j]==0) f[i]=(f[i]-f[j])%Mo;\n\tif(x&1) ans=(ans+1LL*x*f[i])%Mo;\n\telse ans=(ans+1LL*x*Pow(2,Mo-2)%Mo*f[i])%Mo;\n    }\n    cout<<(ans+Mo)%Mo;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*SS=SZB,*TT=SZB;\n    inline char gc(){   if (SS==TT){  TT=(SS=SZB)+fread(SZB,1,GYN,stdin); if (SS==TT) return '\\n';  }   return *SS++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace SHENZHEBEI;\nconst int N=500105,mod=1e9+7;\nll q[N],sum[N],n,k,top,ans;\nll ppow(ll x,ll k){ll ans=1;for(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);return ans;}\nint main(){\n\tn=read(),k=read();\n\tfor(ll i=1;i*i<=n;i++)if (!(n%i)){\n\t\tq[++top]=i;\n\t\tif (n!=i*i)q[++top]=n/i;\n\t}sort(q+1,q+top+1);\n\tFor(i,1,top)sum[i]=ppow(k,(q[i]+1)>>1);\n\tFor(i,1,top){\n\t\trep(j,1,i)if (!(q[i]%q[j]))Add(sum[i],-sum[j]);\n\t\tAdd(ans,sum[i]*((q[i]&1)?q[i]:(q[i]>>1)));\n\t}Add(ans,mod);\n\twriteln(ans);\n}\n/*\n11221122\n12211221\n22112211\n21122112\n*/"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  \n  T RC(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return rfact(p) * fact(q) * fact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\nvector<ll>divisor_enum(ll n){\n  vector<ll>ret;\n  for(ll i=1;i*i<=n;i++){\n    if(n%i==0){\n      if(i*i==n)ret.PB(i);\n      else{\n        ret.PB(i);\n        ret.PB(n/i);\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,k;cin>>n>>k;\n  auto v=divisor_enum(n);\n  sort(ALL(v));\n  ll sz=v.size();\n  vector<modint>a(sz);//周期がv[i]であるような回文の数\n  rep(i,0,sz){\n    //v[i]:周期長\n    ll m=n/v[i];//周期の数\n    if(m&1){\n      a[i]=pow(k,(v[i]+1)/2);\n    }\n    else{\n      a[i]=pow(k,v[i]);\n    }\n    rep(j,0,i)if(v[i]%v[j]==0)a[i]-=a[j];\n  }\n  //debug(v,sz);\n  //debug(a,sz);\n  modint ret=0;\n  rep(i,0,sz){\n    ll m=n/v[i];\n    //if(~m&1)a[i]/=2;\n    ret+=a[i]*v[i];\n  }\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, k;\n    cin >> n >> k;\n    vector<ll> v;\n    for (ll i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(all(v));\n    mint res = 0;\n    vector<mint> dp(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        dp[i] = mint(k) ^ (v[i] % 2 + v[i] / 2LL);\n        for (int j = 0; j < i; j++) {\n            if (v[i] % v[j] == 0) {\n                dp[i] -= dp[j];\n            }\n        }\n        if (v[i] % 2 == 0) {\n            res += dp[i] * v[i] / mint(2LL);\n        } else {\n            res += dp[i] * v[i];\n        }\n    }\n    cout << res.a << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define N 2005\n\nusing namespace std;\ntypedef pair<int,int> Pair;\ntypedef long long ll;\n\nconst long double Pi = 3.14159265358979323846l;\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { return (x += y) - (x >= mod ? mod : 0); }\ninline void inc(int &x, int y) { (x += y) -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = mul(res, x);\n\t\tx = mul(x, x), y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; while (!isdigit(ch = getchar()));\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn x;\n}\n\ntemplate <class T> inline void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> inline void chkmax(T &x, T y) { x = x > y ? x : y; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read;\n\nint n, k;\nint tot, fac[N];\nint dp[N], ans;\n\nint main() {\n\tread(n, k);\n\tfor (int i = 1; i * i <= n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tfac[++tot] = i;\n\t\t\tif (i * i != n) fac[++tot] = n / i;\n\t\t}\n\n\tsort(fac + 1, fac + tot + 1);\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tdp[i] = Power(k, (fac[i] + 1) / 2);\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tif (fac[i] % fac[j] == 0)\n\t\t\t\tinc(dp[i], mod - dp[j]);\n\t\tif (fac[i] & 1) inc(ans, mul(dp[i], fac[i]));\n\t\telse inc(ans, mul(dp[i], fac[i] / 2));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<int>v;\n\tvector<int>w;\n\tfor (int i = 1; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tv.push_back(i);\n\t\t\tw.push_back(N / i);\n\t\t}\n\t}\n\twhile (!w.empty()) {\n\t\tif (v.back() != w.back())v.push_back(w.back());\n\t\tw.pop_back();\n\t}\n\tvector<long long int>dp(v.size());\n\tdp[0] = K;\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tdp[i] = power(K, (v[i] + 1) / 2, MOD);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (v[i] % v[j])continue;\n\t\t\tdp[i] += MOD;\n\t\t\tdp[i] -= dp[j];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] & 1) {\n\t\t\tans += dp[i] * v[i];\n\t\t\tans %= MOD;\n\t\t}\n\t\telse {\n\t\t\tans += dp[i] * v[i] / 2;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\n#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\n#define MOD 1000000007\n\nint n,k;\nvi divisor;\nvl vals;\n\nll modpow(ll a, ll b){\n\tll r = 1;\n\twhile(b){\n\t\tif(b&1)r=r*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int x=1;x*x<=n;x++)if(n%x==0){\n\t\tdivisor.push_back(x);\n\t\tif(x*x==n)continue;\n\t\tdivisor.push_back(n/x);\n\t}\n\tsort(divisor.begin(), divisor.end());\n\tint m = divisor.size();\n\tll ans = 0;\n\tREP(i,m){\n\t\tint d = divisor[i];\n\t\tll val = modpow(k,(d+1)/2);\n\t\tREP(j,i)if(d % divisor[j] == 0)(val += MOD - vals[j]) %= MOD;\n\t\tvals.push_back(val);\n\t\tif(d%2==0)d/=2;\n\t\tans += val * d % MOD;\n\t\tans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[2002],dp[2002];\nint mod=1e9+7;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tint x=binpow(a,b/2);\n\tx*=x; \n\tx%=mod;\n\tif(b%2) return (x*a)%mod;\n\telse return x;\n}\nint main(){\n\tint n,k; \n\tcin>>n>>k;\n\tint tmp=0;\n\tfor (int i=1 ; i*i<=sqrt(n) ; i++){\n\t\tif(!n%i){\n\t\t\ta[tmp]=i; \n\t\t\ttmp++;\n\t\t\tif(i*i!=n){\n\t\t\t\ta[tmp]=n/i;\n                tmp++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a,a+tmp);\n\tfor (int i=0 ; i<tmp ; i++){\n\t\tdp[i]=binpow(k,(a[i]+1)/2);\n\t\tfor (int j=0 ; j<i ; j++){\n\t\t\tif(a[i]%a[j]==0){\n\t\t\t\t((dp[i]-=dp[j])+=mod)%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0 ; i<tmp ; i++){\n\t\tif(a[i]%2) (ans+=(dp[i]*a[i]))%=mod;\n\t\telse (ans+=(dp[i]*(a[i]/2)))%=mod;\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int M=1e9+7;\nint n,k,a[100005],ans;\nvector<int> v;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tv.push_back(i);\n\t\t\tif (i*i!=n)v.push_back(n/i);\n\t\t}\n\tsort(v.begin(),v.end());\n\tfor (int i=0;i<(int)v.size();i++){\n\t\ta[i]=ksm(k,(v[i]+1)/2);\n\t\tfor (int j=0;j<i;j++)\n\t\t\tif (v[i]%v[j]==0)(a[i]+=M-a[j])%=M;\n\t\tif (v[i]&1)(ans+=v[i]*a[i])%=M;\n\t\telse (ans+=v[i]/2*a[i])%=M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\n#define SZ(x) ((int)x.size())\n\nconst ll base = (ll)1e9+7;\nll n, k, dp[5005];\nvector<ll> d;\n\nll fast_pw(ll x, ll y) {\n\tif (y == 0) return 1;\n\tif (y == 1) return x;\n\tll tmp = fast_pw(x, y / 2ll);\n\ttmp = (tmp * tmp) % base;\n\tif (y % 2ll) tmp = (tmp * x) % base;\n\treturn tmp;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\tfor (ll i = 1; i*i <= n; ++i) if (n % i == 0) {\n\t\td.push_back(i);\n\t\tif (n / i != i) d.push_back(n / i);\n\t}\n\tsort(d.begin(), d.end());\n\tll ans = 0;\n\tfor (int i = 0; i < SZ(d); ++i) {\n\t\tdp[i] = fast_pw(k, d[i] / 2 + d[i] % 2);\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tif (d[i] % d[j] == 0)\n\t\t\t\tdp[i] = (dp[i] - dp[j] + base) % base;\n\t\tif (d[i] % 2 == 0) ans = (ans + dp[i] * (ll)(d[i] / 2) % base) % base;\n\t\telse ans = (ans + dp[i] * (ll)d[i] % base) % base;\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] / (ifat[r] * ifat[n - r]);\n\t\t}\n\t};\n};\nusing umod = modular_space::umod;\nint main(){\n\tmodular_space::mod = 1'000'000'007;\n\tint n; umod k; cin >> n >> k;\n\tvector<int> divs;\n\tfor(int i = 1; i * i <= n; i++){\n\t\tif((n%i) == 0){\n\t\t\tdivs.push_back(i);\n\t\t\tif(i * i != n) divs.push_back(n / i);\n\t\t}\n\t}\n\tsort(divs.begin(), divs.end());\n\tvector<umod> f(divs.size());\n\tint len = divs.size();\n\tumod ans = 0;\n\tfor(int i = 0; i < len; i++){\n\t\tf[i] = k ^ ((divs[i] + 1) / 2);\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(divs[i] % divs[j]);\n\t\t\telse f[i] -= f[j];\n\t\t}\n\t\tif(divs[i]&1) ans += f[i] * divs[i];\n\t\telse ans += f[i] * (divs[i] / 2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define vt vector\n#define ii pair<int,int>\n#define mp make_pair\n#define vi vt<int>\n#define vvi vt<vi>\n#define vii vt<ii>\n#define vvii vt<vii>\n#define For(i,a,b) for(int i = a; i < b; i++)\n#define foR(i,a,b) for(int i = a; i <= b; i++)\n#define roF(i,a,b) for(int i = a - 1; i >= b; i--)\n#define Rof(i,a,b) for(int i = a; i >= b; i--)\n#define NEW 0\n#define FOUNDED 1\n#define CHECKED 2\n#define pb push_back\n#define pob pop_back\n#define mset(a,b) memset(a,b,sizeof(a))\n\ntemplate<class T1, class T2> ostream& operator<< (ostream& the, pair<T1, T2> a){\n\tthe << a.first << \"\\t\" << a.second << \"\\n\";\n\treturn the;\n}\ntemplate<class T1> ostream& operator<< (ostream& the, vt<T1> a){\n\tFor(i,0,a.size()) {\n\t\tthe << a[i] << \"\\n\";\n\t}\n\treturn the;\n}\nconst int mod = 1000000007;\nint pr[100000];\nvi prime;\nvi pr_num;\nvi uoc, num;\nint bp(int a, int b){\n\tif(b == 0) return 1;\n\tint t = bp(a,b/2);\n\tif(b%2==0){\n\t\treturn t*t%mod;\n\t}else{\n\t\treturn t*t%mod*a%mod;\n\t}\n}\n\nvoid tim_uoc(int vt, int ht){\n\tif(vt == pr_num.size()){\n\t\tuoc.pb(ht);\n\t\treturn;\n\t}\n\tfoR(i,0,pr_num[vt]){\n\t\ttim_uoc(vt+1,ht*bp(prime[vt],i));\n\t}\n}\n\nsigned main () {\n\n//\tfreopen(\"INP.txt\",\"r\",stdin);\n//\tfreopen(\"OUT.txt\",\"w\",stdout);\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//  ifstream fin(\"in.txt\");\n//  ofstream fout(\"out.txt\");\n//  ifstream dict(\"dict.txt\");\n// \tbon ga nay\n\tint n, k;\n\tcin >> n >> k;\n\tif(k == 1){\n\t\tcout << 1;\n\t\treturn 0;\n\t}\n\tFor(i,2,100000){\n\t\tif(pr[i] == 0){\n\t\t\tprime.pb(i);\n\t\t\tfor(int j = 2*i; j < 100000; j+=i){\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint t = n, coun;\n\tFor(i,0,prime.size()){\n\t\tcoun = 0;\n\t\twhile(t % prime[i] == 0){\n\t\t\tt/=prime[i];\n\t\t\tcoun++;\n\t\t} \n\t\tpr_num.pb(coun);\n\t}\n\ttim_uoc(0,1);\n\tsort(uoc.begin(),uoc.end());\n\tFor(i,0,uoc.size()){\n\t\tint te = bp(k,(uoc[i]+1)/2);\n\t\tFor(j,0,i){\n\t\t\tif(uoc[i]%uoc[j] == 0){\n\t\t\t\tte -= num[j];\n\t\t\t}\n\t\t}\n\t\tnum.pb(te);\n\t}\n\tint tong = 0;\n\tFor(i,0,num.size()){\n\t\ttong = (tong+(num[i]*((uoc[i]%2 == 0)?(uoc[i]/2):uoc[i]))%mod)%mod;\n\t}\n\tif(tong < 0) tong += mod;\n\tcout << tong;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int magic = 1e5 + 5;\nconst int INF = 1e9 + 7;\n\nint n, k;\nint f[magic];\nint ans;\nvector<int> vec;\n\ninline int qpow(ll x, int y){\n\tll ret = 1;\n\tfor(; y; y >>= 1){\n\t\tif(y & 1) (ret *= x) %= INF;\n\t\t(x *= x) %= INF;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tfor(int i = 1; i * i <= n; ++i) if(!(n % i)){\n\t\tvec.PB(i);\n\t\tif(n / i != i) vec.PB(n / i);\n\t}\n\tsort(vec.begin(), vec.end());\n\tFOR(i, 0, vec.size()){\n\t\tFOR(j, 0, i) if(!(vec[i] % vec[j])) ((f[i] -= f[j]) += INF) %= INF;\n\t\t(f[i] += qpow(k, (vec[i] + 1) / 2)) %= INF;\n\t\tif(vec[i] & 1) (ans += (1ll * vec[i] * f[i]) % INF) %= INF;\n\t\telse (ans += (1ll * vec[i] / 2 * f[i]) % INF) %= INF;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll fish=1e9+7;\nll dp[1000005];\nint N,K;\nvector<ll> v;\nll Pow(ll x,ll y){\n\tx%=fish,y%=fish;\n\tint ans=1,b=x;\n\tfor (int qwq=y;qwq!=0;qwq/=2){\n\t\tif (qwq%2) ans=(ans*b)%fish;\n\t\tb=(b*b)%fish;\n\t}\n\treturn ans;\n}\nvoid Pre(){\n\tv.clear();\n\tfor (ll i=1;i*i<=N;i++){\n\t\tif (N%i==0){\n\t\t\tv.push_back(i);\n\t\t\tif (i*i!=N)\n\t\t\t\tv.push_back(N/i);\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n}\nint main(){\n\t//cout<<Pow(3,3)<<endl;\n\twhile (scanf(\"%d%d\",&N,&K)!=EOF){\n\t\t\tPre();\n\t\tll ans=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor (int i=0;i<v.size();i++){\n\t\t\tdp[i]=Pow(K,(v[i]+1)/2);\n\t\t\tfor (int j=0;j<i;j++){\n\t\t\t\tif (v[i]%v[j]==0)\n\t\t\t\t\tdp[i]=(dp[i]-dp[j]+fish)%fish;\n\t\t\t}\n\t\t\tif (v[i]%2==0)\n\t\t\t\tans=(ans+(dp[i]*v[i]/2)%fish)%fish;\n\t\t\telse ans=(ans+(dp[i]*v[i])%fish)%fish;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, K;\nint modpow(int x, int k) {\n  int a = 1;\n  while (k) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> K;\n  int s = modpow(K, (N+1)/2);\n  int num = N;\n  if (N % 2 == 0) num = N/2;\n  s = (1LL*s*num) % MOD;\n  s += (0LL+MOD-(1LL*(num-1)*K)%MOD) % MOD;\n  s %= MOD;\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(a, b, c) for(int a = b; a <= c; ++a)\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n\nconst int N = 1e5 + 10;\nconst int MOD = 1e9 + 7;\n\nint n, k, divn;\nint divsor[N], dp[N];\n\nvoid calc(int x)    {\n    for(int i = 1; i * i <= x; ++i) {\n        if(x % i == 0)  {\n            divsor[++divn] = i;\n            if(i * i < x) divsor[++divn] = x/i;\n        }\n    }\n    sort(divsor + 1, divsor + divn + 1);\n}\n\nint powe(int x, int y){\n    if(!y) return 1ll;\n    int mid = powe(x, y/2);\n    if(y%2) return mid * mid % MOD * x % MOD;\n    else return mid * mid % MOD;\n}\n\nsigned main()\n{\n    //freopen(\"test.inp\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> k;\n    calc(n);\n\n    int ans = 0ll;\n    FOR(i, 1, divn)  {\n        int cur = divsor[i];\n        dp[i] = powe(k, (cur + 1) / 2);\n\n        for(int j = 1; j < i; ++j)  if(cur % divsor[j] == 0) {\n            dp[i] = (dp[i] - dp[j] + 1ll * MOD * MOD) % MOD;\n        }\n        if(cur % 2) ans = (ans + 1ll * cur * dp[i]) % MOD;\n        else ans = (ans + 1ll * cur / 2 * dp[i]) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int mo = 1000000007;\nconst int maxn = 100010;\nusing namespace std;\nint n, k, a[maxn], f[maxn];\nint mul(int a, int b) {\n\tll ans = 1, w = a % mo;\n\tfor ( ; b; b /= 2, w = w * w % mo)\n\t\tif (b & 1) ans = ans * w % mo;\n\treturn (int) ans; \n}\nint main() {\n\tscanf(\"%d%d\", &n, &k); a[0] = 0;\n\tfor (int i = 1; i * i <= n; ++ i) if (n % i == 0)\n\t\ta[++ a[0]] = i, a[++ a[0]] = n / i;\n\tif (a[a[0]] == a[a[0] - 1]) -- a[0];\n\tsort(a + 1, a + a[0] + 1);\n\trep(i, 1, a[0]) f[i] = mul(k, (a[i] + 1) / 2);\n\trep(i, 1, a[0]) rep(j, 1, i - 1) if (a[i] % a[j] == 0)\n\t\tf[i] = (f[i] - f[j] + mo) % mo;\n\tint ans = 0, INV = mul(2, mo - 2);\n\trep(i, 1, a[0]) if (a[i] % 2 == 0) f[i] = (ll) f[i] * INV % mo;\n\trep(i, 1, a[0]) ans = (ans + (ll) f[i] * a[i] % mo) % mo;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=nn/i) v.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tif(n==3){\n\t\tprintf(\"%d\\n\",(1ll*m*(m-1)%MOD*3+1ll*m)%MOD);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tadd(ans,1ll*d[i]*x%MOD);\n\t}\n\tif(n%2==1) ans=2ll*ans*m%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 1000000007;\n\nint n, k, ans;\nvector<int> fac, dp;\n\ninline int pwr(int a, int b) {\n    int c = 1;\n    while (b) {\n        if (b & 1) c = (ll)c * a % MOD;\n        b >>= 1; a = (ll)a * a % MOD;\n    }\n    return c;\n}\ninline void add(int &x, int a) {\n    x = (x + a >= MOD) ? x + a - MOD : x + a;\n}\ninline void sub(int &x, int a) {\n    x = (x < a) ? x - a + MOD : x - a;\n}\n\nint main(void) {\n    cin >> n >> k;\n    int m = sqrt(n);\n    for (int i = 1; i <= m; i++)\n        if (n % i == 0) {\n            fac.push_back(i);\n            fac.push_back(n / i);\n        }\n    sort(fac.begin(), fac.end());\n    fac.erase(unique(fac.begin(), fac.end()), fac.end());\n    dp.resize(fac.size());\n    for (int i = 0; i < fac.size(); i++) {\n        dp[i] = pwr(k, (fac[i] + 1) / 2);\n        for (int j = 0; j < i; j++)\n            if (fac[i] % fac[j] == 0)\n                sub(dp[i], dp[j]);\n        if (fac[i] & 1) add(ans, (ll)dp[i] * fac[i] % MOD);\n        else add(ans, (ll)dp[i] * fac[i] / 2 % MOD);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nmap<int, ll> M;\nll n, k;\n\nll pow(ll a, ll b) {\n    ll r = 1;\n    while(b > 0) {\n        if(b % 2 == 1) r = (r * a) % MOD;\n        a = (a * a) % MOD;\n        b /= 2;\n    }\n    return r;\n}\n\nint main() {\n    cin >> n >> k;\n    vector<int> dzielniki;\n    for(int d = 1; d * d <= n; d++) {\n        if(n % d == 0) {\n            dzielniki.push_back(d);\n        }\n        if(n / d != d) {\n            dzielniki.push_back(n / d);\n        }\n    }\n    sort(dzielniki.begin(), dzielniki.end());\n    for(int d : dzielniki) {\n        M[d] = pow(k, (d + 1) / 2);\n//         cout << \"M[\" << d << \"] = \" << M[d] << endl;\n        for(int i = 0; i < dzielniki.size(); i++) {\n            if(dzielniki[i] >= d) break;\n            if(d % dzielniki[i] == 0) M[d] = (M[d] - M[dzielniki[i]] + MOD) % MOD;\n        }\n//         cout << \"M[\" << d << \"] = \" << M[d] << endl;\n    }\n    ll wynik = 0;\n    for(int d : dzielniki) {\n        ll curr = 0;\n        if(d % 2 == 1) {\n            curr = (M[d] * d) % MOD;\n        } else {\n            curr = (M[d] * (d / 2LL)) % MOD;\n        }\n        wynik = (wynik + curr) % MOD;\n    }\n    cout << wynik;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=500+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nll b[N],f[N],n,m,k;\nint main(){\n\tread(n,k);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\tb[++m]=i;\n\t\tif(i!=n/i)b[++m]=n/i;\n\t}sort(b+1,b+1+m);ll ans=0;\n\trep(i,1,m)f[i]=qpow(k,(b[i]+1)/2);\n\trep(i,1,m)rep(j,i+1,m)if(b[j]%b[i]==0)f[j]=(f[j]-f[i]+mod)%mod;\n\trep(i,1,m)if(b[i]&1)ans=(ans+f[i]*b[i])%mod;\n\t\telse ans=(ans+f[i]*b[i]/2)%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\n#define INF 1000000000LL\n#define EPS 1e-12\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nusing i64 = std::int_fast64_t;\nconst static i64 mod = 1000000007;\nstruct mint {\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tvector<T> seq;\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tseq.resize(2 * n - 1);\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] rsq(n, [] (ll a, ll b) { return a + b; }, 0)\n// [Range Max Query] rMq(n, [] (ll a, ll b) { return max(a, b); }, -1e18)\n// [Range Min Query] rmq(n, [] (ll a, ll b) { return min(a, b); }, 1e18)\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nmint _pow(mint a, long long n) {\n\tif(n == 0) return 1;\n\tmint res = 1;\n\tmint buf = a;\n\twhile(n > 0) {\n\t\tif(n % 2) res *= buf;\n\t\tbuf *= buf;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nusing mi = mint;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, k;\n\tcin >> n >> k;\n\tvector<ll> div;\n\tvector<mi> cnt;\n\tif(n % 2 == 0) {\n\t\tll m = n / 2;\n\t\tfor(int i = 1; i * i <= m; i++) {\n\t\t\tif(m % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != m) div.pb(m / i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tassert(false);\n\t\tfor(int i = 1; i * i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != n) div.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(div));\n\tcnt.assign((int)div.size(), 0);\n\tREP(i, div.size()) {\n\t\tcnt[i] += _pow(k, div[i]);\n\t\tFOR(j, i + 1, div.size()) {\n\t\t\tif(div[j] % div[i] == 0) cnt[j] -= cnt[i];\n\t\t}\n\t}\n\tmi ans = 0;\n\tREP(i, div.size()) {\n\t\tans += cnt[i] * n / (n / div[i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nlong long pw(long long a,long long b){\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint y[2100];\nlong long ks[2100];\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tlong long ret=0;\n\tint sz=0;\n\tfor(int i=1;i*i<=a;i++){\n\t\tif(a%i==0){\n\t\t\ty[sz++]=i;\n\t\t\tif(i*i!=a)y[sz++]=a/i;\n\t\t}\n\t}\n\tstd::sort(y,y+sz);\n\tfor(int i=0;i<sz;i++){\n\t\tlong long cnt=pw(b,(y[i]+1)/2);\n\t\tfor(int j=0;j<i;j++)if(y[i]%y[j]==0)cnt=(cnt+mod-ks[j])%mod;\n\t\tks[i]=cnt;\n\t\t//printf(\"%d: %lld\\n\",y[i],cnt);\n\t\tif(y[i]%2)ret=(ret+cnt*y[i])%mod;\n\t\telse ret=(ret+cnt*y[i]/2)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define lowbit(i) i&-i\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\tull ans=0; For(i,0,5)ans=ans<<15^rand(); return ans;\n}\nconst int mod=1000000007;\nll mul(ll x,ll y,ll mod){\n\treturn x*y%mod;\n}\nll ksm(ll a,ll b,ll mod){\n\tll ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=mul(ans,a,mod);\n\t\ta=mul(a,a,mod);\n\t}\n\treturn ans;\n}\nbool MR(ll n){\n\tconst int pr[9]={2,3,5,7,11,13,17,19,23};\n\tif(n<=1)return 0;\n\tint cnt=0;\n\tll d=n-1; while(!(d&1)){cnt++; d>>=1;}\n\tFor(i,0,8){\n\t\tif(n==pr[i])return 1;\n\t\tll x=ksm(pr[i],d,n),p=x;\n\t\tFor(i,1,cnt){\n\t\t\tx=mul(x,x,n);\n\t\t\tif(x==1&&p!=1&&p!=n-1)return 0;\n\t\t\tp=x;\n\t\t}\n\t\tif(x!=1)return 0;\n\t}\n\treturn 1;\n}\nll f(ll x,ll c,ll n){return (mul(x,x,n)+c)%n;}\nll get(ll n){\n\tconst int B=500;\n\tll c=rand(),x=rand()%n,y=f(x,c,n),p=1;\n    while((x!=y)&&((p==1))){\n    \tll xx=x,yy=y,cj=1;\n    \tfor(int i=0;i<=B&&x!=y&&cj;i++){\n\t\t\tcj=mul(cj,abs(x-y),n);\n\t\t\tx=f(x,c,n); y=f(f(y,c,n),c,n);\n    \t}\n    \tll t=__gcd(cj,n);\n    \tif(t==1)continue;\n    \telse if(cj)return t;\n    \telse {\n \t\t\tx=xx; y=yy;\n \t\t\tfor(int i=0;i<=B&&x!=y&&p==1;i++){\n \t\t\t\tp=__gcd(abs(x-y),n);\n\t\t\t\tx=f(x,c,n); y=f(f(y,c,n),c,n);\n \t\t\t} \n    \t}\n    }\n    return p;\n}\nmap<ll,int> M;\nvoid rho(ll n){\n\tif(n==1)return;\n\tif(MR(n)){M[n]++; return;}\n\tll t=get(n);\n\twhile(t==1&&t==n)t=get(n);\n\trho(t); rho(n/t);\n}\nint ppp,jz;\nll ans,k,pe[100],pp[100];\nll h(ll x){\n\treturn (x&1)?x:x/2;\n}\nll ycl[4][32000];\nll power(ll b){\n\tll ans=1;\n\tFor(i,0,3){\n\t\tans=ans*ycl[i][b%jz]%mod; b/=jz;\n\t}\n\treturn ans;\n}\nll g(ll x){\n\treturn power((x+1)>>1);\n}\nvoid dfs(int p,ll dq,ll s){\n\t//cout<<p<<\" \"<<dq<<\" \"<<s<<endl;\n\tif(p>ppp){\n\t\t//cout<<p<<\" \"<<dq<<\" \"<<s<<endl;\n\t\tans=(ans+h(dq)%mod*g(dq)%mod*(s%mod+mod))%mod; return;\n\t}\n\tif(pp[p]!=2)dfs(p+1,dq,s*(1-pp[p]));\n\tFor(i,1,pe[p]){\n\t\t//cerr<<(i==pe[p])<<\" \"<<(1-pp[p])<<endl;\n\t\tdq*=pp[p]; dfs(p+1,dq,i==pe[p]?s:s*(1-pp[p]));\n\t}\n}\nint main(){\n\t\tll n=read(); k=read();\n\t\tjz=pow(n,0.25)+3;\n\t\tFor(i,0,3){\n\t\t\tll s;\n\t\t\tif(i)s=ycl[i-1][jz]; else s=k%mod;\n\t\t\tFor(j,ycl[i][0]=1,jz)ycl[i][j]=ycl[i][j-1]*s%mod;\n\t\t}\n\t\tM.clear(); rho(n); ans=ppp=0;\n\t\tfor(auto i:M){pp[++ppp]=i.fi; pe[ppp]=i.se;}\n\t\tdfs(1,1,1);\n\t\tcout<<ans<<endl;\n}\n/*\nf(i)=\\sum g(j)\\mu(i/j)\n1\n9311702400 7367823578 1015387267\n3 2 1000000005\n3 3 1000000007\n4 2 1000000009\n4 3 1000000011\n4 4 1000000013\n5 5 1000000015\n7 7 1000000017\n9 9 1000000019\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 10100\n#define mo 1000000007\n#define ll long long\nusing namespace std;\nint n,m,k,f[N],ans=0,a[N];\nint mi(ll a,ll b)\n{\n\tll c=1;\n\tfor(;b;b/=2,a=a*a%mo) if(b%2==1) c=c*a%mo;\n\treturn c;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\tif(n%i==0)\n\t{\n\t\ta[++m]=i;\n\t\tif(i!=n/i) a[++m]=n/i;\n\t}\n\tsort(a+1,a+m+1);\n\tfo(i,1,m)\n\t{\n\t\tf[i]=mi(k,(a[i]+1)/2);\n\t\tfo(j,1,i-1)\n\t\t{\n\t\t\tif(a[i]%a[j]==0) f[i]=(f[i]-f[j]+mo)%mo;\n\t\t}\n\t\tans=(ans+(ll)f[i]*(a[i]%2==1?(ll)a[i]:(ll)(a[i]+1)/2)%mo)%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\nvector<ll> div(ll N){\n    vector<ll> ret;\n    for(ll i = 1; i * i <= N; i++){\n        if(N % i == 0){\n            ret.pb(i);\n            if(i != N / i) ret.pb(N / i);\n        }\n    }\n    sort(all(ret));\n    return ret;\n}\n\nll pow_mod(ll a, ll b, ll m){\n    ll ret = 1;\n    while (b > 0) {\n        if (b & 1) {\n            ret = ret * a % m;\n        }\n        a = a * a % m;\n        b >>= 1;\n    }\n    return ret;\n}\n\nll inv_mod(ll a, ll m){\n    return pow_mod(a, m - 2, m);\n}\n\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    ll inv2 = inv_mod(2, mod);\n    \n    ll N, K;\n    cin >> N >> K;\n    map<ll, int> M;\n    auto D = div(N);\n    rep(i, D.size()){\n        M[D[i]] = i;\n    }\n    vector<ll> E(D.size());\n    rep(i, D.size()){\n        ll A = pow_mod(K, (D[i] + 1) / 2, mod);\n        auto DA = div(D[i]);\n        rep(j, DA.size() - 1){\n            (A -= E[M[DA[j]]]) %= mod;\n        }\n        E[i] = (A + mod) % mod;\n    }\n    ll ret = 0;\n    rep(i, D.size()){\n        ll B;\n        if(D[i] % 2 == 0) B = E[i] * (D[i] / 2) % mod;\n        else B = E[i] * D[i] % mod;\n        (ret += B) %= mod;\n    }\n    \n    output(ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=200005,INF=1<<30;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,K;cin>>N>>K;\n    map<ll,ll> MA;\n    \n    vector<ll> d;\n    for(ll i=1;i*i<=N;i++){\n        if(N%i) continue;\n        d.push_back(i);\n        if(i*i!=N) d.push_back(N/i);\n    }\n    \n    sort(all(d));\n    \n    for(ll a:d){\n        ll sum=rui(K,(a+1)/2);\n        for(ll b:d){\n            if(b>=a) break;\n            if(a%b) continue;\n            \n            sum-=MA[b];\n            sum+=mod;\n        }\n        sum%=mod;\n        MA[a]=sum;\n    }\n    \n    ll ans=0;\n    \n    for(auto a:MA){\n        if(a.fi%2==0) ans+=a.fi*a.se/2;\n        else ans+=a.fi*a.se;\n        ans%=mod;\n        //cout<<a.fi<<\" \"<<a.se<<endl;\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long int\n\nconst int mod=1e9+7;\n\nll p(ll a,ll b){\n\ta%=mod;\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)\tres=res*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nvector<ll> d,f;\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\td.emplace_back(i);\n\t\t\tif(i*i!=n)\n\t\t\t\td.emplace_back(n/i);\n\t\t}\n\t}\n\tsort(d.begin(),d.end());\n\tll ans=0;\n\tfor(int i=0;i<d.size();i++){\n\t\tf.emplace_back(p(k,(d[i]+1)/2));\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(d[i]%d[j]==0)\n\t\t\t\tf[i]=f[i]-f[j]+mod;\n\t\tf[i]%=mod;\n\t\tif(d[i]%2==0)\n\t\t\tans=(ans+d[i]*f[i]%mod*p(2,mod-2))%mod;\n\t\telse\n\t\t\tans=(ans+d[i]*f[i])%mod;\n\t}\n\tcout<<ans<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nlong long modpow(long long a, long long n){\n    if(n==0) return 1;\n    long long re=modpow((a*a)%MOD,n/2)%MOD;\n    if(n%2==1) re= (re*a)%MOD;\n    return re;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    LL n,k;\n    cin >> n >> k;\n    if(n%2==0){\n        cout << 0 <<endl;\n    }else{\n        cout << (n*modpow(k,(n+1)/2)-(n-1)*k+MOD)%MOD<<endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (ll i=(ll)from; i<(ll)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nvector<bool> isp;\n\nvoid sieve(int x=pow(10,6)+10) {\n  isp.resize(x,true); \n  isp[0] = false;\n  isp[1] = false;\n  for (int i=2; pow(i,2)<=x; i++) {\n    if (isp[i]) for(int j=2; i*j<=x; j++) isp[i*j] = false;\n  }\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nll pnk(ll n, ll k) {\n  ll pn = n, now = 0, result = 1;\n  while (k>=1ll<<now) {\n    if (k&1ll<<now) result = result * pn % MOD;\n    pn = pn * pn % MOD;\n    now++;\n  }\n  return result;\n}\n\nint main() {\n  ll N, K; cin >> N >> K;\n\n  // map<string, ll> m;\n  // rep(i,1<<N/2) {\n  //   string S; rep(j,N/2) S += i&1<<j ? '1' : '0';\n  //   rep(j,N/2) S += S[N/2-1-j];\n  //   rep(j,N) {\n  //     m[S]++;\n  //     S = S.substr(1) + S[0];\n  //   }\n  // }\n  // cout << m.size() << endl;\n\n  sieve();\n  vector<ll> yaku;\n  for (ll i=1; i*i<=N; i++) {\n    if (N%i==0) {\n      yaku.push_back(i);\n      if (i*i!=N) yaku.push_back(N/i);\n    }\n  }\n  sort(all(yaku));\n  // debug(all(yaku));\n\n  ll l = yaku.size();\n  vector<ll> count(l,0);\n\n  rep(i,l) {\n    count[i] = pnk(K,(yaku[i]+1)/2);\n    rep(j,i) if (yaku[i]%yaku[j]==0) count[i] = (count[i]-count[j]+MOD) % MOD;\n  }\n  // debug(all(count));\n\n  ll result = 0; rep(i,l) result = (result+(yaku[i]%2 ? yaku[i] : yaku[i]/2)*count[i]) % MOD;\n  cout << result << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= MOD;\n\tif(k%2 == 1){\n\t\tret *= x;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nvector<ll> divisors(ll n){\n\tvector<ll> ret;\n\tret.push_back(1);\n\tfor(int i = 2 ; n > 1 ; i ++){\n\t\tif(i*i > n)i = n;\n\t\tif(n%i == 0){\n\t\t\tint cnt = 0;\n\t\t\twhile(n%i == 0){\n\t\t\t\tn /= i;\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t\tint m = ret.size();\n\t\t\tll x = 1;\n\t\t\tfor(int j = 0 ; j < cnt ; j ++){\n\t\t\t\tx *= i;\n\t\t\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\t\t\tret.push_back(ret[i]*x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(),ret.end());\n\treturn ret;\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\t\n\tvector<ll> div = divisors(n);\n\tll ret = 0;\n\tll cnt[1400];\n\tfor(int i = div.size()-1 ; i >= 0 ; i --){\n\t\tll d = div[i];\n\t\tif(d&1)cnt[i] = d;\n\t\telse cnt[i] = d/2;\n\t\tfor(int j = i+1 ; j < div.size() ; j ++){\n\t\t\tif(div[j]%d == 0)cnt[i] -= cnt[j];\n\t\t}\n\t\tll sum = cnt[i];\n\t\tsum *= modpow(k,(d+1)/2);\n\t\tret += sum;\n\t\tret %= MOD;\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tassert(false);\n\t\tcout << modpow(k, (n + 1) / 2) << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x) cout << #x << \" = \" << (x) << endl;\n#define all(v) (v).begin(), (v).end()\n#define P pair<int, int>\n#define pb push_back\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define V vector<int>\nint N, K;\nV d;\nint n[10000];\nint p[10000];\n\nint pwr(int x, int l)\n{\n    int a = 1;\n    for (int i = 1; i < 50; i++) {\n        if ((l & (1ll << (i - 1)))) {\n            a *= p[i];\n            a %= MOD;\n        }\n    }\n    return a;\n}\nvoid solve()\n{\n    p[0] = 1;\n    p[1] = K;\n    for (int i = 2; i < 50; i++) {\n        p[i] = (p[i - 1] * p[i - 1]) % MOD;\n    }\n    for (int i = 1; i * i <= N; i++) {\n        if (N % i == 0) {\n            d.pb(i);\n            if (i * i != N) {\n                d.pb(N / i);\n            }\n        }\n    }\n    sort(all(d));\n    for (int i = 0; i < (int)d.size(); i++) {\n        n[i] = pwr(K, (d[i] + 1) / 2);\n        for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) {\n                n[i] -= n[j];\n                n[i] %= MOD;\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < (int)d.size(); i++) {\n        if (d[i] % 2) {\n            ans += n[i] * d[i];\n            ans %= MOD;\n        } else {\n            ans += n[i] * (d[i] / 2);\n            ans %= MOD;\n        }\n    }\n    ans = (ans + MOD) % MOD;\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    cin >> N >> K;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define max(a,b) ((a)>(b)?(a):(b))\n#define reg register\ntypedef long long ll;\nint n,k,cnt,fac[2005];\nll f[2005],ans;\nconst int mod=1e9+7;\ninline ll qpow(ll a,ll b){\n\treg ll res=1;\n\twhile(b){\n\t\tif(b&1)res=res*a%mod;\n\t\ta=a*a%mod;b>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(reg int i=1;i<=sqrt(n);i++)\n\t\tif(!(n%i)){\n\t\t\tfac[++cnt]=i;\n\t\t\tif(i!=(n/i))fac[++cnt]=n/i;\n\t\t}\n\tstd::sort(fac+1,fac+1+cnt);\n\tfor(reg int i=1;i<=cnt;i++){\n\t\tf[i]=qpow(k,(fac[i]+1)/2);\n\t\tfor(reg int j=1;j<i;j++)\n\t\t\tif(!(fac[i]%fac[j]))\n\t\t\t\tf[i]=(f[i]-f[j]+mod)%mod;\n\t\tif(fac[i]&1)ans=(ans+f[i]*fac[i]%mod)%mod;\n\t\telse ans=(ans+(f[i]*fac[i]>>1)%mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst ll MOD = ll(1e9 + 7);\nconst int K = 2333;\n\nint n, k;\nll f[K];\n\nll pw(ll a, ll b) {\n    ll r = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) {\n            r = r * a % MOD;\n        }\n        a = a * a % MOD;\n    }\n    return r;\n}\n\nint main() {\n    cin >> n >> k;\n\n    vector<int> divs;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            divs.push_back(i);\n            if (i * i < n) {\n                divs.push_back(n / i);\n            }\n        }\n    }\n    sort(divs.begin(), divs.end());\n    assert(int(divs.size()) < K);\n\n    ll ans = 0;\n    for (int i = 0; i < int(divs.size()); i++) {\n        int d = divs[i];\n        f[i] = pw(k, (d + 1) / 2);\n        for (int j = 0; j < i; j++) {\n            if (d % divs[j] == 0) {\n                f[i] = (f[i] - f[j] + MOD) % MOD;\n            }\n        }\n\n        ll coef = (d % 2 == 0 ? d / 2 : d);\n        ans = (ans + coef * f[i]) % MOD;\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nmap<deque<int>, int> m;\n\nvoid rec(deque<int> v, int pos, long long n, long long k){\n  if(pos == (n+1)/2){\n    for(int i=0; i<n; i++){\n      m[v]++;\n      v.push_back( v.front() );\n      v.pop_front();\n    }\n    return;\n  }\n\n  for(int i=1; i<=k; i++){\n    v[pos] = v[n-1-pos] = i;\n    rec(v, pos+1, n,k);\n  }\n}\n\nint test(long long n, long long k){\n  deque<int> v(n);\n  rec(v, 0, n,k);\n\n  for(auto p : m ){\n    vector<int> v(p.first.begin(), p.first.end());\n    println(join(v, \" \"), \" : \", p.second);\n  }\n  return m.size();\n}\n\nvector<long long> divisors(long long N){\n  if(N==1) return {1LL};\n  \n  vector<long long> ret;\n  ret.push_back(1);\n  ret.push_back(N);\n\n  for(long long i=2; i*i<=N; i++){\n    if(N%i==0){\n      ret.push_back(i);\n      if(i*i != N) ret.push_back(N/i);\n    }\n  }\n\n  sort(ret.begin(), ret.end());\n  return ret;\n}\nint main(){\n  long long n,k;\n  cin >> n,k;\n\n  long long nn = n;\n  long long ans = 0;\n  auto d = divisors(nn);\n\n  vector<long long> dp(d.size(), -1);\n  for(long long i : range(d.size())){\n    long long x = d[i];\n    dp[i] = my_pow_mod(k, (x+1)/2, mod);\n    for(long long j : range(d.size())){\n      long long y = d[j];\n      if(y>=x) break;\n      if(x%y == 0){\n        dp[i] = (dp[i] - dp[j] + mod) % mod;\n      }\n    }\n    (ans += dp[i] * (x%2?x:x/2) % mod) %= mod;\n  }\n  //println(test(nn,k));\n  println(ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 1000000007;\n\nint n, k, ans;\nvector<int> fac, dp;\n\ninline int pwr(int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = (ll)c * a % MOD;\n\t\tb >>= 1; a = (ll)a * a % MOD;\n\t}\n\treturn c;\n}\ninline void add(int &x, int a) {\n\tx = (x + a >= MOD) ? x + a - MOD : x + a;\n}\ninline void sub(int &x, int a) {\n\tx = (x < a) ? x - a + MOD : x - a;\n}\n\nint main(void) {\n\tcin >> n >> k;\n\tint m = sqrt(n);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (n % i == 0) {\n\t\t\tfac.push_back(i);\n\t\t\tfac.push_back(n / i);\n\t\t}\n\tsort(fac.begin(), fac.end());\n\tfac.erase(unique(fac.begin(), fac.end()), fac.end());\n\tdp.resize(fac.size());\n\tfor (int i = 0; i < fac.size(); i++) {\n\t\tdp[i] = pwr(k, (fac[i] + 1) / 2);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (fac[i] % fac[j] == 0)\n\t\t\t\tsub(dp[i], dp[j]);\n\t\tif (fac[i] & 1) add(ans, (ll)dp[i] * fac[i] % MOD);\n\t\telse add(ans, (ll)dp[i] * fac[i] / 2 % MOD);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll n,m,k,i,j,ans,f[100010],a[100010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(i=1;i*i<=n;i++)if(n%i==0){\n\t\ta[++m]=i;\n\t\tif(n/i!=i)a[++m]=n/i;\n\t}\n\tsort(a+1,a+m+1);\n\tfor(i=1;i<=m;i++){\n\t\tf[i]=ksm(k,(a[i]+1)/2);\n\t\tfor(j=1;j<i;j++)if(a[i]%a[j]==0)f[i]=(f[i]-f[j]+p)%p;\n\t\tif(a[i]%2)ans=(ans+f[i]*a[i])%p;\n\t\t else ans=(ans+a[i]*ksm(2,p-2)%p*f[i])%p;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nconst int mod=1000000007,N=1500;\nint n,k,ans,q[N],tot,M[N];\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\ninline ll chu(int x){\n\treturn (x&1)?1:((mod+1)>>1);\n}\nint solve(int x){\n\tif(M[x]!=-1)return M[x];\n\tint ans=ksm(k,(q[x]+1)/2);\n\tfor(int i=1;i<x;i++)if(q[x]%q[i]==0)ans=(ans-solve(i))%mod;\n\tans=(ans+mod)%mod;\n\treturn M[x]=ans;\n}\nint main(){\n\tn=read(); k=read(); memset(M,-1,sizeof(M));\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\tq[++tot]=i; if(i*i!=n)q[++tot]=n/i; \n\t}\n\tsort(&q[1],&q[tot+1]);\n\tfor(int i=1;i<=tot;i++){\n\t\tM[i]=ksm(k,(q[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)if(q[i]%q[j]==0)M[i]=(M[i]-M[j])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++)ans=(ans+solve(i)*chu(q[i])%mod*q[i])%mod;\n\tcout<<(ans+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int mo=1e9+7;\nconst int inv2=5e8+4;\nconst int maxn=100003;\n\nint qpow(int x,int p){\n\tint rt=1;\n\twhile(p){\n\t\tif(p&1)rt=(1ll*rt*x)%mo;\n\t\tx=(1ll*x*x)%mo;\n\t\tp>>=1;\n\t}\n\treturn rt;\n}\nint fac[maxn],pw[maxn],sz,n,k,res;\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tvector<int> v;\n\tfor(int i=1;1ll*i*i<=n;++i){\n\t\tif(n%i==0){\n\t\t\tfac[++sz]=i;\n\t\t\tpw[sz]=qpow(k,i/2+i%2);\n\t\t\tif(1ll*i*i!=n)v.push_back(n/i);\n\t\t}\n\t}\n\tfor(int i=v.size()-1;i>=0;--i){\n\t\tint j=v[i];\n\t\tfac[++sz]=j;\n\t\tpw[sz]=qpow(k,j/2+j%2);\n\t}\n//\tfor(int i=1;i<=sz;++i)printf(\"%d %d ^\\n\",fac[i],pw[i]);\n\tfor(int i=1;i<=sz;++i){\n\t\tfor(int j=1;fac[j]<fac[i];++j)\n\t\t\tif(fac[i]%fac[j]==0)\n\t\t\t\t(pw[i]-=pw[j])%=mo;\n\t\tint x=1ll*pw[i]*fac[i]%mo;\n\t\tif(fac[i]%2==0)x=1ll*inv2*x%mo;\n\t\tres=(res+x)%mo;\n//\t\tprintf(\"%d %d !\\n\",fac[i],pw[i]);\n\t}\n\tprintf(\"%d\\n\",(res+mo)%mo);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nll N,K;\nvector<ll> di;\nmap<ll,  int> moebius(ll n){\n    map<ll,int> res;\n    vector<ll> primes;\n    for (ll i=1; i*i<=n; i++){\n        if (n%i==0){\n            di.push_back(i);\n            if (i!=n/i) di.push_back(n/i);\n        }\n    }\n    for(ll i=2; i*i<=n; i++){\n        if(n%i==0){\n            primes.pb(i);\n            while(n%i==0) n/=i;\n        }\n    }\n    if(n!=1) primes.pb(n);\n    int m=sz(primes);\n    rep(i,0,1<<m){\n        ll mu=1, d=1;\n        rep(j,0,m){\n            if(i>>j&1){\n                mu*=-1;\n                d*=primes[j];\n            }\n        }\n        res[d]=mu;\n    }\n    return res;\n}\nll mod_pow(ll x, ll n, ll mod=MOD){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>N>>K;\n    ll ans=0;\n    map<ll, int> m=moebius(N);\n    for(ll d : di){\n        ll res=0;\n        for(auto j=m.begin(); j!=m.end(); j++){\n            if(d%(j->fr)==0){\n                res+=m[d/j->fr]*mod_pow(K, (j->fr+1)/2)%MOD;\n                res%=MOD;\n            }\n        }\n        res*=(d%2?d:d/2);\n        res%=MOD;\n        ans+=res;\n        ans%=MOD;\n    }\n    cout <<(ans+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll a[2005], dp[2005];\nll mod = 1e9 + 7;\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nint main(){\n\tll n, k; cin >> n >> k;\n\tll cur = 0;\n\tfor (ll i = 1; i <= sqrt(n); i++){\n\t\tif (n % i == 0){\n\t\t\ta[cur] = i; cur++;\n\t\t\tif (i * i != n){\n\t\t\t\ta[cur] = n / i; cur++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a, a + cur);\n\tfor (ll i = 0; i < cur; i++){\n\t\tdp[i] = binpow(k, (a[i] + 1) / 2);\n\t\tfor (ll j = 0; j < i; j++){\n\t\t\tif (a[i] % a[j] == 0){\n\t\t\t\t((dp[i] -= dp[j]) += mod) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (ll i = 0; i < cur; i++){\n\t\tif (a[i] % 2) (ans += (dp[i] * a[i])) %= mod;\n\t\telse (ans += (dp[i] * (a[i] / 2))) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 1000000007;\nvector<ll> inv, FactorialInv, Factorial;\nll beki(ll a, ll b){\n    ll ret = 1 % mod;\n    a %= mod;\n    while(b) {\n        if(b & 1LL) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return ret;\n}\nvoid init_combination(ll MAX){\n    Factorial.resize(MAX + 1);\n    FactorialInv.resize(MAX + 1);\n    inv.resize(MAX + 1);\n    Factorial[0] = 1;\n    inv[0] = 1;\n    for(int i = 1; i <= MAX; i++){\n        Factorial[i] = Factorial[i - 1] * i % mod;\n    }\n    FactorialInv[MAX] = beki(Factorial[MAX], mod - 2);\n    for(ll i = MAX - 1; i >= 0; i--) {\n        FactorialInv[i] = FactorialInv[i+1] * (i+1) % mod;\n    }\n    for(int i = 1; i <= MAX; i++) {\n        inv[i] = FactorialInv[i] * Factorial[i-1] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    if(b < 0) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nll N, K;\nvector<ll> Div;\nvector<vector<ll>> mp;\nvector<ll> ans;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K;\n    for(ll i = 1; i * i <= N; i++) {\n        if(N % i != 0) continue;\n        Div.push_back(i);\n        if(i * i == N) continue;\n        ll k = N / i;\n        Div.push_back(k);\n    }\n    sort(Div.begin(), Div.end());\n    mp.resize(Div.size());\n    ans.resize(Div.size());\n    for(int i = 0; i < Div.size(); i++) {\n        //cerr << Div[i] << \" \";\n        for(int j = i + 1; j < Div.size(); j++) {\n            if(Div[j] % Div[i] == 0) mp[j].push_back(i);\n        }\n    }\n    //cerr << endl;\n    for(ll i = 0; i < Div.size(); i++) {\n        ll num = (Div[i] + 1) / 2;\n        ans[i] = beki(K, num);\n        for(auto j : mp[i]) {\n            //cerr << i << \" \" << j << endl;\n            ans[i] += mod - ans[j];\n            ans[i] %= mod;\n        }\n    }\n    ll sum = 0;\n    for(int i = 0; i < Div.size(); i++) {\n        //cerr << Div[i] << \" \" << ans[i] << endl;\n        if(Div[i] & 1) sum += ans[i] * Div[i];\n        else sum += ans[i] * Div[i] / 2;\n        sum %= mod;\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007;\nll mod_pow(ll N, ll K) {\n    ll ret = 1;\n    for(; K>0; K>>=1) {\n        if(K & 1) (ret *= N) %= MOD;\n        (N *= N) %= MOD;\n    }\n    return ret;\n}\n\nusing ll = long long int;\nint main() {\n    ll N, K, ans = 0, inv2 = mod_pow(2, MOD-2); cin >> N >> K;\n    vector<ll> div, num;\n    for(int k=1; k*k<=N; k++) {\n        if(N % k == 0) {\n            div.push_back(k);\n            if(N / k != k) div.push_back(N / k);\n        }\n    }\n    sort(div.begin(), div.end());\n    int M = div.size(); num.resize(M);\n    for(int i=0; i<M; i++) {\n        num[i] = mod_pow(K, (div[i] + 1) / 2);\n        for(int j=0; j<i; j++) if(div[i] % div[j] == 0) {\n            num[i] = (num[i] - num[j] + MOD) % MOD;\n        }\n        if(div[i] % 2 == 1) (ans += div[i] * num[i]) %= MOD;\n        else (ans += div[i] * num[i] % MOD * inv2) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar('0'+aa%10);\n\treturn;\n}\nconst long long mod=1e9+7;\nlong long n,K,cnt,ans;\nlong long shu[100005],f[100005];\nlong long ksm(long long aa,long long bb)\n{\n\tlong long now=1;\n\twhile(bb)\n\t{\n\t\tif(bb&1) now=now*aa%mod;\n\t\taa=aa*aa%mod;bb>>=1;\n\t}\n\treturn now;\n}\nvoid solve(long long aa)\n{\n\tif(f[aa]) return;\n\tf[aa]=ksm(K,(shu[aa]+1)/2);\n\tfor(long long i=1;i<aa;++i)\n\tif(shu[aa]%shu[i]==0) \n\t{\n\t\tsolve(i);\n\t\tf[aa]=(f[aa]-f[i]+mod)%mod;\n\t}\n\tif(shu[aa]%2==0) (ans+=(shu[aa]/2)*f[aa]%mod)%=mod;\n\telse (ans+=shu[aa]*f[aa]%mod)%=mod;\n\treturn;\n}\nint main()\n{\n\tn=read(),K=read();\n\tif(n==1) {write(K);return 0;}\n\tfor(long long i=1;i*i<=n;++i) if(n%i==0)\n\t{\n\t\tshu[++cnt]=i;\n\t\tif(i*i!=n) shu[++cnt]=n/i;\n\t}\n\tsort(shu+1,shu+cnt+1);\n\tsolve(cnt);\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tLL i = 0;\n\t\twhile(i < pn && count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i]++;\n\t}\n\t\n\tfor(auto && e : divisor) {\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint ans, nr, N, K, dp[10009], dv[10009], mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint substract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\n\nint pow (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\", &N, &K);\nfor (int i=1; i * i<=N; i++)\n    if (N % i == 0)\n        dv[++nr] = i;\nfor (int i=nr; i>=1; i--)\n    if (dv[i] * dv[i] != N)\n        dv[++nr] = N / dv[i];\nfor (int i=1; i<=nr; i++)\n{\n    dp[i] = pow (K, (dv[i] + 1) / 2);\n    for (int j=1; j<i; j++)\n        if (dv[i] % dv[j] == 0)\n            dp[i] = substract (dp[i], dp[j]);\n    int coef = dv[i];\n    if (coef % 2 == 0) coef /= 2;\n    ans = add (ans, mul (dp[i], coef));\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int D=1350,P=1000000007;\nint n,K,fac[D],tot,f[D];\n\nint power(int a,int x)\n{\n\tint ans=1;\n\tfor(;x;x>>=1,a=1ll*a*a%P)\n\t\tif(x&1)ans=1ll*ans*a%P;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tint t=n;\n\tfor(int i=1;i*i<=t;i++)\n\t\tif(t%i==0)\n\t\t{\n\t\t\tfac[++tot]=i;\n\t\t\tif(i*i!=t)fac[++tot]=t/i;\n\t\t}\n\tsort(fac+1,fac+1+tot);\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=power(K,fac[i]+1>>1);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(fac[i]%fac[j]==0)\n\t\t\t\tf[i]=(f[i]-f[j])%P;\n\t}\n\tconst int inv2=P+1>>1;\n\tint ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t\tif(fac[i]&1)ans=(ans+1ll*f[i]*fac[i])%P;\n\t\telse ans=(ans+1ll*inv2*f[i]%P*fac[i])%P;\n\tprintf(\"%d\\n\",(ans+P)%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nconst int q=1000000007;\nint n,m,x[100010],t,f[100010],p;\ninline int power(int a,int b)\n{\n\tif(!b)\n\t  return 1;\n\tint c=power(a,b>>1);\n\tc=(L)c*c%q;\n\tif(b&1)\n\t  c=(L)c*a%q;\n\treturn c;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i*i<=n;i++)\n\t  if(n%i==0)\n\t    {\n\t\t x[++t]=i;\n\t\t if(n/i!=i)\n\t\t   x[++t]=n/i;\n\t\t}\n\tsort(x+1,x+t+1);\n\tfor(i=1;i<=t;i++)\n\t  {\n\t   f[i]=power(m,(x[i]+1)/2);\n\t   for(j=1;j<i;j++)\n\t     if(x[i]%x[j]==0)\n\t       f[i]=(f[i]-f[j])%q;\n\t   p=(p+(L)f[i]*((x[i]&1)?x[i]:(x[i]/2)))%q;\n\t  }\n\tp=(p+q)%q;\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(auto&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(auto&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(auto&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(auto&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(auto&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto& operator<<(auto& o,TRI<S,T,U>& t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T>\nvector<T> divisor(T n)\n{\n    vector<T> res;\n    for(T i=1;(long long)i*i<=n;i++){\n        if(n%i==0){\n            res.pb(i);\n            if(i != n/i){\n                res.pb(n/i);\n            }\n        }\n    }\n    sort(all(res));\n    return res;\n}\n\ntemplate <uint mod>\nclass ModInt {\nprivate:\n    uint v;\n    static uint norm(const uint& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const uint& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static uint inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    uint operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        uint v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nmod kp[1500];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n;\n    mod K;\n    cin >> n >> K;\n    auto res = divisor(n);\n    int m = len(res);\n    mod ans = 0;\n    // show(res);\n    rep(i,m){\n        kp[i] = pow(K, (res[i]+1)/2);\n        // show(kp[i]);\n        rep(j,i){\n            if(res[i] % res[j] == 0) kp[i] -= kp[j];\n        }\n        if(res[i] % 2){\n            ans += kp[i]*res[i];\n        }else{\n            ans += kp[i]*res[i]/2;\n        }\n    }\n    // sar(kp,m);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cmath>\n#include<set>\nusing namespace std;\nconst int64_t mod = 1e9 + 7;\nint64_t mod_pow(int64_t n,int64_t x){//nをx乗\n    if(x%2==0){\n        if(x==0){\n            return 1;\n        }else{\n            int64_t z=mod_pow(n,x/2);\n            return (z*z)%mod;\n        }\n    }else{\n        if(x==1){\n            return n;\n        }else{\n            int64_t z=mod_pow(n,(x-1)/2);\n            return (z*((z*n)%mod))%mod;\n        }\n    }\n}\nint64_t solv(int64_t N,int64_t K){\n    int64_t res;\n    if(N%2==1){\n        res = (mod_pow(K,(N+1)/2) - K + mod)%mod;\n        res = (res * N + K)%mod;\n    }\n    if(N%2==0){\n        if(N%4==0){\n            int64_t tmp1 = (mod_pow(K,N/4)-K+mod)%mod;\n            int64_t tmp2 = (mod_pow(K,N/2) - K - tmp1 + 2*mod)%mod;\n            //cout << tmp1 << ' '<<tmp2 <<endl;\n            res = (K + tmp1 * N * mod_pow(4,mod-2)%mod + tmp2 * N * mod_pow(2,mod-2)%mod )%mod;\n        }else{\n            res = ((mod_pow(K,N/2)-K+mod)*N)%mod;\n            res *= mod_pow(2,mod-2);\n            res = (res+K)%mod;\n        }\n    }\n    return res;\n    \n}\n\n\nint main(){\n    int64_t N,K;\n    cin>>N>>K;\n    cout<< solv(N,K) <<endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 50000 + 100;\nconst int MOD = 1000000000 + 7;\n\nint n, m, k;\nint d[MAXN], f[MAXN];\n\nint fpow(int x, int p)\n{\n\tint ret = 1;\n\tfor(; p; p >>= 1, x = (long long)x * x % MOD)\n\t\tif(p & 1)\n\t\t\tret = (long long)ret * x % MOD;\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> k;\n\tm = 0;\n\tfor(int i = 1; i * i <= n; i++)\n\t\tif(n % i == 0)\n\t\t{\n\t\t\td[++m] = i;\n\t\t\tif(i != n / i)\n\t\t\t\td[++m] = n / i;\n\t\t}\n\tsort(d + 1, d + m + 1);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tf[i] = fpow(k, (d[i] + 1) / 2);\n\t\tfor(int j = 1; j <= i - 1; j++)\n\t\t\tif(d[i] % d[j] == 0)\n\t\t\t\tf[i] = (f[i] - f[j] + MOD) % MOD;\n\t\t// cerr << d[i] << ' ' << f[i] << endl;\n\t}\n\tint ans = 0;\n\tfor(int i = 1; i <= m; i++)\n\t\tans = (ans + (long long)d[i] * f[i] / (d[i] & 1 ? 1 : 2)) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define File(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n#define mod 1000000007\n#define maxn 10010\n\nusing namespace std;\ntypedef long long llg;\n\nint n,k;\nint a[maxn],la;\nllg f[maxn],ans;\n\nllg mi(llg a,int b){\n\tllg s=1;\n\twhile(b){\n\t\tif(b&1) s=s*a%mod;\n\t\ta=a*a%mod; b>>=1;\n\t}\n\treturn s;\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0) a[++la]=i,a[++la]=n/i;\n\tsort(a+1,a+la+1); la=unique(a+1,a+la+1)-a-1;\n\tfor(int i=1;i<=la;i++){\n\t\tf[i]+=mi(k,(a[i]+1)/2); f[i]%=mod;\n\t\tif(f[i]<0) f[i]+=mod;\n\t\tfor(int j=i+1;j<=la;j++)\n\t\t\tif(a[j]%a[i]==0) f[j]-=f[i];\n\t\tif(~a[i]&1) a[i]>>=1;\n\t\tans+=f[i]*a[i]; ans%=mod;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nconst long long MOD = 1000000007;\nint N, K, d[10000], w[10000], L;\nlong long O;\nlong long POWER(long long a, long long b)\n{\n\tlong long r = 1;\n\tfor (; b; b >>= 1)\n\t{\n\t\tif (b & 1)\n\t\t\tr = r * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn r;\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tfor (int i = 1; i * i <= N; i++)\n\t\tif (N % i == 0)\n\t\t{\n\t\t\td[L++] = i;\n\t\t\tif (i * i < N)\n\t\t\t\td[L++] = N / i;\n\t\t}\n\tstd::sort(d, d + L);\n\tfor (int i = 0; i < L; i++)\n\t\tw[i] = d[i];\n\tfor (int i = L - 1; i >= 0; i--)\n\t\tfor (int j = i + 1; j < L; j++)\n\t\t\tif (d[j] % d[i] == 0)\n\t\t\t\tw[i] -= w[j];\n\tfor (int i = 0; i < L; i++)\n\t\tO = (O + (w[i] + MOD) * POWER(K, N / d[i] & 1 ? d[i] + 1 >> 1 : d[i])) % MOD;\n\tprintf(\"%lld\\n\", O);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1 << 30;\n\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\nll cnt[10001];\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tvector<ll> div;\n\tfor (ll i = 1; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tif (i != N / i) div.push_back(N / i);\n\t\t}\n\t}\n\tsort(div.begin(), div.end());\n\tll ans = 0;\n\tfor (int i = 0; i < div.size(); i++) {\n\t\tcnt[i] = mod_pow(K, (div[i] + 1) / 2);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (div[i] % div[j] == 0) (cnt[i] += MOD - cnt[j]) %= MOD;\n\t\t}\n\t\tll add = (cnt[i] * div[i]) % MOD;\n\t\tif (div[i] % 2 == 0) (add *= mod_pow(2, MOD - 2)) %= MOD;\n\t\t(ans += add) %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\tdist.assign(V,LINF);\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLD cap;//int cap;\n\tint rev;\n};\n//edge_flow make_edge_flow(int to,int cap,int rev,LL cost=1){\nedge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n/*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tint dfs(int v,int t,int f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tint d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tint f;\n\t\t\twhile( (f = this->dfs(s,t,INF) ) > 0 ){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\tconst int varMAX = max(100000,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\n\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n#pragma region CGL\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(double x=0,double y=0):x(x),y(y){}\n\n\tPoint\toperator +\t(Point p){return Point(add(x,p.x),add(y,p.y));}\n\tvoid\toperator +=\t(Point p){x=add(x,p.x);y=add(y,p.y);}\n\tPoint\toperator -\t(Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tvoid\toperator -=\t(Point p){x=add(x,-p.x);y=add(y,-p.y);}\n\tPoint\toperator *\t(double a){return Point(x*a,y*a);}\n\tdouble\toperator *\t(Point p){return dot(p);}\n\tPoint\toperator /\t(double a){return Point(x/a,y/a);}\n\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble rot(Point p){return add(x*p.y,-y*p.x);}\n\tdouble add(double a,double b){\n\t\tdouble EPS = 1e-10;\n\t\tif( abs(a+b) < EPS*(abs(a)+abs(b)) ){\n\t\t\treturn 0;\n\t\t}\n\t\treturn a+b;\n\t}\n};\nistream& operator>>(istream& in,Point& P){\n\tin >> P.x >> P.y;\n\treturn in;\n}\nbool operator==(Point A,Point B){\n\tif( A.x==B.x && A.y==B.y)return true;\n\treturn false;\n}\nbool operator<(Point A,Point B){\n\tif( A.x < B.x ) return true;\n\telse if( A.x > B.x ) return false;\n\tif( A.y < B.y ) return true;\n\treturn false;\n}\nbool operator>(Point A,Point B){\n\tif( A<B ) return false;\n\tif( A==B ) return false;\n\treturn true;\n}\n\n//線分で表した直線の交差判定\nbool is_cross(Point p1,Point p2,Point q1,Point q2){\n\tdouble res = (p2-p1).rot(q2-q1);\n\treturn  res != 0;//平行なら0\n}\n\n/*ccwへ//線分p1-p2上に点qがあるか判定\nbool on_seg(Point p1,Point p2,Point q){\n\treturn (p1-q).rot(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}*/\n//直線p1-p2と直線q1-q2の交点\n//交差判定をしてから使う:0除算\nPoint intersection(Point p1,Point p2,Point q1,Point q2){\n\treturn p1+(p2-p1)*((q2-q1).rot(q1-p1)/(q2-q1).rot(p2-p1));\n}\n\n//線分ABに対する点C\nenum PointPotion{ONLINE_BACK=-2,CLOCKWISE,ON_SEGMENT,COUNTER_CLOCKWISE,ONLINE_FRONT};\nPointPotion ccw(Point A,Point B,Point C){\n\tB -= A;C -=A;\n\tif( B.rot(C) > 0 ) return COUNTER_CLOCKWISE;//+1\n\tif( B.rot(C) < 0 ) return CLOCKWISE;//-1\n\tif( B.dot(C) < 0 ) return ONLINE_BACK;//-2\n\tif( B.norm() < C.norm() ) return ONLINE_FRONT;//+2\n\treturn ON_SEGMENT;//0\n}\n//線分p1-p2,と線分q1-q2の交差判定\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(Point p1,Point p2,Point q1,Point q2){\n\treturn\t(ccw(p1,p2,q1) * ccw(p1,p2,q2) <= 0) &&\n\t\t\t(ccw(q1,q2,p1) * ccw(q1,q2,p2) <= 0);\n}\n///\n//直線p1-p2と点q1の距離\ndouble dist_LineP(Point p1,Point p2,Point q1){\n\treturn abs( (p2-p1).rot(q1-p1) )/(p2-p1).norm();\n}\n//線分p1-p2と点q1の距離\ndouble dist_SegP(Point p1,Point p2,Point q1){\n\t//(日)\n\tif( (p2-p1).dot(q1-p1) < 0 ){\n\t\treturn (q1-p1).norm();//p1から見てp2と逆方向\n\t}\n\tif( (p1-p2).dot(q1-p2) < 0 ){\n\t\treturn (q1-p2).norm();//p2から見てp1と逆方向\n\t}\n\treturn dist_LineP(p1,p2,q1);//垂線下ろす\n}\n// 線分同士の最短距離\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=862507#1\ndouble dist_segseg(Point A1,Point A2,Point B1,Point B2){\n\tif( intersect(A1,A2,B1,B2) ){\n\t\treturn 0;\n\t}\n\treturn min(\n\t\tmin(dist_SegP(A1,A2,B1),\n\t\t\tdist_SegP(A1,A2,B2)\n\t\t\t),\n\t\tmin(dist_SegP(B1,B2,A1),\n\t\t\tdist_SegP(B1,B2,A2)\n\t\t\t)\n\t\t);\n}\n#pragma endregion //class Point\n#pragma region CGL\n//多角形内なら2,線上なら1,外なら0\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n//http://www.prefield.com/algorithm/geometry/contains.html\n//点Pから半直線を引く、ガウス\nint contains(vector<Point>& v,Point& P){\n\tbool in = false;\n\tconst int N = v.size();\n\tfor(int i=0;i<N;++i){\n\t\tPoint A = (v[i]-P);\n\t\tPoint B = (v[(i+1)%N]-P);\n\t\tif( A.y > B.y ) swap(A,B);\n\t\tif( A.y <= 0 && 0 < B.y ){\n\t\t\tif( A.rot(B) < 0 ) in =!in;\n\t\t}\n\t\tif( A.rot(B) == 0 && A.dot(B) <= 0 ){\n\t\t\treturn 1;//ON 線上\n\t\t}\n\t}\n\treturn in ? 2:0;//中:外\n}\n#pragma endregion //contains\n#pragma region CGL\n//辞書順で比較\nbool cmp_x(const Point& p,const Point& q){\n\tif( p.x != q.x ) return p.x < q.x;\n\treturn p.y < q.y;\n}\n\n//凸包を求める\nvector<Point> convex_hull(vector<Point> ps,int n){\n\tsort(ps.begin(),ps.end(), cmp_x);\n\tint k = 0;//凸包の頂点数\n\tvector<Point> qs(n*2);//構築中の凸包\n\t//下側の凸包の作成\n\tfor(int i=0;i<n;++i){\n\t\twhile(k>1 && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){//<で線上も加える\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\t//上側凸包の作成\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t && (qs[k-1]-qs[k-2]).rot(ps[i]-qs[k-1]) <=0){//<\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n#pragma endregion //凸包\n#pragma region CGL\ndouble area(vector<Point> poly){\n\tint size = poly.size();\n\tdouble ans = 0;\n\tfor(int i=1;i<size-1;++i){\n\t\tans += (poly[i]-poly[0]).rot(poly[i+1]-poly[0])/2;\n\t}\n\treturn ans;\n}\n#pragma endregion //多角形の面積\n#pragma region CGL\nbool compare_x(Point A,Point B){\n\treturn A.x < B.x;\n}\nbool compare_y(Point A,Point B){\n\treturn A.y < B.y;\n}\n//vecはx座標の昇順で渡される\ndouble closest_pair(vector<Point>::iterator itr,int N){\n\tif(  N <= 1 ) return INF;\n\tint m = N/2;\n\tdouble x = (itr+m)->x;\n\tdouble d = min(closest_pair(itr,m),\n\t\tclosest_pair((itr+m),N-m) );\n\t\n\tinplace_merge(itr,itr+m,itr+N,compare_y);\n\n\tvector<Point> B;\n\tfor(int i=0;i<N;++i){\n\t\tif(fabs((itr+i)->x - x) >= d) continue;\n\t\tint Bsize = B.size();\n\t\tfor(int j=0;j<Bsize;j++){\n\t\t\tdouble dx,dy;\n\t\t\tdx = (itr+i)->x - B[Bsize-j-1].x;\n\t\t\tdy = (itr+i)->y - B[Bsize-j-1].y;\n\t\t\tif( dy >= d ) break;\n\t\t\td = min(d,hypot(dx,dy));\n\t\t}\n\t\tB.push_back(*(itr+i));\n\t}\n\treturn d;\n}\n#pragma endregion //最近対 2D\n#pragma region CGL\nint CircleIntersection(Point A,double AR,Point B,double BR){\n\tdouble D = (B-A).norm();\n\tif( D > AR+BR ){\n\t\treturn 4;\n\t}else if( D == AR+BR ){\n\t\treturn 3;\n\t}else if( abs(AR-BR) < D  ){//&& D<AR+BR\n\t\treturn 2;\n\t}else if(D == abs(AR-BR)){\n\t\treturn 1;\n\t}else if(D+AR < BR || D+BR<AR){\n\t\treturn 0;\n\t}\n\treturn 0;//\n}\n#pragma endregion //円と円の位置関係\n#pragma region CGL\nvector<Point> CircleLine(Point C,double CR,Point A,Point B){\n\tvector<Point> ans(2);//同じ交点なら同じ値\n\tdouble a,b,c;\n\ta = -(A.y-B.y);\n\tb = A.x-B.x;\n\tc = -(a*A.x+b*A.y);\n\n\tdouble l,k,d;\n\tl = a*a+b*b;\n\tk = a*C.x + b*C.y+ c;\n\td = l*CR*CR-k*k;\n\tif(d>0){\n\t\tdouble ds = sqrt(d);\n\t\tdouble apl = a/l;\n\t\tdouble bpl = b/l;\n\t\tdouble xc = C.x-apl*k;\n\t\tdouble yc = C.y-bpl*k;\n\t\tdouble xd = bpl*ds;\n\t\tdouble yd = apl*ds;\n\t\tPoint temp;\n\t\tans[0].x = xc-xd;\n\t\tans[0].y = yc+yd;\n\t\tans[1].x = xc+xd;\n\t\tans[1].y = yc-yd;\n\t}else if(d==0){\n\t\tPoint temp;\n\t\ttemp.x = C.x-a*k/l;\n\t\ttemp.y = C.y-b*k/l;\n\t\tans[0] = temp;\n\t\tans[1] = temp;\n\t}else{\n\t\tPoint temp;\n\t\ttemp.x = INF;\n\t\ttemp.y = INF;\n\t\tans[0] = temp;\n\t\tans[1] = temp;\n\t}\n\treturn ans;\n}\n#pragma endregion //円と直線の交点,距離チェックする。\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n\n#pragma endregion //UnionFind\n#pragma region DSL\nclass segment{\n};\n#pragma endregion //segment tree\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n\n#pragma region \ntemplate<class T,class U>\nistream& operator>>(istream& in,pair<T,U>& P){\n\tin >> P.first >> P.second;\n\treturn in;\n}\n#pragma endregion //cin pair<T,U>\n#pragma region \ntemplate<class T>\nistream& operator>>(istream& in,vector<T>& v){\n\tint size = v.size();\n\tfor(int i=0;i<size;++i){\n\t\tin >> v[i];\n\t}\n\treturn in;\n}\n#pragma endregion //cin vector<int>\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(vector< vector<T> > mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\nnamespace TIME{\ntime_t start,limit;\nvoid time_start(){start = time(NULL);}\nvoid time_set(int num){limit = num;}//秒\nbool check(){return (time(NULL)-start < limit);}\n}\n#pragma endregion //時間計測\n\n#pragma region\n/*\nnamespace RAND{\nmt19937 mt;\nvoid rand_init(){\n\trandom_device rnd;\n\tmt = mt19937(rnd());\n}\nint rand(){\n\treturn mt();\n}\n}\n*/\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n\n//////////////////\ntemplate <typename T>\nclass segment_base{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\npublic:\n\tsegment_base(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}\n\tvoid init(int n,T val_E){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tdat1.resize(2*n);\n\t\tdat1.asigne(2*n,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = min(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int index,T val){\n\t\tfor(dat1[index+=N] = val;index>1;index>>=1){\n\t\t\tdat1[index>>1] = SELECT(dat1[index],dat1[index^1]);//index+0,+1\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\tT query(int L,int R){\n\t\tT ans = VAL_E;//\n\t\tfor(L+=N,R+=N; L<R;L>>=1,R>>=1){\n\t\t\tif(L&1) ans = SELECT(ans,dat1[L++]);\n\t\t\tif(R&1) ans = SELECT(ans,dat1[--R]);\n\t\t}\n\t\treturn ans;\n\t}\n};\n//////////////////\nLL N,K;\nset<LL> used;\nmap<LL,LL> memo;\n/*\nmap[len]:=最小周期がlenの長さlenの回文の個数,文字種K個\n長さlenで周期を持たない回文の個数\n*/\n\nLL dfs(LL num){\n\tif( used.find( num ) != used.end() ){\n\t\treturn memo[ num ];\n\t}\n\tvector<LL> yaku = getDivisor(num);\n\tint size = yaku.size();\n\tLL res = powMod(K,(num/2) + (num&1) );\n\tfor(int i=0;i<size-1;++i){\n\t\tLL temp;\n\t\tif( used.find( yaku[i] ) != used.end() ){\n\t\t\ttemp = memo[ yaku[i] ];\n\t\t}else{\n\t\t\ttemp = dfs( yaku[i] );\n\t\t}\n\t\tres -= temp;\n\t\tres = ( res + MOD ) % MOD;\n\t}\n\tused.insert( num );\n\tmemo[num] = res;\n\treturn res;\n}\n\nvoid solve(){\n\tcin >> N >> K;\n\tdfs( N );\n\t\n\tvector<LL> yaku = getDivisor(N);\n\tint size = yaku.size();\n\tLL ans = 0;\n\t\n\tfor(int i=0;i<size;++i){\n\t\tif( yaku[i] & 1 ){//奇数長の最小周期\n\t\t\tans += (memo[ yaku[i] ]* yaku[i]);\n\t\t}else{//偶数長の最小周期\n\t\t\t/*\n\t\t\t↓ここから回るABCCBA\n\t\t\tABC\n\t\t\tABC←ここから回るCBAABC\n\t\t\t前半分を反転したものが後ろ半分になっている(偶数長の回文)\n\t\t\tサイクリックシフトで前半分をすべて後ろに持っていくと\n\t\t\t並びはそのままで後ろ半分の位置にくる。\n\t\t\t後ろ半分も並び順はそのままで前にくる。\n\t\t\t←→が→←の様にならぶ。\n\t\t\t→←もまた最小周期の条件を満たす。?\n\t\t\tサイクリックシフトで半分重複する。\n\t\t\t*/\n\t\t\tans += (memo[ yaku[i] ]* yaku[i]/2);\n\t\t}\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\t\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define MN 100000\n#define MOD 1000000007\nint p[MN+5],pn,a[MN+5],an;\nmap<int,int> f;\ninline int pw(int x,int y)\n{\n\tint r=1;\n\tfor(;y;y>>=1,x=1LL*x*x%MOD)if(y&1)r=1LL*r*x%MOD;\n\treturn r;\n}\nint main()\n{\n\tint n,k,i,x,u=0,ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\tif(n%2==0)n/=2,u=1;\n\tfor(i=2,x=n;i*i<=x;++i)if(x%i==0)for(p[++pn]=i;x%i==0;)x/=i;\n\tif(x>1)p[++pn]=x;\n\tfor(i=1;i*i<n;++i)if(n%i==0)a[++an]=i,a[++an]=n/i;if(i*i==n)a[++an]=i;\n\tsort(a+1,a+an+1);\n\tfor(i=1;i<=an;++i)f[a[i]]=pw(k,u?a[i]:a[i]+1>>1);\n\tfor(x=1;x<=pn;++x)for(i=an;i;--i)if(a[i]%p[x]==0)\n\t\tf[a[i]]=(f[a[i]]+MOD-f[a[i]/p[x]])%MOD;\n\tfor(i=1;i<=an;++i)ans=(ans+1LL*f[a[i]]*a[i])%MOD;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define rep(i,x) for(int i=0;i<x;i++)\n#define mod 1000000007\nll n,k;\nvector<ll>num,cnt;\nll modpow(ll x,ll n)\n{\n\tll res=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tcin >> n >> k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i == 0) num.pb(i);\n\t\tif(n%i == 0 && i*i != n) num.pb(n/i);\n\t}\n\tsort(num.begin(),num.end()); \n\tll ret = 0;\n\tfor(int i=0;i<num.size();i++){\n\t\tcnt.pb(1);\n\t\tint q = (num[i]+1)/2;\n\t\tcnt[i] = modpow(k,q); //cout << cnt[i] << endl;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(num[i]%num[j] == 0){\n\t\t\t\tcnt[i] = cnt[i]+mod-cnt[j]*(num[j]%2==0?2:1);\n\t\t\t\tcnt[i] %= mod;\n\t\t\t}\n\t\t}\n\t\tif(num[i]%2 == 0) cnt[i] = cnt[i]*(500000004LL)%mod;\n\t\t//cnt[i] = cnt[i] * num[i] % mod;\n\t\tret += cnt[i] * num[i] % mod; //cout << cnt[i] << endl;\n\t}\n\tcout << ret%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// C++(GCC 9.2.1)\n// 解き直し.\n// https://img.atcoder.jp/arc064/editorial.pdf\n// ① 1_27.txt, 1_28.txt, 1_30.txt, 1_31.txt で, WA版となったため, ロジック修正.\n// -> d[i] / 2 は d[i] * 500000004 % MOD に 修正 -> 最終的に, もとに戻した.\n// ② 1_27.txt で, WA版となったため, ロジック修正.\n// -> mPow の 第二引数が, 切り捨てだったものを, 切り上げに修正.\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define all(x) x.begin(), x.end()\nconst LL MOD = 1e9 + 7;\n\n// 与えられた正の整数のすべての約数を抽出.\n// @param X: 約数を抽出したい正の整数.\n// @return ret: すべての約数.\nvector<LL> div(LL X){\n    vector<LL> ret;\n    ret.pb(1);\n    for(LL d = 2; d * d <= X; d++){\n        if(X % d == 0){\n            ret.pb(d);\n            if(d * d != X) ret.pb(X / d);\n        }\n    }\n    if(X > 1) ret.pb(X);\n    sort(all(ret));\n    return ret;\n}\n\n// Fermat's little theorem から, 大きな冪乗の計算を行う.\n// @param a: べき乗したい正整数.\n// @param b: 指数.\n// @return:  べき乗した計算結果(mod版).\nLL mPow(LL a, LL b){\n    LL t = 1;\n    while(b){\n        if(b & 1) t = (t * a) % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return t % MOD;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    LL N, K;\n    scanf(\"%lld %lld\", &N, &K);\n    \n    // 2. 例外.\n    if(N == 1){\n        printf(\"%lld\\n\", K);\n        return 0;\n    }\n    \n    // 3. N の 約数.\n    vector<LL> d = div(N);\n    // for(auto &p : d) printf(\"%lld \", p);\n    // puts(\"\");\n    \n    // 4. 各最小周期に対応する数列の個数.\n    int l = d.size();\n    LL num[l];\n    memset(num, 0, sizeof(num));\n    rep(i, l){\n        // num[i] = mPow(K, d[i] / 2);\n        // num[i] = mPow(K, d[i] * 500000004 % MOD);\n        num[i] = mPow(K, (d[i] + 1) / 2);\n        rep(j, i){\n            if(d[i] % d[j] == 0) num[i] = (num[i] + MOD - num[j]) % MOD;\n        }\n    }\n    \n    // 5. 解答を求めるための数式を計算.\n    LL ans = 0, nd;\n    rep(i, l){\n        // nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        // nd = (d[i] & 1) ? d[i] : (d[i] * 500000004 % MOD);\n        nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        ans += num[i] * nd;\n        ans %= MOD;\n    }\n    \n    // 6. 出力.\n    printf(\"%lld\\n\", ans);\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MOD 1000000007\n\nint n;\nint k;\n\n\nvector<int> dv;\nvector<long long int>  way;\n\nlong long int ppow(long long int i, long long int j) {\n\tlong long int res = 1LL;\n\twhile (j) {\n\t\tif ((j & 1LL)) {\n\t\t\tres *= i;\n\t\t\tif (res >= MOD) {\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t\tj >>= 1;\n\t\ti *= i;\n\t\tif (i >= MOD) {\n\t\t\ti %= MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n >> k;\n\tfor (long long int i = 1; i*i <= n; i++) {\n\t\tif(n%i==0)dv.push_back(i);\n\t\tif (n%i == 0)dv.push_back(n / i);\n\t}\n\tsort(dv.begin(), dv.end());\n\tdv.erase(unique(dv.begin(), dv.end()), dv.end());\n\tfor (int i = 0; i < dv.size(); i++) {\n\t\tway.push_back(ppow(k, (dv[i] + 1) / 2));\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (dv[i] % dv[j] == 0) {\n\t\t\t\tway[i] += MOD - way[j];\n\t\t\t\tif (way[i] >= MOD)way[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < dv.size(); i++) {\n\t\tif (dv[i] % 2 == 0) {\n\t\t\tans += way[i] * dv[i]/2;\n\t\t}\n\t\telse {\n\t\t\tans += way[i] * dv[i];\n\t\t}\n\t\tif (ans >= MOD)ans %= MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nint main()\n{\n\tll n, k;\n  cin>>n>>k;\n  vector<ll> div;\n  for(ll i=1; i*i<=n; i++){\n    if(n%i==0){\n      div.push_back(i);\n      if(i*i<n) div.push_back(n/i);\n    }\n  }\n  sort(div.begin(), div.end());\n  ll ct1[1350], ct[1350];\n  for(int i=0; i<div.size(); i++){\n    ct1[i]=powmod(k, (div[i]+1)/2);\n    ct[i]=ct1[i];\n    for(int j=0; j<i; j++){\n      if(div[i]%div[j]==0){\n        ct[i]-=ct[j];\n        ct[i]+=MOD;\n        ct[i]%=MOD;\n      }\n    }\n  }\n  ll ans=0;\n  for(int i=0; i<div.size(); i++){\n    if(div[i]%2!=0) ans+=(ct[i]*div[i]%MOD);\n    else ans+=(ct[i]*div[i]%MOD*(ll)(5e8+4)%MOD);\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=2000,mod=1e9+7;\ninline int powmod(int a,int b){int c=1;while(b){if(b&1)c=(LL)c*a%mod;a=(LL)a*a%mod;b>>=1;}return c;}\nint n,k,f[N],g[N],num,ans;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0)\n\t{\n\t\tf[++num]=i;\n\t\tif(i*i!=n)f[++num]=n/i;\n\t}\n\tsort(f+1,f+num+1);\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tg[i]=powmod(k,(f[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)if(f[i]%f[j]==0)g[i]=(g[i]-g[j]+mod)%mod;\n\t\tans=(ans+(LL)g[i]*((f[i]&1)?f[i]:f[i]/2)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\n//周期がiの約数の回文数\nint calcnum(int i, int K, int mod){\n    return modpow(K, (i + 1) / 2, mod);\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n\n    map<int, int> f, g;\n    for(int i = 1; i * i <= N; i++){\n        if(N % i == 0){\n            f[i] = calcnum(i, K, mod);\n            f[N / i] = calcnum(N / i, K, mod);\n        }\n    }\n    int ans = 0;\n    for(auto p: f){\n        int n = p.first;\n        int val = p.second;\n        for(auto q: g){\n            int d = q.first;\n            if(n % d == 0){\n                val -= q.second;\n                val = (val % mod + mod) % mod;\n            }\n        }\n        g[n] = val;\n        if(n % 2 == 0) ans += val * (n / 2);\n        else ans += val * n;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nconst int N=2005,mo=1e9+7;\nint n,m,i,j,na,a[N],f[N],ans;\nint Pow(int x,int n){\n\tint k=1;\n\tfor (;n;n>>=1,x=(ll)x*x%mo)\n\t\tif (n&1) k=(ll)k*x%mo;\n\treturn k;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i*i<=n;i++) if (n%i==0) a[++na]=i;\n\tfor (i=na;i;i--) if (a[i]*a[i]!=n) a[++na]=n/a[i];\n\tfor (i=1;i<=na;i++){\n\t\tf[i]=Pow(m,a[i]+1>>1);\n\t\tfor (j=1;j<i;j++)\n\t\t\tif (a[i]%a[j]==0) f[i]=(f[i]-f[j])%mo;\n\t\tans=(ans+(ll)f[i]*(a[i]&1?a[i]:a[i]>>1))%mo;\n\t}\n\tprintf(\"%d\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int mo=1000000007,inv2=(mo+1)/2;\nint d[3000],f[3000];\nint i,j,k,l,t,n,m,top,ans;\nint qsm(int x,int y){\n\tif (!y) return 1;\n\tint t=qsm(x,y/2);\n\tt=(ll)t*t%mo;\n\tif (y%2) t=(ll)t*x%mo;\n\treturn t;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tt=floor(sqrt(n));\n\tfo(i,1,t)\n\t\tif (n%i==0){\n\t\t\td[++top]=i;\n\t\t\tif (i!=n/i) d[++top]=n/i;\n\t\t}\n\tsort(d+1,d+top+1);\n\tfo(i,1,top){\n\t\tf[i]=qsm(k,(d[i]+1)/2);\n\t\tfo(j,1,i-1)\n\t\t\tif (d[i]%d[j]==0) (f[i]-=f[j])%=mo;\n\t\tif (d[i]%2==0) (ans+=(ll)f[i]*d[i]%mo*inv2%mo)%=mo;\n\t\telse (ans+=(ll)f[i]*d[i]%mo)%=mo;\n\t}\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n\nvoid solve(){\n\tcin >> N >> K;\n\tdfs( N );\n\t\n\tvector<LL> yaku = getDivisor(N);\n\tint size = yaku.size();\n\tLL ans = 0;\n\t\n\tfor(int i=0;i<size;++i){\n\t\tif( yaku[i] & 1 ){//奇数長の最小周期\n\t\t\tans += (memo[ yaku[i] ]* yaku[i]);\n\t\t}else{//偶数長の最小周期\n\t\t\t/*\n\t\t\t↓ここから回るABCCBA\n\t\t\tABC\n\t\t\tABC←ここから回るCBAABC\n\t\t\t前半分を反転したものが後ろ半分になっている(偶数長の回文)\n\t\t\tサイクリックシフトで前半分をすべて後ろに持っていくと\n\t\t\t並びはそのままで後ろ半分の位置にくる。\n\t\t\t後ろ半分も並び順はそのままで前にくる。\n\t\t\t←→が→←の様にならぶ。\n\t\t\t→←もまた最小周期の条件を満たす。?\n\t\t\tサイクリックシフトで半分重複する。\n\t\t\t←1←2 →2→1\n\t\t\t→2→1 ←1←2\n\t\t\t偶数長の周期があったとすると、それをつなげた\n\t\t\t→2→1も周期性がある。\n\t\t\t回文なので←1←2も周期性がある。\n\t\t\tこれは\n\t\t\t←1←2 →2→1が最小周期の条件と矛盾するので\n\t\t\t→2→1 ←1←2は偶数長の周期を持たない。\n\n\t\t\t→2→1 ←1←2が奇数長の周期を持つとする。\n\t\t\t元の長さが偶数なので、奇数長の周期が偶数個表れる。\n\t\t\tよって→2→1は奇数周期の回文を繋げて構成されている。\n\t\t\t同じ回文を繋げた文字列も回文なので\n\t\t\t←1←2も回文で奇数長の周期を持つ。\n\t\t\t←1←2 →2→1が奇数長の周期を持つ事になる。\n\t\t\t←1←2 →2→1が内部に周期を持たない事と矛盾するので\n\t\t\t→2→1 ←1←2は奇数長の周期を持たない。\n\n\t\t\t→2→1 ←1←2は内部に周期を持たない。\n\t\t\t*/\n\t\t\tans += (memo[ yaku[i] ]* yaku[i]/2);\n\t\t}\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\t\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007;\nin p2(in a){\n  return 1LL<<a;\n}\nin pw(in a, in b){\n  in r=1;\n  for(in i=40;i>=0;--i){\n    r=r*r%mdl;\n    if(b&p2(i))\n      r=r*a%mdl;\n  }\n  return r;\n}\nin fr(in a){\n  if(a%2==0)\n    return a/2;\n  return (a+1)/2;\n}\nVI dvs;\nVI hv;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,k;\n  cin>>n>>k;\n  in sm=0;\n  for(in i=1;i*i<=n;++i){\n    if(n%i)\n      continue;\n    dvs.PB(i);\n    if(n/i!=i)\n      dvs.PB(n/i);\n  }\n  sort(all(dvs));\n  hv=VI(sz(dvs),0);\n  forv(i,hv){\n    hv[i]=pw(k,fr(dvs[i]));\n    forn(j,i){\n      if(dvs[i]%dvs[j]==0)\n\thv[i]-=hv[j];\n    }\n    hv[i]%=mdl;\n    if(dvs[i]%2)\n      sm+=hv[i]*dvs[i];\n    else\n      sm+=hv[i]*(dvs[i]/2);\n    sm%=mdl;\n  }\n  sm%=mdl;\n  if(sm<0)\n    sm+=mdl;\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\twhile(true) {\n\t\tLL num = 1, prod = 1;\n\t\tinc(i, pn) {\n\t\t\tinc(j, count[i]) {\n\t\t\t\tif(j == 0) { num *= -1; } else { num = 0; }\n\t\t\t\t(prod *= p[i]) %= MOD;\n\t\t\t}\n\t\t}\n\t\tdivisor.push_back(prod);\n\t\tmu[prod] = num;\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) { count[i++] = 0; }\n\t\tif(i == pn) { break; } else { count[i]++; }\n\t}\n\t\n\tfor(auto && e : divisor) { gg[e] = g(e); }\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++(GCC 9.2.1)\n// 解き直し.\n// https://img.atcoder.jp/arc064/editorial.pdf\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define all(x) x.begin(), x.end()\nconst LL MOD = 1e9 + 7;\n\n// 与えられた正の整数のすべての約数を抽出.\n// @param X: 約数を抽出したい正の整数.\n// @return ret: すべての約数.\nvector<LL> div(LL X){\n    vector<LL> ret;\n    ret.pb(1);\n    for(LL d = 2; d * d <= X; d++){\n        if(X % d == 0){\n            ret.pb(d);\n            if(d * d != X) ret.pb(X / d);\n        }\n    }\n    if(X > 1) ret.pb(X);\n    sort(all(ret));\n    return ret;\n}\n\n// Fermat's little theorem から, 大きな冪乗の計算を行う.\n// @param a: べき乗したい正整数.\n// @param b: 指数.\n// @return:  べき乗した計算結果(mod版).\nLL mPow(LL a, LL b){\n    LL t = 1;\n    while(b){\n        if(b & 1) t = (t * a) % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return t % MOD;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    LL N, K;\n    scanf(\"%lld %lld\", &N, &K);\n    \n    // 2. 例外.\n    if(N == 1){\n        printf(\"%lld\\n\", K);\n        return 0;\n    }\n    \n    // 3. N の 約数.\n    vector<LL> d = div(N);\n    // for(auto &p : d) printf(\"%lld \", p);\n    // puts(\"\");\n    \n    // 4. 各最小周期に対応する数列の個数.\n    int l = d.size();\n    LL num[l];\n    memset(num, 0, sizeof(num));\n    rep(i, l){\n        num[i] = mPow(K, d[i] / 2);\n        rep(j, i){\n            if(d[i] % d[j] == 0) num[i] = (num[i] + MOD - num[j]) % MOD;\n        }\n    }\n    \n    // 5. 解答を求めるための数式を計算.\n    LL ans = 0, nd;\n    rep(i, l){\n        nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        ans += num[i] * nd;\n        ans %= MOD;\n    }\n    \n    // 6. 出力.\n    printf(\"%lld\\n\", ans);\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (LL i = (s); i < (n); i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int LL;\ntypedef long double LD;\n\nLL _pow(LL a, LL k) {\n\tLL res = 1;\n\twhile (k) {\n\t\tif (k&1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tLL N, K;\n\tcin >> N >> K;\n\n\tmap<int, LL> num;\n\tREP(i, sqrt(N)+1, 1) {\n\t\tif (N%i == 0) {\n\t\t\tnum[i] = _pow(K, (i+1)/2);\n\t\t\tint j = N / i;\n\t\t\tnum[j] = _pow(K, (j+1)/2);\n\t\t}\n\t}\n\tfor (auto p1 : num) {\n\t\tfor (auto p2 : num) {\n\t\t\tif (p2.first != p1.first && p2.first % p1.first == 0) {\n\t\t\t\tnum[p2.first] -= num[p1.first];\n\t\t\t\tnum[p2.first] = (num[p2.first] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tLL res = 0;\n\tfor (auto p : num) {\n\t\tres = (res + p.second * p.first / (1 + !(p.first&1))) % MOD;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<cmath>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=10005,mod=1000000007;\nint n,k,prm[N],c[N],a[N],tot;\ntypedef long long LL;\nLL ret,ans;\n\nLL getmi(LL a,LL x)\n{\n\tLL rt=1;\n\twhile(x)\n\t{\n\t\tif(x&1) rt=rt*a%mod;\n\t\ta=a*a%mod,x>>=1;\n\t}\n\treturn rt;\n}\n\nvoid dfs2(int x,int d,int val)\n{\n\tif(x>tot)\n\t{\n\t\tif(d&1) ret=(ret+d*getmi(k,(d/val+1)/2))%mod;\n\t\telse ret=(ret+d/2*getmi(k,(d/val+1)/2))%mod;\n\t\treturn;\n\t}\n\tint nw=a[x]?prm[x]:1;\n\trep(i,a[x],c[x]) dfs2(x+1,d*nw,val),nw*=prm[x];\n}\n\nvoid dfs1(int x,int mu,int val)\n{\n\tif(x>tot)\n\t{\n\t\tret=0,dfs2(1,1,val);\n\t\tans=(ans+mu*ret)%mod;\n\t\treturn;\n\t}\n\ta[x]=0,dfs1(x+1,mu,val);\n\ta[x]=1,dfs1(x+1,-mu,val*prm[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tint x=n,lim=sqrt(n);\n\trep(i,2,lim) if(x%i==0)\n\t{\n\t\tprm[++tot]=i;\n\t\twhile(x%i==0) x/=i,++c[tot];\n\t}\n\tif(x>1) prm[++tot]=x,c[tot]=1;\n\tdfs1(1,1,1);\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\nvector<int> getDivs(int N) {\n\tvector<int> ret;\n\tfor (int i = 1; i*i <= N; i++) {\n\t\tif (N%i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i*i < N) ret.push_back(N/i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\treturn ret;\n}\n\nll memo[2000];\nll powMod(ll x, ll p) {\n\tif (x == 0) return 0;\n\tif (p == 0) return 1;\n\tif (p == 1) return x;\n\tif (p%2 == 1) return x*powMod(x, p-1) % MOD;\n\tll tmp = powMod(x, p/2);\n\treturn tmp * tmp % MOD;\n}\n\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tauto divs = getDivs(N);\n\tint M = divs.size();\n\tll ans = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tll& res = memo[i];\n\t\tres = powMod(K, (divs[i]+1)/2);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (divs[i]%divs[j] == 0) res -= memo[j];\n\t\tres = ((res%MOD)+MOD) % MOD;\n\t\tif (divs[i]%2 == 0) (ans += res*divs[i]/2%MOD) %= MOD;\n\t\telse (ans += res*divs[i]%MOD) %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int mod=1e9+7;\ninline int powmod(int a,int b){\n\tint res=1;for(;b;b>>=1){\n\t\tif(b&1)res=1ll*res*a%mod;\n\t\ta=1ll*a*a%mod;\n\t}return res;\n}\nint n,k;\ninline int getlen(int x){\n\treturn powmod(k,(x+1)/2);\n}\nmap<int,int> F;\ninline int f(int n){\n\tif(F.count(n))return F[n];\n\tint &res=F[n];res=getlen(n);\n\tint tmp=sqrt(n);\n\trep(i,1,tmp){\n\t\tif(n%i==0){\n\t\t\tif(i!=n)res=(res-f(i)+mod)%mod;\n\t\t\tif(n/i!=i&&n/i!=n)res=(res-f(n/i)+mod)%mod;\n\t\t}\n\t}return res;\n}\ninline int g(int n){\n\tif(n%2==0)\n\t\treturn 1ll*f(n)*powmod(2,mod-2)%mod;\n\telse\n\t\treturn f(n);\n}\nint main(){\n\tread(n);read(k);\n\tint tmp=sqrt(n),ans=0;\n\trep(i,1,tmp)if(n%i==0){\n\t\tans=(ans+1ll*i*g(i))%mod;\n\t\tif(n/i!=i)ans=(ans+1ll*(n/i)*g(n/i))%mod;\n\t}printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//平方数に注意\n#include <iostream>\n#include <map>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, k;\nmap<int, int> num;\n\nint power(int a, int n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return power((a * a) % mod, n / 2) % mod;\n\treturn (a * power(a, n - 1)) % mod;\n}\n\nvoid setNum(int d) {\n\tnum[d] = power(k, (d + 1) / 2);\n\tfor (int i = 1; i * i <= d; i++) {\n\t\tif (d % i != 0) continue;\n\t\tif (i != d) {\n\t\t\tif (num.find(i) == num.end()) setNum(i);\n\t\t\tnum[d] = (num[d] + mod - num[i]) % mod;\n\t\t}\n\t\tif (i != d / i && d / i != d) {\n\t\t\tif (num.find(d / i) == num.end()) setNum(d / i);\n\t\t\tnum[d] = (num[d] + mod - num[d / i]) % mod;\n\t\t}\n\t}\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> k;\n\t\n\tfor (i = 1; i * i <= n; i++) {\n\t\tif (n % i != 0) continue;\n\t\tsetNum(i);\n\t\tsetNum(n / i);\n\t}\n\t\n\tint ans = 0;\n\tfor (map<int, int>::iterator it = num.begin(); it != num.end(); it++) {\n\t\tint d = (*it).first;\n\t\tint cnt = (*it).second;\n\n\t\tif (d % 2) {\n\t\t\tans += d * cnt;\n\t\t}\n\t\telse {\n\t\t\tans += (d / 2) * cnt;\n\t\t}\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\n#define exp __exp\n#define pow __pow\nusing LL = long long;\nusing LD = long double;\nconst int LN = 30;\nconst int mod = 1000000007;\nconst int phimod = mod - 1;\nint tc, tot, ans;\nLL n, k, base[LN], exp[LN];\nstd::map<LL, int> divisor;\nint pow(int x, int y) {\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = static_cast<LL> (x) * x % mod)\n\t\tif (y & 1) ans = static_cast<LL> (ans) * x % mod;\n\treturn ans;\n}\nvoid reduce(int &x) {\n\tx += x >> 31 & mod;\n}\nint phi(int n) {\n\tint ret = n;\n\tfor (int i = 2; i * i <= n; ++i) if (n % i == 0) {\n\t\tret = ret / i * (i - 1);\n\t\tdo n /= i; while (n % i == 0);\n\t}\n\tif (n > 1) ret = ret / n * (n - 1);\n\treturn ret;\n}\nLL mul(LL x, LL y, LL mod) {\n\tLL ret = (x * y - static_cast<LL> (static_cast<LD> (x) * y / mod + 0.5) * mod) % mod;\n\treturn ret + (ret >> 63 & mod);\n}\nLL pow_(LL x, LL y, LL mod, LL ans = 1) {\n\tfor (; y; y >>= 1, x = mul(x, x, mod))\n\t\tif (y & 1) ans = mul(ans, x, mod);\n\treturn ans;\n}\nconst int primes[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 };\nbool prime_test(LL n) {\n\tLL e = n - 1 >> __builtin_ctzll(n - 1);\n\tfor (int i = 0; i < 12; ++i) {\n\t\tint p = primes[i];\n\t\tif (n == p) return 1;\n\t\tfor (LL d = e, lst = pow_(p, d, n), now; d != n - 1; lst = now, d <<= 1) {\n\t\t\tnow = mul(lst, lst, n);\n\t\t\tif (now == 1 && lst != 1 && lst != n - 1) return 0;\n\t\t}\n\t\tif (pow_(p, n - 1, n) != 1) return 0;\n\t}\n\treturn 1;\n}\nvoid pollard_rho(LL n) {\n\tif (n == 1) return;\n\tif (prime_test(n)) { ++divisor[n]; return; }\n\tfor (; ; ) {\n\t\tLL x = std::rand(), c = std::rand(), y = x, now = 1;\n\t\tint i = 0, k = 1;\n\t\twhile (i <= 1E5) {\n\t\t\tx = mul(x, x, n) + c;\n\t\t\tLL tmp = mul(now, std::abs(x - y), n);\n\t\t\tif (tmp) now = tmp;\n\t\t\tif (!(i & 127)) {\n\t\t\t\tLL d = std::__gcd(now, n);\n\t\t\t\tif (d > 1 && d < n) { pollard_rho(d), pollard_rho(n / d); return; }\n\t\t\t}\n\t\t\tif (x == y) break;\n\t\t\tif (++i == k) y = x, k <<= 1, now = 1;\n\t\t}\n\t}\n}\nint f(LL n) {\n\tint ans = 1;\n\tans = static_cast<LL> (ans) * pow(k, (n + 1 >> 1) % phimod) % mod;\n\tans = static_cast<LL> (ans) * ((n & 1 ? n : n >> 1) % mod) % mod;\n\treturn ans;\n}\nvoid dfs(int dep, LL val, LL miu) {\n\tif (dep == tot) {\n\t\tif ((val & 1) || !(n / val & 1))\n\t\t\treduce(ans += miu % mod * f(n / val) % mod - mod), reduce(ans);\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= exp[dep]; ++i) {\n\t\tdfs(dep + 1, val, miu), val *= base[dep];\n\t\tif (!i) miu = miu * (1 - base[dep]);\n\t}\n}\nint solve() {\n\tdivisor.clear(), pollard_rho(n), tot = ans = 0;\n\tfor (auto pk : divisor) base[tot] = pk.first, exp[tot++] = pk.second;\n\tdfs(0, 1, 1);\n\treturn ans;\n}\nint main() {\n\tstd::cin >> n >> k, k %= mod, std::cout << solve() << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*SS=SZB,*TT=SZB;\n    inline char gc(){   if (SS==TT){  TT=(SS=SZB)+fread(SZB,1,GYN,stdin); if (SS==TT) return '\\n';  }   return *SS++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace SHENZHEBEI;\nconst int N=500105,mod=1e9+7;\nll q[N],sum[N],n,k,top,ans;\nll ppow(ll x,ll k){ll ans=1;for(;k>>=1;Mul(x,x))if (k&1)Mul(ans,x);return ans;}\nint main(){\n\tn=read(),k=read();\n\tfor(ll i=1;i*i<=n;i++)if (!(n%i)){\n\t\tq[++top]=i;\n\t\tif (n!=i*i)q[++top]=n/i;\n\t}sort(q+1,q+top+1);\n\tFor(i,1,top)sum[i]=ppow(k,(q[i]+1)>>1);\n\tFor(i,1,top){\t\n\t\trep(j,1,i)if (!(q[i]%q[j]))Add(sum[i],-sum[j]);\n\t\tAdd(ans,top*((sum[i]&1)?sum[i]:(sum[i]>>1)));\n\t}Add(ans,mod);\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T, class F = multiplies<T>>\nT power(T a, long long n, F op = multiplies<T>(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  unsigned v;\n  modular(long long a = 0) : v((a %= M) < 0 ? a + M : a) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m r) { if ((v += r.v) >= M) v -= M; return *this; }\n  m& operator-=(m r) { if (v < r.v) v += M; v -= r.v; return *this; }\n  m& operator*=(m r) { v = (uint64_t)v * r.v % M; return *this; }\n  m& operator/=(m r) { return *this *= power(r, M - 2); }\n  friend m operator+(m l, m r) { return l += r; }\n  friend m operator-(m l, m r) { return l -= r; }\n  friend m operator*(m l, m r) { return l *= r; }\n  friend m operator/(m l, m r) { return l /= r; }\n  friend bool operator==(m l, m r) { return l.v == r.v; }\n  friend string to_string(m a) { return to_string(a.v); }\n};\n\nconstexpr long long mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<int> ds;\n  for (int i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      ds.push_back(i);\n      ds.push_back(n / i);\n    }\n  }\n  sort(begin(ds), end(ds));\n  ds.erase(unique(begin(ds), end(ds)), end(ds));\n  vector<mint> dp(ds.size());\n  mint res;\n  for (int i = 0; i < (int)ds.size(); ++i) {\n    dp[i] = power(mint(m), (ds[i] + 1) / 2);\n    for (int j = 0; j < i; ++j) {\n      if (ds[i] % ds[j] == 0) {\n        dp[i] -= dp[j];\n      }\n    }\n    res += ds[i] & 1 ? dp[i] * ds[i] : dp[i] * ds[i] / 2;\n  }\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nint n,K,p[105],c[105],cnt,a[5005],top,f[5005],ans=0;\nvoid dfs(int s,int x)\n{\n\tif(s>cnt){a[++top]=x;return;}\n\tfor(int k=0;k<=c[s];++k) dfs(s+1,x),x*=p[s];\n}\ninline int pow(int x,int k)\n{\n\tint sum=1;\n\tfor(;k;k>>=1,x=1LL*x*x%mod) if(k&1) sum=1LL*sum*x%mod;\n\treturn sum;\t\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);\n\tfor(int i=2,t=n;i*i<=t;++i) if(t%i==0)\n\t{\n\t\tp[++cnt]=i;\n\t\twhile(t%i==0) t/=i,++c[cnt];\n\t}\n\tdfs(1,1);sort(a+1,a+top+1);\n\tfor(int i=1;i<=top;++i)\n\t{\n\t\tf[i]=pow(K,(a[i]+1)>>1);\n\t\tfor(int j=1;j<i;++j) if(a[i]%a[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n\t\tans=(ans+1LL*f[i]*((a[i]&1)?a[i]:a[i]/2))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n//負数がないMOD関数\ninline long long imod(long long a, long long b)\n{\n\treturn (a >= 0) ? (a % b) : (a % b + b);\n}\n\n//mint_base型用の累乗関数\ntemplate <long long MOD> class mint_base;\ntemplate <long long MOD> mint_base<MOD> m_pow(mint_base<MOD> x, long long n);\n\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <long long MOD = 1000000007>\nclass mint_base\n{\npublic:\n\tmint_base<MOD> operator+(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a + other.a, MOD));\n\t}\n\tmint_base<MOD> operator-(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a - other.a, MOD));\n\t}\n\tmint_base<MOD> operator*(const mint_base<MOD> &other)const\n\t{\n\t\treturn mint_base<MOD>(imod(a * other.a, MOD));\n\t}\n\tmint_base<MOD> operator+=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a + other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator-=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a - other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator*=(const mint_base<MOD> &other)\n\t{\n\t\ta = imod(a * other.a, MOD);\n\t\treturn mint_base<MOD>(a);\n\t}\n\tmint_base<MOD> operator+()const\n\t{\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator-()const\n\t{\n\t\treturn mint_base<MOD>(-a);\n\t}\n\tmint_base<MOD>& operator++()\n\t{\n\t\t*this += 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator++(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this += 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD>& operator--()\n\t{\n\t\t*this -= 1;\n\t\treturn *this;\n\t}\n\tmint_base<MOD> operator--(int)\n\t{\n\t\tauto tmp = *this;\n\t\t*this -= 1;\n\t\treturn tmp;\n\t}\n\tmint_base<MOD> operator~()const\n\t{\n\t\treturn pow(a, e_phi - 1);\n\t}\n\tmint_base<MOD>& operator=(const mint_base<MOD> &other)\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\texplicit operator long long()const\n\t{\n\t\treturn a;\n\t}\n\texplicit operator int()const\n\t{\n\t\treturn (int)a;\n\t}\n\n\t//無効な数値を指定された場合\n\tstatic_assert(MOD >= 2, \"MOD cannot be below 2.\");\n\tmint_base(long long a_) :a(imod(a_, MOD))\n\t{\n\t\tif (e_phi > 0)return;\n\t\t//オイラー値の導出\n\t\te_phi = MOD;\n\t\tlong long m_ = MOD;\n\t\tfor (int i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\te_phi = e_phi / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)e_phi = e_phi / m_ * (m_ - 1);\n\t}\n\tmint_base() :a(0) {}\nprivate:\n\tstatic long long e_phi;\n\tlong long a;\n};\n\n//mint_base型用の累乗関数\ntemplate<long long MOD>mint_base<MOD> m_pow(mint_base<MOD> x, long long n)\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<long long MOD>mint_base<MOD> fact(mint_base<MOD> x)\n{\n\tmint_base<MOD> res(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\n//mint_baseの階乗計算\n//0からxまでの階乗をsetに出力する\ntemplate<long long MOD>void fact_set(std::vector<mint_base<MOD>> &set, mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tset.push_back(1);\n\tfor (long long i = 1; i <= (long long)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset.push_back(res);\n\t}\n}\n\ntemplate<long long MOD>long long mint_base<MOD>::e_phi = -1;\n\n//mint_base型のstreamへの出力\ntemplate<long long MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (long long)i;\n\treturn os;\n}\n\n//mint_base型のstreamからの入力\ntemplate<long long MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tlong long tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\n\ntypedef mint_base<> mint;\n\n\nint main(void)\n{\n\tmint n, k;\n\tcin >> n;\n\tcin >> k;\n\tmint half = (long long)n / 2ll;\n\tmint ans = 0;\n\tif ((long long)n % 2ll == 0)\n\t{\n\t\tans = (m_pow(k, (long long)half) - k) * half;\n\t\tans += k;\n\t}\n\telse\n\t{\n\t\tans = (m_pow(k, (long long)half + 1) - k) * n;\n\t\tans += k;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<set>\n#include<map>\n#define LL long long\nusing namespace std;\ninline int read( )\n{\n  int sum=0;char c=getchar( );bool f=0;\n  while(c<'0'||c>'9') {if(c=='-') f=1;c=getchar( );}\n  while(c>='0'&&c<='9') {sum=sum*10+c-'0';c=getchar( );}\n  if(f) return -sum;\n  return sum;\n}\nconst int mod=1000000007;\ninline LL quick(LL a,LL b)\n{\n  LL r=1,base=a;\n  while(b)\n    {\n      if(b&1) r=r*base%mod;\n      base=base*base%mod;\n      b>>=1;\n    }\n  return r;\n}\nint p[10005],f[10005];\ninline void up(int &x,int y) {x+=y;if(x>=mod) x-=mod;}\nint main( )\n{\n  int n,k,i,j,x,ans=0,len=0;\n  n=read( );k=read( );\n  for(i=1;i*i<=n;i++)\n    if(n%i==0) p[++len]=i,p[++len]=n/i;\n  sort(p+1,p+len+1);\n  len=unique(p+1,p+len+1)-p-1;\n  for(i=1;i<=len;i++)\n    {\n      x=p[i];\n      f[i]=quick(k,(x+1)>>1);\n      for(j=1;j<i;j++)\n\tif(x%p[j]==0) up(f[i],mod-f[j]);\n      if(!(x&1)) x>>=1;\n      up(ans,(LL)f[i]*x%mod);\n    }\n  printf(\"%d\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nconst ll MOD=1e9+7;\nll fpow(ll a,ll p){\n\tll res=1LL;\n\twhile(p){\n\t\tif(p&1LL) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tp>>=1LL;\n\t}\n\treturn res;\n}\nll n,k;\n\nint main() {\n\t#ifdef kvutxdy\n\tfreopen(\"C:/Users/khanh/OneDrive/RoadtoPurple/Code/Codeforces/input.in\", \"r\", stdin);\n\t#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcin>>n>>k;\n\tll res=0LL;\n\tif(n&1){\n\t\t(res+=fpow(k,(n+1LL)/2LL)*n%MOD)%=MOD;\n\t\tcout<<res;\n\t\treturn 0;\n\t}\n\tres=(fpow(k,n/2LL)-k+MOD*5LL)%MOD;\n\t(res*=n)%=MOD;\n\t(res*=fpow(2LL,MOD-2LL))%=MOD;\n\t(res+=k)%=MOD;\n\tcout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int md=1e9+7;\nint n,m,cc,a[10005],dp[10005],ans;\nint pw(int x,int b){int res=1;for(;b;b>>=1,x=1ll*x*x%md)if(b&1)res=1ll*res*x%md;return res;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0)\n\t{\n\t\ta[++cc]=i;\n\t\tif(i*i!=n)a[++cc]=n/i;\n\t}\n\tsort(a+1,a+cc+1);\n\tfor(int i=1;i<=cc;i++)\n\t{\n\t\tdp[i]=pw(m,(a[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)if(a[i]%a[j]==0)dp[i]=(dp[i]-dp[j]+md)%md;\n\t\tif(a[i]&1)ans=(ans+1ll*dp[i]*a[i]%md)%md;else ans=(ans+1ll*dp[i]*(a[i]/2)%md)%md;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint ans;\nint fastpow(int x,int a){\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\n \nint ys[50005],yscnt;\nint xs[50005];\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tys[++yscnt]=i;\n\t\t\tif(i*i!=n) ys[++yscnt]=n/i;\n\t\t}\n\t}\n\tsort(ys+1,ys+yscnt+1);\n\tfor(int i=1;i<=yscnt;i++){\n\t\tif(n%2==0&&ys[i]%2!=0) continue;\n\t\tans=(ans + fastpow(k,ys[i]%2==0? n/ys[i]:(n/ys[i]+1)/2)*1LL*(n/ys[i])%mod*(1-xs[i]) )%mod;\n\t\tfor(int j=i+1;j<=yscnt;j++) if(ys[j]%ys[i]==0) xs[j]=(xs[j]+ (1-xs[i])*1LL*(ys[j]/ys[i]))%mod;\n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 1e18;\nconst ll fact_table = 5000000;\ndouble Pi = 3.1415926535897932384626;\n \nvector<ll> G[550010];\nvector<pair<ll, double> > tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<\"\\n\";\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,f,g,h,w,i,j,q,r,l;\nll k,ans;\nll x[500005],y[500005],z[500005];\nbool used[500005];\nchar s[500005];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin >> n >> k;\n    ll cnt = rui(k, (n + 1) / 2);\n    if(n % 2 == 0){\n        cnt *= n / 2;\n        cnt %= mod;\n    }else{\n        cnt *= n;\n        cnt %= mod;\n    }\n    ll pair = (n + 1) / 2 - 1;\n    pair %= mod;\n    ll minus = pair * k;\n    minus %= mod;\n    minus = mod - minus;\n    cnt += minus;\n    cnt %= mod;\n    p(cnt);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll naive(ll n, ll k){\n    set<VI> st;\n    int m = (n + 1) / 2;\n    VI a(n);\n    REP(mask, powll(k, m)){\n        REP(i,m){\n            a[i] = (mask / powll(k, i)) % k;\n            a[n - 1 - i] = a[i];\n        }\n        VI b(n);\n        REP(s,n){\n            REP(i,n) b[i] = a[(i+s)%n];\n            st.insert(b);\n        }\n    }\n    return st.size();\n}\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n\n    // if (k <= 10){\n    //     cout << naive(n, k) << endl;\n    // }\n\n    VL factor;\n    for (ll x = 1; x * x <= n; ++x){\n        if (n % x == 0){\n            factor.push_back(x);\n            if (x * x != n) factor.push_back(n / x);\n        }\n    }\n    sort(ALL(factor));\n\n    int m = factor.size();\n    VL way(m);\n    ll ans = 0;\n\n    REP(i,m){\n        ll x = factor[i];\n        way[i] = powll(k, (x + 1) / 2);\n        REP(j,i){\n            if (x % factor[j] == 0){\n                way[i] = (way[i] - way[j] + mod) % mod;\n            }\n        }\n        ll tmp;\n        if (x % 2) tmp =  (way[i] * x) % mod;\n        else tmp = (way[i] * (x / 2)) % mod;\n        ans = (ans + tmp) % mod;\n        // cout << \"f \" << x << \"  \";\n        // cout << tmp << endl;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\tLL test = 0;\n\twhile(true) {\n\t\ttest++;\n\t\tif(test > 1000000) { return 1; }\n\t\t\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tLL i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i]++;\n\t}\n\t\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 1e9 + 7;\nll dp[2005]; \nvll divs;\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nint main(){\n\tll n, k; cin >> n >> k;\n\tfor (ll i = 1; i <= sqrt(n); i++){\n\t\tif (i == sqrt(n)){\n\t\t\tif (i * i == n) divs.pb(i);\n\t\t}\n\t\telse if (n % i == 0){\n\t\t\tdivs.pb(i); divs.pb(n / i);\n\t\t}\n\t}\n\tsort(divs.begin(), divs.end());\n\tfor (ll i = 0; i < divs.size(); i++){\n\t\tdp[i] = binpow(k, (divs[i] + 1) / 2);\n\t\tfor (ll j = 0; j < i; j++){\n\t\t\tif (divs[i] % divs[j] == 0) (dp[i] += (mod - dp[j])) %= mod;\n\t\t}\n \t}\n \tll ans = 0;\n \tfor (ll i = 0; i < divs.size(); i++){\n \t\tif (divs[i] % 2) (ans += (divs[i] * dp[i])) %= mod;\n \t\telse (ans += (divs[i] / 2 * dp[i])) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int mo = 1e9 + 7;\nusing namespace std;\nint pow(int x, int t){\n\tint res = 1;\n\twhile (t > 0){\n\t\tif (t & 1) res = 1ll * res * x % mo;\n\t\tx = 1ll * x * x % mo;\n\t\tt >>= 1;\n\t}\n\treturn res;\n}\nint n, k, dp[10001]; vector <int> p;\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i * i <= n; i++){\n\t\tif (n % i == 0){\n\t\t\tp.push_back(i);\n\t\t\tif (i * i != n) p.push_back(n / i);\n\t\t}\n\t}\n\tsort(p.begin(), p.end()); int ans = 0;\n\tfor (int i = 0; i < p.size(); i++){\n\t\tdp[i] = pow(k, (p[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (p[i] % p[j] == 0) dp[i] = (dp[i] - dp[j] + mo) % mo;\n\t\tans = (ans + dp[i] * (p[i] / (1 + (p[i] % 2 == 0))) % mo) % mo;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nint n, k;\nint getAll(int n) {\n    if (n % 2 == 1) {\n        return mult(n, pw(k, (n + 1) / 2));\n    }\n    else {\n        return mult(n / 2, pw(k, n / 2));\n    }\n}\nint val(int x, int y) {\n    if (x % 2 == 1) {\n        return pw(k, (x + 1) / 2);\n    }\n    if (y % 2 == 0) {\n        return pw(k, (x / 2) + 1);\n    }\n    else {\n        return pw(k, x / 2);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    vector < int > divs;\n    int pp = n;\n    if (n % 2 == 0) pp /= 2;\n    for (int i = 1; 1LL * i * i <= pp; i++) {\n        if (pp % i == 0) {\n            divs.emplace_back(i);\n            if (i != (pp / i)) divs.emplace_back(pp / i);\n        }\n    }\n    sort(divs.begin(), divs.end());\n    vector < int > calc(divs.size());\n    for (int i = 0; i < divs.size(); i++) {\n        calc[i] = divs[i];\n    }\n    for (int i = divs.size() - 1; i >= 0; i--) {\n        for (int j = i + 1; j < divs.size(); j++) {\n            if (divs[j] % divs[i] == 0) {\n                calc[i] = sub(calc[i], calc[j]);\n            }\n        }\n    }\n    /*int my_ans = 0;\n    map < int, int > he;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (mask == 0) continue;\n        int d = n;\n        int frst = -1;\n        int p = 0;\n        for (int bit = 0; bit < n; bit++) {\n            if (mask & (1 << bit)) {\n                p++;\n                if (frst == -1) frst = bit;\n                else {\n                    d = __gcd(d, abs(frst - bit));\n                }\n            }\n        }\n        int cur_ans = val(d, frst);\n        if (p % 2 == 1) {\n            my_ans = sum(my_ans, cur_ans);\n            he[d]++;\n        }\n        else {\n            my_ans = sub(my_ans, cur_ans);\n            he[d]--;\n        }\n\n    }\n    for (auto it : he) {\n        cout << it.first << \" \" << it.second << endl;\n    }\n    cout << \"-----------------\" << endl;\n    cout << \"I got \" << my_ans << endl;\n     */\n    int ans = 0;\n    for (int i = 0; i < divs.size(); i++) {\n        ans = sum(ans, mult(getAll(2 * divs[i]), mult(calc[i], pw(divs[i], mod - 2))));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nmap<int,int> f;\nvector<int> hve;\nint ans=0,n,k;\nint qpower(int a,int c){\n\tint re=1;\n\twhile (c){\n\t\tif (c&1) re=1ll*re*a%mod;\n\t\tc>>=1;a=1ll*a*a%mod;\n\t}\n\treturn re;\n}\nint solveit(int v){\n\tif (f.find(v)!=f.end()) return f[v];\n\tint re=qpower(k,(v+1)/2);\n\tfor (int i=1;i*i<=v;i++){\n\t\tif (v%i==0 && i!=v){\n\t\t\tre=(re-solveit(i)+mod)%mod;\n\t\t\tif (i!=1 && i*i!=v) re=(re-solveit(v/i)+mod)%mod;\n\t\t}\n\t}\n\tf[v]=re;\n\treturn re;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i*i<=n;i++){\n\t\tif (n%i==0){\n\t\t\thve.push_back(i);\n\t\t\tif (i*i!=n) hve.push_back(n/i);\n\t\t}\n\t}\n\tsort(hve.begin(),hve.end());\n\tfor (int i=0;i<hve.size();i++){\n\t\tint ff=solveit(hve[i]);\n\t\tans=(ans+1ll*ff*((hve[i]&1)?hve[i]:hve[i]/2)%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct _IO{_IO(){ios::sync_with_stdio(0);cin.tie(0);}}_io;\n\ntypedef long long ll;\ntypedef long double db;\ntypedef unsigned long long ull;\ntypedef vector<int> vi; typedef vector<vi> vii;\ntypedef pair<int, int> pi;\ntypedef tuple<int, int, int> t3;\ntypedef map<int, int> mi;\n#define fi first\n#define se second\n#define vt vector\n#define be begin()\n#define ed end()\n#define sz size()\n#define cl clear()\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define lb(v, x) lower_bound(v.begin(), v.end(), x)\n#define lbi(v, x) (lb(v, x) - v.begin())\n#define tp(t, x, y) t x, y; tie(x, y)\n#define tp3(t, x, y, z) t x, y, z; tie(x, y, z)\n#define mp make_pair\n#define mt make_tuple\n#define co const\n#define fc(x) for(int x = 1, _end = ri(); x <= _end; x++)\nvoid uni(vi &v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\n\ndb rd() { db x; cin >> x; return x; }\nll ri() { ll x; cin >> x; return x; }\nstring rs() { string s; cin >> s; return s; }\npi rpi() { pi x; cin >> x.fi >> x.se; return x; }\nvi rvi(int n, int f = 0) { vi v(n + f); for (int i = f; i < v.size(); i++) cin >> v[i]; return v; }\nvii rvii(int n, int m, int f = 0) { vii v(n + f, vi(n + f)); for (int i = f; i < v.size(); i++) for (int j = f; j < v[0].size(); j++) cin >> v[i][j]; return v; }\nvoid pr() {}; template <class T, class ...U> void pr(T x, U ...y) { cout << x << ' ', pr(y...); }\nvoid prl() { cout << '\\n'; }; template <class T, class ...U> void prl(T x, U ...y) { cout << x << ' ', prl(y...); }\nvoid pr(const vi &v, int f = 0) { for (int i = f; i < v.size(); i++) cout << v[i] << ' '; }\nvoid prl(const vi &v, int f = 0) { pr(v, f); cout << '\\n'; }\nvoid pr(const pi &x) { cout << x.fi << ' ' << x.se; };\nvoid prl(const pi &x) { pr(x); cout << '\\n'; }\n\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n\nconst int N = 2e5 + 5, M = 1e9 + 7;\n\nll qpow(ll x, ll n) {\n  ll res = 1;\n  for (; n; n >>= 1, x = x * x % M) if (n & 1) res = res * x % M;\n  return res;\n}\n\nint main() {\n  ll n = ri(), k = ri();\n  vi a;\n  for (ll i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      a.pb(i);\n      if (n / i != i) a.pb(n / i);\n    }\n  }\n  sort(all(a));\n  vt<ll> dp(a.sz);\n  ll ans = 0;\n  rep(i, 0, a.sz) {\n    dp[i] = qpow(k, (a[i] + 1) / 2);\n    rep(j, 0, i) {\n      if (a[i] % a[j] == 0) {\n        dp[i] = (dp[i] - dp[j]) % M;\n      }\n      dp[i] = (dp[i] + M) % M;\n    }\n    if (a[i] & 1) ans = (ans + dp[i] * a[i]) % M;\n    else ans = (ans + dp[i] * a[i] / 2) % M;\n  }\n  pr(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) 0;\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n// using mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\ntemplate < class Value >\ninline auto divisors(Value x) {\n  std::vector< Value > ret;\n  std::stack < Value > stk;\n  for (Value i = 1; i * i <= x; i++) {\n    if (x % i == 0) {\n      ret.emplace_back(i);\n      if (i * i < x)\n        { stk.emplace(x / i); }\n    }\n  }\n  while (!stk.empty())\n    { ret.emplace_back(stk.top()), stk.pop(); }\n  return ret;\n}\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, k; std::cin >> n >> k;\n  std::vector< int > divs = divisors(n);\n  debug(divs);\n  std::map< int, mint > dp;\n  for (int d : divs) {\n    mint now = power(mint{k}, (d+1)/2);\n    dp[d] = now;\n  }\n  debug(dp);\n  for (int d : divs) for (int e : divs) {\n    if (d == e || e % d != 0) continue;\n    dp.at(e) -= dp.at(d);\n  }\n  for (int d : divs) {\n    dp.at(d) *= d;\n    if (d % 2==0) dp.at(d) /= 2;\n    dp[d] = dp.at(d);\n  }\n  debug(dp);\n  mint ans = 0;\n  for (int d : divs) {\n    ans += dp.at(d);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nll half = (mod+1)/2;\nll n, K;\n\n\nll pow_mod(ll a, ll r, ll m = mod){\n\tll x = 1;\n\twhile(r){\n\t\tif(r&1) (x*=a)%=m;\n\t\t(a*=a)%=m;\n\t\tr>>=1;\n\t}\n\treturn x;\n}\n\n#define N 2000\nll dp[N];\n\nint main(){\n\tcin>>n>>K;\n\tll res = 0;\n\tvector<ll> v;\n\tfor(ll i = 1; i*i <= n; i++){\n\t\tif(n%i) continue;\n\t\tv.pb(i);\n\t\tif(i*i!=n) v.pb(n/i);\n\t}\n\tsort(all(v));\n\tint m = v.size();\n\trep(i, m){\n\t\tdp[i] = pow_mod(K, (v[i]+1)/2);\n\t\trep(j, i) if(v[i]%v[j]==0) dp[i] -= dp[j];\n\t\tdp[i] = (dp[i]%mod+mod)%mod;\n\t\t(res+=dp[i]*(v[i]%2?1:half)%mod*v[i]%mod)%=mod;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 1e5 + 5;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, k, ans, f[N], stk[N], top; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1;\n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod;\n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> (), m = read <int> (), k = (n + 1) / 2; \n\tfor(int i = 1; i * i <= n; i++)\n\t\tif(n % i == 0)\n\t\t{\n\t\t\tstk[++top] = i; \n\t\t\tif(i * i != n) stk[++top] = n / i; \n\t\t}\n\tsort(stk + 1, stk + top + 1); \n\tfor(int x, i = 1; i <= top; i++) x = (stk[i] + 1) / 2, f[i] = fpow(m, x); \n\tfor(int i = 1; i <= top; i++)\n\t\tfor(int j = i + 1; j <= top; j++)\n\t\t\tif(stk[j] % stk[i] == 0) f[j] = (f[j] - f[i] + mod) % mod; \n\tfor(int i = 1; i <= top; i++)\n\t{\n\t\tif(stk[i] & 1) ans = (1ll * f[i] * stk[i] + ans) % mod;\n\t\telse ans = (1ll * f[i] * (stk[i] / 2) + ans) % mod; \n\t}\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5,mo=1e9+7;\n\nint n,o,p;\nll f[N],a[N],k;\n\nll ksm(ll o,ll t)\n{\n\tll y=1;\n\tfor(;t;t>>=1,o=o*o%mo)\n\tif(t&1)y=y*o%mo;\n\treturn y;\n}\n\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;++i)\n\tif(n%i==0){\n\t\ta[++o]=i;\n\t\tif(i*i%n)a[++o]=n/i;\n\t}\n\tsort(a+1,a+o+1); \n\tll ans=0;\n\tfo(i,1,o){\n\t\tf[i]=ksm(k,(a[i]+1)>>1);\n\t\tfo(l,1,i-1)if(a[i]%a[l]==0)f[i]=(f[i]-f[l]+mo)%mo;\n\t\t(a[i]&1)?ans=(ans+f[i]*a[i])%mo:ans=(ans+(f[i]*a[i]>>1))%mo;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct NumberTheory\n{\n\tvector<ll> primes;\n\tvector<bool> prime;\n\tvector<ll> totient;\n\tvector<ll> sumdiv;\n\tvector<ll> bigdiv;\n\tvoid Sieve(ll n)\n\t{\n\t\tprime.assign(n+1, 1);\n\t\tprime[1] = false;\n\t\tfor(ll i = 2; i <= n; i++)\n\t\t{\n\t\t\tif(prime[i])\n\t\t\t{\n\t\t\t\tprimes.pb(i);\n\t\t\t\tfor(ll j = i*2; j <= n; j += i)\n\t\t\t\t{\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll phi(ll x)\n\t{\n\t\tmap<ll,ll> pf;\n\t\tll num = 1; ll num2 = x;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tif(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tnum2/=primes[i];\n\t\t\t\tnum*=(primes[i]-1);\n\t\t\t}\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tpf[primes[i]]++;\n\t\t\t}\n\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tpf[x]++; num2/=x; num*=(x-1);\n\t\t}\n\t\tx = 1;\n\t\tnum*=num2;\n\t\treturn num;\n\t}\n\t\n\tint mobius(ll x)\n\t{\n\t\tint ans=1;\n\t\tfor(ll i = 0; primes[i]*primes[i] <= x; i++)\n\t\t{\n\t\t\tint cnt=0;\n\t\t\twhile(x%primes[i]==0)\n\t\t\t{\n\t\t\t\tx/=primes[i];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(cnt>=2) return 0;\n\t\t\tif(cnt==1) ans*=-1;\n\t\t}\n\t\tif(x>1) ans*=-1;\n\t\treturn ans;\n\t}\n};\n\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nmap<int,vi> D;\nmap<int,int> phimap;\nmap<int,int> mobiusmap;\t\nNumberTheory nt;\n\nint phi(int x)\n{\n\tif(phimap.find(x)==phimap.end()) return (phimap[x]=nt.phi(x));\n\treturn phimap[x];\n}\n\nint mobius(int x)\n{\n\tif(mobiusmap.find(x)==mobiusmap.end()) return (mobiusmap[x]=nt.mobius(x));\n\treturn mobiusmap[x];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,k; cin>>n>>k;\n\tnt.Sieve(100011);\n\tvector<int> divi;\n\tfor(int d=1;d*d<=n;d++)\n\t{\n\t\tif(n%d==0)\n\t\t{\n\t\t\tdivi.pb(d);\n\t\t\tif(d*d!=n) divi.pb(n/d);\n\t\t}\n\t}\n\tsort(divi.begin(),divi.end());\n\tfor(int x:divi)\n\t{\n\t\tfor(int y:divi)\n\t\t{\n\t\t\tif(x%y==0) D[x].pb(y);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int d:divi)\n\t{\n\t\t//minimal period = d\n\t\tint res = 0;\n\t\tfor(int v:D[d])\n\t\t{\n\t\t\tres = add(res, mult(MOD+mobius(d/v),modpow(k,(v+1)/2)));\n\t\t}\n\t\tif(d%2==0) res=mult(res,modpow(2,MOD-2));\n\t\tres=mult(res,d);\n\t\tans=add(ans,res);\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\nconst int mod=1e9+7;\nll quick(ll a,ll b)\n{\n\tll ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\nconst int maxn=1e5+7;\nll kd[maxn];\nint main()\n{\n\tint n,k;\n\tcin>>n>>k;\n\tvi fac;\n\tfor(int i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tfac.push_back(i);\n\t\t\tif(i*i!=n) fac.push_back(n/i);\n\t\t}\n\t}\n\tsort(fac.begin(),fac.end());\n\tll ans=0;\n\tfor(int i=0;i<fac.size();i++)\n\t{\n\t\tint c=fac[i];\n\t\tif(n&1)\n\t\t\tkd[i]=quick(k,c/2+1);\n\t\telse{\n\t\t\tif(n/2%c==0)\n\t\t\t\tkd[i]=quick(k,c);\n\t\t\telse kd[i]=quick(k,c/2);\n\t\t}\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(fac[i]%fac[j]==0) kd[i]=(kd[i]-kd[j]+mod)%mod;\n\t\tans+=kd[i]*c%mod;\n\t\tans%=mod;\n\t//\tdbg(i,kd[i],c,ans);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int P=1000000007;\n\nvector<int> f,d;\nint n,K,ans;\n\ninline int quick_power(int x,int y)\n{\n\tint ret=1;\n\tfor (;y;y>>=1,x=1ll*x*x%P) if (y&1) ret=1ll*ret*x%P;\n\treturn ret;\n}\n\nvoid generate_state()\n{\n\tfor (int x=1;x*x<=n;++x)\n\t\tif (!(n%x))\n\t\t{\n\t\t\td.push_back(x);\n\t\t\tif (x*x!=n) d.push_back(n/x);\n\t\t}\n\tsort(d.begin(),d.end()),f.reserve(d.size());\n}\n\ninline void update(int &x,int y){(x+=y)%=P;}\n\nvoid dp()\n{\n\tfor (int i=0;i<(int)d.size();++i)\n\t{\n\t\tf[i]=quick_power(K,d[i]+1>>1);\n\t\tfor (int j=0;j<i;++j) if (!(d[i]%d[j])) update(f[i],P-f[j]);\n\t\tif (d[i]&1) update(ans,1ll*f[i]*d[i]%P);\n\t\telse update(ans,1ll*f[i]*(d[i]>>1)%P);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"rotpal.in\",\"r\",stdin),freopen(\"rotpal.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&K),generate_state(),dp(),printf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\n#include <unordered_set>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n\nint main() {\n    long long N, K;\n    cin >> N >> K;\n    long long result = 1;\n    for (int i = 0; i < (N + 1) / 2; ++i) {\n        result = (result * K) % 1000000007;\n    }\n    long long n = (1000000007 + result - K) % 1000000007;\n    if ((N & 1) == 1) {\n        result = (result + (n * ((N - 1) % 1000000007)) % 1000000007) % 1000000007;\n    } else {\n        result = (result + (n * ((N / 2 - 1) % 1000000007)) % 1000000007) % 1000000007;\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long modPow(int a, int p){\n\tif(p == 0) return 1;\n\tlong long res = modPow(a, p/2);\n\tres *= res;\n\tres %= MOD;\n\tif(p%2){\n\t\tres *= a;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, K;\n\twhile(cin >> N >> K){\n\t\tif(N == 1){\n\t\t\tcout << K << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> d;\n\t\tfor(int i=1;i*i<=N;++i){\n\t\t\tif(N%i == 0){\n\t\t\t   d.push_back(i);\n\t\t\t   if(N/i != i) d.push_back(N/i);\n\t\t\t}\n\t\t}\n\t\tsort(d.begin(), d.end());\n\t\tvector<long long> num(d.size(), 0);\n\t\tlong long res = 0;\n\t\tfor(int i=0;i<d.size();i++){\n\t\t\tlong long cycle = d[i];\n\t\t\tnum[i] = modPow(K, (cycle+1)/2);\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(cycle%d[j] == 0) num[i] = (num[i]+MOD-num[j])%MOD;\n\t\t\t}\n\t\t\tif(cycle%2 == 0) cycle /= 2;\n\t\t\tres += num[i] * cycle;\n\t\t\tres %= MOD;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\n#define mod 1000000007\nint n,k,ans,dp[1001000],p[1001000],cnt;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y==1)return x;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\tif(y%2==1)return quickpow(x*x%mod,y/2)*x%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\tp[++cnt]=i;;\n\t\t\tif(i*i!=n)p[++cnt]=n/i;\n\t\t}\n\tstd::sort(p+1,p+cnt+1);\n\tfor(int i=1;i<=cnt;i++){\n\t\tdp[i]=quickpow(k,(p[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(p[i]%p[j]==0)dp[i]=(dp[i]-dp[j]+mod)%mod;\n\t\tif(p[i]%2==0)(ans+=dp[i]*p[i]/2%mod)%=mod;\n\t\telse(ans+=dp[i]*p[i]%mod)%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int maxn = 1e5 + 5;\nconst int mod = 1e9 + 7;\nll ksm (ll a , ll b)\n{\n    ll ans = 1 , base = a;\n    while (b){\n        if (b & 1) ans = ans * base % mod;\n        b >>= 1;\n        base = base * base % mod;\n    }\n    return ans;\n}\nll n , k;\nvector<ll> fact;\nll dp[50005];\nll getans (ll x){\n    return ksm(k , (x - 1) / 2 + 1);\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >> n >> k;\n    ll ans = 0;\n    for (ll i = 1 ; i * i <= n ; i++){\n        if (n % i == 0){\n            fact.push_back(i);\n            if (i != n / i)\n                fact.push_back(n / i);\n        }\n    }\n    sort(fact.begin() , fact.end());\n    int m = fact.size();\n    for (int i = 0 ; i < m ; i++) dp[i] = getans(fact[i]);\n    for (int i = 0 ; i < m ; i++){\n        // 容斥掉重复部分\n        for (int j = 0 ; j < i ; j++)\n            if (fact[i] % fact[j] == 0)\n                dp[i] = (dp[i] - dp[j] + mod) % mod;\n        if (fact[i] & 1) ans = (ans + dp[i] * fact[i]) % mod;\n        else ans = (ans + dp[i] * (fact[i] / 2)) % mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nint n,m,cnt,sum,a[100005],ans[100005];\nint ksm(int x,int y){\n\tint z=1; for (; y; y>>=1,x=(ll)x*x%mod) if (y&1) z=(ll)z*x%mod;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif (n&1){\n\t\tprintf(\"%lld\\n\",((ll)(ksm(n+1>>1,m)-m+mod)*n+m)%mod);\n\t\treturn 0;\n\t}\n\tint i,j; n/=2;\n\tfor (i=1; i*i<=n; i++) if (!(n%i)){\n\t\ta[++cnt]=i;\n\t\tif (i*i<n) a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\tfor (i=1; i<=cnt; i++){\n\t\tans[i]=(ans[i]+ksm(m,a[i]))%mod;\n\t\tsum=(sum+(ll)ans[i]*a[i])%mod;\n\t\tfor (j=i+1; j<=cnt; j++) if (!(a[j]%a[i])) ans[j]=(ans[j]+mod-ans[i])%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i = (a); i <= (b); i++)\n#define FORD(i,a,b) for (int i = (a); i >= (b); i--)\n#define REP(i,a) FOR(i,0,(int)(a)-1)\n#define reset(a,b) memset(a,b,sizeof(a))\n#define BUG(x) cout << #x << \" = \" << x << endl\n#define mod 1000000007\n#define pi acos(-1)\n#define eps 0.00000001deployed\n#define pb push_back\n#define sqr(x) (x) * (x)\n#define _1 first\n#define _2 second\n\nlong long n, k;\n\nlong long expo(long long a, long long b) {\n  long long ret = 1;\n  FORD (i, 50, 0) {\n    ret *= ret;\n    ret %= mod;\n    if ((1ll << i) & b) {\n      ret *= a;\n      ret %= mod;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> k;\n  n = (n + 1) / 2;\n  long long ans = expo(k, n) + mod - k;\n  ans = (ans * k) + k;\n  cout << ans % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint primecnt(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\treturn ans;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tcout << modpow(k, (n + 1) / 2) << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tif ((primecnt(i.first / j.first)) % 2 == 0) {\n\t\t\t\t\tcnt += j.second;\n\t\t\t\t\tif (cnt > mod) cnt -= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcnt -= j.second;\n\t\t\t\t\tif (cnt < 0) cnt += mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod (1000000007)\n#define rv2 (500000004)\n\nint N, K;\nstd::map<int, int> d;\nstd::set<int> set;\n\nint powmod(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1) ret = (1ll) * ret * a % mod;\n\t\tb >>= 1;\n\t\ta = (1ll) * a * a % mod;\n\t}\n\treturn ret;\n}\n\nint get_d(int i){\n\tint ret = powmod(K, (i + 1) / 2);\n\tfor(int j = 1; j * j <= i; ++ j){\n\t\tif(i % j || j == i) continue;\n\t\tret = (ret - d[j] + mod) % mod;\n\t\tif(i / j == j || i / j == i) continue;\n\t\tret = (ret - d[i / j] + mod) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &K);\n\tint ans = 0;\n\tfor(int i = 1; i * i <= N; ++ i){\n\t\tif(N % i) continue;\n\t\tset.insert(i);\n\t\tset.insert(N / i);\n\t}\n\tfor(auto i : set){\n\t\td[i] = get_d(i);\n\t\tif(i % 2) ans = (ans + (1ll) * d[i] * i % mod) % mod;\n\t\telse ans = (ans + (1ll) * d[i] * i % mod * rv2 % mod) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MOD 1000000007\nusing namespace std;\n\nint power(int x,int y){\n\tif(!y) return 1;\n\tint res = power(x * x % MOD,y / 2);\n\tif(y % 2) res = res * x % MOD;\n\treturn res;\n}\n\nsigned main(){\n\tint n,k,ans = 0,cnt[10000] = {};\n\tvector<int> yaku;\n\tcin >> n >> k;\n\tfor(int i = 1;i * i <= n;i++){\n\t\tif(n % i == 0){\n\t\t\tyaku.push_back(i);\n\t\t\tif(i != n / i) yaku.push_back(n / i);\n\t\t}\n\t}\n\tsort(yaku.begin(),yaku.end());\n\tfor(int i = 0;i < yaku.size();i++){\n\t\tint tmp = power(k,(yaku[i] + 1) / 2);\n\t\tfor(int j = 0;j < i;j++){\n\t\t\tif(yaku[i] % yaku[j] == 0) tmp = (tmp - cnt[j] + MOD) % MOD;\n\t\t}\n\t\tcnt[i] = tmp;\n\t\tif(yaku[i] % 2) (ans += tmp * yaku[i]) %= MOD;\n\t\telse (ans += tmp * yaku[i] / 2) %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nll pw(ll n, ll m){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nll inv(ll n){\n\treturn pw(n, mod - 2);\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n, k; cin >> n >> k;\n\tset<int> d;\n\tfor(int i = 1; i * i <= n; i++) if(n % i == 0){\n\t\td.insert(i);\n\t\td.insert(n / i);\n\t}\n\tll ans = 0;\n\tmap<int, int> cnt;\n\tfor(int i : d){\n\t\tif(i % 2) cnt[i] = pw(k, i / 2 + 1);\n\t\telse cnt[i] = pw(k, i / 2);\n\t}\n\t\n\tfor(auto &i: cnt){\n\t\tfor(auto j : cnt){\n\t\t\tif(i.first <= j.first) break;\n\t\t\tif(i.first % j.first == 0) i.second = (i.second + mod - j.second) % mod;\n\t\t}\n\t\tll x = i.second * (ll)i.first % mod;\n\t\tans += i.first % 2 ? x : x * inv(2) % mod;\n\t}\n\tcout << ans % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,k,a[N],tot,dp[N];\ninline int ksm(int d,int tk){int ret=1;while(tk){if(tk&1)ret=1ll*ret*d%p;d=1ll*d*d%p;tk>>=1;}return ret;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i*i<=n;i++)if(n%i==0)\n    {\n    \ta[++tot]=i;if(i*i!=n)a[++tot]=n/i;\n\t}\n\tsort(a+1,a+1+tot);int ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tdp[i]=ksm(k,(a[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)if(a[i]%a[j]==0)dp[i]=(dp[i]-dp[j]+p)%p;\n\t\tif(a[i]%2==0)ans=(ans+1ll*dp[i]*(a[i]/2)%p)%p;\n\t\telse ans=(ans+1ll*dp[i]*a[i]%p)%p;\n\t}printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+100;\nconst int P = 1e9+7;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n#define div div1234567891\n\nint n,k;\nint val[N];\n\ninline int pow_mod(int x,int k){\n   int res = 1,base = x;\n   while(k){\n      if(k&1)res = 1LL*res*base%P;\n      k >>= 1; base = 1LL*base*base%P;\n   }\n   return res;\n}\n\nmap<int,int> vis;\nvector<int> div;\n\ninline void add(int &x,int y){\n   x += y; if(x >= P)x -= P;\n}\n\nint main(){\n   scanf(\"%d%d\",&n,&k);\n   int w = (int)sqrt(n);\n   fr(i,1,w){\n      if(n%i == 0)div.push_back(i);\n   }\n   nfr(i,w,1){\n      if(i*i != n && n%i == 0)div.push_back(n/i);\n   }\n\n   int ans = 0;\n   int sz = div.size()-1;\n   fr(i,0,sz){\n      int cur = div[i];\n      val[i] = pow_mod(k,(cur+1)/2);\n      fr(j,0,i-1){\n         if(div[i]%div[j] == 0)add(val[i],P-val[j]);\n      }\n      add(ans,1LL*val[i]*(cur%2 == 0 ? cur/2 : cur)%P);\n   }\n   printf(\"%d\\n\",ans);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e3+10,mod=1e9+7;\nint f[maxn],num[maxn],tmp;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"f.in\",\"r\",stdin);\n\tfreopen(\"f.out\",\"w\",stdout);\n#endif\n\tint n=read(),m=read();\n\tfor(int i=1;(ll)i*i<=n;++i) if(n%i==0){\n\t\tnum[++tmp]=i;\n\t\tif(i*i!=n) num[++tmp]=n/i;\n\t}\n\tsort(num+1,num+tmp+1);\n\tint ans=0;\n\tREP(i,1,tmp){\n\t\tf[i]=(f[i]+ksm(m,(num[i]+1)/2))%mod;\n\t\tREP(j,i+1,tmp) if(num[j]%num[i]==0) f[j]=(f[j]+mod-f[i])%mod;\n\t\tans=(ans+(ll)f[i]*num[i]%mod*((num[i]&1)?1:((mod+1)/2)))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=1e5+5,Mo=1e9+7;\n\nint pwr(int x,int y) {\n\tint z=1;\n\tfor(;y;y>>=1,x=(ll)x*x%Mo)\n\t\tif (y&1) z=(ll)z*x%Mo;\n\treturn z;\n}\n\nint n,k,a[N],tot,ans,f[N];\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tint m=sqrt(n);\n\tfo(i,1,m) \n\t\tif (!(n%i)) {\n\t\t\ta[++tot]=i;\n\t\t\tif (i*i!=n) a[++tot]=n/i;\n\t\t}\n\tsort(a+1,a+tot+1);\n\tint inv=pwr(2,Mo-2);\n\tfo(i,1,tot) {\n\t\tf[i]=pwr(k,(a[i]+1)/2);\n\t\tfo(j,1,i-1) if (!(a[i]%a[j])) (f[i]+=Mo-f[j])%=Mo;\n\t\tif (a[i]&1) (ans+=(ll)f[i]*a[i]%Mo)%=Mo;\n\t\telse (ans+=(ll)f[i]*a[i]%Mo*inv%Mo)%=Mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n//nCr mod m\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b,ll m=MOD){\n\tll out=1;\n\tll p=a%m;\n\twhile(b){\n\t\tif(b&1)out=out*p%m;\n\t\tp=p*p%m;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\nsigned main(){\n\tint n,k;\n\tcin>>n>>k;\n\tint out=0;\n\tvi y;\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\ty.pb(i);\n\t\tif(i-n/i)y.pb(n/i);\n\t}\n\tsort(all(y));\n\tvi dp(y.size());\n\trep(i,y.size()){\n\t\tint sum=powmod(k,(y[i]+1)/2);\n\t\trep(j,i)if(y[i]%y[j]==0)\n\t\t\t(sum+=MOD-dp[j])%=MOD;\n\t\tdp[i]=sum;\n\t}\n\t\n\trep(i,dp.size()){\n\t\tint t=y[i];\n\t\tif(t%2==0)t/=2;\n\t\t(out+=dp[i]*t%MOD)%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// C++(GCC 9.2.1)\n// 解き直し.\n// https://img.atcoder.jp/arc064/editorial.pdf\n// ① 1_27.txt, 1_28.txt, 1_30.txt, 1_31.txt で, WA版となったため, ロジック修正.\n// -> d[i] / 2 は d[i] * 500000004 % MOD に 修正 -> 最終的に, もとに戻した.\n// ② 1_27.txt で, WA版となったため, ロジック修正.\n// -> mPow の 第二引数が, 切り捨てだったものを, 切り上げに修正.\n// ③ 2. 例外. を 廃止.\n// -> ② の 修正でカバーできるため.\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define all(x) x.begin(), x.end()\nconst LL MOD = 1e9 + 7;\n\n// 与えられた正の整数のすべての約数を抽出.\n// @param X: 約数を抽出したい正の整数.\n// @return ret: すべての約数.\nvector<LL> div(LL X){\n    vector<LL> ret;\n    ret.pb(1);\n    for(LL d = 2; d * d <= X; d++){\n        if(X % d == 0){\n            ret.pb(d);\n            if(d * d != X) ret.pb(X / d);\n        }\n    }\n    if(X > 1) ret.pb(X);\n    sort(all(ret));\n    return ret;\n}\n\n// Fermat's little theorem から, 大きな冪乗の計算を行う.\n// @param a: べき乗したい正整数.\n// @param b: 指数.\n// @return:  べき乗した計算結果(mod版).\nLL mPow(LL a, LL b){\n    LL t = 1;\n    while(b){\n        if(b & 1) t = (t * a) % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return t % MOD;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    LL N, K;\n    scanf(\"%lld %lld\", &N, &K);\n    \n    // 2. 例外.\n    // if(N == 1){\n    //     printf(\"%lld\\n\", K);\n    //     return 0;\n    // }\n    \n    // 3. N の 約数.\n    vector<LL> d = div(N);\n    // for(auto &p : d) printf(\"%lld \", p);\n    // puts(\"\");\n    \n    // 4. 各最小周期に対応する数列の個数.\n    int l = d.size();\n    LL num[l];\n    memset(num, 0, sizeof(num));\n    rep(i, l){\n        // num[i] = mPow(K, d[i] / 2);\n        // num[i] = mPow(K, d[i] * 500000004 % MOD);\n        num[i] = mPow(K, (d[i] + 1) / 2);\n        rep(j, i){\n            if(d[i] % d[j] == 0) num[i] = (num[i] + MOD - num[j]) % MOD;\n        }\n    }\n    \n    // 5. 解答を求めるための数式を計算.\n    LL ans = 0, nd;\n    rep(i, l){\n        // nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        // nd = (d[i] & 1) ? d[i] : (d[i] * 500000004 % MOD);\n        nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        ans += num[i] * nd;\n        ans %= MOD;\n    }\n    \n    // 6. 出力.\n    printf(\"%lld\\n\", ans);\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=1005;\nconst int MOD=1000000007;\n\nint n,k,tot,a[N],f[N];\n\nint ksm(int x,int y)\n{\n\tint ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=(LL)ans*x%MOD;\n\t\tx=(LL)x*x%MOD;y>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t{\n\t\t\ta[++tot]=i;\n\t\t\tif (i*i<n) a[++tot]=n/i;\n\t\t}\n\tsort(a+1,a+tot+1);\n\tint ny2=ksm(2,MOD-2),ans=0;\n\tfor (int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=ksm(k,(a[i]+1)/2);\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]%a[j]==0) (f[i]+=MOD-f[j])%=MOD;\n\t\tif (a[i]&1) (ans+=(LL)f[i]*a[i]%MOD)%=MOD;\n\t\telse (ans+=(LL)f[i]*a[i]%MOD*ny2%MOD)%=MOD;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MOD = 1e9 + 7;\n\nint N, K;\n\nLL fpm(LL base, LL exp)\n{\n    LL ret = 1;\n    for (; exp; exp >>= 1) {\n        if (exp & 1)\n            (ret *= base) %= MOD;\n        (base *= base) %= MOD;\n    }\n    return ret;\n}\n\nvoid input()\n{\n    read(N); read(K);\n}\n\nvoid solve()\n{\n    vector<int> val;\n\n    for (int i = 1; i * i <= N; ++i) {\n        if (N % i == 0) {\n            val.push_back(i);\n            if (N / i != i)\n                val.push_back(N / i);\n        }\n    }\n    std::sort(ALL(val));\n\n    vector<LL> dp;\n    LL ans = 0;\n\n    for (int i = 0; i < SZ(val); ++i) {\n        dp.push_back(fpm(K, (val[i] + 1) / 2));\n        for (int j = 0; j < i; ++j) {\n            if (val[i] % val[j] == 0)\n                (dp[i] -= dp[j]) %= MOD;\n        }\n        if (val[i] & 1)\n            (ans += dp[i] * val[i]) %= MOD;\n        else\n            (ans += dp[i] * val[i] / 2) %= MOD;\n    }\n    (ans += MOD) %= MOD;\n\n    printf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n}\n\n// 上窗风动竹，月微明。\n//     -- 吕渭老《小重山·七夕病中》\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define ll long long\n#define mod 1000000007LL\n \nll h[100010],f[100010],n,k,tot,ans;\n \ninline ll rd()\n{\n    ll x=0;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar());\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x;\n}\n \ninline ll ksm(ll x,ll y) { ll res=1LL;for (;y;x=x*x%mod,y>>=1) if (y&1) res=res*x%mod;return res; }\n \nint main()\n{\n    n=rd();k=rd();tot=0;\n    int sqrtn=(int)sqrt(n);\n    for (int i=1;i<=(int)sqrt(n);i++) if (n%i==0) h[++tot]=i;\n    if (n==sqrtn*sqrtn)\n    {\n        for (int i=1;i<tot;i++) h[tot*2-i]=n/h[i];\n        tot=tot*2-1;\n    }\n    else\n    {\n        for (int i=1;i<=tot;i++) h[tot*2-i+1]=n/h[i];\n        tot<<=1;\n    }\n    f[1]=ans=k;\n    for (int i=2;i<=tot;i++)\n    {\n        f[i]=ksm(k,(ll)((h[i]+1)>>1));\n        for (int j=1;j<i;j++) if (h[i]%h[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n        if (h[i]&1) ans=(ans+f[i]*h[i])%mod;\n        else ans=(ans+f[i]*(h[i]>>1))%mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 1e9 + 7;\nll dp[2005]; \nvll divs;\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nint main(){\n\tll n, k; cin >> n >> k;\n\tfor (ll i = 1; i <= sqrt(n); i++){\n\t\tif (i == sqrt(n)){\n\t\t\tif (i * i == n) divs.pb(i);\n\t\t}\n\t\telse if (n % i == 0){\n\t\t\tdivs.pb(i); divs.pb(n / i);\n\t\t}\n\t}\n\tsort(divs.begin(), divs.end());\n\tfor (ll i = 0; i < divs.size(); i++){\n\t\tdp[i] = binpow(k, (divs[i] + 1) / 2);\n\t\tfor (ll j = 0; j < i; j++){\n\t\t\tif (divs[i] % divs[j] == 0) (dp[i] += (mod - dp[j])) %= mod;\n\t\t}\n \t}\n \tll ans = 0;\n \tfor (ll i = 0; i < divs.size(); i++){\n \t\tif (divs[i] % 2) (ans += (divs[i] * dp[i])) %= mod;\n \t\telse (ans += (divs[i] / 2 * dp[i])) %= mod;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\nnamespace combinatorics\n{\n\tint *fac;\n\tint *ifac;\n\tint __Tmod;\n\tinline int add(int a,int b)\n\t{\n\t\treturn (a+b)%__Tmod;\n\t}\n\tinline int sub(int a,int b)\n\t{\n\t\treturn (a-b+__Tmod)%__Tmod;\n\t}\n\tinline int mult(int a,int b)\n\t{\n\t\treturn (1LL*a*b)%__Tmod;\n\t}\n\tinline int fastpow(int basic,int x)\n\t{\n\t\tint res=1;\n\t\twhile(x)\n\t\t{\n\t\t\tif(x&1)\tres=mult(res,basic);\n\t\t\tbasic=mult(basic,basic);\n\t\t\tx>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline int inv(int x)\n\t{\n\t\treturn fastpow(x,__Tmod-2);\n\t}\n\tvoid init(int n,int tmod)\n\t{\n\t\t__Tmod=tmod;\n\t\tfac=new int[n+5];\n\t\tifac=new int[n+5];\n\t\tfac[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfac[i]=mult(fac[i-1],i);\n\t\t}\n\t\tifac[n]=inv(fac[n]);\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tifac[i]=mult(ifac[i+1],i+1);\n\t\t}\n\t}\n\tinline int C(int n,int m)\n\t{\n\t\treturn mult(mult(fac[n],ifac[m]),ifac[n-m]);\n\t}\n\tinline int Cat(int x)\n\t{\n\t\treturn mult(C(x*2,x),inv(x+1));\n\t}\n};\nusing namespace combinatorics;\nnamespace factorization\n{\n\tstd::vector <int> getfactors(int x)\n\t{\n\t\tstd::vector <int> vec;\n\t\tfor(int i=1;i*i<=x;i++)\n\t\t{\n\t\t\tif(x%i==0)\n\t\t\t{\n\t\t\t\tvec.push_back(i);\n\t\t\t\tif(i!=x/i) vec.push_back(x/i);\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\treturn vec;\n\t}\n};\nusing namespace factorization;\n\n\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nconst int mod=1e9+7;\nusing namespace std;\nint n,k;\nmap <int,int> m;\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n>>k;\n\tinit(0,mod);\n\tvector <int> vec=getfactors(n);\n\tint res=0;\n\tfor(auto len:vec)\n\t{\n\t\tint &s=m[len];\n\t\tif(len&1)\n\t\t{\n\t\t\ts=fastpow(k,(len+1)/2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts=fastpow(k,len/2);\n\t\t}\n\t\tvector <int> v=getfactors(len);\n\t\tfor(auto x:v)\n\t\t{\n\t\t\tif(x==len) continue;\n\t\t\ts=sub(s,m[x]);\n\t\t}\n\t\tif(len&1)\n\t\t{\n\t\t\tres=add(res,mult(len,s));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres=add(res,mult(len/2,s));\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ysf (1000000007)\nint a[3005],f[3005],n,k,tot,ans;\ninline int qpow(int a,int b){\n  int ans=1;\n  while (b){\n    if (b&1) ans=1LL*ans*a%ysf;\n    if (b>>=1) a=1LL*a*a%ysf;\n  }\n  return ans;\n}\nint main(){\n  std::cin>>n>>k;\n  for (int i=1;i*i<=n;++i){\n    if (n%i) continue; a[++tot]=i;\n    if (i*i!=n) a[++tot]=n/i;\n  }\n  std::sort(a+1,a+tot+1);\n  for (int i=1;i<=tot;++i){\n    f[i]=qpow(k,(a[i]+1)>>1);\n    for (int j=1;j<i;++j)\n      if (!(a[i]%a[j])) f[i]-=f[j],f[i]<0?f[i]+=ysf:0;\n    if (a[i]&1) ans=(ans+1LL*a[i]*f[i])%ysf;\n    else ans=(ans+1LL*a[i]*f[i]/2)%ysf;\n  }\n  std::cout<<ans; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nint n,m,cnt,sum,a[100005],ans[100005];\nint ksm(int x,int y){\n\tint z=1; for (; y; y>>=1,x=(ll)x*x%mod) if (y&1) z=(ll)z*x%mod;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif (n&1){\n\t\tprintf(\"%lld\\n\",((ll)(ksm(m,n+1>>1)-m+mod)*n+m)%mod);\n\t\treturn 0;\n\t}\n\tint i,j; n/=2;\n\tfor (i=1; i*i<=n; i++) if (!(n%i)){\n\t\ta[++cnt]=i;\n\t\tif (i*i<n) a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\tfor (i=1; i<=cnt; i++){\n\t\tans[i]=(ans[i]+ksm(m,a[i]))%mod;\n\t\tsum=(sum+(ll)ans[i]*a[i])%mod;\n\t\tfor (j=i+1; j<=cnt; j++) if (!(a[j]%a[i])) ans[j]=(ans[j]+mod-ans[i])%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int P = 1e9 + 7;\nint Pow(int a,int t){\n    int r=1;for(;t;t>>=1,a=1ll*a*a%P)if(t&1)r=1ll*r*a%P;\n    return r;\n}\nvoid pp(int &a,int b){\n    a += b;\n    if(a >= P) a -= P;\n}\nint n , K;\n\nint main(){\n    cin >> n >> K;\n    int ans = 0;\n    if(n&1){\n        ans = 1ll * Pow(K , n/2+1) * n % P;\n        pp(ans , P - 1ll * K * (n - 1) % P);\n    } else {\n        int x = n / 2;\n        set<int> S;\n        map<int,int> Mp;\n        for(int i=1;i*i<=x;++i) if(x % i == 0) S.insert(i) , S.insert(x / i);\n        for(auto e : S){\n            int t = Pow(K , e);\n            for(auto f : Mp) if(e % f.fi == 0) pp(t , P - f.se);\n            pp(ans , 1ll * t * e % P);\n            Mp[e] = t;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid findDivisor(int n, vector<int>& divisor)\n{\n    divisor.clear();\n    stack<int> stk;\n    for(int i=1; i*i<=n; ++i){\n        if(n % i == 0){\n            divisor.push_back(i);\n            if(i * i < n)\n                stk.push(n / i);\n        }\n    }\n    while(!stk.empty()){\n        divisor.push_back(stk.top());\n        stk.pop();\n    }\n}\n\nconst int MOD = 1000000007;\n\nlong long power(int a, int b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    vector<long long> v;\n    if(n % 2 == 0){\n        n /= 2;\n        vector<int> div;\n        findDivisor(n, div);\n\n        int m = div.size();\n        v.assign(m, 0);\n        for(int i=0; i<m; ++i){\n            int x = div[i];\n            v[i] = x * power(k, x) % MOD;\n            for(int j=0; j<i; ++j){\n                int y = div[j];\n                if(x % y == 0){\n                    v[i] -= v[j] * (x / y) % MOD;\n                    v[i] += MOD;\n                    v[i] %= MOD;\n                }\n            }\n        }\n    }\n    else{\n        vector<int> div;\n        findDivisor(n, div);\n\n        int m = div.size();\n        v.assign(m, 0);\n        for(int i=0; i<m; ++i){\n            int x = div[i];\n            v[i] = x * power(k, (x+1)/2) % MOD;\n            for(int j=0; j<i; ++j){\n                int y = div[j];\n                if(x % y == 0){\n                    v[i] -= v[j] * (x / y) % MOD;\n                    v[i] += MOD;\n                    v[i] %= MOD;\n                }\n            }\n        }\n    }\n\n    long long ans = accumulate(v.begin(), v.end(), 0LL) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\n\nint Pow(int x, int e){\n\tint ret = 1;\n\twhile(e){\n\t\tif(e & 1) ret = 1ll * ret * x % Mod;\n\t\tx = 1ll * x * x % Mod;\n\t\te >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, k, ans;\n\nmap<int, int> M;\n\nvoid calc(int l){\n\tint ret = Pow(k, (l + 1) / 2);\n\tfor(int i = 1; i * i <= l; ++i)\n\t\tif(l % i == 0){\n\t\t\tret = (ret + Mod - M[i]) % Mod;\n\t\t\tif(i * i != l && i != 1) ret = (ret + Mod - M[l / i]) % Mod;\n\t\t}\n\tint re = l;\n\tM[re] = ret;\n\tif(re % 2 == 0) ret = 1ll * ret * Pow(2, Mod - 2) % Mod;\n\tans = (ans + 1ll * ret * l) % Mod;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tint i = 1;\n\tfor(; i * i <= n; ++i)\n\t\tif(n % i == 0) calc(i);\n\tfor(--i; i; --i)\n\t\tif(n % i == 0 && i * i != n) calc(n / i);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nll powmod(ll x, ll e) {\n  x %= mod;\n  ll sum = 1;\n  ll cur = x;\n  while (e > 0) {\n    if (e % 2 == 1) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nint main(void){\n  ll n, k;\n  cin >> n >> k;\n  VL n_fact;\n  for (ll i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      n_fact.push_back(i);\n      if (i * i != n) {\n\tn_fact.push_back(n / i);\n      }\n    }\n  }\n  sort(n_fact.begin(), n_fact.end());\n  int m = n_fact.size();\n  VL sym(m, 0LL); // the number of arrays with symmetry k_fact[i]Z/kZ\n  REP(i, 0, m) {\n    int block = n_fact[i];\n    sym[i] = powmod(k, (block + 1) / 2);\n  }\n  REP(i, 0, m) {\n    REP(j, i + 1, m) {\n      if (n_fact[j] % n_fact[i] == 0) {\n\tsym[j] = (sym[j] - sym[i] + mod) % mod;\n      }\n    }\n  }\n  ll tot = 0;\n  REP(i, 0, m) {\n    ll tmp = sym[i];\n    ll f = n_fact[i];\n    tmp *= f % 2 ? f : f / 2;\n    tmp %= mod;\n    tot = (tmp + tot) % mod;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n    if(x<0)x+=MOD;\n}\nLL dp[SIZE];\nint main(){\n    DRII(N,K);\n    VI fac;\n    for(int i=1;i*i<=N;i++){\n        if(N%i==0)fac.PB(i),fac.PB(N/i);\n    }\n    sort(ALL(fac));\n    fac.resize(unique(ALL(fac))-fac.begin());\n    LL an=0;\n    if(N%2==0){\n        REP(i,SZ(fac)){\n            LL me;\n            if(N/fac[i]%2==0){\n                me=mypow(K,fac[i]);\n            }\n            else\n                continue;\n            REP(j,i){\n                if(fac[i]%fac[j]==0){\n                    ADD(me,-dp[j]);\n                }\n            }\n            dp[i]=me;\n            ADD(an,me*fac[i]);\n        }\n    }\n    else{\n        REP(i,SZ(fac)){\n            LL me;\n            me=mypow(K,(fac[i]+1)/2);\n            REP(j,i){\n                if(fac[i]%fac[j]==0){\n                    ADD(me,-dp[j]);\n                }\n            }\n            dp[i]=me;\n            ADD(an,me*fac[i]);\n        }\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar('0'+aa%10);\n\treturn;\n}\nconst long long mod=1e9+7;\nlong long n,K,cnt,ans;\nlong long shu[1000005],f[1000005],vis[1000005];\nlong long ksm(long long aa,long long bb)\n{\n\tlong long now=1;\n\twhile(bb)\n\t{\n\t\tif(bb&1) now=now*aa%mod;\n\t\taa=aa*aa%mod;bb>>=1;\n\t}\n\treturn now;\n}\nvoid solve(long long aa)\n{\n\tif(vis[aa]) return;\n\tvis[aa]=1;\n\tf[aa]=ksm(K,(shu[aa]+1)/2);\n\tfor(long long i=1;i<aa;++i)\n\tif(shu[aa]%shu[i]==0) \n\t{\n\t\tsolve(i);\n\t\tf[aa]=(f[aa]-f[i]+mod)%mod;\n\t}\n\tif(shu[aa]%2==0) (ans+=(shu[aa]/2)*f[aa]%mod)%=mod;\n\telse (ans+=shu[aa]*f[aa]%mod)%=mod;\n\treturn;\n}\nint main()\n{\n\tn=read(),K=read();\n\tfor(long long i=1;i*i<=n;++i) if(n%i==0)\n\t{\n\t\tshu[++cnt]=i;\n\t\tif(i*i!=n) shu[++cnt]=n/i;\n\t}\n\tsort(shu+1,shu+cnt+1);\n\tsolve(cnt);\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e5+10,MOD=1e9+7;\nint n,k,dvs[MAXN],dp[MAXN],tot,res=0;\n\nll quick_pow(ll a,ll b)\n{\n\tll ret=1;\n\tfor(;b;b>>=1,a=a*a%MOD)\n\t\tif(b&1) ret=ret*a%MOD;\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0)\n\t\t{\n\t\t\tdvs[++tot]=i;\n\t\t\tif(i*i!=n) dvs[++tot]=n/i;\n\t\t}\n\tsort(dvs+1,dvs+tot+1);\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tdp[i]=quick_pow(k,(dvs[i]+1)/2);\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tif(dvs[i]%dvs[j]==0) dp[i]=(dp[i]-dp[j]+MOD)%MOD;\n\t\tif(dvs[i]%2==0) (res+=1ll*dp[i]*dvs[i]/2%MOD)%=MOD;\n\t\telse (res+=1ll*dp[i]*dvs[i]%MOD)%=MOD;\n\t}\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef double dob;\ntypedef pair<int,int> par;\nconst int P=1000000007,inv2=500000004;\nLL ans,n,k,a[233],p[233],cnt;\nLL pw(LL x,int k){\n\tLL y=1;\n\twhile (k){\n\t\tif (k&1) y=y*x%P;\n\t\tx=x*x%P;\n\t\tk>>=1;\n\t}\n\treturn y;\n}\n#define g(n) pw(k,(n+1)>>1)\nvoid dfs(LL dep,LL fn,LL gn,LL hn){\n\tif (dep>cnt){\n\t\tLL dlt=g(gn)*hn%P;\n\t\tif (fn%2==0) dlt=dlt*inv2%P;\n\t\tans=(ans+dlt*fn)%P;\n\t\treturn;\n\t}\n\tLL ff=fn;\n\trep(i,0,a[dep]){\n\t\tLL gg=gn;\n\t\trep(j,0,i){\n\t\t\tdfs(dep+1,ff,gg,hn*(i-j>1?0:i-j==1?-1:1));\n\t\t\tgg*=p[dep];\n\t\t}\n\t\tff*=p[dep];\n\t}\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tif (n%2==1){\n\t\tprintf(\"%lld\\n\",g(n)*n%P);\n\t\treturn 0;\n\t}\n\trep(i,2,1e6){\n\t\tif (n%i!=0) continue;\n\t\tp[++cnt]=i;\n\t\twhile (n%i==0){\n\t\t\t++a[cnt];\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif (n!=1) a[++cnt]=1,p[cnt]=n;\n\tdfs(1,1,1,1);\n\tans=(ans+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7;\nint n,k,a[2000],xb,f[2000],i,j,l,ans;\ninline int poww(int x,int y){int ans=1;for(;y;y>>=1,x=1ll*x*x%mo)if(y&1)ans=1ll*ans*x%mo;return ans;}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(i=1;i*i<=n;++i)if(n%i==0){a[++xb]=i;if(i*i<n)a[++xb]=n/i;}\n\tstd::sort(a+1,a+xb+1);\n\tfor(j=1;j<=xb;ans=(ans+1ll*f[j]*(a[j]&1?a[j]:a[j]/2))%mo,++j)\n\t\tfor(f[j]=poww(k,a[j]+1>>1),l=1;l<j;++l)if(a[j]%a[l]==0)f[j]=(f[j]+mo-f[l])%mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mk(a,b) make_pair(a,b)\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nll N,K;\nvector<pll> V;\nvector<ll> R;\nll mod = 1000000007;\nll ans = 0;\n\nll pow_mod(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = pow_mod(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nll unit(ll n)\n{\n    ll num = pow_mod(K,(n + 1) / 2);\n\n    for(int i = 0; i < V.size(); i++)\n        if(n % V[i].fi == 0)num = (num - V[i].se + mod) % mod;\n    V.push_back(mk(n,num));\n\n    if(n % 2 == 0)return (num * (n / 2)) % mod;\n    return num * n % mod;\n}\n\nint main()\n{\n    scanf(\"%lld%lld\",&N,&K);\n\n    for(ll i = 1; i <= (ll)sqrt(N); i++)\n    {\n        if(N % i == 0)\n        {\n            R.push_back(i);\n            if(i * i != N)R.push_back(N / i);\n        }\n    }\n\n    sort(R.begin(),R.end());\n\n    for(int i = 0; i < R.size(); i++)ans = (ans + unit(R[i])) % mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint n,k,ans,divi[2333];\nmap<int,int> mp;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nint calc(int x){\n\tif(mp.find(x)!=mp.end()) return mp[x];\n\tint ans=power(k,(x+1)/2);\n\tfor (int i=1;i<=*divi&&divi[i]<x;i++)\n\t\tif (x%divi[i]==0) ans=(ans+mo-calc(divi[i]))%mo;\n\t//printf(\"%d %d\\n\",x,ans);\n\treturn mp[x]=ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tdivi[++*divi]=i;\n\t\t\tif (i*i!=n) divi[++*divi]=n/i;\n\t\t}\n\tsort(divi+1,divi+*divi+1);\n\tfor (int i=1;i<=*divi;i++)\n\t\tans=(ans+1ll*calc(divi[i])*(divi[i]/(2-(divi[i]&1))))%mo;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int mod = (int)1e9 + 7;\nint n, m;\nmap<int, int> Hash;\nint mod_pow(int x, int k) {\n\tint ret = 1;\n\tfor( ; k > 0; k >>= 1, x = (LL)x * x % mod)\n\t\t(k & 1) && (ret = (LL)ret * x % mod);\n\treturn ret;\n}\nint F(int x) {\n\tif(Hash.count(x))\n\t\treturn Hash[x];\n\tint ret = mod_pow(m, (x + 1) >> 1);\n\tx > 1 && (ret -= F(1)) < 0 && (ret += mod);\n\tfor(int i = 2; i * i <= x; ++i) {\n\t\tif(x % i > 0)\n\t\t\tcontinue;\n\t\t(ret -= F(i)) < 0 && (ret += mod);\n\t\ti * i < x && (ret -= F(x / i)) < 0 && (ret += mod);\n\t}\n\treturn Hash[x] = ret;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tint ans = 0;\n\tfor(int i = 1; i * i <= n; ++i) {\n\t\tif(n % i > 0)\n\t\t\tcontinue;\n\t\tans = (ans + (LL)F(i) * (i >> !(i & 1))) % mod;\n\t\tif(i * i < n)\n\t\t\tans = (ans + (LL)F(n / i) * ((n / i) >> !((n / i) & 1))) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ndouble f[1005][1005],dis[1005],a[1005][3];\nbool b[1005];\nint main()\n{\n\tint i,j,k,n;\n\tdouble xi,xs,ys,xt,yt;\n\tscanf(\"%lf%lf%lf%lf\",&xs,&ys,&xt,&yt);\n\tscanf(\"%d\",&n);\n\ta[0][0]=xs;a[0][1]=ys;a[0][2]=0;\n\ta[n+1][0]=xt;a[n+1][1]=yt;a[n+1][2]=0;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf\",&a[i][0],&a[i][1],&a[i][2]);\n\tn++;\n\tfor(i=0;i<n;i++)\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tf[i][j]=f[j][i]=sqrt((a[i][0]-a[j][0])*(a[i][0]-a[j][0])+(a[i][1]-a[j][1])*(a[i][1]-a[j][1]))-(a[i][2]+a[j][2]);\n\t\t\tif(f[i][j]<0)\n\t\t\t\tf[i][j]=0;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=f[0][i];\n\tb[0]=1; \n\tdis[0]=0; \n\tfor(i=0;i<n;i++){ \n\t\txi=1e10;\n\t\tk=0; \n\t\tfor(j=0;j<=n;j++){\n            if(b[j]==0&&dis[j]<xi){ \n\t\t\t\txi=dis[j]; \n\t\t\t\tk=j; \n\t\t\t} \n        }\n\t\tb[k]=1; \n\t\tfor(j=0;j<=n;j++)\n\t\t\tdis[j]=min(dis[j],dis[k]+f[k][j]);\n\t}\n\tprintf(\"%.10lf\",dis[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    vector<int> divs;\n    for(int i=1; i*i<=N; i++) if(N%i == 0){\n        divs.push_back(i);\n        if(i < N/i) divs.push_back(N/i);\n    }\n    sort(divs.begin(), divs.end());\n    int sz = divs.size();\n\n    vector<int64_t> num(sz);\n    int64_t ans = 0;\n    for(int i=0; i<sz; i++){\n        int d = divs[i];\n        int64_t res = power_mod(K, (d+1)/2);\n        add(num[i], res);\n        add(ans, num[i] * (d%2 ? d : d/2));\n        for(int j=i+1; j<sz; j++) if(divs[j] % divs[i] == 0) add(num[j], MOD - num[i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\n#define INF 1000000000LL\n#define EPS 1e-12\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nusing i64 = std::int_fast64_t;\nconst static i64 mod = 1000000007;\nstruct mint {\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tvector<T> seq;\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tseq.resize(2 * n - 1);\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] rsq(n, [] (ll a, ll b) { return a + b; }, 0)\n// [Range Max Query] rMq(n, [] (ll a, ll b) { return max(a, b); }, -1e18)\n// [Range Min Query] rmq(n, [] (ll a, ll b) { return min(a, b); }, 1e18)\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nmint _pow(mint a, long long n) {\n\tif(n == 0) return 1;\n\tmint res = 1;\n\tmint buf = a;\n\twhile(n > 0) {\n\t\tif(n % 2) res *= buf;\n\t\tbuf *= buf;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nusing mi = mint;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, k;\n\tcin >> n >> k;\n\tvector<ll> div;\n\tvector<mi> cnt;\n\tif(n % 2 == 0) {\n\t\tll m = n / 2;\n\t\tfor(int i = 1; i * i <= m; i++) {\n\t\t\tif(m % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != m) div.pb(m / i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(int i = 1; i * i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != n) div.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(div));\n\tcnt.assign((int)div.size(), 0);\n\tREP(i, div.size()) {\n\t\tcnt[i] += _pow(k, div[i]);\n\t\tFOR(j, i + 1, div.size()) {\n\t\t\tif(div[j] % div[i] == 0) cnt[j] -= cnt[i];\n\t\t}\n\t}\n\tmi ans = 0;\n\tREP(i, div.size()) {\n\t\tans += cnt[i] * n / (n / div[i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL N = 200010;\nconst LL Mod = 1e9+7;\ninline LL read()\n{\n  LL p=0; LL f=1; char ch=getchar();\n  while(ch<'0' || ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n  while(ch>='0' && ch<='9'){p=p*10+(ch-'0'); ch=getchar();}\n  return p*f;\n}\n\nvector<LL> V;\n\nLL qpow(LL x,LL k,LL mo){LL s=1; while(k){if(k&1) s=(s*x)%mo; x=(x*x)%mo; k>>=1;} return s;}\n\nLL f[N]; LL n,k;\n\nint main()\n{\n\n\n  n=read(); k=read(); V.clear();\n  for(LL i=1;i*i<=n;i++) if(n%i==0)\n  {\n    V.push_back(i);\n    if(i*i!=n) V.push_back(n/i);\n  }\n  \n  sort(V.begin(),V.end());\n\n  LL ans=0; LL ny2=qpow(2,Mod-2,Mod);\n  for(LL i=0;i<V.size();i++)\n  {\n  \tLL x=V[i]; f[i]=qpow(k,x/2,Mod);\n  \tif(x&1) f[i]=f[i]*k%Mod;\n  \tfor(LL j=0;j<i;j++) if(x % V[j] == 0)\n  \t  f[i] = (f[i] - f[j] + Mod) % Mod;\n\n  \tif(x&1) ans = (ans + f[i] * V[i] % Mod ) % Mod;\n  \telse ans = (ans + f[i] * V[i] % Mod * ny2 % Mod) % Mod;\n  \t// printf(\"%lld\\n\",f[i]);\n  }\n\n\n  return printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\n// ModInt (ref. anta) {{{\ntemplate<int MOD>\nstruct ModInt{\n    static const int Mod = MOD;\n    unsigned val;\n    ModInt():val(0){}\n    ModInt(unsigned x):val(x%MOD){}\n    ModInt(signed x) {\n        int y = x % MOD;\n        if(y < 0) y += MOD;\n        val = y;\n    }\n    ModInt(signed long long x) {\n        int y = (int)(x % MOD);\n        if(y < 0) y += MOD;\n        val = y;\n    }\n\n    ModInt &operator+=(ModInt rhs) {\n        val += rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt rhs) {\n        val += MOD - rhs.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt rhs) {\n        val = (unsigned)((unsigned long long)val * rhs.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n\n    ModInt inv() const {\n        signed a = val, b = MOD, u = 1, v = 0;\n        while(b) {\n            signed t = a / b;\n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if(u < 0) u += MOD;\n        ModInt res;\n        res.val = u;\n        return res;\n    }\n\n    ModInt operator+(ModInt rhs) const {\n        return ModInt(*this) += rhs;\n    }\n    ModInt operator-(ModInt rhs) const {\n        return ModInt(*this) -= rhs;\n    }\n    ModInt operator*(ModInt rhs) const {\n        return ModInt(*this) *= rhs;\n    }\n    ModInt operator/(ModInt rhs) const {\n        return ModInt(*this) /= rhs;\n    }\n\n    // compare\n    bool operator==(ModInt rhs) const {\n        return val == rhs.val;\n    }\n    bool operator!=(ModInt rhs) const {\n        return val != rhs.val;\n    }\n    bool operator< (ModInt rhs) const {\n        return val <  rhs.val;\n    }\n    bool operator<=(ModInt rhs) const {\n        return val <= rhs.val;\n    }\n    bool operator> (ModInt rhs) const {\n        return val >  rhs.val;\n    }\n    bool operator>=(ModInt rhs) const {\n        return val >= rhs.val;\n    }\n};\ntemplate<int MOD>\nostream& operator << (ostream& os, const ModInt<MOD> m) {\n    return os << m.val;\n}\ntemplate<int MOD, typename T>\nModInt<MOD> pow(ModInt<MOD> a, T b) {\n    if(b == 0) {\n        return 1;\n    } else {\n        auto w = pow(a*a, b/2);\n        if(b&1) w *= a;\n        return w;\n    }\n}\n// }}}\ntypedef ModInt<1000000007> mint;\n\nvector<LL> divisor(LL N) {\n    vector<LL> res;\n    for(LL i = 1; i*i <= N; i++) {\n        if(N % i != 0) continue;\n        res.push_back(i);\n        if(i != N/i) res.push_back(N/i);\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nint main(){\n    iostream_init();\n    LL N, K;\n    cin >> N >> K;\n\n    auto divs = divisor(N);\n    map<LL, mint> f;\n\n    for(auto x : divs) {\n        f[x] += pow(mint(K), (x+1)/2);\n        for(auto y : divs) {\n            if(y < x && x % y == 0) {\n                f[x] -= f[y];\n            }\n        }\n    }\n\n    mint res = 0;\n    for(auto x : divs) {\n        res += f[x] * mint((x % 2 == 0 ? x/2 : x));\n    }\n\n    cout << res << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef vector<pii> vii;\ntypedef vector<string> vs;\nconst int mod = 1000000007;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nll st2(int n) {\n  int c = 0;\n  for (int mask = 0; mask < (1 << n); ++mask) {\n    vi v(2 * n);\n    for (int i = 0; i < n; ++i) if (mask & (1 << i)) v[i] = v[i+n] = 1;\n    for (int i = 0; i < n; ++i) {\n      bool ok = 1;\n      for (int j = 0; j < n/2; ++j) if (v[i + j] != v[i + n - j - 1]) {\n        ok = 0; break;\n      }\n      if (ok) {\n        ++c;\n        break;\n      }\n    }\n  }\n  return c;\n}\n\nint main() {\n  ll n, k;\n  cin >> n >> k;\n//  if (k == 2 && n <= 20) cerr << st2(n) << endl;\n//  if (n % 2) {\n//    cout << (f(n, k) + mod) % mod << endl;\n//  } else {\n    vi d;\n    for (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n      d.push_back(i);\n      if (i * i != n) d.push_back(n / i);\n    }\n    sort(d.begin(), d.end());\n    vl v(d.size());\n    for (int i = 0; i < d.size(); ++i) {\n      v[i] = mpow(k, (d[i] + 1) / 2);\n      for (int j = 0; j < i; ++j) if (d[i] % d[j] == 0) v[i] = (v[i] - v[j]) % mod;\n    }\n    ll res = 0;\n    for (int i = 0; i < d.size(); ++i) {\n      if (d[i] % 2 == 0) res = (res + d[i] / 2 * v[i]) % mod;\n      else res = (res + d[i] * v[i]) % mod;\n    }\n    cout << (res + mod) % mod << endl;\n//  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long Mod = 1000000007, n, K, C[101000];\nvector<long long>V;\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r*a%Mod;\n\t\ta = a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Get(long long a) {\n\treturn Pow(K, (a + 1) / 2);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%lld%lld\", &n, &K);\n\tfor (i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tV.push_back(i);\n\t\t\tif (i*i != n)V.push_back(n / i);\n\t\t}\n\t}\n\tsort(V.begin(), V.end());\n\tint sz = V.size();\n\tlong long res = 0;\n\tfor (i = 0; i < sz; i++) {\n\t\tC[i] = Pow(K, (V[i] + 1) / 2);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (V[i] % V[j] == 0)C[i] = (C[i]-C[j]+Mod)%Mod;\n\t\t}\n\t\tlong long t = C[i] * V[i];\n\t\tif (V[i] % 2 == 0)t /= 2;\n\t\tres = (res + t) % Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ndouble f[1005][1005],dis[1005],a[1005][3];\nbool b[1005];\nint main()\n{\n\tint i,j,k,n;\n\tdouble xi,xs,ys,xt,yt;\n\tscanf(\"%lf%lf%lf%lf\",&xs,&ys,&xt,&yt);\n\tscanf(\"%d\",&n);\n\ta[0][0]=xs;a[0][1]=ys;a[0][2]=0;\n\ta[n+1][0]=xt;a[n+1][1]=yt;a[n+1][2]=0;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf\",&a[i][0],&a[i][1],&a[i][2]);\n\tn++;\n\tfor(i=0;i<n;i++)\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tf[i][j]=f[j][i]=sqrt((a[i][0]-a[j][0])*(a[i][0]-a[j][0])+(a[i][1]-a[j][1])*(a[i][1]-a[j][1]))-(a[i][2]+a[j][2]);\n\t\t\tif(f[i][j]<0)\n\t\t\t\tf[i][j]=0;\n\t\t}\n\tfor(i=1;i<=n;i++) dis[i]=1e10;\n\tdis[0]=0; \n\tfor(i=0;i<n;i++){ \n\t\txi=1e10;\n\t\tk=0;\n\t\tfor(j=0;j<=n;j++){\n            if(b[j]==0&&dis[j]<xi){ \n\t\t\t\txi=dis[j]; \n\t\t\t\tk=j; \n\t\t\t} \n        }\n\t\tb[k]=1; \n\t\tfor(j=0;j<=n;j++)\n\t\t\tdis[j]=min(dis[j],dis[k]+f[k][j]);\n\t}\n\tprintf(\"%.10lf\",dis[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<ctime>\n#include<algorithm>\n#define int long long \n#define re register\n#define gc getchar\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=gc();\n\twhile(v<'0')v=gc();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();\n\treturn t;\n}\n\nint ans[200002],tot,num[200002],cnt;\ninline long long msc(long long x,long long y,long long mod){\nlong long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod);\nreturn tmp<0?tmp+mod:tmp;\n}inline int ksm(re int x,re int y,re int M){\n\tre int ans=1;\n\twhile(y){\n\t\tif(y&1)ans=msc(ans,x,M);\n\t\tx=msc(x,x,M);\n\t\ty>>=1;\n\t}\n\treturn ans;\n}\ninline int random(re int x){\n\treturn ((double)rand()/RAND_MAX*x+0.5);\n}\ninline bool mr(re int n){if(n<2)return 0;\nsrand((unsigned)time(NULL));\t\nif(n==2)return 1;\nif(n==3)return 1;\nif(n==5)return 1;\nif(n==7)return 1;\nif(n==11)return 1;\nif(n==13)return 1;\n\tif(n&1)\n\tif(n%3)\n\tif(n%5)\n\tif(n%7)\n\tif(n%11)\n\tif(n%13){\n\t\tint m=n-1,k=0;\n\t\twhile(!(m&1))m>>=1,++k;\n\t\tfor(re int i=1;i<=3;++i){\n\t\t\tint a=random(n-2)+1,x=ksm(a,m,n),y=0;\n\t\t\tfor(re int j=1;j<=k;++j){\n\t\t\t\ty=msc(x,x,n);\n\t\t\t\tif(y==1&&x!=1&&x!=n-1)return 0;\n\t\t\t\tx=y;\n\t\t\t}\n\t\t\tif(y!=1)return 0;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline int gcd(re int x,re int y){\n\treturn y?gcd(y,x%y):x;\n}\ninline int as(re int x){\n\treturn x<0?-x:x;\n}\n#define ll long long\ninline ll pr(ll x,ll c) {\n\tif(!c)c=rand();\n\tll s=0,t=0;\n\tint stp=0,goal=1;\n\tll val=1;\n\tfor(goal=1;;goal<<=1,s=t,val=1) {\n\t\tfor(stp=1; stp<=goal; ++stp) {\n\t\t\tt=(msc(t,t,x)+c)%x;\n\t\t\tval=msc(val,as(t-s),x);\n\t\t\tif((stp%127)==0) {\n\t\t\t\tll d=gcd(val,x);\n\t\t\t\tif(d>1)return d;\n\t\t\t}\n\t\t}\n\t\tll d=gcd(val,x);\n\t\tif(d>1)return d;\n\t}\n}\nint pp[40]= {9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829};\ninline void ff(re int x){\n\tif(x==1)return;\n\tif(mr(x)){\n\t\tans[++tot]=x;\n\t\treturn;\n\t}\n\tint p=x,tmp=0;\t\n\t\n\twhile(p>=x)p=pr(x,pp[tmp++]);\n\tff(p);\n\tff(x/p);\n}\nint anss;\nint t,n,m,M;\ninline int H(re int x){\n\treturn x&1?x:x/2;\n}\ninline void dfs(re int x,re int y,re int z){\n\tif(x>cnt){\n\t\tif(!(y&1)&&(n/y)&1)return;\n\t\t(anss+=ksm(m,(n/y+1)/2,M)*(H(n/y)%M)%M*(z%M)%M)%=M;\n\t\treturn;\n\t}\n\tdfs(x+1,y,z);\n\tz*=(1-ans[x]);\n\tfor(re int i=1;i<=num[x];++i){\n\t\ty*=ans[x];\n\t\tdfs(x+1,y,z);\n\t}\n}\nsigned main(){\n\tsrand((unsigned)time(NULL));\n\tn=read();m=read();M=1e9+7;tot=0;m%=M;\n\tff(n);sort(ans+1,ans+tot+1);\n\tcnt=0;anss=0;\n\tfor(re int i=1;i<=tot;++i)if(ans[i]!=ans[cnt])ans[++cnt]=ans[i],num[cnt]=1;else ++num[cnt];\n\tdfs(1,1,1);anss<0?anss+=M:anss;\n\tprintf(\"%lld\\n\",anss);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int mo=1e9+7,M=1e5+5;\nll n,k,m,num,ans,a[M][2],b[M],f[M];\nll qmi(ll x,ll n)\n{\n\tll t=1;\n\tfor(;n;n>>=1,x=x*x%mo) if(n&1) t=t*x%mo;\n\treturn t;\n}\nvoid dfs(int id=1,int x=1)\n{\n\tif(id>m)\n\t{\n\t\tb[++num]=x;\n\t\treturn;\n\t}\n\tfor(int j=0,t=1;j<=a[id][1];j++,t=t*a[id][0]) dfs(id+1,x*t);\n}\nvoid pre()\n{\n\tll t=n;\n\tfor(ll i=2;i*i<=t;++i)\n\t\tif(t%i==0)\n\t\t\tfor(a[++m][0]=i;t%i==0;t/=i) a[m][1]++;\n\tif(t>1) a[++m][0]=t,a[m][1]=1;\n\tdfs();\n\tsort(b+1,b+num+1);\n}\nint main()\n{\n\tn=read(),k=read();\n\tpre();\n\tfo(i,1,num)\n\t{\n\t\tint x=b[i];\n\t\tf[i]=qmi(k,(x+1)/2);\n\t\tfo(j,1,i-1)\n\t\t\tif(x%b[j]==0) f[i]=(f[i]-f[j]+mo)%mo;\n\t\tans=(ans+(ll)f[i]*(x&1?x:x/2)%mo)%mo;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntypedef pair<int, int> pii;\n\nint n, K;\n\nint pr(int a, int z) {\n\tint s = 1;\n\twhile (z > 0) {\n\t\tif (z % 2 == 1) s = 1ll * s * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tz /= 2;\n\t}\n\treturn s;\n}\n\nmap<int, int> sum;\npii li[200];\nint len;\n\n#define fi first\n#define se second\n\nint main() {\n\t//freopen(\"64D.in\", \"r\", stdin);\n\tscanf(\"%d%d\", &n, &K);\n\tint _n = n;\n\tfor (int i = 2; i * i <= _n; ++i) if (_n % i == 0) {\n\t\tint c = 0;\n\t\twhile (_n % i == 0) _n /= i, ++c;\n\t\tli[++len] = pii(i, c);\n\t}\n\n\tif (_n != 1) li[++len] = pii(_n, 1);\n\n\tfor (int d = 1; d * d <= n; ++d) {\n\t\tif (n % d == 0) {\n\t\t\tsum[d] = d;\n\t\t\tsum[n / d] = n / d;\n\t\t}\n\t}\n\n\n\n\tfor (int i = 1; i <= len; ++i) {\n\t\tfor (auto it = sum.begin(); it != sum.end(); ++it) if (it->fi % li[i].fi == 0 && sum.find(it->fi / li[i].fi) != sum.end()) {\n\t\t\tsum[it->fi / li[i].fi] -= sum[it->fi];\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\n\tfor (pii p : sum) {\n\t\tans = (ans + 1ll * pr(K, (n / p.fi % 2 == 1) ? (p.fi + 1) / 2 : p.fi) * p.se % mod + mod) % mod;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 1005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K;\nmap<int,int> zz;\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n\tif(c & 1) res = mul(res,t);\n\tt = mul(t,t);\n\tc >>= 1;\n    }\n    return res;\n}\nint f(int x) {\n    if(x == 1) return K;\n    if(zz.count(x)) return zz[x];\n    int res = fpow(K,x / 2);\n    if(x & 1) res = mul(res,K);\n    for(int i = 1 ; i <= x / i ; ++i) {\n\tif(x % i == 0) {\n\t    update(res,MOD - f(i));\n\t    int j = x / i;\n\t    if(j != i && j != x) update(res,MOD - f(j));\n\t}\n    }\n    zz[x] = res;\n    return res;\n}\nvoid Solve() {\n    read(N);read(K);\n    int ans = 0;\n    for(int i = 1 ; i <= N / i; ++i) {\n\tif(N % i == 0) {\n\t    int t = mul(f(i),i);\n\t    if(i % 2 == 0) t = mul(t,(MOD + 1) / 2);\n\t    update(ans,t);\n\t    int j = N / i;\n\t    t = mul(f(j),j);\n\t    if(j % 2 == 0) t = mul(t,(MOD + 1) / 2);\n\t    if(j != i) update(ans,t);\n\t}\n    }\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?(c=getchar()):0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\nconst int dN=1010,O=1000000007;\ninline int fpow(int x,int n){\n\tlint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint fact[dN],fs=0;\nlint f[dN];\ninline void addfact(int x,int e){\n\tfor(int i=0,j=0;i<e;i++){\n\t\tfor(int k=fs;j<k;j++){\n\t\t\tfact[fs++]=fact[j]*x;\n\t\t}\n\t}\n}\nint main(){\n\tint n=ni,k=ni;\n\tfact[fs++]=1;\n\tfor(int x=2,e;x*x<=n;x++){\n\t\tfor(e=0;n%x==0;n/=x,e++);\n\t\taddfact(x,e);\n\t}\n\tif(n!=1){\n\t\taddfact(n,1);\n\t}\n\tlint ans=0;\n\tfor(int i=0;i<fs;i++){\n\t\tint d=fact[i];\n\t\tf[i]=fpow(k,(d+1)>>1);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(d%fact[j]==0){\n\t\t\t\tf[i]-=f[j];\n\t\t\t}\n\t\t}\n\t\tf[i]=(f[i]%O+O)%O;\n\t\tstatic int inv2=inv(2);\n\t\tans+=d&1?f[i]*d%O:(f[i]*d%O*inv2%O);\n\t}\n\tprintf(\"%lld\\n\",ans%O);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint n,m,ans;\nmap<int,int> mp;\nint mi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint work(int p)\n{\n\tif (mp.count(p)) return mp[p];\n\tint ans=0;\n\tfor (int i=1;i*i<=p;i++) if (p%i==0)\n\t{\n\t\tif (i!=p) ans=(ans-work(i))%mo;\n\t\tif ((p/i!=i)&&(p/i!=p)) ans=(ans-work(p/i))%mo;\n\t}\n\tans=(ans+mo)%mo;\n\tif (n/p%2==0) ans=(ans+mi(m,p))%mo;\n\telse if (p&1) ans=(ans+mi(m,(p+1)/2))%mo;\n\telse ans=(ans+mi(m,p/2))%mo;\n\t//if ((n%(2*p)==0)&&(2*p!=n)) ans=(ans+mi[2*p]-mi[p])%mo;\n\treturn mp[p]=ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\t//mi[0]=1;for (int i=1;i<=n;i++) mi[i]=(long long)mi[i-1]*m%mo;\n\t//for (int i=1;i*i<=n;i++) if (n%i==0) {ans+=work(i);ans+=work(n/i);}\n\twork(n);\n\tint ans=0;\n\tfor (map<int,int>::iterator it=mp.begin();it!=mp.end();it++)\n\t{\n\t\t//cerr<<it->first<<' '<<it->second<<endl;\n\t\t//if ((it->first==n)&&(it->first!=1)) continue;\n\t\tans=(ans+(long long)it->first*it->second)%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,k,ans;\n\nvector<int> has;\n\nint f[maxn];\n\nvoid Work(){\n\tn=has.size();\n\tREP(i,0,n-1){\n\t\tf[i]=fexp(k,(has[i]+1)>>1);\n\t\tREP(j,0,i-1)if(has[i]%has[j]==0)f[i]=(f[i]-f[j]+mod)%mod;\n\t\tif(has[i]&1)ans=(ans+1ll*f[i]*has[i])%mod;else ans=(ans+1ll*f[i]*has[i]/2)%mod;\n\t}\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,k);\n\tREP(i,1,(int)sqrt(n+.5))if(n%i==0)has.PB(i),has.PB(n/i);\n\tsort(has.begin(),has.end());\n\thas.erase(unique(has.begin(),has.end()),has.end());\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nconst int MOD = 1e9 + 7;\nconst int N = 1000000;\nint ans[N], finans;\nvector <int> V;\nint powi(int a, int b)\n{\n    int c = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % MOD)\n        if (b & 1) c = 1ll * c * a % MOD;\n    return c;\n}\nint main()\n{\n    cin >> n >> k;\n    for (int i = 1; i * i <= n; ++ i)\n        if (n % i == 0)\n        {\n            V.push_back(i);\n            if (i * i != n) V.push_back(n / i);\n        }\n    sort(V.begin(), V.end());\n    for (int i = 0; i < V.size(); ++ i)\n    {\n        ans[i] = powi(k, (V[i] + 1) / 2);\n        for (int j = 0; j < i; ++ j) if (V[i] % V[j] == 0)\n            ans[i] = (ans[i] - ans[j] + MOD) % MOD;\n        finans = (finans + 1ll * ans[i] * (V[i] & 1? V[i]: V[i] / 2)) % MOD;\n    }\n    cout << finans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\nint modpow(int x, int k) {\n  int a = 1;\n  while (k) {\n    if (k&1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint N, K;\nvector<int> G;\nint D[2000];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> K;\n  for (int d=1; d*d<=N; d++) {\n    if (N%d) continue;\n    G.pb(d);\n    if (d*d != N) G.pb(N/d);\n  }\n  sort(all(G));\n  int ans = 0;\n  rep(i, G.size()) {\n    int d = G[i];\n    D[i] = modpow(K, (d+1)/2);\n    rep(j, i) if (d%G[j] == 0) {\n      D[i] = (D[i] + MOD-D[j]) % MOD;\n    }\n    int d2 = d;\n    if (d%2 == 0) d2 /= 2;\n    ans = (ans+1LL*d2*D[i]) % MOD;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nll pow_mod(ll v, ll st){\n\tll ans = 1ll;\n\tfor(; st; st /= 2ll){\n\t\tif (st & 1){\n\t\t\tans = (ans * v) % MOD;\n\t\t}\n\t\tv = (v * v) % MOD;\n\t}\n\treturn ans;\n}\n\nvi divs;\nvector<ll> dp;\n\nvoid solve(){\n\tint n, k;\n\tcin >> n >> k;\n\tfor(int i = 1; i * i <= n; i++){\n\t\tif (n % i == 0){\n\t\t\tdivs.pb(i);\n\t\t\tif (i * i != n){\n\t\t\t\tdivs.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tSORT(divs);\n\tint m = SZ(divs);\n\tdp.resize(m);\n\tdp[0] = k;\n\tREP(i, 1, m){\n\t\tdp[i] = pow_mod(k, (divs[i] + 1) / 2);\n\t\tREP(j, 0, i){\n\t\t\tif (divs[i] % divs[j] == 0){\n\t\t\t\tdp[i] = (dp[i] + MOD - dp[j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0ll;\n\tREP(i, 0, m){\n\t\t//cout << divs[i] << \" \" << dp[i] << endl;\n\t\tll mul = divs[i];\n\t\tif (divs[i] % 2 == 0){\n\t\t\tmul /= 2;\n\t\t}\n\t\tans = (ans + dp[i] * mul) % MOD;\n\t}\n\tcout << ans << endl;\n\t\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint qpow(int x,int y){\n\tint res=1;\n\tfor (;y;y>>=1,x=1LL*x*x%mod)\n\t\tif (y&1) res=1LL*res*x%mod;\n\treturn res;\n}\ninline int upd(int x){return x+(x>>31&mod);}\n\nint n,k;\nint d[10000],dtot;\nint f[10000];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\td[++dtot]=i;\n\t\t\tif (i*i!=n) d[++dtot]=n/i;\n\t\t}\n\tsort(d+1,d+dtot+1);\n\tint ans=0;\n\tfor (int i=1;i<=dtot;i++){\n\t\tint x=d[i];\n\t\tf[i]=qpow(k,x+1>>1);\n\t\tfor (int j=1;j<i;j++) if (d[i]%d[j]==0) f[i]=upd(f[i]-f[j]);\n\t\tif (x&1) ans=(ans+1LL*f[i]*x)%mod;\n\t\telse ans=(ans+1LL*(x/2)*f[i])%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=nn/i) v.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tadd(ans,1ll*d[i]*x%MOD);\n\t}\n\tif(n%2==1) ans=2ll*ans*m%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\treturn 0;\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// clang-format off\n#define range(i, l, r) for (int i = (int)l; i < (int)(r); ++(i))\n#define rrange(i, l, r) for (int i = ((int)(r) - 1); i >= (int)l; --(i))\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n#define rwhole(f,x,...) ([&](decltype((x)) whole) { return (f)(rbegin(whole), rend(whole), ## __VA_ARGS__); })(x)\n\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\ninline void br(ostream &os = cerr) { os << endl; }\n\nusing int32 = int;\nusing int64 = long long;\n\nconst int mod     = 1e9 + 7;\nconst int32 inf   = 1001001001;\nconst int64 infll = 1001001001001001001ll;\n\nconst int dx[] = {0, -1, 1, 0, -1, 1, -1, 1}, dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\nconst string YES = \"YES\", NO = \"NO\", Yes = \"Yes\", No = \"No\", yes = \"yes\", no = \"no\";\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ntemplate <typename T = int64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { range(i, 0, v.size()) { os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return os; } \ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\ntemplate <typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\ntemplate < int mod >\nstruct ModInt\n{\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p)\n  {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p)\n  {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p)\n  {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p)\n  {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const\n  {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p)\n  {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a)\n  {\n    long long x;\n    is >> x;\n    a = ModInt< mod >(x);\n    return (is);\n  }\n\n};\n\nusing modint = ModInt< mod >;\n\nint64_t power(int64_t x, int64_t n, int64_t mod) {\n  int64_t ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nvector< int64_t > divisor(int64_t n) {\n  vector< int64_t > ret;\n  for(int64_t i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret.push_back(i);\n      if(i * i != n) ret.push_back(n / i);\n    }\n  }\n  sort(begin(ret), end(ret));\n  return (ret);\n}\n\nvoid solver() {\n  int64 N = input(), K = input();\n\n  modint ans = 0;\n  auto d = divisor(N);\n  vector<modint> cnt(d.size());\n\n  range(i, 0, d.size()) {\n    cnt[i] = power(K, (d[i] + 1) / 2, mod);\n\n    range(j, 0, i) {\n      if (d[i] % d[j] == 0) cnt[i] -= cnt[j];\n    }\n\n    if (d[i] & 1) ans += cnt[i] * d[i];\n    else ans += cnt[i] * d[i] / 2;\n  }\n\n  cout << ans << endl;\n}\n\nsigned main(int argc, char *argv[]) {\n  solver();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nconst int N = 1e+5+5;\nconst int mo = 1e+9+7;\n\nint a[N],m;\nint f[N];\n\nint dec(int x,int y){return x>=y?x-y:x+mo-y;}\n\nint quickmi(LL x,int tim){LL ans=1;for(;tim;tim/=2,x=x*x%mo)if (tim&1)ans=ans*x%mo;return ans;}\n\nint add(int x,int y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfo(i,1,sqrt(n))\n\tif (n%i==0){\n\t\ta[++m]=i;\n\t\tif (n/i!=i)a[++m]=n/i;\n\t}\n\tsort(a+1,a+1+m);\n\tf[1]=k;\n\tfo(i,2,m){\n\t\tf[i]=quickmi(k,(a[i]+1)/2);\n\t\tfo(j,1,i-1)\n\t\tif (a[i]%a[j]==0)f[i]=dec(f[i],f[j]);\n\t}\n\tint ans=0;\n\tfo(i,1,m)\n\tif (a[i]&1)ans=add(ans,1ll*f[i]*a[i]%mo);\n\telse ans=add(ans,1ll*f[i]*a[i]/2%mo);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pi = pair<int, int>;\nusing lint = long long;\nconst int mod = 1e9 + 7;\nconst int MAXN = 100005;\n\nint n, k;\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tvector<int> yaksu;\n\tcin >> n >> k;\n\tfor(int i=1; i*i<=n; i++){\n\t\tif(n % i == 0){\n\t\t\tyaksu.push_back(i);\n\t\t\tif(i * i != n) yaksu.push_back(n / i);\n\t\t}\n\t}\n\tsort(yaksu.begin(), yaksu.end());\n\tvector<lint> dp(yaksu.size());\n\tlint ret = 0;\n\tfor(int i=0; i<dp.size(); i++){\n\t\t// dp[i] = (palindrome with exactly yaksu[i] period)\n\t\tdp[i] = ipow(k, (yaksu[i] + 1) / 2);\n\t\tfor(int j=0; j<i; j++){\n\t\t\tif(yaksu[i] % yaksu[j] == 0){\n\t\t\t\tdp[i] += mod - dp[j];\n\t\t\t}\n\t\t}\n\t\tdp[i] %= mod;\n\t\tret += dp[i] * (yaksu[i] % 2 ? yaksu[i] : (yaksu[i] / 2));\n\t\tret %= mod;\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 50009\nusing namespace std;\nconst int MOD=1e9+7;\nint n,m;\nvector<int>G;\nlong long f[maxn],g[maxn];\nvoid div(int n){\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i)\n\t\t\tcontinue;\n\t\tG.push_back(i);\n\t\tif(i*i!=n)\n\t\t\tG.push_back(n/i);\n\t}\n\tsort(G.begin(),G.end());\n}\nlong long mgml(long long a,int b){\n\tlong long res=1;\n\twhile(b){\n\t\tif(b&1)\n\t\t\tres=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tcin>>n>>m;\n\tdiv(n);\n\tint sz=G.size();\n\tfor(int i=0;i<sz;i++){\n\t\tf[i]=mgml(m,(G[i]+1)/2);\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tg[i]=f[i];\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(G[i]%G[j]==0){\n\t\t\t\tg[i]-=g[j];\n\t\t\t\tg[i]%=MOD;\n\t\t\t\tg[i]+=MOD;\n\t\t\t\tg[i]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(G[i]%2==0){\n\t\t\t\tg[i]=g[i]*mgml(2,MOD-2)%MOD;\n\t\t\t}\n\t\t\tans=(ans+g[i]*G[i])%MOD;\n\t\t}\n\t\n\tcout<<ans<<endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tv.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n//\tans=1ll*Pow(m,nn)*(nn+1)%MOD;\n//\tprintf(\"%d\\n\",ans);\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) d[i]-=d[j];\n\t\tadd(ans,1ll*d[i]*x%MOD);\n//\t\tadd(ans,-1ll*d[i]*x%MOD);\n//\t\tprintf(\"%d %d\\n\",x,d[i]);\n\t}\n\tif(n%2==1) ans=2ll*ans*m%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u];i;i=sq[i].nxt)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,k;\nll f[2020];\nvector<int> fac;\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nll qpow(ll x,int y)\n{\n\tll ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=ans*x%maxd;\n\t\tx=x*x%maxd;y>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tn=read();k=read();\n\tfor (int i=1;i*i<=n;i++)\n\t{\n\t\tif (n%i) continue;\n\t\tfac.pb(i);\n\t\tif (i*i!=n) fac.pb(n/i);\n\t}\n\tint len=fac.size();\n\tsort(fac.begin(),fac.end());\n\trep(i,0,len-1)\n\t{\n\t\tint x=fac[i];\n\t\tf[i]=qpow(k,(x+1)/2);\n\t\trep(j,0,i-1)\n\t\t\tif (x%fac[j]==0)\n\t\t\t\tf[i]=(f[i]-f[j]+maxd)%maxd;\n\t}\n\tll ans=0;\n\trep(i,0,len-1)\n\t\tif (fac[i]&1) ans=(ans+f[i]*fac[i])%maxd;\n\t\telse ans=(ans+f[i]*(fac[i]/2))%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\ntypedef long long LL;\nint T;\nLL n,k;int md,ans;\ninline LL mul(LL a,LL b,const LL&md){\n\tLL c=a*b-LL((long double)a*b/md+.5)*md;\n\treturn(c>>63&md)+c;\n}\ninline int intpow(int a,LL b){\n\tint ret=1;for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;return ret;\n}\ninline LL pow(LL a,LL b,const LL&md){\n\tLL ret=1;for(a%=md;b;b>>=1,a=mul(a,a,md))if(b&1)ret=mul(ret,a,md);return ret;\n}\nnamespace MR{\n\tconst int P[]={2,3,5,7,11,13,17,19,23,29,31,37};\n\tbool check(int a,LL n){\n\t\tLL x=n-1;int d=0;\n\t\twhile(!(x&1))x>>=1,++d;\n\t\tfor(x=pow(a,x,n);d--;){\n\t\t\tconst LL lst=x;x=mul(x,x,n);\n\t\t\tif(x==1&&lst!=1&&lst!=n-1)return 0;\n\t\t}\n\t\treturn x==1;\n\t}\n\tbool test(LL n){\n\t\tif(n==1)return 0;\n\t\tfor(int i:P)if(n==i)return 1;\n\t\tif(!(n&1))return 0;\n\t\tfor(int i:P)if(!check(i,n))return 0;\n\t\treturn 1;\n\t}\n}\nvector<LL>v;\nLL find(LL n,int c){\n\tLL x=rand()%(n-1)+1,y=x,k=2,q=1,t=1;\n\tfor(;;k<<=1,y=x,q=1){\n\t\tfor(int i=1;i<=k;++i){\n\t\t\tx=mul(x,x,n)+c-n;x+=x>>63&n;\n\t\t\tq=mul(q,llabs(x-y),n);\n\t\t\tif(!(i&127)){\n\t\t\t\tt=std::__gcd(q,n);\n\t\t\t\tif(t>1)return t;\n\t\t\t}\n\t\t\tt=std::__gcd(q,n);\n\t\t\tif(t>1)return t;\n\t\t}\n\t}\n}\nvoid rho(LL n){\n\tif(n==1)return;\n\tif(MR::test(n))return v.push_back(n);\n\tLL p=n;int c=19260817;\n\twhile(p==n)p=find(p,c--);\n\twhile(n%p==0)n/=p;\n\trho(p),rho(n);\n}\nvoid dfs(int nw,LL t,int mx){\n\tif(nw==v.size()){\n\t\tif(t%2==0&&n/t%2==1)return;\n\t\tt=n/t;\n\t\tans=(ans+intpow(k%md,t+1>>1)*((t%2==0?t/2:t)%md)%md*mx)%md;\n\t}else\n\tfor(LL x=1;x<=n&&n%x==0;x=(x<=n/v[nw])?x*v[nw]:n+1)\n\tdfs(nw+1,t*x,(x==1)?mx:(mx*(md+1-v[nw]%md)%md));\n}\nint main(){\n\tsrand(time(0));\n\tfor(T=1;T--;){\n\t\tscanf(\"%lld%lld\",&n,&k),ans=0,v.clear();md=1e9+7;\n\t\trho(n),sort(v.begin(),v.end()),v.erase(unique(v.begin(),v.end()),v.end());\n\t\tdfs(0,1,1),printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <queue>\n#include <map>\n#include <cstring>\n#include <unordered_set>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nvector<int> getOverlapSuffix(string pattern) {\n    int m = pattern.length();\n    vector<int> os(m);\n    os[m - 1] = m;\n    int left = m - 1, s;\n    for (int i = m - 2; i >= 0; --i) {\n        if (i > left && os[i + s] < i - left) os[i] = os[i + s];\n        else {\n            if (i < left) left = i;\n            s = m - 1 - i;\n            while(left >= 0 && pattern[left] == pattern[left + s]) --left;\n            os[i] = i - left;\n        }\n    }\n    return os;\n}\n\nvector<int> computeGS(string pattern) {\n    int m = pattern.length();\n    vector<int> OSuff = getOverlapSuffix(pattern);\n    vector<int> goodS(m, m);\n    int j = 0;\n    for (int i = m - 2; i >= 0; --i) {\n        if (OSuff[i] == i + 1) {\n            while (j <= m - 1 - i) {\n                goodS[j++] = m - 1 - i;\n            }\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        goodS[m - 1 - OSuff[i]] = m - 1 - i;\n    }\n    return goodS;\n}\n\nvector<int> computeBC(string &pattern) {\n    int m = pattern.length();\n    vector<int> badC(256, -1);\n    for (int i = 0; i < m; ++i) {\n        badC[pattern[i] - 0] = i;\n    }\n    return badC;\n}\n\nint boyermoore(string haystack, string needle) {\n    int m = needle.length();\n    int n = haystack.length();\n    vector<int> badC = computeBC(needle);\n    vector<int> goodS = computeGS(needle);\n    for (int s = 0; s < n; ++s) {\n        int j = m - 1;\n        while (j >= 0 && haystack[s + j] == needle[j]) --j;\n        if (j == -1) {\n            return s;\n        }\n        s += max(goodS[j], j - badC[haystack[s + j]]) - 1;\n    }\n    return -1;\n}\n\nint main() {\n    long long N, K;\n    cin >> N >> K;\n    long long result = 1;\n    for (int i = 0; i < (N + 1) / 2; ++i) {\n        result = (result * K) % 1000000007;\n    }\n    long long n = (1000000007 + result - K) % 1000000007;\n    if ((N & 1) == 1) {\n        result = (result + n * (N - 1)) % 1000000007;\n    } else {\n        result = (result + n * (N / 2 - 1)) % 1000000007;\n    }\n    cout << result << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvector<int> divisors(int n) {\n    vector<int> res;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            res.push_back(i);\n            if (i * i != n) {\n                res.push_back(n / i);\n            }\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nint add(int a, int b) {\n    return (a += b) >= mod ? a - mod : a;\n}\n\nint mul(int a, int b) {\n    return 1LL * a * b % mod;\n}\n\ntemplate<class... T>\nint mul(int a, T... b) {\n    return mul(a, mul(b...));\n}\n\nint modpow(int a, long long b) {\n    int res = 1;\n    for (; b > 0; a = mul(a, a), b >>= 1) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n, K;\n    cin >> n >> K;\n    vector<int> ds = divisors(n);\n    vector<int> dp(ds.size());\n    for (int i = 0; i < ds.size(); i++) {\n        dp[i] = modpow(K, (ds[i] + 1) / 2);\n        for (int j = 0; j < i; j++) {\n            if (ds[i] % ds[j] == 0) {\n                dp[i] = add(dp[i], mod - dp[j]);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < ds.size(); i++) {\n        if (ds[i] % 2 == 0) {\n            ans = add(ans, mul(dp[i], ds[i], (mod + 1) / 2));\n        } else {\n            ans = add(ans, mul(ds[i], dp[i]));\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nconst ll MOD=1e9+7;\nll fpow(ll a,ll p){\n\tll res=1LL;\n\twhile(p){\n\t\tif(p&1LL) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tp>>=1LL;\n\t}\n\treturn res;\n}\nll n,k;\nvector<ll> divisors,dp;\n\nint main() {\n\t#ifdef kvutxdy\n\tfreopen(\"C:/Users/khanh/OneDrive/RoadtoPurple/Code/Codeforces/input.in\", \"r\", stdin);\n\t#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;++i) if(n%i==0){\n\t\tdivisors.push_back(i);\n\t\tif(i*i!=n) divisors.push_back(n/i);\n\t}\n\tsort(divisors.begin(),divisors.end());\n\tint m=divisors.size();\n\tll res=0LL;\n\tdp.resize(m);\n\tfor(int i=0;i<m;++i){\n\t\tdp[i]=fpow(k,(divisors[i]+1)/2);\n\t\tfor(int j=0;j<i;++j) if(divisors[i]%divisors[j]==0){\n\t\t\tdp[i]-=dp[j];\n\t\t\tif(dp[i]<0) dp[i]+=MOD;\n\t\t}\n\t\tll tmp=dp[i]*divisors[i]%MOD;\n\t\tif(divisors[i]%2==0) (tmp*=fpow(2LL,MOD-2LL))%=MOD;\n\t\t(res+=tmp)%=MOD; \n\t}\n\tcout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nll mod_pow(ll a,ll x){\n  ll ret=1;\n  while(x>0){\n    if(x&1){(ret*=a)%=MOD;}\n    (a*=a)%=MOD;\n    x>>=1;\n  }\n  return ret;\n}\n\n\nint main(){\n  ll N,K,a;\n  cin>>N>>K;\n  a=N;\n  vector<ll> A;\n  for(ll i=1;i*i<=N;i++){\n    if(N%i==0){\n      A.push_back(i);\n      if(i*i!=N){A.push_back(N/i);}\n    }\n  }\n  sort(A.begin(),A.end());\n  vector<ll> dp(A.size(),0);\n  for(int i=0;i<(int)A.size();i++){\n    dp[i]=mod_pow(K,(A[i]+1)/2);\n    for(int j=0;j<i;j++){\n      if(A[i]%A[j]==0){dp[i]-=dp[j];}\n    }\n    dp[i]%=MOD;\n  }\n  ll ans=0;\n  for(int i=0;i<A.size();i++){\n    if(A[i]%2==0){ans+=dp[i]*A[i]%MOD*((MOD+1)/2)%MOD;}\n    else{ans+=dp[i]*A[i]%MOD;}\n  }\n  ans%=MOD;\n  if(ans<0){ans+=MOD;}\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint N, K, ans;\nvector<int> Dv;\nint add[100000];\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n\n    ans = 0;\n    ans += 1LL * exp(K, (N + 1) / 2) * (N % 2 == 0? N / 2 : N) % mod;\n    ans %= mod;\n\n    for(int i = 1; i <= sqrt(N); i++) {\n        if(N % i == 0) {\n            Dv.push_back(i);\n            Dv.push_back(N / i);\n        }\n    }\n    sort(Dv.begin(), Dv.end());\n\n    for(int i = 0; i < Dv.size(); i++) {\n        int d = Dv[i];\n        if(d == N) break;\n\n        add[i] += exp(K, (d + 1) / 2);\n\n        for(int j = 0; j < i; j++) {\n            if(Dv[i] % Dv[j] == 0) {\n                add[i] += mod - add[j];\n                add[i] %= mod;\n            }\n        }\n\n        ans += mod - 1LL * add[i] * ((N % 2 == 0? N / 2 : N) - (d % 2 == 0? d / 2 : d)) % mod;\n        ans %= mod;\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\n#define SZ(x) ((int)x.size())\n\nconst ll base = (ll)1e9+7;\nll n, k, dp[5005];\nvector<ll> d;\n\nll fast_pw(ll x, ll y) {\n\tif (y == 0) return 1;\n\tif (y == 1) return x;\n\tll tmp = fast_pw(x, y / 2ll);\n\ttmp = (tmp * tmp) % base;\n\tif (y % 2ll) tmp = (tmp * x) % base;\n\treturn tmp;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\tfor (ll i = 1; i*i <= n; ++i) {\n\t\tif (n % i == 0) d.push_back(i);\n\t\tif (n / i != i) d.push_back(n / i);\n\t}\n\tsort(d.begin(), d.end());\n\tll ans = 0;\n\tfor (int i = 0; i < SZ(d); ++i) {\n\t\tdp[i] = fast_pw(k, d[i] / 2 + d[i] % 2);\n\t\tfor (int j = 0; j < i; ++j) if (d[i] % d[j] == 0)\n\t\t\tdp[i] = (dp[i] - dp[j] + base) % base;\n\t\tif (d[i] % 2 == 0) ans = (ans + dp[i] * (ll)(d[i] / 2) % base) % base;\n\t\telse ans = (ans + dp[i] * (ll)d[i] % base) % base;\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=1e9+7,N=2e5+20;\nll n,k,dp[2500];\nint qpow(ll x,int k){\n\tll ans=1;\n\twhile(k){\n\t\tif(k&1) ans*=x;\n\t\tk>>=1,x*=x;\n\t\tans%=mod,x%=mod;\n\t}\n\treturn ans;\n}\nint v[3000],cnt;\nvoid init(){\n\tfor(ll i=1;i*i<=n;i++)if(n%i==0){\n\t\tv[++cnt]=i;\n\t\tif(i*i!=n) v[++cnt]=n/i;\n\t}\n\tsort(v+1,v+cnt+1);\n}\nint main()\n{\n\tcin>>n>>k;\n\tinit();\n\tll ans=0;\n\tfor(int x=1;x<=cnt;x++){\n\t\tdp[x]=qpow(k,(v[x]+1)/2);\n\t\tfor(int y=1;y<x;y++){\n\t\t\tif(v[x]%v[y]==0)\n\t\t\t\tdp[x]=(dp[x]-dp[y]+mod)%mod;\t\n\t\t}\t\n\t\tif(v[x]%2)\n\t\t\tans=(ans+(dp[x]*v[x])%mod)%mod;\n\t\telse\n\t\t\tans=(ans+(dp[x]*v[x]/2)%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, K;\nmap<ll, ll> memo;\nset<int> divisors;\n\n\nvoid input() {\n  cin >> N >> K;\n}\n\n\nvoid preprocess() {\n  int till = min((int)(sqrt(N)) + 2, N);\n  for (int i = 1 ; i <= till ; i++) {\n    if (N % i == 0) {\n      divisors.insert(i);\n      divisors.insert(N / i);\n    }\n  }\n}\n\n\nvoid solve() {\n  for (auto it1 = divisors.begin() ; it1 != divisors.end() ; it1++) {\n    int d = *it1;\n    ll ways = getPowMod(K, ceil(d/2.0));\n    for (auto it2 = divisors.begin() ; it2 != it1 ; it2++) {\n      if (d % (*it2) == 0) {\n        ways = modSubtract(ways, memo[(*it2)]);\n      }\n    }\n    memo[d] = ways;\n  }\n  ll ans = 0;\n  for (auto p : memo) {\n    if (p.first % 2 == 0) {\n      ans = modSum(ans, modProd(p.second, p.first / 2));\n    } else {\n      ans = modSum(ans, modProd(p.second, p.first));\n    }\n  }\n  cout << ans;\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define sync ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define F first\n#define S second\n#define pb emplace_back\n#define mt make_tuple\n#define gcd __gcd\n#define PI 3.141592653589\n// Input\n#define in(a) scanf(\"%d\",&a)\n#define in2(a,b) scanf(\"%d%d\",&a,&b)\n#define in3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define llin(a) cin >> a\n#define inl(a) scanf(\"%lld\",&a)\n#define read(v,i,n) for(i=0;i<n;i++)in(v[i])\n#define twod(mat,i,j,n,m) rep(i,n){rep(j,m)in(mat[i][j]);}\n#define sc(ch) scanf(\"%c\",&ch)\n#define sstr(str) scanf(\"%s\",str)\n// Output\n#define pr(a) printf(\"%d \",a)\n#define pr2(a,b) printf(\"%d %d\\n\",a,b)\n#define pr3(a,b,c) printf(\"%d %d %d\\n\",a,b,c)\n#define out(a) printf(\"%d\\n\",a)\n#define outl(a) printf(\"%lld\\n\",a)\n#define llpr(a) cout << a << \" \"\n#define llout(a) cout << a << \"\\n\"\n#define yes printf(\"YES\\n\")\n#define no printf(\"NO\\n\")\n#define lin printf(\"\\n\")\n// Iterator\n#define lp(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) for(i=0;i<n;i++)\n#define all(vec) vec.begin(),vec.end()\n#define lower(v,k) lower_bound(v.begin(),v.end(),k)-v.begin()\n#define upper(v,k) upper_bound(v.begin(),v.end(),k)-v.begin()\n#define tf(mytuple) get<0>(mytuple)\n#define ts(mytuple) get<1>(mytuple)\n#define tt(mytuple) get<2>(mytuple)\n// Debug\n#define dbg(v,i,n) for(i=0;i<n;i++)pr(v[i]); lin\n#define what(x) cerr << #x << \" : \" << x << \"\\n\"\n#define ck printf(\"continue\\n\")\n#define debug(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\nvoid err(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args)\n{\n\tcerr << *it << \" = \" << a << \"\\n\";\n\terr(++it, args...);\n}\n// Data Type\n#define ll long long int\n#define ii pair<int,int>\n//#define pli pair<ll,int>\n#define triple tuple<int,int,int>\n#define vi vector<int>\n#define vii vector<pair<int,int> >\n#define vvi vector<vector<int> >\n#define viii vector<pair<pair<int,int>,int> >\n#define vvii vector<vector<pair<int,int> > >\n#define M 1000000007\n#define N 1005  //check the limits, man\nconst ll INF = 1e12;\nll pro(ll a,ll b)\n{\n    return (a*b)%M;\n}\nll power(ll a,ll b)\n{\n    ll x=1;\n    a%=M;\n    while(b>0)\n    {\n        if(b&1)\n            x=pro(x,a);\n        b=b>>1;\n        a=pro(a,a);\n    }\n    return x;\n}\nint main()\n{\n    int n,k,m;\n    ll ans;\n    in2(n,k);\n    if(n&1)\n    {\n        m=(n+1)/2;\n        ans=power(k,m);\n        ans=(ans-k+M);\n        ans=pro(ans,n);\n    }\n    else\n    {\n        m=(n/2);\n        ans=power(k,m);\n        ans=(ans-k+M);\n        ans=pro(ans,m);\n    }\n    ans+=k;\n    llout(ans%M);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tcout << modpow(k, (n + 1) / 2)*n%mod << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[2005], dp[2005];\nint mod = 1e9 + 7;\nint binpow(int a, int b){\n\tif (b == 0) return 1;\n\tint x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nint main(){\n\tint n, k; cin >> n >> k;\n\tint cur = 0;\n\tfor (int i = 1; i <= sqrt(n); i++){\n\t\tif (n % i == 0){\n\t\t\ta[cur] = i; cur++;\n\t\t\tif (i * i != n){\n\t\t\t\ta[cur] = n / i; cur++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a, a + cur);\n\tfor (int i = 0; i < cur; i++){\n\t\tdp[i] = binpow(k, (a[i] + 1) / 2);\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (a[i] % a[j] == 0){\n\t\t\t\t((dp[i] -= dp[j]) += mod) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < cur; i++){\n\t\tif (a[i] % 2) (ans += (dp[i] * a[i])) %= mod;\n\t\telse (ans += (dp[i] * (a[i] / 2))) %= mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= MOD;\n\tif(k%2 == 1){\n\t\tret *= x;\n\t\tret %= MOD;\n\t}\n\treturn ret;\n}\n\nvector<ll> divisors(ll n){\n\tvector<ll> ret;\n\tret.push_back(1);\n\tfor(int i = 2 ; n > 1 ; i ++){\n\t\tif(i*i > n)i = n;\n\t\tif(n%i == 0){\n\t\t\tint cnt = 0;\n\t\t\twhile(n%i == 0){\n\t\t\t\tn /= i;\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t\tint m = ret.size();\n\t\t\tll x = 1;\n\t\t\tfor(int j = 0 ; j < cnt ; j ++){\n\t\t\t\tx *= i;\n\t\t\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\t\t\tret.push_back(ret[i]*x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(),ret.end());\n\treturn ret;\n}\n\nint main(){\n\tll n,k;\n\tcin >> n >> k;\n\t\n\tvector<ll> div = divisors(n);\n\tll ret = 0;\n\tll cnt[1400];\n\tfor(int i = div.size()-1 ; i >= 0 ; i --){\n\t\tll d = div[i];\n\t\tif(d&1)cnt[i] = d;\n\t\telse cnt[i] = d/2;\n\t\tfor(int j = i+1 ; j < div.size() ; j ++){\n\t\t\tif(div[j]%d == 0)cnt[i] += MOD-cnt[j];\n\t\t}\n\t\tll sum = cnt[i]%MOD;\n\t\tsum *= modpow(k,(d+1)/2);\n\t\tret += sum;\n\t\tret %= MOD;\n\t}\n\tcout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nll binpow(ll x, ll e) {\n  ll ret = 1, p = x;\n  while(e > 0) {\n    if(e&1) {(ret *= p) %= MOD; e--;}\n    else {(p *= p) %= MOD; e /= 2;} \n  }\n  return ret;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, k;\n    cin >> n >> k;\n\n    vector<ll> div;\n    for(ll i=1; i*i<=n; ++i) {\n        if(n%i == 0) {\n            div.push_back(i);\n            if(n/i != i) div.push_back(n/i);\n        }\n    }\n    sort(ALL(div));\n\n    ll m = div.size(), ret = 0, inv2 = binpow(2, MOD-2);\n    vector<ll> dp(m);\n    REP(i, m) {\n        // 周期div[i]以下の回文が何通りか\n        dp[i] = binpow(k, ceil(div[i], 2LL));\n        // div[i]の約数の分を引く\n        for(ll j=0; j<i; ++j) {\n            if(div[i]%div[j]) continue;\n            (dp[i] += MOD - dp[j]) %= MOD;\n        }\n        if(div[i]%2) (ret += div[i] * dp[i] % MOD) %= MOD;\n        else (ret += div[i] * dp[i] % MOD * inv2 % MOD) %= MOD;\n    }\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst ll mod=1e9+7;\n\nll mod_pow(ll x, ll n)\n{\n    ll pw[40];\n    pw[0]=x;\n    for(int i=1; i<40; ++i) pw[i]=(pw[i-1]*pw[i-1])%mod;\n\n    ll ret=1;\n    rep(i,40)\n    {\n        if(n>>i&1) (ret*=pw[i])%=mod;\n    }\n    return ret;\n}\n\nvector<int> factor(int n)\n{\n    vector<int> ret;\n\n    int t=n;\n    for(int i=1; i*i<=n; ++i)\n    {\n        if(n%i==0)\n        {\n            ret.pb(i);\n            if(i != n/i) ret.pb(n/i);\n            t /= i;\n        }\n    }\n    if(t>1) ret.pb(t);\n\n    sort(all(ret));\n    return ret;\n}\n\nint main()\n{\n    int n,k;\n    scanf(\" %d %d\", &n, &k);\n\n    vector<int> d = factor(n);\n    int D=d.size();\n\n    vector<ll> dp(D);\n    rep(i,D)\n    {\n        dp[i] = mod_pow(k,(d[i]+1)/2);\n\n        rep(j,i)if(d[i]%d[j]==0) dp[i] = (dp[i]-dp[j]+mod)%mod;\n    }\n\n    ll ans=0;\n    rep(i,D)\n    {\n        if(d[i]%2==0) (ans+=dp[i]*d[i]/2)%=mod;\n        else (ans+=dp[i]*d[i])%=mod;\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvector<ll> divisors(ll x) {\n    vector<ll> res;\n    for(int i = 1; i * i <= x; ++ i) {\n        if(x % i == 0) {\n            res.pb(i);\n            if(i * i != x) res.pb(x / i);\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n\tll n, k; cin >> n >> k;\n    map<int, mint> dp;\n    auto di = divisors(n);\n    sort(all(di));\n    for(int d: di) {\n        dp[d] = modpow((mint)k, (d + 1) / 2);\n        for(int d2: divisors(d)) {\n            if(d == d2) continue;\n            dp[d] -= dp[d2];\n        }\n    }\n    mint ans = 0;\n    for(auto p: dp) {\n        int d = p.fr; mint tmp = p.sc;\n        if(d % 2 == 1) {\n            ans += tmp * (mint)d;\n        } else {\n            ans += tmp * (mint)(d / 2);\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(int value) { \n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tunsigned int Get_value() {\n\t\treturn value_m;\n\t}\n};\n\ntypedef IntMod<1000000007> MInt;\n\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = a; i < n; ++i)\n#define REPM(i,n,a) for(int i = n - 1; i >= a; --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFD 1.0e+308\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nint N, K;\n\n/* なんとかの公式っていうやつあった気がするなあ… */\n/* 素数の2倍とかのときなら通る？ */\nint main() {\n\tMInt sum;\n\tcin >> N >> K;\n\tif (N % 2 == 0) {\n\t\tsum = MInt(K).Pow(N / 2) * N;\n\t\tsum -= MInt(N) * K;\n\t\tsum /= 2;\n\t\tsum += K;\n\t} else {\n\t\tsum = MInt(K).Pow(N / 2 + 1) * N;\n\t\tsum -= MInt(N - 1) * K;\n\t}\n\tcout << sum.Get_value() << endl;\n\tvolatile char a = getchar();\n\ta = getchar();\ta = getchar();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1100000000000000000\n\nint beki(int a,int b,int M = modulo){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=((long long)x*a)%M;\n\t\t}\n\t\ta=((long long)a*a)%M;\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\n\nint gyakugen(int a){\n\treturn beki(a,modulo-2);\n}\n\nint main(){\n\t\n\tint N,K;\n\tcin>>N>>K;\n\t\n\tvector<int> Y;\n\tfor(int i=1;i*i<=N;i++){\n\t\tif(N%i==0){\n\t\t\tY.push_back(i);\n\t\t\tif(i*i!=N)Y.push_back(N/i);\n\t\t}\n\t}\n\t\n\tsort(Y.begin(),Y.end());\n\tvector<int> c(Y.size(),0);\n\t\n\tfor(int i=0;i<Y.size();i++){\n\t\tc[i] = beki(K,(Y[i]+1)/2);\n\t\t\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(Y[i]%Y[j]==0){\n\t\t\t\tint x = c[j];\n\t\t\t\tc[i] = mod(c[i]-x);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor(int i=0;i<Y.size();i++){\n\t\tif(Y[i]%2==0)ans = mod(ans + mod(Y[i] * c[i]/2));\n\t\telse ans = mod(ans + mod(Y[i] * c[i]));\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long lli;\ntypedef vector<lli> vll;\ntypedef vector<vector<lli> > mat;\nconst lli MOD = 1000000007;\nlli n,k;\nvll d;\nvll dp;\nlli ans = 0;\nlli pow(lli a,lli n,lli mod = MOD){\n\tlli ret = 1;\n\tfor(;n!=0;n=n>>1){\n\t\tif(n&1) ret = (ret * a) % mod;\n\t\ta = (a * a) % mod;\n\t}\n\treturn ret;\n}\nint main(){\n    cin >> n >> k;\n    lli i;\n    for(i = 1;i*i < n;i++) if(n%i == 0) d.push_back(i),d.push_back(n/i);\n    if(i*i == n) d.push_back(i);\n    sort(d.begin(),d.end());\n    dp = vector<lli> (d.size());\n    for(lli i = 0;i < d.size();i++){\n        dp[i] += pow(k,(d[i]+1)/2);//k*(d[i]+1)/2;\n        dp[i] %= MOD;\n        for(lli j = i+1;j < d.size();j++){\n            if(d[j]%d[i] == 0) dp[j] -= dp[i],dp[j] = (dp[j] + MOD) % MOD;\n        }\n    }\n    for(lli i = 0;i < d.size();i++){\n        ans += (dp[i]*(d[i]%2 ? d[i] : d[i]/2)) % MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\n#define mod 1000000007\n\nint n, k, ans;\n\nint qpow(int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)res = (long long)res * a % mod;\n\t\ta = (long long)a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tset<int> v;\n\tunordered_map<int, int> s;\n\tfor (int i = 1; i * i <= n; ++i)\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tv.insert(i);\n\t\t\tif (i * i != n)v.insert(n / i);\n\t\t}\n\tfor (auto x : v)\n\t{\n\t\tint res = qpow(k, (x + 1) / 2);\n\t\tfor (int i = 1; i * i <= x; ++i)\n\t\t\tif (x % i == 0)\n\t\t\t{\n\t\t\t\tres -= s[i];\n\t\t\t\tif (res < 0)res += mod;\n\t\t\t\tif (i * i != x)\n\t\t\t\t{\n\t\t\t\t\tres -= s[x / i];\n\t\t\t\t\tif (res < 0)res += mod;\n\t\t\t\t}\n\t\t\t}\n\t\ts[x] = res;\n\t\tans += (long long)res * (x % 2 ? x : x / 2) % mod;\n\t\tif (ans >= mod)ans -= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nint n,m,cnt,sum,a[100005],ans[100005]; bool flag;\nint ksm(int x,int y){\n\tint z=1; for (; y; y>>=1,x=(ll)x*x%mod) if (y&1) z=(ll)z*x%mod;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,j; \n\tif (n&1) flag=1; else n/=2;\n\tfor (i=1; i*i<=n; i++) if (!(n%i)){\n\t\ta[++cnt]=i;\n\t\tif (i*i<n) a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\tfor (i=1; i<=cnt; i++){\n\t\tans[i]=(ans[i]+ksm(m,(flag)?(a[i]+1>>1):a[i]))%mod;\n\t\tsum=(sum+(ll)ans[i]*a[i])%mod;\n\t\tfor (j=i+1; j<=cnt; j++) if (!(a[j]%a[i])) ans[j]=(ans[j]+mod-ans[i])%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3e5 + 9, mod = 1e9 + 7;\n\ntemplate <const int32_t MOD>\nstruct modint {\n    int32_t value;\n    modint() = default;\n    modint(int32_t value_) : value(value_) {}\n    inline modint<MOD> operator + (modint<MOD> other) const { int32_t c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }\n    inline modint<MOD> operator - (modint<MOD> other) const { int32_t c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }\n    inline modint<MOD> operator * (modint<MOD> other) const { int32_t c = (int64_t)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }\n    inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (int64_t)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }\n    modint<MOD> pow(uint64_t k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }\n    modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }\n    inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (modint<MOD> other) const { return value == other.value; }\n    inline bool operator != (modint<MOD> other) const { return value != other.value; }\n    inline bool operator < (modint<MOD> other) const { return value < other.value; }\n    inline bool operator > (modint<MOD> other) const { return value > other.value; }\n};\ntemplate <int32_t MOD> modint<MOD> operator * (int64_t value, modint<MOD> n) { return modint<MOD>(value) * n; }\ntemplate <int32_t MOD> modint<MOD> operator * (int32_t value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }\ntemplate <int32_t MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }\ntemplate <int32_t MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }\n\nusing mint = modint<mod>;\n\nmint ans[N];\nint32_t main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, k; cin >> n >> k;\n\tvector<int> d;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\td.push_back(i);\n\t\t\tif (i != n / i) d.push_back(n / i);\n\t\t}\n\t}\n\tsort(d.begin(), d.end());\n\tfor (int i = 0; i < d.size(); i++) {\n\t\tans[i] = mint(k).pow((d[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; j++) if (d[i] % d[j] == 0) ans[i] -= ans[j];\n\t}\n\tmint res = 0;\n\tfor (int i = 0; i < d.size(); i++) {\n\t\tif (d[i] & 1) res += ans[i] * d[i];\n\t\telse res += ans[i] * d[i] / 2;\n\t}\n\tcout << res << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\n\nusing namespace std;\n\nconst int maxn=1e5+5,md=1e9+7;\n\nll a[maxn],f[maxn];\nll i,j,k,l,m,n,x,y,ans,now,p;\n\nll quickmi(ll x,ll y){\n\tll t1=1;\n\twhile (y){\n\t\tif ((y & 1)) t1=(t1*x)%md;\n\t\tx=(x*x)%md;\n\t\ty/=2; \n\t}\n\treturn t1;\n}\nint main(){\n\twhile (cin>>n>>k){\n\tp=n; now=0;\n\tfor(i=1;i*i<=p;i++){\n\t\tif (p%i==0){\n\t\t\ta[++now]=i;\n\t\t\tif ((p/i)!=i) a[++now]=p/i;\n\t\t}\n\t}\n\tsort(a+1,a+now+1);\n\tmemset(f,0,sizeof(f)); ans=0;\n\tfo(i,1,now){\n\t\tf[i]=quickmi(k,(a[i]+1)/2);\n\t\tfo(j,1,i-1) if (a[i]%a[j]==0) f[i]=(f[i]-f[j]+md)%md;\n\t\tif (a[i]%2==0) ans=(ans+f[i]*(a[i]/2))%md;\n\t\telse ans=(ans+f[i]*a[i])%md;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1e9 + 7;\n\nint n, k, ans;\nunordered_map<int, int>f;\n\nint qp (int a, int b) { int c = 1; for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) c = 1ll * c * a % P; return c; }\n\nint d (int n) {\n\tif (f.count(n)) return f[n];\n\tint ret = qp(k, (n + 1) >> 1);\n\tfor (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n\t\tret = (ret + P - d(i)) % P;\n\t\tif (i > 1 && i * i != n) ret = (ret + P - d(n / i)) % P;\n\t}\n\treturn f[n] = ret;\n}\n\nvoid calc (int x) {\n\tint ret = d(x);\n\tif (!(x & 1)) x >>= 1;\n\tans = (1ll * ret * x + ans) % P;\n}\n\nint main () {\n\tscanf(\"%d%d\", &n, &k); f[1] = k;\n\tfor (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n\t\tcalc(i);\n\t\tif (i * i != n) calc(n / i);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nconst ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    mint K;\n    cin >> N >> K.x;\n    vec<ll> divisors;\n    if(N==1){\n        cout << K.x << endl;\n        return 0;\n    }\n    for(int i=1;i*i<=N;i++){\n        if(N%i==0){\n            if(i<=N/2) divisors.push_back(i);\n            if(i<=N/2 && i*i!=N) divisors.push_back(N/i);\n        }\n    }\n    sort(divisors.begin(),divisors.end());\n    int n = divisors.size();\n    vec<mint> f(n),g(n);\n    for(int i=0;i<n;i++){\n        if(N%2) g[i] = K.pow((divisors[i]+1)/2);\n        else{\n            g[i] = (N/2%divisors[i]? K.pow(divisors[i]/2):K.pow(divisors[i]));\n        }\n        for(int j=0;j<i;j++) if(divisors[i]%divisors[j]==0) g[i] -= g[j];\n    }\n    mint ans = 0;\n    for(int i=n-1;i>=0;i--){\n        f[i] = g[i];\n        ans += f[i]*divisors[i];\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nll N, K;\nconst ll MOD = 1000000007;\nmap<ll, ll> mp;\n\nvector<ll> divs(ll m){\n    vector<ll> ans;\n    for(ll i = 1; i*i <= m; i++){\n        if(m%i == 0) {\n            ans.push_back(i);\n            if(i*i != m) ans.push_back(m/i);\n        }\n    }\n    sort(ans.begin(), ans.end());\n    return ans;\n}\n\ntemplate <typename T>\nT pow(T a, ll n) {\n\tT ans = 1;\n\tT tmp = a;\n\tfor (int i = 0; i <= 60; i++) {\n\t\tll m = (ll)1 << i;\n\t\tif (m & n) {\n\t\tans *= tmp;\n\t\tans %= MOD;\n\t\t}\n\t\ttmp *= tmp;\n\t\ttmp %= MOD;\n\t}\n\treturn ans;\n}\n\nll calc(ll m){\n    return pow<ll>(K, (m+1)/2);\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> K;\n    vector<ll> v = divs(N); \n    ll ans = 0;\n    for(int i : v){\n        ll tmp = calc(i);\n        for(int j : v){\n            if(j < i && i%j == 0){\n                tmp -= mp[j];\n                tmp += MOD;\n                tmp %= MOD;\n            }\n            mp[i] = tmp;\n        }\n        // cout << i << ' ' << mp[i] << endl;\n        if(i%2 == 1) ans += (mp[i]*i)%MOD;\n        else ans += (mp[i]*i/2)%MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n6 3 -> 75\nababab\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\nvector<int> d, f;\n\nvoid add(int &x,int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\nint pw(int x,int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n >> k;\n\tfor (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n\t\td.push_back(i);\n\t\tif (i < (n / i)) d.push_back(n / i);\t\n\t}\n\tsort(d.begin(), d.end());\n\tf.resize(d.size());\n\tint ans = 0;\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tf[i] = pw(k, (d[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; ++j) if (d[i] % d[j] == 0) {\n\t\t\tadd(f[i], mod - f[j]);\n\t\t} \n\t\tadd(ans, 1ll * f[i] * (d[i] & 1 ? d[i] : d[i] >> 1) % mod);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nconst int N=100000+19;\nconst int p=1e9+7;\n\nint Pow(int a,int b){\n\tint res=1;\n\tfor (;b;b>>=1,a=1ll*a*a%p) if (b&1) res=1ll*res*a%p;\n\treturn res;\n}\n\nint d[N],f[N];\nint n,k,res;\n\nint main(){\n\tn=IN(),k=IN();\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\td[++*d]=i;\n\t\t\tif (i*i!=n) d[++*d]=n/i;\n\t\t}\n\tsort(d+1,d+*d+1);\n\tFor(i,1,*d+1){\n\t\tf[i]=Pow(k,(d[i]+1)/2);\n\t\tFor(j,1,i)\n\t\t\tif (d[i]%d[j]==0){\n\t\t\t\tf[i]=(f[i]-f[j]+p)%p;\n\t\t\t}\n\t\tif (d[i]&1){\n\t\t\tres=(res+1ll*d[i]*f[i])%p;\n\t\t} else{\n\t\t\tres=(res+1ll*d[i]*f[i]%p*Pow(2,p-2))%p;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst ll mod=1e9+7;\n\nll mod_pow(ll x, ll n)\n{\n    ll pw[40];\n    pw[0]=x;\n    for(int i=1; i<40; ++i) pw[i]=(pw[i-1]*pw[i-1])%mod;\n\n    ll ret=1;\n    rep(i,40)\n    {\n        if(n>>i&1) (ret*=pw[i])%=mod;\n    }\n    return ret;\n}\n\nvector<int> factor(int n)\n{\n    vector<int> ret;\n\n    for(int i=1; i*i<=n; ++i)\n    {\n        if(n%i==0)\n        {\n            ret.pb(i);\n            if(i != n/i) ret.pb(n/i);\n        }\n    }\n\n    sort(all(ret));\n    return ret;\n}\n\nint main()\n{\n    int n,k;\n    scanf(\" %d %d\", &n, &k);\n\n    vector<int> d = factor(n);\n    int D=d.size();\n\n    vector<ll> dp(D);\n    rep(i,D)\n    {\n        dp[i] = mod_pow(k,(d[i]+1)/2);\n\n        rep(j,i)if(d[i]%d[j]==0) dp[i] = (dp[i]-dp[j]+mod)%mod;\n    }\n\n    ll ans=0;\n    rep(i,D)\n    {\n        if(d[i]%2==0) (ans+=dp[i]*d[i]/2)%=mod;\n        else (ans+=dp[i]*d[i])%=mod;\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n//#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<list>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1e9+7;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\n//llint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tllint n,i,j,K;cin>>n>>K;\n\tvector<int>yku;\n\tfor(i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tyku.pub(i);\n\t\t\tif(i*i<n){yku.pub(n/i);}\n\t\t}\n\t}\n\tSO(yku);\n\tvector<llint>suu(yku.size());\n\tllint ans=0;\n\tfor(i=0;i<yku.size();i++){\n\t\tllint aaa=(yku[i]+1)/2;\n\t\tllint bgen=K;\n\t\tllint pta=1;\n\t\tfor(int h=0;h<30;h++){\n\t\t\tif(aaa&(1<<h)){pta*=bgen;pta%=mod;}\n\t\t\tbgen*=bgen;bgen%=mod;\n\t\t}\n\t\tllint xxx=yku[i];\n\t\tif(yku[i]%2==0){xxx/=2;}\n\t\tpta*=xxx;pta%=mod;pta-=suu[i];pta%=mod;\n\t\t//cerr<<\"pt=\"<<pta<<endl;\n\t\tfor(j=i+1;j<yku.size();j++){if(yku[j]%yku[i]==0){\n\t\t\tllint hos=yku[j];\n\t\t\tif(hos%2==0){hos/=2;}\n\t\t\tsuu[j]+=pta*hos/xxx;\n\t\t}}\n\t\tans+=pta;ans%=mod;\n\t\t\n\t}\n\tans+=mod;ans%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n\nconst long long mod = 1e9 + 7;\n\nlong long n, k, dp[100005], ans;\nvector<long long> divisor;\n\nlong long BinPow(long long m, long long t){\n    if(t == 0)\n        return 1;\n    else if(t == 1)\n        return m % mod;\n    else{\n        long long sum = BinPow(m, t / 2);\n        sum *= sum; sum %= mod;\n        if(t % 2 == 1){\n            sum *= m;\n            sum %= mod;\n        }\n        return sum % mod;\n    }\n}\n\nint main() {\n    cin.tie(0), ios::sync_with_stdio(0);\n    cin >> n >> k;\n    for(long long i = 1; i <= sqrt(n); i++){\n        if(n % i == 0){\n            divisor.pb(i);\n            if(i != n / i)\n                divisor.pb(n / i);\n        }\n    }\n    sort(divisor.begin(), divisor.end());\n    for(int i = 0; i < divisor.size(); i++){\n        dp[i] = BinPow(k, (divisor[i] + 1) / 2);\n        for(int j = 0; j < i; j++){\n            if(divisor[i] % divisor[j] == 0){\n            //cout << dp[i] << \" \" << dp[j] << \" \" << i << \" \" << j << \"\\n\";\n                dp[i] = dp[i] - dp[j];\n                dp[i] %= mod;\n            }\n        }\n        dp[i] = (dp[i] % mod + mod) % mod;\n        long long times = divisor[i];\n        if(times % 2 == 0)\n            times /= 2;\n        ans += (times * dp[i]) % mod;\n        ans %= mod;\n    }\n    cout << ans % mod << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\n\n// Problem Specific Parameter:\nconst ll mod=1000000007LL;\n\t\nll power(ll a,ll n){\n\tll b=1LL;\n\twhile(n){\n\t\tif(n&1) b=b*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nvector<int> fact;\nll num[1500];\n\nint main(void){\n\tll n,k;\n\tcin >> n >> k;\n\n\tfor(int i=1;i*i<=n;++i){\n\t\tif(n%i) continue;\n\t\tfact.emplace_back(i);\n\t\tif(i!=n/i) fact.emplace_back(n/i);\n\t}\n\n\tsort(_all(fact));\n\tconst int m=fact.size();\n\n\trep(i,m){\n\t\tll d=fact[i];\n\t\tnum[i]=power(k,(d+1)/2LL);\n\t\trep(j,i){\n\t\t\tif(d%fact[j]) continue;\n\t\t\tnum[i]+=mod-num[j];\n\t\t\tnum[i]%=mod;\n\t\t}\n\t}\n\n\tll ans=0LL;\n\trep(i,m){\n\t\tll d=fact[i];\n\t\tif(d%2)\n\t\t\tans+=d*num[i]%mod;\n\t\telse\n\t\t\tans+=d/2*num[i]%mod;\n\t\tans%=mod;\n\t}\t\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int mo=1000000007;\nint a[2000],f[2000];\n\nint ksm(int x,int y){\n\tint i=1;\n\tfor (;y;y>>=1,x=1ll*x*x%mo)\n\t\tif (y&1) i=1ll*i*x%mo;\n\treturn i;\n}\n\nint main(){\n\tint n,k,m=0,ans=0;\n\tscanf(\"%d%d\\n\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0) a[++m]=i;\n\tfor (int i=m;i;i--)\n\t\tif (a[i]*a[i]!=n) a[++m]=n/a[i];\n\tfor (int i=1;i<=m;i++){\n\t\tf[i]=ksm(k,(a[i]+1)/2);\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]%a[j]==0) (f[i]-=f[j])%=mo;\n\t\tans=(ans+1ll*f[i]*(a[i]&1?a[i]:a[i]/2))%mo;\n\t}\n\tprintf(\"%d\\n\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(int n,int k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(tmp+v[j].second*v[i].first/v[j].first)%mod;\n\t\t\t}\n\t\t}\n\t\tll tmq=(x*Pmod((x+1)/2,k)-tmp+mod)%mod;\n\t\t//cout<<tmp<<\" \"<<tmq<<endl;\n\t\tv[i].second=tmq;\n\t\tans[x%2]+=tmq;\n\t\tans[x%2]%=mod*(ll)10;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=int(1e9+7);\nint n,k,m,a[2000],f[2000],ans;\n\nint qpow(int a,int b)\n{\n\tint x=a;  a=1;\n\twhile (b)\n\t\t{\n\t\t\tif (b&1)  a=1LL*a*x%mo;\n\t\t\tx=1LL*x*x%mo,b>>=1;\n\t\t}\n\treturn a;\n}\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&k);\n\tfor (int i=1; i*i<=n; i++)\n\t\tif (n%i==0)\n\t\t\t{\n\t\t\t\ta[++m]=i;\n\t\t\t\tif (i!=n/i)  a[++m]=n/i;\n\t\t\t}\n\tsort(a+1,a+m+1);\n\tfor (int i=1; i<=m; i++)\n\t\tf[i]=qpow(k,(a[i]+1)/2);\n\tfor (int i=1; i<=m; i++)\n\t\tfor (int j=i+1; j<=m; j++)\n\t\t\tif (a[j]%a[i]==0)\n\t\t\t\tf[j]=(f[j]+mo-f[i])%mo;\n\tfor (int i=1; i<=m; i++)\n\t\tif (a[i]&1)  ans=(ans+1LL*f[i]*a[i])%mo;\n\t\telse  ans=(ans+1LL*f[i]*a[i]/2)%mo;\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn = 10005;\nconst int mod = 1e9+7;\n\nint f[maxn],num[maxn],tot,n,K,ans;\nint fpm(LL p,LL k) {\n\tLL res=1ll;\n\twhile (k) {\n\t\tif (k&1) (res*=p)%=mod;\n\t\t(p*=p)%=mod;k>>=1;\n\t}\n\treturn res;\n}\nint calc(int n) {\n\treturn n&1?n:n>>1;\n}\n\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc064f.in\",\"r\",stdin);\n\t\tfreopen(\"arc064f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&K);\n\tfor (int i=1;i*i<=n;i++)\n\tif (n%i==0) {\n\t\tnum[++tot]=n/i;\n\t\tif (i*i!=n) num[++tot]=i;\n\t}\n\tsort(num+1,num+tot+1);\n\tfor (int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=fpm(K,num[i]+1>>1);\n\t\tfor (int j=1;j<i;j++)\n\t\tif (num[i]%num[j]==0)\n\t\t\tf[i]=(f[i]-f[j])%mod;\n\t\tans=(ans+(LL)f[i]*calc(num[i]))%mod;\n\t}\n\tprintf(\"%d\",ans<0?ans+mod:ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nlong long modpow(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, k, ans = 0;\n    cin >> n >> k;\n    set<ll> s;\n    map<ll,ll> mp;\n    for(int i=1;i*i<=n;i++)if(n%i==0)s.insert(i),s.insert(n/i);\n    for(auto& i:s){\n    \tmp[i] = modpow(k,(i+1)/2);\n    \tfor(auto& j:s){\n    \t\tif(i<=j) continue;\n    \t\tif(i % j == 0) (mp[i] -= mp[j]) %= mod;\n    \t}\n    \tans += mp[i]*(i&1?i:i/2)%mod;\n    \tans %= mod;\n    }\n    ans += mod;\n    cout << ans%mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i*i<=n;i++) if(n%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=n/i) v.push_back(n/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,(x+1)/2);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tif(x%2==0) add(ans,1ll*d[i]*x/2%MOD);\n\t\telse add(ans,1ll*d[i]*x%MOD);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define MN 50005\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nmap<int,ll> f;\nint n,k,num[10000005],a[MN],sum[MN],tot,tt;ll ans;\nll pow(int x,int y){\n\tll tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=tmp*x%mod;\n\t\ty>>=1,x=1ll*x*x%mod;\n\t}return tmp;\n}\nvoid add(ll &x,int y){(x+=y)>=mod?x-=mod:0;}\nvoid dec(ll &x,int y){(x-=y)<0?x+=mod:0;}\nvoid dfs(int u,int now){\n\tif(u==tot+1){num[++tt]=now;return ;}\n\tfor(int i=0;i<=sum[u];i++)dfs(u+1,now*pow(a[u],i));\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);int tmp=(int)sqrt(n);f[1]=k;\n\tint now=n;\n\tfor(int i=2;i<=tmp;i++)if(now%i==0){\n\t\ta[++tot]=i;\n\t\twhile(now%i==0)now/=i,sum[tot]++;\n\t}if(now!=1)a[++tot]=now,sum[tot]=1;dfs(1,1);\n\tsort(num+1,num+tt+1);\n\tfor(int i=2;i<=tt;i++){\n\t\tf[num[i]]=pow(k,(num[i]+1)/2);\n\t\tfor(int j=2;j<sqrt(num[i]);j++)if(num[i]%j==0){\n\t\t\tdec(f[num[i]],f[j]),dec(f[num[i]],f[num[i]/j]);\n\t\t}dec(f[num[i]],f[1]);\n\t\tif((int)sqrt(num[i])*(int)sqrt(num[i])==num[i])dec(f[num[i]],f[(int)sqrt(num[i])]);\n\t}for(int i=1;i<=tt;i++)if(num[i]%2==1)add(ans,f[num[i]]*num[i]%mod);else add(ans,f[num[i]]*num[i]/2%mod);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntypedef long long ll;\nusing namespace std;\n\nvector<int> sieve_of_eratosthenes(int n) { // enumerate primes in [2,n] with O(n log log n)\n    vector<bool> is_prime(n+1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i*i <= n; ++i)\n        if (is_prime[i])\n            for (int k = i+i; k <= n; k += i)\n                is_prime[k] = false;\n    vector<int> primes;\n    for (int i = 2; i <= n; ++i)\n        if (is_prime[i])\n            primes.push_back(i);\n    return primes;\n}\nvector<ll> list_prime_factrors(ll n, vector<int> const & primes) {\n    vector<ll> result;\n    for (int p : primes) {\n        if (n < p *(ll) p) break;\n        while (n % p == 0) {\n            result.push_back(p);\n            n /= p;\n        }\n    }\n    if (n != 1) result.push_back(n);\n    return result;\n}\nll powi(ll x, ll y, ll p) { // O(log y)\n    assert (y >= 0);\n    x = (x % p + p) % p;\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % p;\n        x = x * x % p;\n    }\n    return z;\n}\n\nconst ll mod = 1e9+7;\nint main() {\n    int n, k; cin >> n >> k;\n    set<int> ds { 1 };\n    for (ll p : list_prime_factrors(n, sieve_of_eratosthenes(sqrt(n) + 3))) {\n        set<int> prev_ds = ds;\n        for (int d : prev_ds) {\n            ds.insert(d * p);\n        }\n    }\n    ll ans = 0;\n    map<int,ll> num;\n    for (int d : ds) {\n        ll acc = powi(k, (d+1)/2, mod);\n        for (int d2 : ds) if (d % d2 == 0 and d2 < d) {\n            acc -= num[d2];\n        }\n        num[d] = (acc % mod + mod) % mod;\n        ans += num[d] * d / (d % 2 == 0 ? 2 : 1);\n    }\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\n#include<random>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\n#define INF 1000000000LL\n#define EPS 1e-12\n#define FOR(i,n,m) for(ll i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\n#include <cstdint>\nusing i64 = std::int_fast64_t;\nconst static i64 mod = 1000000007;\nstruct mint {\n\ti64 n;\npublic:\n\tmint(const i64 n = 0) : n((n % mod + mod) % mod) {}\n\tmint pow(int m) const {\n\t\ti64 a = n, r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; r %= mod; }\n\t\t\ta = (a * a) % mod; m /= 2;\n\t\t}\n\t\treturn mint(r);\n\t}\n\tmint &operator++() { *this += 1; return *this; }\n\tmint &operator--() { *this -= 1; return *this; }\n\tmint operator++(int) { mint ret = *this; *this += 1; return ret; }\n\tmint operator--(int) { mint ret = *this; *this -= 1; return ret; }\n\tmint operator~() const { return (this -> pow(mod - 2)); } // inverse\n\tfriend bool operator==(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const mint& lhs, const mint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend mint &operator+=(mint& lhs, const mint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator-=(mint& lhs, const mint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator*=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint &operator/=(mint& lhs, const mint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend mint operator+(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n + rhs.n);\n\t}\n\tfriend mint operator-(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n - rhs.n);\n\t}\n\tfriend mint operator*(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * rhs.n);\n\t}\n\tfriend mint operator/(const mint& lhs, const mint& rhs) {\n\t\treturn mint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, mint& m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, mint& m) { os << m.n; return os; }\n\ntemplate <typename T>\nclass SegTree {\nprivate:\n\tint n;\n\tconst function<T(T, T)> op; // 演算\n\tconst T ie; // 演算の単位元\n\tvector<T> seq;\n\npublic:\n\t/// op: 演算, ie: 演算の単位元\n\tSegTree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tseq.resize(2 * n - 1);\n\t\tfor(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n\t}\n\n\t/// k 番目(0-indexed)の要素を e で更新\n\tvoid update(int k, const T e) {\n\t\tk += n - 1;\n\t\tseq[k] = e;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n\t\t}\n\t}\n\n\t// k 番目(0-indexed)の要素を取得\n\tT get(int k) {\n\t\tk += n - 1;\n\t\treturn seq[k];\n\t}\n\n\t/// [a, b) 番目(0-indexed)の要素全体の演算結果を返す\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1) r = n;\n\t\tif(r <= a || b <= l) return ie;\n\t\tif(a <= l && r <= b) return seq[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn op(vl, vr);\n\t}\n};\n// [Range Sum Query] rsq(n, [] (ll a, ll b) { return a + b; }, 0)\n// [Range Max Query] rMq(n, [] (ll a, ll b) { return max(a, b); }, -1e18)\n// [Range Min Query] rmq(n, [] (ll a, ll b) { return min(a, b); }, 1e18)\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nmint _pow(mint a, long long n) {\n\tif(n == 0) return 1;\n\tmint res = 1;\n\tmint buf = a;\n\twhile(n > 0) {\n\t\tif(n % 2) res *= buf;\n\t\tbuf *= buf;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\nusing mi = mint;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, k;\n\tcin >> n >> k;\n\tvector<ll> div;\n\tvector<mi> cnt;\n\tif(n % 2 == 0) {\n\t\tll m = n / 2;\n\t\tfor(int i = 1; i * i <= m; i++) {\n\t\t\tif(m % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != m) div.pb(m / i);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(div));\n\t\tcnt.assign((int)div.size(), 0);\n\t\tREP(i, div.size()) {\n\t\t\tcnt[i] += _pow(k, div[i]);\n\t\t\tFOR(j, i + 1, div.size()) {\n\t\t\t\tif(div[j] % div[i] == 0) cnt[j] -= cnt[i];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(int i = 1; i * i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tdiv.pb(i);\n\t\t\t\tif(i * i != n) div.pb(n / i);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(div));\n\t\tcnt.assign((int)div.size(), 0);\n\t\tREP(i, div.size()) {\n\t\t\tcnt[i] += _pow(k, 1 + (div[i] - 1) / 2);\n\t\t\tFOR(j, i + 1, div.size()) {\n\t\t\t\tif(div[j] % div[i] == 0) cnt[j] -= cnt[i];\n\t\t\t}\n\t\t}\n\t}\n\tmi ans = 0;\n\tREP(i, div.size()) {\n\t\tans += cnt[i] * n / (n / div[i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cassert>\n#include<utility>\n#include<vector>\n#define llong long long\n#define pll pair<llong,llong>\n#define mkpr make_pair\nusing namespace std;\n\nconst int N = 6720;\nconst int P = 1e9+7;\nvector<pll> fac;\nllong a[N+3];\nllong f[N+3],ff[N+3];\nint coe[N+3];\nllong n,m; int cnt;\nllong ans;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\n\nvoid factorize()\n{\n\tllong x = n;\n\tfor(int i=2; i<=100000; i++)\n\t{\n\t\tif(x%i==0)\n\t\t{\n\t\t\tfac.push_back(mkpr(i,0));\n\t\t\twhile(x%i==0)\n\t\t\t{\n\t\t\t\tfac[fac.size()-1].second++;\n\t\t\t\tx/=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(x>1) {fac.push_back(mkpr(x,1));}\n}\n\nvoid dfs0(llong x,int id,int pos)\n{\n\tif(pos==fac.size()) {a[id] = x; return;}\n\tfor(int i=0; i<=fac[pos].second; i++)\n\t{\n\t\tdfs0(x,id+coe[pos]*i,pos+1);\n\t\tx*=fac[pos].first;\n\t}\n}\n\nvoid dfs(int id0,int id,int pos,int coef)\n{\n\tif(pos==fac.size()) {ff[id0] = (ff[id0]+coef*f[id]%P+P)%P; return;}\n\tint cur = (id0%coe[pos+1])/coe[pos];\n\tfor(int i=0; i<=1 && i<=cur; i++)\n\t{\n\t\tdfs(id0,id-coe[pos]*i,pos+1,i==1?-coef:coef);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfactorize();\n\tcoe[0] = 1; for(int i=1; i<=fac.size(); i++) coe[i] = coe[i-1]*(fac[i-1].second+1); cnt = coe[fac.size()];\n\tdfs0(1,0,0);\n\tfor(int i=0; i<cnt; i++) f[i] = quickpow(m,(a[i]+1)/2);\n//\tprintf(\"a: \"); for(int i=0; i<cnt; i++) printf(\"%lld \",a[i]); puts(\"\");\n\tfor(int i=0; i<cnt; i++)\n\t{\n\t\tdfs(i,i,0,1);\n\t}\n//\tprintf(\"ff: \"); for(int i=0; i<cnt; i++) printf(\"%lld \",ff[i]); puts(\"\");\n\tans = 0ll;\n\tfor(int i=0; i<cnt; i++)\n\t{\n\t\tif(a[i]&1)\n\t\t{\n\t\t\tans = (ans+ff[i]*(a[i]%P))%P;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = (ans+ff[i]*(a[i]/2%P))%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n#define incID(i, l, r) for(LL i = (l)    ; i <  (r); ++i)\n#define incII(i, l, r) for(LL i = (l)    ; i <= (r); ++i)\n#define decID(i, l, r) for(LL i = (r) - 1; i >= (l); --i)\n#define decII(i, l, r) for(LL i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec(i, n)  decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define  ALL(v)  v.begin(),  v.end()\n#define RALL(v) v.rbegin(), v.rend()\ntemplate<typename T> bool setmin  (T & a, T b) { if(b <  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmax  (T & a, T b) { if(b >  a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmineq(T & a, T b) { if(b <= a) { a = b; return true; } else { return false; } }\ntemplate<typename T> bool setmaxeq(T & a, T b) { if(b >= a) { a = b; return true; } else { return false; } }\nLL mo(LL a, LL b) { assert(b > 0); a %= b; if(a < 0) { a += b; } return a; }\nLL fl(LL a, LL b) { assert(b > 0); return (a > 0 ? a / b : (a - b + 1) / b); }\nLL ce(LL a, LL b) { assert(b > 0); return (a < 0 ? a / b : (a + b - 1) / b); }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n#define bit(b, i) (((b) >> (i)) & 1)\n#define BC __builtin_popcountll\n#define SC static_cast\n#define SI(v) SC<int>(v.size())\n#define SL(v) SC<LL >(v.size())\n#define RF(e, v) for(auto & e: v)\n#define ef else if\n#define UR assert(false)\n\n// ---- ----\n\ntemplate<LL M> class ModInt {\nprivate:\n\tLL v = 0;\npublic:\n\tModInt() { }\n\tModInt(LL vv) { setval(vv); }\n\tModInt & setval(LL vv) { v = vv % M; if(v < 0) { v += M; } return (*this); }\n\tLL getval() const { return v; }\n\tModInt & operator+=(const ModInt & b)       { return setval(v + b.v); }\n\tModInt & operator-=(const ModInt & b)       { return setval(v - b.v); }\n\tModInt & operator*=(const ModInt & b)       { return setval(v * b.v); }\n\tModInt & operator/=(const ModInt & b)       { return setval(v * b.inv()); }\n\tModInt & operator^=(            LU b)       { return setval(ex(v, b)); }\n\tModInt   operator+ (                ) const { return ModInt(+v); }\n\tModInt   operator- (                ) const { return ModInt(-v); }\n\tModInt   operator+ (const ModInt & b) const { return ModInt(v + b.v); }\n\tModInt   operator- (const ModInt & b) const { return ModInt(v - b.v); }\n\tModInt   operator* (const ModInt & b) const { return ModInt(v * b.v); }\n\tModInt   operator/ (const ModInt & b) const { return ModInt(v * b.inv()); }\n\tModInt   operator^ (            LU b) const { return ModInt(ex(v, b)); }\n\tLL inv() const {\n\t\tLL x = (ex_gcd(v, M).FI + M) % M;\n\t\tassert(v * x % M == 1);\n\t\treturn x;\n\t}\n\tLL ex(LL a, LU b) const {\n\t\tLL D = 64, x[64], y = 1;\n\t\tinc(i, D) { if((b >> i) == 0) { D = i; break; } }\n\t\tinc(i, D) { x[i] = (i == 0 ? a : x[i - 1] * x[i - 1]) % M; }\n\t\tinc(i, D) { if((b >> i) & 1) { (y *= x[i]) %= M; } }\n\t\treturn y;\n\t}\n\tpair<LL, LL> ex_gcd(LL a, LL b) const {\n\t\tif(b == 0) { return MP(1, 0); }\n\t\tauto p = ex_gcd(b, a % b);\n\t\treturn MP(p.SE, p.FI - (a / b) * p.SE);\n\t}\n};\ntemplate<LL M> ModInt<M> operator+(LL a, const ModInt<M> & b) { return  b + a; }\ntemplate<LL M> ModInt<M> operator-(LL a, const ModInt<M> & b) { return -b + a; }\ntemplate<LL M> ModInt<M> operator*(LL a, const ModInt<M> & b) { return  b * a; }\ntemplate<LL M> ModInt<M> operator/(LL a, const ModInt<M> & b) { return  a * b.inv(); }\ntemplate<LL M> istream & operator>>(istream & is, ModInt<M> & b) { LL v; is >> v; b.setval(v); return is; }\ntemplate<LL M> ostream & operator<<(ostream & os, const ModInt<M> & b) { return (os << b.getval()); }\n\n// ---- ----\n\nvector<pair<LL, LL>> prime_factorization(LL x) {\n\tassert(x > 0);\n\tvector<pair<LL, LL>> f;\n\tfor(LL i = 2; i <= x; i++) {\n\t\tif(i * i > x) { i = x; }\n\t\tif(x % i == 0) {\n\t\t\tf.EB(i, 0);\n\t\t\twhile(x % i == 0) { f.back().SE++; x /= i; }\n\t\t}\n\t}\n\treturn f;\n}\n\nvector<LL> divisors(LL x) {\n\tauto pf = prime_factorization(x);\n\tvector<LL> d = { 1 };\n\tfor(auto e: pf) {\n\t\tint ds = d.size();\n\t\tinc(i, ds) {\n\t\t\tLL v = d[i];\n\t\t\tinc(j, e.SE) { v *= e.FI; d.PB(v); }\n\t\t}\n\t}\n\tsort(ALL(d));\n\treturn d;\n}\n\n// ----\n\ntypedef ModInt<1'000'000'007> MI;\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\t\n\tauto di = divisors(n);\n\tmap<int, MI> v;\n\tMI ans = 0;\n\tRF(d, di) {\n\t\tv[d] += MI(k) ^ (n / d % 2 == 0 ? d : (d + 1) / 2);\n\t\tans += d * v[d];\n\t\tRF(m, di) {\n\t\t\tif(m % d == 0 && m != d) { v[m] -= v[d]; }\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int mo = 1e9 + 7;\nusing namespace std;\nint pow(int x, int t){\n\tint res = 1;\n\twhile (t > 0){\n\t\tif (t & 1) res = 1ll * res * x % mo;\n\t\tx = 1ll * x * x % mo;\n\t\tt >>= 1;\n\t}\n\treturn res;\n}\nint n, k, dp[10001]; vector <int> p;\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i * i <= n; i++){\n\t\tif (n % i == 0){\n\t\t\tp.push_back(i);\n\t\t\tif (i * i != n) p.push_back(n / i);\n\t\t}\n\t}\n\tsort(p.begin(), p.end()); int ans = 0;\n\tfor (int i = 0; i < p.size(); i++){\n\t\tdp[i] = pow(k, (p[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tif (p[i] % p[j] == 0) dp[i] = (dp[i] - dp[j] + mo) % mo;\n\t\tans = (ans + 1ll * dp[i] * (p[i] / (1 + (p[i] % 2 == 0))) % mo) % mo;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nint n,k,tot;\nint s[2005],f[2005];\nint po(int a,int b){\n\tint an=1;\n\twhile(b!=0){\n\t\tif(b&1) an=(ll)an*a%mod;\n\t\ta=(ll)a*a%mod;b=(b>>1);\n\t}\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\ts[++tot]=i;\n\t\t\tif(i*i!=n) s[++tot]=n/i; \n\t\t}\n\tsort(s+1,s+1+tot);f[1]=k;\n\tfor(int i=2;i<=tot;i++){\n\t\tf[i]=po(k,(s[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(s[i]%s[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n\t}\n\tint ans=0,ni=po(2,mod-2);\n\tfor(int i=1;i<=tot;i++){\n\t\tif(s[i]%2==0) ans=(ans+(ll)f[i]*ni%mod*s[i]%mod)%mod;\n\t\telse ans=(ans+(ll)f[i]*s[i]%mod)%mod; \n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\nvector<int> d, f;\n\nvoid add(int &x,int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\nint pw(int x,int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n >> k;\n\tfor (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n\t\td.push_back(i);\n\t\tif (i < (n / i)) d.push_back(n / i);\t\n\t}\n\tsort(d.begin(), d.end());\n\tf.resize(d.size());\n\tint ans = 0;\n\tfor (int i = 0; i < d.size(); ++i) {\n\t\tf[i] = pw(k, (d[i] + 1) >> 1);\n\t\tfor (int j = 0; j < i; ++j) if (d[i] % d[j] == 0) {\n\t\t\tadd(f[i], mod - f[j]);\n\t\t} \n\t\tadd(ans, 1ll * f[i] * (d[i] & 1 ? d[i] : d[i] >> 1) % mod);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "ll N,K,M;\nll mo=1000000007;\nvector<ll> V;\nll dp[2020];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvector<ll> enumdiv(ll n) {\n\tvector<ll> S;\n\tfor(ll i=1;i*i<=n;i++) if(n%i==0) {S.push_back(i); if(i*i!=n) S.push_back(n/i); }\n\tsort(S.begin(),S.end());\n\treturn S;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\t\n\tV=enumdiv(N);\n\tM=V.size();\n\t\n\tll ret=0;\n\tFOR(x,M) {\n\t\tdp[x] = modpow(K,(V[x]+1)/2);\n\t\tFOR(y,x) if(V[x]%V[y]==0) dp[x] += mo - dp[y];\n\t\tdp[x] %= mo;\n\t\t\n\t\tif(V[x]%2==0) {\n\t\t\tret += dp[x]*V[x]/2;\n\t\t}\n\t\telse {\n\t\t\tret += dp[x]*V[x];\n\t\t}\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N, K;\n\tcin >> N >> K;\n\n\tvll div;\n\tfor (ll i = 1; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\tdiv.push_back(i);\n\t\t\tif (i * i != N) { div.push_back(N / i); }\n\t\t}\n\t}\n\n\tll d = div.size();\n\tsort(++div.begin(), div.end());\n\n\tvmint c(d, 0);\n\n\trep(i, d) {\n\t\tll x = div[i];\n\t\tif ((N / x) % 2 == 1) {\n\t\t\tc[i] = pw(K, (x + 1) / 2);\n\t\t}\n\t\telse { c[i] = pw(K, x); }\n\n\t\trep(j, i) {\n\t\t\tif (div[i] % div[j] == 0) { c[i] -= c[j]; }\n\t\t}\n\t}\n\n\tmint ans = 0;\n\trep(i, d) {\n\t\tans += c[i] * div[i];\n\t}\n\n\tcout << ans << endl;\n\n\t\n\n}"
  },
  {
    "language": "C++",
    "code": "// C++(GCC 9.2.1)\n// 解き直し.\n// https://img.atcoder.jp/arc064/editorial.pdf\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define all(x) x.begin(), x.end()\nconst LL MOD = 1e9 + 7;\n\n// 与えられた正の整数のすべての約数を抽出.\n// @param X: 約数を抽出したい正の整数.\n// @return ret: すべての約数.\nvector<LL> div(LL X){\n    vector<LL> ret;\n    ret.pb(1);\n    for(LL d = 2; d * d <= X; d++){\n        if(X % d == 0){\n            ret.pb(d);\n            if(d * d != X) ret.pb(X / d);\n        }\n    }\n    if(X > 1) ret.pb(X);\n    sort(all(ret));\n    return ret;\n}\n\n// Fermat's little theorem から, 大きな冪乗の計算を行う.\n// @param a: べき乗したい正整数.\n// @param b: 指数.\n// @return:  べき乗した計算結果(mod版).\nLL mPow(LL a, LL b){\n    LL t = 1;\n    while(b){\n        if(b & 1) t = (t * a) % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return t % MOD;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    LL N, K;\n    scanf(\"%lld %lld\", &N, &K);\n    \n    // 2. 例外.\n    if(N == 1){\n        printf(\"%lld\\n\", K);\n        return 0;\n    }\n    \n    // 3. N の 約数.\n    vector<LL> d = div(N);\n    // for(auto &p : d) printf(\"%lld \", p);\n    // puts(\"\");\n    \n    // 4. 各最小周期に対応する数列の個数.\n    int l = d.size();\n    LL num[l];\n    memset(num, 0, sizeof(num));\n    rep(i, l){\n        // 1_27.txt, 1_28.txt, 1_30.txt, 1_31.txt で, WA版となったため, ロジック修正.\n        // num[i] = mPow(K, d[i] / 2);\n        num[i] = mPow(K, d[i] * 500000004 % MOD);\n        rep(j, i){\n            if(d[i] % d[j] == 0) num[i] = (num[i] + MOD - num[j]) % MOD;\n        }\n    }\n    \n    // 5. 解答を求めるための数式を計算.\n    LL ans = 0, nd;\n    rep(i, l){\n        // 1_27.txt, 1_28.txt, 1_30.txt, 1_31.txt で, WA版となったため, ロジック修正.\n        // nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        nd = (d[i] & 1) ? d[i] : (d[i] * 500000004 % MOD);\n        ans += num[i] * nd;\n        ans %= MOD;\n    }\n    \n    // 6. 出力.\n    printf(\"%lld\\n\", ans);\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k;\nconst int MOD = 1e9 + 7;\nconst int N = 1000000;\nint ans[N], finans;\nvector <int> V;\nint powi(int a, int b)\n{\n    int c = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % MOD)\n        if (b & 1) c = 1ll * c * a % MOD;\n    return c;\n}\nint main()\n{\n    cin >> n >> k;\n    for (int i = 1; i * i <= n; ++ i)\n        if (n % i == 0)\n        {\n            V.push_back(i);\n            if (i * i != n) V.push_back(n / i);\n        }\n    sort(V.begin(), V.end());\n    for (int i = 0; i < V.size(); ++ i)\n    {\n        ans[i] = powi(k, (V[i] + 1) / 2);\n        for (int j = 0; j < i; ++ j) if (V[i] % V[j] == 0)\n            ans[i] = (ans[i] - ans[j] + MOD) % MOD;\n        finans = (finans + 1ll * ans[i] * (V[i] & 1? V[i]: V[i] / 2)) % MOD;\n    }\n    cout << finans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXD = 2333;\nconst int MOD = 1e9 + 7;\nint N, K;\nint dp[MAXD];\n\nint powmod(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tr = ll(r) * a % MOD;\n\t\t}\n\t\ta = ll(a) * a % MOD;\n\t\tb /= 2;\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin >> N >> K;\n\n\tvector<int> factors;\n\tfor (int i = 1; i*i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\tfactors.push_back(i);\n\t\t\tif (i*i != N) {\n\t\t\t\tfactors.push_back(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(factors.begin(), factors.end());\n\n\tfor (size_t i = 0; i < factors.size(); i++) {\n\t\tdp[i] = powmod(K, (factors[i]+1)/2);\n\t\tfor (size_t j = 0; j < i; j++) {\n\t\t\tif (factors[i] % factors[j]) continue;\n\t\t\tdp[i] -= dp[j];\n\t\t\tif (dp[i] < 0) dp[i] += MOD;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (size_t i = 0; i < factors.size(); i++) {\n\t\tif (factors[i] % 2 == 0) {\n\t\t\tans = (ans + ll(dp[i]) * factors[i] / 2) % MOD;\n\t\t} else {\n\t\t\tans = (ans + ll(dp[i]) * factors[i]) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nll mod=1e9+7;\nll ex(ll x,ll p){\n\tll a=1;\n\twhile(p){\n\t\tif(p%2) a=a*x%mod;\n\t\tx=x*x%mod;\n\t\tp/=2;\n\t}\n\treturn a;\n}\nint N,X;\nvector<int> ds;\nll dp[10000];\nint main(){\n\tcin>>N>>X;\n\tfor(int i=1;i*i<=N;i++){\n\t\tif(N%i==0){\n\t\t\tds.pb(i);\n\t\t\tif(i*i!=N) ds.pb(N/i);\n\t\t}\n\t}\n\tsort(all(ds));\n\tint K=ds.size();\n\trep(i,K){\n\t\tint L=ds[i];\n\t\tll tmp=ex(X,(L+1)/2);\n\t\trep(j,i) if(ds[i]%ds[j]==0) tmp-=dp[j];\n\t\ttmp=(tmp%mod+mod)%mod;\n\t\tdp[i]=tmp;\n\t}\n\tll ans=0;\n\trep(i,K){\n\t\tll ad=dp[i]*ds[i];\n\t\tif(ds[i]%2==0) ad/=2;\n\t\tans=(ans+ad)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MOD 1000000007  // prime number\ntypedef unsigned long long ull;\n\nunsigned long long bipow(unsigned long long n, unsigned long long m,\n                         int p = MOD) {\n    if (m == 0) return 1;\n    if (m % 2 == 0) {\n        n = (n * n) % p;\n        return bipow(n, m / 2, p) % p;\n    } else\n        return (n * bipow(n, m - 1, p)) % p;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    unsigned long long N, K;\n    cin >> N >> K;\n    ull temp = bipow(K, N / 2) % MOD;\n    ull ans = (temp * N / 2) % MOD;\n    ull temp2 = ((N / 2 - 1) * K) % MOD;\n    ans = (ans - temp2) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 1200000;\nmap < int, int > a;\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2) res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, k;\n    cin >> n >> k;\n    vector < int > div;\n    for (int i = 1; i * i <= n; i++){\n        if (n % i == 0){\n            div.pb(i);\n            if (i * i != n) div.pb(n / i);\n        }\n    }\n    sort(div.begin(), div.end());\n    int ans = 0;\n    for (auto i: div){\n        int len = (i + 1) / 2;\n        int x = binpow(k, len);\n        x = (x + a[i]) % mod;\n        int z;\n        if (i % 2) z = i; else z = len;\n        ans = (ans + x * z) % mod;\n        for (auto j: div){\n            if (j % i == 0){\n                a[j] = (a[j] - x + mod) % mod;\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,k,i,j,top,a[100005],f[100005],ans;\nlong long ksm(long long u,long long v){\n\tlong long o=1;\n\twhile(v){\n\t\tif(v&1)\n\t\t\to=o*u%mo;\n\t\tu=u*u%mo;\n\t\tv>>=1;\n\t}\n\treturn o;\n}\nint main(){\n\t//freopen(\"camp.in\",\"r\",stdin);\n\t//freopen(\"camp.out\",\"w\",stdout);\n\t//sort(o+1,o+n+1);\n\tn=read();k=read();\n\tfor(i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\ttop++;\n\t\t\ta[top]=i;\n\t\t\tif(i*i!=n){\n\t\t\t\ttop++;\n\t\t\t\ta[top]=n/i;\n\t\t\t}\n\t\t}\n\tsort(a+1,a+top+1);\n\tfor(i=1;i<=top;i++){\n\t\tf[i]=ksm(k,a[i]+1>>1);\n\t\tfor(j=1;j<i;j++)\n\t\t\tif(a[i]%a[j]==0)\n\t\t\t\tf[i]=(f[i]-f[j]+mo)%mo;\n\t\tif(a[i]&1)\n\t\t\tans=(ans+f[i]*a[i])%mo;\n\t\telse\n\t\t\tans=(ans+f[i]*a[i]/2)%mo;\n\t}\n\tpus(ans,2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Mod\n{\n    static const int P = int(1e9+7);\n    long long k;\n\n    Mod() = default;\n    Mod(long long k) : k(k%P) {}\n};\n\nMod operator+(const Mod a, const Mod b) { return a.k + b.k; }\nMod operator*(const Mod a, const Mod b) { return a.k * b.k; }\nMod operator-(const Mod a, const Mod b) { return a.k + (Mod::P - b.k); }\nMod operator+=(Mod& a, const Mod b) { return a = a+b; }\nMod operator-=(Mod& a, const Mod b) { return a = a-b; }\nMod power(const Mod a, const int k)\n{\n    if (k == 0) return 1;\n    else if (k % 2 == 0) return power(a*a, k/2);\n    else return a * power(a*a, k/2);\n}\n\nint main()\n{\n    int N, K; cin >> N >> K;\n\n    auto divisors = vector<int>();\n    for (auto d = 1; d*d <= N; d++) if (N % d == 0)\n    {\n        divisors.push_back(d);\n        if (d != N/d) divisors.push_back(N/d);\n    }\n    sort(begin(divisors), end(divisors));\n    const auto D = int(divisors.size());\n\n    auto answer = Mod(0);\n    auto ways = vector<Mod>(divisors.size());\n    for (auto i = 0; i < D; i++)\n    {\n        ways[i] = power(K, (divisors[i] + 1)/2);\n        for (auto j = 0; j < i; j++) if (divisors[i] % divisors[j] == 0)\n            ways[i] -= ways[j];\n\n        answer += ways[i] * (divisors[i] % 2 == 1 ? divisors[i] : divisors[i]/2);\n    }\n    cout << answer.k << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nnum n, k, ans;\nmap<num, num> pre;\n\nnum inline qpow(num a, num p) {\n    num res = 1;\n    for (; p; p >>= 1) {\n        if (p & 1) {\n            res *= a;\n            res %= mod;\n        }\n        a *= a;\n        a %= mod;\n    }\n    return res;\n}\n\nnum solve(num a) {\n    if (pre[a])  return pre[a];\n    if (a == 1)  return pre[a] = k;\n    num res = 0;\n    for (num b = 1; b * b <= a; ++b) {\n        if (a % b)  continue;\n        num bb = a / b;\n        res -= solve(b);\n        res %= mod;\n        if (b != bb && bb != a) {\n            res -= solve(bb);\n            res %= mod;\n        }\n    }\n    res += qpow(k, (a - 1) / 2 + 1);\n    res += mod;\n    res %= mod;\n    return pre[a] = res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    solve(n);\n    foreach (it, pre) {\n        num a = it->first, cnt = it->second, cur = a * cnt % mod;\n        ans += (a & 1) ? cur : cur * qpow(2, mod - 2);\n        ans %= mod;\n    }\n    cout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(ll n,ll k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=(x*Pmod((x+1)/2,k))%mod;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(mod+tmp-((v[j].second*v[i].first/v[j].first)%mod))%mod;\n\t\t\t}\n\t\t}\n\t\tv[i].second=tmp;\n\t\tans[x%2]+=tmp;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint pow_mod(int x, int k) {\n\tint ans = 1;\n\twhile (k) {\n\t\tif (k&1) ans = 1LL * ans * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, k;\n\nint fac[222222], fn, dp[222222];\n\nint cal() {\n\tif (n % 2) {\n\t\tint ans = pow_mod(k, (n + 1) / 2);\n\t\tans = (ans - k + MOD) % MOD;\n\t\tans = 1LL * ans * n % MOD;\n\t\tans = (ans + k) % MOD;\n\t\treturn ans;\n\t}\n\tfn = 0;\n\tn /= 2;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tfac[++fn] = i;\n\t\t\tfac[++fn] = n / i;\n\t\t}\n\t}\n\tsort(fac + 1, fac + fn + 1);\n\tfn = unique(fac + 1, fac + 1 + fn) - fac - 1;\n\tfor (int i = 1; i <= fn; i++) {\n\t\tdp[i] = 1LL * pow_mod(k, fac[i]) % MOD;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (fac[i] % fac[j] == 0) {\n\t\t\t\tdp[i] = (dp[i] - dp[j] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= fn; i++) ans = (ans + 1LL * dp[i] * fac[i] % MOD) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tprintf(\"%d\\n\", cal());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REPP(i,a,b,c) for(int i=a; i<=b; i+=c)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,c) for(int i=a; i>=b; i-=c)\n#define REV(i,a,b) REVV(i,a,b,1)\n#define FOR(i,a) REP(i,0,(int)a-1)\n#define FORD(i,a) REV(i,(int)a-1,0)\n#define PB push_back\n#define POB pop_back\n#define MP make_pair\n#define FI first\n#define SE second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair < int , int > pii;\ntypedef vector < int > vi;\ntypedef vector < pii > vii;\ntypedef vector < ll > vl;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nll addMod(ll a, ll b){\n\treturn (a+b+MOD*1000) % MOD;\n}\n\nll mulMod(ll a, ll b){\n\treturn (a*b) % MOD;\n}\n\nll fast(ll a, ll b){\n\tif(b == 0) return 1;\n\tll tmp = fast(a,b/2);\n\ttmp = mulMod(tmp, tmp);\n\tif(b & 1) tmp = mulMod(tmp, a);\n\treturn tmp;\n}\n\n/////////////////////////////////////////////////////////\n\nconst int N = 1e5;\n\nint n,m;\nll ans;\nvi divi;\nll val[N + 5];\n\nvoid input(){\n\tcin >> n >> m;\n}\n\nvoid output(){\n\tcout << ans << endl;\n}\n\nvoid getDiv(){\n\tint sq = sqrt(n);\n\tREP(i,1,sq){\n\t\tif(n % i == 0){\n\t\t\tdivi.PB(i);\n\t\t\tif(n/i != i) divi.PB(n/i);\n\t\t}\n\t}\n\tsort(divi.begin(), divi.end());\n}\n\nvoid process(){\n\tll v;\n\tans = 0;\n\tgetDiv();\n\tFOR(i,divi.size()){\n\t\tval[i] = fast(m, (divi[i] + 1) / 2);\n\t\tFOR(j,divi.size()){\n\t\t\tif(divi[j] >= divi[i]) break;\n\t\t\tif(divi[i] % divi[j] == 0){\n\t\t\t\tval[i] = addMod(val[i], -val[j]);\n\t\t\t}\n\t\t}\n\t\tv = divi[i];\n\t\tif(v % 2 == 0){\n\t\t\tv /= 2;\n\t\t}\n\t\tans = addMod(ans, mulMod(v, val[i]));\n\t}\n}\n\nint main(){\n\tios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tinput();\n\tprocess();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#define N 100010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nint num[N],tot;\nll n,k,f[N];\nll ksm(ll a,ll b=mod-2)\n{\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tll q=ksm(a,b>>1);\n\tif(b&1) return q*q%mod*a%mod;\n\treturn q*q%mod;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\tif(n%i==0)\n\t{\n\t\tnum[++tot]=i;\n\t\tif(i*i!=n) num[++tot]=n/i;\n\t}\n\tsort(num+1,num+tot+1);\n\tll ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=ksm(k,(num[i]+1)>>1);\n\t\tfor(int j=1;j<i;j++)\n\t\tif(num[i]%num[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\tans=(ans+f[i]*num[i]/(num[i]&1?1:2))%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint ans;\nint fastpow(int x,int a){\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\n\nint ys[50005],yscnt;\nint xs[50005];\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tys[++yscnt]=i;\n\t\t\tif(i*i!=n) ys[++yscnt]=n/i;\n\t\t}\n\t}\n\tsort(ys+1,ys+yscnt+1);\n\tfor(int i=1;i<=yscnt;i++){\n\t\tif(n%2==0&&ys[i]%2!=0) continue;\n\t\tans=(ans + fastpow(k,ys[i]%2==0? n/ys[i]:(n/ys[i]+1)/2)*1LL*(n/ys[i])%mod*(1-xs[i]) )%mod;\n\t\tfor(int j=i+1;j<=yscnt;j++) if(ys[j]%ys[i]==0) xs[j]+=(1-xs[i])*(ys[j]/ys[i]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long modPow(int a, int p){\n\tif(p == 0) return 1;\n\tlong long res = modPow(a, p/2);\n\tres *= res;\n\tres %= MOD;\n\tif(p%2){\n\t\tres *= a;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, K;\n\twhile(cin >> N >> K){\n\t\tif(N == 1){\n\t\t\tcout << K << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> d;\n\t\tfor(int i=1;i*i<=N;++i){\n\t\t\tif(N%i == 0){\n\t\t\t   d.push_back(i);\n\t\t\t   if(N/i != i) d.push_back(N/i);\n\t\t\t}\n\t\t}\n\t\tsort(d.begin(), d.end());\n\t\tvector<long long> num(d.size(), 0);\n\t\tlong long res = 0;\n\t\tfor(int i=0;i<d.size();i++){\n\t\t\tlong long cycle = d[i];\n\t\t\tnum[i] = modPow(K, (cycle+1)/2);\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(cycle%d[j] == 0) num[i] = (num[i]+MOD-num[j])%MOD;\n\t\t\t}\n\t\t\tif(cycle%2 == 0) cycle /= 2;\n\t\t\tres += num[i] * cycle;\n\t\t\tres %= MOD;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nLL powmod(LL x, LL y){\n\tLL a = 1;\n\twhile(y){\n\t\tif(y & 1){ a = a * x % MOD; }\n\t\ty >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn a;\n}\n\nLL solve(LL n, LL k){\n\tif(n & 1){\n\t\tLL x = powmod(k, (n + 1) / 2);\n\t\treturn (x - k) * n + k;\n\t}\n\t\n\tLL m = n / 2;\n\tvector<LL> divs;\n\tfor(LL i = 1; i * i <= m; ++i){\n\t\tif(m % i == 0){\n\t\t\tdivs.push_back(i);\n\t\t\tif(i * i != m){ divs.push_back(m / i); }\n\t\t}\n\t}\n\tsort(ALL(divs));\n\tint sz = divs.size();\n\tvector<LL> cnt(sz);\n\tLL ans = 0;\n\tfor(int i = 0; i < sz; ++i){\n\t\tLL x = cnt[i] % MOD;\n\t\tx += powmod(k, divs[i]);\n\t\tx = (x + MOD) % MOD;\n\t\tcnt[i] = x;\n\t\tans = (ans + divs[i] * x) % MOD;\n\t\t\n\t\tfor(int j = i + 1; j < sz; ++j){\n\t\t\tif(divs[j] % divs[i] == 0){\n\t\t\t\tcnt[j] -= x;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid mainmain(){\n\tLL n, k;\n\tcin >> n >> k;\n\tcout << solve(n, k) << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <map>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\ntypedef long long LL;\nconst int N=100500,mo=1e9+7;\nint m,n;\nint fj[N][2],fj0;\nint d[N];\nLL ans;\nmap<int,int>f;\nLL ksm(LL q,int w) {\n\tLL ans=1;\n\tfor(; w; w>>=1,q=q*q%mo)if(w&1)ans=ans*q%mo;\n\treturn ans;\n}\nint ss1(int q,int w,int e) {\n\tif(q>w)return f[e];\n\tint ans=ss1(q+1,w,e);\n\tfo(i,1,d[q])((ans+=ss1(q+1,w,(e=e*fj[q][0])))>=mo?ans-=mo:0);\n\treturn ans;\n}\nvoid ss(int q,int e) {\n\tif(q>fj0) {\n\t\tLL t=(((n/e)%2?ksm(m,(e+1)>>1):ksm(m,e))-ss1(1,q,1)+mo)%mo;\n\t\tf[e]=t;\n\t\tans=(ans+t*e)%mo;\n\t\treturn;\n\t}\n\td[q]=0;\n\tss(q+1,e);\n\tfo(i,1,fj[q][1])d[q]=i,ss(q+1,(e*=fj[q][0]));\n}\nint main() {\n\tint q,w;\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==1)return printf(\"%d\\n\",m),0;\n\tq=n;\n\tfor(int i=2; i*i<=q; ++i)if(q%i==0) {\n\t\t\tfor(fj[++fj0][0]=i; !(q%i); ++fj[fj0][1],q/=i);\n\t\t}\n\tif(q>1)fj[++fj0][0]=q,fj[fj0][1]=1;\n\tss(1,1);\n\tprintf(\"%lld\\n\",(ans+mo)%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    long long x;\n    is >> x;\n    a = ModInt< mod >(x);\n    return (is);\n  }\n\n};\n\nusing modint = ModInt< mod >;\n\nvector< int64_t > divisor(int64_t n) {\n  vector< int64_t > ret;\n  for(int64_t i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret.push_back(i);\n      if(i * i != n) ret.push_back(n / i);\n    }\n  }\n  sort(begin(ret), end(ret));\n  return (ret);\n}\n\n\ntemplate< int mod >\nstruct Combination {\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz) : mfact(sz + 1), rfact(sz + 1) {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n\n  modint ret = 0;\n  auto div = divisor(N);\n  Combination< mod > uku(1);\n  vector< modint > dp(div.size());\n  for(int i = 0; i < div.size(); i++) {\n    dp[i] += uku.pow(K, (div[i] + 1) / 2);\n    for(int j = i - 1; j >= 0; j--) {\n      if(div[i] % div[j] == 0) dp[i] -= dp[j];\n    }\n    if(div[i] % 2 == 0) ret += dp[i] * div[i] / 2;\n    else ret += dp[i] * div[i];\n  }\n  cout << ret << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<utility>\n#include<set>\n#include<stack>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<iomanip>\n#include<cstring>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<climits>\n#include<cmath>\n#include<cctype>\n\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define ren(i,a,b) for(int i=a;i>=b;i--)\n#define ff first\n#define ss second\n#define pll pair<long long int,long long int>\n#define pii pair<int,int>\n#define vll vector<long long int>\n#define vii vector<int>\n#define gi(n) scanf(\"%d\",&n)\n#define gll(n) scanf(\"%lld\",&n)\n#define gstr(n) scanf(\"%s\",n)\n#define gl(n) cin >> n\n#define oi(n) printf(\"%d\",n)\n#define oll(n) printf(\"%lld\",n)\n#define ostr(n) printf(\"%s\",n)\n#define ol(n) cout << n\n#define os cout<<\" \"\n#define on cout<<\"\\n\"\n#define o2(a,b) cout<<a<<\" \"<<b\n#define all(n) n.begin(),n.end()\n#define present(s,x) (s.find(x) != s.end())\n#define cpresent(s,x) (find(all(s),x) != s.end())\n#define tr(container, it) for(__typeof(container.begin()) it = container.begin(); it != container.end(); it++)\nusing namespace std;\n\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef vector<vector<ll> > mat;\n\nll m=1e9+7;\n\nll p(ll a,ll b)\n{\n\tll r=1;\n\twhile(b)\n\t{\n\t\tif(b%2)r=(r*a)%m;\n\t\ta=(a*a)%m;\n\t\tb/=2;\n\t}\n\treturn r;\n}\n\nint main()\n{ios_base::sync_with_stdio(false);\nll n,k;\ncin>>n>>k;\n\nll dp[10004];\nvll div;\n\nfor(ll i=1;i*i<=n;i++)\n{\n\tif(n%i==0)\n\t{\n\t\tdiv.pb(i);\n\t\tif(i*i!=n)div.pb(n/i);\n\t}\n}\n\nsort(all(div));\n\nrep(i,0,div.size()-1)\n{\n\tdp[i]=p(k,(div[i]+1)/2);\n\trep(j,0,i-1)\n\t{\n\t\tif(div[i]%div[j]==0)\n\t\tdp[i]-=dp[j];\n\t\tdp[i]%=m;\n\t}\n\tif(dp[i]<0)dp[i]+=m;\n}\nll ans=0;\nrep(i,0,div.size()-1)\n{\n\tif(div[i]%2==0)\n\tans+=dp[i]*(div[i]/2);\n\telse\n\tans+=dp[i]*div[i];\n\tans%=m;\n}\nol(ans);\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\nint n,k,a[2000],dp[2000],tp;\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\ta[++tp]=i;\n\t\tif(i*i!=n)a[++tp]=n/i;\n\t}\n\tsort(a+1,a+tp+1);\n\tfor(int i=1;i<=tp;++i){\n\t\tdp[i]=qpow(k,(a[i]+1)/2);\n\t\tfor(int j=1;j<i;++j)if(a[i]%a[j]==0)\n\t\t\tdp[i]=(dp[i]-dp[j]+mod)%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=tp;++i)\n\t\tans=(ans+1ll*(a[i]&1?a[i]:a[i]/2)*dp[i])%mod;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T>\nvector<T> divisor(T n)\n{\n    vector<T> res;\n    for(T i=1;i*i<=n;i++){\n        if(n%i==0){\n            res.pb(i);\n            if(i != n/i){\n                res.pb(n/i);\n            }\n        }\n    }\n    sort(all(res));\n    return res;\n}\n\nll mod_pow(ll a,ll b)\n{\n    a %= MOD;\n    ll res = 1;\n    while(b){\n        if(b & 1){\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nmap<int,int> mp;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, K;\n    cin >> n >> K;\n    vi res = divisor(n);\n    int m = len(res);\n    rep(i,m){\n        int val = mod_pow(K,(res[i]+1)/2);\n        rep(j,i){\n            if(res[i] % res[j] == 0){\n                val = sub(val,mp[res[j]]);\n            }\n        }\n        mp[res[i]] = val;\n    }\n    int ans = 0;\n    rep(i,m){\n        if(res[i] % 2){\n            ans = add(ans,mul(mp[res[i]],res[i]));\n        }else{\n            ans = add(ans,mul(mp[res[i]],res[i]/2));\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\tmu[prod] = m;\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\tfor(auto && e : divisor) { gg[e] = g(e); }\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define mo 1000000007\n#define LL long long\nusing namespace std;\nLL ksm(LL k,LL n)\n{\n\tLL s=1;\n\tfor(;n;n>>=1,k=k*k%mo) if(n&1) s=s*k%mo;\n\treturn s;\n}\nint main()\n{\n\tLL n,m;\n\tcin>>n>>m;\n\tif(n==1) printf(\"%lld\",m);\n\telse printf(\"%lld\",(((ksm(m,n/2)-m+mo)%mo*ksm(2,mo-2)%mo)%mo*n%mo+m)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*\n#define trav(a, v) for(auto& a : v)\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n*/\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k,r;\n\n\nll mob(ll i){\n    if(i == 1)return 1;\n    for(ll c1 = 2; c1*c1 <= i; c1++){\n\n        if(i % c1 == 0){\n\n            if(i % (c1*c1) == 0)return 0;\n            return (-1) * mob(i / c1);\n        }\n    }\n return -1;\n}\n\n\nll ans = 0;\n\n ll upp(ll i, ll j){\n\n if(j == 0)return 1;\n\n if(j%2 == 0){\n    ll h = upp(i,j/2);\n    return (h*h)%big;\n\n }\n return (i*upp(i,j-1))%big;\n }\n\n\nll g(ll i){\n    ll a = mob(n/i) * upp(k, (n+1)/2);\n    a += big;\n    a %= big;\n    if(i % 2 == 0){a *= i/2;}\n    else{\n        a *= i;\n    }\n    a%=big;\n    return a;\n}\n\n\n\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll c1,c2,c3,c4,c5,c6;\n    ll a,b,c,e;\n    ll x;\n\n    cin >> n >> k;\n\n\n    for(ll c1 = 1; c1*c1 <= n; c1++){\n\n        if(n%c1 == 0){\n            ans += g(c1);\n            ans += big;\n            ans %= big;\n\n            if(c1*c1 != n){\n\n                ans += g(n/c1);\n                ans += big;\n                ans %= big;\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nll powll(ll x, ll y){\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll naive(ll n, ll k){\n    set<VI> st;\n    int m = (n + 1) / 2;\n    VI a(n);\n    REP(mask, powll(k, m)){\n        REP(i,m){\n            a[i] = (mask / powll(k, i)) % k;\n            a[n - 1 - i] = a[i];\n        }\n        VI b(n);\n        REP(s,n){\n            REP(i,n) b[i] = a[(i+s)%n];\n            st.insert(b);\n        }\n    }\n    return st.size();\n}\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n\n    if (k <= 10){\n        cout << naive(n, k) << endl;\n    }\n\n    VL factor;\n    for (ll x = 1; x * x <= n; ++x){\n        if (n % x == 0){\n            factor.push_back(x);\n            if (x * x != n) factor.push_back(n / x);\n        }\n    }\n    sort(ALL(factor));\n\n    int m = factor.size();\n    VL way(m);\n    ll ans = 0;\n\n    REP(i,m){\n        ll x = factor[i];\n        way[i] = powll(k, (x + 1) / 2);\n        REP(j,i){\n            if (x % factor[j] == 0){\n                way[i] = (way[i] - way[j] + mod) % mod;\n            }\n        }\n        ll tmp;\n        if (x % 2) tmp =  (way[i] * x) % mod;\n        else tmp = (way[i] * (x / 2)) % mod;\n        ans = (ans + tmp) % mod;\n        // cout << \"f \" << x << \"  \";\n        // cout << tmp << endl;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\n\nint n,m,cnt,sum,a[100005],ans[100005];\nint ksm(int x,int y){\n\tint z=1; for (; y; y>>=1,x=(ll)x*x%mod) if (y&1) z=(ll)z*x%mod;\n\treturn z;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tif (n&1){\n\t\tprintf(\"%lld\\n\",((ll)(ksm(n+1>>1,m)-m+mod)*n+m)%mod);while(1);\n\t\treturn 0;\n\t}\n\tint i,j; n/=2;\n\tfor (i=1; i*i<=n; i++) if (!(n%i)){\n\t\ta[++cnt]=i;\n\t\tif (i*i<n) a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\tfor (i=1; i<=cnt; i++){\n\t\tans[i]=(ans[i]+ksm(m,a[i]))%mod;\n\t\tsum=(sum+(ll)ans[i]*a[i])%mod;\n\t\tfor (j=i+1; j<=cnt; j++) if (!(a[j]%a[i])) ans[j]=(ans[j]+mod-ans[i])%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint num[2000],fac[2000],cnt;\n\nint add(int x,int y)\n{return (x+y)%mod;}\nint sub(int x,int y)\n{return (x-y+mod)%mod;}\nint mul(int x,int y)\n{return 1LL*x*y%mod;}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ans=mul(x,ans);\n\t\ty>>=1,x=mul(x,x);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;++i)\n\t  if(n%i==0)\n\t    {\n\t    \tfac[++cnt]=i;\n\t    \tif(i*i<n)\n\t    \t  fac[++cnt]=n/i;\n\t    }\n\tsort(fac+1,fac+1+cnt);\n\tint ans=0;\n\tfor(int i=1;i<=cnt;++i)\n\t{\n\t\tnum[i]=fpow(k,(fac[i]+1)>>1);\n\t\tfor(int j=1;j<i;++j)\n\t\t  if(fac[i]%fac[j]==0)\n\t\t    num[i]=sub(num[i],num[j]);\n\t\tif(fac[i]%2==0)ans=add(ans,mul(num[i],fac[i]>>1));\n\t\telse ans=add(ans,mul(num[i],fac[i]));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?(c=getchar()):0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\nconst int dN=5010,O=1000000007;\ninline int fpow(int x,int n){\n\tlint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint fact[dN],fs=0;\nlint f[dN];\ninline void addfact(int x,int e){\n\tfor(int i=0,j=0;i<e;i++){\n\t\tfor(int k=fs;j<k;j++){\n\t\t\tfact[fs++]=fact[j]*x;\n\t\t}\n\t}\n}\nint main(){\n\tint n=ni,k=ni;\n\tfact[fs++]=1;\n\tfor(int x=2,e;x*x<=n;x++){\n\t\tfor(e=0;n%x==0;n/=x,e++);\n\t\taddfact(x,e);\n\t}\n\tif(n!=1){\n\t\taddfact(n,1);\n\t}\n\tlint ans=0;\n\tfor(int i=0;i<fs;i++){\n\t\tint d=fact[i];\n\t\tf[i]=fpow(k,(d+1)>>1);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(d%fact[j]==0){\n\t\t\t\tf[i]-=f[j];\n\t\t\t}\n\t\t}\n\t\tf[i]=(f[i]%O+O)%O;\n\t\tstatic int inv2=inv(2);\n\t\tans+=d&1?f[i]*d%O:(f[i]*d%O*inv2%O);\n\t}\n\tprintf(\"%lld\\n\",ans%O);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n# @Author:      iLovePKU_zbtxdy\n# @DateTime:    2020-02-07 14:24:52\n# @Description: Think twice. Code once. \n# @More: Once lots of AC, try Brute-force,dynamic programming\n****************************************************************/\n#include<bits/stdc++.h>\nusing namespace std;\n#define close std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define eps 1e-8\n#define int long long \ntypedef long long ll;\nconst int maxn = 1e6+10;\nconst int INF = 0x3f3f3f3f;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1.0);\nll mod = 1e9+7;\nll bin(ll x , ll n , ll MOD){\n    ll ret = MOD != 1;\n    for(x %= MOD; n ; n >>= 1, x = x * x % MOD)\n        if(n & 1)ret = ret * x % MOD;\n    return ret;\n}\nint n , len , k , tot[maxn];\nvector<int > v;\nint32_t main()\n{\n    cin >> n >> k;\n    len = sqrt(n);\n    for(int i = 1; i <= len; i++){\n        if(n % i == 0){\n            v.emplace_back(i);\n            if(i != n / i)v.emplace_back(n / i);\n        }\n    }sort(v.begin(), v.end());\n    int size  = v.size();\n    ll ans = 0;\n    for(int i = 0 ; i < size ; i++){\n        tot[i] = bin(k , (v[i] + 1) / 2, mod);\n        for(int j = 0 ; j < i ; j++){\n            if(v[i] % v[j] == 0){\n                tot[i] = (tot[i] + mod - tot[j]) % mod;\n            }\n        }\n        if(v[i] & 1){ans += tot[i] * v[i]; ans %= mod;}\n        else {ans += tot[i] * (v[i] / 2) ; ans %= mod;}\n    }cout << ans << endl;\n    system(\"pause\");\n}\n/***************************************************************************\n*stuff you should look for\n*int overflow, array bounds\n*special cases (n=1?), set tle\n*do smth instead of nothing and stay organized\n***************************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u];i;i=sq[i].nxt)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,k;\nll f[2020];\nvector<int> fac;\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nll qpow(ll x,int y)\n{\n\tll ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=ans*x%maxd;\n\t\tx=x*x%maxd;y>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tn=read();k=read();\n\tfor (int i=1;i*i<=n;i++)\n\t{\n\t\tif (n%i) continue;\n\t\tfac.pb(i);\n\t\tif (i*i!=n) fac.pb(n/i);\n\t}\n\tint len=fac.size();\n\tsort(fac.begin(),fac.end());\n\trep(i,0,len-1)\n\t{\n\t\tint x=fac[i];\n\t\tf[i]=qpow(k,(x+1)/2);\n\t\trep(j,0,i-1)\n\t\t\tif (x%fac[j]==0)\n\t\t\t\tf[i]=(f[i]-f[j]+maxd)%maxd;\n\t}\n\tll ans=0;\n\trep(i,0,len-1)\n\t\tif (fac[i]&1) ans=(ans+f[i]*fac[i])%maxd;\n\t\telse ans=(ans+f[i]*(fac[i]/2))%maxd;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\ntypedef long long ll;\nint ksm(ll a,int b,int c=1){\n\tfor(;b;b/=2,a=a*a%mod)\n\t\tif(b&1)c=c*a%mod;\n\treturn c;\n}\n\ninline void reduce(int&x){x+=x>>31&mod;}\nint n,K,ans;\nvector<pair<int,int> >factor(int n){\n\tvector<pair<int,int> >ret;\n\tfor(int i=1;i*i<=n;++i)if(n%i==0)ret.emplace_back(i,0),ret.emplace_back(n/i,0);\n\tsort(ret.begin(),ret.end());\n\treturn ret;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>K;\n\tauto vec=factor(n);\n\tfor(auto&i:vec){\n\t\tint res=ksm(K,(i.first+1)/2);\n\t\tfor(auto j:vec)if(i.first%j.first==0)reduce(res-=j.second);\n\t\ti.second=res;res=(ll)res*i.first/(2-(i.first&1))%mod;\n\t\treduce(ans+=res-mod);\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n#define Would\n#define you\n#define please\n\nconst ll mod = 1e9 + 7;\nll modpow(ll A, ll B) {\n\tll kotae = 1;\n\twhile (B > 0) {\n\t\tif (B & 1) kotae = kotae * A % mod;\n\t\tA = A * A % mod;\n\t\tB >>= 1;\n\t}\n\treturn kotae;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tll N, K;\n\tcin >> N >> K;\n\n\tif (N % 2) {\n\t\tll a = modpow(K, N / 2 + 1);\n\t\tll kotae = (a - K + mod) * N + K;\n\t\tco(kotae % mod);\n\t}\n\telse {\n\t\tll a = modpow(K, N / 2);\n\t\tll n = N / 2;\n\t\tint k = 2;\n\t\twhile (n % 2 == 0) {\n\t\t\ta = a - (modpow(K, n / 2) - K + mod) * modpow(k, mod - 2) % mod + mod;\n\t\t\ta %= mod;\n\t\t\tn /= 2;\n\t\t\tk *= 2;\n\t\t}\n\t\t//おどろくほどわからない\n\t\tif ((N - 4) % 8 == 0) {\n\t\t\ta = (a + mod - 2) % mod;\n\t\t}\n\t\tll kotae = (a - K + mod) * modpow(2, mod - 2) % mod * N + K;\n\t\tif ((N - 4) % 8 == 0) {\n\t\t\tkotae += 4;\n\t\t}\n\n\t\tco(kotae % mod);\n\t}\n\n\t//set<string> ST;\n\t//int kaisuu = modpow(K, N / 2);\n\t//if (N % 2) kaisuu *= K;\n\t//rep(i, kaisuu){\n\t//\tstring S;\n\t//\tint kari = i;\n\t//\trep(j, (N + 1) / 2) {\n\t//\t\tS += '1' + kari % K;\n\t//\t\tkari /= K;\n\t//\t}\n\t//\trep(j, N / 2) {\n\t//\t\tS += S[N / 2 - j - 1];\n\t//\t}\n\n\t//\trep(j, N) {\n\t//\t\tST.insert(S);\n\t//\t\tchar tmp = S[0];\n\t//\t\tS.erase(0, 1);\n\t//\t\tS += tmp;\n\t//\t}\n\t//}\n\t//co(ST.size());\n\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\ninline int Get() {\n\tchar ch;\n\twhile ((ch = getchar()) < '0' || ch > '9');\n\tint Num = ch - '0';\n\twhile ((ch = getchar()) >= '0' && ch <= '9')\n\t\tNum = (Num << 3) + (Num << 1) + ch - '0';\n\treturn Num;\n}\nconst int Mod = 1e9 + 7;\nconst int N = 1e5 + 5;\nint n, m, ans, v[N], g[N], sze;\ninline int pow(int x, int k) {\n\tll res = 1, r = x % Mod;\n\tfor (; k; k >>= 1, r = r * r % Mod) \n\t\tif (k & 1) res = res * r % Mod;\n\treturn res;\n}\nint main() {\n\tn = Get(), m = Get();\n\tfor (int i = 1; (ll)i * i <= n; ++i)\n\t\tif (!(n % i)) {\n\t\t\tv[sze++] = i;\n\t\t\tif (n / i != i) v[sze++] = n / i;\n\t\t}\n\t\n\tstd :: sort(v, v + sze);\n\tfor (int i = 0, x; i < sze; ++i) {\n\t\tx = v[i], g[i] = pow(m, x + (x & 1) >> 1);\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tif (!(x % v[j])) g[i] = (g[i] - g[j] + Mod) % Mod;\n\t} \n\t\n\tfor (int i = 0, x; i < sze; ++i)\n\t\tx = v[i], (ans += (ll)((x & 1) ? x : x >> 1) * g[i] % Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!================================================================!//\n//!  888888ba  oo          oo                                      !//\n//!  88    '8b                                                     !//\n//!  88     88 dP dP   .dP dP .d8888b. .d8888b. 88d888b. .d8888b.  !//\n//!  88     88 88 88   d8' 88 Y8ooooo. 88'  '88 88'  '88 Y8ooooo.  !//\n//!  88    .8P 88 88 .88'  88       88 88.  .88 88             88  !//\n//!  8888888P  dP 8888P'   dP '88888P' '88888P' dP       '88888P'  !//\n//!================================================================!//\ntemplate <typename T>\nstd::vector<T> Divisors(const T n)\n{\n    std::vector<T> head, tail;\n    for (T i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            head.push_back(i);\n            if (i * i != n) { tail.push_back(n / i); }\n        }\n    }\n    for (auto it = tail.rbegin(); it != tail.rend(); it++) { head.push_back(*it); }\n    return head;\n}\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const ll N = read<ll>(), K = read<ll>();\n    auto D = Divisors(N);\n    std::map<ll, mint> dp;\n    mint ans = 0;\n    for (const ll d : D) {\n        dp[d] = mint(K) ^ ((d + 1) / 2);\n        for (const ll e : D) {\n            if (e < d and d % e == 0) { dp[d] -= dp[e]; }\n        }\n        ans += dp[d] * (d % 2 == 0 ? d / 2 : d);\n    }\n    SHOW(dp);\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <cassert>\nusing namespace std;\n#define fast_io ios_base::sync_with_stdio (false) ; cin.tie(0) ; cout.tie(0) ;\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define MOD (long long int)(1e9+7)\n#define INF (int)(1e9)\n#define LINF (long long int)(1e18)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  if(n <= 1e7){\n    ret *= kaijo(n); ret %= MOD;\n    ret *= gyaku_kaijo(r); ret %= MOD;\n    ret *= gyaku_kaijo(n-r); ret %= MOD;\n  }else{\n    rep(i,r){\n      ret *= n-i; ret %= MOD;\n      ret *= mpow(r-i, MOD-2); ret %= MOD;\n    }\n  }\n  return ret;\n}\n\nvector<ll> yakusu(ll n){\n  vector<ll> ret;\n  for(ll p = 1; p*p <= n; p++){\n    if(n%p == 0){\n      ret.push_back(p);\n      if(p*p != n){\n        ret.push_back(n/p);\n      }\n    }\n  }\n  sort(all(ret));\n  return ret;\n}\n\nint main(void){\n  fast_io\n  cout<<fixed<<setprecision(15);\n\n  ll n,k;cin>>n>>k;\n  vector<ll> yaku = yakusu(n);\n  map<ll,ll> mp;\n  ll ans = 0;\n  rep(i,yaku.size()){\n    ll p = yaku[i];\n    ll num = (p+1) / 2;\n    ll val = mpow(k, num);\n    vector<ll> ko = yakusu(p);\n    ko.pop_back();\n    rep(j,ko.size()){\n      ll q = ko[j];\n      assert(mp.count(q) > 0);\n      val -= mp[q];\n      val += MOD;\n      val %= MOD;\n    }\n    mp[p] = val;\n    //cout<<p<<\" \"<<mp[p]<<endl;\n    ans += val * p / (p%2 == 0 ? 2 : 1) % MOD;\n    ans %= MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=200000;\nconst int mod=1e9+7;\nint qpow(int a,int b) { int c=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) c=1ll*c*a%mod;\n\treturn c;\n}\n\nint n,k,fac[N],cnt=0,dp[N];\n\nint main() {\n\tn=read(),k=read();\n\tfor (int i=1;i*i<=n;++i) {\n\t\tif (n%i) continue;\n\t\tfac[++cnt]=i;\n\t\tif (i*i!=n) fac[++cnt]=n/i;\n\t}\n\tsort(fac+1,fac+cnt+1);\n\tfor (int i=1;i<=cnt;++i) {\n\t\tdp[i]=qpow(k,(fac[i]+1)/2);\n\t\tfor (int j=1;j<i;++j)\n\t\t\tif (fac[i]%fac[j]==0) dp[i]=(dp[i]-dp[j]+mod)%mod;\n\t}\n\tint ans=0;\n\tfor (int i=1;i<=cnt;++i) {\n\t\tif (fac[i]&1) ans=(ans+1ll*dp[i]*fac[i])%mod;\n\t\telse ans=(ans+1ll*dp[i]*fac[i]/2)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(ll n,ll k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=Pmod((x+1)/2,k);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(mod+tmp-v[j].second)%mod;\n\t\t\t}\n\t\t}\n\t\tv[i].second=tmp;\n\t\tans[x%2]+=tmp*x%mod;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int mod = 1000000007;\n\ninline void inc(int &x, int y) { (x += y) >= mod && (x -= mod); }\ninline int mul(int x, int y) { return 1LL * x * y - 1LL * x * y / mod * mod; }\ninline int modpower(int x, int y) {\n  int res = 1;\n  while (y) {\n    if (y & 1) res = mul(res, x);\n    y >>= 1, x = mul(x, x);\n  }\n  return res;\n}\n\nint n, k, ans;\nint F[10000];\nint main() {\n  scanf(\"%d %d\", &n, &k);\n  vector<int> factor;\n  for (int i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      factor.push_back(i);\n      if (i * i != n) factor.push_back(n / i);\n    }\n  }\n  sort(factor.begin(), factor.end());\n  ans = 0;\n  for (int i = 0; i < (int)factor.size(); ++i) {\n    int x = factor[i];\n    F[i] = modpower(k, (x + 1) / 2);\n    for (int j = 0; j < i; ++j)\n      if (x % factor[j] == 0) inc(F[i], mod - F[j]);\n    inc(ans, mul(F[i], (x & 1) ? x : x / 2));\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first\n# define y second \n# define mp make_pair\n\n# define pb push_back\n# define vec vector\n# define sz(a) int(a.size())\n\n# define y1 kek_y1                  \n# define left kek_left\n# define right kek_right\n\nusing namespace std;\n\ntypedef long  long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int Sz = 1110111;\nconst int Mod = (int)1e9 + 7;\nconst int MX = (1<<30) - 1; // 1e9\nconst ll MXLL = (1ll<<62) - 1;        \n\ninline void Read_rap() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n}\nvoid files (string name) {\n\tif (fopen ((name+\".in\").c_str(), \"r\")) {\n\t\tfreopen ((name+\".in\").c_str(), \"r\", stdin);\n\t\tfreopen ((name+\".out\").c_str(), \"w\", stdout);\n\t}\n}                       \nint n;\n\nint x[Sz], y[Sz];\n   \nint r[Sz];\n\nconst int N = 1003;\n\nld dist[N][N];\n\nint main()\n{\n\tRead_rap();\n\n\tcin >> x[1] >> y[1];\n\tcin >> x[2] >> y[2];\n\tcin >> n;\n\tfor (int i = 3; i <= n+2; i++) \n\t\tcin >> x[i] >> y[i] >> r[i];\n        \t\n    n += 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tld D = sqrt ( (x[i] - x[j]) * 1ll * (x[i] - x[j]) + (y[i] - y[j]) * 1ll * (y[i] - y[j]));\n\t\t\tdist[i][j] = max ((ld)0.0, D - r[i] - r[j]);\n\t\t}\n\t}                    \n\tvec<bool> used(n + 1, 0);\n\tvec<ld> d(n + 1, 2*(ld)MX);\n\td[1] = 0;    \n\tfor (int t = 0; t < n-1; t++) {\n\t\tint v = -1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!used[i] && (v == -1 || d[v] > d[i]))\n\t\t\t\tv = i;\n\t\t}                   \n\t\tused[v] = 1;\n\t\tfor (int to = 1; to <= n; to++) {\n\t\t\t//if (!used[to])\n\t\t\t\td[to] = min (d[to], d[v] + dist[v][to]);\n\t\t}\n\t}\n\tcout << fixed <<setprecision (10) << d[2];\n\n\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n//Coded by Z....\t\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\n\nll mod_pow(ll x, ll k) {\n\tll res = 1;\n\tfor (; k; k /= 2, x = x * x % MOD) {\n\t\tif (k & 1) res = res * x % MOD;\n\t}\n\treturn res;\n}\n\nint N, K;\nll ret;\n\nint main() {\n\tcin >> N >> K;\n\n\tvi dv;\n\n\tfor (int i = 1; i * i <= N; ++i) {\n\t\tif (N % i == 0) {\n\t\t\tdv.pb(i);\n\t\t\tif (i * i != N) {\n\t\t\t\tdv.pb(N / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(dv));\n\n\tvector<ll> vec(dv.size());\n\n\tll ret = 0;\n\trep(i, dv.size()) {\n\t\tll t = mod_pow(K, (dv[i] + 1) / 2);\n\t\trep(j, i) {\n\t\t\tif (dv[i] % dv[j] == 0) {\n\t\t\t\tt = (t - vec[j]);\n\t\t\t\tif (t < 0) t += MOD;\n\t\t\t}\n\t\t}\n\t\tvec[i] = t;\n\n\t\tif (dv[i] & 1) {\n\t\t\tret = (ret + vec[i] * dv[i]) % MOD;\n\t\t} else {\n\t\t\tret = (ret + vec[i] * dv[i] / 2) % MOD;\n\t\t}\n\t}\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint mo=1000000007;\nlint zyo(lint x,lint y){\n    lint ret=1,a=x;\n    while(y>0){\n    \tif(y%2==1) ret=(ret*a)%mo;\n    \ta=(a*a)%mo;y/=2;\n    }\n    return ret;\n}\nvector<lint> yak;\nlint dp[114514];\nint main()\n{\n\tint n,k;lint out=0;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tyak.pb(i);\n\t\t\tif(i*i<n) yak.pb(n/i);\n\t\t}\n\t}\n\tsort(All(yak));\n\tint m=yak.size();\n\trep(i,m){\n\t\tdp[i]=zyo(k,((yak[i]+1)/2));\n\t\trep(j,i){\n\t\t\tif(yak[i]%yak[j]>0) continue;\n\t\t\tdp[i]+=mo-dp[j];\n\t\t}\n\t\tdp[i]%=mo;\n\t}\n\trep(i,m){\n\t\tif(yak[i]%2>0){\n\t\t\tout+=dp[i]*yak[i];\n\t\t}\n\t\telse{\n\t\t\tout+=dp[i]*yak[i]/2;\n\t\t}\n\t\tout%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    REP(i, M){\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        if(l1 <= rmax){\n            int t = n1[rmax + 1];\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            int t = n1[l1];\n            REP(k, t + 1){\n                dp[i + 1][t] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][t] %= mod;\n            }\n        }\n    }\n    //debug(dp);\n    cout << dp[M][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint n, k;\nbool prime[100005];\nvector<llint> pvec, fvec, vec;\nllint cnt[1505], cnt2[1505];\nmap<llint, llint> mp;\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nllint moebius(llint x)\n{\n\tllint ret = 1;\n\tfor(int i = 0; i < fvec.size(); i++){\n\t\tbool flag = false;\n\t\tllint p = fvec[i];\n\t\twhile(x % p == 0){\n\t\t\tx /= p;\n\t\t\tif(flag) return 0;\n\t\t\tflag = true;\n\t\t\tret *= mod-1, ret %= mod;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> k;\n\t\n\tfor(int i = 2; i < 4005; i++){\n\t\tif(prime[i]) continue;\n\t\tfor(int j = 2*i; j < 100005; j+=i) prime[j] = true;\n\t}\n\tfor(int i = 2; i < 100005; i++){\n\t\tif(!prime[i]) pvec.push_back(i);\n\t}\n\t\n\tllint t = n;\n\tfor(int i = 0; i < pvec.size(); i++){\n\t\tllint p = pvec[i];\n\t\twhile(t % p == 0){\n\t\t\tt /= p;\n\t\t\tfvec.push_back(p);\n\t\t}\n\t}\n\tif(t > 1) fvec.push_back(t);\n\tsort(fvec.begin(), fvec.end());\n\tfvec.erase(unique(fvec.begin(), fvec.end()), fvec.end());\n\t\n\tfor(llint i = 1; i*i <= n; i++){\n\t\tif(n%i) continue;\n\t\tvec.push_back(i);\n\t\tvec.push_back(n/i);\n\t}\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\n\tllint m = vec.size();\n\tfor(int i = 0; i < m; i++) mp[vec[i]] = i;\n\tfor(int i = 0; i < m; i++){\n\t\tcnt[i] = modpow(k, (vec[i]+1)/2);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(vec[i] % vec[j]) continue;\n\t\t\tcnt2[i] += moebius(vec[j]) * cnt[mp[vec[i]/vec[j]]] % mod;\n\t\t\tcnt2[i] %= mod;\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tllint p = vec[i];\n\t\tif(p % 2) ans += p * cnt2[i] % mod, ans %= mod;\n\t\telse ans += p/2 * cnt2[i] % mod, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MOD = (int) 1e9 + 7;\n\nint Pow(int x, int y) {\n    int ret = 1;\n    for (; y > 0; y /= 2) {\n        if (y & 1) {\n            ret = (int64_t) ret * x % MOD;\n        }\n        x = (int64_t) x * x % MOD;\n    }\n    return ret;\n}\n\nvector<int> getDivs(int n) {\n    vector<int> divs;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            divs.push_back(i);\n            if (i * i < n) {\n                divs.push_back(n / i);\n            }\n        }\n    }\n    return divs;\n}\n\nint nonSubpalindromic(int n, int k) {\n    vector<int> divs = getDivs(n);\n    int ans = Pow(k, (n + 1) / 2);\n    for (int p: divs) {\n        if (p != n) {\n            ans -= nonSubpalindromic(p, k);\n            ans %= MOD;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, k;\n    cin >> n >> k;\n\n    int ans = 0;\n\n    vector<int> divs = getDivs(n);\n    if (n % 2 == 1) {\n        for (int p: divs) {\n            int mul = p;\n            ans = (ans + (int64_t) mul * nonSubpalindromic(p, k)) % MOD;\n        }\n    } else {\n        for (int p: divs) {\n            if (p % 2 == 0) {\n                int mul = (int64_t) p * Pow(2, MOD - 2) % MOD;\n                int val = nonSubpalindromic(p, k);\n                // cerr << p << ' ' << mul << ' ' << val << endl;\n                ans = (ans + (int64_t) mul * val) % MOD;\n            } else {\n                int mul = p;\n                int val = nonSubpalindromic(p, k);\n                ans = (ans + (int64_t) mul * val) % MOD;\n            }\n        }\n    }\n\n    ans %= MOD;\n    if (ans < 0) {\n        ans += MOD;\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ndouble f[1005][1005],dis[1005],a[1005][3];\nbool b[1005];\nint main()\n{\n\tint i,j,k,n;\n\tdouble xi,xs,ys,xt,yt;\n\tscanf(\"%lf%lf%lf%lf\",&xs,&ys,&xt,&yt);\n\tscanf(\"%d\",&n);\n\ta[0][0]=xs;a[0][1]=ys;a[0][2]=0;\n\ta[n+1][0]=xt;a[n+1][1]=yt;a[n+1][2]=0;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf%lf\",&a[i][0],&a[i][1],&a[i][2]);\n\tn++;\n\tfor(i=0;i<n;i++)\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tf[i][j]=f[j][i]=sqrt((a[i][0]-a[j][0])*(a[i][0]-a[j][0])+(a[i][1]-a[j][1])*(a[i][1]-a[j][1]))-(a[i][2]+a[j][2]);\n\t\t\tif(f[i][j]<0)\n\t\t\t\tf[i][j]=0;\n\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tdis[i]=f[0][i];\n\tb[0]=1; \n\tdis[0]=0; \n\tfor(i=0;i<=n;i++){ \n\t\txi=1e10;\n\t\tk=0; \n\t\tfor(j=0;j<=n;j++){\n            if(b[j]==0&&dis[j]<xi){ \n\t\t\t\txi=dis[j]; \n\t\t\t\tk=j; \n\t\t\t} \n        }\n\t\tb[k]=1; \n\t\tfor(j=0;j<=n;j++)\n\t\t\tdis[j]=min(dis[j],dis[k]+f[k][j]);\n\t}\n\tprintf(\"%.10lf\",dis[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> d;\n    for (int i = 1; i*i <= n; i++) {\n        if (n%i) continue;\n        d.emplace_back(i);\n        if (i*i!=n) d.emplace_back(n/i);\n    }\n\n    sort(d.begin(), d.end());\n    map<int,mint> f;\n    int m = d.size();\n    for (int i = 0; i < m; i++) {\n        mint ways = mint(k).exp((d[i]+1)/2);\n        for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) {\n                ways -= f[d[j]];\n            }\n        }\n        f[d[i]] = ways;\n    }\n    \n    mint res = 0;\n    for (auto& p: f) {\n        int x; mint w;\n        tie(x,w) = p;\n        if (x & 1) res += w * x;\n        else res += w * (x/2);\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nint ans;\nint fastpow(int x,int a){\n\tint ret=1;\n\twhile(a){\n\t\tif(a&1) ret=ret*1LL*x%mod;\n\t\tx=x*1LL*x%mod;a>>=1;\n\t}\n\treturn ret;\n}\n\nint ys[50005],yscnt;\nint xs[50005];\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tys[++yscnt]=i;\n\t\t\tif(i*i!=n) ys[++yscnt]=n/i;\n\t\t}\n\t}\n\tsort(ys+1,ys+yscnt+1);\n\tfor(int i=1;i<=yscnt;i++){\n\t\tif(n%2==0&&ys[i]%2!=0) continue;\n\t\tans=(ans + fastpow(k,ys[i]%2==0? n/ys[i]:(n/ys[i]+1)/2)*1LL*(n/ys[i])%mod*(1-xs[i]) )%mod;\n\t\tfor(int j=i+1;j<=yscnt;j++) if(ys[j]%ys[i]==0) xs[j]=(xs[j]+ (1-xs[i])*1LL*(ys[j]/ys[i]))%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint pow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nconst int MAXN = 100010;\nint n, K, li[MAXN], bak, f[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> K;\n\tfor (int i = 1; i * i <= n; ++i)\n\t\tif (n % i == 0) {\n\t\t\tli[++bak] = i;\n\t\t\tif (i * i != n) li[++bak] = n / i;\n\t\t}\n\tstd::sort(li + 1, li + 1 + bak);\n\tint ans = 0;\n\tfor (int i = bak; i; --i) {\n\t\tf[i] = pow(K, n / li[i] + 1 >> 1);\n\t\tfor (int j = i + 1; j <= bak; ++j)\n\t\t\tif (li[j] % li[i] == 0)\n\t\t\t\treduce(f[i] -= f[j]);\n\t\tint r = n / li[i];\n\t\treduce(ans += mul(f[i], r & 1 ? r : r >> 1) - mod);\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"math.h\"\nusing namespace std;\n\nlong long int ans=1;\nlong long int N, M;\nlong long int box;\nlong long int modi[100];\nint num;\n\nint main() {\n\tcin >> N >> M;\n\tbox = (N+1)/2;\n\tmodi[0] = M;\n\tfor (int i = 1; i < 100; i++) {\n\t\tmodi[i] = modi[i - 1] * modi[i - 1];\n\t\tmodi[i] %= 1000000007;\n\t}\n\twhile (box>0) {\n\t\tif (box % 2 == 0) {\n\t\t\tbox /= 2;\n\t\t\tnum++;\n\t\t}\n\t\telse {\n\t\t\tans *= modi[num];\n\t\t\tans %= 1000000007;\n\t\t\tbox--;\n\t\t}\n\t}\n\tif(N%2==0)\tans += (ans - M)*((N + 1) / 2 - 1);\n\telse ans += (ans - M)*(N - 1);\n\twhile(ans<0)ans += 10000000070000000;\n\tans %= 1000000007;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t//mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int md = 1e9 + 7;\nint n, k;\nvector<int> dvs;\nint dp[N];\n\nint pw(int x, int y) {\n\tint res = 1;\n\twhile(y) {\n\t\tif (y & 1) res = 1LL * res * x % md; x = 1LL * x * x % md;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> k;\n\n\t// find divisors of n\n\tfor (int i = 1; i * i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tdvs.push_back(i);\n\t\t\tif (i != n / i) dvs.push_back(n / i);\n\t\t}\n\t}\n\tsort(dvs.begin(), dvs.end());\n\n\t// calculate DPs\n\tdp[0] = k;\n\tfor (int i = 1; i < dvs.size(); ++i) {\n\t\tint d = dvs[i]; // minimum period\n\t\tdp[i] = pw(k, (d + d % 2) / 2);\n\t\tfor (int j = 0; j < i; ++j) if (d % dvs[j] == 0) {\n\t\t\tdp[i] -= dp[j];\n\t\t\tif (dp[i] < 0) dp[i] += md;\n\t\t}\n\t}\n\n\t// calculate the answer\n\tint ans = 0;\n\tfor (int i = 0; i < dvs.size(); ++i) {\n\t\tint d = dvs[i]; \n\t\tans = (ans + 1LL * dp[i] * ((d & 1) ? d : d / 2)) % md;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n\tchar ch = getchar(), f = 1; x = 0;\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') ch = getchar(), f = -1;\n\twhile (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n\tx *= f;\n}\n\ntemplate <typename Tp> void out(Tp x) {\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n\treturn;\n}\n\ntemplate <typename Tp> Tp Max(const Tp &x, const Tp &y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp Min(const Tp &x, const Tp &y) {return x < y ? x : y;}\ntemplate <typename Tp> bool chkmax(Tp &x, Tp y) {return x >= y ? 0 : (x=y, 1);}\ntemplate <typename Tp> bool chkmin(Tp &x, Tp y) {return x <= y ? 0 : (x=y, 1);}\n\nconst int MAXN = 3010;\nconst int MOD = 1000000007;\n\nint n, k;\nint yue[MAXN], f[MAXN];\n\nint power(int x, int y)\n{\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % MOD;\n\t\tx = 1ll * x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tin(n); in(k);\n\n\tint sqr = sqrt(n);\n\n\tFOR(i, 1, sqr) {\n\t\tif (n % i == 0) {\n\t\t\tyue[++yue[0]] = i;\n\t\t\tif (i != n / i) yue[++yue[0]] = n / i;\n\t\t}\n\t}\n\n\tstd::sort(yue + 1, yue + yue[0] + 1);\n\n\tLL ans = 0;\n\t\n\tFOR(i, 1, yue[0]) {\n\t\tf[i] = power(k, (yue[i] + 1) / 2);\n\t\tFOR(j, 1, i - 1) if (yue[i] % yue[j] == 0) f[i] = (f[i] - f[j] + MOD) % MOD;\n\t\tif (yue[i] % 2 == 0) ans = (ans + 1ll * f[i] * power(2, MOD - 2) % MOD * yue[i]) % MOD;\n\t\telse ans = (ans + 1ll * f[i] * yue[i]) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\nusing lint = long long;\n\nstruct modint {\n    int v;\n    modint(lint v_ = 0): v(v_ % MOD) { }\n    modint operator+ (const modint &m) const {\n        return modint(v + m.v);\n    }\n    modint operator- (const modint &m) const {\n        return modint(v - m.v + MOD);\n    }\n    modint operator* (const modint &m) const {\n        return modint((lint)v * m.v);\n    }\n    modint operator+= (const modint &m) {\n        v = (v + m.v) % MOD;\n        return *this;\n    }\n    modint operator*= (const modint &m) {\n        v = ((lint)v * m.v) % MOD;\n        return *this;\n    }\n    modint operator-= (const modint &m) {\n        v = (v - m.v + MOD) % MOD;\n        return *this;\n    }\n    modint pow(int k) {\n        modint cur(v), ret(1);\n        while(k > 0) {\n            if(k & 1) ret *= cur;\n            cur = cur * cur;\n            k >>= 1;\n        }\n        return ret;\n    }\n    modint inv() {\n        return pow(MOD - 2);\n    }\n};\n\nconst modint INV2 = modint(2).inv();\n\nint N, K;\n\nmodint ans;\n\nmodint ways[int(5.1e4)];\n\nint main() {\n    scanf(\"%d%d\", &N, &K);\n    \n    vector<int> divs;\n    for(int i = 1; i * i <= N; i++) {\n        if(N % i == 0) {\n            divs.push_back(i);\n            if(i * i != N) divs.push_back(N/i);\n        }\n    }\n    \n    sort(divs.begin(), divs.end());\n    \n    for(int i = 0; i < int(divs.size()); i++) {\n        // degree of freedom : divs[i]\n        \n        ways[i] += modint(K).pow((divs[i] + 1) / 2);\n        for(int j = 0; j < i; j++) if(divs[i] % divs[j] == 0) ways[i] -= ways[j];\n        \n        ans += (divs[i] % 2 == 1 ? modint(1) : INV2) * ways[i] * divs[i];\n    }\n    \n    printf(\"%d\\n\", ans.v);\n    \n    \n    return 0;\n}\n\n/*\nN이 홀수\n\nABCBA => A, B, C 중 하나라도 다르면 서로 다른 수열을 얻음\n\nBCBAA -> B=A, C=A -> 전부 같아야\nCBAAB -> C=B=A\nBAABC -> B=C=A\nAABCB -> A=B=C\n\n염려:\nDEFED\nEFEDD\nFEDDE\nEDDEF\nDDEFE\n\n\nN이 짝수 -> A, B, C가 하나라도 다르면 서로 다른 palin 수열 2개가 같은 결과\n\nABCCBA \nBCCBAA B=A=C\nCCBAAB C=B=A\nCBAABC (palin!)\nBAABCC B=C=A\nAABCCB A=B=C\n*/ac"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nconst ll MOD = (ll)(1e9 + 7);\n\n\nll mod_pow(ll a, ll b, ll p) {\n  ll res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % p;\n    a = (a * a) % p;\n    b >>= 1;\n  }\n  return res;\n}\n\nconst int SIZE = 1000000;\nvector<int> primes;\nbool isPrime[SIZE];\n\nvoid make_primes() {\n  if (primes.size() > 0) return;\n  memset(isPrime, true, sizeof(isPrime));\n  isPrime[0] = isPrime[1] = false;\n  for (int i = 2; i * i < SIZE; i++) \n    if (isPrime[i])\n      for (int j = i * i; j < SIZE; j += i)\n        isPrime[j] = false;\n  REP(i, SIZE) if (isPrime[i]) primes.push_back(i);\n}\n\nvector<int> divisors(int n) {\n  vector<int> ds;\n  for(int d = 1; d * d <= n; d++) {\n    if (n % d == 0) {\n      ds.push_back(d);\n      if (d * d != n) ds.push_back(n/d);\n    }\n  }\n  sort(ds.begin(), ds.end());\n  return ds;\n}\n\nvector<int> factorize(int n) {\n  vector<int> ps;\n  for (int i = 0; primes[i] * primes[i] <= n; i++) {\n    while (n % primes[i] == 0) {\n      ps.push_back(primes[i]);\n      n /= primes[i];\n    }\n  }\n  if (n > 1) ps.push_back(n);\n  sort(ps.begin(), ps.end());\n  return ps;\n}\n\nmap<int,int> mobius(int N) {\n  map<int,int> res;\n  vector<int> ps = factorize(N);\n  ps.erase(unique(ALL(ps)), ps.end());\n  int M = ps.size();\n  REP(i, 1 << M) {\n    int mu = 1, d = 1;\n    REP(j, M) if (i >> j & 1) {\n      mu *= -1;\n      d *= ps[j];\n    }\n    res[d] = mu;\n  }\n  return res;\n}\n\nint N, K;\n\nll f(int t) {\n  return mod_pow(K, (t+1)/2, MOD);\n}\n\nint main2() {\n  cin >> N >> K;\n\n  map<int,int> m = mobius(N);\n  vector<int> ds = divisors(N);\n\n  ll ans = 0;\n  for (int t : ds) {\n    ll cur = 0;\n    for (int s : ds) if (t % s == 0) {\n      cur += m[t/s] * f(s) % MOD;\n      cur = (cur % MOD + MOD) % MOD;\n    }\n    ans += cur * (t % 2 == 0 ? t / 2 : t);\n    ans = (ans % MOD + MOD) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  make_primes();\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nmap<int, ll> M;\nll n, k;\n\nll pow(ll a, ll b) {\n    ll r = 1;\n    while(b > 0) {\n        if(b % 2 == 1) r = (r * a) % MOD;\n        a = (a * a) % MOD;\n        b /= 2;\n    }\n    return r;\n}\n\nint main() {\n    cin >> n >> k;\n    vector<int> dzielniki;\n    for(int d = 1; d * d <= n; d++) {\n        if(n % d == 0) {\n            dzielniki.push_back(d);\n            if(n / d != d) {\n                dzielniki.push_back(n / d);\n            }\n        }\n    }\n    sort(dzielniki.begin(), dzielniki.end());\n    for(int j = 0; j < dzielniki.size(); j++) {\n        ll d = dzielniki[j];\n//         cout << d << endl;\n        M[d] = pow(k, (d + 1) / 2);\n//         cout << \"M[\" << d << \"] = \" << M[d] << endl;\n        for(int i = 0; i < dzielniki.size(); i++) {\n            if(dzielniki[i] >= d) break;\n            if(d % dzielniki[i] == 0) M[d] = (M[d] - M[dzielniki[i]] + MOD) % MOD;\n        }\n//         cout << \"M[\" << d << \"] = \" << M[d] << endl;\n    }\n    ll wynik = 0;\n    for(ll d : dzielniki) {\n        ll curr = 0;\n        if(d % 2 == 1) {\n            curr = (M[d] * d) % MOD;\n        } else {\n            curr = (M[d] * (d / 2LL)) % MOD;\n        }\n        wynik = (wynik + curr) % MOD;\n    }\n    cout << wynik;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::sort;\n\nconst int N=1e5+10,Mod=1e9+7;\n\nint n,k,que[N],dp[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&k);\n}\n\nvoid Solve() {\n\tint top=0;\n\tfor (int i=1;i*i<=n;++i) {\n\t\tif (n%i) continue;\n\t\tque[++top]=i;\n\t\tif (i*i==n) continue;\n\t\tque[++top]=n/i;\n\t}\n\tsort(que+1,que+top+1);\n\t\n\tint cnt=1,d=0,ans=0;\n\tfor (int i=1;i<=top;++i) {\n\t\twhile (d<((que[i]+1)>>1)) ++d,cnt=1ll*cnt*k%Mod;\n\t\tdp[i]=cnt;\n\t\tfor (int j=1;j<i;++j) if (que[i]%que[j]==0) {\n\t\t\tdp[i]=(dp[i]-dp[j]+Mod)%Mod;\n\t\t}\n\t\tif (que[i]&1) ans=(ans+1ll*dp[i]*que[i]%Mod)%Mod;\n\t\telse ans=(ans+1ll*dp[i]*que[i]/2%Mod)%Mod;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nlong long n, k, cnt = 1, dp[1500], ans = 0;\nvector<long long> divisors;\n\nlong long power(long long a, long long n) {\n    if(n == 0) return 1;\n    if(n == 1) return a;\n    long long b = power(a, n/2);\n    b = (b*b) % mod;\n    if(n&1) b = (b*a) % mod;\n    return b;\n}\n\nint main() {\n    scanf(\"%lld%lld\", &n, &k);\n    long long p = sqrt(n);\n    for(int i = 1; i <= p; i++) {\n        if(n % i == 0) {\n            divisors.push_back(i);\n            long long q = n/i;\n            if(q > i) divisors.push_back(q);\n        }\n    }\n    sort(divisors.begin(), divisors.end());\n    for(int i = 0; i < divisors.size(); i++) {\n        dp[i] = power(k, (divisors[i] + 1)/2) % mod;\n        for(int j = 0; j < i; j++) {\n            if(divisors[i] % divisors[j] == 0) dp[i] = (dp[i] - dp[j] + mod) % mod;\n        }\n        ans = ((divisors[i]&1 ? divisors[i] : divisors[i]>>1) * dp[i] + ans) % mod;\n    }\n    printf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tbool flag = true;\n\tif (n % 2 == 0) {\n\t\tn /= 2;\n\t\tflag = false;\n\t}\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tif (!flag) {\n\t\t\t\tmp[i] = modpow(k, i);\n\t\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[i] = modpow(k, (i + 1) / 2);\n\t\t\t\tmp[n / i] = modpow(k, (n / i + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\t//cout << i.first << ' ' << i.second << endl;\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod (1000000007)\n#define rv2 (500000004)\n\nint N, K;\nstd::map<int, int> d;\n\nint powmod(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1) ret = (1ll) * ret * a % mod;\n\t\tb >>= 1;\n\t\ta = (1ll) * a * a % mod;\n\t}\n\treturn ret;\n}\n\nint get_d(int i){\n\tint ret = powmod(K, (i + 1) / 2);\n\tfor(int j = 1; j * j <= i; ++ j){\n\t\tif(i % j || j == i) continue;\n\t\tret = (ret - d[j] + mod) % mod;\n\t\tif(i / j == j || i / j == i) continue;\n\t\tret = (ret - d[i / j] + mod) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &K);\n\tint ans = 0;\n\tfor(int i = 1; i <= N; ++ i){\n\t\tif(N % i) continue;\n\t\td[i] = get_d(i);\n\t\tif(i % 2) ans = (ans + (1ll) * d[i] * i % mod) % mod;\n\t\telse ans = (ans + (1ll) * d[i] * i % mod * rv2 % mod) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 60; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; }\n\t\tp %= m; q *= q; q %= m;\n\t}\n\treturn p;\n}\nlong long N, K, M[1500], mod = 1000000007; vector<long long>E;\nint main() {\n\tcin >> N >> K;\n\tfor (int i = 1; i*i <= N; i++) {\n\t\tif (N%i != 0)continue;\n\t\tE.push_back(i);\n\t\tE.push_back(N / i);\n\t}\n\tsort(E.begin(), E.end());\n\tE.erase(unique(E.begin(), E.end()), E.end());\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tlong long cnt = modpow(K, (E[i] + 1) / 2, mod);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (E[i] % E[j] == 0)cnt -= M[j]; cnt += mod; cnt %= mod;\n\t\t}\n\t\tM[i] = cnt;\n\t}\n\tlong long ret = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tlong long G = E[i]; if (G % 2 == 0)G /= 2;\n\t\tret += G*M[i]; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, K;\nvector<int> divs;\n\ni64 modpow(i64 a, int p)\n{\n\tif (p == 0) return 1;\n\ti64 ret = modpow(a, p / 2);\n\tret = ret * ret % MOD;\n\tif (p % 2 == 1) ret = ret * a % MOD;\n\treturn ret;\n}\n\nint mebius(int v)\n{\n\tint ret = 1;\n\tfor (int p : divs) if (p > 1 && v % p == 0) {\n\t\tv /= p;\n\t\tif (v % p == 0) return 0;\n\t\tret *= -1;\n\t}\n\treturn ret;\n}\n\nmap<int, int> meb;\nmap<int, i64> ori;\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\n\tfor (int i = 1; i * i <= N; ++i) {\n\t\tif (N % i == 0) {\n\t\t\tdivs.push_back(i);\n\t\t\tif (N != i * i) divs.push_back(N / i);\n\t\t}\n\t}\n\tsort(divs.begin(), divs.end());\n\tfor (int a : divs) meb[a] = mebius(a);\n\n\tif (N % 2 == 0) {\n\t\tfor (int a : divs) if ((N / a) % 2 == 0) {\n\t\t\tori[a] = modpow(K, a);\n\t\t}\n\t\ti64 ret = 0;\n\t\tfor (int a : divs) if ((N / a) % 2 == 0) {\n\t\t\ti64 tmp = 0;\n\t\t\tfor (int b : divs) if (a % b == 0) {\n\t\t\t\tADD(tmp, MOD + ori[b] * meb[a / b]);\n\t\t\t}\n\t\t\tADD(ret, tmp * a);\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t} else {\n\t\tfor (int a : divs) {\n\t\t\tori[a] = modpow(K, (a + 1) / 2);\n\t\t}\n\t\ti64 ret = 0;\n\t\tfor (int a : divs) {\n\t\t\ti64 tmp = 0;\n\t\t\tfor (int b : divs) if (a % b == 0) {\n\t\t\t\tADD(tmp, MOD + ori[b] * meb[a / b]);\n\t\t\t}\n\t\t\tADD(ret, tmp * a);\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int P = 1e9+7;\nconst int inv =  5e8+4;\nint Pow(int a,int b){\n\tif(b==0) return 1;\n\tint ret = Pow(a,b>>1);\n\tret=1ll*ret*ret%P;\n\tif(b&1) ret=1ll*ret*a%P;\n\treturn ret;\n}\nint n,K,ans,q[100000];\nmap<int,int> POW,F; \ninline add(int &x,int y ){x=(x+y)%P;}\n\nint main(){\n\tcin>>n>>K;\n\tint t,l;\n\tfor(int i=1;1ll*i*i<=n;i++) if(n%i==0){\n\t\t//cout<<i<<endl;\n\t\tPOW[i] = Pow(K,(i+1)>>1);\n\t\tt = n/i;\n\t\tPOW[t] = Pow(K,(t+1)>>1);\n\t}\n\t//cout<<POW[n]<<endl;\n\tint cnt = 0;\n\tfor(int i=1;1ll*i*i<=n;i++) if(n%i==0){\n\t\t//cout<<i<<endl;\n\t\tt = i;\n\t\tl = n/t;\n\t\tadd(F[t],POW[t]);\n\t\tfor(int j=2;1ll*j*j<=l;j++) if(l%j==0){\n\t\t\tadd(F[j*t],-F[t]);\n\t\t\tif(j*j!=l) add(F[t*(l/j)],-1ll*F[t]%P);\n\t\t}\n\t\tif(n!=t) add(F[n],-1ll*F[t]%P);\n\t\tif(t&1) add(ans,1ll*F[t]*t%P);\n\t\telse add(ans,1ll*t*F[t]%P*inv%P);\n\t\t\n\t\tif(i*i!=n)q[++cnt] = n/i;\n\t}\n\t//cout<<\"YYY\"<<endl;\n\tfor(int i=cnt;i>0;i--){\n\t\tt = q[i];\n\t\tl = n/t;\n\t\tadd(F[t],POW[t]);\n\t\tfor(int j=2;1ll*j*j<=l;j++) if(l%j==0){\n\t\t\tadd(F[j*t],-F[t]);\n\t\t\tif(j*j!=l) add(F[t*(l/j)],-1ll*F[t]%P);\n\t\t}\n\t\tif(n!=t) add(F[n],-1ll*F[t]%P);\n\t\t//add(ans,1ll*F[t]*t%P);\n\t\t//if(t!=n) add(ans,1ll*F[t]*t%P);\n\t\t//else {\n\t\tif(t&1) add(ans,1ll*F[t]*t%P);\n\t\telse add(ans,1ll*F[t]*t%P*inv%P);\n\t\t//}\n\t}\n\t\n\tans =(ans+P)%P;\n\tcout<<ans<<endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvector<int> dzielniki_n;\n\nmap<int, int> palin;\n\nint pot(long long x, long long y){\n    long long wyn = 1;\n    while (y){\n        if (y % 2)\n            wyn = (wyn * x) % mod;\n        y /= 2;\n        x = (x * x) % mod;\n    }\n    return wyn;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    long long wynik = 0;\n    cin >> n >> k;\n    for (int i = 1; i * i <= n; i++)\n        if (n % i == 0){\n            dzielniki_n.push_back(i);\n            if (i * i < n)\n                dzielniki_n.push_back(n / i);\n        }\n    sort(dzielniki_n.begin(), dzielniki_n.end());\n    for (int i : dzielniki_n){\n        int pom = pot(k, (i + 1) / 2);\n        for (int j = 0; dzielniki_n[j] < i; j++)\n            if (!(i % dzielniki_n[j])){\n                pom -= palin[dzielniki_n[j]];\n                if (pom < 0)\n                    pom += mod;\n            }\n        palin[i] = pom;\n        if (i % 2)\n            wynik = (wynik + ((long long)pom * i) % mod) % mod;\n        else\n            wynik = (wynik + ((long long)pom * i / 2) % mod) % mod;\n    }\n    cout << wynik << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 2010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nvector<int> fac;\nint n;\nll k,sum[MAXN];\nvoid get_fac(int x){\n\tfor(int i=1;i*i<=x;i++)\n\t\tif(x%i==0){\n\t\t\tfac.push_back(i);\n\t\t\tif(i*i!=x)\n\t\t\t\tfac.push_back(x/i);\n\t\t}\n\tsort(fac.begin(),fac.end());\n}\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\t\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d%lld\",&n,&k);\n\tget_fac(n);\n\tll ans=0;\n\tfor(int i=0;i<fac.size();i++){\n\t\tsum[i]=fsp(k,(fac[i]+1)/2);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(fac[i]%fac[j]==0){\n\t\t\t\tsum[i]-=sum[j];\n\t\t\t\tsum[i]%=MOD;\n\t\t\t}\n\t\t}\n\t\tif(fac[i]%2)\n\t\t\t(ans+=sum[i]*fac[i]%MOD)%=MOD;\n\t\telse\n\t\t\t(ans+=sum[i]*(fac[i]/2ll)%MOD)%=MOD;\n\t}\n\tPF(\"%lld\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\nconst int SZE = 1e6+1;\n\nLL expo(LL a,LL b){\n\tif(b==0)return 1;\n\tif(b==1)return a;\n\tLL h=expo(a,b/2);\n\th=(h*h)%MOD;\n\tif(b%2)h=(h*a)%MOD;\n\treturn h;\n}\n\nint main(){\n\tLL n,k;\n\tscanf(\"%lld%lld\",&n,&k);\n\tif(n%2){\n\t\tLL h=(n+1)/2;\n\t\tLL ans=((n*expo(k,h)-n*k+k)%MOD+MOD)%MOD;\n\t\tprintf(\"%lld\",ans);\n\t}\n\telse{\n\t\tLL h=n/2;\n\t\tLL ans=((h*expo(k,h)-h*k+k)%MOD+MOD)%MOD;\n\t\tprintf(\"%lld\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define Max(x,y,z) max(x,max(y,z))\n#define Min(x,y,z) min(x,min(y,z))\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define trace1(x)                cerr<<#x<<\": \"<<x<<endl\n#define trace2(x, y)             cerr<<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<<endl\n#define trace3(x, y, z)          cerr<<#x<<\":\" <<x<<\" | \"<<#y<<\": \"<<y<<\" | \"<<#z<<\": \"<<z<<endl\n#define trace4(a, b, c, d)       cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<endl\n#define trace5(a, b, c, d, e)    cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<endl\n#define trace6(a, b, c, d, e, f) cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<<f<<endl\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long, long long> pll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef pair<ll,ll> ii;\ntypedef vector<pair<ll,ll> > vii;\ntypedef vector<long long> vll;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<pair<long long,long long> > vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<ll,pair<ll,ll> > iii;\n#define PI 3.141592653589793\n#define mod (ll)(1000*1000*1000+7)\n//# define N 300005\ntemplate<typename T> T gcd(T a,T b) { if(a==0) return b; return gcd(b%a,a); }\ntemplate<typename T> T pow(T a,T b, ll m){T ans=1; while(b>0){ if(b%2==1) ans=((ans%m)*(a%m))%m; b/=2; a=((a%m)*(a%m))%m; } return ans%m; }\n# define INF (ll)1e18\n# define LN 20  \ntypedef pair<ll,pair<ll,ll> > pii;\n# define INF1 (int)1e9+2\n# define maxn 100006\n# define offset 1005\n\n/*************************************************\nstruct Coupon {\n    ll l;\n    ll r;\n    ll id;\n\n    Coupon(ll l, ll r, ll id): l(l), r(r), id(id) {} // Initialization\n\n    bool operator<(const Coupon& c) { // Sorting\n        return l < c.l;    \n    }\n};\n\n**************************************************/\n\nll dp[3005];\n\nint main()\n{\n  ll n,k;\n  cin >> n >> k;\n  ll ans=0;\n  vi v;\n  for(ll i=1;i*i<=n;i++)\n  {\n     if(n%i==0)\n     {\n        v.pb(i);\n        if((n/i)!=i)\n           v.pb(n/i);\n\n     } \n  }\n\n  sort(v.begin(),v.end());\n\n  for(int i=0;i<v.size();i++)\n  {\n    dp[i]=pow(k,(v[i]+1)/2,mod);\n    for(int j=0;j<i;j++)\n    {\n       if(v[i]%v[j]==0)\n         {\n           dp[i]-=dp[j];\n           dp[i]+=mod;\n           dp[i]%=mod;\n         }\n    }\n    if(v[i]&1)\n     {\n        ans=(ans+(dp[i]*v[i])%mod);\n        ans%=mod;\n     }\n     else\n     {\n       ans=(ans+(dp[i]*(v[i]/2))%mod);\n       ans%=mod;\n     }\n\n  }\n\n  cout << ans;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1500;\nconst int q=1e9+7;\ninline int Plus(int x,int y) {return (x+=y)>=q?x-q:x;}\ninline void Pe(int &x,int y) {x=Plus(x,y);}\ninline int Sub(int x,int y) {return (x-=y)<0?x+q:x;}\ninline void Se(int &x,int y) {x=Sub(x,y);}\ninline int Multi(int x,int y) {return 1ll*x*y%q;}\ninline void Me(int &x,int y) {x=Multi(x,y);}\ninline int mi(int x,int y) {\n\tint ret=1;\n\tfor (;y;y>>=1,Me(x,x)) if (y&1) Me(ret,x);\n\treturn ret;\n}\nint d[maxn],s=0,n,k,f[maxn],ans=0;\nint main() {\n\tcin>>n>>k;\n\tfor (int i=1;i*i<=n;++i) if (n%i==0) {\n\t\td[++s]=i;\n\t\tif (i*i!=n) d[++s]=n/i;\n\t}\n\tsort(d+1,d+s+1);\n\tfor (int i=1;i<=s;++i) {\n\t\tint di=d[i],&fi=f[i]=mi(k,(di+1)/2);\n\t\tfor (int j=1;j<i;++j) if (di%d[j]==0) Se(fi,f[j]);\n\t\tPe(ans,((1ll*fi*di)>>(~di&1))%q);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define vt vector\n#define ii pair<int,int>\n#define mp make_pair\n#define vi vt<int>\n#define vvi vt<vi>\n#define vii vt<ii>\n#define vvii vt<vii>\n#define For(i,a,b) for(int i = a; i < b; i++)\n#define foR(i,a,b) for(int i = a; i <= b; i++)\n#define roF(i,a,b) for(int i = a - 1; i >= b; i--)\n#define Rof(i,a,b) for(int i = a; i >= b; i--)\n#define NEW 0\n#define FOUNDED 1\n#define CHECKED 2\n#define pb push_back\n#define pob pop_back\n#define mset(a,b) memset(a,b,sizeof(a))\n\ntemplate<class T1, class T2> ostream& operator<< (ostream& the, pair<T1, T2> a){\n\tthe << a.first << \"\\t\" << a.second << \"\\n\";\n\treturn the;\n}\ntemplate<class T1> ostream& operator<< (ostream& the, vt<T1> a){\n\tFor(i,0,a.size()) {\n\t\tthe << a[i] << \"\\n\";\n\t}\n\treturn the;\n}\nconst int mod = 1000000007;\nint pr[100000];\nvi prime;\nvi pr_num;\nvi uoc, num;\nint bp(int a, int b){\n\tif(b == 0) return 1;\n\tint t = bp(a,b/2);\n\tif(b%2==0){\n\t\treturn t*t%mod;\n\t}else{\n\t\treturn t*t%mod*a%mod;\n\t}\n}\n\nvoid tim_uoc(int vt, int ht){\n\tif(vt == pr_num.size()){\n\t\tuoc.pb(ht);\n\t\treturn;\n\t}\n\tfoR(i,0,pr_num[vt]){\n\t\ttim_uoc(vt+1,ht*bp(prime[vt],i));\n\t}\n}\n\nsigned main () {\n\n//\tfreopen(\"INP.txt\",\"r\",stdin);\n//\tfreopen(\"OUT.txt\",\"w\",stdout);\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//  ifstream fin(\"in.txt\");\n//  ofstream fout(\"out.txt\");\n//  ifstream dict(\"dict.txt\");\n// \tbon ga nay\n\tint n, k;\n\tcin >> n >> k;\n\tFor(i,2,100000){\n\t\tif(pr[i] == 0){\n\t\t\tprime.pb(i);\n\t\t\tfor(int j = 2*i; j < 100000; j+=i){\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint t = n, coun;\n\tFor(i,0,prime.size()){\n\t\tcoun = 0;\n\t\twhile(t % prime[i] == 0){\n\t\t\tt/=prime[i];\n\t\t\tcoun++;\n\t\t} \n\t\tpr_num.pb(coun);\n\t}\n\ttim_uoc(0,1);\n\tsort(uoc.begin(),uoc.end());\n\tFor(i,0,uoc.size()){\n\t\tint te = bp(k,(uoc[i]+1)/2);\n\t\tFor(j,0,i){\n\t\t\tif(uoc[i]%uoc[j] == 0){\n\t\t\t\tte -= num[j];\n\t\t\t}\n\t\t}\n\t\tnum.pb(te);\n\t}\n\tint tong = 0;\n\tFor(i,0,num.size()){\n\t\ttong = (tong+(num[i]*((uoc[i]%2 == 0)?(uoc[i]/2):uoc[i]))%mod)%mod;\n\t}\n\tif(tong < 0) tong += mod;\n\tcout << tong;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,k,m,ans;\nint a[N],dp[N];\nbool vis[N];\n\ninline int solve(int x){\n\tif(vis[x]) return dp[x];\n\tvis[x]=1;\n\tdp[x]=exp(k,(a[x]+1)/2);\n\tfor(int i=1;i<x;i++)\n\t\tif(a[x]%a[i]==0) ch(dp[x],mod-solve(i));\n\tif(a[x]&1) ch(ans,(ll)dp[x]*a[x]%mod);\n\telse ch(ans,(ll)dp[x]*a[x]/2%mod);\n//\tdprintf(\"%d %d\\n\",a[x],dp[x]);\n\treturn dp[x];\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n,k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\ta[++m]=i;\n\t\t\tif(n/i!=i) a[++m]=n/i;\n\t\t}\n\tsort(a+1,a+m+1);\n\tsolve(m);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<unordered_map>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll pn[105],cnt,n,mod,sigma,a[200005],ans;\nint pp[40]= {9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829};\nll Multi(ll x,ll y,ll p) {\n\tll z=(long double)x/p*y;\n\tll res=(unsigned ll)x*y-(unsigned ll)z*p;\n\treturn (res+p)%p;\n}\nll Power(ll x,ll y,ll z) {\n\tll ret=1;\n\twhile(y) {\n\t\tif(y&1)ret=Multi(ret,x,z);\n\t\tx=Multi(x,x,z),y>>=1;\n\t}\n\treturn ret;\n}\nbool Miller_Rabbin(ll n) {\n\tif(n==2)return 1;\n\tif(n<2)return 0;\n\tll m=n-1;\n\tint k=0;\n\twhile(m%2==0)k++,m/=2;\n\tfor(int i=1; i<=5; i++) {\n\t\tll kk=rand()%(n-1)+1,x=Power(kk,m,n),y=0;\n\t\tfor(int j=1; j<=k; j++) {\n\t\t\ty=Multi(x,x,n);\n\t\t\tif(y==1&&x!=1&&x!=n-1)return 0;\n\t\t\tx=y;\n\t\t}\n\t\tif(y!=1)return 0;\n\t}\n\treturn 1;\n}\ninline ll gcd(ll a,ll b) {\n\tif(b==0)return a;\n\tif(a==0)return b;\n\treturn gcd(b,a%b);\n}\nll ABS(ll x) {\n\treturn x<0?-x:x;\n}\ninline ll Pollard_Rho(ll x,ll c) {\n\tif(!c)c=rand();\n\tll s=0,t=0;\n\tint stp=0,goal=1;\n\tll val=1;\n\tfor(goal=1;; goal<<=1,s=t,val=1) {\n\t\tfor(stp=1; stp<=goal; ++stp) {\n\t\t\tt=(Multi(t,t,x)+c)%x;\n\t\t\tval=Multi(val,ABS(t-s),x);\n\t\t\tif((stp%127)==0) {\n\t\t\t\tll d=gcd(val,x);\n\t\t\t\tif(d>1)return d;\n\t\t\t}\n\t\t}\n\t\tll d=gcd(val,x);\n\t\tif(d>1)return d;\n\t}\n}\nunordered_map<ll,bool> is;\nvoid FindDivisor(ll n) {\n\tif(n==1)return ;\n\tif(Miller_Rabbin(n)) {\n\t\tif(!is[n])pn[++cnt]=n,is[n]=1;\n\t\treturn ;\n\t}\n\tll p=n,x=0;\n\twhile(p>=n)p=Pollard_Rho(n,pp[x++]);\n\twhile(n%p==0)n/=p;\n\tFindDivisor(p),FindDivisor(n);\n}\nunordered_map<ll,ll> t;\nvoid DFS(int now,ll x,ll nowt) {\n\tif(now>cnt)return a[++a[0]]=x,t[x]=nowt,void();\n\tDFS(now+1,x,nowt);\n\tll tmpn=n;\n\twhile(tmpn%pn[now]==0) {\n\t\tDFS(now+1,x*=pn[now],nowt*(1-pn[now]));\n\t\ttmpn/=pn[now];\n\t}\n}\nint main() {\n\tsrand(time(0));\n\tcin>>n>>sigma,mod=1000000007;\n\tFindDivisor(n);\n\tDFS(1,1,1);\n\tfor(int i=1; i<=a[0]; i++) {\n\t\tif(a[i]%2==1&&(n/a[i])%2==0)continue;\n\t\tans=(ans+(a[i]%2?a[i]:a[i]/2)%mod*Power(sigma,(a[i]+1)/2,mod)%mod*(t[n/a[i]]%mod+mod))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nconst int N=2e5+20;\nvector<ll> v;\nll n,k,dp[2500];\nll powmod(ll x,ll n)\n{\n\tll s=1;\n\twhile(n)\n\t{\n\t\tif(n&1)\n\t\t\ts=(s*x)%mod;\n\t\tn>>=1;\n\t\tx=(x*x)%mod;\n\t}\n\treturn s;\n}\nvoid init()\n{\n\tv.clear();\n\tfor(ll i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tif(i*i!=n)\n\t\t\t\tv.push_back(n/i);\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n}\nint main()\n{\n\twhile(cin>>n>>k)\n\t{\n\t\tinit();\n\t\tll ans=0;\n\t\tfor(int x=0;x<v.size();x++)\n\t\t{\n\t\t\tdp[x]=powmod(k,(v[x]+1)/2);\n\t\t\tfor(int y=0;y<x;y++)\n\t\t\t{\n\t\t\t\tif(v[x]%v[y]==0)\n\t\t\t\t\tdp[x]=(dp[x]-dp[y]+mod)%mod;\t\n\t\t\t}\t\n\t\t\tif(v[x]%2)\n\t\t\t\tans=(ans+(dp[x]*v[x])%mod)%mod;\n\t\t\telse\n\t\t\t\tans=(ans+(dp[x]*v[x]/2)%mod)%mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,m,ans,a[5010],cnt,f[5010],p=1e9+7;\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y%2==1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i*i<=n;i++)if(n%i==0){\n\t\ta[++cnt]=i;\n\t\tif(n/i!=i)a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\tfor(i=1;i<=cnt;i++){\n\t\tf[i]=ksm(m,(a[i]+1)/2)%p;\n\t\tfor(j=1;j<i;j++)if(a[i]%a[j]==0)f[i]=(f[i]-f[j]+p)%p;\n\t\tif(a[i]%2==1)ans=(ans+a[i]*f[i]%p)%p;\n\t\t else ans=(ans+a[i]*f[i]%p*ksm(2,p-2)%p)%p;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\n//周期がiの約数の回文数\nint calcnum(int i, int K, int mod){\n    return modpow(K, (i + 1) / 2, mod);\n}\n\nint mebius(int d){\n    int m = 1;\n    int d0 = d;\n    for(int i = 2; i * i <= d; i++){\n        int k = 0;\n        while(d0 % i == 0){\n            k++;\n            d0 /= i;\n        }\n        if(k >= 2) return 0;\n        else if(k == 1) m *= -1;\n    }\n    if(d > 1) return -m;\n    else return m;\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n\n    map<int, int> f, mu;\n    for(int i = 1; i * i <= N; i++){\n        if(N % i == 0){\n            f[i] = calcnum(i, K, mod);\n            f[N / i] = calcnum(N / i, K, mod);\n            mu[i] = mebius(i);\n            mu[N / i] = mebius(N / i);\n        }\n    }\n    int ans = 0;\n    for(auto p: f){\n        int n = p.first;\n        int val = 0;\n        for(auto q: f){\n            int d = q.first;\n            if(n % d == 0){\n                val += mu[n / d] * q.second;\n                val = (val % mod + mod) % mod;\n            }\n        }\n        //g[n] = val;\n        //cout << n << \" \" << val << endl;\n        if(n % 2 == 0) ans += val * (n / 2);\n        else ans += val * n;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint N, K;\nconst int MOD = 1e9 + 7;\nint pw(int x, int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y & 1)res = (ll)res * x % MOD;\n\t\tx = (ll)x * x % MOD;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tscanf(\"%d%d\", &N, &K);\n\tset <int> M;\n\tvector <int> v;\n\tint flag = 1;\n\tif(N % 2 == 0)N /= 2, flag = 0;\n\tM.insert(1); M.insert(N);\n\tfor(int i=2;i*i<=N;i++){\n\t\tif(N % i == 0){\n\t\t\tM.insert(i);\n\t\t\tif(i*i != N)M.insert(N/i);\n\t\t}\n\t}\n\tfor(int e : M)v.pb(e);\n\tll ans = 0;\n\tvector <ll> D;\n\tD.resize(sz(v));\n\tfor(int i=0;i<sz(v);i++){\n\t\tif(flag == 0)D[i] = (D[i] + pw(K, v[i])) % MOD;\n\t\telse D[i] = (D[i] + pw(K, (v[i]+1)/2)) % MOD;\n\t\t//printf(\"%d %lld\\n\", v[i], D[i]);\n\t\tfor(int j=i+1;j<sz(v);j++)if(v[j] % v[i] == 0)D[j] = (D[j] - D[i]) % MOD;\n\t\tans += D[i] * v[i];\n\t\tans %= MOD;\n\t}\n\tif(ans < 0)ans += MOD;\n\tprintf(\"%lld\", ans);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0bd35dc5e428754fa574049b6be8efe0\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\nint n, K;\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>();\n}\n\nvector<int> seq;\nunordered_map<int, vector<int> > fact;\n\ninline void get_fact(int N)\n{\n\tfor(int i = 1; (LL) i * i <= N; ++i) if(N % i == 0)\n\t{\n\t\tseq.push_back(i);\n\t\tif(i != N / i) seq.push_back(N / i);\n\t}\n\n\tsort(ALL(seq));\n\tfor(auto i : seq) for(auto j : seq) if(i % j == 0 && i != j)\n\t\tfact[i].push_back(j);\n}\n\ninline void solve()\n{\n\tget_fact(n);\n\n\tstatic unordered_map<int, int> f;\n\n\tfor(auto i : seq)\n\t{\n\t\tf[i] = fpm(K, (i + 1) / 2);\n\t\tfor(auto d : fact[i]) (f[i] -= f[d]) %= MOD;\n\t}\n\n\tint ans[2] = {0, 0};\n\tfor(auto i : seq) (ans[i & 1] += (LL) f[i] * i % MOD) %= MOD;\n\n\tconst int inv2 = (MOD + 1) / 2;\n\tint res = ((LL) ans[0] * inv2 % MOD + ans[1]) % MOD;\n\tprintf(\"%d\\n\", (res + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\nint n,k,ans;\n\nint qpow(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)res=(long long)res*a%mod;\n\t\ta=(long long)a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tset<int> v;\n\tunordered_map<int,int> s;\n\tfor(int i=1;i*i<=n;++i)\n\t\tif(n%i==0)\n\t\t{\n\t\t\tv.insert(i);\n\t\t\tif(i*i!=n)v.insert(n/i);\n\t\t}\n\tfor(auto x : v)\n\t{\n\t\tint res=qpow(k,(x+1)/2);\n\t\tfor(int i=1;i*i<=x;++i)\n\t\t\tif(x%i==0)\n\t\t\t{\n\t\t\t\tres-=s[i];\n\t\t\t\tif(res<0)res+=mod;\n\t\t\t\tif(i*i!=x)\n\t\t\t\t{\n\t\t\t\t\tres-=s[x/i];\n\t\t\t\t\tif(res<0)res+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\ts[x]=res;\n\t\tans+=(long long)res*(x%2?x:x/2)%mod;\n\t\tif(ans>=mod)ans-=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MOD = 1e9 + 7;\n\nint64_t mpow(int64_t a, int64_t e) {\n    int64_t r = 1, p = a;\n    while (e) {\n        if (e & 1)\n            r = (r * p) % MOD;\n        p = (p * p) % MOD;\n        e >>= 1;\n    }\n    return r;\n}\n\nint64_t cnt[1 << 16];\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector <int> divs;\n    for (int i = 1; i * i <= n; i++)\n        if (n % i == 0) {\n            divs.push_back(i);\n            if (i * i != n)\n                divs.push_back(n / i);\n        }\n    sort(divs.begin(), divs.end());\n\n    int64_t total = 0;\n    for (int i = 0; i < divs.size(); i++) {\n        cnt[i] = mpow(k, (divs[i] + 1) / 2);\n        for (int j = 0; j < i; j++)\n            if (divs[i] % divs[j] == 0)\n                cnt[i] = (cnt[i] - cnt[j] + MOD) % MOD;\n        if (divs[i] % 2)\n            total += cnt[i] * divs[i];\n        else\n            total += cnt[i] * (divs[i] / 2);\n        total %= MOD;\n    }\n    cout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nconst int mod=100000007;\nmap<int,int> M;\nint n,k,ans;\ninline int ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\ninline ll chu(int x){\n\treturn (x&1)?1:((mod+1)>>1);\n}\nint solve(int x){\n\tif(M.count(x))return M[x];\n\tint ans=ksm(k,(x+1)/2);\n\tfor(int i=1;i*i<=x;i++){\n\t\tif(i!=x)ans=(ans-solve(i))%mod;\n\t\tif(i*i!=x&&i!=1)ans=(ans-solve(x/i))%mod;\n\t}\n\tans=(ans+mod)%mod;\n\treturn M[x]=ans;\n}\nint main(){\n\tn=read(); k=read();\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\tans=(ans+solve(i)*chu(i)%mod*i)%mod;\n\t\tif(i*i!=n)ans=(ans+solve(n/i)*chu(n/i)%mod*(n/i))%mod;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  ll n,t;\n  cin>>n>>t;\n  ll re=0;\n  vector<int> fs;\n  for(int i=1;i*i<=n;++i){\n    if(n%i) continue;\n    fs.pb(i);\n    fs.pb(n/i);\n  }\n  sort(all(fs));\n  UNIQUE(fs);\n  //cout<<fs;\n  const int m=fs.size();\n  vector<ll> dec(m);\n  rep(i,m){\n    const int x=fs[i];\n    ll p=modpow(t,(x+1)/2);\n    (p+=MOD-dec[i])%=MOD;\n    reps(j,i+1,m) if(fs[j]%x==0) (dec[j]+=p)%=MOD;\n    (re+=p*(x%2?x:x/2)%MOD)%=MOD;\n  }\n  cout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define vt vector\n#define ii pair<int,int>\n#define mp make_pair\n#define vi vt<int>\n#define vvi vt<vi>\n#define vii vt<ii>\n#define vvii vt<vii>\n#define For(i,a,b) for(int i = a; i < b; i++)\n#define foR(i,a,b) for(int i = a; i <= b; i++)\n#define roF(i,a,b) for(int i = a - 1; i >= b; i--)\n#define Rof(i,a,b) for(int i = a; i >= b; i--)\n#define NEW 0\n#define FOUNDED 1\n#define CHECKED 2\n#define pb push_back\n#define pob pop_back\n#define mset(a,b) memset(a,b,sizeof(a))\n\ntemplate<class T1, class T2> ostream& operator<< (ostream& the, pair<T1, T2> a){\n\tthe << a.first << \"\\t\" << a.second << \"\\n\";\n\treturn the;\n}\ntemplate<class T1> ostream& operator<< (ostream& the, vt<T1> a){\n\tFor(i,0,a.size()) {\n\t\tthe << a[i] << \"\\n\";\n\t}\n\treturn the;\n}\nconst int mod = 1000000007;\nint pr[100000];\nvi prime;\nvi pr_num;\nvi uoc, num;\nint bp(int a, int b){\n\tif(b == 0) return 1;\n\tint t = bp(a,b/2);\n\tif(b%2==0){\n\t\treturn t*t%mod;\n\t}else{\n\t\treturn t*t%mod*a%mod;\n\t}\n}\n\nvoid tim_uoc(int vt, int ht){\n\tif(vt == pr_num.size()){\n\t\tuoc.pb(ht);\n\t\treturn;\n\t}\n\tfoR(i,0,pr_num[vt]){\n\t\ttim_uoc(vt+1,ht*bp(prime[vt],i));\n\t}\n}\n\nsigned main () {\n\n//\tfreopen(\"INP.txt\",\"r\",stdin);\n//\tfreopen(\"OUT.txt\",\"w\",stdout);\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//  ifstream fin(\"in.txt\");\n//  ofstream fout(\"out.txt\");\n//  ifstream dict(\"dict.txt\");\n// \tbon ga nay\n\tint n, k;\n\tcin >> n >> k;\n\tFor(i,2,100000){\n\t\tif(pr[i] == 0){\n\t\t\tprime.pb(i);\n\t\t\tfor(int j = 2*i; j < 100000; j+=i){\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint t = n, coun;\n\tFor(i,0,prime.size()){\n\t\tcoun = 0;\n\t\twhile(t % prime[i] == 0){\n\t\t\tt/=prime[i];\n\t\t\tcoun++;\n\t\t} \n\t\tpr_num.pb(coun);\n\t}\n\ttim_uoc(0,1);\n\tsort(uoc.begin(),uoc.end());\n\tFor(i,0,uoc.size()){\n\t\tint te = bp(k,(uoc[i]+1)/2);\n\t\tFor(j,0,i){\n\t\t\tif(uoc[i]%uoc[j] == 0){\n\t\t\t\tte -= num[j];\n\t\t\t}\n\t\t}\n\t\tnum.pb(te);\n\t}\n\tint tong = 0;\n\tFor(i,0,num.size()){\n\t\ttong = (tong+num[i]*((uoc[i]%2 == 0)?(uoc[i]/2):uoc[i]))%mod;\n\t}\n\tif(tong < 0) tong += mod;\n\tcout << tong;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { cout << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\ntypedef pair<LL,LL> LP;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\t\n}\n\nconst LL mod = 1e9+7;\n\nlong long modpow(long long a, long long b, long long modd = mod){\n\ta %= modd;\n\tif(a == 0) return 0;\n\tlong long res = 1;\n\twhile(b != 0){\n\t\tif(b&1) res = res*a%modd;\n\t\ta = a*a%modd;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tios_init();\n\tLL n,k;\n\twhile(cin >> n >> k){\n\t\tLL h = (n+1)/2;\n\t\tLL ans;\n\t\tif(n%2 == 0) ans = ((k+(modpow(k,h)-k)*h%mod)%mod+mod)%mod;\n\t\telse ans = ((k+(modpow(k,h)-k)*n%mod)%mod+mod)%mod;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*\n#define trav(a, v) for(auto& a : v)\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n*/\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k,r;\n\n\nll mob(ll i){\n    if(i == 1)return 1;\n    for(ll c1 = 2; c1*c1 <= i; c1++){\n\n        if(i % c1 == 0){\n\n            if(i % (c1*c1) == 0)return 0;\n            return (-1) * mob(i / c1);\n        }\n    }\n return -1;\n}\n\n\nll ans = 0;\n\n ll upp(ll i, ll j){\n\n if(j == 0)return 1;\n\n if(j%2 == 0){\n    ll h = upp(i,j/2);\n    return (h*h)%big;\n\n }\n return (i*upp(i,j-1))%big;\n }\n\n\nll g(ll i){\n    ll a = mob(n/i) * upp(k, (i+1)/2);\n    a += big;\n    a %= big;\n    if(i % 2 == 0){a *= i/2;}\n    else{\n        a *= i;\n    }\n    a%=big;\n    return a;\n}\n\n\n\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll c1,c2,c3,c4,c5,c6;\n    ll a,b,c,e;\n    ll x;\n\n    cin >> n >> k;\n\n\n    for(ll c1 = 1; c1*c1 <= n; c1++){\n\n        if(n%c1 == 0){\n            ans += g(c1);\n            ans += big;\n            ans %= big;\n\n            if(c1*c1 != n){\n\n                ans += g(n/c1);\n                ans += big;\n                ans %= big;\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define mo 1000000007\n#define LL long long\nusing namespace std;\nLL ksm(LL k,LL n)\n{\n\tLL s=1;\n\tfor(;n;n>>=1,k=k*k%mo) if(n&1) s=s*k%mo;\n\treturn s;\n}\nint pi[100005];\nLL f[100005];\nint main()\n{\n\tLL n,m;\n\tcin>>n>>m;\n\tfo(i,1,sqrt(n)) \n\t{\n\t\tif(n%i==0) \n\t\t{\n\t\t\tpi[++pi[0]]=i;\n\t\t\tif(n%(n/i)==0&&n/i!=i) pi[++pi[0]]=n/i;\n\t\t}\n\t}\n\tLL ans=0;\n\tsort(pi+1,pi+pi[0]+1);\n\tfo(i,1,pi[0])\n\t{\n\t\tif(n/pi[i]%2==0)\n\t\t{\n\t\t\tf[i]=ksm(m,pi[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf[i]=ksm(m,(pi[i]+1)/2);\n\t\t}\n\t\tfo(j,1,i-1) if(pi[i]%pi[j]==0) f[i]=(f[i]-f[j]+mo)%mo;\n\t\tans=(ans+f[i]*pi[i])%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,K,M;\nll mo=1000000007;\nvector<ll> V;\nll dp[2020];\n\nll modpow(ll a, ll n = mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nvector<ll> enumdiv(ll n) {\n\tvector<ll> S;\n\tfor(ll i=1;i*i<=n;i++) if(n%i==0) {S.push_back(i); if(i*i!=n) S.push_back(n/i); }\n\tsort(S.begin(),S.end());\n\treturn S;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K;\n\t\n\tV=enumdiv(N);\n\tM=V.size();\n\t\n\tll ret=0;\n\tFOR(x,M) {\n\t\tdp[x] = modpow(K,(V[x]+1)/2);\n\t\tFOR(y,x) if(V[x]%V[y]==0) dp[x] += mo - dp[y];\n\t\tdp[x] %= mo;\n\t\t\n\t\tif(V[x]%2==0) {\n\t\t\tret += dp[x]*V[x]/2;\n\t\t}\n\t\telse {\n\t\t\tret += dp[x]*V[x];\n\t\t}\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\n#define pb push_back\n#define reset(a,b) memset(a,b,sizeof a);\n#define ALL(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sz(x) (int)(x.size())\n#define lt(x) (int)(x.length())\n#define MOD 1000000007 \n#define mx 100003\n\nint n;\nmap<int, int> jaw, banyak;\n\nbool is_prime(int now){\n\tif(now == 1)\n\t\treturn false;\n\tfor(int i = 2; i * i <= now; i++){\n\t\tif(now % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvector<int> prima;\n\nint berapa(int x){\n\t// debug(x);\n\tint cnt = 1;\n\tfor(int i : prima){\n\t\t// debug(i);\n\t\tint hit = 0;\n\t\twhile(x % i == 0){\n\t\t\tx /= i;\n\t\t\thit += 1;\n\t\t}\n\t\tif(hit > 1)\n\t\t\treturn 0;\n\t\tif(hit == 1)\n\t\t\tcnt *= -1;\n\t}\n\treturn cnt;\n}\n\nlong long POW(long long a, int b){\n\tlong long ret = 1;\n\twhile(b > 0){\n\t\tif(b & 1)\n\t\t\tret = ret * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint k;\n\tset<int> faktor;\n\tcin >> n >> k;\n\tfor(int i = 1; i * i <= n; i++){\n\t\tif(n % i == 0){\n\t\t\tfaktor.insert(i);\n\t\t\tfaktor.insert(n / i);\n\t\t}\n\t}\n\tfor(int i : faktor){\n\t\tif(is_prime(i))\n\t\t\tprima.pb(i);\n\t}\n\tif(n & 1){\n\t\tfor(int i : faktor){\n\t\t\tbanyak[i] = POW(k, (i / 2) + 1);\n\t\t}\n\t\tfor(auto it = faktor.rbegin(); it != faktor.rend(); it++){\n\t\t\tint i = *it;\n\t\t\t// debug(i);\n\t\t\tfor(int x : faktor){\n\t\t\t\tif(i % x > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// debug(x);\n\t\t\t\tint coef = berapa(i / x);\n\t\t\t\tjaw[i] += banyak[x] * coef;\n\t\t\t\tjaw[i] %= MOD;\n\t\t\t\tif(jaw[i] < 0)\n\t\t\t\t\tjaw[i] += MOD;\n\t\t\t\t// debug(x);\n\t\t\t}\n\t\t}\n\t\t// cin >> k;\n\t\tlong long ans = 0;\n\t\t// for(auto i : jaw){\n\t\t\t// ans = ans + POW(k, (i.f + 1) / 2) * i.s % MOD;\n\t\t// }\n\t\t// cout << ans << endl;\n\t\tfor(auto i : jaw){\n\t\t\tans = (ans + 1LL * i.f * i.s) % MOD;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\telse{\n\t\tfor(int i : faktor){\n\t\t\tbanyak[i] = POW(k, __gcd(i, n / 2));\n\t\t}\n\t\tfor(int i : faktor){\n\t\t\t// int i = *it;\n\t\t\t// debug(i);\n\t\t\tfor(int x : faktor){\n\t\t\t\tif(i % x > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t// debug(x);\n\t\t\t\tint coef = berapa(i / x);\n\t\t\t\tjaw[i] += banyak[x] * coef;\n\t\t\t\tjaw[i] %= MOD;\n\t\t\t\tif(jaw[i] < 0)\n\t\t\t\t\tjaw[i] += MOD;\n\t\t\t\t// debug(x);\n\t\t\t}\n\t\t}\n\t\t// cin >> k;\n\t\tlong long ans = 0;\n\t\tfor(auto i : jaw){\n\t\t\tans = (ans + 1LL * i.f * i.s % MOD) % MOD;\n\t\t\t// cout << i.f << ' ' << i.s << endl;\n\t\t\t// debug(ans);\n\t\t}\n\t\tcout << ans << endl;\n\t\t// for(auto i : jaw)\n\t}\n}\n// 1 1 1 ->  1\n// 1 2 1 -> 2 1 1 -> 1 1 2 -> 3\n// 2 1 2 -> 1 2 2 -> 2 2 1 -> 3\n// 2 2 2 -> 1\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <deque>\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nvector <int> dv;\nvector <ll> dp;\n\nll mpow(ll n,ll t)\n{\n\tif(t==0) return 1LL;\n\tll ret=mpow(n,t/2);\n\tret=ret*ret%MOD;\n\tif(t%2==1) ret=ret*n%MOD;\n\treturn ret;\n}\nint main()\n{\n\tint n,k;\n\tscanf(\"%d %d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tdv.push_back(i);\n\t\t\tif(i<n/i) dv.push_back(n/i);\n\t\t}\n\t}\n\tsort(dv.begin(),dv.end());\n\tdp.resize(dv.size());\n\tll ret=0;\n\tfor(int i=0;i<dv.size();i++)\n\t{\n\t\tdp[i]=mpow(k,(dv[i]+1)/2);\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tif(dv[i]%dv[j]==0)\n\t\t\t{\n\t\t\t\tdp[i]-=dp[j];\n\t\t\t\tif(dp[i]<0) dp[i]+=MOD;\n\t\t\t}\n\t\t}\n\t\tret+=dp[i]*(ll) (dv[i]%2==1?dv[i]:dv[i]/2)%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\ntypedef pair<pll, pll> P;\nconst ll INF = 1ll<<60;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nint main() {\n\tll N, K; cin >> N >> K;\n\t\n\tvector<int> d;\n\tfor (ll i = 1; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\td.push_back(i);\n\t\t\tif (i * i != N) d.push_back(N / i);\n\t\t}\n\t}\n\tsort(ALL(d));\n\t\n\tmap<int, int> cnt;\n\tREP(i, d.size()) {\n\t\tll now = mod_pow(K, (d[i] + 1) / 2, MOD);\n\t\tfor (ll j = 2; j * j <= d[i]; j++) {\n\t\t\tif (d[i] % j == 0) {\n\t\t\t\tnow = (now - cnt[j] + MOD) % MOD;\n\t\t\t\tif (j * j != d[i]) now = (now - cnt[d[i] / j] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\tcnt[d[i]] = now;\n\t}\n\t\n\tll ans = (-K + MOD) % MOD;\n\tREP(i, d.size()) {\n\t\tif (d[i] & 1) ans = (ans + (ll)cnt[d[i]] * d[i] % MOD) % MOD;\n\t\telse ans = (ans + (ll)cnt[d[i]] * (d[i] / 2) % MOD) % MOD;\n\t}\n\tif (N == 1) ans = K;\n\tcout << ans << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\ntemplate <typename ITR>\nbool next_value(int base, ITR bg, ITR ed) {\n\tint c = 1;\n\tfor (; bg != ed && c == 1; ++bg) {\n\t\t(*bg) += c;\n\t\tif ((c = ((*bg) == base)))(*bg) = 0;\n\t}\n\treturn !c;\n}\n\nvoid rot(vector<int> &v) {\n\tint n = v.size();\n\tfor (int i : range(n - 1)) {\n\t\tswap(v[i], v[i + 1]);\n\t}\n}\nLL naive(LL N,LL K) {\n\tset<vector<int>> s;\n\tvector<int> v(N, 0);\n\tdo {\n\t\tauto u = v;\n\t\treverse(ALL(u));\n\t\tbool ok = true;\n\t\tfor (int i : range((int)N)) {\n\t\t\tif (v[i]!=u[i]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif(ok)for (int i : range((int)N)) {\n\t\t\ts.insert(u);\n\t\t\trot(u);\n\t\t}\n\t} while (next_value(K, ALL(v)));\n\treturn s.size();\n}\n\n\nnamespace testcase {\n\n\tconstexpr int LIM = 8;\n\tLL N, K;\n\tLL in[2] = { 7ll,1ll };\n\tbool generate() {\n\t\tN = in[0] + 1;\n\t\tK = in[1] + 1;\n\t\tbool ret = next_value(LIM, in, in + 2);\n\t\treturn ret;\n\t}\n\tbool input() {\n\t\tDEBUG{\n\t\t\treturn generate();\n\t\t}\n\t\telse {\n\t\t\treturn !!(cin >> N >> K);\n\t\t}\n\t}\n\n\tvoid output(LL ret) {\n\t\tDEBUG{\n\t\t\t\tcout << N << \" \" << K;\n\t\t\t\tLL expected_answer = naive(N, K);\n\t\t\t\tif (ret == expected_answer) {\n\t\t\t\t\tcout << \": OK(\" << ret << \")\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \": NG\" << endl;\n\t\t\t\t\tcout << \" expected:\" << expected_answer << endl;\n\t\t\t\t\tcout << \" received:\" << ret << endl;\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcout << ret << endl;\n\t\t}\n\t}\n}\n\nconstexpr int mod = 1e9 + 7;\nLL divisor[112345];\nLL dp[112345];\nLL pow_mod(LL a, LL n, int M = mod) {\n\tLL res = 1;\n\ta %= M;\n\twhile (n) {\n\t\tif (n & 1)\n\t\t\tres = (res*a) % M;\n\t\ta = (a*a) % M;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ninline LL invMod(LL a, LL m = mod) {\n\tLL b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tLL t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n\nLL solve() {\n\tLL N = testcase::N;\n\tLL K = testcase::K;\n\tint m = 0;\n\tfor (LL d = 1; d*d <= N; d++) {\n\t\tif (N%d == 0) {\n\t\t\tdivisor[m++] = d;\n\t\t\tdivisor[m++] = N / d;\n\t\t}\n\t}\n\tsort(divisor, divisor + m);\n\tm = unique(divisor, divisor + m) - divisor;\n\tLL i2 = invMod(2);\n\tfor (int i : range(m)) {\n\t\tconst LL len = divisor[i] / 2;\n\t\tLL& latte = dp[i];\n\t\tif (divisor[i] % 2 == 0) {\n\t\t\tlatte = pow_mod(K, len) * divisor[i] % mod;\n\t\t}\n\t\telse {\n\t\t\tlatte = pow_mod(K, len + 1) * divisor[i] % mod;\n\t\t}\n\t\tfor(int j:range(i)){\n\t\t\tif (divisor[i] % divisor[j] == 0) {\n\t\t\t\tLL malta = divisor[i] / divisor[j];\n\t\t\t\tlatte += mod - dp[j] * malta % mod;\n\t\t\t}\n\t\t}\n\t\tlatte %= mod;\n\t}\n\tLL ret = 0;\n\tfor (int i : range(m)) {\n\t\tLL x = 1;\n\t\tif (divisor[i] % 2 == 0)x = i2;\n\t\tret += dp[i]*x%mod;\n\t}\n\treturn ret%mod;\n}\nint main() {\n\twhile (testcase::input()) {\n\t\tLL ret = solve();\n\t\ttestcase::output(ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int P=1000000007;\n\ninline int pow(int a,int b)\n{\n\tint r=1;\n\tfor(;b;b>>=1,a=(ll)a*a%P)\n\t\tif(b&1)r=(ll)r*a%P;\n\treturn r;\n}\n\nint n,k;\nstd::vector<int>p,v;\n\ninline int g(int v)\n{\n\treturn v&1?v:v/2;\n}\n\ninline int c(int v)\n{\n\treturn pow(k,(v+1)/2);\n}\n\nint main()\n{\n\tin,n,k;\n\tfor(int i=1;i*i<=n;i++)if(n%i==0)\n\t{\n\t\tp.pb(i);\n\t\tif(i*i!=n)p.pb(n/i);\n\t}\n\tstd::sort(p.begin(),p.end());\n\tint m=p.size(),ans=0;\n\tfo0(i,m)\n\t{\n\t\tint t=c(p[i]);\n\t\tfo0(j,i)if(p[i]%p[j]==0)t=(t+P-v[j])%P;\n\t\tv.pb(t);\n\t\tans=(ans+(ll)t*g(p[i]))%P;\n\t}\n\tout,ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  /*bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };*/\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[100031];\nint l[3331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[3331];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v;\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(long long x,long long y)\n{\n  long long p=1;\n  for(;y;y/=2,x*=x,x%=mod)\n  if(y%2)\n  {\n    p*=x;\n    p%=mod;\n  }\n  return p;\n}\n\nint main()\n{\n  scanf(\"%d %d\",&a,&b);\n  for(int i=1;i*i<=a;i++)\n  if(a%i==0)\n  {\n    v.push_back(i);\n    if(a/i!=i) v.push_back(a/i);\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<v.size();i++)\n  {\n    p[v[i]]=i;\n    //printf(\"%d \",v[i]);\n  }\n  for(int h=(int)v.size()-1;h>=0;h--)\n  {\n    long long s=a/v[h];\n    o[h]+=f(b,s/2+s%2);\n    o[h]%=mod;\n    if(s%2) x+=o[h]*s%mod;\n    else x+=o[h]*(s/2)%mod;\n    x%=mod;\n    for(int i=0;i<h&&(long long)v[i]*v[i]<=v[h];i++)\n    if(v[h]%v[i]==0)\n    {\n      o[i]=(o[i]-o[h]+mod)%mod;\n      if(v[h]/v[i]>v[i]&&v[i]>1) o[p[v[h]/v[i]]]=(o[p[v[h]/v[i]]]-o[h]+mod)%mod;\n    }\n    //printf(\"%lld %lld %lld\\n\",o[h],s,x);\n  }\n  printf(\"%lld\",x);\n}\n//2\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=nn/i) v.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tadd(ans,1ll*d[i]*x%MOD);\n\t}\n\tif(n%2==1){\n\t\tans=3ll*ans*m%MOD;\n\t\tadd(ans,-2ll*m%MOD);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*\n#define trav(a, v) for(auto& a : v)\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n*/\n\ntypedef long long ll;\ntypedef long double ld;\n\nll big = 1000000007ll;\nll n,m,k,r;\n\n\nll mob(ll i){\n    if(i == 1)return 1;\n    for(ll c1 = 2; c1*c1 <= i; c1++){\n\n        if(i % c1 == 0){\n\n            if(i % (c1*c1) == 0)return 0;\n            return (-1) * mob(i / c1);\n        }\n    }\n return -1;\n}\n\n\nll ans = 0;\n\n ll upp(ll i, ll j){\n\n if(j == 0)return 1;\n\n if(j%2 == 0){\n    ll h = upp(i,j/2);\n    return (h*h)%big;\n\n }\n return (i*upp(i,j-1))%big;\n }\n\n\nll g(ll i, ll m){\n    ll a = mob(m/i) * upp(k, (i+1)/2);\n    a += big;\n    a %= big;\n    //if(i % 2 == 0){a *= i/2;}\n  //  else{\n  //      a *= i;\n  //  }\n   // a%=big;\n\n   // cout << i << \" \" << a << \"\\n\";\n\n    return a;\n}\n\n\n\nll g2(ll i){\nll ans = 0;\nfor(ll c1 = 1; c1*c1 <= i; c1++){\n    if(i % c1 == 0){\n        ans += g(c1,i);\n        if((c1*c1) != i){\n            ans += g(i/c1,i);\n        }\n        ans %= big;\n    }\n}\n\n//cout << i << \" \" << ans << \"\\n\";\nreturn ans;\n}\n\n\nint main()\n{\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll c1,c2,c3,c4,c5,c6;\n    ll a,b,c,e;\n    ll x;\n\n    cin >> n >> k;\n\n\n    for(ll c1 = 1; c1*c1 <= n; c1++){\n\n        if(n%c1 == 0){\n            a = 1;\n            if(c1 % 2 == 0){a = c1/2;}\n            else{a = c1;}\n            ans += a*g2(c1);\n            ans += big;\n            ans %= big;\n\n            if(c1*c1 != n){\n                if(n/c1 % 2 == 0){a = (n/c1)/2;}\n                else{a = n/c1;}\n                ans += a*g2(n/c1);\n                ans += big;\n                ans %= big;\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2005,Mod=1e9+7;\nint v[N],f[N];\ninline int qpow(int a,int b){\n\tint ans=1;\n\twhile (b){\n\t\tif (b&1) ans=1ll*ans*a%Mod;\n\t\ta=1ll*a*a%Mod,b>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n    int n,k,tot=0,ans=0;\n    scanf (\"%d%d\",&n,&k);\n    for (int i=1; i*i<=n; i++)\n        if (n%i==0) {\n\t\t\tv[++tot]=i;\n\t\t\tif (i*i!=n) v[++tot]=n/i;\n\t\t}\n    sort(v+1,v+tot+1);\n    for (int i=1; i<=tot; i++){\n        f[i]=qpow(k,(v[i]+1)/2);\n        for (int j=1; j<i; j++) if (v[i]%v[j]==0) f[i]=(f[i]-f[j]+Mod)%Mod;\n        if (v[i]&1) ans=(1ll*ans+1ll*v[i]*f[i]%Mod)%Mod;\n        else ans=(1ll*ans+1ll*(v[i]/2)*f[i]%Mod)%Mod;\n    }\n    printf (\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n\nll Pmod(int n,int k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n\nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=0;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(tmp+v[j].second*v[i].first/v[j].first)%mod;\n\t\t\t}\n\t\t}\n\t\tll tmq=(x*Pmod(x/2,k)-tmp+mod)%mod;\n\t\t//cout<<tmp<<\" \"<<tmq<<endl;\n\t\tv[i].second=tmq;\n\t\tans[x%2]+=tmq;\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll po (ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nll ad(ll a, ll b) { return (a+b)%MOD; }\nll sub(ll a, ll b) { return (a-b+MOD)%MOD; }\nll mul(ll a, ll b) { return a*b%MOD; }\n\nint N,K;\nmap<int,int> num;\nvi divi;\n\nll solve() {\n    ll ans = 0;\n    for (int i: divi) {\n        num[i] = po(K,(i+1)/2);\n        for (int j: divi) if (i % j == 0 && j != i) num[i] = sub(num[i],num[j]); \n        if (i&1) ans = ad(ans,mul(i,num[i]));\n        else ans = ad(ans,mul(i/2,num[i]));\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> K;\n    for (int i = 1; i*i <= N; ++i) {\n        if (N % i == 0) {\n            divi.pb(i);\n            divi.pb(N/i);\n        }\n    }\n    sort(all(divi)); divi.erase(unique(all(divi)),divi.end());\n    cout << solve();\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 5005;\nconst int mod = 1e9 + 7;\n\nint n, m, tot, ans, a[MAXN], f[MAXN];\n\ninline int Qow(int x, int y)\n{\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % mod)\n\t\tif (y & 1)\n\t\t\tr = 1LL * r * x % mod;\n\treturn r;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read();\n\tfor (int i = 1; i * i <= n; i ++)\n\t\tif (n % i == 0)\n\t\t{\n\t\t\ta[++ tot] = i;\n\t\t\tif (i * i < n)\n\t\t\t\ta[++ tot] = n / i;\n\t\t}\n\tsort(a + 1, a + tot + 1);\n\tfor (int i = 1; i <= tot; i ++)\n\t{\n\t\tf[i] = Qow(m, a[i] + 1 >> 1);\n\t\tfor (int j = 1; j < i; j ++)\n\t\t\tif (a[i] % a[j] == 0)\n\t\t\t\tf[i] = (f[i] - f[j] + mod) % mod;\n\t\tans = (1LL * f[i] * (a[i] & 1 ? a[i] : a[i] >> 1) + ans) % mod;\n\t}\n\treturn printf(\"%d\\n\", ans), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MOD=1000000007;\nint mypow(int x,int n) { int ret=1; while(true) { if(n&1) ret=(ll)ret*x%MOD; if((n>>=1)==0) return ret; x=(ll)x*x%MOD; } }\n\n\nint len,mxval;\n\nvoid run() {\n\tscanf(\"%d%d\",&len,&mxval);\n\n\tvector<int> dv;\tfor(int i=1;i*i<=len;++i) if(len%i==0) { dv.PB(i); if(i*i<len) dv.PB(len/i); } sort(dv.begin(),dv.end());\n\tint ndv=SZ(dv);\n\tvector<int> ways(ndv);\n\tREP(i,ndv) {\n\t\tways[i]=mypow(mxval,(dv[i]+1)/2);\n\t\tREP(j,i) if(dv[i]%dv[j]==0) ways[i]=(ways[i]+MOD-ways[j])%MOD;\n\t}\n\tint ret=0;\n\tREP(i,ndv) {\n\t\tint times=dv[i]%2==0?dv[i]/2:dv[i];\n\t\t//printf(\"%d: %d*%d\\n\",dv[i],times,ways[i]);\n\t\tret=(ret+(ll)times*ways[i])%MOD;\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=10005,mod=1000000007;\nint n,k,prm[N],c[N],a[N],tot;\ntypedef long long LL;\nLL ret,ans;\n\nLL getmi(LL a,LL x)\n{\n\tLL rt=1;\n\twhile(x)\n\t{\n\t\tif(x&1) rt=rt*a%mod;\n\t\ta=a*a%mod,x>>=1;\n\t}\n\treturn rt;\n}\n\nvoid dfs2(int x,int d,int val)\n{\n\tif(x>tot)\n\t{\n\t\tif(d&1) ret=(ret+d*getmi(k,(d/val+1)/2))%mod;\n\t\telse ret=(ret+d/2*getmi(k,(d/val+1)/2))%mod;\n\t\treturn;\n\t}\n\tint nw=a[x]?prm[x]:1;\n\trep(i,a[x],c[x]) dfs2(x+1,d*nw,val),nw*=prm[x];\n}\n\nvoid dfs1(int x,int mu,int val)\n{\n\tif(x>tot)\n\t{\n\t\tret=0,dfs2(1,1,val);\n\t\tans=(ans+mu*ret)%mod;\n\t\treturn;\n\t}\n\ta[x]=0,dfs1(x+1,mu,val);\n\ta[x]=1,dfs1(x+1,-mu,val*prm[x]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tint x=n,lim=sqrt(n);\n\trep(i,2,lim) if(x%i==0)\n\t{\n\t\tprm[++tot]=i;\n\t\twhile(x%i==0) x/=i,++c[tot];\n\t}\n\tif(x>1) prm[++tot]=x,c[tot]=1;\n\tdfs1(1,1,1);\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = (int) 1e6 + 6, mod = (int) 1e9 + 7;\nint dp[N];\nint pw(int a, int b) { return b != 0? pw(a * 1ll * a % mod, b >> 1) * 1ll * (b & 1? a: 1) % mod: 1; }\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    vector<int> d;\n    for (int i = 1; i * i <= n; ++i)\n        if (n % i == 0) {\n            d.push_back(i);\n            if (i * i != n)\n                d.push_back(n / i);\n        }\n    sort(d.begin(), d.end());\n    long long res = 0;\n    for (int j = 0; j < (int) d.size(); ++j) {\n        int x = d[j];\n        int g = (x / 2) + (x % 2);\n        dp[j] = pw(k, g);\n        for (int l = 0; l < j; ++l) if (x % d[l] == 0) {\n            dp[j] = (dp[j] - dp[l] + mod) % mod;\n        }\n        res = (res + dp[j] * 1ll * (x & 1? x: g)) % mod;\n    }\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nll n, k;\n\nll mod_pow(ll x, ll t) {\n    ll res = 1;\n    while (t > 0) {\n        if (t & 1) res = (res * x) % mod;\n        x = (x * x) % mod;\n        t >>= 1;\n    }\n    return res;\n}\n\nvector<ll> divisor(ll n) {\n    vector<ll> res;\n    for (ll i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            res.push_back(i);\n            if (i != n/i) res.push_back(n/i);\n        }\n    }\n    return res;\n}\n\nll solve() {\n    vector<ll> d = divisor(n);\n    sort(ALL(d));\n    int l = d.size();\n    ll num[l];\n    for (int i = 0; i < l; i++) {\n        num[i] = mod_pow(k, d[i]/2+(d[i]%2));\n        for (int j = 0; j < i; j++) {\n            if (d[i] % d[j] == 0) {\n                num[i] = (num[i] - num[j] + mod) % mod;\n            }\n        }\n    }\n\n    ll res = 0;\n    for (int i = 0; i < l; i++) {\n        res = (res + num[i] * (d[i]%2==0?d[i]/2:d[i]) % mod) % mod;\n    }\n    return res;\n}\n\nvoid input() {\n    cin >> n >> k;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ll sig(ll x){\n//    int ans = 1;\n//    for(ll i = 2; i*i <= x; ++i){\n//        if(x%(i*i)==0)\n//            return 0;\n//        if(x%i == 0){\n//            x /= i;\n//            ans *= -1;\n//        }\n//    }\n//    if(x > 1)\n//        ans *= -1;\n//    return ans;\n//}\n//void __(){\n//    ll n,k;\n//    cin >> n >> k;\n//    if(n%2 == 1){\n//        ll ans = ipow(k,n/2+1)*n%MOD;\n//        ans -= k*(n-1);\n//        ans += MOD;\n//        print ans % MOD;\n//        return;\n//    }\n//    n /= 2;\n//    vl divs;\n//    for(ll i = 1; i*i <= n; ++i){\n//        if(n%i == 0){\n//            divs.pb(i);\n//            if(i*i < n)\n//                divs.pb(n/i);\n//        }\n//    }\n//    sort(rall(divs));\n//    ll ans = 0;\n//    for(int x : divs){\n//        ll ways = 0;\n//        for(int y : divs){\n//            if(x%y == 0){\n//                ways += sig(x/y)*ipow(k,y);\n//            }\n//        }\n//        ways %= MOD;\n//        ans += ways*x%MOD;\n//    }\n//    ans = (ans%MOD+MOD)%MOD;\n//    print ans;\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nll ipow(ll x, ll p, ll mod = MOD){\n    if(abs(x) >= mod)\n        x %= mod;\n    if(x < 0)\n        x += mod;\n    if(p == 0)\n        return 1;\n    if(p == 1)\n        return x;\n    return ipow(x * x % mod, p / 2, mod) * ipow(x, p % 2, mod) % mod;\n}\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout) \n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\nll sig(ll x){\n    int ans = 1;\n    for(ll i = 2; i*i <= x; ++i){\n        if(x%(i*i)==0)\n            return 0;\n        if(x%i == 0){\n            x /= i;\n            ans *= -1;\n        }\n    }\n    if(x > 1)\n        ans *= -1;\n    return ans;\n}\nvoid __(){\n    ll n,k;\n    cin >> n >> k;\n    if(n%2 == 1){\n        ll ans = ipow(k,n/2+1)*n%MOD;\n        ans -= k*(n-1);\n        ans += MOD;\n        print ans % MOD;\n        return;\n    }\n    n /= 2;\n    vl divs;\n    for(ll i = 1; i*i <= n; ++i){\n        if(n%i == 0){\n            divs.pb(i);\n            if(i*i < n)\n                divs.pb(n/i);\n        }\n    }\n    sort(rall(divs));\n    ll ans = 0;\n    for(int x : divs){\n        ll ways = 0;\n        for(int y : divs){\n            if(x%y == 0){\n                ways += sig(x/y)*ipow(k,y);\n            }\n        }\n        ways %= MOD;\n        ans += ways*x%MOD;\n    }\n    ans = (ans%MOD+MOD)%MOD;\n    print ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 1) {\n\t\tcout << modpow(k, (n + 1) / 2) << endl;\n\t\treturn 0;\n\t}\n\tn /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tmp[i] = modpow(k, i);\n\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tif (cnt > mod) cnt -= mod;\n\t\t\t\tif (cnt < 0) cnt += mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int,int> pii;\n\nconst int mod=1e9+7;\ninline int add(int x,int y) {return (x+y>=mod) ? (x+y-mod) : (x+y);}\ninline int dec(int x,int y) {return (x-y<0) ? (x-y+mod) : (x-y);}\ninline int mul(int x,int y) {return (long long)x*y%mod;}\ninline int power(int a,int b,int rs=1) {for(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a); return rs;}\n\nconst int N=1e5+50;\nint n,k;\n#define div divc\nvector <int> div;\nint g[N];\nint main() {\n\tcin>>n>>k; k%=mod;\n\tdiv.push_back(1);\n\tint t=n;\n\tfor(int i=2;i*i<=t;i++) {\n\t\tif(!(t%i)) {\n\t\t\tint c=0;\n\t\t\twhile(!(t%i)) t/=i, ++c;\n\t\t\tfor(int j=div.size()-1;~j;j--) \n\t\t\t\tfor(int x=i,z=1;z<=c;x*=i,++z) \n\t\t\t\t\tdiv.push_back(div[j]*x);\n\t\t}\n\t}\n\tif(t!=1) \n\t\tfor(int j=div.size()-1;~j;j--) div.push_back(div[j]*t);\n\tsort(div.begin(),div.end());\n\tfor(int i=0;i<div.size();i++) \n\t\tg[i]=power(k,(div[i]+1)/2);\n\tfor(int i=0;i<div.size();i++) \n\t\tfor(int j=i-1;~j;j--) if(!(div[i]%div[j]))\n\t\t\tg[i]=dec(g[i],g[j]);\n\tint ans=0;\n\tfor(int i=0;i<div.size();i++)\n\t\tans=add(ans,mul((div[i]&1) ? div[i] : (div[i]/2),g[i]));\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nint n,k,fac[100111],cnt,f[100111],ans;\nint main()\n{\n\tget2(n,k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0)\n\t\t{\n\t\t\tfac[++cnt]=i;\n\t\t\tif(n/i!=i)fac[++cnt]=n/i;\n\t\t}\n\tsort(fac+1,fac+cnt+1);\n\tfor(int i=1;i<=cnt;i++)\n\t{\n\t\tf[i]=power(k,fac[i]+1>>1);\n\t\tfor(int j=1;j<i;j++)if(fac[i]%fac[j]==0)f[i]=(f[i]-f[j]+mod)%mod;\n\t\tif(fac[i]%2==1)ans=(ans+1ll*fac[i]*f[i])%mod;\n\t\telse ans=(ans+1ll*fac[i]/2*f[i])%mod;\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9 + 7;\nvector<int> d;\nint n, k, cnt = -1;\nlong long dp[12911], ans;\nmap<int, int> id;\n\ninline long long fpow(int a, int b){\n\tlong long ret = 1, tmp = a;\n\twhile(b){\n\t\tif(b & 1) ret = ret * tmp % mod;\n\t\ttmp = tmp * tmp % mod; b >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k); int sq = sqrt(n);\n\tif(n == 1){printf(\"%d\", k); return 0;}\n\tfor(int i = 1; i <= sq; ++i) \n\t\tif(n % i == 0){d.push_back(i); id[i] = ++cnt;}\n\tfor(int i = d.size() - 1; i >= 0; --i) \n\t\tif(n / d[i] > sq){d.push_back(n / d[i]); id[n / d[i]] = ++cnt;}\n\tint llppdd = d.size() - 1;\n\tfor(int i = 0; i <= llppdd; ++i){\n\t\tint now = d[i];\n\t\tif((n / now) & 1) \n\t\tdp[i] = fpow(k, (now + 1) / 2);\n\t\telse \n\t\tdp[i] = fpow(k, now);\n\t\tsq = sqrt(now);\n\t\tfor(int j = 1; j <= sq; ++j){\n\t\t\tif(now % j != 0 || j == now) continue;\n\t\t\tdp[i] = (dp[i] - dp[id[j]] + mod) % mod;\n\t\t\tif(now / j > sq && j != 1) dp[i] = (dp[i] - dp[id[now / j]] + mod) % mod;\n\t\t}\n\t\tans = (ans + dp[i] * now) % mod;\n\t}\n\tprintf(\"%lld\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\n#define mod 1000000007\nint n,k,ans,dp[1001000],p[1001000],cnt;\nint quickpow(int x,int y){\n\tif(y==0)return 1;\n\tif(y==1)return x;\n\tif(y%2==0)return quickpow(x*x%mod,y/2);\n\tif(y%2==1)return quickpow(x*x%mod,y/2)%x%mod;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\tp[++cnt]=i;;\n\t\t\tif(i*i!=n)p[++cnt]=n/i;\n\t\t}\n\tstd::sort(p+1,p+cnt+1);\n\tfor(int i=1;i<=cnt;i++){\n\t\tdp[i]=quickpow(k,(p[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(p[i]%p[j]==0)dp[i]=(dp[i]-dp[j]+mod)%mod;\n\t\tif(p[i]%2==0)(ans+=dp[i]*p[i]/2%mod)%=mod;\n\t\telse(ans+=dp[i]*p[i]%mod)%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int N = 1e6 + 1;\nconst int mod = 1e9 + 7;\nint n, k;\nint a[N], f[N];\nint add(int x, int y) {\n    x+= y;\n    return x >= mod ?x - mod : x;\n}\nint sub(int x, int y) {\n    x -= y;\n    return x < 0 ? x +mod : x;\n}\nint mul(int x, int y){\n    return 1ll * x * y % mod;\n}\nint calc(int x, int y) {\n    int z = 1;\n    while (y) {\n        if (y & 1) z = mul(z, x);\n        x = mul(x, x), y >>= 1;\n    }\n    return z;\n}\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 1; 1ll * i * i <= n; i ++)\n        if (n % i == 0) {\n            a[++a[0]] = i;\n            if (1ll * i * i != n)\n                a[++a[0]] = n / i;\n        }\n    sort(a+1, a+ a[0]+ 1);\n    int ans = 0;\n    for (int i = 1; i <= a[0]; i ++) {\n        f[i] = calc(k, ((a[i] + 1) / 2));\n        for (int j = 1; j < i; j ++)\n            if (a[i] % a[j] == 0)\n                f[i] = sub(f[i], f[j]);\n        if (a[i] & 1)\n            ans = add(ans, mul(f[i], a[i]) );\n        else\n            ans = add(ans, mul(f[i], a[i] / 2) );\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define gc( ) std::getchar( )\n#define pc( i ) std::putchar( i )\n#define RE cout << \"Passing [\" << __FUNCTION__ << \"] on \" << __LINE__ << '\\n'\n#define DEBUG(...) for( auto &i: __VA_ARGS__ ) cout << i << \" \"; cout << '\\n'\n#define space ' '\n#define enter '\\n'\nusing std::make_pair;\n\ntemplate < typename T >\ninline T read( )\n{\n register T x = 0;\n register char ch = gc( );\n register bool f = 0;\n while( !std::isdigit( ch ) )\n {\n  f = ( ch == '-' );\n  ch = gc( );\n }\n while( std::isdigit( ch ) )\n {\n  x = x * 10 + ( ch - '0' );\n  ch = gc( );\n }\n return f ? -x : x;\n}\n\ntemplate < typename T >\nvoid print( T x )\n{\n if( x < 0 )\n {\n  x = -x;\n  pc( '-' );\n }\n if( x < 10 )\n {\n  pc( x + 48 );\n  return;\n }\n print < T > ( x / 10 );\n pc( x % 10 + 48 );\n return ;\n}\n\nnamespace Solution\n{\n#define IOS std::ios::sync_with_stdio( false ), std::cin.tie( 0 ), std::cout.tie( 0 )\n#define Rep( i, j, k ) for( int i = j; i >= k; --i )\n#define rdi( ) read < int > ( )\n#define rdl( ) read < long long > ( )\n#define pti( i ) print < int > ( i ), putchar( space )\n#define ptl( i ) print < long long > ( i ), putchar( space )\n#define For( i, j, k ) for( int i = j; i <= k; ++i )\n using std::cin;\n using std::cout;\n using std::endl;\n using std::vector;\n using std::map;\n using std::queue;\n using std::deque;\n using std::set;\n using std::pair;\n const int Maxn = 4001, mod = 1e9 + 7;\n long long n, k, ans, dp[ Maxn ];\n vector < int > a;\n long long POW( long long u, long long U )\n {\n  long long res = 1;\n  while( U )\n  {\n   if( U & 1 )\n    res = res * u % mod;\n   u = u * u % mod;\n   U >>= 1;\n  }\n  return res;\n }\n void Fakemain( )\n {\n  IOS;\n  cin >> n >> k;\n  int ___ = sqrt( n );\n  For( i, 1, ___ )\n   if( !( n % i ) )\n   {\n    a.push_back( i );\n    if( i != n / i )\n     a.push_back( n / i );\n   }\n  std::sort( a.begin( ), a.end( ), std::less < int > ( ) );\n  for( int i = 0; i < ( int ) a.size( ); ++i )\n  {\n   dp[ i ] = POW( k, ( a[ i ] + 1 ) / 2 );\n   for( int j = 0; j < i; ++j )\n    if( a[ i ] % a[ j ] == 0 )\n     dp[ i ] = ( dp[ i ] - dp[ j ] + mod ) % mod;\n   if( a[ i ] & 1 )\n    ans = ( ans + dp[ i ] * a[ i ] ) % mod;\n   else\n    ans = ( ans + dp[ i ] * a[ i ] / 2 ) % mod;\n  }\n  cout << ans;\n  return;\n }\n\n} // namespace Solution\n\nint main( int argc, char* argv[] )\n{\n Solution::Fakemain( );\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nll mul(ll a,ll b,ll mod) {\n    ll d=((long double)a*b+0.5)/mod,ret=a*b-d*mod;\n    return (ret%mod+mod)%mod;\n}\nvector<ll> fac;\nll qpow(ll a,ll b,ll mod) {\n    ll ret=1;\n    while(b) {\n        if(b&1) ret=mul(ret,a,mod);\n        a=mul(a,a,mod); b>>=1;\n    }\n    return ret;\n}\nbool pri(ll n) {\n    if(n==2) return 1;\n    for(int T=1;T<=10;T++) {\n        ll a=rand()%(n-2)+2;\n        if(qpow(a,n-1,n)!=1) return 0;\n        ll p=n-1;\n        while(!(p&1)) {\n            p>>=1;ll x=qpow(a,p,n);\n            if(mul(x,x,n)==1&&x!=1&&x!=n-1) return 0;\n        }\n    }\n    return 1;\n}\nll rho(ll n,ll c) {\n    ll i=0,k=2,x=rand()%(n-1)+1,y=x;\n    while(1) {\n        x=(mul(x,x,n)+c)%n;\n        ll gg=__gcd((y-x+n)%n,n);\n        if(gg!=1&&gg!=n) return gg;\n        if(x==y) return n;\n        ++i;if(i==k) y=x,k<<=1;\n    }\n}\nvoid fact(ll n,ll c) {\n    if(n==1) return;\n    if(pri(n)) { fac.pb(n);return; }\n    ll p=n;while(p==n) p=rho(n,c--);\n    fact(p,c);fact(n/p,c);\n}\nll n,k,mod,p[N],tot=0,ans=0,a[N];\nll g(ll n) { return qpow(k,(n+1)/2,mod); }\nll h(ll n) { return (n&1)?n%mod:(n/2)%mod; }\nvoid dfs(int i,ll x,ll Mul) {\n    if(i==tot+1) {\n        if((n/x)%2==1&&x%2==0) return;\n        ans=(ans+1ll*g(n/x)*h(n/x)%mod*Mul%mod)%mod;\n        return;\n    }\n    dfs(i+1,x,Mul);\n    Mul=1ll*Mul*(1-p[i]%mod+mod)%mod;x*=p[i];\n    for(int j=1;j<=a[i];j++) dfs(i+1,x,Mul),x*=p[i];\n}\nvoid work() {\n    tot=ans=0;cin>>n>>k;mod=1e9+7;k%=mod;\n    fac.clear();fact(n,141905);\n    sort(fac.begin(),fac.end());\n    for(int i=0,siz=fac.size();i<siz;i++) {\n        if(!i || fac[i]!=fac[i-1]) p[++tot]=fac[i],a[tot]=1;\n        else a[tot]++;\n    }\n    dfs(1,1,1);printf(\"%lld\\n\",ans);\n}\nint main() {\n\twork();\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\n\ninline LL pow(LL x, LL exp) {\n  LL res = 1;\n  for (; exp; exp >>= 1, x = x * x % mod)\n    if (exp & 1) res = res * x % mod;\n  return res;\n}\n\nLL dp[5005], arr[5005];\n\nint main() {\n  LL n, k, m = 0;\n  scanf(\"%lld%lld\", &n, &k);\n  for (LL i = 1; i * i <= n; i ++)\n    if (n % i == 0) {\n      arr[++ m] = i;\n      if (i * i != n) arr[++ m] = n / i;\n    }\n  sort(arr + 1, arr + m + 1);\n  LL ans = 0;\n  for (int i = 1; i <= m; i ++) {\n    dp[i] = pow(k, (arr[i] + 1) / 2);\n    for (int j = 1; j < i; j ++)\n      if (arr[i] % arr[j] == 0) {\n\tdp[i] -= dp[j];\n\tif (dp[i] < 0) dp[i] += mod;\n      }\n    if (arr[i] & 1) ans += arr[i] * dp[i] % mod;\n    else ans += (arr[i] / 2) * dp[i] % mod;\n    if (ans >= mod) ans -= mod;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n \ntypedef long long ll;\ninline int Get() {\n\tchar ch;\n\twhile ((ch = getchar()) < '0' || ch > '9');\n\tint Num = ch - '0';\n\twhile ((ch = getchar()) >= '0' && ch <= '9')\n\t\tNum = (Num << 3) + (Num << 1) + ch - '0';\n\treturn Num;\n}\nconst int Mod = 1e9 + 7;\nint n, m, ans;\nstd :: vector <int> v, g;\ninline int pow(int x, int k) {\n\tll res = 1, r = x % Mod;\n\tfor (; k; k >>= 1, r = r * r % Mod) \n\t\tif (k & 1) res = res * r % Mod;\n\treturn res;\n}\nint main() {\n\tn = Get(), m = Get();\n\tfor (int i = 1; (ll)i * i <= n; ++i)\n\t\tif (!(n % i)) {\n\t\t\tv.push_back(i), g.push_back(0);\n\t\t\tif (n / i != i) v.push_back(n / i), g.push_back(0);\n\t\t}\n\t\n\tstd :: sort(v.begin(), v.end());\n\tfor (int i = 0, sze = v.size(), x; i < sze; ++i) {\n\t\tx = v[i], g[i] = pow(m, x + (x & 1) >> 1);\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tif (!(x % v[j])) g[i] = (g[i] - g[j] + Mod) % Mod;\n\t} \n\t\n\tfor (int i = 0, sze = v.size(), x; i < sze; ++i)\n\t\tx = v[i], (ans += (ll)((x & 1) ? x : x >> 1) * g[i] % Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n    int x(0), sgn(1); char ch(getchar());\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n    for (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n    return x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int Mod = 1e9 + 7;\n\nint fpm(int x, int power) {\n\tint res = 1;\n\tfor (; power; power >>= 1, x = 1ll * x * x % Mod)\n\t\tif (power & 1) res = 1ll * res * x % Mod;\n\treturn res;\n}\n\nconst int N = 3010;\n\nint d[N], f[N], tot;\n\nint main () {\n\n\tFile();\n\n\tint n = read(), k = read();\n\n\tFor (i, 1, sqrt(n)) if (!(n % i)) {\n\t\td[++ tot] = i;\n\t\tif (i != n / i) d[++ tot] = n / i;\n\t}\n\tsort(d + 1, d + tot + 1);\n\n\tint ans = 0;\n\tFor (i, 1, tot) {\n\t\tf[i] = fpm(k, (d[i] + 1) / 2);\n\t\tFor (j, 1, i - 1)\n\t\t\tif (!(d[i] % d[j])) \n\t\t\t\t(f[i] += Mod - f[j]) %= Mod;\n\t\tans = (ans + 1ll * f[i] * (d[i] / (2 - (d[i] & 1)))) % Mod;\n\t}\n\tprintf (\"%d\\n\", ans);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define forr(i,p,n) for(ll i=p;i<n;i++)\n#define tam 4000\n#define offset 220010\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<double,double> iib;\ntypedef pair<ll,ii> iii;\ntypedef pair<map<ll,ll> ,ll> mi;\ntypedef pair<ii,ii> iiii;\ntypedef vector<ll> vi;\nll N,K;\nvector<ll> divs;\nmap<ll,bool> vis;\nmap<ll,ll> dp;\nconst ll MOD=1e9+7;\n\nll pot(ll base,ll exp)\n{\n    base%=MOD;\n    ll resp=1;\n    while(exp>0)\n    {\n        if (exp&1)\n            resp*=base,resp%=MOD;\n        base*=base;base%=MOD;\n        exp/=2;\n    }\n    return resp%MOD;\n}\nll f(ll num)\n{\n    ll tot=0;\n    if (vis[num]!=0)\n        return dp[num];\n    vis[num]=1;\n    tot=pot(K,(num+1)/2);\n    tot%=MOD;\n    forr(i,0,divs.size())\n    {\n        if (divs[i]!=num && num%divs[i]==0)\n            tot-=f(divs[i]),tot+=MOD,tot%=MOD;\n    }\n    return dp[num]=tot;\n}\nint  main()\n{\n    //cout<<pot(3,4)<<\" \"<<pot(2,10)<<endl;\n    cin>>N>>K;\n    if (N!=1)\n    divs.pb(1);\n    for(ll i=2;i*i<=N;i++)\n    {\n        if (N%i==0){\n            if (N/i!=i)\n            divs.pb(i),divs.pb(N/i);\n            else\n            divs.pb(i);\n        }\n    }\n    sort(divs.begin(),divs.end());\n    /*forr(i,0,divs.size())\n    cout<<divs[i]<<\" \";\n    cout<<endl;\n    cout<<divs.size()<<' ';\n    cout<<unique(divs.begin(),divs.end())-divs.begin()<<endl;*/\n    //cout<<f(N)<<endl;\n    ll answer=f(N)%MOD;\n    if (N%2==0) answer*=N/2;\n    else answer*=N;\n    answer%=MOD;\n    //cout<<endl<<endl;\n    forr(i,0,divs.size()){\n        //cout<<divs[i]<<' ';\n        if (divs[i]%2)\n        answer+=(f(divs[i])*divs[i])%MOD,answer%=MOD;\n        else\n        answer+=(f(divs[i])*(divs[i]/2))%MOD,answer%=MOD;\n        //cout<<answer<<' ';\n    }\n    cout<<answer<<endl;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define MOD 1000000007\n\nlong mod_pow(long x, long n, long p=MOD){\n  if(x==0) return 0;\n  long res=1;\n  x %= p;\n  while(n>0){\n    if(n&1) res=res*x%p;\n    x=x*x%p;\n    n>>=1;\n  }\n  return res;\n}\n\nint main(){\n  long n,k;\n  cin>>n>>k;\n\n  vector<int> divs;\n  for(long x = 1; x *x <= n; x++) if(n%x==0){\n    divs.pb(x);\n    divs.pb(n/x);\n  }\n  uniq(divs);\n\n  map<long,long> cnt;\n  rep(i,divs.size()){\n    long d = divs[i];\n    long tmp = mod_pow(k, (d+1)/2);\n    rep(j,i) if(d%divs[j]==0){\n      tmp = (tmp - cnt[divs[j]] + MOD) %MOD;\n    }\n    cnt[d] = tmp;\n  }\n\n  long ans = 0;\n  for(auto &p : cnt){\n    if(p.fi%2 == 0) ans += p.fi/2 * p.se;\n    else ans += p.fi * p.se;\n    ans %= MOD;\n  }\n\n  cout << ans %MOD << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666,mo=1e9+7;\nint n,k,p[N],a[N],len,b[N],res;\nll power(ll a, ll n){\n\tll res=1;\n\twhile(n){\n\t\tif(n&1)res=res*a%mo;a=a*a%mo;n>>=1;\n\t}\n\treturn res;\n}\nvoid facfac(int n){\n\tfor(int x=2;x*x<=n;x++)if(n%x==0){\n\t\tp[++len]=x;while(n%x==0)n/=x,a[len]++;\n\t}\n\tif(n>1)p[++len]=n,a[len]=1;\n}\ninline int calc(){\n\tint res=1;\n\trep(i,1,len)if(a[i]-b[i])res=1LL*res*(1-p[i]+mo)%mo;\n\treturn res;\n}\nvoid dfs(int dep, int y){\n\tif(dep>len){\n\t\tint ans=0;\n\t\tif(y%2==0)ans=1LL*y/2*calc()%mo;\n\t\telse if(n/y&1)ans=1LL*y*calc()%mo;\n\t//\tcerr<<y<<' '<<ans<<endl;\n\t\tres=(res+1LL*ans*power(k,(y+1)/2))%mo;\n\t\treturn;\n\t}\n\trep(i,0,a[dep])b[dep]=i,dfs(dep+1,y),y*=p[dep];\n}\nint main() {\n\tread(n);read(k);facfac(n);\n\tdfs(1,1);cout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nconst long long MOD = 1000000007;\nint N, K, d[240], w[240], L;\nlong long O;\nlong long POWER(long long a, long long b)\n{\n\tlong long r = 1;\n\tfor (; b; b >>= 1)\n\t{\n\t\tif (b & 1)\n\t\t\tr = r * a % MOD;\n\t\ta = a * a % MOD;\n\t}\n\treturn r;\n}\nint main()\n{\n\tscanf(\"%d%d\", &N, &K);\n\tfor (int i = 1; i * i <= N; i++)\n\t\tif (N % i == 0)\n\t\t{\n\t\t\td[L++] = i;\n\t\t\tif (i * i < N)\n\t\t\t\td[L++] = N / i;\n\t\t}\n\tstd::sort(d, d + L);\n\tfor (int i = 0; i < L; i++)\n\t\tw[i] = d[i];\n\tfor (int i = L - 1; i >= 0; i--)\n\t\tfor (int j = i + 1; j < L; j++)\n\t\t\tif (d[j] % d[i] == 0)\n\t\t\t\tw[i] -= w[j];\n\tfor (int i = 0; i < L; i++)\n\t\tO = (O + (w[i] + MOD) * POWER(K, N / d[i] & 1 ? d[i] + 1 >> 1 : d[i])) % MOD;\n\tprintf(\"%lld\\n\", O);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\nusing lint = long long;\n\nstruct modint {\n    int v;\n    modint(lint v_ = 0): v(v_ % MOD) { }\n    modint operator+ (const modint &m) const {\n        return modint(v + m.v);\n    }\n    modint operator- (const modint &m) const {\n        return modint(v - m.v + MOD);\n    }\n    modint operator* (const modint &m) const {\n        return modint((lint)v * m.v);\n    }\n    modint operator+= (const modint &m) {\n        v = (v + m.v) % MOD;\n        return *this;\n    }\n    modint operator*= (const modint &m) {\n        v = ((lint)v * m.v) % MOD;\n        return *this;\n    }\n    modint operator-= (const modint &m) {\n        v = (v - m.v + MOD) % MOD;\n        return *this;\n    }\n    modint pow(int k) {\n        modint cur(v), ret(1);\n        while(k > 0) {\n            if(k & 1) ret *= cur;\n            cur = cur * cur;\n            k >>= 1;\n        }\n        return ret;\n    }\n    modint inv() {\n        return pow(MOD - 2);\n    }\n};\n\nconst modint INV2 = modint(2).inv();\n\nint N, K;\n\nmodint ans;\n\nmodint ways[int(5.1e4)];\n\nint main() {\n    scanf(\"%d%d\", &N, &K);\n    \n    vector<int> divs;\n    for(int i = 1; i * i <= N; i++) {\n        if(N % i == 0) {\n            divs.push_back(i);\n            if(i * i != N) divs.push_back(N/i);\n        }\n    }\n    \n    sort(divs.begin(), divs.end());\n    \n    for(int i = 0; i < int(divs.size()); i++) {\n        // degree of freedom : divs[i]\n        \n        ways[i] += modint(K).pow((divs[i] + 1) / 2);\n        for(int j = 0; j < i; j++) if(divs[i] % divs[j] == 0) ways[i] -= ways[j];\n        \n        ans += (divs[i] % 2 == 1 ? modint(1) : INV2) * ways[i] * divs[i];\n    }\n    \n    printf(\"%d\\n\", ans.v);\n    \n    \n    return 0;\n}\n\n/*\nN이 홀수\n\nABCBA => A, B, C 중 하나라도 다르면 서로 다른 수열을 얻음\n\nBCBAA -> B=A, C=A -> 전부 같아야\nCBAAB -> C=B=A\nBAABC -> B=C=A\nAABCB -> A=B=C\n\n염려:\nDEFED\nEFEDD\nFEDDE\nEDDEF\nDDEFE\n\n\nN이 짝수 -> A, B, C가 하나라도 다르면 서로 다른 palin 수열 2개가 같은 결과\n\nABCCBA \nBCCBAA B=A=C\nCCBAAB C=B=A\nCBAABC (palin!)\nBAABCC B=C=A\nAABCCB A=B=C\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\nll po(ll a, ll b)\n{\n\tif (b == 0)return 1;\n\tll z = po(a, b / 2);\n\tz = z*z%mod;\n\tif (b % 2 == 1)z = z*a%mod;\n\treturn z;\n}\nint main()\n{\n\tll num, kai;\n\tscanf(\"%lld%lld\", &num, &kai);\n\tvector<ll>vec;\n\tfor (ll i = 1; i*i <= num; i++)\n\t{\n\t\tif (num%i == 0)\n\t\t{\n\t\t\tvec.push_back(i);\n\t\t\tif (i != num / i)vec.push_back(num / i);\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\tvector<ll>ans;\n\tvector<ll>ret;\n\tfor (int i = 0; i < vec.size(); i++)\n\t{\n\t\tif (num % 2 == 0)\n\t\t{\n\t\t\tif (vec[i] % 2 == 0)ans.push_back(num / vec[i]),ret.push_back(po(kai, ans[i])*(num / vec[i]) % mod);\n\t\t\telse ans.push_back(0),ret.push_back(0);\n\t\t}\n\t\telse ans.push_back((num / vec[i] + 1) / 2),ret.push_back(po(kai, ans[i])*(num / vec[i]) % mod);\n\t}\n\tfor (int i = vec.size() - 1; i >= 0; i--)\n\t{\n\t\tif (num % 2 == 0 && vec[i] % 2 == 1)continue;\n\t\tfor (int j = i + 1; j < vec.size(); j++)\n\t\t{\n\t\t\tif (vec[j] % vec[i] == 0)ret[i] = (ret[i] + mod - ret[j] * (vec[j] / vec[i]) % mod) % mod;\n\t\t}\n\t\t//printf(\"%lld %lld\\n\", vec[i], ret[i]);\n\t}\n\tll r = 0;\n\tfor (int i = 0; i < vec.size(); i++)\n\t{\n\t\tr += ret[i];\n\t\tr %= mod;\n\t}\n\tprintf(\"%lld\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=1e6+5,M=2e6+5,mo=1e9+7;\nll f[N],fac[N],i,n,K,j,ans;\nll ksm(ll x,ll y)\n{\n\tll ret=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ret=ret*x%mo;\n\t\ty>>=1;\n\t\tx=x*x%mo;\n\t}\n\treturn ret;\n}\nvoid predo()\n{\n\tfo(i,1,trunc(sqrt(n)))\n\tif (n%i==0)\n\t{\n\t\tfac[++fac[0]]=i;\n\t\tif (i*i!=n) fac[++fac[0]]=n/i;\n\t}\n\tsort(fac+1,fac+1+fac[0]);\n}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&K);\n\tpredo();\n\tfo(i,1,fac[0])\n\t{\n\t\tf[i]=ksm(K,(fac[i]+1)/2);\n\t\tfo(j,1,i-1)\n\t\t\tif (fac[i]%fac[j]==0)\n\t\t\t\t(f[i]-=f[j])%=mo;\n\t\tif (fac[i]%2)\n\t\t\t(ans+=f[i]*fac[i])%=mo;\n\t\telse (ans+=f[i]*fac[i]/2)%=mo;\n\t}\n\tprintf(\"%lld\\n\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <map>\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nstd::vector<intmax_t> divisor(intmax_t n) {\n  std::vector<intmax_t> res;\n  for (intmax_t i = 1; i*i <= n; ++i) {\n    if (n % i) continue;\n    res.push_back(i);\n    if (n/i != i) res.push_back(n/i);\n  }\n  std::sort(res.begin(), res.end());\n  return res;\n}\n\nstd::vector<intmax_t> factor(intmax_t n) {\n  std::vector<intmax_t> res;\n  for (intmax_t i = 2; i*i <= n; ++i) {\n    if (n % i) continue;\n    res.push_back(i);\n    do n /= i; while (n % i == 0);\n  }\n  if (n > 1) res.insert(std::lower_bound(res.begin(), res.end(), n), n);\n  return res;\n}\n\nstd::map<intmax_t, intmax_t> moebius(intmax_t n) {\n  auto fs = factor(n);\n  size_t m = fs.size();\n  std::map<intmax_t, intmax_t> res;\n  for (size_t i = 0; i < (1_zu << m); ++i) {\n    intmax_t d = 1;\n    intmax_t mu = 1;\n    for (size_t j = 0; j < m; ++j) {\n      if (i >> j & 1) {\n        d *= fs[j];\n        mu = -mu;\n      }\n    }\n    res[d] = mu;\n  }\n  return res;\n}\n\ntemplate <typename InputIt>\nauto compress(InputIt first, InputIt last) {\n  using value_type = typename InputIt::value_type;\n  std::map<value_type, size_t> res;\n  while (first != last) res[*first++];\n  size_t i = 0;\n  for (auto& p: res) p.second = i++;\n  return res;\n}\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nconstexpr intmax_t mod = 1e9+7;\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  std::vector<intmax_t> ds = divisor(n);\n  std::vector<intmax_t> f(ds.size());\n  for (size_t i = 0; i < ds.size(); ++i)\n    f[i] = modpow(k, (ds[i]+1)/2, mod);\n\n  std::map<intmax_t, intmax_t> mu = moebius(n);\n  std::vector<size_t> dp(ds.size());\n  for (size_t i = 0; i < ds.size(); ++i) {\n    for (size_t j = 0; j <= i; ++j) {\n      if (ds[i] % ds[j]) continue;\n      intmax_t cur = (mu[ds[i]/ds[j]] * f[j]) % mod;\n      if (cur < 0) cur += mod;\n      (dp[i] += cur) %= mod;\n    }\n  }\n\n  intmax_t inv2 = modpow(2_jd, mod-2, mod);\n  intmax_t res = 0;\n  for (size_t i = 0; i < dp.size(); ++i) {\n    intmax_t cur = dp[i];\n    (cur *= ds[i]) %= mod;\n    if (ds[i] % 2 == 0) (cur *= inv2) %= mod;\n    (res += cur) %= mod;\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n数据不清空，爆零两行泪。\n多测不读完，爆零两行泪。\n边界不特判，爆零两行泪。\n贪心不证明，爆零两行泪。\nD P 顺序错，爆零两行泪。\n大小少等号，爆零两行泪。\n变量不统一，爆零两行泪。\n越界不判断，爆零两行泪。\n调试不注释，爆零两行泪。\n溢出不 l l，爆零两行泪。\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1000000007;\nint qpow(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint inv(int x){return qpow(x,mod-2);}\nint n,m;\nsigned main(){\n\tcin>>n>>m;\n\tif(n&1)cout<<(((qpow(m,n/2+1)-m)*n+m)%mod+mod)%mod;\n\telse cout<<(((qpow(m,(n/2+1)/2)-m)*(n/2)+(qpow(m,n/2)-qpow(m,(n/2+1)/2))*inv(2)%mod*n+m)%mod+mod)%mod;\n\treturn 0;\n}\n/*1\n4 2\n*/\n/*2\n1 10\n*/\n/*3\n6 3\n*/\n/*4\n1000000000 1000000000\n*/"
  },
  {
    "language": "C++",
    "code": "// C++(GCC 9.2.1)\n// 解き直し.\n// https://img.atcoder.jp/arc064/editorial.pdf\n// ① 1_27.txt, 1_28.txt, 1_30.txt, 1_31.txt で, WA版となったため, ロジック修正.\n// -> d[i] / 2 は d[i] * 500000004 % MOD に 修正.\n// ② 1_27.txt で, WA版となったため, ロジック修正.\n// mPow の 第二引数が, 切り捨てだったものを, 切り上げに修正.\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define repex(i, a, b, c) for(int i = a; i < b; i += c)\n#define repx(i, a, b) repex(i, a, b, 1)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define pb push_back\n#define all(x) x.begin(), x.end()\nconst LL MOD = 1e9 + 7;\n\n// 与えられた正の整数のすべての約数を抽出.\n// @param X: 約数を抽出したい正の整数.\n// @return ret: すべての約数.\nvector<LL> div(LL X){\n    vector<LL> ret;\n    ret.pb(1);\n    for(LL d = 2; d * d <= X; d++){\n        if(X % d == 0){\n            ret.pb(d);\n            if(d * d != X) ret.pb(X / d);\n        }\n    }\n    if(X > 1) ret.pb(X);\n    sort(all(ret));\n    return ret;\n}\n\n// Fermat's little theorem から, 大きな冪乗の計算を行う.\n// @param a: べき乗したい正整数.\n// @param b: 指数.\n// @return:  べき乗した計算結果(mod版).\nLL mPow(LL a, LL b){\n    LL t = 1;\n    while(b){\n        if(b & 1) t = (t * a) % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return t % MOD;\n}\n\nint main(){\n    \n    // 1. 入力情報.\n    LL N, K;\n    scanf(\"%lld %lld\", &N, &K);\n    \n    // 2. 例外.\n    if(N == 1){\n        printf(\"%lld\\n\", K);\n        return 0;\n    }\n    \n    // 3. N の 約数.\n    vector<LL> d = div(N);\n    // for(auto &p : d) printf(\"%lld \", p);\n    // puts(\"\");\n    \n    // 4. 各最小周期に対応する数列の個数.\n    int l = d.size();\n    LL num[l];\n    memset(num, 0, sizeof(num));\n    rep(i, l){\n        // num[i] = mPow(K, d[i] / 2);\n        // num[i] = mPow(K, d[i] * 500000004 % MOD);\n        num[i] = mPow(K, (d[i] + 1) / 2);\n        rep(j, i){\n            if(d[i] % d[j] == 0) num[i] = (num[i] + MOD - num[j]) % MOD;\n        }\n    }\n    \n    // 5. 解答を求めるための数式を計算.\n    LL ans = 0, nd;\n    rep(i, l){\n        // nd = (d[i] & 1) ? d[i] : d[i] / 2;\n        nd = (d[i] & 1) ? d[i] : (d[i] * 500000004 % MOD);\n        ans += num[i] * nd;\n        ans %= MOD;\n    }\n    \n    // 6. 出力.\n    printf(\"%lld\\n\", ans);\n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 1000000007\n#define MMOD 998244353\n#define MAX 2010101\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 繰り返し二乗法 //////////\n\nll power(ll a,ll b){\n  ll res=1;\n  while(b>0){\n    if(b&1) res=res*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return res;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,K;\n  cin>>N>>K;\n  \n  vector<ll> DIV;\n  for(ll i=1; i<=sqrt(N); ++i){\n    if(N%i==0){\n      if(i*i==N) DIV.PB(i);\n      else{\n        DIV.PB(i);\n        DIV.PB(N/i);\n      }\n    }\n  }\n  SORT(DIV);\n  \n  vector<ll> NUM(DIV.size(),0);\n  \n  for(ll i=0; i<(ll)DIV.size(); ++i){\n    NUM[i]=power(K,(DIV[i]+1)/2);\n    for(ll j=0; j<i; ++j){\n      if(DIV[i]%DIV[j]==0) NUM[i]-=NUM[j];\n    }\n    NUM[i]=(NUM[i]%MOD+MOD)%MOD;\n  }\n  \n  ll ans=0;\n  for(ll i=0; i<(ll)DIV.size(); ++i){\n    if(DIV[i]%2==1) ans+=NUM[i]*DIV[i]%MOD;\n    else ans+=NUM[i]*DIV[i]/2%MOD;\n    ans%=MOD;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,k;\n  cin>>n>>k;\n  vector<Int> v;\n  for(Int i=1;i*i<=n;i++){\n    if(n%i) continue;\n    v.emplace_back(i);\n    v.emplace_back(n/i);\n  }\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  Int m=v.size();\n\n  const Int MOD = 1e9+7;\n  auto mod_pow=[&](Int b,Int x){\n    Int res=1;\n    while(x){\n      if(x&1) res=res*b%MOD;\n      b=b*b%MOD;\n      x>>=1;\n    }\n    return res;\n  };\n  //Int inv=mod_pow(2,MOD-2);\n  \n  Int ans=0;\n  vector<Int> dp(m);\n  for(Int i=0;i<m;i++){\n    dp[i]=mod_pow(k,(v[i]+1)/2);\n    for(Int j=0;j<i;j++)\n      if(v[i]%v[j]==0) dp[i]+=MOD-dp[j];\n    dp[i]%=MOD;\n    if(v[i]&1) ans+=dp[i]*v[i]%MOD;\n    else ans+=dp[i]*(v[i]/2)%MOD;\n    ans%=MOD;\n    //cout<<v[i]<<\":\"<<dp[i]<<endl;\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#pragma GCC target(\"avx,popcnt\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 1e9 + 7, i2 = (mod+1)/2;\nll n, k, f[maxn];\nvector<int> divs;\nll bp(ll a, ll p) {\n\tll r = 1;\n\twhile(p) {\n\t\tif(p&1) r = r*a%mod;\n\t\ta = a*a%mod, p>>=1;\n\t}\n\treturn r;\n}\n\nint p[maxn], b[maxn];\nint cycl(string s) {\n\tint i = 0, j = -1; b[0] = -1;\n\twhile(i < s.size()) {\n\t\twhile(j != -1 && s[i] != s[j]) j = b[j];\n\t\ti++, j++;\n\t\tb[i] = j;\n\t}\n\tint t = s.size() - b[s.size()];\n\treturn s.size()%t ? s.size() : t;\n}\nvoid brute(int n, int k) {\n\tmap<int, int> cnt;\n\tset<string> vis;\n\tint tn = n;\n\tn = (n+1)/2;\n\t\n\twhile(true) {\n\t\tstring s, t;\n\t\tfor(int i = 0; i < n; i++) s.pb(p[i]+'a');\n\t\tt = s;\n\t\tif(tn&1) t.pop_back();\n\t\treverse(all(t));\n\t\ts += t;\n\t\t\n\t\tint ok = 1;\n\t\tstring u = s + s;\n\t\tfor(int i = 0; i < tn; i++)  ok &= !vis.count(u.substr(i, tn));\n\t\tvis.insert(s);\n\t\t\n\t\tif(ok) {\n\t\t\tcnt[cycl(s)]++;\n\t\t\tif(cycl(s) == 2) cout << s << '\\n';\n\t\t}\n\t\tint add = 1;\n\t\tfor(int i = 0; add && i < n; i++)\n\t\t\t((++p[i] == k) ? p[i] : add) = 0;\n\t\tif(add) break;\n\t}\n\tfor(auto i : cnt) cout << i.first << \" \" << i.second << '\\n';\n\t//return ans.size();\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> k;\n\t//cout << brute(n, k) << '\\n';\n\t//return 0;\n\tfor(int i = 1; i*i <= n; i++) {\n\t\tif(n%i) continue;\n\t\tdivs.pb(i);\n\t\tif(n/i != i) divs.pb(n/i);\n\t}\n\tsort(all(divs));\n\tfor(int i = 0; i < divs.size(); i++) {\n\t\tf[i] = bp(k, (divs[i]+1)/2);\n\t\tif(divs[i]%2 == 3) {\n\t\t\tint t = divs[i]/2;\n\t\t\tt = (t+1)/2;\n\t\t\tf[i] = (f[i] + bp(k, t))*i2%mod;\n\t\t}\n\t\t//cout << divs[i] << \" \" << f[i] << '\\n';\n\t}\n\tfor(int i = 0; i < divs.size(); i++) {\n\t\t\n\t\tfor(int j = i+1; j < divs.size(); j++) {\n\t\t\tif(divs[j]%divs[i]) continue;\n\t\t\tf[j] = (mod + f[j] - f[i])%mod;\n\t\t\t//if(divs[i] > 1 && (divs[j]/divs[i])%2 == 0)\n\t\t\t//f[j] = (mod + f[j] - f[i]))%mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i = 0; i < divs.size(); i++) {\n\t\tif(divs[i]%2 == 0) f[i] = f[i]*i2%mod;\n\t\tans = (ans + divs[i] * f[i])%mod;\n\t}\n\tcout << ans << '\\n';\n\t//brute(n, k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\n// const int mod = 998244353;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class T> vector<T> make_vec(size_t a) {return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts){\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nvector<ll> divisor(ll n) {\n  vector< ll> ret;\n  for(ll i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret.push_back(i);\n      if(i * i != n) ret.push_back(n / i);\n    }\n  }\n  sort(ret.begin(), ret.end());\n  return (ret);\n}\nint main(){\n    iosetup();\n    int n, k; cin >> n >> k;\n    auto ds = divisor(n);\n    modint ans = 0;\n    map<int, modint> dp;\n    rep(i, 0, ds.size()){\n        int t = ds[i];\n        modint tmp = k;\n        // cerr << tmp << endl;\n        // if(n % (2 * t) != 0) {\n            if(t % 2)tmp = tmp.pow((t+1)/2);\n            else tmp = tmp.pow(t/2);\n        // }\n        // cerr << i << \" \" << tmp << endl;\n        dp[i] += tmp;\n        rep(j, i + 1, ds.size()){\n            if(ds[j] % t == 0) dp[j] -= dp[i];\n        }\n        if(t%2) ans += dp[i] * t;\n        else ans += dp[i] * (t / 2);\n    }\n    // for(auto e: dp) cerr << e << endl;\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nll n, k;\n\n/// --- math {{{ ///\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll d;\n  return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n}\nll modinv(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  if(x < 0) x += mod;\n  return x;\n}\nll modpow(ll a, ll b, ll mod) {\n  ll r = 1;\n  a %= mod;\n  while(b) {\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\n/// }}}--- ///\n\n// O(N^.5)\n/// --- divisor {{{ ///\n#include <vector>\nvector< ll > divisor(ll n) {\n  vector< ll > res;\n  for(ll i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      res.emplace_back(i);\n      if(i != n / i) res.emplace_back(n / i);\n    }\n  }\n  return res;\n}\n/// }}}--- ///\n\nconst ll mod = 1e9 + 7;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> k;\n  auto ds = divisor(n);\n  sort((ds).begin(), (ds).end());\n  vector<ll> num(ds.size());\n  ll ans = 0;\n  for(int i = 0; i < ds.size(); i++) {\n    ll d = ds[i];\n    num[i] = modpow(k, (d + 1) / 2, mod);\n    for(int j = 0; j < i; j++) {\n      if(d % ds[j] == 0) num[i] -= num[j];\n    }\n    num[i] %= mod;\n    ans += num[i] * (d & 1 ? d : d / 2) % mod;\n  }\n  ans = (ans % mod + mod) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n# @Author:      iLovePKU_zbtxdy\n# @DateTime:    2020-02-07 14:24:52\n# @Description: Think twice. Code once. \n# @More: Once lots of AC, try Brute-force,dynamic programming\n****************************************************************/\n#include<bits/stdc++.h>\nusing namespace std;\n#define close std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define eps 1e-8\ntypedef long long ll;\nconst int maxn = 1e6+10;\nconst int INF = 0x3f3f3f3f;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\nconst double PI = acos(-1.0);\nll mod = 1e9+7;\nll bin(ll x , ll n , ll MOD){\n    ll ret = MOD != 1;\n    for(x %= MOD; n ; n >>= 1, x = x * x % MOD)\n        if(n & 1)ret = ret * x % MOD;\n    return ret;\n}\nint n , len , k , tot[maxn];\nvector<int > v;\nint main()\n{\n    cin >> n >> k;\n    len = sqrt(n);\n    for(int i = 1; i <= len; i++){\n        if(n % i == 0){\n            v.emplace_back(i);\n            if(i != n / i)v.emplace_back(n / i);\n        }\n    }sort(v.begin(), v.end());\n    int size  = v.size();\n    ll ans = 0;\n    for(int i = 0 ; i < size ; i++){\n        tot[i] = bin(k , (v[i] + 1) / 2, mod);\n        for(int j = 0 ; j < i ; j++){\n            if(v[i] % v[j] == 0){\n                tot[i] = (tot[i] + mod - tot[j]) % mod;\n            }\n        }\n        if(v[i] & 1){ans += tot[i] * v[i]; ans %= mod;}\n        else {ans += tot[i] * (v[i] / 2) ; ans %= mod;}\n    }cout << ans << endl;\n    system(\"pause\");\n}\n/***************************************************************************\n*stuff you should look for\n*int overflow, array bounds\n*special cases (n=1?), set tle\n*do smth instead of nothing and stay organized\n***************************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=1e6+5,mod=1e9+7;\nint n,k,ans;\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nvector<int>a;\nint f[maxn];\nint main(){\n\tread(n);read(k);\n\tint tmp=sqrt(n);\n\trep(i,1,tmp)if(n%i==0){\n\t\ta.pb(i);\n\t\tif(n/i!=i)a.pb(n/i);\n\t}\n\tsort(All(a));\n\tans=f[0]=k;\n\trep2(i,1,SZ(a)){\n\t\tf[i]=power(k,(a[i]+1)/2,mod);\n\t\trep2(j,0,i)if(a[i]%a[j]==0)f[i]=sub(f[i],f[j]);\n\t\tif(a[i]&1)ans=(ans+1ll*f[i]*a[i])%mod;\n\t\telse ans=(ans+1ll*f[i]*(a[i]/2))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 2010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nvector<int> fac;\nint n;\nll k,sum[MAXN];\nvoid get_fac(int x){\n\tfor(int i=1;i*i<=x;i++)\n\t\tif(x%i==0){\n\t\t\tfac.push_back(i);\n\t\t\tif(i*i!=x)\n\t\t\t\tfac.push_back(x/i);\n\t\t}\n\tsort(fac.begin(),fac.end());\n}\nll fsp(ll x,int y){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres=res*x%MOD;\n\t\tx=x*x%MOD;\n\t\ty>>=1;\t\n\t}\n\treturn res;\n}\nint main(){\n\tSF(\"%d%lld\",&n,&k);\n\tget_fac(n);\n\tll ans=0;\n\tfor(int i=0;i<fac.size();i++){\n\t\tsum[i]=fsp(k,(fac[i]+1)/2);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(fac[i]%fac[j]==0){\n\t\t\t\tsum[i]-=sum[j];\n\t\t\t\tsum[i]%=MOD;\n\t\t\t}\n\t\t}\n\t\tif(fac[i]%2)\n\t\t\t(ans+=sum[i]*fac[i]%MOD)%=MOD;\n\t\telse\n\t\t\t(ans+=sum[i]*(fac[i]/2ll)%MOD)%=MOD;\n\t}\n\tPF(\"%lld\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\n\nll N, K, M;\nll ans;\nmap<int, int> P;\nvector<pi> vp;\n\nmap<vi, ll> dp[11];\n\nll diviser(const vi& vec) {\n\tll n = 1;\n\trep(i, 0, M) {\n\t\tn *= mod_pow(vp[i].fst, vec[i]);\n\t}\n\treturn n;\n}\n\nll loop(vi vec, int at) {\n\tif(dp[at].find(vec) != dp[at].end()) return dp[at][vec];\n\tif(at == 0) {\n\t\tll l = diviser(vec);\n\t\treturn dp[at][vec] = mod_pow(K, (l + 1) / 2);\n\t}\n\telse {\n\t\tint p = vec[at - 1];\n\t\tll res = 0;\n\t\tif(p - 1 >= 0) {\n\t\t\tvec[at - 1] = p - 1;\n\t\t\tADD(res, mod - loop(vec, at - 1));\n\t\t}\n\n\t\tvec[at - 1] = p;\n\t\tADD(res, loop(vec, at - 1));\n\t\treturn dp[at][vec] = res;\n\t}\n}\n\nvoid loop2(vi vec, int at) {\n\tif(at == M) {\n\t\tll l = diviser(vec);\n\t\tif(l % 2 == 0) ADD(ans, (l / 2) * loop(vec, M) % mod);\n\t\telse ADD(ans, l * loop(vec, M) % mod);\n\t\treturn;\n\t}\n\tvec.resize(at + 1);\n\trep(i, 0, vp[at].sec + 1) {\n\t\tvec[at] = i;\n\t\tloop2(vec, at + 1);\n\t}\n}\n\nvoid solve() {\n\tcin >> N >> K;\n\tans = 0;\n\tll n = N;\n\tfor(int i = 2; i * i <= n; i++) {\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\t\t\tP[i]++;\n\t\t}\n\t}\n\tif(n != 1) P[n]++;\n\n\tvp = vector<pi>(all(P));\n\tM = sz(vp);\n\n\n\tloop2({}, 0);\n\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\n#define LL long long\nusing namespace std;\nconst int mo=1e9+7;\nint n,k,w[N],lw,f[N],ans;\nLL fpm(LL x,LL y){ LL s=1; while(y){ if(y&1) s=(s*x)%mo; y>>=1,x=(x*x)%mo;} return s;}\nint main()\n{\n\tint i,j;\n\tcin>>n>>k;\n\tfor(i=1;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\tw[++lw]=i;\n\t\t\tif(i*i!=n) w[++lw]=n/i;\n\t\t  }\n\tsort(w+1,w+lw+1);\n\tfor(i=1;i<=lw;i++){\n\t\tf[i]=fpm(k,(w[i]+1)/2);\n\t\tfor(j=1;j<i;j++)\n\t\t\tif(w[i]%w[j]==0)\n\t\t\t\tf[i]=(f[i]-f[j]+mo)%mo;\n\t\tif(w[i]%2==0)\n\t\t\tans=(ans+1LL*f[i]*(w[i]/2))%mo;\n\t\telse\n\t\t\tans=(ans+1LL*f[i]*w[i])%mo;\n\t  }\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<int MOD>\nstruct ModInt {\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int getInt() const { return (int)x; }\n    template<class T> T get() const { return (T)x; }\n    inline int mod() const { return MOD; }\n    ModInt(int y=0) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % (unsigned long long)MOD; else x = y; }\n    ModInt &operator+=(const ModInt &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &y) { if ((x += MOD - y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &y) { x = (unsigned long long)x * y.x % (unsigned long long)MOD; return *this; }\n    ModInt &operator/=(const ModInt &y) { x = (unsigned long long)x * y.inv().x % (unsigned long long)MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n};\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nMint operator+(Mint x, const Mint &y) { if ((x.x += y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator-(Mint x, const Mint &y) { if ((x.x += x.mod() - y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator*(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.x % (unsigned long long)x.mod(); return x; }\nMint operator/(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.inv().x % (unsigned long long)x.mod(); return x; }\nbool operator<(const Mint &x, const Mint &y) { return x.x < y.x; }\nbool operator==(const Mint &x, const Mint &y) { return x.x == y.x; }\nbool operator!=(const Mint &x, const Mint &y) { return x.x != y.x; }\n\nint N, K;\nMint A[60];\nint main() {\n    scanf(\"%d%d\", &N, &K);\n    vector<int> D;\n    for (int i=1; i*i<=N; i++) {\n\tif (N % i == 0) {\n\t    D.push_back(i);\n\t    if (i*i < N) D.push_back(N / i);\n\t}\n    }\n\n    Mint ans = 0;\n    sort(D.begin(), D.end());\n    for (int i=D.size(); i--;) {\n\tMint g = Mint(K).pow((D[i]+1)/2);\n\tMint t = (D[i] % 2? D[i] - A[i]: D[i] / 2 - A[i]);\n\tans += t * g;\n\tREP (j, i) {\n\t    if (D[i] % D[j] == 0) A[j] += t;\n\t}\n    }\n\n    printf(\"%d\\n\", ans.getInt());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int MOD = 1e9+7;\nconst int MAXV = 2048;\nint ipow(int a, int b)\n{\n    int res = 1;\n    while(b)\n    {\n        if(b&1) res = (1LL*res*a)%MOD;\n        a = (1LL*a*a)%MOD;\n        b /= 2;\n    }\n    return res;\n}\nint solve(int N, int K)\n{\n    int divisor[MAXV];\n    int value[MAXV];\n    int count = 0;\n    {\n        int i;\n        for(i=1; i*i<N; ++i)\n            if(N%i==0)\n                divisor[count++] = i;\n        if(i*i==N) divisor[count++] = i;        \n        for(--i; i>0; --i)\n            if(N%i==0)\n                divisor[count++] = N/i;     \n    }\n    for(int i=0; i<count; ++i)\n    {\n        value[i] = ipow(K, (divisor[i]+1)/2);\n        for(int j=0; j<i; ++j)\n            if(divisor[i]%divisor[j] == 0)\n            {\n                value[i] -= value[j];\n                if(value[i] < 0) value[i] += MOD;\n            }\n    }\n    int ans = 0;\n    for(int i=0; i<count; ++i)\n    {\n        if(divisor[i] % 2 == 0) divisor[i] /= 2;\n        ans = (ans + 1LL * value[i] * divisor[i]) % MOD;\n    }\n    return ans;\n}\n\n\nint main()\n{\n    int N, K;\n    scanf(\"%d%d\", &N, &K);\n    printf(\"%d\\n\", solve(N, K));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nmap<int,int>mp;\nconst int p = 1000000007;\nint pw(int x,int y)\n{\n    int lst=1;\n    while(y)\n    {\n        if(y&1)lst=1LL*lst*x%p;\n        y>>=1;\n        x=1LL*x*x%p;\n    }\n    return lst;\n}\nint yin[100005],cnt;\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i*i<=n;i++)\n    {\n        if(n%i==0)\n        {\n            yin[++cnt]=i;\n            if(i*i!=n)yin[++cnt]=n/i;\n        }\n    }\n    int ans=0;\n    sort(yin+1,yin+cnt+1);\n    for(int i=1;i<=cnt;i++)\n    {\n        int tmp=pw(k,(yin[i]-1)/2+1);\n        if(i!=1)\n        for(int j=1;j*j<=yin[i];j++)\n        {\n            if(yin[i]%j==0)\n            {\n                tmp-=mp[j];\n                if(j*j!=yin[i]&&j!=1)tmp-=mp[yin[i]/j];\n                tmp=(tmp%p+p)%p;\n            }\n        }\n        mp[yin[i]]=tmp;\n        if(yin[i]%2==1)ans+=1LL*tmp*yin[i]%p;\n        else ans+=1LL*tmp*yin[i]%p*500000004%p;\n        ans%=p;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\n#define Mo 1000000007\n\nusing namespace std;\nint i,j,m,n,p,k,F[N],Q[N],ans;\nconst int inv2=500000004;\nvoid jian(int &x,int y)\n{\n\t\tx-=y; if (x<0) x+=Mo;\n}\nvoid jia(int &x,int y)\n{\n\t\tx+=y; if (x>=Mo) x-=Mo;\n}\nint power(int x,int y)\n{\n\t\tint sum=1;\n\t\tfor (;y;y>>=1)\n\t\t{\n\t\t\t\tif (y&1) sum=1ll*sum*x%Mo;\n\t\t\t\tx=1ll*x*x%Mo;\n\t\t}\n\t\treturn sum;\n}\nint main()\n{\t\n\tscanf(\"%d%d\",&n,&k);\n\tfor (i=1;i*i<=n;++i) if (n%i==0)\n\t{\n\t\t\tQ[++Q[0]]=i;\n\t\t\tif (i*i!=n) Q[++Q[0]]=n/i;\n\t}\n\tsort(Q+1,Q+Q[0]+1);\n\tfor (i=1;i<=Q[0];++i)\n\t{\n\t\t\tF[i]=power(k,(Q[i]+1)/2);\n\t\t\tfor (j=1;j<i;++j) if (Q[i]%Q[j]==0) jian(F[i],F[j]); \n\t}\n\tfor (i=1;i<=Q[0];++i)\n\t{\n\t\t\tif (n&1||Q[i]%2==1)\tjia(ans,1ll*F[i]*Q[i]%Mo);\n\t\t\telse jia(ans,1ll*F[i]*inv2%Mo*Q[i]%Mo);\t \n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n\nlong long bipow(long long K, int p){\n    if(p == 0) return 1;\n    if(p % 2 == 0){\n        long long tmp = (K * K) % MOD;\n        return bipow(tmp, p / 2) % MOD;\n    }else\n        return (K * bipow(K, p-1)) % MOD;\n}\n\nvector<long long> divs(int n){\n    vector<long long> ret;\n    for(int i=1; i*i<=n; i++){\n        if(n % i == 0){\n            ret.push_back(i);\n            if(i * i != n) ret.push_back(n / i);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    long long N, K;\n    cin >> N >> K;\n\n    vector<long long> dv = divs(N);\n    sort(dv.begin(), dv.end());\n\n    vector<long long> num(dv.size(), 0);\n\n    num[0] = K;\n    for(int i=1; i<dv.size(); i++){\n        long long d = dv[i];\n        long long tmp1 = bipow(K, (d+1)/2);\n        long long tmp2 = 0;\n        for(int j=0; j<i; j++){\n            int d2 = dv[j];\n            if(d % d2 == 0) tmp2 = (tmp2 + num[j]) % MOD;\n        }\n        num[i] = (tmp1 - tmp2 + MOD) % MOD;\n    }\n    long long ans = 0;\n    for(int i=0; i<dv.size(); i++){\n        long long d = dv[i];\n        if(d % 2 == 0)\n            ans += (num[i] * d / 2) % MOD;\n        else\n            ans += (num[i] * d) % MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=10000,mo=1e9+7;\n\ntypedef long long LL;\n\nint n,m,tot,p[N],f[N],Inv,ans;\n\nint quick(int x,int y)\n{\n\tif (!y) return 1;\n\tint s=quick(x,y>>1); s=(LL)s*s%mo;\n\tif (y&1) s=(LL)s*x%mo;\n\treturn s;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tInv=quick(2,mo-2);\n\tfor (int i=1;i*i<=n;i++) if (n%i==0)\n\t{\n\t\tp[tot++]=i;\n\t\tif (i*i<n) p[tot++]=n/i;\n\t}\n\tsort(p,p+tot);\n\tfor (int i=0;i<tot;i++)\n\t{\n\t\tf[i]=quick(m,(p[i]+1)/2);\n\t\tfor (int j=0;j<i;j++) if (p[i]%p[j]==0) f[i]=(f[i]-f[j])%mo;\n\t\tif (f[i]<0) f[i]+=mo;\n\t\tif (p[i]&1) ans=(ans+(LL)f[i]*p[i])%mo;\n\t\telse ans=(ans+(LL)f[i]*p[i]%mo*Inv)%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint pow_mod(int x, int k) {\n\tint ans = 1;\n\twhile (k) {\n\t\tif (k&1) ans = 1LL * ans * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, k;\n\nint fac[222222], fn, dp[222222];\n\nint cal() {\n\tfn = 0;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tfac[++fn] = i;\n\t\t\tfac[++fn] = n / i;\n\t\t}\n\t}\n\tsort(fac + 1, fac + fn + 1);\n\tfn = unique(fac + 1, fac + 1 + fn) - fac - 1;\n\tfor (int i = 1; i <= fn; i++) {\n\t\tif (n % 2 == 0 && n / 2 % fac[i] == 0) dp[i] = pow_mod(k, fac[i]);\n\t\telse dp[i] = pow_mod(k, (fac[i] + 1) / 2);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (fac[i] % fac[j] == 0) {\n\t\t\t\tdp[i] = (dp[i] - dp[j] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= fn; i++) ans = (ans + 1LL * dp[i] * fac[i] % MOD) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tprintf(\"%d\\n\", cal());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(ll n,ll k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=Pmod((x+1)/2,k);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(mod+tmp-v[j].second)%mod;\n\t\t\t}\n\t\t}\n\t\tv[i].second=tmp;\n\t\tans[x%2]+=tmp*x%(mod*(ll)10);\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[arc064] F - Rotated Palindromes\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n#define ALL(c) (c).begin(), (c).end()\n\nconst int MAX_D = 1400;\nconst int MOD = 1e9 + 7;\n\nclass gf {\npublic:\n    int n;\n    gf() : n(0) {}\n    gf(int n) : n(n < 0 ? n % MOD + MOD : n % MOD) {}\n    gf operator+(gf x) { return gf((n + x.n) % MOD); }\n    gf operator-(gf x) { return gf((n - x.n + MOD) % MOD); }\n    gf operator*(gf x) { return gf((1LL * n * x.n) % MOD); }\n    gf& operator+=(gf x) { return *this = (*this + x); }\n    gf& operator-=(gf x) { return *this = (*this - x); }\n    gf& operator*=(gf x) { return *this = (*this * x); }\n};\n\nint N, K;\ngf dp[MAX_D];\n\nvector<int> divisors(int n) {\n    vector<int> ret;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            if (i * i != n) {\n                ret.push_back(n / i);\n            }\n        }\n    }\n    return ret;\n}\n\nll mod_pow(ll a, ll n, ll m) {\n    ll ret = 1;\n    for (; n > 0; n >>= 1) {\n        if (n & 1) {\n            (ret *= a) %= m;\n        }\n        (a *= a) %= m;\n    }\n    return ret;\n}\n\nll solve() {\n    auto divs = divisors(N);\n    int D = divs.size();\n    sort(divs.begin(), divs.end());\n\n    for (int i = 0; i < D; i++) {\n        dp[i] = mod_pow(K, (divs[i] + 1) / 2, MOD);\n        for (int j = 0; j < i; j++) {\n            if (divs[i] % divs[j] == 0) {\n                dp[i] -= dp[j];\n            }\n        }\n    }\n\n    gf ans = 0;\n    for (int i = 0; i < D; i++) {\n        if (divs[i] % 2) {\n            ans += dp[i] * divs[i];\n        } else {\n            ans += dp[i] * (divs[i] / 2);\n        }\n    }\n\n    return ans.n;\n}\n\nint main() {\n    cin >> N >> K;\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first\n# define y second \n# define mp make_pair\n\n# define pb push_back\n# define vec vector\n# define sz(a) int(a.size())\n\n# define y1 kek_y1                  \n# define left kek_left\n# define right kek_right\n\nusing namespace std;\n\ntypedef long  long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int Sz = 1110111;\nconst int Mod = (int)1e9 + 7;\nconst int MX = (1<<30) - 1; // 1e9\nconst ll MXLL = (1ll<<62) - 1;        \n\ninline void Read_rap() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n}\nvoid files (string name) {\n\tif (fopen ((name+\".in\").c_str(), \"r\")) {\n\t\tfreopen ((name+\".in\").c_str(), \"r\", stdin);\n\t\tfreopen ((name+\".out\").c_str(), \"w\", stdout);\n\t}\n}                       \nint n;\n\nint x[Sz], y[Sz];\n   \nint r[Sz];\n\nconst int N = 1003;\n\nld dist[N][N];\n\nint main()\n{\n\tRead_rap();\n\n\tcin >> x[1] >> y[1];\n\tcin >> x[2] >> y[2];\n\tcin >> n;\n\tfor (int i = 3; i <= n+2; i++) \n\t\tcin >> x[i] >> y[i] >> r[i];\n        \t\n    n += 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tld D = sqrt ( (x[i] - x[j]) * 1ll * (x[i] - x[j]) + (y[i] - y[j]) * 1ll * (y[i] - y[j]));\n\t\t\tdist[i][j] = max ((ld)0.0, D - r[i] - r[j]);\n\t\t}\n\t}                    \n\tvec<bool> used(n + 1, 0);\n\tvec<ld> d(n + 1, 4*(ld)MX);\n\td[1] = 0;    \n\tfor (int t = 0; t < n-1; t++) {\n\t\tint v = -1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!used[i] && (v == -1 || d[v] > d[i]))\n\t\t\t\tv = i;\n\t\t}                   \n\t\tused[v] = 1;\n\t\tfor (int to = 1; to <= n; to++) {\n\t\t\t//if (!used[to])\n\t\t\t\td[to] = min (d[to], d[v] + dist[v][to]);\n\t\t}\n\t}\n\tcout << fixed <<setprecision (10) << d[2];\n\n\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n//Coded by Z....\t\n    "
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int hsz = 1e7 + 39, mod = 1e9 + 7;\nint n, k, ans;\nmap<int, bool> vis;\nmap<int, int> pre;\n\nstruct hash_table {\n    int sz, hd[hsz + 5], nxt[hsz + 5], key[hsz + 5], val[hsz + 5];\n    \n    void inline ins(int id, int w) {\n        int hid = id % hsz;\n        for (int i = hd[hid]; i; i = nxt[i]) {\n            if (id == key[i])  return;\n        }\n        ++sz;\n        key[sz] = id;\n        val[sz] = w;\n        nxt[sz] = hd[hid];\n        hd[hid] = sz;\n    }\n    \n    int inline qry(int id) {\n        int hid = id % hsz;\n        for (int i = hd[hid]; i; i = nxt[i]) {\n            if (id == key[i])  return val[i];\n        }\n        return -1;\n    }\n};\nhash_table dat;\n\nint inline qpow(int a, int p) {\n    int res = 1;\n    for (; p; p >>= 1) {\n        if (p & 1) {\n            res = (num) res * a % mod;\n        }\n        a = (num) a * a % mod;\n    }\n    return res;\n}\n\nvoid inline upd(int &a, int b) {\n    a += b;\n    if (a >= mod) {\n        a -= mod;\n    }\n    if (a < 0) {\n        a += mod;\n    }\n}\n\nint solve(int a) {\n    int res = dat.qry(a);\n    if (res != -1)  return res;\n    if (a == 1) {\n        res = k % mod;\n        dat.ins(1, res);\n        return res;\n    }\n    res = 0;\n    for (int b = 1; b * b <= a; ++b) {\n        if (a % b)  continue;\n        int bb = a / b;\n        upd(res, -solve(b));\n        if (b != bb && bb != a) {\n            upd(res, -solve(bb));\n        }\n    }\n    upd(res, qpow(k, (a - 1) / 2 + 1));\n    dat.ins(a, res);\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    solve(n);\n    cont (i, dat.sz) {\n        int a = dat.key[i], cnt = dat.val[i], cur = (num) a * cnt % mod;\n        upd(ans, (a & 1) ? cur : (num) cur * qpow(2, mod - 2) % mod);\n    }\n    cout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nint n,K,p[105],c[105],cnt,a[5005],top,f[5005],ans=0;\nvoid dfs(int s,int x)\n{\n\tif(s>cnt){a[++top]=x;return;}\n\tfor(int k=0;k<=c[s];++k) dfs(s+1,x),x*=p[s];\n}\ninline int pow(int x,int k)\n{\n\tint sum=1;\n\tfor(;k;k>>=1,x=1LL*x*x%mod) if(k&1) sum=1LL*sum*x%mod;\n\treturn sum;\t\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&K);int t=n;\n\tfor(int i=2;i*i<=t;++i) if(t%i==0)\n\t{\n\t\tp[++cnt]=i;\n\t\twhile(t%i==0) t/=i,++c[cnt];\n\t}\n\tif(t>1) p[++cnt]=t,c[cnt]=1;\n\tdfs(1,1);sort(a+1,a+top+1);\n\tfor(int i=1;i<=top;++i)\n\t{\n\t\tf[i]=pow(K,(a[i]+1)>>1);\n\t\tfor(int j=1;j<i;++j) if(a[i]%a[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n\t\tans=(ans+1LL*f[i]*((a[i]&1)?a[i]:a[i]/2))%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\ninline int qpow(int bas,int pw)\n{\n\tint ret=1; for(;pw;pw>>=1,bas=1ll*bas*bas%mod)\n\tif(pw&1) ret=1ll*ret*bas%mod; return ret;\n}\ninline void Add(int &x,int y)\n{\n\tx+=y; if(x>=mod) x-=mod;\n\tif(x<0) x+=mod;\n}\nint n,k,di[10010],F[10010];\nint main()\n{\n\tn=read(); k=read();\n\tfor(int i=1;i*i<=n;i++) if(n%i==0)\n\t{\n\t\tdi[++di[0]]=i; if(i*i!=n)\n\t\tdi[++di[0]]=n/i;\n\t}\n\tsort(di+1,di+1+di[0]);\n\tfor(int i=1;i<=di[0];i++)\n\t{\n\t\tF[i]=qpow(k,(di[i]+1)/2);\n\t\tfor(int j=1;j<i;j++) if(di[i]%di[j]==0)\n\t\t\tAdd(F[i],-F[j]);\n\t}\n\tint Ans=0;\n\tfor(int i=1;i<=di[0];i++)\n\t\tif(di[i]&1) Add(Ans,1ll*di[i]*F[i]%mod);\n\t\telse Add(Ans,1ll*di[i]/2*F[i]%mod);\n\tcout << Ans << endl;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#define Rep(i, x, y) for (int i = x; i <= y; i ++)\n#define Dwn(i, x, y) for (int i = x; i >= y; i --)\n#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)\n#define ev g[i].y\n#define eps 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N = 10005, mod = 1000000007;\nint n, m, k, a[N];\nll f[N], ans;\n// struct arr { int x; };\nll mypow(ll x, int y) {\n\tll z = 1;\n\twhile (y) {\n\t\tif (y & 1) (z *= x) %= mod;\n\t\ty >>= 1; (x *= x) %= mod;\n\t}\n\treturn z;\n}\nint main()\n{\n\tscanf (\"%d%d\", &n, &k);\n\tfor (int i = 1; i * i <= n; i ++) {\n\t\tif (n % i == 0) {\n\t\t\ta[++ m] = i;\n\t\t\tif (i * i != n) {\n\t\t\t\ta[++ m] = n / i;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a + 1, a + m + 1);\n\tRep(i, 1, m) {\n\t\tint x = a[i];\n\t\tf[i] = mypow(k, (x + 1) / 2);\n\t\tRep(j, 1, i - 1) if (x % a[j] == 0) f[i] = (f[i] - f[j] + mod) % mod;\n\t\t// cout << f[i]<<endl;\n\t\tif (x & 1) ans += f[i] * x;\n\t\telse ans += f[i] * x / 2;\n\t}\n\tprintf(\"%lld\\n\", ans % mod);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define inv2 500000004\n\nlong long modpow(long long n, long long r) {\n    n %= mod, r %= (mod-1);\n    if (!n) return 0;\n    long long ret = 1; long long tmp = n;\n    while (r != 0) {\n        if (r % 2) ret *= tmp;\n        tmp *= tmp; tmp %= mod; ret %= mod;\n        r /= 2;\n    }\n    return ret;\n}\n\nauto getdiv = [&](long long n) {\n    vector<long long> g;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            g.emplace_back(i);\n            if (n != i * i) g.emplace_back(n / i);\n        }\n    }\n    sort(g.begin(), g.end());\n    return g;\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    long long n, k; cin >> n >> k;\n    auto g = getdiv(n);\n    int sz = g.size();\n    vector<long long> w(sz, 0);\n    auto f = [&](long long x) {\n        return modpow(k, (x+1)/2);\n    };\n    for (int i = 0; i < sz; i++) {\n        w[i] += f(g[i]); w[i] %= mod;\n        for (int j = i+1; j < sz; j++) {\n            if (g[j] % g[i] == 0) {\n                w[j] += mod - w[i];\n                w[j] %= mod;\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i = 0; i < sz; i++) {\n        if (g[i] % 2 == 0) w[i] = w[i] * inv2 % mod;\n        ans += w[i] * g[i] % mod;\n    }\n    cout << ans % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3005;\nconst int MOD=1000000007;\n\nint n,k,tot,a[N],f[N];\n\nint ksm(int x,int y)\n{\n\tint ans=1;\n\twhile (y)\n\t{\n\t\tif (y&1) ans=(LL)ans*x%MOD;\n\t\tx=(LL)x*x%MOD;y>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t{\n\t\t\ta[++tot]=i;\n\t\t\tif (i*i<n) a[++tot]=n/i;\n\t\t}\n\tsort(a+1,a+tot+1);\n\tint ny2=ksm(2,MOD-2),ans=0;\n\tfor (int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=ksm(k,(a[i]+1)/2);\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]%a[j]==0) (f[i]+=MOD-f[j])%=MOD;\n\t\tif (a[i]&1) (ans+=(LL)f[i]*a[i]%MOD)%=MOD;\n\t\telse (ans+=(LL)f[i]*a[i]%MOD*ny2%MOD)%=MOD;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nint n, k;\nmap<int, ll> f;\n\nll add(ll x, ll y) {\n\treturn (x + y + mod) % mod;\n}\n\nvoid Add(ll &x, ll y) {\n\tx = (x + y + mod) % mod;\n}\n\nll mul(ll x, ll y) {\n\treturn (x * y) % mod;\n}\n\nvoid Mul(ll &x, ll y) {\n\tx = (x * y) % mod;\n}\n\nll q_pow(ll x, int y) {\n\tll ans = 1;\n\tfor(; y; y >>= 1) {\n\t\tif(y & 1) Mul(ans, x);\n\t\tMul(x, x);\n\t}\n\treturn ans;\n}\n\nll get(int x) {\n\tif(!f.count(x)) {\n\t\tint len = sqrt(x);\n\t\tll pos = q_pow(k, (x / 2) + (x & 1));\n\t\tfor(int i = 2; i <= len; ++i) {\n\t\t\tif(x % i) continue;\n\t\t\tAdd(pos, -get(i));\n\t\t\tif(i * i != x) Add(pos, -get(x / i));\n\t\t}\n\t\tif(x != 1) Add(pos, -k);\n\t\t// printf(\"%d %lld\\n\", x, pos);\n\t\treturn f[x] = pos;\n\t}\n\telse return f[x];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tint len = sqrt(n);\n\tll ans = 0;\n\tfor(int i = 1; i <= len; ++i) {\n\t\tif(n % i) continue;\n\t\tif(i & 1) Add(ans, mul(i, get(i)));\n\t\telse Add(ans, mul(i / 2, get(i)));\n\t\tif(i * i != len) {\n\t\t\tint now = n / i;\n\t\t\tif(now & 1) Add(ans, mul(now, get(now)));\n\t\t\telse Add(ans, mul(now / 2, get(now)));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int mo=1e9+7;\nconst int maxn=23333;\n\nint n,k,m,d[maxn],dp[maxn],Ans;\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d%d\",&n,&k);\n\tfor (i=1;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t{\n\t\t\td[++m]=i;\n\t\t\tif (i*i!=n) d[++m]=n/i;\n\t\t}\n\tsort(d+1,d+1+m);\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tdp[i]=power(k,(d[i]+1)/2);\n\t\tfor (j=1;j<i;j++)\n\t\t\tif (d[i]%d[j]==0)\n\t\t\t\t(dp[i]+=mo-dp[j])%=mo;\n\t\tif (d[i]&1)\n\t\t\t(Ans+=(LL)dp[i]*d[i]%mo)%=mo;\n\t\telse\n\t\t\t(Ans+=(LL)dp[i]*(d[i]/2)%mo)%=mo;\n\t}\n\tprintf(\"%d\\n\",Ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\tmu[prod] = m;\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\tfor(auto && e : divisor) { gg[e] = g(e); }\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nsigned main(){\n\tint n=read(),m=n,k=read();\n\tvi pri;\n\tfor(int i=2;i*i<=n;i++)\n\t\tif(n%i==0){\n\t\t\tpri.PB(i);\n\t\t\twhile(n%i==0)n/=i;\n\t\t}\n\tif(n>1)pri.PB(n);\n\tvi p,q;\n\tREP(bits,1<<pri.size()){\n\t\tint x=1,y=1;\n\t\tREP(i,pri.size())\n\t\t\tif((bits>>i)&1){\n\t\t\t\tx*=pri[i];\n\t\t\t\ty*=-1;\n\t\t\t}\n\t\tp.PB(x);\n\t\tq.PB(y);\n\t}\n\tint ans=0;\n\tconst auto f=[&](int d){\n\t\treturn modPow(k,(d+1)/2);\n\t};\n\tconst auto g=[&](int d){\n\t\tint res=0;\n\t\tREP(i,p.size())\n\t\t\tif(d%p[i]==0){\n\t\t\t\tif(q[i]==1)\n\t\t\t\t\tadd(res,f(d/p[i]));\n\t\t\t\telse\n\t\t\t\t\tsub(res,f(d/p[i]));\n\t\t\t}\n\t\treturn res;\n\t};\n\tconst auto h=[&](int d){\n\t\treturn (d&1)?d:d/2;\n\t};\n\tfor(int i=1;i*i<=m;i++)\n\t\tif(m%i==0){\n\t\t\tadd(ans,h(i)*g(i));\n\t\t\tif(i<m/i)\n\t\t\t\tadd(ans,h(m/i)*g(m/i));\n\t\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\ntypedef long double f3;\nint la;\nll alp[]={2,3,5,7,11,13,17,19,23,29},a[233];\nll ch(ll x,ll y,ll p) {\n\tx%=p, y%=p; return (x*y-ll((f3(x)*y+0.5)/p)*p+p)%p;\n}\nll qp(ll x,ll y,ll p) {ll re=1;for(;y;y>>=1,x=ch(x,x,p))if(y&1)re=ch(re,x,p);return re;}\nll gcd(ll x,ll y) {return y?gcd(y,x%y):x;}\nbool check(ll a,ll n,ll r,ll s) {\n\tll x=qp(a,r,n),lst=x;\n\tint i;\n\tfor(i=1;i<=s;i++,lst=x) {\n\t\tx=ch(x,x,n);\n\t\tif(x==1&&lst!=1&&lst!=n-1) return 0;\n\t}return x==1;\n}\nbool MR(ll n) {\n\tll r=n-1,s=0;\n\tfor(;!(r&1);r>>=1,s++) ;\n\tint i;\n\tfor(i=0;i<8;i++) {\n\t\tif(alp[i]==n) return 1;\n\t\tif(!check(alp[i],n,r,s)) return 0;\n\t}return 1;\n}\nll PR(ll n,ll c) {\n\tll x=rand()%(n-1),y=x,p;\n\tfor(p=1;p==1;) {\n\t\tx=(ch(x,x,n)+c)%n, y=(ch(y,y,n)+c)%n, y=(ch(y,y,n)+c)%n;\n\t\tp=gcd(x>y?x-y:y-x,n);\n\t}return p;\n}\nvoid solve(ll n) {\n\tif(n<=1) return ;\n\tif(!(n&1)) {\n\t\ta[++la]=2; while(!(n&1)) n>>=1;\n\t}\n\tif(n<=1) return ;\n\tif(MR(n)) {a[++la]=n; return ;}\n\tll t=n;\n\tfor(;t==n;t=PR(n,rand()%(n-1)));\n\tsolve(t);\n\twhile(n%t==0) n/=t; \n\tsolve(n);\n}\nll n,K,mod,ans;\nll qp2(ll x,ll y) {ll re=1;x%=mod;for(;y;y>>=1,x=x*x%mod) if(y&1) re=re*x%mod; return re;}\nll g(ll x) {return qp2(K,((x+1)>>1));}\nll h(ll x) {return ((x&1)?x:(x>>1))%mod;}\nvoid dfs(int dep,ll now,ll mud) {\n\tif(dep==la+1) {\n\t\tif(((n/now)&1)&&(!(now&1))) return ;\n\t\tans=(ans+g(n/now)*h(n/now)%mod*mud)%mod;\n\t\treturn ;\n\t}\n\tdfs(dep+1,now,mud);\n\tmud=mud*(mod+1-a[dep]%mod)%mod;\n\tll nxt=now*a[dep];\n\tfor(;n%nxt==0;) {\n\t\tdfs(dep+1,nxt,mud); nxt=nxt*a[dep];\n\t}\n}\nint main() {\n\t\tans=0;\n\t\tscanf(\"%lld%lld\",&n,&K);\n  mod=1000000007;\n\t\tla=0; solve(n);\n\t\tsort(a+1,a+la+1); la=unique(a+1,a+la+1)-a-1;\n\t\tdfs(1,1,1);\n\t\tprintf(\"%lld\\n\",(ans+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll M = 1e9+7;\nconst int MN = 100100;\nvl fac;\nunordered_map<ll,ll> dp;\ninline ll mul(ll a, ll b) {return (a*b)%M;}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {\n\t\t\tac = mul(ac,b);\n\t\t}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll n,k;\nll ds(ll v) {\n\tif(dp.find(v) != dp.end()) {return dp[v];}\n\tll tot = bp(k,(v+1)/2);\n\tfor(int i=0;i<fac.size();i++) {\n\t\tif(fac[i] >= v) break;\n\t\tif(!(v%fac[i])) {\n\t\t\t\ttot -= ds(fac[i]);\n\t\t}\n\t}\n\ttot = ((tot%M)+M)%M;\n\treturn dp[v] = tot;\n}\nconst ll H = 500000004;\nint main() {\n\tscanf(\"%lld %lld\",&n,&k);\n\tfor(int i=1;i*i<=n;i++) {\n\t\tif(!(n%i)) {fac.push_back(i);\n\t\t\tif(i != n/i) {\n\t\t\tfac.push_back(n/i);}}\n\t}\n\tsort(fac.begin(),fac.end());\n\tll res = 0;\n\tfor(int i=0;i<fac.size();i++) {\n\t\tif(fac[i]&1) {\n\t\t\tres += ds(fac[i])*fac[i];\n\t\t} else {\n\t\t\tres += ((ds(fac[i])*H)%M)*fac[i];\n\t\t}\n\t\t//printf(\"oof %d = %lld\\n\",fac[i],ds(fac[i]));\n\t\tres %= M;\n\t}\n\tres = ((res%M)+M)%M;\n\tprintf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 3000;\nconst int moder = 1e9 + 7;\n\nint power_mod(int a, int index){\n\tint ans = 1;\n\twhile (index){\n\t\tif (index & 1)\n\t\t\tans = 1ll * ans * a % moder;\n\t\ta = 1ll * a * a % moder;\n\t\tindex >>= 1;\n\t}\n\treturn ans;\n}\n\nstd::vector <int> fact;\nint num[N];\n\nint main(){\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tint cnt = 0;\n\tfor (int i = 1; i * i <= n; ++ i){\n\t\tif (!(n % i)){\n\t\t\tfact.push_back(i);\n\t\t\tfact.push_back(n / i);\n\t\t}\n\t}\n\tsort(fact.begin(), fact.end());\n\tfact.erase(unique(fact.begin(), fact.end()), fact.end());\n\tint ans = 0;\n\tfor (int i = 0; i < fact.size(); ++ i){\n\t\tnum[i] = power_mod(k, (fact[i] + 1) / 2);\n\t\tfor (int j = 0; j < i; ++ j){\n\t\t\tif (!(fact[i] % fact[j])){\n\t\t\t\tnum[i] = (num[i] - num[j] + moder) % moder;\n\t\t\t}\n\t\t}\n\t\tif (fact[i] & 1){\n\t\t\tans = (ans + 1ll * num[i] * fact[i]) % moder;\n\t\t}\n\t\telse{\n\t\t\tans = (ans + 1ll * num[i] * fact[i] % moder * power_mod(2, moder - 2)) % moder;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nlong long modpow(long long n, int k) {\n\tlong long r = 1;\n\twhile (k > 0) {\n\t\tif (k & 1) r = (r * n) % mod;\n\t\tn = (n * n) % mod;\n\t\tk >>= 1;\n\t}\n\treturn r;\n}\nint main() {\n\tint N, K;\n\tcin >> N >> K;\n\tvector<int> D;\n\tfor (int i = 1; i*i <= N; ++i) if (N % i == 0) {\n\t\tD.push_back(i);\n\t\tif (N/i > i) D.push_back(N/i);\n\t}\n\tsort(D.begin(), D.end());\n\tmap<int, int> num;\n\tlong long res = 0;\n\tfor (int i = 0; i < D.size(); ++i) {\n\t\tint d = D[i];\n\t\tlong long r = modpow(K, (d + 1) / 2);\n\t\tfor (int j = 0; j < i; ++j) if (d % D[j] == 0) {\n\t\t\tr = (r - num[D[j]] + mod) % mod;\n\t\t}\n\t\tnum[d] = r;\n\t\tif (d % 2) {\n\t\t\tres = (res + r * d) % mod;\n\t\t} else {\n\t\t\tres = (res + r * (d / 2)) % mod;\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, ans, k; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint fpow(int x, int y)\n{\n\tint res = 1; \n\tfor( ; y; y >>= 1, x = 1ll * x * x % mod)\n\t\tif(y & 1) res = 1ll * res * x % mod; \n\treturn res; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (), k = (n + 1) / 2; \n\tans = (1ll * fpow(m, k) * k % mod - 1ll * m * (k - 1 + mod) % mod + mod) % mod; \n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\ntypedef vector<int> vi;\n\nconst int mod = 1e9 + 7;\nint n, K, ans;\nvi prime, dp;\n\nint fpow(int a, int m) {\n    int res = 1;\n    for(; m; m >>= 1, a = (1LL * a * a) % mod) if(m & 1) res = (1LL * res * a) % mod;\n    return res;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n >> K;\n    for (int i = 1; i * i <= n; ++i) {\n        if(n % i == 0) {\n            prime.pb(i);\n            if(i < n / i) prime.pb(n / i);\n        }\n    }\n    sort(prime.begin(), prime.end() );\n    dp.resize(prime.size() );\n\n    for(int i = 0; i < prime.size(); ++i) {\n        dp[i] = fpow(K, (prime[i] + 1) >> 1);\n        for(int j = 0; j < i; ++j) {\n            if( (prime[i] % prime[j]) == 0) dp[i] -= dp[j], dp[i] %= mod;\n        }\n        ans += (1LL * (prime[i] & 1 ? prime[i] : prime[i] >> 1) * dp[i]) % mod;\n        ans %= mod;\n    }\n\n    cout << (ans + mod) % mod;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { val += val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\nint n, k;\nmap<int, mint> mem;\nmint f(int d) {\n    if(not mem.count(d)) {\n        mint& ans = mem[d];\n        ans = mint(k) ^ ((d + 1) / 2);\n        if(d != 1) {\n            ans -= f(1);\n            for(int dd = 2; dd * dd <= d; dd++) {\n                if(d % dd == 0) {\n                    ans -= f(dd);\n                    if(d / dd != dd) {\n                        ans -= f(d / dd);\n                    }\n                }\n            }\n        }\n    }\n    return mem[d];\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> k;\n    mint ans = 0;\n    auto multiplier = [](int d) { return d % 2 ? d : d / 2; };\n    for(int d = 1; d * d <= n; d++) {\n        if(n % d == 0) {\n            ans += f(d) * multiplier(d);\n            if(n / d != d) {\n                ans += f(n / d) * multiplier(n / d);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint n, k;\n\nint binPow (int x, int y) {\n    int ans = 1;\n    while (y) {\n        if (y & 1) ans = (ans * x) % mod;\n        x = (x * x) % mod;\n\n        y >>= 1;\n    }\n\n    return ans;\n}\n\nvoid input(){\n    scanf(\"%lld %lld\", &n, &k);\n}\n\nvoid solve(){\n    if (n == 1) {\n        printf(\"%lld\", k);\n        return;\n    }\n\n    if (n % 2 == 1) {\n        int ans = binPow(k, n / 2 + 1);\n        ans = ans + binPow(k, n / 2) * (n / 2) % mod * binPow(k, n / 2) % mod;\n        ans %= mod;\n        ans = (ans + mod) % mod;\n        printf(\"%lld\", ans);\n    }\n    else {\n        int ans = 0;\n        ans = ans + binPow(k, n / 2) * ((n - 2) / 2 + 1) % mod;\n        ans = ans - k * (n - 2) / 2; ans %= mod;\n        ans = (ans + mod) % mod;\n        printf(\"%lld\", ans);\n    }\n}\n\nsigned main(){\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nll n, m;\n\nvector<ll> a;\nvector<ll> p;\n\nll s[10000];\n\nll modpow(ll x, ll y)\n{\n\tll ans=1;\n\twhile(y)\n\t{\n\t\tif(y%2) ans*=x, ans%=MOD;\n\t\tx*=x, x%=MOD, y/=2;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>m;\n\tint flag=0;\n\tif(n%2 == 0) n/=2, flag=1;\n\tfor(i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i == 0)\n\t\t{\n\t\t\ta.push_back(i);\n\t\t\tif(i*i != n) a.push_back(n/i);\n\t\t}\n\t}\n\tsort(all(a));\n\tint t=a.size();\n\t/*int t=a.size();\n\tfor(i=1;i<t;i++)\n\t{\n\t\tfor(j=1;j<i;j++)\n\t\t{\n\t\t\tif(a[i]%a[j] == 0) break;\n\t\t}\n\t\tif(j == i) p.push_back(a[i]);\n\t}*/\n\tfor(i=0;i<t;i++)\n\t{\n\t\ts[i]=modpow(m, (flag?a[i]:1+a[i]/2));\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(a[i]%a[j] == 0) s[i]-=s[j];\n\t\t}\n\t\ts[i]%=MOD;\n\t\tif(s[i] < 0) s[i]+=MOD;\n\t}\n\tll ans=0;\n\tfor(i=0;i<t;i++)\n\t{\n\t\tans+=s[i]*a[i], ans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long i64;\nconst int MOD = 1000000007;\n\nint N, K, tot;\nint divisor[100005];\ni64 f[100005];\n\ni64 fpm(i64 x, i64 y) {\n  i64 res = 1;\n  while (y) {\n    if (y & 1) res = res * x % MOD;\n    x = x * x % MOD;\n    y >>= 1;\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &K);\n  \n  for (int i = 1; i * i <= N; ++i)\n    if (N % i == 0) {\n      divisor[++tot] = i;\n      if (N / i != i) divisor[++tot] = N / i;\n    }\n\n  sort(divisor + 1, divisor + tot + 1);\n  \n  for (int i = 1; i <= tot; ++i) {\n    f[i] = fpm(K, (divisor[i] + 1) / 2);\n    for (int j = 1; j < i; ++j)\n      if (divisor[i] % divisor[j] == 0)\n\tf[i] = (f[i] - f[j]) % MOD;\n  }\n\n  i64 res = 0;\n\n  for (int i = 1; i <= tot; ++i)\n    if (divisor[i] & 1)\n      res = (res + f[i] * divisor[i] % MOD) % MOD;\n    else\n      res = (res + f[i] * divisor[i] / 2 % MOD) % MOD;\n\n  printf(\"%lld\\n\", (res + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mod (1000000007)\n#define rv2 (500000004)\n#define MAXN (2010)\n\nint N, K;\nint d[MAXN];\n\nint powmod(int a, int b){\n\tint ret = 1;\n\twhile(b){\n\t\tif(b & 1) ret = ret * a % mod;\n\t\tb >>= 1;\n\t\ta = a * a % mod;\n\t}\n\treturn ret;\n}\n\nint get_d(int i){\n\tint ret = powmod(K, (i + 1) / 2);\n\tfor(int j = 1; j * j <= i; ++ j){\n\t\tif(i % j || j == i) continue;\n\t\tret = (ret - d[j] + mod) % mod;\n\t\tif(i / j == j || i / j == i) continue;\n\t\tret = (ret - d[i / j] + mod) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\", &N, &K);\n\tint ans = 0;\n\tfor(int i = 1; i <= N; ++ i){\n\t\tif(N % i) continue;\n\t\td[i] = get_d(i);\n\t\tif(i % 2) ans = (ans + (1ll) * d[i] * i % mod) % mod;\n\t\telse ans = (ans + (1ll) * d[i] * i % mod * rv2 % mod) % mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nconst int N=2e5+20;\nvector<ll> v;\nll n,k,dp[2500];\nll powmod(ll x,ll n)\n{\n\tll s=1;\n\twhile(n)\n\t{\n\t\tif(n&1)\n\t\t\ts=(s*x)%mod;\n\t\tn>>=1;\n\t\tx=(x*x)%mod;\n\t}\n\treturn s;\n}\nvoid init()\n{\n\tv.clear();\n\tfor(ll i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tif(i*i!=n)\n\t\t\t\tv.push_back(n/i);\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n}\nint main()\n{\n\twhile(cin>>n>>k)\n\t{\n\t\tinit();\n\t\tll ans=0;\n\t\tfor(int x=0;x<v.size();x++)\n\t\t{\n\t\t\tdp[x]=powmod(k,(v[x]+1)/2);\n\t\t\tfor(int y=0;y<x;y++)\n\t\t\t{\n\t\t\t\tif(v[x]%v[y]==0)\n\t\t\t\t\tdp[x]=(dp[x]-dp[y]+mod)%mod;\t\n\t\t\t}\t\n\t\t\tif(v[x]%2)\n\t\t\t\tans=(ans+(dp[x]*v[x])%mod)%mod;\n\t\t\telse\n\t\t\t\tans=(ans+(dp[x]*v[x]/2)%mod)%mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx_ori[4] = { -1,0, 1,0 }, dy_ori[4] = { 0,1,0,-1 };\nint dx[4] = {0, 0, 0, 0}, dy[4] = {0, 0, 0, 0};\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\n\nsigned main() {\n  int n, k;\n  cin >> n >> k;\n\n  map<int, ll> dp;\n  for (ll x = 1; x * x <= n; x++) {\n    if (n % x == 0) {\n      dp[x] = 0;\n      dp[n / x] = 0;\n    }\n  }\n\n  for (auto itr = dp.begin(); itr != dp.end(); itr++) {\n    int i = itr->first;\n    int zi = (i + 1) / 2;\n    dp[i] = mod_pow(k, zi);\n    //DEBUG(dp[i]);\n    for (auto itr2 = dp.begin(); itr2->first < i; itr2++) {\n      int j = itr2->first;\n      if (i % j != 0) continue;\n      (dp[i] -= itr2->second) %= MOD;\n    }\n    //DEBUG(pll(i, dp[i]));\n  }\n\n  ll ans = 0;\n  for (auto itr = dp.begin(); itr != dp.end(); itr++) {\n    int i = itr->first;\n    if (i % 2 == 1) {\n      ans = (ans + itr->second * i % MOD) % MOD;\n    }\n    else {\n      ans = (ans + itr->second * (i / 2) % MOD) % MOD;\n    }\n  }\n  ans = (ans + MOD) % MOD;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define mod 1000000007\n\nll n, k;\nll i, j;\n\nvector<ll> dp;\nvector<ll> divs;\nll ans;\n\nvoid pre() {\n    ll i, j;\n\n    for (i = 1; i * i <= n; i++) {\n        if (n % i != 0) continue;\n\n        divs.pb(i);\n        if (i < n / i)\n            divs.pb(n / i);\n    }\n\n    dp = vector<ll>(divs.size() + 11, 0);\n    sort(divs.begin(), divs.end());\n}\n\nll poww(ll a, ll b) {\n    ll ans = 1;\n\n    while (b > 0) {\n        if (b & 1) ans = (ans * a) % mod;\n        b >>= 1;\n        a = (a * a) % mod;\n    }\n\n    return ans;\n}\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%lld%lld\", &n, &k);\n    pre();\n\n    for (i = 0; i < divs.size(); i++) {\n        dp[i] = poww(k, (divs[i] + 1) / 2);\n\n        for (j = 0; j < i; j++)\n            if (divs[i] % divs[j] == 0)\n                dp[i] += mod - dp[j];\n\n        dp[i] %= mod;\n    }\n\n    for (i = 0; i < divs.size(); i++) {\n        if (divs[i] % 2 == 0) {\n            ans += (dp[i] * (divs[i] / 2)) % mod;\n        } else {\n            ans += (dp[i] * divs[i]) % mod;\n        }\n    }\n\n    ans %= mod;\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nll N,K;\nvector<ll> di;\nmap<ll,  int> moebius(ll n){\n    map<ll,int> res;\n    vector<ll> primes;\n    for (ll i=1; i*i<=n; i++){\n        if (n%i==0){\n            di.push_back(i);\n            if (i!=n/i) di.push_back(n/i);\n        }\n    }\n    for(ll i=2; i*i<=n; i++){\n        if(n%i==0){\n            primes.pb(i);\n            while(n%i==0) n/=i;\n        }\n    }\n    if(n!=1) primes.pb(n);\n    int m=sz(primes);\n    rep(i,0,1<<m){\n        ll mu=1, d=1;\n        rep(j,0,m){\n            if(i>>j&1){\n                mu*=-1;\n                d*=primes[j];\n            }\n        }\n        res[d]=mu;\n    }\n    return res;\n}\nll mod_pow(ll x, ll n, ll mod=MOD){\n    if (n==0) return 1;\n    ll res=mod_pow(x*x%mod, n/2, mod);\n    if (n%2==1) res=res*x%mod;\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>N>>K;\n    ll ans=0;\n    map<ll, int> m=moebius(N);\n    for(ll d : di){\n        ll res=0;\n        for(ll D: di){\n            if(d%D==0){\n                res+=m[d/D]*mod_pow(K, (D+1)/2);\n                res%=MOD;\n            }\n        }\n        res*=(d%2?d:d/2);\n        res%=MOD;\n        ans+=res;\n        ans%=MOD;\n    }\n    cout <<(ans+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nint binpow(int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\ta = 1LL * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\nint N, K;\nint main() {\n\tcin >> N >> K;\n\tvector<int> d;\n\tfor (int i = 1; i * i <= N; i++) {\n\t\tif (N % i == 0) {\n\t\t\td.push_back(i);\n\t\t\tif (i * i != N) d.push_back(N / i);\n\t\t}\n\t}\n\tsort(d.begin(), d.end());\n\tvector<int> dp(d.size());\n\tint ret = 0;\n\tfor (int i = 0; i < d.size(); i++) {\n\t\tdp[i] = binpow(K, (N % 2 == 0 && (N / 2) % d[i] == 0 ? d[i] : (d[i] + 1) / 2));\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (d[i] % d[j] == 0) {\n\t\t\t\tdp[i] -= dp[j];\n\t\t\t\tif (dp[i] < 0) dp[i] += mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + 1LL * dp[i] * d[i]) % mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\ntemplate <typename ITR>\nbool next_value(int base, ITR bg, ITR ed) {\n\tint c = 1;\n\tfor (; bg != ed && c == 1; ++bg) {\n\t\t(*bg) += c;\n\t\tif ((c = ((*bg) == base)))(*bg) = 0;\n\t}\n\treturn !c;\n}\n\nvoid rot(vector<int> &v) {\n\tint n = v.size();\n\tfor (int i : range(n - 1)) {\n\t\tswap(v[i], v[i + 1]);\n\t}\n}\nLL naive(LL N,LL K) {\n\tset<vector<int>> s;\n\tvector<int> v(N, 0);\n\tdo {\n\t\tauto u = v;\n\t\treverse(ALL(u));\n\t\tbool ok = true;\n\t\tfor (int i : range((int)N)) {\n\t\t\tif (v[i]!=u[i]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif(ok)for (int i : range((int)N)) {\n\t\t\ts.insert(u);\n\t\t\trot(u);\n\t\t}\n\t} while (next_value(K, ALL(v)));\n\treturn s.size();\n}\n\n\nnamespace testcase {\n\n\tconstexpr int LIM = 6;\n\tLL N, K;\n\tLL in[2] = { 5ll,1ll };\n\tbool generate() {\n\t\tN = in[0] + 1;\n\t\tK = in[1] + 1;\n\t\tbool ret = next_value(LIM, in, in + 2);\n\t\treturn ret;\n\t}\n\tbool input() {\n#ifdef VS\n\t\treturn generate();\n#else\n\t\treturn !!(cin >> N >> K);\n#endif\n\t}\n\n\tvoid output(LL ret) {\n#ifdef VS\n\t\tcout << N << \" \" << K;\n\t\tLL expected_answer = naive(N, K);\n\t\tif (ret == expected_answer) {\n\t\t\tcout << \": OK(\" << ret << \")\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \": NG\" << endl;\n\t\t\tcout << \" expected:\" << expected_answer << endl;\n\t\t\tcout << \" received:\" << ret << endl;\n\t\t\texit(0);\n\t\t}\n#else\n\t\tcout << ret << endl;\n#endif\n\t}\n}\n\nconstexpr int mod = 1e9 + 7;\nLL divisor[112345];\nLL dp[112345];\nLL pow_mod(LL a, LL n, int M = mod) {\n\tLL res = 1;\n\ta %= M;\n\twhile (n) {\n\t\tif (n & 1)\n\t\t\tres = (res*a) % M;\n\t\ta = (a*a) % M;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n\ninline LL invMod(LL a, LL m = mod) {\n\tLL b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tLL t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n\nLL solve() {\n\tLL N = testcase::N;\n\tLL K = testcase::K;\n\tint m = 0;\n\tfor (LL d = 1; d*d <= N; d++) {\n\t\tif (N%d == 0) {\n\t\t\tdivisor[m++] = d;\n\t\t\tdivisor[m++] = N / d;\n\t\t}\n\t}\n\tsort(divisor, divisor + m);\n\tm = unique(divisor, divisor + m) - divisor;\n\tLL i2 = invMod(2);\n\tfor (int i : range(m)) {\n\t\tconst LL len = divisor[i] / 2;\n\t\tLL& latte = dp[i];\n\t\tif (divisor[i] % 2 == 0) {\n\t\t\tlatte = pow_mod(K, len) * divisor[i] % mod;\n\t\t\tif (len == 0)latte = 0;\n\t\t}\n\t\telse {\n\t\t\tlatte = pow_mod(K, len + 1) * divisor[i] % mod;\n\t\t}\n\t\tfor(int j:range(i)){\n\t\t\tif (divisor[i] % divisor[j] == 0) {\n\t\t\t\tLL malta = divisor[i] / divisor[j];\n\t\t\t\tlatte += mod - dp[j] * malta % mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (divisor[i] % 2==0) {\n\t\t\tlatte = (latte%mod)*i2%mod;\n\t\t}\n\t\t\n\t\tlatte %= mod;\n\n\t}\n\tLL ret = 0;\n\tfor (int i : range(m))ret += dp[i];\n\treturn ret%mod;\n}\nint main() {\n\twhile (testcase::input()) {\n\t\tLL ret = solve();\n\t\ttestcase::output(ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n, s) for (LL i = (s); i < (n); i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int LL;\ntypedef long double LD;\n\nLL _pow(LL a, LL k) {\n\tLL res = 1;\n\twhile (k) {\n\t\tif (k&1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tLL N, K;\n\tcin >> N >> K;\n\n\tLL res = (_pow(K, (N+1)/2) - K) % MOD;\n\tres = (res * (N/2)) % MOD;\n\tres = (res + K) % MOD;\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P 1000000007\n#define ll long long\nusing namespace std;\nint n,k,f[100005],a[100005],ly;\nint pw(int x,int y)\n{\n\tint ans=1;\n\tfor (;y;y>>=1,x=(ll)x*x%P)\n\t\tif (y&1) ans=(ll)ans*x%P;\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tint Ans=0;\n\tfor (int i=1;i*i<=n;i++)\n\t\tif (n%i==0)\n\t\t{\n\t\t\ta[++ly]=i;\n\t\t\tif (i*i!=n) a[++ly]=n/i;\n\t\t}\n\tsort(a+1,a+ly+1);\n\tfor (int i=1;i<=ly;i++)\n\t{\n\t\tf[i]=pw(k,(a[i]+1)/2);\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (a[i]%a[j]==0) f[i]=(f[i]+P-f[j])%P;\n\t\tif (a[i]&1) Ans=(Ans+(ll)f[i]*a[i]%P)%P;\n\t\telse Ans=(Ans+(ll)f[i]*(a[i]/2)%P)%P;\n\t}\n\t/*\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=pw(k,(i+1)/2);\n\t\tfor (int j=1;j<i;j++)\n\t\t\tif (i%j==0) dp[i]=(dp[i]+P-dp[j])%P;\n\t\t//cout<<i<<' '<<dp[i]<<' '<<n/i<<endl;\n\t\tif (n%i==0)\n\t\t\tif (i&1) Ans=(Ans+(ll)dp[i]*i%P)%P;\n\t\t\telse Ans=(Ans+(ll)dp[i]*(i/2)%P)%P;\n\t}*/\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint a[2005], dp[2005];\nint mod = 1e9 + 7;\nint binpow(int a, int b){\n\tif (b == 0) return 1;\n\tint x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nsigned main(){\n\tint n, k; cin >> n >> k;\n\tint cur = 0;\n\tfor (int i = 1; i <= sqrt(n); i++){\n\t\tif (n % i == 0){\n\t\t\ta[cur] = i; cur++;\n\t\t\tif (i * i != n){\n\t\t\t\ta[cur] = n / i; cur++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a, a + cur);\n\tfor (int i = 0; i < cur; i++){\n\t\tdp[i] = binpow(k, (a[i] + 1) / 2);\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (a[i] % a[j] == 0){\n\t\t\t\t((dp[i] -= dp[j]) += mod) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < cur; i++){\n\t\tif (a[i] % 2) (ans += (dp[i] * a[i])) %= mod;\n\t\telse (ans += (dp[i] * (a[i] / 2))) %= mod;\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ll sig(ll x){\n//    int ans = 1;\n//    for(ll i = 2; i*i <= x; ++i){\n//        if(x%(i*i)==0)\n//            return 0;\n//        if(x%i == 0){\n//            x /= i;\n//            ans *= -1;\n//        }\n//    }\n//    if(x > 1)\n//        ans *= -1;\n//    return ans;\n//}\n//void __(){\n//    ll n,k;\n//    cin >> n >> k;\n//    if(n%2 == 1){\n//        print ipow(k,n/2+1);\n//        return;\n//    }\n//    n /= 2;\n//    vl divs;\n//    for(ll i = 1; i*i <= n; ++i){\n//        if(n%i == 0){\n//            divs.pb(i);\n//            if(i*i < n)\n//                divs.pb(n/i);\n//        }\n//    }\n//    sort(rall(divs));\n//    ll ans = 0;\n//    for(int x : divs){\n//        ll ways = 0;\n//        for(int y : divs){\n//            if(x%y == 0){\n//                ways += sig(x/y)*ipow(k,y);\n//            }\n//        }\n//        ways %= MOD;\n//        ans += ways*x%MOD;\n//    }\n//    ans = (ans%MOD+MOD)%MOD;\n//    print ans;\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define pb push_back\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nll ipow(ll x, ll p, ll mod = MOD){\n    if(abs(x) >= mod)\n        x %= mod;\n    if(x < 0)\n        x += mod;\n    if(p == 0)\n        return 1;\n    if(p == 1)\n        return x;\n    return ipow(x * x % mod, p / 2, mod) * ipow(x, p % 2, mod) % mod;\n}\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout) \n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\nll sig(ll x){\n    int ans = 1;\n    for(ll i = 2; i*i <= x; ++i){\n        if(x%(i*i)==0)\n            return 0;\n        if(x%i == 0){\n            x /= i;\n            ans *= -1;\n        }\n    }\n    if(x > 1)\n        ans *= -1;\n    return ans;\n}\nvoid __(){\n    ll n,k;\n    cin >> n >> k;\n    if(n%2 == 1){\n        print ipow(k,n/2+1);\n        return;\n    }\n    n /= 2;\n    vl divs;\n    for(ll i = 1; i*i <= n; ++i){\n        if(n%i == 0){\n            divs.pb(i);\n            if(i*i < n)\n                divs.pb(n/i);\n        }\n    }\n    sort(rall(divs));\n    ll ans = 0;\n    for(int x : divs){\n        ll ways = 0;\n        for(int y : divs){\n            if(x%y == 0){\n                ways += sig(x/y)*ipow(k,y);\n            }\n        }\n        ways %= MOD;\n        ans += ways*x%MOD;\n    }\n    ans = (ans%MOD+MOD)%MOD;\n    print ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long cnt[300000] = {};\nint main() {\n\tlong long n, k;\n\tcin >> n >> k;\n\tvector<long long> inputs;\n\tfor (long long i = 1; i <= sqrt(n); ++i) {\n\t\tif (n % i == 0) {\n\t\t\tinputs.push_back(i);\n\t\t\tif (i * i != n) {\n\t\t\t\tinputs.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(inputs.begin(), inputs.end());\n\tlong long ans = 0;\n\tfor (int i = 0; i < inputs.size(); ++i) {\n\t\tcnt[i] = powing(k, (inputs[i] + 1) / 2);\n\t\tfor (int q = 0; q < i; ++q) {\n\t\t\tif (inputs[i] % inputs[q] != 0) continue;\n\t\t\tcnt[i] += MAX_MOD - cnt[q];\n\t\t\tcnt[i] %= MAX_MOD;\n\t\t}\n\t\tlong long geko = inputs[i];\n\t\tif (geko % 2 == 0) geko /= 2;\n\t\tans += geko * cnt[i];\n\t\tans %= MAX_MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <map>\n\nstd::vector<intmax_t> divisor(intmax_t n) {\n  std::vector<intmax_t> res;\n  for (intmax_t i = 1; i*i <= n; ++i) {\n    if (n % i) continue;\n    res.push_back(i);\n    if (n/i != i) res.push_back(n/i);\n  }\n  std::sort(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename InputIt>\nauto compress(InputIt first, InputIt last) {\n  using value_type = typename InputIt::value_type;\n  std::map<value_type, size_t> res;\n  while (first != last) res[*first++];\n  size_t i = 0;\n  for (auto& p: res) p.second = i++;\n  return res;\n}\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nconstexpr intmax_t mod = 1e9+7;\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  std::vector<intmax_t> ds = divisor(n);\n  std::vector<size_t> dp(ds.size());\n  intmax_t inv2 = modpow(2_jd, mod-2, mod);\n  for (size_t i = 0; i < ds.size(); ++i) {\n    intmax_t cur = modpow(k, (ds[i]+1)/2, mod);\n    for (size_t j = 0; j < i; ++j) {\n      if (ds[i] % ds[j]) continue;\n      cur = (cur + mod - dp[j]) % mod;\n    }\n    dp[i] = cur;\n  }\n\n  intmax_t res = 0;\n  for (size_t i = 0; i < dp.size(); ++i) {\n    intmax_t cur = dp[i];\n    (cur *= ds[i]) %= mod;\n    if (ds[i] % 2 == 0) (cur *= inv2) %= mod;\n    (res += cur) %= mod;\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint gi() {\n\tint w;bool q=1;char c;\n\twhile (((c=getchar())<'0'||'9'<c)&&c!='-');\n\tif (c=='-') q=0,c=getchar();\n\tw=c-'0';\n\twhile ('0'<=(c=getchar())&&c<='9') w=w*10+c-'0';\n\treturn q?w:-w;\n}\nconst int mod=1e9+7;\ninline int qpow(int x,int y) {\n\tint ans=1;\n\twhile (y) {\n\t\tif (y&1) ans=1LL*ans*x%mod;\n\t\tx=1LL*x*x%mod;y>>=1;\n\t}\n\treturn ans;\n}\nconst int N=1e5;\nint p[N],c[N],f[N];\nint main()\n{\n\tint n=gi(),m=gi(),i,j,ans=0,sq=sqrt(n),len=0;\n\tconst int inv2=(mod+1)>>1;\n\tfor (i=1;i<=sq;i++) if (!(n%i)) p[++len]=i;\n\tfor (i=sq*sq==n?sq-1:sq;i;i--) if (!(n%i)) p[++len]=n/i;\n\tfor (i=1;i<=len;i++) {\n\t\tf[i]=qpow(m,(p[i]+1)>>1);\n\t\tfor (j=1;j<i;j++)\n\t\t\tif (!(p[i]%p[j]))\n\t\t\t\t(f[i]-=f[j])%=mod;\n\t}\n\tfor (i=1;i<=len;i++) ans=(ans+1LL*f[i]*p[i]%mod*(p[i]&1?1:inv2))%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < n; ++i)\n\nint md = 1e9 + 7;\nmap<int, int> p;\n\nint pw(int x, int p) {\n\tif (!p)return 1;\n\tint t = pw(x, p >> 1);\n\tt = (ll)t * t % md;\n\tif (p & 1)t = (ll)t * x % md;\n\treturn t;\n}\n\nint main() {\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 1; i * i <= n; ++i)if (n % i == 0)p[i], p[n / i];\n\tfor (map<int, int>::iterator it = p.begin(); it != p.end(); ++it) {\n\t\tit->second = pw(k, it->first + 1 >> 1);\n\t\tif (it->first == 1)continue;\n\t\tfor (int i = 1; i * i <= it->first; ++i)if (it->first % i == 0) {\n\t\t\tit->second += md - p[i];\n\t\t\tif (it->second >= md)it->second -= md;\n\t\t\tif (it->first / i != i && i != 1) {\n\t\t\t\tit->second += md - p[it->first / i];\n\t\t\t\tif (it->second >= md)it->second -= md;\n\t\t\t}\n\t\t}\n\t}\n\tint an = 0;\n\tfor (map<int, int>::iterator it = p.begin(); it != p.end(); ++it) {\n\t\tan += (ll)it->second * (it->first & 1 ? it->first : it->first >> 1) % md;\n\t\tif (an >= md)an -= md;\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n       \n       \n                               //----------------kokomade tenpure------------\n\nvector<int> ve;\nvector<int> dp;\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,k;\n \tcin>>n>>k;\n \t\n \tfor(int i=1;i*i<=n;i++)if(n%i==0){\n \t\tif(i*i==n) dp.pb(0),ve.pb(i);\n \t\telse{\t\n \t\t\tve.pb(i);\n \t\t\tve.pb(n/i);\n \t\t\tdp.pb(0);\n \t\t\tdp.pb(0);\n \t\t}\n \t}\n \tsort(ve.begin(),ve.end());\n \tint r=ve.size();\n \tfor(int i=0;i<r;i++){\n \tdp[i]=\tbeki(k,(ve[i]+1)/2,inf);\n \t\tfor(int j=0;j<i;j++)if(ve[i]%ve[j]==0){\n \t\t\tdp[i]+=inf-dp[j];\n\t\t\tdp[i]%=inf;\n \t\t}\n \t//\tcout<<ve[i]<<\" \"<<dp[i]<<endl;\n \t}\n \tint ans=0;\n \t\n \tfor(int i=0;i<r;i++){\n \t\tif(ve[i]%2){\n \t\t\tans+=dp[i]*ve[i]%inf;\n \t\t}\n \t\telse{\n \t\t\tint g=ve[i]/2;\n \t\t\tans+=dp[i]*g%inf;\n \t\t\t\n \t\t}\n \t\tans%=inf;\n \t}\n \tcout<<ans<<endl;\n\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\n\nconst int P=1e9+7,N=2333;\nint fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\n\nint n,k,m,ve[N],f[N],ans;\n\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){ve[++m]=i;if(i*i<n)ve[++m]=n/i;}\n\tsort(ve+1,ve+m+1);\n\tfor(int i=1;i<=m;i++){\n\t\tf[i]=fpow(k,(ve[i]+1)/2);\n\t\tfor(int j=1;j<i;j++)if(ve[i]%ve[j]==0)f[i]=(f[i]-f[j]+P)%P;\n\t\tif(ve[i]&1)ans=(ans+(ll)ve[i]*f[i])%P;\n\t\telse ans=(ans+(ll)(ve[i]>>1)*f[i])%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define LL long long\n#define MAXN 100010\n\nconst LL P=1000000007;\n\nLL n,m,lim=100000;\nLL f1[MAXN],f2[MAXN];\nLL p1[MAXN],p2[MAXN];\n\nvoid init(){\n\tp1[0]=1;\n\tfor(int i=1;i<=lim;i++)\n\t\tp1[i]=p1[i-1]*m%P;\n\tp2[0]=1;\n\tfor(int i=1;i<=lim;i++)\n\t\tp2[i]=p2[i-1]*p1[lim]%P;\n}\n\nLL getP(LL x){ return p2[x/lim]*p1[x%lim]%P; }\n\nLL dp(int x){\n\tif(x<=lim){\n\t\tif(~f1[x]) return f1[x];\n\t}else{\n\t\tif(~f2[n/x]) return f2[n/x];\n\t}\n\tLL res=getP((x+1)/2);\n\tfor(int i=1;i*i<=x;i++){\n\t\tif(x%i) continue;\n\t\tint j=x/i;\n\t\tif(i!=x) res=(res-dp(i))%P;\n\t\tif(j!=i && j!=x) res=(res-dp(j))%P;\n\t}\n\tif(res<0) res+=P;\n\tif(x<=lim){\n\t\treturn f1[x]=res;\n\t}else{\n\t\treturn f2[n/x]=res;\n\t}\n}\n\nLL g(int x){\n\tif(x&1) return x;\n\telse return x>>1;\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tmemset(f1,-1,sizeof f1);\n\tmemset(f2,-1,sizeof f2);\n\tscanf(\"%lld%lld\",&n,&m);\n\tinit();\n\tdp(n);\n\tLL ans=0;\n\tfor(int i=1;i<=lim;i++)\n\t\tif(f1[i]!=-1)\n\t\t\tans=(ans+f1[i]*g(i))%P;\n\tfor(int i=1;i<=lim;i++)\n\t\tif(f2[i]!=-1)\n\t\t\tans=(ans+f2[i]*g(n/i))%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nll MOD = 1000000007;\n//ll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n/*\n12221\n22211\n22112\n21122\n11222\n横に一マス移動しても変わらない\n横に二マス移動しても変わらない\n横に三マス移動しても変わらない\nNの約数マス\n約数包徐\naaaa\nbaab\n\naaaaa\nbaaab\nababa\ncbabc\n\naaaaaa\nabaaba\nbaaaab\nbbaabb\ncbaabc\n全ての回文の数を求める\n回文になってかつNの約数ループになっているものを数える\n\nabababab...ab|ba...babababa\naba aba aba aba //3ループ\n abaaba   abaaba//6ループ\naba aba | aba aba\n\n*/\nll N, K;\nvector<ll> divN;\nll d;\nvoid solve(){\n  vector<mint> loop(d, Mint);\n  rep(i, d){\n    loop[i] = pow_mod(K, (divN[i] + 1) / 2);\n  }\n  rep(i, d){\n    rep(j, d){\n      if(i < j && divN[j] % divN[i] == 0){\n        loop[j] -= loop[i];\n      }\n    }\n  }\n  mint ans = 0;\n  rep(i, d){\n    mint add = loop[i] * divN[i];\n    if(divN[i] % 2 == 0) add /= 2;\n    ans += add;\n  }\n  ans.get();\n}\n\n\nint main(){\n  cin >> N >> K;\n  divN = divisor(N);\n  d = divN.size();\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define inf 20021225\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nmap<int,int> f; int n,k;\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint calc(int x)\n{\n\tif(f.find(x)!=f.end())\treturn f[x];\n\tint tmp=ksm(k,x+1>>1);\n\tfor(int i=1;i*i<=x;i++)\tif(x%i==0)\n\t{\n\t\tif(i!=x)\tupd(tmp,mdn-calc(i));\n\t\tif(i!=x/i&&x/i!=x)\tupd(tmp,mdn-calc(x/i));\n\t}\n\treturn f[x]=tmp;\n}\nint odd,even;\nint main()\n{\n\tn=read(),k=read();\n\tfor(int i=1;i*i<=n;i++)\tif(n%i==0)\n\t{\n\t\tint w=i;\n\t\tif(w&1)\tupd(odd,1ll*w*calc(w)%mdn); else\tupd(even,1ll*w*calc(w)%mdn);\n\t\tw=n/i; if(w==i)\tcontinue;\n\t\tif(w&1)\tupd(odd,1ll*w*calc(w)%mdn); else\tupd(even,1ll*w*calc(w)%mdn);\n\t}\n\teven=500000004ll*even%mdn;\n\tprintf(\"%d\\n\",(odd+even)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=3005;\nconst int mod=1e9+7;\nint n,q,cnt,val[N],dp[N];\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\ntemplate <class T>\ninline int fpow(int x,T t){\n\tint ans=1;\n\tfor(; t; x=(lint)x*x%mod,t>>=1){\n\t\tif(t&1) ans=(lint)ans*x%mod;\n\t}\n\treturn ans;\n}\n\nvoid get_val(){\n\tstatic int buk[N];\n\tbool flag=0;\n\tfor(int i=1; i*i<=n; ++i){\n\t\tif(n%i) continue;\n\t\tval[++cnt]=i;\n\t\tif(i*i==n) flag=1;\n\t\telse buk[cnt]=n/i;\n\t}\n\tfor(int i=cnt-flag; i; --i){\n\t\tval[++cnt]=buk[i];\n\t}\n}\n\nvoid get_dp(){\n\tfor(int i=1; i<=cnt; ++i){\n\t\tint res=fpow(q,(val[i]+1)>>1);\n\t\tfor(int j=1; j<i; ++j){\n\t\t\tif(val[i]%val[j]==0) res=(res-dp[j])%mod;\n\t\t}\n\t\tdp[i]=(res+mod)%mod;\n\t}\n}\n\nint main(){\n\tn=nxi(),q=nxi();\n\tget_val();\n\tget_dp();\n\tint ans=0;\n\tfor(int i=1; i<=cnt; ++i){\n\t\tint wgt=val[i]&1?val[i]:val[i]>>1;\n\t\tans=(ans+(lint)wgt*dp[i])%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll num[2000];\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> v;\n\trep1(i, 100000) {\n\t\tif (n%i == 0) {\n\t\t\tv.push_back(i);\n\t\t\tv.push_back(n / i);\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, v.size()) {\n\t\tint d = (v[i] + 1) / 2;\n\t\tll sum = mod_pow(k, d);\n\t\trep(j, i) {\n\t\t\tif (v[i] % v[j] == 0) {\n\t\t\t\tsum -= num[j];\n\t\t\t\tif (sum < 0)sum += mod;\n\t\t\t}\n\t\t}\n\t\tnum[i] = sum;\n\t}\n\tll ans = 0;\n\trep(i, v.size()) {\n\t\tif (v[i] % 2 == 0) {\n\t\t\tans = (ans + num[i] * v[i] / 2) % mod;\n\t\t}\n\t\telse {\n\t\t\tans = (ans + (num[i] * v[i])) % mod;\n\t\t}\n\t\t//cout << num[i] << endl;\n\t\t//ans = (ans + num[i] * ((v[i]+1)/2)) % mod;\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n//const int inf = 0x3f3f3f3f;\nconst ll inf = 1ll << 62;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define pi 3.14159265358979323846\n#define pc putchar\n#define gc getchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n//char __wzp[1<<15|1],*__S=__wzp+32768;\n//#define gc() (__S>=__wzp+32768?(__wzp[fread(__wzp,sizeof(char),1<<15,stdin)]=EOF),*((__S=__wzp)++):*(__S++))\n#define rd read\n#define mem(x,v) memset(x,v,sizeof(x))\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\ninline ll read(){\n    register ll x=0,f=1;register char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int mod = 1e9+7;\nint n,k,top,q[233333],sum[233333];\ninline int qpow(int a,int b){\n\tint ans = 1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint main(){\n\tn = rd(),k = rd();\n\tfor(int i=1;i*i<=n;++i){\n\t\tif(!(n%i)){\n\t\t\tq[++top] = i;\n\t\t\tif(n != i*i) q[++top] = n / i;\n\t\t}\n\t}sort(q+1,q+1+top);\n\tRep(i,1,top) sum[i] = qpow(k,(q[i]+1)>>1);\n\tint ans = 0;\n\tRep(i,1,top){\n\t\trep(j,1,i)if(!(q[i]%q[j])) sum[i]=(sum[i]-sum[j]+mod)%mod;\n\t\tans = (ans + 1ll * sum[i]*((q[i]&1)?q[i]:(q[i]>>1)) % mod) %mod;\n\t}writeln((ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::sort;\n\nconst int N=1e5+10,Mod=1e9+7;\n\nint n,k,que[N],dp[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&k);\n}\n\nint pow(int x,int t) {\n\tint ret=1;\n\twhile (t) {\n\t\tif (t&1) ret=1ll*ret*x%Mod;\n\t\tx=1ll*x*x%Mod;\n\t\tt=t>>1;\n\t}\n\treturn ret;\n}\n\nvoid Solve() {\n\tint top=0;\n\tfor (int i=1;i*i<=n;++i) {\n\t\tif (n%i) continue;\n\t\tque[++top]=i;\n\t\tif (i*i==n) continue;\n\t\tque[++top]=n/i;\n\t}\n\tsort(que+1,que+top+1);\n\t\n\tint ans=0;\n\tfor (int i=1;i<=top;++i) {\n\t\tdp[i]=pow(k,(que[i]+1)>>1);\n\t\tfor (int j=1;j<i;++j) if (que[i]%que[j]==0) {\n\t\t\tdp[i]=(dp[i]-dp[j]+Mod)%Mod;\n\t\t}\n\t\tif (que[i]&1) ans=(ans+1ll*dp[i]*que[i]%Mod)%Mod;\n\t\telse ans=(ans+1ll*dp[i]*que[i]/2%Mod)%Mod;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e3+10,mod=1e9+7;\nint f[maxn],num[maxn],tmp;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tint n=read(),m=read();\n\tfor(int i=1;(ll)i*i<=n;++i) if(n%i==0){\n\t\tnum[++tmp]=i;\n\t\tif(i*i!=n) num[++tmp]=n/i;\n\t}\n\tsort(num+1,num+tmp+1);\n\tint ans=0;\n\tREP(i,1,tmp){\n\t\tf[i]=(f[i]+ksm(m,(num[i]+1)/2))%mod;\n\t\tREP(j,i+1,tmp) if(num[j]%num[i]==0) f[j]=(f[j]+mod-f[i])%mod;\n\t\tans=(ans+(ll)f[i]*num[i]%mod*((num[i]&1)?1:((mod+1)/2)))%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\nll modpow(ll a,ll b){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return r;\n}\n\nint main(){\n  int n,k;\n  scanf(\"%d%d\",&n,&k);\n  vi divisor;\n  for(int x=1;x*x<=n;x++){\n    if(n%x!=0)continue;\n    divisor.push_back(x);\n    if(x*x!=n)divisor.push_back(n/x);\n  }\n  sort(ALL(divisor));\n  int m = divisor.size();\n  vl vals(m,0);\n  ll ans = 0;\n  REP(i,m){\n    int v = divisor[i];\n    ll unit = modpow(k,(v+1)/2);\n    REP(j,i)if(v%divisor[j]==0)unit=(unit-vals[j]+MOD)%MOD;\n    vals[i] = unit;\n    unit *= v;\n    if(v%2==0)unit /= 2;\n    ans = (ans+unit)%MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define get_variable_name(x) #x\n#define debug(x) cout << #x << \" = \" << x << endl\n\n#define ALL(x) (x).begin(), (x).end()\n#define SORT(x) sort((x).begin(), (x).end())\n#define REVERSE(x) reverse( (x).begin(),(x).end())\n#define UNIQUE(x) (x).erase(unique(ALL((x))), (x).end())\n#define PW(x) (1LL<<(x))\n\nusing namespace std;\nusing ll = int64_t;\nusing P = pair<int, int>;\n\ntemplate<class T,class U>\nostream& operator<<(ostream &os, const pair<T, U> &p) {\n    os << get_variable_name(p) << \" = (\" << p.first <<\", \" << p.second << \")\";\n    return os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os, const vector<T> &v){\n    cout << get_variable_name(v) << \" = [\";\n    for(auto i : v) \n        os << \" \" << i; \n    os << \" ]\";\n    return os;\n}\n\n\nconst int INF = 1e8;\n\nconst ll MOD = 1e9+7LL;\n\nll num[10000];\n\n// 5 5\n// 101\n//  5 * (5 * 5) * (5 * 5)\n\ntemplate<typename T>\nT xpow(T x, T n, T M) {\n    T ret = 1;\n    T val = x;\n    for(; n != 0; n >>= 1) {\n        if(n & 1) {\n            ret *= val;\n            ret %= M;\n        }\n        val *= val;\n        val %= M;\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    ll N, K;\n\n    cin >> N >> K;\n\n    vector<ll> divs;\n\n    for(ll i = 1; i*i <= N; i++) {\n        if(N % i == 0) {\n            divs.emplace_back(i);\n            if(i*i < N) divs.emplace_back(N/i); \n        }\n    }\n\n    sort(ALL(divs));\n\n    ll ans = 0;\n\n    // d:cyclic\n    for(int i = 0; i < divs.size(); i++) {\n        ll d = divs[i];\n        ll val = xpow<ll>(K, (d+1)/2, MOD);\n        for(int j = 0; j < i; j++) {\n            if(divs[i] % divs[j] == 0) {\n                val = (val - num[j] + MOD) % MOD;\n            }\n        }\n        num[i] = val;\n        if(d & 1) { // odd\n            ans += num[i] * d;\n        } else { // even\n            ans += num[i] * d / 2;\n        }\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n#define MOD 1000000007\ntypedef long long ll;\nll modpow(ll a, ll n) {\n\ta %= MOD;\n\tif (a == 0) return 0;\n\tll r = 1;\n\twhile (n) r = r*((n % 2) ? a : 1) % MOD, a = a*a%MOD, n >>= 1;\n\treturn r;\n}\nvector<ll> enumdiv(ll n) {\n\tvector<ll> S;\n\tfor (ll i = 1; i*i <= n; i++) if (n%i == 0) { S.push_back(i); if (i*i != n) S.push_back(n / i); }\n\tsort(S.begin(), S.end());\n\treturn S;\n}\n//-----------------------------------------------------------------\nll N, K;\nmap<ll, ll> memo;\nll num(ll d) {\n\tif (memo.find(d) != memo.end()) return memo[d];\n\n\tll ret = modpow(K, (d + 1) / 2);\n\t\n\tauto v = enumdiv(d);\n\tfor (ll dd : v) if (dd != d) {\n\t\tret = (ret - num(dd) + MOD) % MOD;\n\t}\n\n\treturn memo[d] = ret;\n}\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> K;\n\n\tll ans = 0;\n\tauto v = enumdiv(N);\n\tfor (ll d : v) {\n\t\tif (d % 2)\n\t\t\tans = (ans + num(d) * d) % MOD;\n\t\telse\n\t\t\tans = (ans + num(d) * d / 2) % MOD;\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD (1000000007)\n#define LL long long\nusing namespace std;\n\nLL n,k,ans;\nvector<LL>v,f;\n\nLL Qpow(LL a,LL b)\n{\n\tLL ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n>>k;\n\tfor (int i=1; i<=sqrt(n); ++i)\n\t\tif (n%i==0)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tif (n/i!=i) v.push_back(n/i);\n\t\t}\n\tsort(v.begin(),v.end());\n\tf.resize(v.size());\n\tfor (int i=0,sz=v.size(); i<sz; ++i)\n\t{\n\t\tf[i]=Qpow(k,(v[i]+1)/2);\n\t\tfor (int j=0; j<i; ++j)\n\t\t\tif (v[i]%v[j]==0) (f[i]-=f[j])%=MOD;\n\t\tif (v[i]%2) (ans+=f[i]*v[i]%MOD)%=MOD;\n\t\telse (ans+=f[i]*v[i]/2%MOD)%=MOD;\n\t}\n\tcout<<(ans+MOD)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define MN 50005\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nmap<int,ll> f;\nint n,k,num[10000005],a[MN],sum[MN],tot,tt;ll ans;\nll pow(int x,int y){\n\tll tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=tmp*x%mod;\n\t\ty>>=1,x=1ll*x*x%mod;\n\t}return tmp;\n}\nvoid add(ll &x,int y){(x+=y)>=mod?x-=mod:0;}\nvoid dec(ll &x,int y){(x-=y)<0?x+=mod:0;}\nvoid dfs(int u,int now){\n\tif(u==tot+1){num[++tt]=now;return ;}\n\tfor(int i=0;i<=sum[u];i++)dfs(u+1,now*pow(a[u],i));\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);if(n%2==0)n/=2;int tmp=(int)sqrt(n);f[1]=k;\n\tint now=n;\n\tfor(int i=2;i<=tmp;i++)if(now%i==0){\n\t\ta[++tot]=i;\n\t\twhile(now%i==0)now/=i,sum[tot]++;\n\t}if(now!=1)a[++tot]=now,sum[tot]=1;dfs(1,1);\n\tsort(num+1,num+tt+1);\n//\tfor(int i=1;i<=tt;i++)printf(\"%d \",num[i]);puts(\"\");\n\tfor(int i=2;i<=tt;i++){\n\t\tf[num[i]]=pow(k,num[i]);\n\t\tfor(int j=2;j<sqrt(num[i]);j++)if(num[i]%j==0){\n\t\t//\tif(f[j]==0)puts(\"bad!\"),printf(\"%d %d\\n\",num[i],j);\n\t\t//\tif(f[num/j]==0)puts(\"bad!\"),printf(\"%d %d\\n\",num[i],num[i]/j);\n\t\t\tdec(f[num[i]],f[j]),dec(f[num[i]],f[num[i]/j]);\n\t\t}dec(f[num[i]],f[1]);\n\t\tif((int)sqrt(num[i])*(int)sqrt(num[i])==num[i])dec(f[num[i]],f[(int)sqrt(num[i])]);\n\t}\n\tfor(int i=1;i<=tt;i++)add(ans,f[num[i]]*num[i]%mod);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <map>\n\nstd::vector<intmax_t> divisor(intmax_t n) {\n  std::vector<intmax_t> res;\n  for (intmax_t i = 1; i*i <= n; ++i) {\n    if (n % i) continue;\n    res.push_back(i);\n    if (n/i != i) res.push_back(n/i);\n  }\n  std::sort(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename InputIt>\nauto compress(InputIt first, InputIt last) {\n  using value_type = typename InputIt::value_type;\n  std::map<value_type, size_t> res;\n  while (first != last) res[*first++];\n  size_t i = 0;\n  for (auto& p: res) p.second = i++;\n  return res;\n}\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nconstexpr intmax_t mod = 1e9+7;\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  std::vector<intmax_t> ds = divisor(n);\n  std::map<intmax_t, size_t> map = compress(ds.begin(), ds.end());\n  std::vector<size_t> dp(map.size());\n  intmax_t inv2 = modpow(2_jd, mod-2, mod);\n  for (auto d: ds) {\n    intmax_t cur = modpow(k, (d+1)/2, mod);\n    for (auto d0: ds) {\n      if (d == d0) break;\n      if (d % d0) continue;\n      cur = (cur + mod - dp[map.at(d0)]) % mod;\n    }\n    dp[map.at(d)] = cur;\n  }\n\n  intmax_t res = 0;\n  for (auto d: ds) {\n    intmax_t cur = dp[map.at(d)];\n    (cur *= d) %= mod;\n    if (d % 2 == 0) (cur *= inv2) %= mod;\n    (res += cur) %= mod;\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 100005;\nint fac[MAXN],n,f[MAXN],m;\ninline int ksm(int x,int k)\n{\n  int ret=1;\n  while(k){\n    if(k&1)ret=(long long)ret*x%MOD;\n    x=(long long)x*x%MOD;\n    k>>=1;\n  }\n  return ret;\n}\ninline void sub(int &x,int a)\n{\n  x-=a;\n  if(x<0)x+=MOD;\n}\ninline void add(int &x,int a)\n{\n  x+=a;\n  if(x>=MOD)x-=MOD;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i*i<=n;++i){\n    if(n%i==0){\n      fac[++fac[0]]=i;\n      if(i*i!=n)fac[++fac[0]]=n/i;\n    }\n  }\n  int ans=0;\n  sort(fac+1,fac+fac[0]+1);\n  for(int i=1;i<=fac[0];++i){\n    f[i]=ksm(m,(fac[i]+1)>>1);\n    for(int j=1;j<i;++j)\n      if(fac[i]%fac[j]==0)sub(f[i],f[j]);\n    if(fac[i]&1){\n      add(ans,(long long)f[i]*fac[i]%MOD);      \n    }else{\n      add(ans,(long long)f[i]*fac[i]%MOD*500000004%MOD);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (n % 2 == 0) n /= 2;\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tmp[i] = modpow(k, i);\n\t\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[i] = modpow(k, (i + 1) / 2);\n\t\t\t\tmp[n / i] = modpow(k, (n / i + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\t//cout << i.first << ' ' << i.second << endl;\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a),i##_end=(b);i<=i##_end;++i)\n#define For(i,a,b) for(int i=(a),i##_end=(b);i<i##_end;++i)\n#define per(i,a,b) for(int i=(b),i##_st=(a);i>=i##_st;--i)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x\" = \"<<x<<endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define Es(x,i) for(Edge *i=G[x];i;i=i->nxt)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf=~0u>>1,MOD=1e9+7;\ninline int rd() {\n    int x,c,f=1;while(!isdigit(c=getchar()))f=c!='-';x=c-'0';\n    while(isdigit(c=getchar()))x=x*10+c-'0';return f?x:-x;\n}\ninline int pw(int n,int m,int p=MOD){int r=1;for(;m;m>>=1,n=1ll*n*n%p)if(m&1)r=1ll*r*n%p;return r;}\nmap<int,int> f;\nint n,k;\ninline int dfs(int x){\n\tif(f.count(x))return f[x];\n\telse if(x==1)return f[x]=k;\n\tll p=pw(k,(x+1)/2);\n\tfor(int i=1;i*i<=x;i++){\n\t\tif(!(x%i)){\n\t\t\tp=(p-dfs(i))%MOD;\n\t\t\tint y=x/i;\n\t\t\tif(y!=i&&y!=x){\n\t\t\t\tp=(p-dfs(y))%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn f[x]=(p+MOD)%MOD;\n}\nint main(){\n\tn=rd(),k=rd();\n\tll p=0;\n\tdfs(n);\n\tfor(int i=1;i*i<=n;i++)if(!(n%i)){\n\t\tp=(p+1ll*f[i]*i/(i%2?1:2))%MOD;\n\t\tint y=n/i;\n\t\tif(y!=i){\n\t\t\tp=(p+1ll*f[y]*y/(y%2?1:2))%MOD;\n\t\t}\n\t}\n\tcout<<p<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\n# define int long long\n\nvector<int> dzielniki_n;\n\nmap<int, int> palin;\n\nint pot(long long x, long long y){\n    long long wyn = 1;\n    while (y){\n        if (y % 2)\n            wyn = (wyn * x) % mod;\n        y /= 2;\n        x = (x * x) % mod;\n    }\n    return wyn;\n}\n\n# define int int\n\nint main()\n{\n    # define int long long\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    long long wynik = 0;\n    cin >> n >> k;\n    for (int i = 1; i * i <= n; i++)\n        if (n % i == 0){\n            dzielniki_n.push_back(i);\n            if (i * i < n)\n                dzielniki_n.push_back(n / i);\n        }\n    sort(dzielniki_n.begin(), dzielniki_n.end());\n    for (int i : dzielniki_n){\n        long long pom = pot(k, (i + 1) / 2);\n        for (int j = 0; dzielniki_n[j] < i; j++)\n            if (!(i % dzielniki_n[j])){\n                pom = (pom - palin[dzielniki_n[j]]) % mod;\n            }\n        palin[i] = pom;\n        if (i % 2)\n            wynik = (wynik + ((long long)pom * i) % mod) % mod;\n        else\n            wynik = (wynik + ((long long)pom * i / 2) % mod) % mod;\n    }\n    cout << wynik << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod = 1000000007;\nvector<ll> v;\nll cnt[2010] = {};\nll pw(ll a,ll x){\n    ll ret = 1;\n    while(x){\n        if(x&1) (ret *= a) %= mod;\n        (a *= a) %= mod; x /= 2;\n    }\n    return ret;\n}\n\nint main(){\n    ll i,j,n,k; cin >> n >> k;\n    for(i=1;i*i<=n;i++){\n        if(n%i==0){\n            v.push_back(i);\n            if(i*i!=n) v.push_back(n/i);\n        }\n    }\n    sort(v.begin(),v.end());\n    for(i=0;i<v.size();i++){\n        ll num = pw(k,(v[i] + 1)/2);\n        for(j=0;j<i;j++){\n            if(v[i]%v[j]==0){\n                num -= cnt[j];\n                if(num<0) num += mod;\n            }\n        }\n        cnt[i] = num;\n    }\n    ll ans = 0;\n    for(i=0;i<v.size();i++){\n        if(v[i]&1) (ans += v[i]*cnt[i]%mod) %= mod;\n        else (ans += v[i]/2*cnt[i]%mod) %= mod;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename T>\nvector<pair<T, int>> prime_factor(T num) {\n  vector<pair<T, int>> ret;\n  for (T i=2; i*i<=num; ++i) {\n    int cnt = 0;\n    while (num%i == 0) {\n      num /= i;\n      ++cnt;\n    }\n    if (cnt != 0) ret.emplace_back(i, cnt);\n  }\n  if (num != 1) ret.emplace_back(num, 1);\n  return ret;\n}\n\n// if (srt > 0), sorted by ascending order. else if (srt < 0), sorted by descending order.\ntemplate<typename T>\nvector<T> divisor(vector<pair<T, int>> &pf, int srt) {\n  vector<T> ret;\n  ret.emplace_back(1);\n  for (auto &p : pf) {\n    int sz = ret.size();\n    T x; int y;\n    tie(x,y) = p;\n    for (int i=0; i<sz; ++i) {\n      T d = ret[i];\n      for (int j=0; j<y; ++j) {\n        d *= x;\n        ret.emplace_back(d);\n      }\n    }\n  }\n  if (srt > 0) sort(ret.begin(), ret.end());\n  else if (srt < 0) sort(ret.rbegin(), ret.rend());\n  return ret;\n}\n\ntemplate<typename T>\nvector<T> divisor(const T &num, int srt) {\n  auto pf = prime_factor(num);\n  return divisor(pf, srt);\n}\n\nvoid solve() {\n  int n, k; cin >> n >> k;\n\n  auto div = divisor(n, 0);\n\n  map<int, ll> cnt;\n\n  for (auto &v : div) {\n    auto &tmp = cnt[v];\n    (tmp += modpow(k, (v + 1) / 2)) %= MOD;\n\n    auto d = divisor(n / v, 0);\n    rep1(i,d.size()) {\n      cnt[v * d[i]] += MOD - tmp;\n    }\n  }\n\n  ll ans = 0;\n\n  for (auto &p : cnt) {\n    if (p.first & 1) {\n      (ans += p.first * p.second) %= MOD;\n    } else {\n      (ans += p.first / 2 * p.second) %= MOD;\n    }\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll f(ll len,ll alp){\n  if(len<=0)return 0;\n  if(len%2==0){\n    return mod_pow(alp,len/2);\n  }else{\n    return mod_pow(alp,len/2)*alp%mod;\n  }\n}\n\nll n,k;\nset<ll> ds;\nmap<ll,ll> dp;\n\nint main(){\n\tcin>>n>>k;\n  for(ll i=1;i*i<=n;i++){\n    if(n%i==0){\n      ds.insert(i);\n      ds.insert(n/i);\n    }\n  }\n  ll res=0;\n  for(ll d : ds){\n    ll cnt=f(d,k);\n    for(ll d_ : ds){\n      if(d_==d)break;\n      if(d%d_!=0)continue;\n      cnt=(cnt-dp[d_]+mod)%mod;\n    }\n    dp[d]=cnt;\n    if(d%2==0)cnt=cnt*mod_pow(2,mod-2)%mod;\n    (res+=(cnt*d)%mod)%=mod;\n  }\n  cout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nconst int MOD = 1e9 + 7;\n\nll modpow(ll a, ll b)\n{\n\tll r = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=(r*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll mult(ll a, ll b)\n{\n\ta%=MOD;\n\tb%=MOD;\n\treturn (a*b)%MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tll n, k;\n\tcin>>n>>k;\n\tif(n&1)\n\t{\n\t\tcout<<(mult(n,((modpow(k,(n+1)/2)-k)%MOD + MOD)%MOD)+k)%MOD<<'\\n';\n\t\treturn 0;\n\t}\n\tll a = modpow(k,n/2);\n\tll b = modpow(k,((n/2)+1)/2);\n\t//cerr<<a<<' '<<b<<'\\n';\n\tll ans = mult(n/2,((a-k)%MOD+MOD)%MOD);\n\t//ll ans2 = mult(n/4, ((b-k)%MOD+MOD)%MOD);\n\t//ll ans2 = 0;\n\t//ll ans = mult(n/2, (a-k)%MOD+MOD);\n\tll ans3 = k;\n\tans+=ans3;\n\tcout<<ans%MOD<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long int\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\nusing namespace std;\ntypedef vector<int, int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef pair<double, int> PDI;\ntypedef vector<PDI> VD;\n\nconst int MOD = (int)1e9 + 7;\nint n, k;\n\nint times(int x, int pn)\n{\n  int ret = 1, now = x;\n  \n  while(pn){\n    if(pn % 2)\n      ret *= now;\n    \n    ret %= MOD;\n \n    now *= now;\n    now %= MOD;\n \n    pn /= 2;\n  }\n \n  return ret;\n}\n\nsigned main()\n{\n  cin >> n >> k;\n\n  cout << times(k, n / 2) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint fpow(int x,int y)\n{\n\tif(y==0)\n\t\treturn 1;\n\tint ret=fpow(x,y>>1);\n\tret=(long long)ret*ret%mod;\n\tif(y&1)\n\t\tret=(long long)ret*x%mod;\n\treturn ret;\n}\nint q[10101],qn;\nint f[10101];\nint main()\n{\n\tint n,k;\n\tint ans=0;\n\tscanf(\"%d%d\",&n,&k);\n\tqn=0;\n\tfor(int i=1;i*i<=n;i++)\n\t\tif(n%i==0)\n\t\t{\n\t\t\tq[++qn]=i;\n\t\t\tif(i*i!=n)\n\t\t\t\tq[++qn]=n/i;\n\t\t}\n\tsort(q+1,q+1+qn);\n\tfor(int i=1;i<=qn;i++)\n\t{\n\t\tf[i]=fpow(k,(q[i]+1)>>1);\n\t\tfor(int j=1;j<i;j++)\n\t\t\tif(q[i]%q[j]==0)\n\t\t\t\t(f[i]+=mod-f[j])%=mod;\n\t}\n\tfor(int i=1;i<=qn;i++)\n\t\tif(q[i]&1)\n\t\t\tans=((long long)f[i]*q[i]+ans)%mod;\n\t\telse\n\t\t\tans=((long long)f[i]*q[i]/2+ans)%mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i++]++;\n\t}\n\t\n\treturn 0;\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,m,ans,a[5010],cnt,f[5010],p=1e9+7;\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y%2==1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nint main(){\n\tll i,j;\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i*i<=n;i++)if(n%i==0){\n\t\ta[++cnt]=i;\n\t\tif(n/i!=i)a[++cnt]=n/i;\n\t}\n\tsort(a+1,a+cnt+1);\n\t//puts(\"-1\");\n\tfor(i=1;i<=cnt;i++){\n\t\t//printf(\"%lld %lld\\n\",i,a[i]);\n\t\tf[i]=ksm(m,(a[i]+1)/2)%p;\n\t//\tputs(\"-2\");\n\t\tfor(j=1;j<i;j++)if(a[i]%a[j]==0)f[i]=(f[i]-f[j]+p)%p;\n\t\t//puts(\"-3\");\n\t\tif(a[i]%2==1)ans=(ans+a[i]*f[i]%p)%p;\n\t\t else ans=(ans+a[i]*f[i]%p*ksm(2,p-2)%p)%p;\n\t\t//printf(\"%lld %lld %lld\\n\",i,f[i],ans);\n\t}\n\tprintf(\"%lld\",ans);\n}\n/*\n一个串循环位移后能得到的不同的串的个数为该串的最短循环节\n枚举循环节长度，算出该长度的方案（容斥） \n1e9以内最多质因子的数只有1000多 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nusing ll = long long;\n\nint add(int x, int y) { return ((x += y) >= MOD) ? x - MOD : x; }\nint sub(int x, int y) { return add(x, MOD - y); }\nint mult(int x, int y) { return ll(x) * y % MOD; }\nint pw(int x, int y) {\n   int ans = 1;\n   for (; y > 0; y >>= 1, x = mult(x, x)) if (y & 1) ans = mult(ans, x);\n   return ans;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N, K;\n   cin >> N >> K;\n   vector<int> divs;\n   for (int i = 1; i * i <= N; ++i) {\n      if (N % i == 0) {\n         divs.emplace_back(i);\n         if (i * i < N) divs.emplace_back(N / i);\n      }\n   }\n   sort(divs.begin(), divs.end());\n   int M = divs.size();\n   vector<int> dp(M);\n   int ans = 0;\n   for (int i = 0; i < M; ++i) {\n      int z = divs[i];\n      dp[i] = pw(K, (z + 1) / 2);\n      for (int j = 0; j < i; ++j) {\n         if (divs[i] % divs[j] == 0) {\n            dp[i] = sub(dp[i], dp[j]);\n         }\n      }\n      ans = add(ans, mult(dp[i], (z % 2) ? z : z / 2));\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000000\n#define EPS 1e-10\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define double long double\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\n\nll mod = 1000000007;\nll modsize;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nint mobius(int n) {\n\tint ans = 0;\n\tint m = n;\n\tfor (int i = 2; i*i <= m; i++) {\n\t\tint check = 0;\n\t\twhile (n%i == 0) {\n\t\t\tn /= i;\n\t\t\tans++;\n\t\t\tcheck++;\n\t\t\tif (check >= 2) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1) ans++;\n\tif (ans % 2 == 0) return 1;\n\telse return -1;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\t//modcalc();\n\n\tint n, k;\n\tcin >> n >> k;\n\tbool flag = true;\n\tif (n % 2 == 0) {\n\t\tn /= 2;\n\t\tflag = false;\n\t}\n\tint ans = 0;\n\tmap<int, int> mp;\n\tfor (int i = 1; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tif (flag) {\n\t\t\t\tmp[i] = modpow(k, i);\n\t\t\t\tmp[n / i] = modpow(k, n / i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[i] = modpow(k, (i + 1) / 2);\n\t\t\t\tmp[n / i] = modpow(k, (n / i + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : mp) {\n\t\t//cout << i.first << ' ' << i.second << endl;\n\t\tint cnt = i.second;\n\t\tfor (auto j : mp) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i.first%j.first == 0) {\n\t\t\t\tcnt += mobius(i.first/j.first)*j.second;\n\t\t\t\tcnt = (cnt + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tcnt *= i.first;\n\t\tcnt %= mod;\n\t\tans += cnt;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,tot,ans;\nmap<int,int>mp;\nint f[1008],dor[1008];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;1ll*i*i<=n;i++)\n\tif (n%i==0)\n\t    {\n\t        dor[++tot]=i;\n\t\tif (n/i!=i) dor[++tot]=n/i;\n\t    }\n    sort(dor+1,dor+tot+1);\n    for (int i=1;i<=tot;i++) mp[dor[i]]=i;\n    for (int i=1;i<=tot;i++)\n\t{\n\t    f[i]=power(k,(dor[i]+1)/2);\n\t    for (int j=1;j<i;j++)\n\t\tif (dor[i]%dor[j]==0)\n\t\t    f[i]=(f[i]-f[j])%mod;\n\t}\n    //for (int i=1;i<=tot;i++) printf(\"%d %d\\n\",dor[i],f[i]);\n    for (int i=1;i<=tot;i++)\n    \tif ((n/dor[i])&1) ans=(ans+f[i])%mod;\n    \telse ans=((ans+f[i])%mod+f[mp[dor[i]*2]])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n    \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#define N 100010\n#define mod 1000000007\n#define ll long long\nusing namespace std;\nint num[N],tot;\nll n,k,f[N];\nll ksm(ll a,ll b=mod-2)\n{\n\tif(b==0) return 1;\n\tif(b==1) return a;\n\tll q=ksm(a,b>>1);\n\tif(b&1) return q*q%mod*a%mod;\n\treturn q*q%mod;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tfor(int i=1;i*i<=n;i++)\n\tif(n%i==0)\n\t{\n\t\tnum[++tot]=i;\n\t\tif(i*i!=n) num[++tot]=n/i;\n\t}\n\tsort(num+1,num+tot+1);\n\tll ans=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tf[i]=ksm(k,(num[i]+1)>>1);\n\t\tfor(int j=1;j<i;j++)\n\t\tif(num[i]%num[j]==0) f[i]=(f[i]-f[j]+mod)%mod;\n\t}\n\tfor(int i=1;i<=tot;i++)\n\tans=(ans+f[i]*num[i]/(num[i]&1?1:2))%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 0bd35dc5e428754fa574049b6be8efe0\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\nint n, K;\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>();\n}\n\nvector<int> seq;\nunordered_map<int, vector<int> > fact;\n\ninline void get_fact(int N)\n{\n\tfor(int i = 1; (LL) i * i <= N; ++i) if(N % i == 0)\n\t{\n\t\tseq.push_back(i);\n\t\tif(i != N / i) seq.push_back(N / i);\n\t}\n\n\tsort(ALL(seq));\n\tfor(auto i : seq) for(auto j : seq) if(i % j == 0 && i != j)\n\t\tfact[i].push_back(j);\n}\n\ninline void solve()\n{\n\tget_fact(n);\n\n\tstatic unordered_map<int, int> f;\n\n\tfor(auto i : seq)\n\t{\n\t\tf[i] = fpm(K, (i + 1) / 2);\n\t\tfor(auto d : fact[i]) f[i] -= f[d];\n\t}\n\n\tint ans[2] = {0, 0};\n\tfor(auto i : seq) (ans[i & 1] += (LL) f[i] * i % MOD) %= MOD;\n\n\tconst int inv2 = (MOD + 1) / 2;\n\tint res = ((LL) ans[0] * inv2 % MOD + ans[1]) % MOD;\n\tprintf(\"%d\\n\", (res + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nmap<int, int> mp;\n\nconst int mod = 1e9 + 7;\n\nint qpow(int a, int n){\n    int res = 1;\n    while(n > 0){\n        if(n & 1)\n            res = 1LL * res * a % mod;\n        a = 1LL * a * a % mod; \n        n >>= 1;\n    }\n    return res;\n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b){\n    a -= b;\n    if(a < 0)\n        a += mod;\n}\n\nint k;\n\nint Dp(int n){\n    if(mp.count(n))\n        return mp[n];\n    int res = qpow(k, (n + 1) / 2);\n    for(int i = 2;1LL * i * i <= n;i++){\n        if(n % i == 0){\n            sub(res, Dp(i));\n            if(i != n / i){\n                sub(res, Dp(n / i));\n            }\n        }\n    }\n    sub(res, Dp(1));\n    return mp[n] = res;\n}\n\nint main(){\n    int n;\n    cin >> n >> k;\n    mp[1] = k;\n    int res = 0;\n    for(int i = 1;1LL * i * i <= n;i++){\n        if(n % i == 0){\n            if(i & 1){\n                add(res, 1LL * Dp(i) * i % mod);\n            }else{\n                add(res, 1LL * Dp(i) * i / 2 % mod);\n            }\n            if(i != n / i){\n                if((n / i) & 1){\n                    add(res, 1LL * Dp(n / i) * n / i % mod);\n                }else{\n                    add(res, 1LL * Dp(n / i) * (n / i / 2) % mod);\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\n\nll powm(ll a,ll b){\n    ll res=1;\n    while(b){\n        if(b&1) res*=a;\n        a*=a;\n        a%=MOD;\n        res%=MOD;\n        b>>=1;\n    }\n    return res;\n}\n\nll mod_inv(ll x){\n    return powm(x,MOD-2);\n}\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    set<int> divisor;\n    for(int i=1;i<1e5;i++){\n        if(n%i==0){\n            divisor.insert(i);\n            divisor.insert(n/i);\n        }\n    }\n    vector<ll> div(divisor.begin(),divisor.end());\n\n    vector<ll> dp(div.size());\n    ll res=0;\n    \n    for(int i=0;i<div.size();i++){\n        ll cnt=powm(k,div[i]/2+(ll)(div[i]%2!=0));\n        cnt=(cnt+MOD)%MOD;\n        for(int j=0;j<i;j++){\n            if(div[i]%div[j]==0) cnt-=dp[j];\n            cnt=(cnt%MOD+MOD)%MOD;\n        }\n        dp[i]=cnt;\n        if(div[i]%2==0){\n            res+=(((cnt*mod_inv(2))%MOD)*div[i])%MOD;\n        }\n        else{\n            res+=(cnt*div[i])%MOD;\n        }\n        res%=MOD;\n    }\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t5005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nlong long n, k, dp[MAXN];\nint tot, value[MAXN];\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmp * tmp % P;\n\telse return tmp * tmp % P * x % P;\n}\nvoid inc(long long &x, long long y) {\n\tx = (x + y) % P;\n}\nvoid dec(long long &x, long long y) {\n\tx = (x - y + P) % P;\n}\nint main() {\n\tread(n), read(k);\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (i * i == n) value[++tot] = i;\n\t\telse if (n % i == 0) {\n\t\t\tvalue[++tot] = i;\n\t\t\tvalue[++tot] = n / i;\n\t\t}\n\t}\n\tsort(value + 1, value + tot + 1);\n\tfor (int i = 1; i <= tot; i++) {\n\t\tdp[i] = power(k, (value[i] + 1) / 2);\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tif (value[i] % value[j] == 0) dec(dp[i], dp[j]);\n\t}\n\tlong long ans = 0;\n\tfor (int i = 1; i <= tot; i++)\n\t\tif (value[i] & 1) inc(ans, value[i] * dp[i] % P);\n\t\telse inc(ans, value[i] / 2 * dp[i] % P);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\n//周期がiの約数の回文数\nint calcnum(int i, int K, int mod){\n    return modpow(K, (i + 1) / 2, mod);\n}\n\nint mebius(int d){\n    int m = 1;\n    int d0 = d;\n    for(int i = 2; i * i <= d; i++){\n        int k = 0;\n        while(d0 % i == 0){\n            k++;\n            d0 /= i;\n        }\n        if(k >= 2) return 0;\n        else if(k == 1) m *= -1;\n    }\n    if(d0 > 1) return -m;\n    else return m;\n}\n\nsigned main(){\n\n    int N, K; cin >> N >> K;\n    int mod = 1000000007;\n\n    map<int, int> f, mu;\n    for(int i = 1; i * i <= N; i++){\n        if(N % i == 0){\n            f[i] = calcnum(i, K, mod);\n            f[N / i] = calcnum(N / i, K, mod);\n            mu[i] = mebius(i);\n            mu[N / i] = mebius(N / i);\n        }\n    }\n    int ans = 0;\n    for(auto p: f){\n        int n = p.first;\n        int val = 0;\n        for(auto q: f){\n            int d = q.first;\n            if(n % d == 0){\n                val += mu[n / d] * q.second;\n                val = (val % mod + mod) % mod;\n            }\n        }\n        //g[n] = val;\n        //cout << n << \" \" << val << endl;\n        if(n % 2 == 0) ans += val * (n / 2);\n        else ans += val * n;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvector<pair<long long, long long> > prime_factorize(long long n) {\n    vector<pair<long long, long long> > res;\n    for (long long p = 2; p * p <= n; ++p) {\n        if (n % p != 0) continue;\n        int num = 0;\n        while (n % p == 0) { ++num; n /= p; }\n        res.push_back(make_pair(p, num));\n    }\n    if (n != 1) res.push_back(make_pair(n, 1));\n    return res;\n}\n\nvector<long long> calc_divisor(long long n) {\n    vector<long long> res;\n    for (long long i = 1LL; i*i <= n; ++i) {\n        if (n % i == 0) {\n            res.push_back(i);\n            long long j = n / i;\n            if (j != i) res.push_back(j);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    long long N, K;\n    cin >> N >> K;\n    \n    vector<long long> div = calc_divisor(N);\n    long long res = 0;\n    for (auto d : div) {\n        long long tmp = 0;\n        vector<long long> div2 = calc_divisor(d);\n        for (auto e : div2) {\n            auto pf = prime_factorize(d/e);\n            bool ok = true;\n            for (auto p : pf) {\n                if (p.second > 1) ok = false;\n            }\n            if (!ok) continue;\n            int mebius = (pf.size() & 1 ? -1 : 1);\n            long long pow = modpow(K, (e+1)/2, MOD);\n            tmp += pow * mebius;\n            tmp = (tmp % MOD + MOD) % MOD;\n        }\n        res += tmp * (d % 2 == 0 ? d/2 : d) % MOD;\n        res = res % MOD;\n        \n        //cout << d << \": \" << tmp << endl;\n    }\n    cout << res << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mod 1000000007\nusing namespace std;\nint n,K;\nint fac[100010],cnt;\nint f[100010];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint ans;\nint main()\n{\n    cin>>n>>K;\n    for(int i=1;i<=sqrt(n);i++)\n    {\n        if(n%i==0)\n        {\n            fac[++cnt]=i;\n            if(n/i!=i)  fac[++cnt]=n/i;\n        }\n    }\n    sort(fac+1,fac+cnt+1);\n    for(int i=1;i<=cnt;i++)\n    {\n        f[i]=quick_pow(K,(fac[i]+1)/2);\n        for(int j=1;j<i;j++)\n        {\n            if(fac[i]%fac[j]==0)  f[i]=(f[i]-f[j]+mod)%mod;\n        }\n        if(fac[i]&1)  ans=(ans+1ll*fac[i]*f[i]%mod)%mod;\n        else          ans=(ans+1ll*(fac[i]>>1)*f[i]%mod)%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint ModPow(int a,int r,int m)\n{\n\tint x=1;\n\tfor(;r;r>>=1){\n\t\tif(r&1) x=(ll)x*a%m;\n\t\ta=(ll)a*a%m;\n\t}\n\treturn x;\n}\n\nint ModInverse(int a,int m)\n{\n\tint x=1;\n\tfor(int b=m,u=0;b;){\n\t\tll t=a/b;\n\t\tswap(a-=b*t,b);\n\t\tswap(x-=u*t,u);\n\t}\n\treturn (x+m)%m;\n}\n\nint ModMul(int a,int b,int m)\n{\n\treturn (ll)a*b%m;\n}\n\nint ModDiv(int a,int b,int m)\n{\n\treturn ModMul(a,ModInverse(b,m),m);\n}\n\nint main()\n{\n\tfor(int n,k;cin>>n>>k&&n|k;){\n\t\tvi divs;\n\t\tfor(int i=1;i*i<=n;i++){\n\t\t\tif(n%i==0){\n\t\t\t\tdivs.push_back(i);\n\t\t\t\tif(i*i!=n)\n\t\t\t\t\tdivs.push_back(n/i);\n\t\t\t}\n\t\t}\n\t\tsort(all(divs));\n\n\t\tint m=divs.size();\n\t\tvi dp(m);\n\t\trep(i,m){\n\t\t\tdp[i]=ModPow(k,(divs[i]+1)/2,MOD);\n\t\t\trep(j,i) if(divs[i]%divs[j]==0)\n\t\t\t\tdp[i]=(dp[i]-dp[j]+MOD)%MOD;\n\t\t}\n\n\t\tint res=0;\n\t\trep(i,m)\n\t\t\tif(divs[i]%2==0)\n\t\t\t\t(res+=ModDiv(ModMul(divs[i],dp[i],MOD),2,MOD))%=MOD;\n\t\t\telse\n\t\t\t\t(res+=ModMul(divs[i],dp[i],MOD))%=MOD;\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=5e3+3,mo=1e9+7;\nint n,K,a[mn],f[mn];\nint Pow(LL x,int y){\n\tLL ans=1;\n\tfor(;y;y/=2,(x*=x)%=mo)if(y&1)(ans*=x)%=mo;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tint lim=sqrt(n);\n\tfo(i,1,lim)if(n%i==0){\n\t\ta[++a[0]]=i;\n\t\tif(i*i!=n)a[++a[0]]=n/i;\n\t}\n\tsort(a+1,a+a[0]+1);\n\tint ans=0;\n\tfo(i,1,a[0]){\n\t\tf[i]=Pow(K,(a[i]+1)/2);\n\t\tfo(j,1,i-1)if(a[i]%a[j]==0)f[i]=(f[i]-f[j])%mo;\n\t\tans=(ans+1ll*f[i]*((a[i]&1)?a[i]:a[i]/2))%mo;\n\t}\n\tprintf(\"%d\",(ans+mo)%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nvector<int> dzielniki_n;\n\nmap<int, int> palin;\n\nint pot(long long x, long long y){\n    long long wyn = 1;\n    while (y){\n        if (y % 2)\n            wyn = (wyn * x) % mod;\n        y /= 2;\n        x = (x * x) % mod;\n    }\n    return wyn;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    long long wynik = 0;\n    cin >> n >> k;\n    for (int i = 1; i * i <= n; i++)\n        if (n % i == 0){\n            dzielniki_n.push_back(i);\n            if (i * i < n)\n                dzielniki_n.push_back(n / i);\n        }\n    sort(dzielniki_n.begin(), dzielniki_n.end());\n    for (int i : dzielniki_n){\n        long long pom = pot(k, (i + 1) / 2);\n        for (int j = 0; dzielniki_n[j] < i; j++)\n            if (!(i % dzielniki_n[j])){\n                pom = (pom - palin[dzielniki_n[j]]) % mod;\n            }\n        palin[i] = pom;\n        if (i % 2)\n            wynik = (wynik + ((long long)pom * i) % mod) % mod;\n        else\n            wynik = (wynik + ((long long)pom * i / 2) % mod) % mod;\n    }\n    cout << wynik << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nLL K;\nvector<int> divs;\nmap<int, LL> dp;\n\nLL mypow(LL base, LL exp) {\n  if (exp == 0) return 1;\n  LL res = mypow(base*base%MOD, exp/2);\n  if (exp%2) res = res*base % MOD;\n  return res;\n}\n\nLL f(LL t) {\n  LL num = (t/2) + t%2;\n  return mypow(K, num);\n}\n\nint main() {\n  scanf(\"%d%lld\", &N, &K);\n  for (int d=1; d*d<=N; d++) {\n    if (N%d == 0) {\n      divs.eb(d);\n      divs.eb(N/d);\n    }\n  }\n  sort(all(divs));\n  divs.erase(unique(all(divs)), divs.end());\n  \n  LL ans = 0;\n  for (int g : divs) {\n    dp[g] = f(g);\n    vector<int> dd;\n    for (int d=1; d*d<=g; d++) {\n      if (g%d == 0) {\n        dd.eb(d);\n        dd.eb(g/d);\n      }\n    }\n    sort(all(dd));\n    dd.erase(unique(all(dd)), dd.end());\n    if (dd.back() == g) dd.pop_back();\n    for (int d : dd) {\n      dp[g] = (dp[g] + MOD - dp[d]) % MOD;\n    }\n    //printf(\"dp[%d]: %lld\\n\", g, dp[g]);\n    //ans += dp[g]*g;\n    //ans %= MOD;\n  }\n\n  if (N%2) {\n    for (int g : divs) {\n      ans += dp[g]*g;\n      ans %= MOD;\n    }\n  } else {\n    for (int g : divs) {\n      if (g%2) {\n        ans += dp[g]*g;\n      } else {\n        ans += dp[g]*(g/2);\n        ans %= MOD;\n      }\n    }\n  }\n\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint n,k,cnt,a[10000],b[10000],ans;\nconst int mu=1000000007;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*1ll*x%mu)\n\t\tif (y&1) ans=ans*1ll*x%mu;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tint x=(int)sqrt(n);\n\tfor (int i=1;i<=x;i++) \n\t\tif (n%i==0) a[++cnt]=i;\n\tint t=cnt;\n\tif (a[cnt]*a[cnt]==n) t--;\n\tfor (int i=t;i>=1;i--) a[++cnt]=n/a[i];\n\tfor (int i=1;i<=cnt;i++){\n\t\tb[i]=ksm(k,(a[i]+1)/2);\n\t\tfor (int j=1;j<i;j++) \n\t\t\tif (a[i]%a[j]==0) b[i]=(b[i]-b[j])%mu;\n\t\tb[i]=(b[i]+mu)%mu;\n\t\tif (a[i]%2==0) ans=(ans+a[i]/2*1ll*b[i])%mu;\n\t\telse ans=(ans+a[i]*1ll*b[i])%mu;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int mod=1e9+7;\nint n,k;\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint main(){\n\tread(n);read(k);\n\tif(n&1){\n\t\tprintf(\"%d\\n\",add(1ll*sub(power(k,(n+1)/2,mod),k)*n%mod,k));\n\t}else assert(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define vt vector\n#define ii pair<int,int>\n#define mp make_pair\n#define vi vt<int>\n#define vvi vt<vi>\n#define vii vt<ii>\n#define vvii vt<vii>\n#define For(i,a,b) for(int i = a; i < b; i++)\n#define foR(i,a,b) for(int i = a; i <= b; i++)\n#define roF(i,a,b) for(int i = a - 1; i >= b; i--)\n#define Rof(i,a,b) for(int i = a; i >= b; i--)\n#define NEW 0\n#define FOUNDED 1\n#define CHECKED 2\n#define pb push_back\n#define pob pop_back\n#define mset(a,b) memset(a,b,sizeof(a))\n\ntemplate<class T1, class T2> ostream& operator<< (ostream& the, pair<T1, T2> a){\n\tthe << a.first << \"\\t\" << a.second << \"\\n\";\n\treturn the;\n}\ntemplate<class T1> ostream& operator<< (ostream& the, vt<T1> a){\n\tFor(i,0,a.size()) {\n\t\tthe << a[i] << \"\\n\";\n\t}\n\treturn the;\n}\nconst int mod = 1000000007;\nint pr[100000];\nvi prime;\nvi pr_num;\nvi uoc, num;\nint bp(int a, int b){\n\tif(b == 0) return 1;\n\tint t = bp(a,b/2);\n\tif(b%2==0){\n\t\treturn t*t%mod;\n\t}else{\n\t\treturn t*t%mod*a%mod;\n\t}\n}\n\nvoid tim_uoc(int vt, int ht){\n\tif(vt == pr_num.size()){\n\t\tuoc.pb(ht);\n\t\treturn;\n\t}\n\tfoR(i,0,pr_num[vt]){\n\t\ttim_uoc(vt+1,ht*bp(prime[vt],i));\n\t}\n}\n\nsigned main () {\n\n//\tfreopen(\"INP.txt\",\"r\",stdin);\n//\tfreopen(\"OUT.txt\",\"w\",stdout);\n//\tfreopen(\".inp\",\"r\",stdin);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n//  ifstream fin(\"in.txt\");\n//  ofstream fout(\"out.txt\");\n//  ifstream dict(\"dict.txt\");\n// \tbon ga nay\n\tint n, k;\n\tcin >> n >> k;\n\tFor(i,2,100000){\n\t\tif(pr[i] == 0){\n\t\t\tprime.pb(i);\n\t\t\tfor(int j = 2*i; j < 100000; j+=i){\n\t\t\t\tpr[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint t = n, coun;\n\tFor(i,0,prime.size()){\n\t\tcoun = 0;\n\t\twhile(t % prime[i] == 0){\n\t\t\tt/=prime[i];\n\t\t\tcoun++;\n\t\t} \n\t\tpr_num.pb(coun);\n\t}\n\ttim_uoc(0,1);\n\tsort(uoc.begin(),uoc.end());\n\tFor(i,0,uoc.size()){\n\t\tint te = bp(k,(uoc[i]+1)/2);\n\t\tFor(j,0,i){\n\t\t\tif(uoc[i]%uoc[j] == 0){\n\t\t\t\tte -= num[j];\n\t\t\t}\n\t\t}\n\t\tnum.pb(te);\n\t}\n\tint tong = 0;\n\tFor(i,0,num.size()){\n\t\ttong = (tong+(num[i]*((uoc[i]%2 == 0)?(uoc[i]/2):uoc[i]))%mod)%mod;\n\t}\n\tif(tong < 0) tong += mod;\n\tcout << tong;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*SS=SZB,*TT=SZB;\n    inline char gc(){   if (SS==TT){  TT=(SS=SZB)+fread(SZB,1,GYN,stdin); if (SS==TT) return '\\n';  }   return *SS++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace SHENZHEBEI;\nconst int N=500105,mod=1e9+7;\nll q[N],sum[N],n,k,top,ans;\nll ppow(ll x,ll k){ll ans=1;for(;k;k>>=1,Mul(x,x))if (k&1)Mul(ans,x);return ans;}\nint main(){\n\tn=read(),k=read();\n\tfor(ll i=1;i*i<=n;i++)if (!(n%i)){\n\t\tq[++top]=i;\n\t\tif (n!=i*i)q[++top]=n/i;\n\t}sort(q+1,q+top+1);\n\tFor(i,1,top)sum[i]=ppow(k,(q[i]+1)>>1);\n\tFor(i,1,top){\n\t\trep(j,1,i)if (!(q[i]%q[j]))Add(sum[i],-sum[j]+mod);\n\t\tAdd(ans,sum[i]*((q[i]&1)?q[i]:(q[i]>>1)));\n\t}Add(ans,mod);\n\twriteln(ans);\n}\n/*\n11221122\n12211221\n22112211\n21122112\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int MOD=1e9+7;\nint n,m,ans,nn;\nint d[1505];\nvector<int> v;\n\nint Pow(int x,int y){\n\tint ret=1,mt=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*mt%MOD;\n\t\tmt=1ll*mt*mt%MOD;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=MOD) x-=MOD;\n\tif(x<0) x+=MOD;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tnn=n/2;\n\tfor(int i=1;i*i<=nn;i++) if(nn%i==0){\n\t\tv.push_back(i);\n\t\tif(i!=nn/i) v.push_back(nn/i);\n\t}\n\tif(n==1){\n\t\tprintf(\"%d\\n\",m);\n\t\treturn 0;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint x=v[i];\n\t\td[i]=Pow(m,x);\n\t\tfor(int j=0;j<i;j++) if(x%v[j]==0) add(d[i],-d[j]);\n\t\tif(n%2==0) add(ans,1ll*d[i]*x%MOD);\n\t\telse{\n\t\t\tif(x==1){\n\t\t\t\tadd(ans,((1ll*m)+(1ll*m*(m-1)%MOD*n%MOD))%MOD);\n\t\t\t}else{\n\t\t\t\tadd(ans,1ll*d[i]*x%MOD*m%MOD*(nn/x)%MOD);\n\t\t\t\tadd(ans,1ll*d[i]*m%MOD);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nLL powmod(LL x, LL y){\n\tLL a = 1;\n\twhile(y){\n\t\tif(y & 1){ a = a * x % MOD; }\n\t\ty >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn a;\n}\n\nLL solve(LL n, LL k){\n\tif(n & 1){\n\t\tLL x = powmod(k, (n + 1) / 2);\n\t\treturn (x - 1) * n + 1;\n\t}\n\t\n\tLL m = n / 2;\n\tvector<LL> divs;\n\tfor(LL i = 1; i * i <= m; ++i){\n\t\tif(m % i == 0){\n\t\t\tdivs.push_back(i);\n\t\t\tif(i * i != m){ divs.push_back(m / i); }\n\t\t}\n\t}\n\tsort(ALL(divs));\n\tint sz = divs.size();\n\tvector<LL> cnt(sz);\n\tLL ans = 0;\n\tfor(int i = 0; i < sz; ++i){\n\t\tLL x = cnt[i] % MOD;\n\t\tx += powmod(k, divs[i]);\n\t\tx = (x + MOD) % MOD;\n\t\tcnt[i] = x;\n\t\tans = (ans + divs[i] * x) % MOD;\n\t\t\n\t\tfor(int j = i + 1; j < sz; ++j){\n\t\t\tif(divs[j] % divs[i] == 0){\n\t\t\t\tcnt[j] -= x;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid mainmain(){\n\tLL n, k;\n\tcin >> n >> k;\n\tcout << solve(n, k) << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nconst int maxn=2e3+10;\nint n,k,tot,ans,a[maxn],f[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nint power(int a,int b){\n    int ret=1;\n    for(;b;b>>=1,a=1ll*a*a%mod)\n        if(b&1)ret=1ll*ret*a%mod;\n    return ret;\n}\nint main(){\n    n=read();k=read();int num=sqrt(n);\n    for(int i=1;i*i<n;i++)\n        if(!(n%i))a[++tot]=i,a[++tot]=n/i;\n    if(num*num==n)a[++tot]=num;sort(a+1,a+tot+1);\n    for(int i=1;i<=tot;i++){\n        f[i]=power(k,(a[i]+1)>>1);\n        for(int j=1;j<i;j++)if(!(a[i]%a[j]))f[i]=f[i]-f[j];\n        if(a[i]&1)ans=(ans+1ll*a[i]*f[i])%mod;\n        else ans=(ans+a[i]*1ll*power(2,mod-2)%mod*f[i])%mod;\n    }write(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=5e5+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nll b[N],f[N],n,m,k;\nint main(){\n\tread(n,k);\n\tfor(int i=1;i*i<=n;i++)if(n%i==0){\n\t\tb[++m]=i;\n\t\tif(i!=n/i)b[++m]=n/i;\n\t}sort(b+1,b+1+m);ll ans=0;\n\trep(i,1,m)f[i]=qpow(k,(b[i]+1)/2);\n\trep(i,1,m)rep(j,i+1,m)if(b[j]%b[i]==0)f[j]=(f[j]-f[i]+mod)%mod;\n\trep(i,1,m)if(b[i]&1)ans=(ans+f[i]*b[i])%mod;\n\t\telse ans=(ans+f[i]*b[i]/2)%mod;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nconst int N=2e5+20;\nvector<ll> v;\nll n,k,dp[2500];\nll powmod(ll x,ll n)\n{\n\tll s=1;\n\twhile(n)\n\t{\n\t\tif(n&1)\n\t\t\ts=(s*x)%mod;\n\t\tn>>=1;\n\t\tx=(x*x)%mod;\n\t}\n\treturn s;\n}\nvoid init()\n{\n\tv.clear();\n\tfor(ll i=1;i*i<=n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tv.push_back(i);\n\t\t\tif(i*i!=n)\n\t\t\t\tv.push_back(n/i);\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n}\nint main()\n{\n\twhile(cin>>n>>k)\n\t{\n\t\tinit();\n\t\tll ans=0;\n\t\tfor(int x=0;x<v.size();x++)\n\t\t{\n\t\t\tdp[x]=powmod(k,(v[x]+1)/2);\n\t\t\tfor(int y=0;y<x;y++)\n\t\t\t{\n\t\t\t\tif(v[x]%v[y]==0)\n\t\t\t\t\tdp[x]=(dp[x]-dp[y]+mod)%mod;\t\n\t\t\t}\t\n\t\t\tif(v[x]%2)\n\t\t\t\tans=(ans+(dp[x]*v[x])%mod)%mod;\n\t\t\telse\n\t\t\t\tans=(ans+(dp[x]*v[x]/2)%mod)%mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst long long mod = 1000000007;\n\nlong long fpow(long long a, long long p)\n{\n\tlong long r = 1;\n\twhile (p){\n\t\tif (p & 1) r = r * a % mod;\n\t\ta = a * a % mod;\n\t\tp /= 2;\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tint N,K;\n\tscanf (\"%d %d\",&N,&K);\n\n\tvector<int> f;\n\tfor (int i=1;i*i<=N;i++) if (N % i == 0){\n\t\tf.push_back(i);\n\t\tif (i * i != N) f.push_back(N/i);\n\t}\n\tsort(f.begin(),f.end());\n\n\tvector<long long> d(f.size());\n\tlong long ans = 0;\n\tfor (int i=0;i<f.size();i++){\n\t\td[i] = fpow(K,(f[i]+1)/2);\n\t\tfor (int j=0;j<i;j++) if (f[i] % f[j] == 0){\n\t\t\td[i] = (d[i] + mod - d[j]) % mod;\n\t\t}\n\t\tlong long n = d[i] * f[i] % mod;\n\t\tif (f[i] % 2 == 0) n = n * 500000004 % mod;\n\t\tans = (ans + n) % mod;\n\t}\n\n\tprintf (\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nll quick_pow(ll a,ll b){\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) ans=ans*a%mod;\n\treturn ans;\n}\nll n,K,ans=0,op[100005],s[100005],sum[100005];\nint top;\nint main(){\n\tscanf(\"%lld%lld\",&n,&K);\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\ts[++top]=i;\n\t\t\tif(n!=i*i) s[++top]=n/i;\n\t\t}\n\t}\n\tsort(s+1,s+top+1);\n\tfor(int i=1;i<=top;i++) sum[i]=quick_pow(K,(s[i]+1)/2);\n\tfor(int i=1;i<=top;i++){\n\t\tll tot=sum[i];\n\t\tfor(int p=1;p<i;p++) if(s[i]%s[p]==0){\n\t\t\ttot=(tot-sum[p])%mod;\n\t\t}\n\t\tsum[i]=tot;\n\t\tans=(ans+tot*((s[i]&1)?s[i]:(s[i]>>1)))%mod;\n\t}\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=110,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint dec(int x,int y){x-=y;return x<0?x+p:x;}\nint mul(int x,int y){return (ll)x*y%p;}\nint power(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x))\n\t\tif (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nint n,k,prime[N],pw[N],cnt;\nvoid factor(int x){\n\tfor (int i=2;i*i<=x;i++)\n\tif (x%i==0){\n\t\tprime[++cnt]=i;\n\t\twhile (x%i==0) pw[cnt]++,x/=i;\n\t}\n\tif (x>1) prime[++cnt]=x,pw[cnt]=1;\n}\nint ans,fac[1<<20],bit[1<<20],bits[1<<20];\nvoid dfs(int x,int val){\n\tif (x>cnt){\n        int size=0;\n        for (int i=1;i<=cnt;i++)\n            if (val%prime[i]==0) bit[1<<(size++)]=prime[i];\n        fac[0]=1;\n        for (int i=1;i<(1<<size);i++) fac[i]=fac[i^(i&-i)]*bit[i&-i];\n        int calc=0;\n        for (int i=0;i<(1<<size);i++){\n            int v=power(k,(val/fac[i]+1)>>1);\n            calc=(bits[i]&1?dec(calc,v):inc(calc,v));\n        }\n        if ((val&1)==0) val/=2;\n        ans=inc(ans,mul(calc,val));\n        return;\n\t}\n\tdfs(x+1,val);\n\tfor (int i=1;i<=pw[x];i++) dfs(x+1,val*=prime[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfactor(n);\n\tfor (int i=0;i<(1<<20);i++) bits[i]=bits[i>>1]+(i&1);\n\tdfs(1,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[2002],dp[2002];\nint mod=1e9+7;\nint binpow(int a,int b){\n\tif(b==0) return 1;\n\tint x=binpow(a,b/2);\n\tx*=x; \n\tx%=mod;\n\tif(b%2) return (x*a)%mod;\n\telse return x;\n}\nint main(){\n\tint n,k; \n\tcin>>n>>k;\n\tint tmp=0;\n\tfor (int i=1 ; i*i<=sqrt(n) ; i++){\n\t\tif(!n%i){\n\t\t\ta[tmp]=i; \n\t\t\ttmp++;\n\t\t\tif(i*i!=n){\n\t\t\t\ta[tmp]=n/i;\n                tmp++;\n\t\t\t}\n\t\t}\n\t}\n\tsort(a,a+tmp);\n\tfor (int i=0 ; i<tmp ; i++){\n\t\tdp[i]=binpow(k,(a[i]+1)/2);\n\t\tfor (int j=0 ; j<i ; j++){\n\t\t\tif(a[i]%a[j]==0){\n\t\t\t\t((dp[i]-=dp[j])+=mod)%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0 ; i<tmp ; i++){\n\t\tif(a[i]%2) (ans+=(dp[i]*a[i]))%=mod;\n\t\telse (ans+=(dp[i]*(a[i]/2)))%=mod;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <algorithm>\n\ntypedef long long ll;\ninline int Get() {\n\tchar ch;\n\twhile ((ch = getchar()) < '0' || ch > '9');\n\tint Num = ch - '0';\n\twhile ((ch = getchar()) >= '0' && ch <= '9')\n\t\tNum = (Num << 3) + (Num << 1) + ch - '0';\n\treturn Num;\n}\nconst int Mod = 1e9 + 7;\nint n, m, ans;\nstd :: vector <int> v, g;\ninline int pow(int x, int k) {\n\tll res = 1, r = x % Mod;\n\tfor (; k; k >>= 1, r = r * r % Mod) \n\t\tif (k & 1) res = res * r % Mod;\n\treturn res;\n}\nint main() {\n\tn = Get(), m = Get();\n\tfor (int i = 1; (ll)i * i <= n; ++i)\n\t\tif (!(n % i)) {\n\t\t\tv.push_back(i), g.push_back(0);\n\t\t\tif (n / i != i) v.push_back(n / i);\n\t\t}\n\t\n\tstd :: sort(v.begin(), v.end());\n\tfor (int i = 0, sze = v.size(), x; i < sze; ++i) {\n\t\tx = v[i], g[i] = pow(m, x + (x & 1) >> 1);\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tif (!(x % v[j])) g[i] = (g[i] - g[j] + Mod) % Mod;\n\t} \n\t\n\tfor (int i = 0, sze = v.size(), x; i < sze; ++i)\n\t\tx = v[i], (ans += (ll)((x & 1) ? x : x >> 1) * g[i] % Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int mod=1e9+7;\nint n,k;\nint main(){\n\tread(n);read(k);\n\tif(n&1){\n\t\tprintf(\"%lld\\n\",1ll*power(k,(n+1)/2,mod)*n%mod);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"math.h\"\nusing namespace std;\n\nlong long int ans=1;\nlong long int N, M;\nlong long int box;\nlong long int modi[100];\nint num;\n\nint main() {\n\tcin >> N >> M;\n\tbox = (N+1)/2;\n\tmodi[0] = M;\n\tfor (int i = 1; i < 100; i++) {\n\t\tmodi[i] = modi[i - 1] * modi[i - 1];\n\t\tmodi[i] %= 1000000007;\n\t}\n\twhile (box>0) {\n\t\tif (box % 2 == 0) {\n\t\t\tbox /= 2;\n\t\t\tnum++;\n\t\t}\n\t\telse {\n\t\t\tans *= modi[num];\n\t\t\tans %= 1000000007;\n\t\t\tbox--;\n\t\t}\n\t}\n\tif(N%2==0)\tans += ((ans - M)*((N + 1) / 2 - 1))%1000000007;\n\telse ans += ((ans - M)*(N - 1))%1000000007;\n\twhile(ans<0)ans += 10000000070000000;\n\tans %= 1000000007;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nint n, k;\nint getAll(int n) {\n    if (n % 2 == 1) {\n        return mult(n, pw(k, (n + 1) / 2));\n    }\n    else {\n        return mult(n / 2, pw(k, n / 2));\n    }\n}\nint val(int x, int y) {\n    if (x % 2 == 1) {\n        return pw(k, (x + 1) / 2);\n    }\n    if (y % 2 == 0) {\n        return pw(k, (x / 2) + 1);\n    }\n    else {\n        return pw(k, x / 2);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    vector < int > divs;\n    int pp = n;\n    if (n % 2 == 0) pp /= 2;\n    for (int i = 1; 1LL * i * i <= pp; i++) {\n        if (pp % i == 0) {\n            divs.emplace_back(i);\n            if (i != (pp / i)) divs.emplace_back(pp / i);\n        }\n    }\n    sort(divs.begin(), divs.end());\n    vector < int > calc(divs.size());\n    for (int i = 0; i < divs.size(); i++) {\n        calc[i] = divs[i];\n    }\n    for (int i = divs.size() - 1; i >= 0; i--) {\n        for (int j = i + 1; j < divs.size(); j++) {\n            if (divs[j] % divs[i] == 0) {\n                calc[i] = sub(calc[i], calc[j]);\n            }\n        }\n    }\n    /*int my_ans = 0;\n    map < int, int > he;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (mask == 0) continue;\n        int d = n;\n        int frst = -1;\n        int p = 0;\n        for (int bit = 0; bit < n; bit++) {\n            if (mask & (1 << bit)) {\n                p++;\n                if (frst == -1) frst = bit;\n                else {\n                    d = __gcd(d, abs(frst - bit));\n                }\n            }\n        }\n        int cur_ans = val(d, frst);\n        if (p % 2 == 1) {\n            my_ans = sum(my_ans, cur_ans);\n            he[d]++;\n        }\n        else {\n            my_ans = sub(my_ans, cur_ans);\n            he[d]--;\n        }\n\n    }\n    for (auto it : he) {\n        cout << it.first << \" \" << it.second << endl;\n    }\n    cout << \"-----------------\" << endl;\n    cout << \"I got \" << my_ans << endl;\n     */\n\n    int ans = 0;\n    if (n % 2 == 0) {\n        for (int i = 0; i < divs.size(); i++) {\n            ans = sum(ans, mult(getAll(2 * divs[i]), mult(calc[i], pw(divs[i], mod - 2))));\n        }\n    }\n    else {\n        for (int i = 0; i < divs.size(); i++) {\n            ans = sum(ans, mult(getAll(divs[i]), mult(calc[i], pw(divs[i], mod - 2))));\n        }\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp setprecision\n#define pb(x) push_back(x)\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst string alpha = \"abcdefghijklmnopqrstuvwxyz\";\n\nconst int MAX_N = 2e5;\nll fac[MAX_N+1], ifac[MAX_N+1], inv[MAX_N+1];\n\n//mpow(x,n)で(x^n)をO(log(n))で計算\nll mpow(ll x, ll n){\n    ll res = 1, now = x;\n    while(n > 0){\n        if(n & 1) res *= now, res %= MOD;\n        now *= now, now %= MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\n//setcomb()でfac,ifac,invを全て計算\nvoid setcomb(){\n    rep2(i, 1, MAX_N){\n        inv[i] = mpow(i, MOD-2);\n    }\n    //i!とi!の逆元\n    fac[0] = 1, ifac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = (fac[i-1]*i) % MOD;\n        ifac[i] = (ifac[i-1]*inv[i]) % MOD;\n    }\n}\n\n//comb(n, k)でnCk\nll comb(int n, int k){\n    ll c = fac[n];\n    c *= ifac[n-k], c %= MOD;\n    c *= ifac[k], c %= MOD;\n    return c;\n}\n\n//perm(n, k)でnPk\nll perm(int n, int k){\n    return(fac[n]*ifac[n-k])%MOD;\n}\n\nll N, K;\nvector<ll> ds, ps;\n\n//n文字で複数の同じ文字列に分解できない回分の数\nll num(ll n){\n    vector<ll> p;\n    for(auto &e: ps) if(n%e == 0) p.pb(e);\n    ll sum = 0;\n    int N = p.size();\n    rep(i, 1<<N){\n        int c = __builtin_popcount(i);\n        //n個をj文字ずつの回文に区切れる場合\n        ll j = 1;\n        rep(k, N) if(i & (1<<k)) j *= p[k];\n        j = n/j;\n        ll tmp = mpow(K, (j+1)/2);\n        if(c&1) sum += MOD-tmp;\n        else sum += tmp;\n        sum %= MOD;\n    }\n    return sum;\n}\n\nint main(){\n    cin >> N >> K;\n    rep2(i, 1, N){\n        if(i*i > N) break;\n        if(i*i == N) ds.pb(i);\n        elif(N%i == 0) ds.pb(i), ds.pb(N/i);\n    }\n    ll sub = N;\n    rep2(i, 2, N){\n        if(sub == 1) break;\n        if(i*i > sub) {ps.pb(sub); break;}\n        if(sub%i == 0) ps.pb(i);\n        while(sub%i == 0) sub /= i;\n    }\n    ll sum = 0;\n    //e文字ずつで区切れる場合\n    //for(auto &e: ps) cout << e << endl;\n    for(auto &e: ds){\n        //cout << e << ' ' << num(e) << endl;\n        if(e&1) sum += e*num(e), sum %= MOD;\n        else sum += (e/2)*num(e), sum %= MOD;\n    }\n    cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<int, ll> pli;\ntypedef pair<double,double> pdd;\n#define SQ(i) ((i)*(i))\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define SZ(i) int(i.size())\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define REP1(i,j) FOR(i, 1, j+1, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define ALL(_a) _a.begin(),_a.end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#ifdef tmd\n#define TIME(i) Timer i(#i)\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,deque<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define TIME(i)\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n#endif\nclass Timer {\nprivate:\n    string scope_name;\n    chrono::high_resolution_clock::time_point start_time;\npublic:\n    Timer (string name) : scope_name(name) {\n        start_time = chrono::high_resolution_clock::now();\n    }\n    ~Timer () {\n        auto stop_time = chrono::high_resolution_clock::now();\n        auto length = chrono::duration_cast<chrono::microseconds>(stop_time - start_time).count();\n        double mlength = double(length) * 0.001;\n        debug(scope_name, mlength);\n    }\n};\n\nconst ll MOD = 1000000007;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst int iNF = 0x3f3f3f3f;\nconst ll MAXN = 100005;\n\nll n, k, dp[MAXN];\nvector<ll> divi;\nvector<ll> ddivi[MAXN];\n\nll mpow(ll base,ll ep) {\n    ll ret = 1;\n    while (ep > 0) {\n        if (ep & 1) {\n            ret = ret * base % MOD;\n        }\n        base = base * base % MOD;\n        ep >>= 1;\n    }\n    return ret;\n}\n/********** Good Luck :) **********/\nint main()\n{\n    TIME(main);\n    IOS();\n\n    cin >> n >> k;\n    for (int i=1; i*i<=n; i++) {\n        if (n % i == 0) {\n            divi.eb(i);\n            if (i * i != n) {\n                divi.eb(n/i);\n            }\n        }\n    }\n    sort(ALL(divi));\n\n    REP (i, SZ(divi)) {\n        ll d = divi[i];\n        for (int j=1; j*j<=d; j++) {\n            if (d % j == 0) {\n                ddivi[i].eb(lower_bound(ALL(divi), j)-divi.begin());\n                if (j * j != d) {\n                    ddivi[i].eb(lower_bound(ALL(divi), d/j)-divi.begin());\n                }\n            }\n        }\n        sort(ALL(ddivi[i]));\n        ddivi[i].pop_back();\n    }\n\n    ll ans = 0;\n    REP (i, SZ(divi)) {\n        if ((n / divi[i]) & 1) {\n            dp[i] = mpow(k, (divi[i]+1)/2);\n        } else {\n            dp[i] = mpow(k, divi[i]);\n        }\n\n        for (auto v : ddivi[i]) {\n            dp[i] -= dp[v];\n        }\n        dp[i] = (dp[i] % MOD + MOD) % MOD;\n        debug(divi[i], dp[i]);\n        ans += divi[i] * dp[i];\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n\nlong long bipow(long long K, int p){\n    if(p == 0) return 1;\n    if(p % 2 == 0){\n        long long tmp = (K * K) % MOD;\n        return bipow(tmp, p / 2) % MOD;\n    }else\n        return (K * bipow(K, p-1)) % MOD;\n}\n\nvector<long long> divs(int n){\n    vector<long long> ret;\n    for(int i=1; i*i<=n; i++){\n        if(n % i == 0){\n            ret.push_back(i);\n            if(i * i != n) ret.push_back(n / i);\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    long long N, K;\n    cin >> N >> K;\n\n    vector<long long> dv = divs(N);\n    sort(dv.begin(), dv.end());\n\n    vector<long long> num(dv.size(), 0);\n\n    num[0] = K;\n    for(int i=1; i<dv.size(); i++){\n        long long d = dv[i];\n        long long tmp1 = bipow(K, (d+1)/2);\n        long long tmp2 = 0;\n        for(int j=0; j<i; j++){\n            int d2 = dv[j];\n            if(d % d2 == 0) tmp2 = (tmp2 + num[j]) % MOD;\n        }\n        num[i] = (tmp1 - tmp2 + MOD) % MOD;\n    }\n    long long ans = 0;\n    for(int i=0; i<dv.size(); i++){\n        long long d = dv[i];\n        if(d % 2 == 0)\n            ans += (num[i] * d / 2) % MOD;\n        else\n            ans += (num[i] * d) % MOD;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n\n//-----\nconst int N = 1e3 + 7, MOD = 1e9 + 7;\nint add(int a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }\nint mul(int a, int b) { return ll(a) * b % MOD; }\nint qpow(int a, int b) { int r = 1; for (;b;b>>=1) {if (b&1)r=mul(r,a);a=mul(a,a);}return r; }\nint n, k, dp[N];\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n  cin >> n >> k;\n  vi v;\n  for (int i = 1; i * i <= n; i++) if (n % i == 0) {\n  \tv.pb(i);\n  \tif (i * i <= n) v.pb(n / i);\n\t}\n\tsort(all(v));\n\tint ans = 0;\n\trep(i, 0, sz(v)) {\n\t\tdp[i] = qpow(k, v[i] + 1 >> 1);\n\t\trep(j, 0, i) if (v[i] % v[j] == 0) dp[i] = add(dp[i], MOD - dp[j]);\n\t\tif (v[i] & 1) ans = add(ans, mul(dp[i], v[i]));\n\t\telse ans = add(ans, mul(dp[i], v[i] >> 1));\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ll long long\n#define rep2(i,a,b) for(int i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\nll MOD=1e9+7;\n#define INF 1e9+7\n#define N 310000\n#define MAX_V 400010\n#define vec vector<int>\nusing namespace std;\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umap unordered_map<ll,int,custom_hash>\nstruct pair_hash\n{\n    template<class T1,class T2>\n    size_t operator() (const pair<T1,T2> &p)const{\n        return hash<T1>()(p.first)^hash<T2>()(p.second);\n    }\n};\nll int inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N){\n        inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n    }\n    return;\n}\nvoid calc_comb(ll int n){\n    comb[0]=1;\n    rep2(i,1,n){\n        comb[i]=comb[i-1]*(n+1-i)*inv[i]%MOD;\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N){\n        prd[i]=i*prd[i-1]%MOD;\n        invprd[i]=inv[i]*invprd[i-1]%MOD;\n    }\n    return ;\n}\nll cmb(int a,int b){\n    return prd[a]*invprd[b]%MOD*invprd[a-b]%MOD;\n}\nll modpow(ll x,ll n){\n    if(n==0) return 1;\n    ll res=modpow(x*x%MOD,n/2);\n    if(n&1) res=res*x%MOD;\n    return res;\n}\nvector<int> divisor(int n){\n    vector<int> res;\n    for(int i=1;i*i<=n;i++){\n        if(n%i==0){\n            res.push_back(i);\n            if(i!=n/i) res.push_back(n/i);\n        }\n    }\n    return res;\n}\nvec d;\nll m;\nmap<ll,ll> mp;\nll calc(int k){\n    ll sum=modpow(m,(k+1)/2);\n    rep(i,d.size()){\n        if(k%d[i]==0&&k!=d[i])sum-=mp[d[i]];\n        sum=(sum+MOD)%MOD;\n    }\n    mp[k]=sum;\n    return (k%2?sum*k%MOD:sum*k/2%MOD);\n}\nmain(){\n    ll n;\n    cin>>n>>m;\n    calc_inv();\n    d=divisor(n);\n    sort(d.begin(),d.end());\n    ll ans=0;\n    rep(i,d.size()){\n        ans=(ans+calc(d[i]))%MOD;\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\n\nlong long modpow(long long a, long long n){\n    if(n==0) return 1;\n    long long re=modpow((a*a)%MOD,n/2)%MOD;\n    if(n%2==1) re= (re*a)%MOD;\n    return re;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    LL n,k;\n    cin >> n >> k;\n    if(n%2==0){\n        cout << (n*modpow(k,n/2)-n*k/2+MOD)*modpow(2,MOD-2)%MOD <<endl;\n    }else{\n        cout << (n*modpow(k,(n+1)/2)-(n-1)*k+MOD)%MOD<<endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nint n, k, tot, ans, a[N], dp[N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint Dec(int a, int b){\n    return (a -= b) < 0 ? a + Mod : a;\n}\nint Mul(int a, int b){\n    return 1ll * a * b % Mod;\n}\nint Qpow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1) ans = Mul(ans, a);\n        a = Mul(a, a), b >>= 1;\n    }\n    return ans;\n}\nint main(){\n    n = read(), k = read();\n    for(int i = 1; i * i <= n; ++i) if(n % i == 0){\n        a[++tot] = i;\n        if(n / i != i) a[++tot] = n / i;\n    }\n    sort(a + 1, a + tot + 1);\n    rep(i, 1, tot){\n        dp[i] = Qpow(k, (a[i] + 1) / 2);\n        rep(j, 1, i - 1) if(a[i] % a[j] == 0) dp[i] = Dec(dp[i], dp[j]);\n        if(a[i] & 1) ans = Inc(ans, Mul(dp[i], a[i]));\n        else ans = Inc(ans, Mul(dp[i], a[i] / 2));\n    }\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,k,ans;\n\nvector<int> has;\n\nint f[maxn];\n\nvoid Work(){\n\tn=has.size();\n\tREP(i,0,n-1){\n\t\tf[i]=fexp(k,(has[i]+1)>>1);\n\t\tREP(j,0,i-1)f[i]=(f[i]-f[j]+mod)%mod;\n\t\tif(has[i]&1)ans=(ans+1ll*f[i]*has[i])%mod;else ans=(ans+1ll*f[i]*has[i]/2)%mod;\n\t}\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,k);\n\tREP(i,1,(int)sqrt(n+.5))if(n%i==0)has.PB(i),has.PB(n/i);\n\tsort(has.begin(),has.end());\n\thas.erase(unique(has.begin(),has.end()),has.end());\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int P = 1e9 + 7;\nint Pow(int a,int t){\n    int r=1;for(;t;t>>=1,a=1ll*a*a%P)if(t&1)r=1ll*r*a%P;\n    return r;\n}\nvoid pp(int &a,int b){\n    a += b;\n    if(a >= P) a -= P;\n}\nint n , K;\n\nint main(){\n    cin >> n >> K;\n    int ans = 0;\n    if(n == -1){\n        ans = 1ll * Pow(K , n/2+1) * n % P;\n        pp(ans , P - 1ll * K * (n - 1) % P);\n    } else {\n        int x = n / 2;\n        set<int> S;\n        map<int,int> Mp;\n        for(int i=1;i*i<=n;++i) if(n % i == 0) S.insert(i) , S.insert(n / i);\n        for(auto e : S){\n            int t = 0;\n            if(n % 2 == 0 && x % e == 0) t = Pow(K , e);\n            else t = Pow(K , (e + 1) / 2);\n            for(auto f : Mp) if(e % f.fi == 0) pp(t , P - f.se);\n            pp(ans , 1ll * t * e % P);\n            Mp[e] = t;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> div;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\twhile(true) {\n\t\tLL num = 1, prod = 1;\n\t\tinc(i, pn) {\n\t\t\tinc(j, count[i]) {\n\t\t\t\tif(j == 0) { num *= -1; } else { num = 0; }\n\t\t\t\t(prod *= p[i]) %= MOD;\n\t\t\t}\n\t\t}\n\t\tdiv.push_back(prod);\n\t\tmu[prod] = num;\n\t\t\n\t\tint i = 0;\n\t\twhile(count[i] == e[i]) { count[i++] = 0; }\n\t\tif(i == pn) { break; } else { count[i]++; }\n\t}\n\t\n\tfor(auto && e : div) { gg[e] = g(e); }\n\t\n\tfor(auto && x : div) {\n\tfor(auto && t : div) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <math.h>\n#include <iomanip>      // std::setprecision\n#include <algorithm>\nusing namespace std;\n\nconst long long di = pow(10,9) + 7;\n\nint main(){\n    long long i,n,k,j = 0,mid = 0;\n    cin >> n >> k;\n    int div = ceil(sqrt(n));\n    long long d[n];\n    for (i = 1; i <= div; i ++){\n        if(n % i == 0){\n            d[j] = i;\n            j++;\n            mid++;\n        }\n    }\n    for (i = j - 1; i >= 0; i--){\n        if(n/d[i] > d[mid-1]){\n        d[mid] = n/d[i];\n        mid++;\n        }\n    }\n    long long ans[mid];\n\n    for(i = 0 ; i < mid; i++){\n        ans[i] = (long long)pow(k, ceil((double)d[i]/2.0)) % di;\n        for(j = 0; j < i; j ++){\n            if(d[i] % d[j] == 0){\n                ans[i] = (ans[i] - ans[j]) % di;\n            }\n        }\n    }\n    long long out=0;\n    for(i = 0; i < mid; i++){\n        if (d[i] %2 !=0)\n        out = (out + ans[i] * d[i]) % di;\n        else out = (out + ans[i] * d[i]/2) % di;\n    }\n    cout << out;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define yn YN\nint n,k,ys[23333],yn=0;\nll f[23333];\nconst ll MOD=1e9+7;\nll qp(ll a,ll b)\n{\n\tll x=1;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;++i) if(n%i==0)\n\t{ys[++yn]=i; if(i!=n/i) ys[++yn]=n/i;}\n\tsort(ys+1,ys+1+yn); ll ans=0;\n\tfor(int i=1;i<=yn;++i)\n\t{\n\t\tf[i]=qp(k,(ys[i]+1)/2);\n\t\tfor(int j=1;j<i;++j) if(ys[i]%ys[j]==0)\n\t\t\tf[i]-=f[j];\n\t\tans+=f[i]%MOD*ys[i]/(2-ys[i]%2); ans%=MOD;\n\t}\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXD=2500,MOD=1000000007;\n\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=(1LL*ret*a)%MOD;\n\t\ta=(1LL*a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\nint dp[MAXD];\nvector<int> fac;\n\nint main()\n{\n\tint N,K,ans=0;\n\tscanf(\"%d%d\",&N,&K);\n\tfor(int i=1;1LL*i*i<=N;i++)\n\t\tif(N%i==0)\n\t\t{\n\t\t\tfac.push_back(i);\n\t\t\tif(1LL*i*i!=N)\n\t\t\t\tfac.push_back(N/i);\n\t\t}\n\tsort(fac.begin(),fac.end());\n\tfor(int i=0;i<(int)fac.size();i++)\n\t{\n\t\tint d=fac[i];\n\t\tdp[i]=PowMod(K,(d+1)/2);\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(d%fac[j]==0)\n\t\t\t\tdp[i]=(dp[i]-dp[j]+MOD)%MOD;\n\t\tif(d%2==0)\n\t\t\td/=2;\n\t\tans=(ans+(1LL*dp[i]*d)%MOD)%MOD;\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\ntypedef long long int64;\nconst int mod = 1e9 + 7;\n\ninline int64 modPow(int64 x, int64 n)\n{\n  if(n == 0) return (1);\n  int64 ret = modPow(x, n / 2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return (ret);\n}\n\nint main()\n{\n  int N, K;\n  cin >> N >> K;\n  vector< int > divisor;\n  for(int i = 1; i * i <= N; i++) {\n    if(N % i == 0) {\n      divisor.push_back(i);\n      if(i * i != N) divisor.push_back(N / i);\n    }\n  }\n  sort(begin(divisor), end(divisor));\n  vector< int64 > dp(divisor.size());\n  int64 ret = 0LL;\n  for(int i = 0; i < divisor.size(); i++) {\n    dp[i] = modPow(K, (divisor[i] + 1) / 2);\n    for(int j = 0; j < i; j++) {\n      if(divisor[i] % divisor[j] == 0) (dp[i] += mod - dp[j]) %= mod;\n    }\n    if(divisor[i] % 2 == 0) ret += divisor[i] / 2 * dp[i] % mod;\n    else ret += divisor[i] * dp[i] % mod;\n    ret %= mod;\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <time.h>\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace std::tr1;\nusing namespace std;\n/* cau troi cho Garena nhap de con Bach */\n#define FSYNC ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\n#define endl '\\n'\n#define inf 0x3f3f3f3f\n#define lb lower_bound\n#define pob pop_back\n#define ub upper_bound\n#define ite ::iterator\n#define db(x) {cout <<\"#db \" << x << endl;}\n#define here() {cout <<\"here \\n\";}\n#define mod 1000000007\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\nconst int MOD = 1e9 + 7;\nconst int _MOD = 998244353;\nconst int N = 1e5;\n\nint build[100];\nset<list<int> >s;\nint n,k;\nint times = 0;\nvoid bt(int st){\n\tif(st > (n+1)/2 ){\n\t\tlist<int> li;\n\t\tfor(int i = 1 ; i <= (n+1)/2 ; i ++) build[n+1-i] = build[i];\n\t\tfor(int i = 1 ; i <= n ; i ++) li.push_back(build[i]);\n\t\t//for(int i = 1 ; i <= n ; i ++) cout << build[i] << \" \";\n\t\t//cout << endl;\n\t\tfor(int i = 1 ; i <= n ; i ++){\n\t\t\ts.insert(li);\n\t\t\t//times ++;\n\t\t\tli.push_back(li.front());\n\t\t\tli.pop_front();\n\t\t}\n\t\treturn;\n\t}\n\tfor(int j = 1 ; j <= k ; j ++){\n\t\tbuild[st] = j;\n\t\tbt(st+1);\n\t}\n}\nsigned main(){\n\twhile(cin >> n >> k){\n\t\ts.clear();\n\t\tbt(1);\n\t\tcout << s.size() << endl;\n\t}\n\treturn 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint pow_mod(int x, int k) {\n\tint ans = 1;\n\twhile (k) {\n\t\tif (k&1) ans = 1LL * ans * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nint n, k;\n\nint fac[555], fn, dp[555];\n\nint cal() {\n\tif (n % 2) {\n\t\tint ans = pow_mod(k, (n + 1) / 2);\n\t\tans = (ans - k + MOD) % MOD;\n\t\tans = 1LL * ans * n % MOD;\n\t\tans = (ans + k) % MOD;\n\t\treturn ans;\n\t}\n\tfn = 0;\n\tn /= 2;\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tfac[++fn] = i;\n\t\t\tfac[++fn] = n / i;\n\t\t}\n\t}\n\tsort(fac + 1, fac + fn + 1);\n\tfn = unique(fac + 1, fac + 1 + fn) - fac - 1;\n\tfor (int i = 1; i <= fn; i++) {\n\t\tdp[i] = 1LL * pow_mod(k, fac[i]) % MOD;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (fac[i] % fac[j] == 0) {\n\t\t\t\tdp[i] = (dp[i] - dp[j] + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= fn; i++) ans = (ans + 1LL * dp[i] * fac[i] % MOD) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tprintf(\"%d\\n\", cal());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint n, k, ans, l, a[100010];\nmap<int, int>mp;\ninline int pow(int y, int x){\n\tint s=1, t=y;\n\twhile(x){if(x&1)s=(ll)s*t%mod; t=(ll)t*t%mod; x>>=1;}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%d\", &n, &k);\n\tl=0; mp.clear();\n\tfor(int i=1; i*i<=n; i++)if(n%i==0){\n\t\ta[++l]=i; mp[i]=pow(k, (i+1)/2);\n\t\tif(i*i<n){a[++l]=n/i; mp[n/i]=pow(k, (n/i+1)/2);}\n\t}\n\tsort(a+1, a+1+l);\n\tfor(int i=2; i<=l; i++){\n\t\tfor(int j=1; j*j<=a[i]; j++)if(a[i]%j==0){\n\t\t\tmp[a[i]]=(mp[a[i]]-mp[j]+mod)%mod;\n\t\t\tif(j*j<a[i]&&j>=2)mp[a[i]]=(mp[a[i]]-mp[a[i]/j]+mod)%mod;\n\t\t}\n\t}\n\tans=0;\n\tfor(int i=1; i<=l; i++){\n\t\tif(a[i]&1)ans=(ans+(ll)a[i]*mp[a[i]]%mod)%mod;\n\t\telse ans=(ans+(ll)(a[i]/2)*mp[a[i]]%mod)%mod;\n\t}\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Since g++10 is released, some characters is not valid inside #if 0 :(\n * So, why not using clang++? :D\n\n * Date:\n  echo -n '  ' && date +%Y.%m.%d # Just Run this (Type !!sh in Vim).\n\n * Solution:\n  To be updated after \"Accept\".\n\n * Digression:\n\n * CopyRight:\n          ▁▃▄▄▄▃▃▃▃▄▶\n        ▗▇▀▔    ▔▔▔▔\n       ▄▛   ▃▅━━■▄▂\n      ▟▊   ▐▘     ▀▙\n     ▟▜▌   ▐▖   ▋  ▐▍\n    ▟▘ ▜   ▝▀▇▆●▘  ▐▌\n  ▗▟▘   ▜▃       ▁▅▛\n  ▔▀▼▅▄▃▃██▅▄▄▄▅■▀▔\n        ▔▔▔▔▔▔\n */\n\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\ntypedef std::pair<ll, int> par;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator () (a...); }\n} read;\n\ninline ll mul (ll a, ll b, ll c) {\n\treturn __int128(a) * b % c;\n}\n\nll power (ll x, ll k, ll mod) {\n\tll res = 1;\n\twhile (k) {\n\t\tif (k & 1) res = mul(res, x, mod);\n\t\tx = mul(x, x, mod);\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nbool miller (ll n, int p) {\n\tll x = n - 1, test = power(p, x, n);\n\tif (test != 1) return 0;\n\twhile (!(x & 1) and test == 1) {\n\t\tx >>= 1;\n\t\ttest = power(p, x, n);\n\t\tif (test != 1 and test != n - 1) return 0;\n\t}\n\treturn 1;\n}\n\nbool is_prime (ll n) {\n\tint prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n\tfor (int p : prime) if (n == p) return 1;\n\tfor (int p : prime) if (n % p == 0) return 0;\n\tfor (int p : prime) if (!miller(n, p)) return 0;\n\treturn 1;\n}\n\nll gcd (ll a, ll b) {\n\tif (!b) return a;\n\treturn gcd(b, a % b);\n}\n\nll nxt (ll x, ll c, ll n) {\n\tll res = mul(x, x, n) + c;\n\treturn res >= n ? res - n : res;\n}\n\nll porllard (ll n) {\n\tif (n == 4) return 2;\n\tll c = (rand() * (ll(RAND_MAX) + 1) + rand()) % n;\n\tll a = nxt(rand(), c, n), b = nxt(a, c, n);\n\twhile (a != b) {\n\t\tll g = gcd(n, std::abs(a - b));\n\t\tif (g > 1 and g < n) return g;\n\t\ta = nxt(a, c, n);\n\t\tb = nxt(b, c, n);\n\t\tb = nxt(b, c, n);\n\t}\n\treturn porllard(n);\n}\n\nstd::map<ll, int> get;\nvoid factor (ll n, int coe) {\n\tif (n == 1) return;\n\tif (is_prime(n)) return get[n] += coe, void();\n\tll d = porllard(n);\n\tint k = 0;\n\twhile (n % d == 0) n /= d, ++ k;\n\tfactor(n, coe);\n\tfactor(d, coe * k);\n}\n\npar pr[100];\nll ans;\nvoid dfs (int i, ll d, ll c, ll n, ll K, ll mod) {\n\tif (!i) {\n\t\tif (d & 1 and !(n / d & 1)) return;\n\t\tll g = power(K, (d + 1) >> 1, mod);\n\t\tll h = d & 1 ? d : d >> 1;\n\t\tans += mul(mul(g, h, mod), c, mod);\n\t\treturn;\n\t}\n\tfor (int k = 0; k <= pr[i].second; k ++) {\n\t\tdfs(i - 1, d, k == pr[i].second ? c : c * (1 - pr[i].first), n, K, mod);\n\t\td *= pr[i].first;\n\t}\n}\n\nint main () {\n\tll n = read, K = read, mod = 1000000007;\n\tget.clear();\n\tfactor(n, 1);\n\tint pp = 0;\n\tfor (par p : get)\n\t\tpr[++ pp] = p;\n\tans = 0;\n\tdfs(pp, 1, 1, n, K, mod);\n\tans %= mod;\n\tif (ans < 0) ans += mod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint dp[2010],cnt,n,k,a[2010],ans;\nint fastpow(int x,int y)\n{\n    int sum=1;\n    while(y)\n    {\n        if(y&1)\n        {\n            sum=(1ll*sum*x)%mod;\n        }\n        x=(1ll*x*x)%mod;\n        y>>=1;\n    }\n    return sum;\n}\nsigned main()\n{\n    scanf(\"%lld%lld\",&n,&k);\n    for(int i=1;i*i<=n;i++)//枚举因子\n    {\n        if(n%i==0)\n        {\n            a[++cnt]=i;\n            if(i*i!=n)\n            {\n                a[++cnt]=n/i;\n            }\n        }\n    }\n    sort(a+1,a+cnt+1);\n    for(int i=1;i<=cnt;i++)\n    {\n        dp[i]=fastpow(k,(a[i]+1)/2);//有多少个回文串\n        for(int j=1;j<i;j++)\n        {\n            if(a[i]%a[j]==0)//去重\n            {\n                dp[i]=(dp[i]-dp[j]+mod)%mod;\n            }\n        }\n        if(a[i]&1)//统计答案\n        {\n            ans=(ans+dp[i]*a[i])%mod;\n        }else{\n            ans=(ans+dp[i]*(a[i]/2))%mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#include <vector>\n#include <map>\n#include <utility>\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n\ntemplate<typename T> void swap(T & x, T & y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T & a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T & a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nLL n, k;\nbool c[40000];\nLL p[20], e[20], pn;\nconst LL MOD = 1000000007;\nstd::vector<LL> divisor;\nstd::map<LL, LL> mu, gg;\nLL ans;\n\nLL g(LL x) {\n\tLL ex = (x + 1) / 2;\n\tLL ans = 1, prod = k;\n\twhile(ex) {\n\t\tif(ex & 1) { (ans *= prod) %= MOD; }\n\t\t(prod *= prod) %= MOD;\n\t\tex /= 2;\n\t}\n\t\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tfor(LL i = 2; i * i > 1000000000; i++) {\n\t\tif(c[i]) { continue; }\n\t\tfor(LL j = i * 2; j < 40000; j += i) { c[j] = true; }\n\t}\n\tLL nn = n;\n\tincID(i, 2, 40000) {\n\t\tif(! c[i] && nn % i == 0) {\n\t\t\tp[pn] = i;\n\t\t\twhile(nn % i == 0) {\n\t\t\t\te[pn]++;\n\t\t\t\tnn /= i;\n\t\t\t}\n\t\t\tpn++;\n\t\t}\n\t}\n\tif(nn != 1) {\n\t\tp[pn] = nn;\n\t\te[pn] = 1;\n\t\tpn++;\n\t}\n\t\n\t\n\tLL count[21];\n\tinc(i, pn) { count[i] = 0; }\n\tLL prod = 1;\n\twhile(true) {\n\t\tdivisor.push_back(prod);\n\t\tLL m = 1;\n\t\tinc(i, pn) { if(count[i] > 1) { m = 0; } else if(count[i] == 1) { m *= -1; } }\n\t\t// mu[prod] = m;\n\t\tmu.insert(std::make_pair(prod, m));\n\t\t\n\t\tLL i = 0;\n\t\twhile(count[i] == e[i]) {\n\t\t\tinc(j, e[i]) { prod /= p[i]; }\n\t\t\tcount[i++] = 0;\n\t\t}\n\t\tif(i == pn) { break; }\n\t\tprod *= p[i];\n\t\tcount[i]++;\n\t}\n\t\n\t\n\tfor(auto && e : divisor) {\n\t\t// gg[e] = g(e);\n\t\tgg.insert(std::make_pair(e, g(e)));\n\t}\n\t\n\tfor(auto && x : divisor) {\n\tfor(auto && t : divisor) {\n\t\tif(t % x == 0) {\n\t\t\t(ans += mu[t / x] * (t % 2 == 0 ? t / 2 : t) * gg[x]) %= MOD;\n\t\t}\n\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fm, to)    for (int i = fm; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int hsz = 1e7 + 39, mod = 1e9 + 7;\nint n, k, ans;\n\nstruct hash_table {\n    int sz, hd[hsz + 5], nxt[hsz + 5], key[hsz + 5], val[hsz + 5];\n    \n    void inline ins(int id, int w) {\n        int hid = id % hsz;\n        for (int i = hd[hid]; i; i = nxt[i]) {\n            if (id == key[i])  return;\n        }\n        ++sz;\n        key[sz] = id;\n        val[sz] = w;\n        nxt[sz] = hd[hid];\n        hd[hid] = sz;\n    }\n    \n    int inline qry(int id) {\n        int hid = id % hsz;\n        for (int i = hd[hid]; i; i = nxt[i]) {\n            if (id == key[i])  return val[i];\n        }\n        return -1;\n    }\n};\nhash_table dat;\n\nint inline qpow(int a, int p) {\n    int res = 1;\n    for (; p; p >>= 1) {\n        if (p & 1) {\n            res = (num) res * a % mod;\n        }\n        a = (num) a * a % mod;\n    }\n    return res;\n}\n\nvoid inline upd(int &a, int b) {\n    a += b;\n    if (a >= mod) {\n        a -= mod;\n    }\n    if (a < 0) {\n        a += mod;\n    }\n}\n\nint solve(int a) {\n    int res = dat.qry(a);\n    if (res != -1)  return res;\n    if (a == 1) {\n        res = k % mod;\n        dat.ins(1, res);\n        return res;\n    }\n    res = 0;\n    for (int b = 1; b * b <= a; ++b) {\n        if (a % b)  continue;\n        int bb = a / b;\n        upd(res, -solve(b));\n        if (b != bb && bb != a) {\n            upd(res, -solve(bb));\n        }\n    }\n    upd(res, qpow(k, (a - 1) / 2 + 1));\n    dat.ins(a, res);\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> k;\n    solve(n);\n    cont (i, dat.sz) {\n        int a = dat.key[i], cnt = dat.val[i], cur = (num) a * cnt % mod;\n        upd(ans, (a & 1) ? cur : (num) cur * qpow(2, mod - 2) % mod);\n    }\n    cout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "\n/* -------------------------------- Template -------------------------------- */\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// template<typename T> constexpr T inf = [](){ assert(false); };\n// template<> constexpr int inf<int> = 1e9;\n// template<> constexpr ll inf<ll> = 1e18;\n// template<> constexpr ld inf<ld> = 1e30;\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nvoid solve();\n\nint main() {\n  std::locale loc(std::locale(), new yes_no);\n  std::cout << std::boolalpha << std::setprecision(12) << std::fixed;\n  std::cout.imbue(loc);\n  solve();\n  return 0;\n}\n\nusing namespace std;\n\n/* -------------------------------- Library -------------------------------- */\n\ntemplate<int M, bool IsPrime = false>\nclass Modulo {\n  using ll = long long;\n  int n;\n  static enable_if_t<IsPrime, ll> inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n  }\npublic:\n  Modulo () : n(0) {;}\n  Modulo (int m) : n(m) {\n    if (n >= M) n %= M;\n    else if (n < 0) n = (n % M + M) % M;\n  }\n  Modulo (ll m) {\n    if (m >= M) m %= M;\n    else if (m < 0) m = (m % M + M) % M;\n    n = m;\n  }\n  explicit operator int() const { return n; }\n  explicit operator ll() const { return n; }\n  bool operator==(const Modulo &a) const { return n == a.n; }\n  Modulo operator+=(const Modulo &a) { n += a.n; if (n >= M) n -= M; return *this; }\n  Modulo operator-=(const Modulo &a) { n -= a.n; if (n < 0) n += M; return *this; }\n  Modulo operator*=(const Modulo &a) { n = (ll(n) * a.n) % M; return *this; }\n  Modulo operator+(const Modulo &a) const { Modulo res = *this; return res += a; }\n  Modulo operator-(const Modulo &a) const { Modulo res = *this; return res -= a; }\n  Modulo operator*(const Modulo &a) const { Modulo res = *this; return res *= a; }\n  Modulo operator^(int n) const {\n    if (n == 0) return Modulo(1);\n    const Modulo a = *this;\n    Modulo res = (a * a) ^ (n / 2);\n    return n % 2 ? res * a : res;\n  }\n  enable_if_t<IsPrime, Modulo> operator/(const Modulo &a) const {\n    return *this * inv(ll(a), M);\n  }\n};\n\ntemplate<int M> Modulo<M, true> fact(int n, bool sw = true) {\n  static vector<Modulo<M, true>> v1 = {1}, v2 = {1};\n  if (n >= (int)v1.size()) {\n    const int from = v1.size(), to = n + 1024;\n    v1.reserve(to);\n    v2.reserve(to);\n    for (int i = from; i < to; ++i) {\n      v1.push_back(v1.back() * Modulo<M, true>(i));\n      v2.push_back(v2.back() / Modulo<M, true>(i));\n    }\n  }\n  return sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Modulo<M, true> comb(int a, int b) {\n  if (b < 0 || b > a) return fact<M>(0);\n  return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a-b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Modulo<mod, true>;\n\n/* ---------------------------------- Main ---------------------------------- */\n\nMod dp[32000];\n\nvoid solve() {\n  int N, K;\n  cin >> N >> K;\n  set<int> divs;\n  for (int i = 1; i * i <= N; ++i) {\n    if (N % i == 0) {\n      divs.insert(i);\n      divs.insert(N / i);\n    }\n  }\n  vector<int> div;\n  for (int i: divs) div.push_back(i);\n  const int n = div.size();\n  REP(i,n) {\n    dp[i] = Mod(K) ^ (div[i] + 1) / 2;\n    REP(j,i) {\n      if (div[i] % div[j] == 0) dp[i] -= dp[j];\n    }\n  }\n  Mod res = 0;\n  REP(i,n) res += dp[i] * Mod(div[i] % 2 ? div[i] : div[i] / 2);\n  cout << int(res) << endl;\n  return;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nvoid ADD(LL& x,LL v){\n    x=(x+v)%MOD;\n    if(x<0)x+=MOD;\n}\nLL dp[SIZE];\nint main(){\n    DRII(N,K);\n    VI fac;\n    for(int i=1;i*i<=N;i++){\n        if(N%i==0)fac.PB(i),fac.PB(N/i);\n    }\n    sort(ALL(fac));\n    fac.resize(unique(ALL(fac))-fac.begin());\n    fac.pop_back();\n    LL an=0;\n    if(N%2==0){\n        REP(i,SZ(fac)){\n            LL me;\n            if(N/fac[i]%2==0){\n                me=mypow(K,fac[i]);\n            }\n            else\n                continue;\n            REP(j,i){\n                if(fac[i]%fac[j]==0){\n                    ADD(me,-dp[j]);\n                }\n            }\n            dp[i]=me;\n            ADD(an,me*fac[i]);\n        }\n    }\n    else{\n    }\n    cout<<an<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int mo=1e9+7;\nint i,j,n,k,f[2005],fac[2005],cnt,ans;\nint qs(int x,int y){\n\tint s=1;\n\tfor(;y;y>>=1,x=(ll)x*x%mo) if (y&1) s=(ll)s*x%mo;\n\treturn s;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&k);\n\tfo(i,1,n){\n\t\tif (i*i>n) break;\n\t\tif (n%i==0){\n\t\t\tfac[++cnt]=i,fac[++cnt]=n/i;\n\t\t\tif (fac[cnt]==fac[cnt-1]) cnt--;\n\t\t}\n\t}\n\tsort(fac+1,fac+1+cnt);\n\tfo(i,1,cnt){\n\t\tf[i]=qs(k,(fac[i]+1)>>1);\n\t\tfo(j,1,i-1) if (fac[i]%fac[j]==0) (f[i]-=f[j])%=mo;\n\t}\n\tfo(i,1,cnt) {\n\t\tif (!(fac[i]&1)) fac[i]>>=1;\n\t\t(ans+=(ll)f[i]*fac[i]%mo)%=mo;\n\t}\n\tprintf(\"%d\\n\",(ans+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nstd::vector<int> ytx;\nint n, k;\nint dp[maxn];\ninline void reduce(int & x) {\n\tx += x >> 31 & mod;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> k;\n\tfor(int i = 1;i * i <= n;++i) if(n % i == 0) {\n\t\tytx.push_back(i);\n\t\tif(i * i != n) ytx.push_back(n / i);\n\t}\n\tsort(ytx.begin(), ytx.end());\n\tint lol = 0;\n\trep(i, 0, ytx.size() - 1) {\n\t\tdp[i] = pow(k, ytx[i] + 1 >> 1);\n\t\trep(j, 0, i - 1) if(ytx[i] % ytx[j] == 0) reduce(dp[i] -= dp[j]);\n\t\tlol = (lol + dp[i] * (ytx[i] & 1 ? ytx[i] : ytx[i] + 1ll >> 1)) % mod;\n\t}\n\tcout << lol << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nmap<deque<int>, int> m;\n\nvoid rec(deque<int> v, int pos, long long n, long long k){\n  if(pos == (n+1)/2){\n    for(int i=0; i<n; i++){\n      m[v]++;\n      v.push_back( v.front() );\n      v.pop_front();\n    }\n    return;\n  }\n\n  for(int i=1; i<=k; i++){\n    v[pos] = v[n-1-pos] = i;\n    rec(v, pos+1, n,k);\n  }\n}\n\nint test(long long n, long long k){\n  deque<int> v(n);\n  rec(v, 0, n,k);\n\n  for(auto p : m ){\n    vector<int> v(p.first.begin(), p.first.end());\n    println(join(v, \" \"), \" : \", p.second);\n  }\n  return m.size();\n}\n\nint main(){\n  long long n,k;\n  cin >> n,k;\n\n  long long nn = n;\n\n  long long ans = 0;\n  if(n%2 == 0){\n    int t = 0;\n    while(n%2 == 0){\n      ans = (ans + mod + (t?-1:+1) * my_pow_mod(k, n/2, mod) * n/2) % mod;\n      n/=2;\n      t++;\n    }\n    if(n!=1){\n      ans = (ans + mod + (t?-1:+1) * k*(n-1) % mod) % mod;\n    }\n  }else{\n    ans = my_pow_mod(k, (n+1)/2, mod) * n % mod;\n    ans = (ans - k*(n-1) % mod + mod) % mod;\n  }\n\n  println(ans);\n\n  //println(test(nn,k));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_>\nstruct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nnum powmod(num a, long long b) {\n\tnum r = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tr *= a;\n\t\t}\n\t\ta *= a;\n\t\tb /= 2;\n\t}\n\treturn r;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N, K; cin >> N >> K;\n\tvector<int> divs;\n\tfor (int d = 1; d * d <= N; d++) {\n\t\tif (N % d == 0) {\n\t\t\tdivs.push_back(d);\n\t\t\tif (d * d < N) {\n\t\t\t\tdivs.push_back(N / d);\n\t\t\t}\n\t\t}\n\t}\n\tsort(divs.begin(), divs.end());\n\n\tunordered_map<int, num> dp;\n\tfor (int d : divs) {\n\t\tnum s = powmod(K, (d + 1) / 2);\n\t\tfor (int u : divs) {\n\t\t\tif (d % u == 0) {\n\t\t\t\ts -= dp[u];\n\t\t\t}\n\t\t}\n\t\tdp[d] = s;\n\t}\n\n\tnum ans = 0;\n\tfor (int d : divs) {\n\t\tif (d % 2 == 0) {\n\t\t\tans += dp[d] * (d / 2);\n\t\t} else {\n\t\t\tans += dp[d] * d;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int mod=1e9+7;\nint n,k;\nint main(){\n\tread(n);read(k);\n\tif(n&1){\n\t\tprintf(\"%lld\\n\",1ll*power(k,(n+1)/2,mod)*n%mod);\n\t}else assert(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid findDivisor(int n, vector<int>& divisor)\n{\n    divisor.clear();\n    stack<int> stk;\n    for(int i=1; i*i<=n; ++i){\n        if(n % i == 0){\n            divisor.push_back(i);\n            if(i * i < n)\n                stk.push(n / i);\n        }\n    }\n    while(!stk.empty()){\n        divisor.push_back(stk.top());\n        stk.pop();\n    }\n}\n\nconst int MOD = 1000000007;\n\nlong long power(int a, int b)\n{\n    long long ret = 1;\n    long long tmp = a;\n    while(b > 0){\n        if(b & 1){\n            ret *= tmp;\n            ret %= MOD;\n        }\n        tmp *= tmp;\n        tmp %= MOD;\n        b >>= 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n\n    if(n % 2 == 0){\n        n /= 2;\n        vector<int> div;\n        findDivisor(n, div);\n\n        int m = div.size();\n        vector<long long> v(m, 0);\n        for(int i=0; i<m; ++i){\n            int x = div[i];\n            v[i] = x * power(k, x) % MOD;\n            for(int j=0; j<i; ++j){\n                int y = div[j];\n                if(x % y == 0){\n                    v[i] -= v[j] * (x / y) % MOD;\n                    v[i] += MOD;\n                    v[i] %= MOD;\n                }\n            }\n        }\n\n        long long ans = 0;\n        for(int i=0; i<m; ++i){\n            ans += v[i];\n            ans %= MOD;\n        }\n        cout << ans << endl;\n    }\n    else{\n        vector<int> div;\n        findDivisor(n, div);\n\n        int m = div.size();\n        vector<long long> v(m, 0);\n        for(int i=0; i<m; ++i){\n            int x = div[i];\n            v[i] = x * power(k, (x+1)/2) % MOD;\n            for(int j=0; j<i; ++j){\n                int y = div[j];\n                if(x % y == 0){\n                    v[i] -= v[j] * (x / y) % MOD;\n                    v[i] += MOD;\n                    v[i] %= MOD;\n                }\n            }\n        }\n\n        long long ans = 0;\n        for(int i=0; i<m; ++i){\n            ans += v[i];\n            ans %= MOD;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n  static inline int64 Normalize(int64 x) {\n    if (0 <= x && x < P) return x; x %= P; if (x < 0) x += P; return x;\n  }\n public:\n  FiniteField(int64 x) : x(Normalize(x)) {}\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nFiniteField Power(FiniteField x, int p) {\n  if (p < 0) return FiniteField(1) / Power(x, -p);\n  FiniteField value = 1;\n  while (p) {\n    if (p % 2) value *= x;\n    x *= x;\n    p /= 2;\n  }\n  return value;\n}\n\nostream& operator<<(ostream& s, const FiniteField& v) { s << v.Value(); return s; }\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, k;\n  cin >> n >> k;\n\n  vector<int> ds;\n  for (int i = 1; i * i <= n; i++) {\n    if (n % i == 0) {\n      ds.push_back(i);\n      if (i != n / i) ds.push_back(n / i);\n    }\n  }\n  sort(ds.begin(), ds.end());\n\n  int m = ds.size();\n  vector<FiniteField> cs(m);\n  FiniteField ans = 0;\n  for (int i = 0; i < m; i++) {\n    int d = ds[i];\n    FiniteField c = Power(FiniteField(k), (d + 1) / 2);\n    for (int j = 0; j < i; j++) {\n      if (ds[i] % ds[j] == 0) {\n        c -= cs[j];\n      }\n    }\n    cs[i] = c;\n    \n    if (d % 2 == 0) d /= 2;\n    ans += c * d;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2010,MD=1e9+7;\nint v[N],f[N];\nint Pow(int x,int y)\n{\n    int ans=1;\n    for(;y;x=x*1LL*x%MD,y>>=1)if(y&1)ans=1LL*ans*x%MD;\n    return ans;\n}\nint main()\n{\n    int n,k,tot=0,ans=0,i;\n    cin>>n>>k;\n    for(i=1; i*i<n; i++)\n        if(n%i==0)v[tot++]=i,v[tot++]=n/i;\n    if(i*i==n)v[tot++]=i;\n    sort(v,v+tot);\n    for(int i=0; i<tot; i++)\n    {\n        f[i]=Pow(k,(v[i]+1)/2);\n        for(int j=0; j<i; j++)if(v[i]%v[j]==0) f[i]=(f[i]-f[j])%MD;\n        if(v[i]&1) ans=(ans+1LL*v[i]*f[i])%MD;\n        else ans=(ans+v[i]*1LL*Pow(2,MD-2)%MD*f[i])%MD;\n    }\n    cout<<(ans+MD)%MD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nconst int maxn = 1e5 + 10;\nll n, k, ans;\nvector<ll> d;\nll f[maxn];\nll powMod(ll a, ll k)\n{\n\tll ret = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1) ret = ret * a % mod;\n\t\ta = a * a % mod; k >>= 1;\n\t}\n\treturn ret;\n}\nll inv(ll a) { return powMod(a, mod - 2);}\nint main()\n{\n\tcin >> n >> k;\n\tfor(ll i = 1; i * i <= n; ++i)\n\t\tif(n % i == 0)\n\t\t{\n\t\t\td.push_back(i);\n\t\t\tif(i * i != n)\n\t\t\t\td.push_back(n / i);\n\t\t}\n\tsort(d.begin(), d.end());\n\tfor(int i = 0; i < d.size(); ++i)\n\t{\n\t\tint len = d[i];\n\t\tf[i] = powMod(k, (len + 1) / 2);\n\t\tfor(int j = 0; j < i; ++j)\n\t\t\tif(d[i] % d[j] == 0)\n\t\t\t\tf[i] = (f[i] + mod - f[j]) % mod;\n\t\tll tmp = f[i] * len % mod;\n\t\tif(len % 2 == 0) tmp = tmp * inv(2) % mod;\n\t\tans = (ans + tmp) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1]*i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\n\nll com(ll n, ll k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll modpow(ll x, ll n, ll mod){\n\tll res = 1;\n\twhile(n > 0){\n\t\tif(n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nvl divisor(ll k){\n\tvl c;\n\tfor(ll i=1; i*i<=k; i++){\n\t\tif(k % i == 0){\n\t\t\tc.push_back(i);\n\t\t\tif((k / i) != i){\n\t\t\t\tc.push_back(k/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(c.begin(), c.end());\n\treturn c;\n}\n\nint main(){\n\tint n,k; cin >> n >> k;\n\tcomInit();\n\tvl div = divisor(n);\n\tint m = div.size();\n\tmap<int,mint> mp;\n\tfor(auto i : div){\n\t\tmp[i] = modpow(k,i/2,mod);\n\t\tif(i & 1) mp[i] *= k;\n\t}\n\tmint ans = 0;\n\tfor(auto i : div){\n\t\tauto start = mp.find(i);\n\t\tfor(auto itr = next(start,1); itr != mp.end(); itr++){\n\t\t\tif((*itr).first % i != 0) continue;\n\t\t\t(*itr).second -= mp[i];\n\t\t}\n\t\tif(i & 1 ^ 1) mp[i] *= inv[2];\n\t\tans += mp[i] * i;\n\t}\n\tcout << ans.value() << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long read()\n{\n\tchar ch=getchar();long long x=0,ff=1;\n\twhile(ch<'0'||ch>'9') {if(ch=='-') ff=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*ff;\n}\nvoid write(long long aa)\n{\n\tif(aa<0) putchar('-'),aa=-aa;\n\tif(aa>9) write(aa/10);\n\tputchar('0'+aa%10);\n\treturn;\n}\nconst long long mod=1e9+7;\nlong long n,K,cnt,ans;\nlong long shu[100005],f[100005];\nlong long ksm(long long aa,long long bb)\n{\n\tlong long now=1;\n\twhile(bb)\n\t{\n\t\tif(bb&1) now=now*aa%mod;\n\t\taa=aa*aa%mod;bb>>=1;\n\t}\n\treturn now;\n}\nvoid solve(long long aa)\n{\n\tif(f[aa]) return;\n\tf[aa]=ksm(K,(shu[aa]+1)/2);\n\tfor(long long i=1;i<=cnt;++i)\n\tif(shu[i]<shu[aa]&&shu[aa]%shu[i]==0) \n\t{\n\t\tsolve(i);\n\t\tf[aa]=(f[aa]-f[i]+mod)%mod;\n\t}\n\tif(shu[aa]%2==0) (ans+=(shu[aa]/2)*f[aa]%mod)%=mod;\n\telse (ans+=shu[aa]*f[aa]%mod)%=mod;\n\treturn;\n}\nint main()\n{\n\tn=read(),K=read();\n\tif(n==1) {write(K);return 0;}\n\tfor(long long i=1;i*i<=n;++i) if(n%i==0)\n\t{\n\t\tshu[++cnt]=i;\n\t\tif(i*i!=n) shu[++cnt]=n/i;\n\t}\n\tsolve(2);\n\twrite(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n \nll Pmod(ll n,ll k){\n\tll r=k,ret=1;\n\twhile(true){\n\t\tif(n==0)break;\n\t\tif(n%2==1){\n\t\t\tret=ret*r%mod;\n\t\t}\n\t\tn/=2;\n\t\tr=r*r%mod;\n\t}\n\treturn ret;\n}\n \nvector<pair<ll,ll> > v;\nint main(){\n\tll n,k;\n\tcin>>n>>k;\n\tfor(ll i=1;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\tv.push_back(make_pair(i,-1));\n\t\t\tif(i!=n/i)v.push_back(make_pair(n/i,-1));\n\t\t}\n\t}\n\tsort(v.begin(),v.end());\n\tll ans[2]={0,0};\n\tfor(int i=0;i<v.size();i++){\n\t\tll x=v[i].first;\n\t\tll tmp=Pmod((x+1)/2,k);\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(x%v[j].first==0){\n\t\t\t\ttmp=(mod+tmp-v[j].second)%mod;\n\t\t\t}\n\t\t}\n\t\tv[i].second=tmp;\n\t\tans[x%2]+=tmp*x%(mod*(ll)10);\n\t}\n\t//cout<<ans[0]<<\" \"<<ans[1]<<endl;\n\tcout<<(ans[0]/2+ans[1])%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\n\nconst int MaxNF = 1344;\n\nconst int M = 1000000007;\nconst int I2 = M + 1 >> 1;\n\ninline int modpow(int a, const int &n)\n{\n\tint res = 1;\n\tfor (int i = n; i; i >>= 1)\n\t{\n\t\tif (i & 1)\n\t\t\tres = (s64)res * a % M;\n\t\ta = (s64)a * a % M;\n\t}\n\treturn res;\n}\n\nint n, nK;\n\nint nF = 0, fac[MaxNF];\n\nint f[MaxNF];\n\nint main()\n{\n\tcin >> n >> nK;\n\n\tint l = floor(sqrt(n));\n\tfor (int i = 1; i <= l; ++i)\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tfac[nF++] = i;\n\t\t\tif (i != n / i)\n\t\t\t\tfac[nF++] = n / i;\n\t\t}\n\n\tsort(fac, fac + nF);\n\n\tint res = 0;\n\tfor (int i = 0; i < nF; ++i)\n\t{\n\t\tf[i] = modpow(nK, fac[i] + 1 >> 1);\n\n\t\tfor (int k = 0; k < i; ++k)\n\t\t\tif (fac[i] % fac[k] == 0)\n\t\t\t\tf[i] = (f[i] + M - f[k]) % M;\n\n\t\tint ways = (s64)f[i] * fac[i] % M;\n\t\tif (~fac[i] & 1)\n\t\t\tways = (s64)ways * I2 % M;\n\n\t\tres = (res + ways) % M;\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=1e9+7,N=2e5+20;\nll n,k,dp[2500];\nint qpow(ll x,int k){\n\tll ans=1;\n\twhile(k){\n\t\tif(k&1) ans*=x;\n\t\tk>>=1,x*=x;\n\t\tans%=mod,x%=mod;\n\t}\n\treturn ans;\n}\nint v[3000],cnt;\nvoid init(){\n\tfor(ll i=1;i*i<=n;i++)if(n%i==0){\n\t\tv[++cnt]=i;\n\t\tif(i*i!=n) v[++cnt]=n/i;\n\t}\n\tsort(v+1,v+cnt+1);\n}\nint main()\n{\n\tcin>>n>>k;\n\tinit();\n\tll ans=0;\n\tfor(int x=1;x<=cnt;x++){\n\t\tdp[x]=qpow(k,(v[x]+1)/2);\n\t\tfor(int y=1;y<x;y++){\n\t\t\tif(v[x]%v[y]==0)\n\t\t\t\tdp[x]=(dp[x]-dp[y]+mod)%mod;\t\n\t\t}\t\n\t\tif(v[x]%2)\n\t\t\tans=(ans+(dp[x]*v[x])%mod)%mod;\n\t\telse\n\t\t\tans=(ans+(dp[x]*v[x]/2)%mod)%mod;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <map>\n\nstd::vector<intmax_t> divisor(intmax_t n) {\n  std::vector<intmax_t> res;\n  for (intmax_t i = 1; i*i <= n; ++i) {\n    if (n % i) continue;\n    res.push_back(i);\n    if (n/i != i) res.push_back(n/i);\n  }\n  std::sort(res.begin(), res.end());\n  return res;\n}\n\ntemplate <typename InputIt>\nauto compress(InputIt first, InputIt last) {\n  using value_type = typename InputIt::value_type;\n  std::map<value_type, size_t> res;\n  while (first != last) res[*first++];\n  size_t i = 0;\n  for (auto& p: res) p.second = i++;\n  return res;\n}\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\nconstexpr intmax_t mod = 1e9+7;\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  std::vector<intmax_t> ds = divisor(n);\n  std::map<intmax_t, size_t> map = compress(ds.begin(), ds.end());\n  std::vector<size_t> dp(map.size());\n  intmax_t inv2 = modpow(2_jd, mod-2, mod);\n  intmax_t res = 0;\n  for (auto d: ds) {\n    intmax_t cur = modpow(k, (d+1)/2, mod);\n    for (auto d0: ds) {\n      if (d == d0) break;\n      if (d % d0) continue;\n      cur = (cur + mod - dp[map.at(d0)]) % mod;\n    }\n    dp[map.at(d)] = cur;\n\n    (cur *= d) %= mod;\n    if (d % 2 == 0) (cur *= inv2) %= mod;\n    (res += cur) %= mod;\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint N, K;\nvector<pair<int, int>> moeb;\n\nlong powmod(long b, long e) {\n  if (e == 0) return 1;\n  if (e % 2 == 1) return b * powmod(b, e - 1) % mod;\n  long t = powmod(b, e / 2);\n  return t * t % mod;\n}\n\nvoid pre(int n) {\n  vector<int> ps;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      ps.push_back(i);\n    }\n    while (n % i == 0) {\n      n /= i; \n    }\n  }\n  if (n != 1) {\n    ps.push_back(n);\n  }\n  \n  const int m = ps.size();\n  for (int s = 0; s < (1 << m); ++s) {\n    int prod = 1;\n    int val = 1;\n    for (int k = 0; k < m; ++k) {\n      if (s & (1 << k)) {\n        prod *= ps[k];\n        val *= -1;\n      }\n    }\n    moeb.push_back(make_pair(prod, val));\n  }\n}\n\nset<int> divisors(int n) {\n  set<int> ret;\n  for (int i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      ret.insert(i);\n      ret.insert(n / i);\n    }\n  }\n  return ret;\n}\n\nlong sub(int n) {\n  long sum = 0;\n  for (auto p : moeb) {\n    if (n % p.first != 0) continue;\n    int d = n / p.first;\n    long sgn = mod + p.second;\n    int exp = N % 2 == 0 ? d : (d + 1) / 2;\n    sum += sgn * powmod(K, exp) % mod;\n  }\n  return sum;\n}\n\nint main() {\n  cin >> N >> K;\n  const int n = N % 2 == 0 ? N / 2 : N;\n  pre(n);\n  long sum = 0;\n  for (int d : divisors(n)) {\n    sum = (sum + d * sub(d)) % mod;\n  }\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 1005;\nint fac[MAXN],n,f[MAXN],m;\ninline int ksm(int x,int k)\n{\n  int ret=1;\n  while(k){\n    if(k&1)ret=(long long)ret*x%MOD;\n    x=(long long)x*x%MOD;\n    k>>=1;\n  }\n  return ret;\n}\ninline void sub(int &x,int a)\n{\n  x-=a;\n  if(x<0)x+=MOD;\n}\ninline void add(int &x,int a)\n{\n  x+=a;\n  if(x>=MOD)x-=MOD;\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=n;++i){\n    if(n%i==0){\n      fac[++fac[0]]=i;\n    }\n  }\n  int ans=0;\n  sort(fac+1,fac+fac[0]+1);\n  for(int i=1;i<=fac[0];++i){\n    f[i]=ksm(m,(fac[i]+1)>>1);\n    for(int j=1;j<i;++j)\n      if(fac[i]%fac[j]==0)sub(f[i],f[j]);\n    if(fac[i]&1){\n      add(ans,(long long)f[i]*fac[i]%MOD);      \n    }else{\n      add(ans,(long long)f[i]*fac[i]%MOD*500000004%MOD);\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int P = 1e9+7;\nconst int inv =  5e8+4;\nint Pow(int a,int b){\n\tif(b==0) return 1;\n\tint ret = Pow(a,b>>1);\n\tret=1ll*ret*ret%P;\n\tif(b&1) ret=1ll*ret*a%P;\n\treturn ret;\n}\nint n,K,ans,q[100000];\nmap<int,int> POW,F; \ninline void add(int &x,int y ){x=(x+y)%P;}\n\nint main(){\n\tcin>>n>>K;\n\tint t,l;\n\tfor(int i=1;1ll*i*i<=n;i++) if(n%i==0){\n\t\t//cout<<i<<endl;\n\t\tPOW[i] = Pow(K,(i+1)>>1);\n\t\tt = n/i;\n\t\tPOW[t] = Pow(K,(t+1)>>1);\n\t}\n\t//cout<<POW[n]<<endl;\n\tint cnt = 0;\n\tfor(int i=1;1ll*i*i<=n;i++) if(n%i==0){\n\t\t//cout<<i<<endl;\n\t\tt = i;\n\t\tl = n/t;\n\t\tadd(F[t],POW[t]);\n\t\tfor(int j=2;1ll*j*j<=l;j++) if(l%j==0){\n\t\t\tadd(F[j*t],-F[t]);\n\t\t\tif(j*j!=l) add(F[t*(l/j)],-1ll*F[t]%P);\n\t\t}\n\t\tif(n!=t) add(F[n],-1ll*F[t]%P);\n\t\tif(t&1) add(ans,1ll*F[t]*t%P);\n\t\telse add(ans,1ll*t*F[t]%P*inv%P);\n\t\t\n\t\tif(i*i!=n)q[++cnt] = n/i;\n\t}\n\t//cout<<\"YYY\"<<endl;\n\tfor(int i=cnt;i>0;i--){\n\t\tt = q[i];\n\t\tl = n/t;\n\t\tadd(F[t],POW[t]);\n\t\tfor(int j=2;1ll*j*j<=l;j++) if(l%j==0){\n\t\t\tadd(F[j*t],-F[t]);\n\t\t\tif(j*j!=l) add(F[t*(l/j)],-1ll*F[t]%P);\n\t\t}\n\t\tif(n!=t) add(F[n],-1ll*F[t]%P);\n\t\t//add(ans,1ll*F[t]*t%P);\n\t\t//if(t!=n) add(ans,1ll*F[t]*t%P);\n\t\t//else {\n\t\tif(t&1) add(ans,1ll*F[t]*t%P);\n\t\telse add(ans,1ll*F[t]*t%P*inv%P);\n\t\t//}\n\t}\n\t\n\tans =(ans+P)%P;\n\tcout<<ans<<endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\ntypedef long long int64;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\nstatic const int INV2 = 5e8 + 4;\n\nint n, k;\n\ninline int fpow(int base, int exp)\n{\n    int64 ans = 1;\n    for (; exp; exp >>= 1, base = (int64)base * base _) if (exp & 1) (ans *= base)__;\n    return ans;\n}\n\nstd::map<int, int> calc_mem;\nint calc(int n)\n{\n    if (n == 1) return k;\n    auto itr = calc_mem.find(n);\n    if (itr != calc_mem.end()) return itr->second;\n\n    int ret = fpow(k, (n + 1) / 2);\n    for (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n        (ret -= calc(i))__;\n        if (i != 1 && i * i != n) (ret -= calc(n / i))__;\n    }\n    (ret += MODULUS)__;\n    return (calc_mem[n] = ret);\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n\n    int64 ans;\n    for (int i = 1; i * i <= n; ++i) if (n % i == 0) {\n        (ans += (int64)calc(i) * (i % 2 ? i : (i / 2)))__;\n        if (i * i != n)\n            (ans += (int64)calc(n / i) * ((n / i) % 2 ? (n / i) : (n / i / 2)))__;\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MOD = 1000000007;\nint n, k, len, i, j, a[50005], f[50005], ans;\ninline int ksm(int x, int y, int z)\n{\n\tint b = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) b = 1ll * b * x % z;\n\t\tx = 1ll * x * x % z;\n\t\ty >>= 1;\n\t}\n\treturn b;\n}\nint main()\n{\n\tcin >> n >> k;\n\tfor(i = 1; i * i <= n; i ++)\n\t\tif (n % i == 0)\n\t\t{\n\t\t\ta[++len] = i;\n\t\t\tif (n / i != i) a[++len] = n / i;\n\t\t}\n\tsort(a + 1, a + 1 + len);\n\tint inv2 = (MOD + 1) >> 1;\n\tfor(i = 1; i <= len; i ++)\n\t{\n\t\tf[i] = ksm(k, (a[i] + 1) >> 1, MOD);\n\t\tfor(j = 1; j < i; j ++)\n\t\t\tif (a[i] % a[j] == 0) f[i] = (f[i] + MOD - f[j]) % MOD;\n\t\tif (a[i] & 1) ans = (ans + 1ll * f[i] * a[i]) % MOD;\n\t\telse ans = (ans + 1ll * f[i] * a[i] % MOD * inv2) % MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int mod=1e9+7;\nint n,k,tot,ans;\nmap<int,int>mp;\nint f[100008],dor[100008];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint main()\n{\n    n=read(),k=read();\n    for (int i=1;1ll*i*i<=n;i++)\n\tif (n%i==0)\n\t    {\n\t        dor[++tot]=i;\n\t\tif (n/i!=i) dor[++tot]=n/i;\n\t    }\n    sort(dor+1,dor+tot+1);\n    for (int i=1;i<=tot;i++) mp[dor[i]]=i;\n    for (int i=1;i<=tot;i++)\n\t{\n\t    f[i]=(power(k,(dor[i]+1)/2)-f[1])%mod;\n\t    for (int j=2;1ll*j*j<=dor[i];j++)\n\t\tif (dor[i]%j==0)\n\t\t    {\n\t\t\tf[i]=(f[i]-f[mp[j]])%mod;\n\t\t\tif (dor[i]/j!=j) f[i]=(f[i]-f[mp[dor[i]/j]])%mod;\n\t\t    }\n\t}\n    //for (int i=1;i<=tot;i++) printf(\"%d %d\\n\",dor[i],f[i]);\n    for (int i=1;i<=tot;i++)\n    \tif ((n/dor[i])&1) ans=(ans+f[i])%mod;\n    \telse ans=((ans+f[i])%mod+f[mp[dor[i]*2]])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n    \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int mod=1000000007,I2=mod+1>>1;\nll pw(ll a,int n){ll b=1;for(;n;n>>=1)n%2?b=b*a%mod:1,a=a*a%mod;return b;}\nint p[20],c[20],cnt;\nll dfs(int i,int x,int K){\n\tif(i==cnt)return pw(K,x+1>>1)*x%mod;\n\tll s=0,t;\n\tfor(int k=0,w=1;k<=c[i];k++,w*=p[i]){\n\t\tt=w&1?1:I2;\n\t\tif(k<c[i])(t+=(mod-p[i])*1ll*(w*p[i]&1?1:I2))%=mod;\n\t\t(s+=dfs(i+1,x*w,K)*t)%=mod;\n\t}\n\treturn s;\n}\nint calc(int N,int K){\n\tint x=N;cnt=0;\n\tfor(int i=2;i*i<=x;i++)if(x%i==0){\n\t\tp[cnt]=i,c[cnt]=0;\n\t\twhile(x%i==0)c[cnt]++,x/=i;\n\t\tcnt++;\n\t}\n\tif(x>1)p[cnt]=x,c[cnt++]=1;\n\treturn dfs(0,1,K);\n}\nint main(){\n\tint N,K;\n\tscanf(\"%d%d\",&N,&K);\n\tprintf(\"%d\\n\",calc(N,K)); \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\nlong long modpow(long long a, long long b){ \n  long long r = 1LL;\n\n  while(b){\n    if(b & 1LL)r *= a;\n    if(r >= MOD)r %= MOD;\n    a *= a;\n    if(a >= MOD)a %= MOD;\n    b >>= 1LL;\n  }\n  return r;\n}\n\nvector<ll> f(ll n){\n\tset<ll> se;\n\tfor(int i = 1; i * i <= n; i++){\n\t\tif(n%i==0){\n\t\t\tse.insert(i);\n\t\t\tse.insert(n/i);\n\t\t}\n\t}\n\tvector<ll> ret(all(se));\n\treturn ret;\n}\n\nll dp[5000];\n\nint main() {\n\tll n,k;\n\tcin>>n>>k;\n\tvector<ll> v = f(n);\n\tclr(dp,0);\n\trep(i,0,v.sz){\n\t\tll a = v[i];\n\t\tll c = 0;\n\t\tif(a%2==0){\n\t\t\tc += modpow(k,a/2);\n\t\t\tc %= MOD;\n\t\t}\n\t\telse{\n\t\t\tc += k * modpow(k,(a-1)/2);\n\t\t\tc %= MOD;\n\t\t}\n\t\trep(j,0,i){\n\t\t\tll b = v[j];\n\t\t\tif(a%b==0){\n\t\t\t\tc += MOD;\n\t\t\t\tc -= dp[j];\n\t\t\t\tc %= MOD;\n\t\t\t}\n\t\t}\n\t\tdp[i] = c;\n\t}\n\tll ans = 0;\n\trep(i,0,v.sz){\n\t\tif(v[i]%2==0){\n\t\t\tans += dp[i] * v[i] / 2;\n\t\t\tans %= MOD;\n\t\t} \n\t\telse{\n\t\t\tans += dp[i] * v[i];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nll n, k;\n\nll f(ll n, ll k)\n{\n    return inq(k, n / 2) * (n % 2 ? k : 1) % MOD;\n}\n\nll ans = 0;\nll res[5050];\n\nsigned main()\n{\n    srand(time(NULL));\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    cin >> n >> k;\n    vector<int> divs;\n    for (int i = 1; i * i <= n; i++)\n    {\n        if (n % i == 0)\n        {\n            divs.push_back(i);\n            if (i * i != n) divs.push_back(n / i);\n        }\n    }\n    sort(all(divs));\n    for (int i = 0; i < divs.size(); i++)\n    {\n        res[i] = f(divs[i], k);\n        for (int j = 0; j < i; j++)\n        {\n            if (divs[i] % divs[j] == 0)\n            {\n                res[i] = (res[i] + MOD - res[j]) % MOD;\n            }\n        }\n        if (divs[i] % 2 == 0) ans = (ans + res[i] * divs[i] / 2) % MOD;\n        else ans = (ans + res[i] * divs[i]) % MOD;\n    }\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nint n,k;\nvector<int> fac; \nll ans[N],pali[N];\nint main(){\n  scanf(\"%d%d\",&n,&k);\n  \n  int x=1;\n  while(x*x<=n){\n    if((n)%x==0){\n      fac.pb(x); fac.pb(n/x);\n    }\n    x++;\n  }\n  sort(all(fac)); fac.resize(unique(all(fac))-fac.begin());\n  ll sum=0,z=power(2,mod-2);\n  REP(i,fac.size()){\n\n    pali[i]=power(k,(fac[i]+1)/2);\n    REP(j,i) if(fac[i]%fac[j]==0){\n      int x=fac[i]/fac[j];\n      if(x%2==0) pali[i]-=pali[j];\n      else pali[i]-=pali[j];\n    }\n    pali[i]%=mod;\n   // printf(\"%d %lld %lld\\n\",fac[i],ans[i],pali[i]);\n    if(fac[i]%2==0){\n      sum+=fac[i]*pali[i]%mod*z%mod;\n    }else sum+=fac[i]*pali[i]%mod;\n  }\n  printf(\"%lld\\n\",(sum%mod+mod)%mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint N,K;\n\nsigned main(){\n    cin>>N>>K;\n\n    vint ei;\n    for(int i=1;i*i<=N;i++){\n        if(N%i)continue;\n        ei.pb(i);\n        if(i*i!=N)ei.pb(N/i);\n    }\n\n    sort(all(ei));\n    vint dp(ei.size());\n    int ans=0;\n    for(int i=0;i<ei.size();i++){\n        dp[i]=mpow(K,(ei[i]+1)/2);\n        for(int j=0;j<i;j++)if(ei[i]%ei[j]==0)dp[i]=(dp[i]-dp[j]+mod)%mod;\n        if(ei[i]%2)ans=(ans+dp[i]*ei[i])%mod;\n        else ans=(ans+dp[i]*ei[i]/2)%mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<unordered_map>\nusing namespace std;\n\n#define mod 1000000007\n\nint n, k, ans;\n\nint qpow(int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)res = (long long)res * a % mod;\n\t\ta = (long long)a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tset<int> v;\n\tunordered_map<int, int> s;\n\tfor (int i = 1; i * i <= n; ++i)\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tv.insert(i);\n\t\t\tif (i * i != n)v.insert(n / i);\n\t\t}\n\tfor (auto x : v)\n\t{\n\t\tint res = qpow(k, (x + 1) / 2);\n\t\tfor (int i = 1; i * i <= x; ++i)\n\t\t\tif (x % i == 0)\n\t\t\t{\n\t\t\t\tres -= s[i];\n\t\t\t\tif (res < 0)res += mod;\n\t\t\t\tif (i * i != x)\n\t\t\t\t{\n\t\t\t\t\tres -= s[x / i];\n\t\t\t\t\tif (res < 0)res += mod;\n\t\t\t\t}\n\t\t\t}\n\t\ts[x] = res;\n\t\tans += (long long)res * (x % 2 ? x : x / 2) % mod;\n\t\tif (ans >= mod)ans -= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define MN 50005\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nmap<int,ll> f;\nint n,k,num[10000005],a[MN],sum[MN],tot,tt;ll ans;\nll pow(int x,int y){\n\tll tmp=1;\n\twhile(y){\n\t\tif(y&1)tmp=tmp*x%mod;\n\t\ty>>=1,x=1ll*x*x%mod;\n\t}return tmp;\n}\nvoid add(ll &x,int y){(x+=y)>=mod?x-=mod:0;}\nvoid dec(ll &x,int y){(x-=y)<0?x+=mod:0;}\nvoid dfs(int u,int now){\n\tif(u==tot+1){num[++tt]=now;return ;}\n\tfor(int i=0;i<=sum[u];i++)dfs(u+1,now*pow(a[u],i));\n}\nint main(){\n\tbool pd=0;scanf(\"%d%d\",&n,&k);int tmp=(int)sqrt(n);f[1]=k;\n\tint now=n;\n\tfor(int i=2;i<=tmp;i++)if(now%i==0){\n\t\ta[++tot]=i;\n\t\twhile(now%i==0)now/=i,sum[tot]++;\n\t}if(now!=1)a[++tot]=now,sum[tot]=1;dfs(1,1);\n\tsort(num+1,num+tt+1);\n//\tfor(int i=1;i<=tt;i++)printf(\"%d \",num[i]);puts(\"\");\n\tfor(int i=2;i<=tt;i++){\n\t\tf[num[i]]=pow(k,(num[i]+1)/2);\n\t\tfor(int j=2;j<sqrt(num[i]);j++)if(num[i]%j==0){\n\t\t//\tif(f[j]==0)puts(\"bad!\"),printf(\"%d %d\\n\",num[i],j);\n\t\t//\tif(f[num/j]==0)puts(\"bad!\"),printf(\"%d %d\\n\",num[i],num[i]/j);\n\t\t\tdec(f[num[i]],f[j]),dec(f[num[i]],f[num[i]/j]);\n\t\t}dec(f[num[i]],f[1]);\n\t\tif((int)sqrt(num[i])*(int)sqrt(num[i])==num[i])dec(f[num[i]],f[(int)sqrt(num[i])]);\n\t}//printf(\"%lld %lld %lld %lld\\n\",f[1],f[2],f[3],f[6]);\n\tans=k;for(int i=2;i<=tt;i++)if(num[i]%2==1)add(ans,f[num[i]]*num[i]%mod);else add(ans,f[num[i]]*num[i]/2%mod);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ysf (1000000007)\n\nint a[3005],f[3005],n,k,tot,ans;\n\ninline int qpow(int a,int b){\n  int ans=1;\n  while (b){\n    if (b&1) ans=1LL*ans*a%ysf;\n    if (b>>=1) a=1LL*a*a%ysf;\n  }\n  return ans;\n}\n\nint main(){\n  std::cin>>n>>k;\n  for (int i=1;i*i<=n;++i){\n    if (n%i) continue; a[++tot]=i;\n    if (i*i!=n) a[++tot]=n/i;\n  }\n  std::sort(a+1,a+tot+1);\n  for (int i=1;i<=tot;++i){\n    f[i]=qpow(k,(a[i]+1)>>1);\n    for (int j=1;j<i;++j)\n      if (!(a[i]%a[j])) f[i]-=f[j],f[i]<0?f[i]+=ysf:0;\n    ans=(ans+1LL*f[i]*(a[i]&1?a[i]:a[i]/2))%ysf;\n  }\n  std::cout<<ans; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nll n, k, num[2020], res;\nvector<ll> d;\n\nsigned main() {\n\tcin >> n >> k;\n\tfor (int i=1; i*i<=n; i++) if (n%i==0) {\n\t\td.push_back(i);\n\t\tif (i*i!=n) d.push_back(n/i);\n\t}\n\tsort(all(d));\n\trep(i,d.size()) {\n\t\tnum[i] = mop(k,(d[i]+1)/2);\n\t\trep(j,i) if (d[i]%d[j]==0) (num[i] += mod - num[j]) %= mod;\n\t\t(res += num[i] * d[i] / (d[i]%2 ? 1 : 2)) %= mod;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nconst int mod = 1e9+7;\n\nll dp[100005];\nll pow2(ll a, ll b){\n    ll ans = 1;\n    while(b){\n        if(b%2 == 1) ans = ans*a%mod;\n        a = a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\nint main(){\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n\n    vector<int> f;\n    for(int i=1;i*i<=n;i++){\n        if(n%i == 0){\n            f.eb(i);\n            if(n/i != i) f.eb(n/i);\n        }\n    }   \n    sort(all(f));\n    ll ans = 0;\n    for(int i=0;i<sz(f);i++){\n        dp[i] = pow2(k, (f[i]+1)/2);\n        for(int j=0;j<i;j++){\n            if(f[i]%f[j] == 0){\n                dp[i] = (dp[i] - dp[j] + mod)%mod;\n            }\n        }\n        if(f[i]%2 == 0) ans = (ans + dp[i]*1ll*f[i]/2)%mod;\n        else ans = (ans + dp[i]*1ll*f[i])%mod;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define int long long\n#define mod (int)1000000007\n#define N 64000\nvector<int> vec;\nint tot[N];\nint pow(int base,int up)\n{\n    int ans=1;\n    while(up)\n    {\n        if(up&1) ans*=base,ans%=mod;\n        base*=base;\n        base%=mod;\n        up>>=1;\n    }\n    return ans;\n}\nsigned main()\n{\n    int n,k,len;\n    cin>>n>>k;\n    len=sqrt(n);\n    for(int i=1;i<=len;i++) if(n%i==0)//获取所有可能的循环节长度\n    {\n        vec.push_back(i);\n        if(i!=n/i) vec.push_back(n/i);\n    }\n    sort(vec.begin(), vec.end());\n    int ans=0;\n    for(int i=0;i<vec.size();i++)\n    {\n        tot[i]=pow(k,(vec[i]+1)/2);//循环节长度为vec[i]时循环节的数量。因为是回文串，所以只需要知道前面半截即可确定出整个回文串，下面也是同理\n        for(int j=0;j<i;j++) if(vec[i]%vec[j]==0)\n        tot[i]-=tot[j],tot[i]=(tot[i]+mod)%mod;//去除【长度为vec[i]的循环节】内部含有循环节的情况\n        if(vec[i]&1) ans+=tot[i]*vec[i],ans%=mod;\n        else ans+=tot[i]*(vec[i]/2),ans%=mod;\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst ll MOD = 1e9 + 7;\n\nll pw(ll a, ll b) {\n\tll ans = 1;\n\twhile (b) {\n\t\twhile (!(b & 1))\n\t\t\tb >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD;\n\t\t--b;\n\t}\n\treturn ans;\n}\n\nll n, k;\nll dp[10000];\nvector<ll> vv;\n\nint main() {\n\tcin >> n >> k;\n\tfor (ll i = 1; i * i <= n; ++i) {\n\t\tif (n % i != 0)\n\t\t\tcontinue;\n\t\tvv.push_back(i);\n\t\tif (i * i != n)\n\t\t\tvv.push_back(n / i);\n\t}\n\tsort(vv.begin(), vv.end());\n\tif (n % 2 == 0) {\n\t\tvector<ll> gg;\n\t\tfor (ll i: vv)\n\t\t\tif ((n / i) % 2 == 0)\n\t\t\t\tgg.push_back(i);\n\t\tvv = gg;\n\t\tll ans = 0;\n\t\tfor (int i = 0; i < vv.size(); ++i)\n\t\t\tdp[i] = pw(k, vv[i]);\n\t\tfor (int i = 0; i < vv.size(); ++i) {\n\t\t\tans = (ans + dp[i] * vv[i]) % MOD;\n\t\t\tfor (int j = i + 1; j < vv.size(); ++j)\n\t\t\t\tif (vv[j] % vv[i] == 0)\n\t\t\t\t\tdp[j] = (dp[j] - dp[i] + MOD) % MOD;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\telse {\n\t\tll ans = 0;\n\t\tfor (int i = 0; i < vv.size(); ++i)\n\t\t\tdp[i] = pw(k, (vv[i] + 1) / 2);\n\t\tfor (int i = 0; i < vv.size(); ++i) {\n\t\t\tans = (ans + dp[i] * vv[i]) % MOD;\n\t\t\tfor (int j = i + 1; j < vv.size(); ++j)\n\t\t\t\tif (vv[j] % vv[i] == 0)\n\t\t\t\t\tdp[j] = (dp[j] - dp[i] + MOD) % MOD;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint N, K;\nvector<pair<int, int>> moeb;\n\nlong powmod(long b, long e) {\n  if (e == 0) return 1;\n  if (e % 2 == 1) return b * powmod(b, e - 1) % mod;\n  long t = powmod(b, e / 2);\n  return t * t % mod;\n}\n\nvoid pre(int n) {\n  vector<int> ps;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      ps.push_back(i);\n    }\n    while (n % i == 0) {\n      n /= i; \n    }\n  }\n  if (n != 1) {\n    ps.push_back(n);\n  }\n  \n  const int m = ps.size();\n  for (int s = 0; s < (1 << m); ++s) {\n    int prod = 1;\n    int val = 1;\n    for (int k = 0; k < m; ++k) {\n      if (s & (1 << k)) {\n        prod *= ps[k];\n        val *= -1;\n      }\n    }\n    moeb.push_back(make_pair(prod, val));\n  }\n}\n\nset<int> divisors(int n) {\n  set<int> ret;\n  for (int i = 1; i * i <= n; ++i) {\n    if (n % i == 0) {\n      ret.insert(i);\n      ret.insert(n / i);\n    }\n  }\n  return ret;\n}\n\nlong sub(int n) {\n  long sum = 0;\n  for (auto p : moeb) {\n    if (n % p.first != 0) continue;\n    int d = n / p.first;\n    long sgn = mod + p.second;\n    int exp = N % 2 == 0 ? d : (d + 1) / 2;\n    sum = (sum + sgn * powmod(K, exp)) % mod;\n  }\n  return sum;\n}\n\nint main() {\n  cin >> N >> K;\n  const int n = N % 2 == 0 ? N / 2 : N;\n  pre(n);\n  long sum = 0;\n  for (int d : divisors(n)) {\n    sum = (sum + d * sub(d)) % mod;\n  }\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <stdio.h>\n#include <cstring>\n#include <random>\n#include <chrono>\n#include <bitset>\n#include <fstream>\n#include <sstream>\n \nusing namespace std;\nusing namespace std::chrono;\n \n/*\n#define trav(a, v) for(auto& a : v)\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n*/\n \ntypedef long long ll;\ntypedef long double ld;\n \nll big = 1000000007ll;\nll n,m,k,r;\n \n \nll mob(ll i){\n    if(i == 1)return 1;\n    for(ll c1 = 2; c1*c1 <= i; c1++){\n        \n        if(i % c1 == 0){\n            \n            if(i % (c1*c1) == 0)return 0;\n            return (-1) * mob(i / c1);\n        }\n    }\n return -1;\n}\n \n\nll ans = 0;\n \n ll upp(ll i, ll j){\n \n if(j == 0)return 1;\n \n if(j%2 == 0){\n    ll h = upp(i,j/2);\n    return (h*h)%big;\n    \n }\n return (i*upp(i,j-1))%big;\n }\n \n \nll g(ll i){\n    ll a = mob(n/i) * upp(k, (n+1)/2);\n    a += big;\n    a %= big;\n    if(i % 2 == 0){a *= i/2;}\n    else{\n        a *= i;\n    }\n    a%=big;\n    return a;\n}\n \n \nll f(ll i){\n\n    \n    for()\n\n\n}\n \nint main()\n{\n \n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n    ll c1,c2,c3,c4,c5,c6;\n    ll a,b,c,e;\n    ll x;\n    \n    cin >> n >> k;\n    \n    \n    for(ll c1 = 1; c1*c1 <= n; c1++){\n        \n        if(n%c1 == 0){\n            ans += g(c1);\n            ans += big;\n            ans %= big;\n            \n            if(c1*c1 != n){\n    \n                ans += g(n/c1);\n                ans += big;\n                ans %= big;\n            }\n        }\n    }\n    \n    cout << ans << \"\\n\";\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<int MOD>\nstruct ModInt {\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int getInt() const { return (int)x; }\n    template<class T> T get() const { return (T)x; }\n    inline int mod() const { return MOD; }\n    ModInt(int y=0) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % (unsigned long long)MOD; else x = y; }\n    ModInt &operator+=(const ModInt &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &y) { if ((x += MOD - y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &y) { x = (unsigned long long)x * y.x % (unsigned long long)MOD; return *this; }\n    ModInt &operator/=(const ModInt &y) { x = (unsigned long long)x * y.inv().x % (unsigned long long)MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n};\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nMint operator+(Mint x, const Mint &y) { if ((x.x += y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator-(Mint x, const Mint &y) { if ((x.x += x.mod() - y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator*(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.x % (unsigned long long)x.mod(); return x; }\nMint operator/(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.inv().x % (unsigned long long)x.mod(); return x; }\nbool operator<(const Mint &x, const Mint &y) { return x.x < y.x; }\nbool operator==(const Mint &x, const Mint &y) { return x.x == y.x; }\nbool operator!=(const Mint &x, const Mint &y) { return x.x != y.x; }\n\nint N, K;\nint main() {\n    scanf(\"%d%d\", &N, &K);\n\n    if (N == 1) {\n\tprintf(\"%d\\n\", K);\n\treturn 0;\n    }\n    vector<int> D;\n    for (int i=1; i*i<=N; i++) {\n\tif (N % i == 0) {\n\t    D.push_back(i);\n\t    if (i*i < N) D.push_back(N / i);\n\t}\n    }\n\n    Mint ans = 0;\n    sort(D.begin(), D.end());\n    vector<Mint> A(D.size());\n    for (int i=D.size(); i--;) {\n\tMint g = Mint(K).pow((D[i]+1)/2);\n\tMint t = (D[i] % 2? D[i] - A[i]: D[i] / 2 - A[i]);\n\tans += t * g;\n\tREP (j, i) {\n\t    if (D[i] % D[j] == 0) A[j] += t;\n\t}\n    }\n\n    printf(\"%d\\n\", ans.getInt());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long powing(long long a, long long b) {\n\tlong long ans = 1;\n\twhile (b != 0) {\n\t\tif (b % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long cnt[300000] = {};\nint main() {\n\tlong long n, k;\n\tcin >> n >> k;\n\tvector<long long> inputs;\n\tfor (long long i = 1; i <= sqrt(n); ++i) {\n\t\tif (n % i == 0) {\n\t\t\tinputs.push_back(i);\n\t\t\tif (i * i != n) {\n\t\t\t\tinputs.push_back(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(inputs.begin(), inputs.end());\n\treverse(inputs.begin(), inputs.end());\n\tlong long ans = 0;\n\tfor (int i = 0; i < inputs.size(); ++i) {\n\t\tcnt[i] = powing(k, (inputs[i] + 1) / 2);\n\t\tfor (int q = 0; q < i; ++q) {\n\t\t\tif (inputs[q] % inputs[i] != 0) continue;\n\t\t\tcnt[i] += MAX_MOD - cnt[q];\n\t\t\tcnt[i] %= MAX_MOD;\n\t\t}\n\t\tlong long geko = inputs[i];\n\t\tif (geko % 2 == 0) geko /= 2;\n\t\tans += geko * cnt[i];\n\t\tans %= MAX_MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// clang-format off\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++(i))\n#define reps(i, n) for (int i = 1; i <= (int)(n); ++(i))\n#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; --(i))\n#define rreps(i, n) for (int i = (int)(n); i > 0; --(i))\n\n#define range(i, l, r) for (int i = (int)l; i < (int)(r); ++(i))\n#define rrange(i, l, r) for (int i = ((int)(r) - 1); i >= (int)l; --(i))\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n#define rwhole(f,x,...) ([&](decltype((x)) whole) { return (f)(rbegin(whole), rend(whole), ## __VA_ARGS__); })(x)\n\nusing int32 = int;\nusing int64 = long long;\n\nconstexpr int mod     = 1e9 + 7;\nconstexpr int32 inf   = 1001001001;\nconstexpr int64 infll = 1001001001001001001ll;\nconstexpr int dx[]    = {0, -1, 1, 0, -1, 1, -1, 1},\n              dy[]    = {-1, 0, 0, 1, -1, -1, 1, 1};\nconst string YES = \"YES\", NO = \"NO\", Yes = \"Yes\", No = \"No\", yes = \"yes\", no = \"no\";\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { os << v[0]; for (int i = 1; i < v.size(); ++i) os << \" \" << v[i]; return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << p.fs << \" \" << p.sc; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.fs >> p.sc; return is; }\n\nstruct IoSetup { IoSetup(){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10); cerr << fixed << setprecision(10); } } iosetup;\n\ntemplate<typename T = int64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// clang-format on\n\nvector< int64 > divisor(int64 n) {\n  vector< int64 > ret;\n  for(int64 i = 1; i * i <= n; i++) {\n    if(n % i == 0) {\n      ret.push_back(i);\n      if(i * i != n) ret.push_back(n / i);\n    }\n  }\n  sort(begin(ret), end(ret));\n  return (ret);\n}\n\nint64 power(int64 x, int64 n, int mod) {\n  int64 ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= mod;\n    (x *= x) %= mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nvoid solver() {\n  int64 N = input(), K = input();\n\n  vector<int64> d = divisor(N);\n  vector<int64> cnt(d.size());\n\n  int64 ans = 0;\n  \n  range(i, 0, d.size()) {\n    cnt[i] = power(K, (d[i] + 1) / 2, mod);\n    range(j, 0, i) {\n      if (d[i] / d[j] * d[j] == d[i]) {\n        cnt[i] -= cnt[j];\n        if (cnt[i] < 0) cnt[i] += mod;\n      }\n    }\n\n    if (d[i] & 1) (ans += d[i] * cnt[i] % mod) %= mod;\n    else (ans += d[i] * power(2, mod - 2, mod) % mod * cnt[i] % mod) %= mod;\n  }\n\n  cout << ans << endl;\n}\n\nsigned main(int argc, char *argv[]) {\n    solver();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nlint MOD = 1000000007;\n\ntemplate <typename T>\nT power(T x, T n, T mod) {\n    T ans = 1;\n    while (n>0)\n    {\n        if (n & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return ans;\n}\n\nint N;\nlint K;\n\nint main()\n{\n    cin >> N >> K;\n\n    vector<lint> divs;\n    for (int d=1; d*d<=N; d++)\n    {\n        if (N % d == 0) divs.push_back(d);\n    }\n    for (int i = divs.size()-1; i>=0; i--)\n    {\n        if (divs.back() != N / divs[i]) divs.push_back(N / divs[i]);\n    }\n\n    vector<lint> w(divs.size());\n\n    lint ans = 0;\n    for (int i=0; i<divs.size(); i++)\n    {\n        lint d = divs[i];\n        lint tmp = power(K, (d + 1)/2, MOD);\n        for (int j=0; j<i; j++)\n        {\n            if (divs[i] % divs[j]) continue;\n            tmp = (tmp - w[j] + MOD) % MOD;\n        }\n        w[i] = tmp;\n        ans = (ans + tmp * ((d&1) ? d : d/2 )) % MOD; \n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\" -Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n,k,cnt;\nint ans[6666],factor[6666];\nint main(){\n\tcin>>n>>k;\n\tfor(int i=1;i*i<=n;i++){\n\t\tif(n%i==0)factor[++cnt]=i;\n\t}\n\tfor(int i=sqrt(n)+5;i>=1;i--){\n\t\tif(n%i==0&&(n/i>factor[cnt]))factor[++cnt]=n/i;\n\t}\n\tfor(int i=1;i<=cnt;i++){\n\t\tans[i]=modpow(k,(factor[i]+1)/2);\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(factor[i]%factor[j]==0){\n\t\t\t\tans[i]-=ans[j];\n\t\t\t\tif(ans[i]<0)ans[i]+=mod;\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=1;i<=cnt;i++){\n\t\tif(factor[i]%2==0){\n\t\t\tres=res+1ll*ans[i]*factor[i]%mod;\n\t\t\tres%=mod;\n\t\t}else{\n\t\t\tres=res+2ll*ans[i]*factor[i]%mod;\n\t\t\tres%=mod;\n\t\t}\n\t}\n\tcout<<res*500000004ll%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define mod 1000000007\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define N 500055\n#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint f[N],n,m,k,tot,z[N],ans;\ninline void add(int &x,int k){\n\tx+=k;x+=(x>=mod)?mod:0;x+=(x<0)?mod:0;\n}\nint ksm(int x,int k){\n\tint sum=1;\n\twhile (k){\n\t\tif (k&1) sum=(ll)sum*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\tk>>=1;\n\t}\n\treturn sum;\n}\nsigned main(){\n\tn=read();k=read();\n\tint t=sqrt(n);\n\tF(i,1,t){\n\t\tif (t%i==0){\n\t\t\tz[++tot]=i;\n\t\t\tif (i*i!=n) z[++tot]=n/i;\n\t\t}\n\t}\n\tsort(z+1,z+tot+1);\n\tint inv=(mod+1)/2;\n\tF(i,1,tot){\n\t\tf[i]=ksm(k,(z[i]+1)/2);\n\t\tF(j,1,i-1) if (z[i]%z[j]==0) add(f[i],-f[j]);\n\t\tif (z[i]&1) add(ans,1LL*f[i]*z[i]%mod);\n\t\telse add(ans,1LL*inv*f[i]%mod*z[i]%mod);\n\t}\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=1005;\nconst int mod=1e9+7;\nLL pr[MAXN],plen,n,K;\nLL mul(LL x, LL y, LL mo) {\n    x %= mo; y %= mo;\n    LL z = (long double) x * y / mo; z = x * y - z * mo;\n    if(z < 0) z += mo; else if(z > mo) z -= mo;\n    return z;\n}\nLL pow_mod(LL a,LL b,LL mod)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=mul(a,a,mod))if(b&1)ret=mul(ret,a,mod);\n\treturn ret;\n}\nnamespace Prime\n{\n\tbool Miller_rabin(LL n)\n\t{\n\t\tif(n==2)return 1;\n\t\tif(n<2||!(n%2))return 0;\n\t\tLL S=n-1,t=0;while(!S&1)S>>=1,++t;\n\t\tfor(int i=1;i<=20;i++)\n\t\t{\n\t\t\tLL x=pow_mod(rand()%(n-1)+1,S,n);\n\t\t\tfor(int j=1;j<=t;j++)\n\t\t\t{\n\t\t\t\tLL y=mul(x,x,n);\n\t\t\t\tif(y==1&&x!=1&&x!=n-1)return 0;\n\t\t\t\tx=y;\n\t\t\t}if(x!=1)return 0;\n\t\t}return 1;\n\t}\n\tLL gcd(LL a,LL b){return a==0?b:gcd(b%a,a);}\n\tLL try_split(LL n,LL c)\n\t{\n\t\tLL i=1,k=2,x=rand()%n,y=x;\n\t\twhile(1)\n\t\t{\n\t\t\ti++;x=(mul(x,x,n)+c)%n;\n\t\t\tLL d=gcd(abs(x-y),n);\n\t\t\tif(d!=1&&d!=n)return d;\n\t\t\tif(x==y)return n;\n\t\t\tif(i==k)y=x,k<<=1;\n\t\t}\n\t}\n\tLL p1[MAXN],p2[MAXN],id;\n\tvoid Pollard_rho(LL n)\n\t{\n\t\tif(n==1)return ;\n\t\tif(Miller_rabin(n))pr[++plen]=n;\n\t\telse\n\t\t{\n\t\t\tLL d=try_split(n,rand()%n);\n\t\t\tPollard_rho(d);Pollard_rho(n/d);\n\t\t}\n\t}\n}\nLL prime[MAXN],mxlim[MAXN],len;\nvoid ad(LL &x,LL y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(LL &x,LL y){x-=y;if(x<0)x+=mod;}\nLL ans;\nvoid dfs(int k,LL cho,LL val)\n{\n\tif(k==len+1)\n\t{\n\t\tif((cho&1)&&!(n&1))return ;\n\t\tif(!(cho&1))\n\t\t{\n\t\t\tval%=mod;if(val<0)val+=mod;\n\t\t\tLL sum=mul(mul(pow_mod(K,(cho+1)/2,mod),val,mod),cho/2,mod);\n\t\t\tad(ans,sum);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tval%=mod;if(val<0)val+=mod;\n\t\t\tLL sum=mul(mul(pow_mod(K,(cho+1)/2,mod),val,mod),cho,mod);\n\t\t\tad(ans,sum);\n\t\t}return ;\n\t}LL mu=1;\n\tfor(int i=0;i<=mxlim[k];i++)\n\t\tdfs(k+1,cho*mu,(i==mxlim[k])?val:val*(1-prime[k])),mu*=prime[k];\n}\nint main()\n{\n\tn=read();K=read();K%=mod;plen=0;\n\tPrime::Pollard_rho(n);\n\tsort(pr+1,pr+1+plen);len=0;\n\tfor(int i=1,nxt;i<=plen;i=nxt+1)\n\t{\n\t\tnxt=i;while(nxt+1<=plen&&pr[nxt+1]==pr[i])++nxt;\n\t\tprime[++len]=pr[i];mxlim[len]=nxt-i+1;\n\t}ans=0;\n\tdfs(1,1,1);\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#define ALL(v) begin(v),end(v)\n#else\n#define ALL(v) (v).begin(),(v).end()\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n\n\nLL powmod(LL x, LL y){\n\tLL a = 1;\n\twhile(y){\n\t\tif(y & 1){ a = a * x % MOD; }\n\t\ty >>= 1;\n\t\tx = x * x % MOD;\n\t}\n\treturn a;\n}\n\nLL solve(LL n, LL k){\n\tvector<LL> divs;\n\tif(n & 1){\n\t\tfor(LL i = 1; i * i <= n; i += 2){\n\t\t\tif(n % i == 0){\n\t\t\t\tdivs.push_back(i);\n\t\t\t\tLL t = n / i;\n\t\t\t\tif(i != t && t & 1){ divs.push_back(t); }\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tLL m = n / 2;\n\t\tfor(LL i = 1; i * i <= m; ++i){\n\t\t\tif(m % i == 0){\n\t\t\t\tdivs.push_back(i);\n\t\t\t\tif(i * i != m){ divs.push_back(m / i); }\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(divs));\n\tint sz = divs.size();\n\tvector<LL> cnt(sz);\n\tLL ans = 0;\n\tfor(int i = 0; i < sz; ++i){\n\t\tLL x = cnt[i] % MOD;\n\t\tLL y;\n\t\tif(n & 1){\n\t\t\ty = powmod(k, (divs[i] + 1) / 2);\n\t\t}\n\t\telse{\n\t\t\ty = powmod(k, divs[i]);\n\t\t}\n\t\tx = (x + y + MOD) % MOD;\n\t\tcnt[i] = x;\n\t\tans = (ans + divs[i] * x) % MOD;\n\t\t\n\t\tfor(int j = i + 1; j < sz; ++j){\n\t\t\tif(divs[j] % divs[i] == 0){\n\t\t\t\tcnt[j] -= x;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid mainmain(){\n\tLL n, k;\n\tcin >> n >> k;\n\tLL ans = (solve(n, k) % MOD + MOD) % MOD;\n\tcout << ans << endl;\n}\n\n\n\n}\nint main() try{\n//\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tcerr << fixed << setprecision(4);\n\tmainmain();\n}\ncatch(...){}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define K\t1344\t/* https://oeis.org/A066150 */\n#define MD\t1000000007\n#define V2\t500000004\n\nlong long power(int a, int k) {\n\tlong long b = a, p = 1;\n\n\twhile (k) {\n\t\tif (k & 1)\n\t\t\tp = p * b % MD;\n\t\tb = b * b % MD;\n\t\tk >>= 1;\n\t}\n\treturn p;\n}\n\nint main() {\n\tstatic int mm[K], xx[K];\n\tint n, a, m, l, r, k, i, j, ans;\n\n\tscanf(\"%d%d\", &n, &a);\n\tl = 0, r = K - 1;\n\tfor (m = 1; m <= n / m; m++)\n\t\tif (n % m == 0) {\n\t\t\tmm[l] = m, xx[l] = power(a, (m + 1) / 2), l++;\n\t\t\tif (m != n / m)\n\t\t\t\tmm[r] = n / m, xx[r] = power(a, (n / m + 1) / 2), r--;\n\t\t}\n\twhile (++r < K)\n\t\tmm[l] = mm[r], xx[l] = xx[r], l++;\n\tk = l;\n\tans = 0;\n\tfor (j = 0; j < k; j++) {\n\t\tfor (i = 0; i < j; i++)\n\t\t\tif (mm[j] % mm[i] == 0)\n\t\t\t\txx[j] = (xx[j] - xx[i] + MD) % MD;\n\t\tans = (ans + (long long) xx[j] * (mm[j] % 2 == 0 ? mm[j] / 2 : mm[j])) % MD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null divs[N_MAX], dlen = 0;\null dp[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 1; i * i <= n; i++) {\n\t\tif (n % i) continue;\n\t\tdivs[dlen++] = i;\n\t}\n\twhile (--i) {\n\t\tif (n % i) continue;\n\t\tif (i * i < n) {\n\t\t\tdivs[dlen++] = n / i;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dlen; i++) {\n\t\tdp[i] = bitpow(k, (divs[i] + 1) / 2, MOD);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (divs[i] % divs[j]) continue;\n\t\t\tdp[i] = (MOD + dp[i] - dp[j]) % MOD;\n\t\t}\n\t\t// printf(\"%lld: %llu\\n\", divs[i], dp[i]);\n\t\tresult = (result + dp[i] * (divs[i] / (divs[i] % 2 ? 1 : 2)) % MOD) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRotatedPalindromes solver = new FRotatedPalindromes();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRotatedPalindromes {\n        Debug debug = new Debug();\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Modular mod = new Modular(1e9 + 7);\n            CachedPow cp = new CachedPow(k, mod);\n            int inv2 = (mod.getMod() + 1) / 2;\n            IntegerList factorList = Factorization.factorizeNumber(n);\n            factorList.sort();\n            int[] factors = factorList.toArray();\n            int[] cnt = new int[factors.length];\n            for (int i = 0; i < factors.length; i++) {\n                int d = factors[i];\n                int way = cp.pow(DigitUtils.ceilDiv(d, 2));\n                cnt[i] = way;\n            }\n            for (int i = 0; i < factors.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (factors[i] % factors[j] == 0) {\n                        cnt[i] = mod.subtract(cnt[i], cnt[j]);\n                    }\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i < factors.length; i++) {\n                int c = cnt[i];\n                if (factors[i] % 2 == 0) {\n                    c = mod.mul(c, inv2);\n                }\n                ans = mod.plus(ans, mod.mul(c, factors[i]));\n            }\n\n            debug.debug(\"factors\", factors);\n            debug.debug(\"cnt\", cnt);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline = System.getSecurityManager() == null;\n        private PrintStream out = System.err;\n        int[] empty = new int[0];\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (!x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n\n        public CachedPow(int x, Modular mod) {\n            this(x, mod.getMod(), mod);\n        }\n\n        public CachedPow(int x, int maxExp, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            int k = Math.max(1, (int) DigitUtils.round(Math.sqrt(maxExp)));\n            first = new int[k];\n            second = new int[maxExp / k + 1];\n            first[0] = 1;\n            for (int i = 1; i < k; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[k - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp % first.length], second[exp / first.length]);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerList factorizeNumber(int x) {\n            IntegerList ans = new IntegerList();\n            factorizeNumber(x, ans);\n            return ans;\n        }\n\n        public static void factorizeNumber(int x, IntegerList ans) {\n            for (int i = 1; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                if (i * i != x) {\n                    ans.add(x / i);\n                }\n            }\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static long round(double x) {\n            if (x >= 0) {\n                return (long) (x + 0.5);\n            } else {\n                return (long) (x - 0.5);\n            }\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n\n    void dfs(int cur, int pos, int[] num, int[] cnt, TreeSet<Integer> set) {\n      if (pos == num.length) {\n        set.add(cur);\n        return;\n      }\n      dfs(cur, pos + 1, num, cnt, set);\n      for (int i = 0; i < cnt[pos]; i++) {\n        cur *= num[pos];\n        dfs(cur, pos + 1, num, cnt, set);\n      }\n    }\n\n    ArrayList<Integer> divisors(int N) {\n      TreeMap<Integer, Integer> map = new TreeMap<>();\n      for (long i = 2; i * i <= N; i++) {\n        if (N % i != 0) continue;\n        int count = 0;\n        while (N % i == 0) {\n          N /= i;\n          count++;\n        }\n        map.put((int) i, count);\n      }\n      int[] num = new int[map.size()];\n      int[] cnt = new int[map.size()];\n      int i = 0;\n      for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        num[i] = entry.getKey();\n        cnt[i] = entry.getValue();\n        i++;\n      }\n      TreeSet<Integer> ret = new TreeSet<>();\n      dfs(1, 0, num, cnt, ret);\n      ArrayList<Integer> list = new ArrayList<>();\n      for (int r : ret) list.add(r);\n      return list;\n    }\n\n    public static long modPow(long x, long e, long MOD) {\n      long ret = 1;\n      long cur = x;\n      while (e > 0) {\n        if ((e & 1) != 0) ret = (ret * cur) % MOD;\n        cur = (cur * cur) % MOD;\n        e /= 2;\n      }\n      return ret;\n    }\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int MOD = (int) (1e9 + 7);\n      int N = in.nextInt();\n      long K = in.nextInt();\n      if (N == 1) {\n        out.println(K);\n        return;\n      }\n\n      ArrayList<Integer> divisors = divisors(N);\n      Collections.sort(divisors);\n\n      long[] num = new long[divisors.size()];\n      for (int i = 0; i < num.length; i++) {\n        num[i] = modPow(K, (divisors.get(i) + 1) / 2, MOD);\n        for (int j = 0; j < i; j++) {\n          if (divisors.get(i) % divisors.get(j) == 0) {\n            num[i] -= num[j];\n            if (num[i] <= 0) num[i] += MOD;\n          }\n        }\n      }\n\n      long ans = 0;\n      for (int i = 0; i < num.length; i++) {\n        long d = divisors.get(i);\n        if (d % 2 == 0) d /= 2;\n        ans += num[i] * d;\n        ans %= MOD;\n      }\n      out.println(ans);\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRotatedPalindromes solver = new FRotatedPalindromes();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRotatedPalindromes {\n        Debug debug = new Debug();\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Modular mod = new Modular(1e9 + 7);\n            //CachedPow cp = new CachedPow(k, mod);\n            Power power = new Power(mod);\n            int inv2 = (mod.getMod() + 1) / 2;\n            IntegerList factorList = Factorization.factorizeNumber(n);\n            factorList.sort();\n            int[] factors = factorList.toArray();\n            int[] cnt = new int[factors.length];\n            for (int i = 0; i < factors.length; i++) {\n                int d = factors[i];\n                int way = power.pow(k, DigitUtils.ceilDiv(d, 2));\n                cnt[i] = way;\n            }\n            for (int i = 0; i < factors.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (factors[i] % factors[j] == 0) {\n                        cnt[i] = mod.subtract(cnt[i], cnt[j]);\n                    }\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i < factors.length; i++) {\n                int c = cnt[i];\n                if (factors[i] % 2 == 0) {\n                    c = mod.mul(c, inv2);\n                }\n                ans = mod.plus(ans, mod.mul(c, factors[i]));\n            }\n\n            debug.debug(\"factors\", factors);\n            debug.debug(\"cnt\", cnt);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline = System.getSecurityManager() == null;\n        private PrintStream out = System.err;\n        int[] empty = new int[0];\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (!x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerList factorizeNumber(int x) {\n            IntegerList ans = new IntegerList();\n            factorizeNumber(x, ans);\n            return ans;\n        }\n\n        public static void factorizeNumber(int x, IntegerList ans) {\n            for (int i = 1; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                if (i * i != x) {\n                    ans.add(x / i);\n                }\n            }\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tfinal static long MODULO = 1_000_000_000 + 7;\n\tstatic ArrayList<Integer> divs;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tlong K = sc.nextLong();\n\n\t\tdivs = new ArrayList<>();\n\t\tfor (int i = 1; i * i <= N; ++i) {\n\t\t\tif (N % i == 0) {\n\t\t\t\tdivs.add(i);\n\t\t\t\tif (i * i != N) {\n\t\t\t\t\tdivs.add(N / i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(divs);\n\t\tHashMap<Integer, Long> dp = new HashMap<>();\n\t\tfor (int d : divs) {\n\t\t\tdp.put(d, pow(K, (d + 1) / 2));\n\t\t\tfor (int i = 0; divs.get(i) < d; ++i) {\n\t\t\t\tif (d % divs.get(i) == 0)\n\t\t\t\t\tdp.put(d, (dp.get(d) - dp.get(divs.get(i)) + MODULO) % MODULO);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int d : divs) {\n\t\t\tans = (ans + dp.get(d) * (d % 2 == 0 ? d / 2 : d)) % MODULO;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Div {\n\t\tint div;\n\t\tint num;\n\n\t\tpublic Div(int div, int num) {\n\t\t\tthis.div = div;\n\t\t\tthis.num = num;\n\t\t}\n\t}\n\n\tstatic long pow(long a, long n) {\n\t\tlong ret = 1;\n\t\tfor (; n > 0; n >>= 1, a = (a * a) % MODULO) {\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tret = (ret * a) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRotatedPalindromes solver = new FRotatedPalindromes();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRotatedPalindromes {\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Modular mod = new Modular(1e9 + 7);\n            //CachedPow cp = new CachedPow(k, mod);\n            Power power = new Power(mod);\n            int inv2 = (mod.getMod() + 1) / 2;\n            IntegerList factorList = Factorization.factorizeNumber(n);\n            factorList.sort();\n            int[] factors = factorList.toArray();\n            int[] cnt = new int[factors.length];\n            for (int i = 0; i < factors.length; i++) {\n                int d = factors[i];\n                int way = power.pow(k, DigitUtils.ceilDiv(d, 2));\n                cnt[i] = way;\n            }\n            for (int i = 0; i < factors.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (factors[i] % factors[j] == 0) {\n                        cnt[i] = mod.subtract(cnt[i], cnt[j]);\n                    }\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i < factors.length; i++) {\n                int c = cnt[i];\n                if (factors[i] % 2 == 0) {\n                    c = mod.mul(c, inv2);\n                }\n                ans = mod.plus(ans, mod.mul(c, factors[i]));\n            }\n\n            debug.debug(\"factors\", factors);\n            debug.debug(\"cnt\", cnt);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (!x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(\"[%d]\", i);\n                    }\n                    out.append(\"=\").append(\"\" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerList factorizeNumber(int x) {\n            IntegerList ans = new IntegerList();\n            factorizeNumber(x, ans);\n            return ans;\n        }\n\n        public static void factorizeNumber(int x, IntegerList ans) {\n            for (int i = 1; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                if (i * i != x) {\n                    ans.add(x / i);\n                }\n            }\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc064;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        long n = in.nextInt();\n        long k = in.nextInt();\n\n\n        long[] divisors = new long[2000];\n        int di = 0;\n        for (long i = 1 ; i * i <= n ; i++) {\n            if (n % i == 0) {\n                long j = n / i;\n                divisors[di++] = i;\n                if (i < j) {\n                    divisors[di++] = j;\n                }\n            }\n        }\n        divisors = Arrays.copyOf(divisors, di);\n        Arrays.sort(divisors);\n\n        long[] ptn = new long[di];\n        for (int i = 0 ; i < di ; i++) {\n            long cycle = divisors[i];\n            long A = pow(k, (cycle+1)/2);\n            for (int j = 0 ; j < i ; j++) {\n                if (cycle % divisors[j] == 0) {\n                    A = (A - ptn[j] + MOD) % MOD;\n                }\n            }\n            ptn[i] = A;\n        }\n\n        long total = 0;\n        for (int i = 0; i < di ; i++) {\n            long cycle = divisors[i];\n            total += ptn[i] * (cycle % 2 == 0 ? cycle / 2 : cycle) % MOD;\n        }\n        total %= MOD;\n\n        out.println(total);\n        out.flush();\n    }\n\n    static final int MOD = 1000000007;\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x%2 != 0) {\n                res = (res*a)%MOD;\n            }\n            a = (a*a)%MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD-2)%MOD;\n    }\n\n    static long[] _fact;\n    static long[] _invfact;\n\n    static long comb(long ln, long lr) {\n        int n = (int) ln;\n        int r = (int) lr;\n        if (n < 0 || r < 0 || r > n) {\n            return 0;\n        }\n        if (r > n/2) {\n            r = n-r;\n        }\n        return (((_fact[n]*_invfact[n-r])%MOD)*_invfact[r])%MOD;\n    }\n\n    static void prec(int n) {\n        _fact = new long[n+1];\n        _invfact = new long[n+1];\n        _fact[0] = 1;\n        _invfact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            _fact[i] = _fact[i-1]*i%MOD;\n            _invfact[i] = inv(_fact[i]);\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n  static final long MOD = 1_000_000_007;\n\n  public static void main(String[] args) {\n    long N = sc.nextInt();\n    long K = sc.nextInt();\n    if (N == 1) {\n      System.out.println(K);\n      return;\n    }\n    ArrayList<Long> divisor = new ArrayList<>();\n    for (long i = 2; i * i <= N; i++) {\n      if (N % i != 0) continue;\n      divisor.add(i);\n      if (i * i != N) {\n        divisor.add(N / i);\n      }\n    }\n    divisor.add(N);\n    Collections.sort(divisor);\n    HashMap<Long, Long> map = new HashMap<>();\n    map.put(1L, K);\n    for (long d : divisor) {\n      long add = pow(K, (d + 1) / 2) - K;\n      for (long i = 2; i * i <= d; i++) {\n        if (d % i != 0) continue;\n        add += MOD - map.get(i);\n        if (i * i != d) add += MOD - map.get(d / i);\n      }\n      map.put(d, add % MOD);\n    }\n    long ans = 0;\n    for (long k : map.keySet()) {\n      ans += (k % 2 == 0 ? k / 2 : k) * map.get(k);\n    }\n    System.out.println(ans % MOD);\n  }\n\n  static long pow(long base, long p) {\n    if (p == 0) return 1;\n    if (p == 1) return base;\n    long ret = pow(base, p / 2);\n    ret = ret * ret % MOD;\n    if (p % 2 == 1) {\n      ret = ret * base % MOD;\n    }\n    return ret;\n  }\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\n\t\t\tList<Integer> factor = new ArrayList<Integer>();\n\t\t\tfor (int i = 1; i*i <= n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tfactor.add(i);\n\t\t\t\t\tif (n != i*i) factor.add(n/i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(factor);\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tlong[] dp = new long[factor.size()];\n\t\t\tfor (int i = 0; i < factor.size(); i++) {\n\t\t\t\tlong d = factor.get(i);\n\t\t\t\tdp[i] = powmod(K, (d + 1) / 2, mod);\n\t\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\t\tif (d % factor.get(j) == 0) {\n\t\t\t\t\t\tdp[i] -= dp[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i] %= mod;\n\t\t\t\tans += dp[i] * d / (d % 2 == 0 ? 2 : 1);\n\t\t\t}\n\t\t\t\n\t\t\tio.out.println((ans % mod + mod) % mod);\n\t\t}\n\t}\n\t\n\tstatic long powmod(long n, long r, int m) {\n\t\tlong res = 1;\n\t\tfor(; r != 0; r >>>= 1, n = n * n % m) {\n\t\t\tif((r&1) == 1) {\n\t\t\t\tres = res * n;\n\t\t\t\tif(res >= m) {\n\t\t\t\t\tres %= m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic int mod = 1000000007;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), K = ni();\n\t\tlong[][] vs = new long[2000][];\n\t\tint p = 0;\n\t\tfor(int i = 1;i*i <= n;i++){\n\t\t\tif(n % i == 0){\n\t\t\t\tvs[p++] = new long[]{i, count(n, i, K)};\n\t\t\t\tif(i*i < n){\n\t\t\t\t\tvs[p++] = new long[]{n/i, count(n, n/i, K)};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrays.sort(vs, 0, p, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\treturn Long.compare(a[0], b[0]);\n\t\t\t}\n\t\t});\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\tif(vs[i][0] % vs[j][0] == 0){\n\t\t\t\t\tvs[i][1] -= vs[j][1];\n\t\t\t\t\tif(vs[i][1] < 0)vs[i][1] += mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor(long[] v : vs)if(v != null)ret += v[1]*v[0]%mod;\n\t\tout.println(ret%mod);\n\t}\n\t\n\tstatic long count(int n, int pe, int K)\n\t{\n\t\tif(n/pe % 2 == 0){\n\t\t\treturn pow(K, pe, mod);\n\t\t}else{\n\t\t\treturn pow(K, (pe+1)/2, mod);\n\t\t}\n\t}\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRotatedPalindromes solver = new FRotatedPalindromes();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRotatedPalindromes {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Modular mod = new Modular(1e9 + 7);\n            //CachedPow cp = new CachedPow(k, mod);\n            Power power = new Power(mod);\n            int inv2 = (mod.getMod() + 1) / 2;\n            IntegerList factorList = Factorization.factorizeNumber(n);\n            factorList.sort();\n            int[] factors = factorList.toArray();\n            int[] cnt = new int[factors.length];\n            for (int i = 0; i < factors.length; i++) {\n                int d = factors[i];\n                int way = power.pow(k, DigitUtils.ceilDiv(d, 2));\n                cnt[i] = way;\n            }\n            for (int i = 0; i < factors.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (factors[i] % factors[j] == 0) {\n                        cnt[i] = mod.subtract(cnt[i], cnt[j]);\n                    }\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i < factors.length; i++) {\n                int c = cnt[i];\n                if (factors[i] % 2 == 0) {\n                    c = mod.mul(c, inv2);\n                }\n                ans = mod.plus(ans, mod.mul(c, factors[i]));\n            }\n\n            //debug.debug(\"factors\", factors);\n            //debug.debug(\"cnt\", cnt);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerList factorizeNumber(int x) {\n            IntegerList ans = new IntegerList();\n            factorizeNumber(x, ans);\n            return ans;\n        }\n\n        public static void factorizeNumber(int x, IntegerList ans) {\n            for (int i = 1; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                if (i * i != x) {\n                    ans.add(x / i);\n                }\n            }\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.shuffle(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskD solver = new TaskD();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskD {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Power pow = new NumberTheory.Power(mod);\n\n            IntList factors = new IntList();\n            for (int i = 1; i * i <= n; i++) {\n                if (n % i != 0) {\n                    continue;\n                }\n                factors.add(i);\n                if (n / i != i) {\n                    factors.add(n / i);\n                }\n            }\n\n            factors.sort();\n            IntList cnt = new IntList();\n            cnt.expandWith(0, factors.size());\n\n            int ans = 0;\n            for (int i = 0; i < factors.size(); i++) {\n                int j = factors.get(i);\n                int ways = pow.pow(k, DigitUtils.ceilDiv(j, 2));\n\n                for (int t = 0; t < i; t++) {\n                    if (j % factors.get(t) == 0) {\n                        ways = mod.subtract(ways, cnt.get(t));\n                    }\n                }\n\n                cnt.set(i, ways);\n\n\n                if (j % 2 == 0) {\n                    ways = mod.mul(ways, j / 2);\n                } else {\n                    ways = mod.mul(ways, j);\n                }\n                ans = mod.plus(ways, ans);\n            }\n\n            out.println(ans);\n        }\n\n    }\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        private void ensureSpace(int need) {\n            int req = size + need;\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(1);\n            data[size++] = x;\n        }\n\n        public void expandWith(int x, int len) {\n            ensureSpace(len - size);\n            while (size < len) {\n                add(x);\n            }\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.randomizedArray(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public void set(int i, int x) {\n            checkRange(i);\n            data[i] = x;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class Power {\n            final NumberTheory.Modular modular;\n\n            public Power(NumberTheory.Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n        }\n\n    }\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n    static class DigitUtils {\n        private DigitUtils() {}\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            return a < 0 ? -floorDiv(-a, b) : (a + b - 1) / b;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tprivate static long mod = 1000000000 + 7;\n\n\tpublic static void main(String[] args) {\n\t\t FastScanner sc = new FastScanner();\n\t\t int N = sc.nextInt();\n\t\t int K = sc.nextInt();\n\t\t \n\t\t long[] divs = enumDiv(N);\n\t\t long[] dp = new long[2000];\n\n\t\t long ret = 0;\n\t\t for (int i = 0; i < divs.length; i ++) {\n\t\t\t dp[i] = powMod(K, (divs[i] + 1) / 2, mod);\n\t\t\t \n\t\t\t for (int j = 0; j < i; j ++) {\n\t\t\t\t if (divs[i] % divs[j] == 0) {\n\t\t\t\t\t dp[i] += mod - dp[j];\n\t\t\t\t\t dp[i] %= mod;\n\t\t\t\t }\n\t\t\t }\n\n\t\t\t if (divs[i] % 2 == 0) {\n\t\t\t\t ret += dp[i] * divs[i] / 2;\n\t\t\t } else {\n\t\t\t\t ret += dp[i] * divs[i];\n\t\t\t }\n\t\t\t ret %= mod;\n\t\t }\n\n\t\t System.out.println(ret);\n\t\t\n\t}\n\n\tprivate static long[] enumDiv(long n) {\n\t\tlong[] ret = new long[2000];\n\t\tint ptr = 0;\n\n\t\tfor (long i = 1; i * i <= n; i ++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tret[ptr ++] = i;\n\t\t\t\t\n\t\t\t\tif (i * i != n) {\n\t\t\t\t\tret[ptr ++] = n / i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = Arrays.copyOf(ret, ptr);\n\t\tArrays.sort(ret);\n\t\treturn ret;\n\t\t\n\t}\n\n\tpublic static long powMod(long x, long k, long mod) {\n\t\tint n = 63 - Long.numberOfLeadingZeros(k);\n\t\tlong answer = 1;\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tanswer = (answer * answer) % mod;\n\t\t\tif (((k >> i) & 1L) == 1L) {\n\t\t\t\tanswer = (answer * x) % mod;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\n}\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Collections;\n\npublic class Main {\n\tpublic static long MOD = 1000000007;\n\n\t// calcurate n^k\n\tpublic static long pow(long n, long k) {\n\t\tlong ans = 1;\n\t\tlong tmp = n;\n\t\twhile(true) {\n\t\t\tif(k==0) {\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t\tif(k % 2 == 1) {\n\t\t\t\tans = (ans * tmp) % MOD;\n\t\t\t}\n\t\t\ttmp = (tmp * tmp) % MOD;\n\t\t\tk /= 2;\n\t\t}\n\t}\n\n\tpublic static ArrayList<Integer> divisors(int n) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1; i*i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tlist.add(i);\n\t\t\t\tif(i != n/i) list.add(n/i);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(list);\n\t\treturn list;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint N = r.nextInt();\n\t\tint K = r.nextInt();\n\t\tArrayList<Integer> divisor = divisors(N);\n\t\tlong[] num = new long[divisor.size()];\n\t\tlong tmpSum = 0;\n\t\tfor(int i=0; i<divisor.size(); i++) {\n\t\t\tnum[i] = pow(K, (divisor.get(i)+1)/2);\n\t\t\tfor(int j=0; j<i; j++) {\n\t\t\t\tif(divisor.get(i) % divisor.get(j) == 0) {\n\t\t\t\t\tnum[i] -= num[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(num[i]<0) num[i] += MOD;\n\t\t\ttmpSum += num[i];\n\t\t\ttmpSum %= MOD;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor(int i=0; i<divisor.size(); i++) {\n\t\t\tif(num[i]<0) num[i] += MOD;\n\t\t\tnum[i] = num[i] % MOD;\n\t\t}\n\t\tfor(int i=0; i<divisor.size(); i++) {\n\t\t\tlong d = (long)divisor.get(i);\n\t\t\tif(d%2==0) ans += num[i]*d/2;\n\t\t\telse ans += num[i]*d;\n\t\t\tans = ans % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n\n    void dfs(int cur, int pos, int[] num, int[] cnt, TreeSet<Integer> set) {\n      if (pos == num.length) {\n        set.add(cur);\n        return;\n      }\n      dfs(cur, pos + 1, num, cnt, set);\n      for (int i = 0; i < cnt[pos]; i++) {\n        cur *= num[pos];\n        dfs(cur, pos + 1, num, cnt, set);\n      }\n    }\n\n    ArrayList<Integer> divisors(int N) {\n      TreeMap<Integer, Integer> map = new TreeMap<>();\n      for (long i = 2; i * i <= N; i++) {\n        if (N % i != 0) continue;\n        int count = 0;\n        while (N % i == 0) {\n          N /= i;\n          count++;\n        }\n        map.put((int) i, count);\n      }\n      if (N != 1) map.put(N, 1);\n      int[] num = new int[map.size()];\n      int[] cnt = new int[map.size()];\n      int i = 0;\n      for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        num[i] = entry.getKey();\n        cnt[i] = entry.getValue();\n        i++;\n      }\n      TreeSet<Integer> ret = new TreeSet<>();\n      dfs(1, 0, num, cnt, ret);\n      ArrayList<Integer> list = new ArrayList<>();\n      for (int r : ret) list.add(r);\n      return list;\n    }\n\n    public static long modPow(long x, long e, long MOD) {\n      long ret = 1;\n      long cur = x;\n      while (e > 0) {\n        if ((e & 1) != 0) ret = (ret * cur) % MOD;\n        cur = (cur * cur) % MOD;\n        e /= 2;\n      }\n      return ret;\n    }\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int MOD = (int) (1e9 + 7);\n      int N = in.nextInt();\n      long K = in.nextInt();\n      if (N == 1) {\n        out.println(K);\n        return;\n      }\n\n      ArrayList<Integer> divisors = divisors(N);\n      Collections.sort(divisors);\n\n      long[] num = new long[divisors.size()];\n      for (int i = 0; i < num.length; i++) {\n        num[i] = modPow(K, (divisors.get(i) + 1) / 2, MOD);\n        for (int j = 0; j < i; j++) {\n          if (divisors.get(i) % divisors.get(j) == 0) {\n            num[i] -= num[j];\n            if (num[i] <= 0) num[i] += MOD;\n          }\n        }\n      }\n\n      long ans = 0;\n      for (int i = 0; i < num.length; i++) {\n        long d = divisors.get(i);\n        if (d % 2 == 0) d /= 2;\n        ans += num[i] * d;\n        ans %= MOD;\n      }\n      out.println(ans);\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "//package com.company;\n// Always comment out package when submitting.\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n        int mod = 1_000_000_007;\n        long mult(long a, long b) {\n            return a * b % mod;\n        }\n        long add(long a, long b) {\n            return (a + b + mod) % mod;\n        }\n        long pow(long a, long b) {\n            long ret = 1;\n            while (b != 0) {\n                if (b % 2 == 1) ret = ret * a % mod;\n                a = a * a % mod;\n                b >>= 1;\n            }\n            return ret;\n        }\n        int N, K;\n        Map<Integer, Long> irreducibleCount;\n        public long getOne(int val, int factor) {\n            if (val == factor) return 0;\n            return getOrSolve(factor);\n        }\n        public long getOrSolve(int val) {\n            if (irreducibleCount.containsKey(val)) return irreducibleCount.get(val);\n            long total = pow(K, (val + 1) / 2);\n            for (int factor = 1; factor * factor <= val; factor++) {\n                if (val % factor == 0) {\n                    total = add(total, -getOne(val, factor));\n                    if (val != factor * factor)\n                        total = add(total, -getOne(val, val / factor));\n                }\n            }\n            irreducibleCount.put(val, total);\n            return total;\n        }\n        public long getOne(int factor) {\n            if (factor % 2 == 0) {\n                return mult(getOrSolve(factor), factor / 2);\n            } else {\n                return mult(getOrSolve(factor), factor);\n            }\n        }\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            N = sc.nextInt();\n            K = sc.nextInt();\n            irreducibleCount = new HashMap<>();\n            long total = 0;\n            for (int factor = 1; factor * factor <= N; factor++) {\n                if (N % factor == 0) {\n                    total = add(total, getOne(factor));\n                    if (N != factor * factor) {\n                        total = add(total, getOne(N / factor));\n                    }\n                }\n            }\n            pw.println(total);\n        }\n    }\n\n    // template, actual code is in class Task.\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(\"Test.in\"));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(\"Test.out\"));\n\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n//        System.err.println(\"Memory increased: \" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n//        System.err.println(\"Time used: \" + (TIME_END - TIME_START) + \".\");\n    }\n\n    // Faster IO with BufferedReader wrapped with Scanner\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        List<Integer> divisors = new ArrayList<>();\n        for (int i = 1 ; i * i <= n ; i++) {\n            if (n % i == 0) {\n                if (i * i < n) {\n                    divisors.add(n / i);\n                }\n                divisors.add(i);\n            }\n        }\n        Collections.sort(divisors);\n\n        long ans = 0;\n        long[] ptn = new long[divisors.size()];\n        for (int i = 0; i < divisors.size(); i++) {\n            int cycle = divisors.get(i);\n            long pt = pow(k, (cycle+1)/2);\n            ptn[i] = pt;\n            for (int j = 0; j < i ; j++) {\n                if (cycle % divisors.get(j) == 0) {\n                    ptn[i] += (MOD - ptn[j]) % MOD;\n                    ptn[i] %= MOD;\n                }\n            }\n            long add = ptn[i] * cycle % MOD;\n            if (cycle % 2 == 0) {\n                add *= inv(2);\n                add %= MOD;\n            }\n            ans += add;\n        }\n        out.println(ans % MOD);\n        out.flush();\n    }\n\n    static Set<String> rotate(String p) {\n        int n = p.length();\n        Set<String> lw = new HashSet<>();\n        Set<String> al = new HashSet<>();\n        for (int i = 0; i < n ; i++) {\n            String part = p.substring(i) + p.substring(0, i);\n            if (isPalindrome(part)) {\n                lw.add(part);\n            }\n            al.add(part);\n        }\n        debug(al.size(), al);\n        return lw;\n\n    }\n\n    static boolean isPalindrome(String x) {\n        return x.equals(new StringBuilder().append(x).reverse().toString());\n    }\n\n    static final int MOD = 1000000007;\n\n    static long pow(long a, long x) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            x /= 2;\n        }\n        return res;\n    }\n\n    static long inv(long a) {\n        return pow(a, MOD - 2) % MOD;\n    }\n\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int Mod = (int)1e9 + 7;\n\n    public void Solve()\n    {\n        int N = Reader.Int(), K = Reader.Int();\n        long ans = 0;\n        var div = Divisors(N);\n        var num = new long[div.Length];\n\n        for (int a = 0; a < div.Length; a++)\n        {\n            for (int b = 0; b < a; b++)\n                if (div[a] % div[b] == 0)\n                    num[a] -= num[b];\n            long pow = ModPower(K, (div[a] + 1) / 2, Mod);\n            num[a] = ((num[a] + pow) % Mod + Mod) % Mod;\n            if (div[a] % 2 == 0)\n                ans += num[a] * (div[a] / 2) % Mod;\n            else\n                ans += num[a] * div[a] % Mod;\n        }\n\n        Console.WriteLine(ans % Mod);\n    }\n\n    long ModPower(long x, long n, long mod) // x ^ n\n    {\n        long res = 1;\n        if ((x %= mod) < 0) x += mod;\n        for (; n > 0; n >>= 1, x = x * x % mod)\n            if ((n & 1) == 1) res = res * x % mod;\n        return res;\n    }\n\n    static int[] Divisors(int n)\n    {\n        var divisors = new List<int>();\n        int sqrt = (int)Math.Sqrt(n);\n        for (int i = 1; i <= sqrt; i++)\n            if (n % i == 0)\n            {\n                divisors.Add(i);\n                if (i * i != n) divisors.Add(n / i);\n            }\n        divisors.Sort();\n        return divisors.ToArray();\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    public static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    long N,K;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        Generateprimenumber P = new Generateprimenumber(100000);\n        long count = 0;\n        long[] div = P.Divisor(N);\n        Array.Sort(div);\n        Map m = new Map(div);\n        for(int i=0;i<div.Length;i++){\n            long[] div2 = P.Divisor(div[i]);\n            long c = Pow(K,(div[i]+1)/2);\n            for(int j=0;j<div2.Length;j++){\n                c = (c + Define.mod - m.Get(div2[j]))%Define.mod;\n            }\n            m.Set(div[i],c);\n            if(div[i] % 2 == 0){\n                c = c * (div[i]/2) % Define.mod;\n            }\n            else{\n                c = c * div[i] % Define.mod;\n            }\n            count = (count + c) % Define.mod; \n        }\n        sb.Append(count+\"\\n\");\n    }\n    public long Pow(long n,long k){\n        if(k == 0){\n            return 1;\n        }\n        else if(k % 2 == 0){\n            long t = Pow(n,k/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return n*Pow(n,k-1)%Define.mod;\n        }\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        N = int.Parse(str[0]);\n        K = int.Parse(str[1]);\n    }    \n}\nclass Generateprimenumber{\n    public long[] p;\n    public int length;\n    public Generateprimenumber(int n){\n        bool[] a = new bool[n+1];\n        List<long> pp = new List<long>();\n        int j = 2;\n        for(int i=0;i<n+1;i++){\n            a[i] = true;\n        }\n        while(j<=n){\n            if(a[j]){\n                pp.Add(j);\n                for(int i=j;(long)i*(long)j<=n;i++){\n                    a[i*j] = false;\n                }\n            }\n            j++;\n        }\n        length = pp.Count;\n        p = pp.ToArray();\n    }\n    public long[] Divisor(long n){\n        List<int> pp = new List<int>();\n        long num = n;\n        int count = 1;\n        bool last = false;\n        for(int i=0;p[i]*p[i] <= num;i++){\n            int j=0;\n            while(num % p[i] == 0){\n                num /= p[i];\n                j++;\n            }\n            pp.Add(j);\n            count *= j+1; \n        }\n        if(num != 1){\n            pp.Add(1);\n            count *= 2;\n            last = true;\n        }\n        long[] div = new long[count];\n        for(int i=0;i<count;i++){\n            long x = 1;\n            int y = i;\n            int z = count;\n            for(int j=0;j<pp.Count;j++){\n                z /= pp[j]+1;\n                int k = y/z;\n                y %= z;\n                for(int l=0;l<k;l++){\n                    x *= j == pp.Count - 1 && last ? num : p[j];\n                }\n            }\n            div[i] = x;\n        }\n        return div;\n    }\n}\nclass Map{\n    long[] trees;\n    long[] data;\n    int length;\n    public Map(long[] t){\n        trees = t;\n        length = trees.Length;\n        data = new long[length];\n        Array.Sort(trees,(a,b) => Compare(a,b));\n    }\n    public int Compare(long a,long b){\n        //ソートの仕方\n        if(a > b){\n            return 1;\n        }\n        else if(a < b){\n            return -1;\n        }\n        else{\n            return 0;\n        }\n    }\n    public long Get(long a){\n        int min = 0;\n        int max = length-1;\n        while(min != max){\n            if(Compare(a,trees[(min+max)/2]) <= 0){\n                max = (min+max)/2;\n            }\n            else{\n                min = (min+max)/2+1;\n            }\n        }\n        return data[min];\n    }\n    public void Set(long a,long b){\n        int min = 0;\n        int max = length-1;\n        while(min != max){\n            if(Compare(a,trees[(min+max)/2]) <= 0){\n                max = (min+max)/2;\n            }\n            else{\n                min = (min+max)/2+1;\n            }\n        }\n        data[min] = b;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nusing V = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var k = sc.Integer();\n            ModInteger ans = 0;\n            var div = MathEx.GetDivisors(n);\n            var dp = new ModInteger[div.Count];\n            for (int i = 0; i < div.Count; i++)\n            {\n                if (n % 2 == 0)\n                    dp[i] += ModInteger.Pow(k, div[i]);\n                else dp[i] += ModInteger.Pow(k, div[i] / 2 + 1);\n                for (int j = 0; j < i; j++)\n                    if (div[i] % div[j] == 0) dp[i] -= dp[j];\n                if (n % 2 == 0 && (n / div[i]) % 2 == 0)\n                    ans += dp[i] * div[i];\n                if (n % 2 == 1)\n                    ans += dp[i] * div[i];\n            }\n            Debug.WriteLine(dp.AsJoinedString());\n            //naive(n, k);\n            IO.Printer.Out.WriteLine(ans);\n        }\n        public void naive(int n, int k)\n        {\n            var s = new HashSet<string>();\n            Action<List<int>> dfs = null;\n            dfs = a =>\n              {\n                  if (a.Count == n)\n                  {\n                      var b = a.ToArray().Reverse().ToArray();\n                      var ok = true;\n                      for (int i = 0; i < n; i++)\n                          if (a[i] != b[i]) ok = false;\n                      if (!ok) return;\n                      for (int i = 0; i < n; i++)\n                      {\n                          var otaku = new List<int>();\n                          for (int j = 0; j < n; j++)\n                              otaku.Add(a[(i + j) % n]);\n                          s.Add(otaku.AsJoinedString());\n\n                      }\n                      return;\n                  }\n                  for (int i = 1; i <= k; i++)\n                  {\n                      a.Add(i);\n                      dfs(a);\n                      a.RemoveAt(a.Count - 1);\n                  }\n              };\n            dfs(new List<C>());\n            Debug.WriteLine(s.Count);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger() { num = n }; }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n#region Divisors\npublic static partial class MathEx\n{\n    static public List<Number> GetDivisors(Number v)\n    {\n        var ret = new List<Number>();\n        for (Number i = 1; i * i <= v; i++)\n        {\n            if (v % i != 0) continue;\n            ret.Add(i);\n            if (v / i != i) ret.Add(v / i);\n\n        }\n        ret.Sort();\n        return ret;\n    }\n}\n#endregion\n#region Inverse\npublic partial struct ModInteger\n{\n    static public ModInteger Inverse(ModInteger v)\n    {\n        long p, q;\n        ExGCD(v.num, Mod, out p, out q);\n        return new ModInteger(p % Mod + Mod);\n    }\n    static public long ExGCD(long a, long b, out long x, out long y)\n    {\n        var u = new long[] { a, 1, 0 };\n        var v = new long[] { b, 0, 1 };\n        while (v[0] != 0)\n        {\n            var t = u[0] / v[0];\n            for (int i = 0; i < 3; i++)\n            {\n                var tmp = u[i] - t * v[i];\n                u[i] = v[i];\n                v[i] = tmp;\n            }\n        }\n        x = u[1];\n        y = u[2];\n        if (u[0] > 0)\n            return u[0];\n        for (int i = 0; i < 3; i++)\n            u[i] = -u[i];\n        return u[0];\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tif(N%2==1){\n\t\t\tif(N==1){\n\t\t\t\tConsole.WriteLine(K);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong ret = ModPow(K,(N+1)/2);\n\t\t\tret += (mod - K);\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tret *= N;\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tret += K;\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tConsole.WriteLine(ret);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong tot = ModPow(K,N/2);\n\t\tlong per = ModPow(K,((N/2)+1)/2);\n\t\tlong notp= (tot - per + mod) % mod;\n\t\tnotp *= N/2;\n\t\tnotp %= mod;\n\t\t\n\t\tper += (mod - K);\n\t\tper %= mod;\n\t\t\n\t\tper *= (N/2);\n\t\tper %= mod;\n\t\t\n\t\t//Console.WriteLine(\"{0} {1} {2}\",notp,per,K);\n\t\t\n\t\tlong ans = (notp + per + K) %mod;\n\t\tConsole.WriteLine(ans);\n\t\t\n\t\t\n\t}\n\tlong N,K;\n\tpublic Sol(){\n\t\tvar d = rla();\n\t\tN = d[0];\n\t\tK = d[1];\n\t}\n\tstatic long mod = (long)1e9+7;\n\tstatic long ModPow(long n,long k){\n\t\t\n\t\tif(k==0)return 1;\n\t\tif(n==0)return 0;\n\t\tlong ret=1;\n\t\tlong x=n;\n\t\twhile(k>0){\n\t\t\tif((k&1)==1){ret*=x;ret%=mod;}\n\t\t\t\n\t\t\tx*=x;x%=mod;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn ret;\n\t\t\n\t}\n\n\tpublic static long ModInv(long n){\n\t\t//(mod-2)乗を返す\n\t\t// modが素数の時だけ!!!!\n\t\treturn ModPow(n,mod-2);\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nusing V = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var k = sc.Integer();\n            ModInteger ans = 0;\n            var div = MathEx.GetDivisors(n);\n            var dp = new ModInteger[div.Count];\n            for (int i = 0; i < div.Count; i++)\n            {\n                if (n % 2 == 0)\n                    dp[i] += ModInteger.Pow(k, div[i]);\n                else dp[i] += ModInteger.Pow(k, div[i] / 2 + 1);\n                for (int j = 0; j < i; j++)\n                    if (div[i] % div[j] == 0) dp[i] -= dp[j];\n                if (n % 2 == 0 && (n / div[i]) % 2 == 0)\n                    ans += dp[i] * div[i];\n                if (n % 2 == 1)\n                    ans += dp[i] * div[i];\n            }\n            Debug.WriteLine(dp.AsJoinedString());\n            naive(n, k);\n            IO.Printer.Out.WriteLine(ans);\n        }\n        public void naive(int n, int k)\n        {\n            var s = new HashSet<string>();\n            Action<List<int>> dfs = null;\n            dfs = a =>\n              {\n                  if (a.Count == n)\n                  {\n                      var b = a.ToArray().Reverse().ToArray();\n                      var ok = true;\n                      for (int i = 0; i < n; i++)\n                          if (a[i] != b[i]) ok = false;\n                      if (!ok) return;\n                      for (int i = 0; i < n; i++)\n                      {\n                          var otaku = new List<int>();\n                          for (int j = 0; j < n; j++)\n                              otaku.Add(a[(i + j) % n]);\n                          s.Add(otaku.AsJoinedString());\n\n                      }\n                      return;\n                  }\n                  for (int i = 1; i <= k; i++)\n                  {\n                      a.Add(i);\n                      dfs(a);\n                      a.RemoveAt(a.Count - 1);\n                  }\n              };\n            dfs(new List<C>());\n            Debug.WriteLine(s.Count);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger() { num = n }; }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n#region Divisors\npublic static partial class MathEx\n{\n    static public List<Number> GetDivisors(Number v)\n    {\n        var ret = new List<Number>();\n        for (Number i = 1; i * i <= v; i++)\n        {\n            if (v % i != 0) continue;\n            ret.Add(i);\n            if (v / i != i) ret.Add(v / i);\n\n        }\n        ret.Sort();\n        return ret;\n    }\n}\n#endregion\n#region Inverse\npublic partial struct ModInteger\n{\n    static public ModInteger Inverse(ModInteger v)\n    {\n        long p, q;\n        ExGCD(v.num, Mod, out p, out q);\n        return new ModInteger(p % Mod + Mod);\n    }\n    static public long ExGCD(long a, long b, out long x, out long y)\n    {\n        var u = new long[] { a, 1, 0 };\n        var v = new long[] { b, 0, 1 };\n        while (v[0] != 0)\n        {\n            var t = u[0] / v[0];\n            for (int i = 0; i < 3; i++)\n            {\n                var tmp = u[i] - t * v[i];\n                u[i] = v[i];\n                v[i] = tmp;\n            }\n        }\n        x = u[1];\n        y = u[2];\n        if (u[0] > 0)\n            return u[0];\n        for (int i = 0; i < 3; i++)\n            u[i] = -u[i];\n        return u[0];\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tif(N%2==1){\n\t\t\tif(N==1){\n\t\t\t\tConsole.WriteLine(K);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong ret = ModPow(K,(N+1)/2);\n\t\t\tret += (mod - K);\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tret *= N;\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tret += K;\n\t\t\tret %= mod;\n\t\t\t\n\t\t\tConsole.WriteLine(ret);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong tot = ModPow(K,N/2);\n\t\tlong per = ModPow(K,((N/2)+1)/2);\n\t\tlong notp= (tot - per + mod) % mod;\n\t\tnotp *= N;\n\t\tnotp %= mod;\n\t\t\n\t\tper += (mod - K);\n\t\tper %= mod;\n\t\t\n\t\tper *= (N/2);\n\t\tper %= mod;\n\t\t\n\t\tlong ans = (notp + per + K) %mod;\n\t\tConsole.WriteLine(ans);\n\t\t\n\t\t\n\t}\n\tlong N,K;\n\tpublic Sol(){\n\t\tvar d = rla();\n\t\tN = d[0];\n\t\tK = d[1];\n\t}\n\tstatic long mod = (long)1e9+7;\n\tstatic long ModPow(long n,long k){\n\t\t\n\t\tif(k==0)return 1;\n\t\tif(n==0)return 0;\n\t\tlong ret=1;\n\t\tlong x=n;\n\t\twhile(k>0){\n\t\t\tif((k&1)==1){ret*=x;ret%=mod;}\n\t\t\t\n\t\t\tx*=x;x%=mod;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn ret;\n\t\t\n\t}\n\n\tpublic static long ModInv(long n){\n\t\t//(mod-2)乗を返す\n\t\t// modが素数の時だけ!!!!\n\t\treturn ModPow(n,mod-2);\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int Mod = (int)1e9 + 7;\n\n    public void Solve()\n    {\n        int N = Reader.Int(), K = Reader.Int();\n        long ans = 0;\n        var div = Divisors(N);\n        var num = new long[div.Length];\n\n        for (int a = 0; a < div.Length; a++)\n        {\n            for (int b = 0; b < a; b++)\n                if (div[a] % div[b] == 0)\n                    num[a] -= num[b];\n            long pow = ModPower(K, (div[a] + 1) / 2, Mod);\n            num[a] = (num[a] + pow % Mod + Mod) % Mod;\n            if (div[a] % 2 == 0)\n                ans += num[a] * (div[a] / 2) % Mod;\n            else\n                ans += num[a] * div[a] % Mod;\n        }\n\n        Console.WriteLine(ans % Mod);\n    }\n\n    long ModPower(long x, long n, long mod) // x ^ n\n    {\n        long res = 1;\n        if ((x %= mod) < 0) x += mod;\n        for (; n > 0; n >>= 1, x = x * x % mod)\n            if ((n & 1) == 1) res = res * x % mod;\n        return res;\n    }\n\n    static int[] Divisors(int n)\n    {\n        var divisors = new List<int>();\n        int sqrt = (int)Math.Sqrt(n);\n        for (int i = 1; i <= sqrt; i++)\n            if (n % i == 0)\n            {\n                divisors.Add(i);\n                if (i * i != n) divisors.Add(n / i);\n            }\n        divisors.Sort();\n        return divisors.ToArray();\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    public static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    long N,K;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        Generateprimenumber P = new Generateprimenumber(100000);\n        long count = 0;\n        long[] div = P.Divisor(N);\n        Array.Sort(div);\n        Map m = new Map(div);\n        for(int i=0;i<div.Length;i++){\n            long[] div2 = P.Divisor(div[i]);\n            long c = Pow(K,(div[i]+1)/2);\n            for(int j=0;j<div2.Length;j++){\n                c = (c + Define.mod - m.Get(div2[j]))%Define.mod;\n            }\n            m.Set(div[i],c);\n            if(div[i] % 2 == 0){\n                c = c * (div[i]/2) % Define.mod;\n            }\n            else{\n                c = c * div[i] % Define.mod;\n            }\n            count = (count + c) % Define.mod; \n        }\n        sb.Append(count+\"\\n\");\n    }\n    public long Pow(long n,long k){\n        if(k == 0){\n            return 1;\n        }\n        else if(k % 2 == 0){\n            long t = Pow(n,k/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return n*Pow(n,k-1)%Define.mod;\n        }\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        N = int.Parse(str[0]);\n        K = int.Parse(str[1]);\n    }    \n}\nclass Generateprimenumber{\n    public long[] p;\n    public int length;\n    public Generateprimenumber(int n){\n        bool[] a = new bool[n+1];\n        List<long> pp = new List<long>();\n        int j = 2;\n        for(int i=0;i<n+1;i++){\n            a[i] = true;\n        }\n        while(j<=n){\n            if(a[j]){\n                pp.Add(j);\n                for(int i=j;(long)i*(long)j<=n;i++){\n                    a[i*j] = false;\n                }\n            }\n            j++;\n        }\n        length = pp.Count;\n        p = pp.ToArray();\n    }\n    public long[] Divisor(long n){\n        List<int> pp = new List<int>();\n        long num = n;\n        int count = 1;\n        bool last = false;\n        for(int i=0;p[i]*p[i] <= num;i++){\n            int j=0;\n            while(num % p[i] == 0){\n                num /= p[i];\n                j++;\n            }\n            pp.Add(j);\n            count *= j+1; \n        }\n        if(num != 1){\n            pp.Add(1);\n            count *= 2;\n            last = true;\n        }\n        long[] div = new long[count];\n        for(int i=0;i<count;i++){\n            long x = 1;\n            int y = i;\n            int z = count;\n            for(int j=0;j<pp.Count;j++){\n                z /= pp[j]+1;\n                int k = y/z;\n                y %= z;\n                for(int l=0;l<k;l++){\n                    x *= j == pp.Count - 1 && last ? num : p[j];\n                }\n            }\n            div[i] = x;\n        }\n        return div;\n    }\n}\nclass Map{\n    long[] trees;\n    long[] data;\n    int length;\n    public Map(long[] t){\n        trees = t;\n        length = trees.Length;\n        data = new long[length];\n        Array.Sort(trees,(a,b) => Compare(a,b));\n    }\n    public int Compare(long a,long b){\n        //ソートの仕方\n        if(a > b){\n            return 1;\n        }\n        else if(a < b){\n            return -1;\n        }\n        else{\n            return 0;\n        }\n    }\n    public long Get(long a){\n        int min = 0;\n        int max = length-1;\n        while(min != max){\n            if(Compare(a,trees[(min+max)/2]) <= 0){\n                max = (min+max)/2;\n            }\n            else{\n                min = (min+max)/2+1;\n            }\n        }\n        return data[min];\n    }\n    public void Set(long a,long b){\n        int min = 0;\n        int max = length-1;\n        while(min != max){\n            if(Compare(a,trees[(min+max)/2]) <= 0){\n                max = (min+max)/2;\n            }\n            else{\n                min = (min+max)/2+1;\n            }\n        }\n        data[min] = b;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public long N, K;\n        public long MOD = 1000000007;\n\n        public void Run()\n        {\n            {\n                var line = Input.ReadLongArray();\n                N = line[0];\n                K = line[1];\n                var divisors = Divisors(N);\n                var D = divisors.Count;\n                var C = new long[D];\n                var CC = new long[D];\n\n                for (int i = 0; i < D; i++)\n                {\n                    long d = divisors[i];\n                    C[i] = RotationCount(d);\n                }\n\n                for (int i = 0; i < D; i++)\n                {\n                    CC[i] = C[i];\n                    for (int j = 0; j < i; j++)\n                    {\n                        if (divisors[i] % divisors[j] == 0)\n                        {\n                            CC[i] += (MOD - CC[j]);\n                            CC[i] %= MOD;\n                        }\n                    }\n                }\n\n                long ret = 0;\n                for (int i = 0; i < D; i++)\n                {\n                    long v = divisors[i];\n                    if (v % 2 == 0) v /= 2;\n                    ret += CC[i] * v;\n                    ret %= MOD;\n                }\n\n                Console.WriteLine(ret);\n            }\n        }\n\n        public long RotationCount(long d)\n        {\n            // 周期Dの数列の個数(周期Dを乗じる前）\n            long x = (d + 1) / 2;\n            return Power(K, x, MOD);\n        }\n\n        // repeat square - (X ** n) % _M\n        public static long Power(long x, long n, long M)\n        {\n            long tmp = 1;\n\n            if (n > 0)\n            {\n                tmp = Power(x, n / 2, M);\n                if (n % 2 == 0) tmp = (tmp * tmp) % M;\n                else tmp = (((tmp * tmp) % M) * x) % M;\n            }\n\n            return tmp;\n        }\n\n        public List<long> Divisors(long x)\n        {\n            var dict = new Dictionary<long, int>();\n\n            for (int d = 2; d * d <= x; d++)\n            {\n                while (x % d == 0)\n                {\n                    if(!dict.ContainsKey(d)) dict.Add(d, 0);\n                    dict[d]++;\n                    x /= d;\n                }\n            }\n\n            if(x > 1) dict.Add(x, 1);\n\n            long[] primes = dict.Keys.ToArray();\n            int[] ary = dict.Keys.Select(k => dict[k]).ToArray();\n            // Console.Error.WriteLine(string.Join(\", \", primes));\n            // Console.Error.WriteLine(string.Join(\", \", ary));\n\n            var bf = new BruteForceArray(primes, ary);\n            var divisors = bf.DFSRun();\n            return divisors;\n        }\n\n    }\n\n    // libs ----------\n    // 0/1ビット列を全通り列挙\n    class BruteForceArray\n    {\n        public int[] Counts;\n        public long[] Primes;\n        public int N;\n        public int[] F;\n        public List<long> ret;\n        public BruteForceArray(long[] primes, int[] counts)\n        {\n            this.Primes = primes;\n            this.Counts = counts;\n            N = counts.Length;\n            F = new int[N];\n            ret = new List<long>();\n        }\n\n        public List<long> DFSRun()\n        {\n            DFS(0);\n            ret.Sort();\n            return ret;\n        }\n\n        private void DFS(int i)\n        {\n            if (i == N)\n            {\n                var divisor = CalcDivisor(F);\n                ret.Add(divisor);\n            }\n            else\n            {\n                for (int j = 0; j <= Counts[i]; j++)\n                {\n                    F[i] = j;\n                    DFS(i + 1);\n                }\n            }\n        }\n\n        public long CalcDivisor(int[] counts)\n        {\n            var ret = 1L;\n            for (int i = 0; i < Primes.Length; i++)\n            {\n                for (int j = 0; j < counts[i]; j++)\n                {\n                    ret *= Primes[i];\n                }\n            }\n\n            return ret;\n        }\n    }\n    // common ----------\n\n        internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N, K;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N, out K);\n\t\t}\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tvar d = new List<int>();\n\t\t\tfor (var i = 1; i * i <= N; i++)\n\t\t\t{\n\t\t\t\tif (i * i == N) d.Add(i);\n\t\t\t\telse if (N % i == 0) { d.Add(i); d.Add(N / i); }\n\t\t\t}\n\t\t\td.Sort();\n\t\t\tvar D = d.Count;\n\t\t\tvar a = new long[D];\n\t\t\tfor (var i = 0; i < D; i++)\n\t\t\t{\n\t\t\t\ta[i] = Pow(K, (d[i] + 1L) / 2, Mod);\n\t\t\t\tfor (var j = 0; j < i; j++) if (d[i] % d[j] == 0) a[i] = (a[i] - a[j]) % Mod;\n\t\t\t}\n\t\t\tvar s = 0L;\n\t\t\tfor (var i = 0; i < D; i++) s = (s + (d[i] % 2 == 0 ? d[i] / 2 : d[i]) * a[i] % Mod) % Mod;\n\t\t\tif (s < 0) s += Mod;\n\t\t\tpr.WriteLine(s);\n\t\t}\n\t\tint[] SuffixArray(string S)\n\t\t{\n\t\t\tvar N = S.Length;\n\t\t\tvar sa = new int[N + 1];\n\t\t\tvar r = new int[N + 1];\n\t\t\tfor (var i = 0; i <= N; i++)\n\t\t\t{\n\t\t\t\tsa[i] = i;\n\t\t\t\tr[i] = i < N ? S[i] : -1;\n\t\t\t}\n\t\t\tvar k = 1;\n\t\t\tComparison<int> comp = (i, j) =>\n\t\t\t  {\n\t\t\t\t  if (r[i] != r[j]) return r[i] - r[j];\n\t\t\t\t  var a = i + k <= N ? r[i + k] : -1;\n\t\t\t\t  var b = j + k <= N ? r[j + k] : -1;\n\t\t\t\t  return a - b;\n\t\t\t  };\n\t\t\tfor (; k <= N; k *= 2)\n\t\t\t{\n\t\t\t\tArray.Sort(sa, comp);\n\t\t\t\tvar tmp = new int[N + 1];\n\t\t\t\tfor (var i = 1; i <= N; i++) tmp[sa[i]] = tmp[sa[i - 1]] + (comp(sa[i - 1], sa[i]) < 0 ? 1 : 0);\n\t\t\t\tr = tmp;\n\t\t\t}\n\t\t\treturn sa;\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length <= 1) return; QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (int i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\n\nclass Myon\n{\n    static Scanner cin;\n    public Myon() { }\n    public static int Main()\n    {\n        //Console.SetOut(new Printer(Console.OpenStandardOutput()));\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n\n    long mod = 1000000007;\n\n    public void calc()\n    {\n        long N = cin.nextLong();\n        long K = cin.nextLong();\n        long ans = calc2(N, K);\n        Console.WriteLine(ans);\n    }\n\n    /*\n    List<long> prime;\n    List<long> num;\n    List<long> mul;\n    int isPrime(long a)\n    {\n        long i;\n        int ans = 1;\n        for (i = 2; i * i <= a; i++)\n        {\n            if (a % i == 0)\n            {\n                prime.Add(i);\n                long cnt = 0;\n                while(a%i == 0)\n                {\n                    cnt++;\n                    a /= i;\n                }\n                num.Add(cnt);\n                mul.Add(ans);\n                ans *= (int)cnt + 1;\n            }\n        }\n        if(a != 1)\n        {\n            prime.Add(a);\n            num.Add(1);\n            mul.Add(ans);\n            ans *= 2;\n        }\n        return ans;\n    }\n    */\n    \n    long calc2(long N, long K)\n    {\n        List<long> num = new List<long>();\n        for (int i = 1; i * i <= N; i++)\n        {\n            if (N % i == 0)\n            {\n                num.Add(i);\n                if (i != N / i) num.Add(N / i);\n            }\n        }\n        num.Sort();\n\n        int ID = num.Count;\n        long[] dp = new long[ID];\n        long ans = 0;\n        for (int i = 0; i < ID; i++)\n        {\n            dp[i] = num[i];\n            if (num[i] % 2 == 0) dp[i] /= 2;\n        }\n        \n        for (int i = ID - 1; i >= 0; i--)\n        {\n            ans += calc3(num[i], K) * dp[i];\n            ans %= mod;\n            for (int j = 0; j < i; j++)\n            {\n                if(num[i] % num[j] == 0)\n                {\n                    dp[j] -= dp[i];\n                    dp[j] %= mod;\n                }\n            }\n        }\n\n        ans %= mod;\n        if (ans < 0) ans += mod;\n        return ans;\n    }\n\n    long calc3(long N, long K)\n    {\n        N = (N + 1) / 2;\n        return powmod(K, N);\n    }\n    \n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n}\n\nclass Printer : StreamWriter\n{\n    public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n    public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    public Printer(Stream stream, Encoding encoding) : base(stream, encoding) { }\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        while (i >= s.Length)\n        {\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n        }\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!long);\n    auto N = s[0];\n    auto K = s[1];\n\n    long[] F;\n    for (long i = 1; i * i <= N; ++i) {\n        if (N % i == 0) {\n            F ~= N / i;\n            F ~= i;\n        }\n    }\n    F = F.sort().uniq().array;\n\n    auto cnt = new long[](F.length);\n\n    foreach (i; 0..F.length.to!int) {\n        cnt[i] = powmod(K, (F[i]+1)/2, MOD);\n        foreach (j; 0..i) {\n            if (F[i] % F[j] == 0) {\n                cnt[i] -= cnt[j];\n                cnt[i] = (cnt[i] % MOD + MOD) % MOD;\n            }\n        }\n    }\n\n    long ans = 0;\n    foreach (i; 0..F.length.to!int) {\n        if (F[i] % 2 == 0) {\n            ans = (ans + cnt[i] * F[i] / 2 % MOD) % MOD;\n        } else {\n            ans = (ans + cnt[i] * F[i] % MOD) % MOD;\n        }\n    }\n    ans.writeln;\n}\n\nlong powmod(long a, long x, long m) {\n    long ret = 1;\n    while (x) {\n        if (x % 2) ret = ret * a % m;\n        a = a * a % m;\n        x /= 2;\n    }\n    return ret;\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"X\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.conv, std.range, std.algorithm;\n// import dcomp.foundation;\n// import dcomp.scanner, dcomp.modint, dcomp.numeric.primitive;\n// import dcomp.numeric.prime;\nalias Mint = ModInt!(10^^9 + 7);\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, k;\n    sc.read(n, k);\n    auto divs = n.divisorList;\n    int x = divs.length.to!int;\n    Mint[] co0 = new Mint[x];\n    Mint sm = 0;\n    foreach (i, d; divs) {\n        Mint base = pow(Mint(k), (d+1)/2);\n        foreach (j, e; divs) {\n            if (d <= e) break;\n            if (d % e) continue;\n            base -= co0[j];\n        }\n        co0[i] = base;\n        base *= Mint(d);\n        if (d % 2 == 0) base /= Mint(2);\n        sm += base;\n    }\n//    writeln(co0);\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n    auto opBinary(string op:\"*\")(ModInt r) const {return make( (long(v)*r.v%MD).to!uint );}\n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    static assert( is(ModInt!(uint(1000000000) * 2))); //not overflow\n    static assert(!is(ModInt!(uint(1145141919) * 2))); //overflow!\n    alias Mint = ModInt!(10^^9+7);\n    // negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n\n    Mint a = 48;\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    auto normS(uint x) {return (x<MD)?x:x-MD;}\n    auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n    auto opBinary(string op:\"+\")(DModInt r) {\n        return make(normS(v+r.v));\n    }\n    auto opBinary(string op:\"-\")(DModInt r) {\n        return make(normS(v+MD-r.v));\n    }\n    auto opBinary(string op:\"*\")(DModInt r) {\n        return make((long(v)*r.v%MD).to!uint);\n    }\n    auto opBinary(string op:\"/\")(DModInt r) {\n        return this*inv(r);\n    }\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\nunittest {\n    alias Mint = DModInt!(\"default\");\n    Mint.MD = 10^^9 + 7;\n    //negative check\n    assert(Mint(-1).v == 10^^9 + 6);\n    assert(Mint(-1L).v == 10^^9 + 6);\n    Mint a = Mint(48);\n    Mint b = Mint.inv(a);\n    assert(b.v == 520833337);\n    Mint c = Mint(15);\n    Mint d = Mint(3);\n    assert((c/d).v == 5);\n}\n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n// optimize\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\nunittest {\n    import std.stdio;\n    alias Mint = ModInt!(10^^9 + 7);\n    auto r = factTable!Mint(20);\n    Mint a = 1;\n    assert(r[0] == Mint(1));\n    foreach (i; 1..20) {\n        a *= Mint(i);\n        assert(r[i] == a);\n    }\n    auto p = invFactTable!Mint(20);\n    foreach (i; 1..20) {\n        assert((r[i]*p[i]).v == 1);\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/prime.d */\n// module dcomp.numeric.prime;\n\nT[] divisorList(T)(T x) {\n    import std.algorithm : sort;\n    T[] res;\n    for (T i = 1; i*i <= x; i++) {\n        if (x%i == 0) {\n            res ~= i;\n            if (i*i != x) res ~= x/i;\n        }\n    }\n    sort(res);\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(divisorList(1), [1]));\n    assert(equal(divisorList(2), [1, 2]));\n    assert(equal(divisorList(4), [1, 2, 4]));\n    assert(equal(divisorList(24), [1, 2, 3, 4, 6, 8, 12, 24]));\n}\n\nT[] factorList(T)(T x) {\n    T[] res;\n    for (T i = 2; i*i <= x; i++) {\n        while (x % i == 0) {\n            res ~= i;\n            x /= i;\n        }\n    }\n    if (x > 1) res ~= x;\n    // res is sorted!\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(factorList(1), new int[0]));\n    assert(equal(factorList(2), [2]));\n    assert(equal(factorList(4), [2, 2]));\n    assert(equal(factorList(24), [2, 2, 2, 3]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T) {\n    return pow(x, n, T(1));\n}\nT pow(T, U)(T x, U n, T e) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsigned縺ｯNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>  \nusing namespace std;\n\n#define ll long long\n#define P 1e9+7 \n\nll n,k,dp[33335];\n\nvector<ll> fac;\n\nll fpow(ll a,ll b){\n\tll c=1;\n\tfor(;b;b>>=1,a=a*a%P)\n\t\tif(b&1) c=c*a%P;\n\treturn c;\n}\n\nvoid work()\n{\n\tll ans=0;\n\tfor(int x=0;x<fac.size();x++){\n\t\tdp[x]=fpow(k,(fac[x]+1)/2);\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif(fac[x]%fac[y]==0)\n\t\t\t\tdp[x]=(dp[x]-dp[y]+P)%P;\n\t\t}\n\t\tif(fac[x]%2) ans=(ans+dp[x]*fac[x]%P)%P\n        else ans=(ans+dp[x]*fac[x]/2%P)%P;\n\t}\n    cout<<ans<<endl;  \n}\n\nvoid init()\n{\n\tfac.clear();\n\tfor(ll i=1;i*i<=n;i++){\n        if(n%i==0){\n            fac.push_back(i);\n            if(i*i!=n) fac.push_back(n/i);\n        }\n    }\n    sort(fac.begin(),fac.end());\n}\n\nint main()\n{\n\twhile(cin>>n>>k) init(),work();\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>  \nusing namespace std;\n\n#define ll long long\n#define P 1000000007 \n\nll n,k,dp[33335];\n\nvector<ll> fac;\n\nll fpow(ll a,ll b){\n\tll c=1;\n\tfor(;b;b>>=1,a=a*a%P)\n\t\tif(b&1) c=c*a%P;\n\treturn c;\n}\n\nvoid work()\n{\n\tll ans=0;\n\tfor(int x=0;x<fac.size();x++){\n\t\tdp[x]=fpow(k,(fac[x]+1)/2);\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif(fac[x]%fac[y]==0)\n\t\t\t\tdp[x]=(dp[x]-dp[y]+P)%P;\n\t\t}\n\t\tif(fac[x]%2) ans=(ans+dp[x]*fac[x]%P)%P; \n        else ans=(ans+dp[x]*fac[x]/2%P)%P;\n\t}\n    cout<<ans<<endl;  \n}\n\nvoid init()\n{\n\tfac.clear();\n\tfor(ll i=1;i*i<=n;i++){\n        if(n%i==0){\n            fac.push_back(i);\n            if(i*i!=n) fac.push_back(n/i);\n        }\n    }\n    sort(fac.begin(),fac.end());\n}\n\nint main()\n{\n\twhile(cin>>n>>k) init(),work();\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>  \nusing namespace std;  \ntypedef long long ll;  \nconst ll mod=1e9+7;  \nconst int N=2e5+20;  \nvector<ll> v;  \nll n,k,dp[2500];  \nll powmod(ll x,ll n)  \n{  \n    ll s=1;  \n    while(n)  \n    {  \n        if(n&1)  \n            s=(s*x)%mod;  \n        n>>=1;  \n        x=(x*x)%mod;  \n    }  \n    return s;  \n}  \nvoid init()  \n{  \n    v.clear();  \n    for(ll i=1;i*i<=n;i++)  \n    {  \n        if(n%i==0)  \n        {  \n            v.push_back(i);  \n            if(i*i!=n)  \n                v.push_back(n/i);  \n        }  \n    }  \n    sort(v.begin(),v.end());  \n}  \nint main()  \n{  \n    while(cin>>n>>k)  \n    {  \n        init();  \n        ll ans=0;  \n        for(int x=0;x<v.size();x++)  \n        {  \n            dp[x]=powmod(k,(v[x]+1)/2);  \n            for(int y=0;y<x;y++)  \n            {  \n                if(v[x]%v[y]==0)  \n                    dp[x]=(dp[x]-dp[y]+mod)%mod;      \n            }     \n            if(v[x]%2)  \n                ans=(ans+(dp[x]*v[x])%mod)%mod;  \n            else  \n                ans=(ans+(dp[x]*v[x]/2)%mod)%mod;  \n        }  \n        cout<<ans<<endl;  \n    }  \n    return 0;  \n}  \n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc newSeqWithImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], newSeqWithImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate Seq*[T](lens: varargs[int]; init: T): untyped =\n  newSeqWithImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 1000000007\nvar N:int\nvar K:int\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  K = nextInt()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int32\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a.int32\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0.int32: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v = ((self.v.int * initModInt(a, Mod).v.int) mod MOD).int32\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n#{{{ toInt(seq[int], b = 10), toSeq(n: int, b = 10, min_digit)\nproc toInt(d: seq[int], b = 10):int =\n  result = 0\n  var p = 1\n  for di in d:\n    result += p * di\n    p *= b\nproc toSeq(n: int, b = 10, min_digit = -1):seq[int] =\n  result = newSeq[int]()\n  var n = n\n  while n > 0:result.add(n mod b); n = n div b\n  if min_digit >= 0:\n    while result.len < min_digit: result.add(0)\n#}}}\n\nproc naive(N, K:int):Mint =\n  s := initSet[seq[int]]()\n  ct := newSeq[int](N + 1)\n  d := (N + 1) div 2\n  for n in 0..<K^d:\n    a := toSeq(n, K, d)\n    a.reverse\n    b := a\n    if N mod 2 == 1: discard b.pop\n    b.reverse\n    a = a & b\n    p := N\n    for i in 0..<N:\n      c := a[i..<N] & a[0..<i]\n      if i != 0 and c == a:\n        p = i\n        break\n      s.incl(c)\n    echo a, \" \", p\n    ct[p].inc\n  echo ct\n  return initMint(s.len)\n\nproc divisor(n:int):seq[int] =\n  result = newSeq[int]()\n  var i = 1\n  while i * i <= n:\n    if n mod i == 0:\n      result.add(i)\n      if i * i != n: result.add(n div i)\n    i += 1\n  result.sort(cmp[int])\n\nproc main() =\n  d := N.divisor\n  dp := newSeq[Mint](d.len)\n  ans := initMint(0)\n  for i in 0..<d.len:\n    s := initMint(K)^((d[i] + 1) div 2)\n    for j in 0..<i:\n      if d[i] mod d[j] == 0:\n        s -= dp[j]\n    dp[i] = s\n    let variation = if d[i] mod 2 == 0: d[i] div 2 else: d[i]\n    ans += dp[i] * variation\n  print ans\n  return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\n\nN,K = MI()\nmod = 10**9+7\n\ndef divisor(n):  # nの約数のリスト\n    res = []\n    for i in range(1,int(n**.5)+1):\n        if n % i == 0:\n            res.append(i)\n            if i != n//i:\n                res.append(n//i)\n    return res\n\nA = divisor(N)\n\nd = {}  # d[i] = iの約数のリスト(iはNの約数)\nfor a in A:\n    d[a] = divisor(a)\n\nprime = []  # Nの素因数のリスト\nfor i in range(2,int(N**.5)+1):\n    if N % i == 0:\n        prime.append(i)\n        while N % i == 0:\n            N //= i\nif N != 1:\n    prime.append(N)\n\nmu = {}  # mu[i] = μ(i) (iはNの約数)\nfor a in A:\n    b = a\n    r = 1\n    for p in prime:\n        if b % p == 0:\n            r *= -1\n            if b//p % p == 0:\n                r = 0\n                break\n    mu[a] = r\n\n\nans = 0\nfor a in A:\n    for b in d[a]:\n        if a % 2 == 0:\n            ans += mu[a//b]*pow(K,(b+1)//2,mod)*(a//2)\n            ans %= mod\n        else:\n            ans += mu[a//b]*pow(K,(b+1)//2,mod)*a\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,k = map(int,readline().split())\nMOD = 10**9+7\n\nif n&1:\n    ans = k + (pow(k,(n+1)//2,MOD)-k)*n\n    print(ans%MOD)\n\nelse:\n    def divisor_list(N): #約数のリスト\n        if N == 1: return [1]\n        res = []\n        for i in range(1,N):\n            if i*i >= N: break\n            if N%i == 0:\n                res.append(i)\n                res.append(N//i)\n        if i*i == N: res.append(i)\n        return sorted(res)\n\n    p = [1] + [i for i in divisor_list(n) if i%2==0 and i!=2]\n    \n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        if pi==1:\n            ans += v\n        else:\n            ans += v*(pi//2)\n    ans %= MOD\n        \n        \n    print(ans)        \n        \n        \n"
  },
  {
    "language": "Python",
    "code": "def prime_factor(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            while n % i == 0:\n                n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n\ndef divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    return divisors\n\n\ndef mebius(n):\n    res = {}\n    primes = prime_factor(n)\n    m = len(primes)\n    for i in range(1 << m):\n        mu = 1\n        d = 1\n        for j in range(m):\n            if i >> j & 1:\n                mu *= -1\n                d *= primes[j]\n        res[d] = mu\n    return res\n\n\nmod = 10**9+7\nN, K = map(int, input().split())\ndiv = divisors(N)\n\nans = 0\n\nfor x in div:\n    div2 = divisors(x)\n    mu = mebius(x)\n    cnt = 0\n    for y in mu.keys():\n        cnt += pow(K, ((x//y)+1)//2, mod)*mu[y]\n    if x % 2 == 0:\n        cnt *= pow(2, mod-2, mod)\n    ans += x*cnt\n    ans %= mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10 ** 9 + 7\ni = 1\nM = N\ndiv = []\nwhile i * i <= N:\n    if N % i == 0:\n        div.append(i)\n        if N // i != i:\n            div.append(N // i)\n    i += 1\n\n\ndiv = sorted(div)\nN1 = len(div)\nnum = [0] * (N1 + 1)\nans = 0\nfor i in range(N1):\n    num[i] = pow(K, (div[i] + 1) // 2, MOD)\n    for j in range(i):\n        if div[i] % div[j] == 0:\n            num[i] = num[i] - num[j] + MOD\n            num[i] %= MOD\n\n    if div[i] % 2 == 0:\n        ans += div[i] * num[i] // 2\n        ans %= MOD\n    else:\n        ans += div[i] * num[i]\n        ans %= MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "M=10**9+7;D=[];i=1;r=0;N,K=map(int,input().split())\nwhile i*i<=N:\n\tif N%i==0:D.append(i);i*i<N and D.append(N//i)\n\ti+=1\nD.sort();N=[]\nfor i in range(len(D)):\n\tN.append(pow(K,-~D[i]//2,M))\n\tfor j in range(i):\n\t\tif D[i]%D[j]==0:N[i]=(N[i]-N[j])%M\n\tr=(r+(N[i]*D[i]*pow(2,M-2+D[i]%2,M)))%M\nprint(r)"
  },
  {
    "language": "Python",
    "code": "mod = 10 ** 9 +7\n\ndef main():\n    n, k = map(int, input().split())\n    if n % 2 == 0:\n        ans = pow(k, n // 2, mod) * (n // 2)\n        ans -= k * (n // 2 - 1)\n    else:\n        ans = pow(k, (n + 1) // 2, mod) * n\n        ans -= k * (n - 1)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "M=10**9+7;D=[];i=1;r=0;N,K=map(int,raw_input().split())\nwhile i*i<=N:\n\tif N%i==0:D.append(i);i*i<N and D.append(N/i)\n\ti+=1\nD.sort();N=[]\nfor i in range(len(D)):\n\tN.append(pow(K,-~D[i]/2,M))\n\tfor j in range(i):\n\t\tif D[i]%D[j]==0:N[i]=(N[i]-N[j])%M\n\tr=(r+(N[i]*D[i]*pow(2,M-2+D[i]%2,M)))%M\nprint r"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,k = map(int,readline().split())\nMOD = 10**9+7\n\ndef divisor_list(N): #約数のリスト\n    if N == 1: return [1]\n    res = []\n    for i in range(1,N):\n        if i*i >= N: break\n        if N%i == 0:\n            res.append(i)\n            res.append(N//i)\n    if i*i == N: res.append(i)\n    return sorted(res)\n\n\n\nif n&1:\n    p = [i for i in divisor_list(n)]\n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    #print(r)\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        ans += v*(pi)\n    ans %= MOD\n    print(ans)\n    \n    \n\nelse:\n    p = [1] + [i for i in divisor_list(n) if i%2==0 and i!=2]\n    \n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        if pi==1:\n            ans += v\n        else:\n            ans += v*(pi//2)\n    ans %= MOD\n        \n        \n    print(ans)        \n        \n        \n    \n    \n    \n    \n\n\n    \n    \n    \n    \n    \n    "
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (ll i=(ll)from; i<(ll)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nvector<bool> isp;\n\nvoid sieve(int x=pow(10,6)+10) {\n  isp.resize(x,true); \n  isp[0] = false;\n  isp[1] = false;\n  for (int i=2; pow(i,2)<=x; i++) {\n    if (isp[i]) for(int j=2; i*j<=x; j++) isp[i*j] = false;\n  }\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nll pnk(ll n, ll k) {\n  ll pn = n, now = 0, result = 1;\n  while (k>=1ll<<now) {\n    if (k&1ll<<now) result = result * pn % MOD;\n    pn = pn * pn % MOD;\n    now++;\n  }\n  return result;\n}\n\nint main() {\n  ll N, K; cin >> N >> K;\n\n  // map<string, ll> m;\n  // rep(i,1<<N/2) {\n  //   string S; rep(j,N/2) S += i&1<<j ? '1' : '0';\n  //   rep(j,N/2) S += S[N/2-1-j];\n  //   rep(j,N) {\n  //     m[S]++;\n  //     S = S.substr(1) + S[0];\n  //   }\n  // }\n  // cout << m.size() << endl;\n\n  sieve();\n  vector<ll> yaku;\n  for (ll i=1; i*i<=N; i++) {\n    if (N%i==0) {\n      yaku.push_back(i);\n      if (i*i!=N) yaku.push_back(N/i);\n    }\n  }\n  sort(all(yaku));\n  // debug(all(yaku));\n\n  ll l = yaku.size();\n  vector<ll> count(l,0);\n\n  rep(i,l) {\n    count[i] = pnk(K,(yaku[i]+1)/2);\n    rep(j,i) if (yaku[i]%yaku[j]==0) count[i] = (count[i]-count[j]+MOD) % MOD;\n  }\n  // debug(all(count));\n\n  ll result = 0; rep(i,l) result = (result+(yaku[i]%2 ? yaku[i] : yaku[i]/2)*count[i]) % MOD;\n  cout << result << endl;\n\n  return 0;\n}"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,k = map(int,readline().split())\nMOD = 10**9+7\n\ndef divisor_list(N): #約数のリスト\n    if N == 1: return [1]\n    res = []\n    for i in range(1,N):\n        if i*i >= N: break\n        if N%i == 0:\n            res.append(i)\n            res.append(N//i)\n    if i*i == N: res.append(i)\n    return sorted(res)\n\n\n\nif n&1:\n    p = [1] + [i for i in divisor_list(n)]\n    \n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        ans += v*(pi)\n    ans %= MOD\n    print(ans)\n    \n    \n\nelse:\n    p = [1] + [i for i in divisor_list(n) if i%2==0 and i!=2]\n    \n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        if pi==1:\n            ans += v\n        else:\n            ans += v*(pi//2)\n    ans %= MOD\n        \n        \n    print(ans)        \n        \n        \n    \n    \n    \n    \n\n\n    \n    \n    \n    \n    \n    "
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,K = map(int,input().split())\n\nU=int(10**4.5+10)\ndiv = np.arange(1,U,dtype=np.int64)\ndiv = div[N%div==0]\ndiv = sorted(np.union1d(div,N//div))\n\nA = {d:pow(K,int((d+1)//2),MOD) for d in div}\nB = {}\nfor d in div:\n    B[d] = A[d] - sum(B[dd] for dd in div if dd < d and d%dd == 0)\n\nanswer = sum(B[d] * (d//2 if d%2 == 0 else d) for d in div)\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "M=10**9+7;D=[];i=1;r=0;N,K=map(int,input().split())\nwhile i*i<=N:\n\tif N%i==0:D.append(i);i*i<N and D.append(N//i)\n\ti+=1\nD.sort();N=[]\nfor i in range(len(D)):\n\tN.append(pow(K,-~D[i]//2,M))\n\tfor j in range(i):\n\t\tif D[i]%D[j]==0:N[i]=(N[i]-N[j])%M\n\tr=(r+(N[i]*D[i]*pow(2,M-2+D[i]%2,M)))%M\nprint(r)"
  },
  {
    "language": "Python",
    "code": "import sys\ndef MI(): return map(int,sys.stdin.readline().rstrip().split())\n\nN,K = MI()\nmod = 10**9+7\n\ndef divisor(n):  # nの約数のリスト\n    res = []\n    for i in range(1,int(n**.5)+1):\n        if n % i == 0:\n            res.append(i)\n            if i != n//i:\n                res.append(n//i)\n    return res\n\nA = divisor(N)\n\nd = {}  # d[i] = iの約数のリスト(iはNの約数)\nfor a in A:\n    d[a] = divisor(a)\n\nprime = []  # Nの素因数のリスト\nfor i in range(2,int(N**.5)+1):\n    if N % i == 0:\n        prime.append(i)\n        while N % i == 0:\n            N //= i\nif N != 1:\n    prime.append(N)\n\nmu = {}  # mu[i] = μ(i) (iはNの約数)\nfor a in A:\n    b = a\n    r = 1\n    for p in prime:\n        if b % p == 0:\n            r *= -1\n            if b//p % p == 0:\n                r = 0\n                break\n    mu[a] = r\n\n\nans = 0\nfor a in A:\n    for b in d[a]:\n        if a % 2 == 0:\n            ans += mu[a//b]*pow(K,(b+1)//2,mod)*(a//2)\n            ans %= mod\n        else:\n            ans += mu[a//b]*pow(K,(b+1)//2,mod)*a\n            ans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from math import gcd\n\ndef divisors(M):#Mの約数列 O(n^(0.5+e))\n    d=[]\n    i=1\n    while M>=i**2:\n        if M%i==0:\n            d.append(i)\n            if i**2!=M:\n                d.append(M//i)\n        i=i+1\n    d.sort()\n    return d\n\nmod=10**9+7\nN,K=map(int,input().split())\ndiv=divisors(N)\n\nres=[0 for i in range(len(div))]\nans=0\nif N%2==0:\n    for i in range(len(div)):\n        d=div[i]\n        g=gcd(2*d,N)\n        res[i]+=pow(K,g//2,mod)\n        res[i]%=mod\n        ans+=d*res[i]\n        ans%=mod\n        for j in range(i+1,len(div)):\n            if div[j]%d==0:\n                res[j]-=res[i]\n                res[j]%=mod\n\n    print(ans%mod)\nelse:\n    for i in range(len(div)):\n        d=div[i]\n        g=gcd(2*d,N)\n        res[i]+=pow(K,(g+1)//2,mod)\n        res[i]%=mod\n        ans+=d*res[i]\n        ans%=mod\n        for j in range(i+1,len(div)):\n            if div[j]%d==0:\n                res[j]-=res[i]\n                res[j]%=mod\n\n    print(ans%mod)\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,k = map(int,readline().split())\nMOD = 10**9+7\n\nif n&1:\n    ans = k + (pow(k,(n+1)//2,MOD)-k)*n\n    print(ans%MOD)\n\nelse:\n    assert 0\n    def divisor_list(N): #約数のリスト\n        if N == 1: return [1]\n        res = []\n        for i in range(1,N):\n            if i*i >= N: break\n            if N%i == 0:\n                res.append(i)\n                res.append(N//i)\n        if i*i == N: res.append(i)\n        return sorted(res)\n\n    p = [1] + [i for i in divisor_list(n) if i%2==0 and i!=2]\n    \n    r = {pi:pow(k,(pi+1)//2,MOD) for pi in p}\n    for pi in p:\n        for pj in p:\n            if pj >= pi: break\n            if pi%pj==0:\n                r[pi] -= r[pj]\n\n    #print(r)\n    ans = 0\n    for pi,v in r.items():\n        if pi==1:\n            ans += v\n        else:\n            ans += v*(pi//2)\n    ans %= MOD\n        \n        \n    print(ans)        \n        \n        \n    \n    \n    \n    \n\n\n    \n    \n    \n    \n    \n    "
  },
  {
    "language": "Python",
    "code": "@parallel\n@roles('allgame')\ndef _last_redis_save():\n\twith cd(get_deploy_path()):\n\t\tredisSet = set()\n\t\tret = run('supervisorctl status')\n\t\tfor line in ret.split('\\n'):\n\t\t\tline = line.strip()\n\t\t\tif line.find('RUNNING') >= 0 and line.find('redis') >= 0:\n\t\t\t\tname = line.split()[0].strip()\n\t\t\t\tredisSet.add(name)\n\n\t\tret = []\n\t\twith cd('db'):\n\t\t\tfor redis in sorted(list(redisSet)):\n\t\t\t\tport = redis[5:]\n\t\t\t\tret.append(run('ls -l -h game%s.rdb' % port))\n\t\treturn '\\n'.join(ret)\n\ndef last_redis_save():\n\tresult = execute(_last_redis_save)\n\tfor k in sorted(result.keys()):\n\t\tprint '-'*20\n\t\tprint k, ':'\n\t\tv = result[k]\n\t\tprint v"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,k = list(map(int, input().split()))\nM = 10**9+7\n### 約数列挙\ndef fs(n):\n    s = set()\n    for i in range(1,int(n**0.5)+2):\n        if n%i==0:\n            s.add(i)\n            s.add(n//i)\n    l = sorted(list(s))\n    return l\nds = fs(n)\nm = len(ds)\nnums = [None]*m\nfor i in range(m):\n    val = pow(k, (ds[i]+1)//2, M)\n    for j in range(i):\n        if ds[i]%ds[j]==0:\n            val -= nums[j]\n            val %= M\n    nums[i] = val%M\nans = 0\ninv2 = pow(2, M-2, M)\nfor i in range(m):\n    if ds[i]%2==0:\n        ans += ds[i]*nums[i]*inv2\n    else:\n        ans += ds[i]*nums[i]\n    ans %= M\nprint(ans%M)"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nS = []; T = []\nfor x in range(1, int(N**.5)+1):\n    if N % x == 0:\n        S.append(x)\n        if x*x < N:\n            T.append(N//x)\nT.reverse()\nS += T\nM = len(S)\nU = []\n\nMOD = 10**9 + 7\nans = 0\nv = 0\nfor i in range(M):\n    x = S[i]\n    v = pow(K, (x+1)//2, MOD)\n    for j in range(i):\n        y = S[j]\n        if x % y == 0:\n            v -= U[j]\n    U.append(v % MOD)\n    ans = (ans + (v * x if x & 1 else v * (x//2))) % MOD\nprint(ans)"
  },
  {
    "language": "Rust",
    "code": "\nuse std::{cmp::{max, min, Reverse}, collections::{BTreeMap, BTreeSet, VecDeque, BinaryHeap} };\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer\n}\nfn read_lines<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nfn read_tabulate<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.parse().ok().expect(\"Can't Parse\"));\n    }\n    vec\n}\nmacro_rules! assign {\n    () => {};\n    ($($token:tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        assign_iter!(iter, $($token)*);\n    };\n}\nmacro_rules! assign_iter {\n    ($iter:expr) =>{};\n    ($iter:expr,) =>{};\n    ($iter:expr, $id:ident:$t:tt $($tail:tt)*) => {\n        let $id: $t = $iter.next().unwrap().parse().ok().expect(\"Can't Parse\");\n        assign_iter!($iter, $($tail)*);\n    };\n    ($iter:expr, mut $id:ident:$t:tt $($tail:tt)*) => {\n        let mut $id: $t = $iter.next().unwrap().parse().ok().expect(\"Can't Parse\");\n        assign_iter!($iter, $($tail)*)\n    };\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nstruct KeyValue<K, V>{\n    key: K, \n    value: V\n}\nimpl <K: Clone, V: Clone> Clone for KeyValue<K, V> {\n    fn clone(&self) -> Self {\n        KeyValue{key: self.key.clone(), value: self.value.clone()}\n    }\n}\nimpl <K: PartialEq, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialEq, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        match self.key.partial_cmp(&other.key) {\n            Some(r) => r,\n            None => panic!(\"Can\\'t Compare\"),\n        }\n    }\n}\nfn pow_mod(base: i64, exp: usize, modulo: i64) -> i64 {\n    match exp {\n        0 => 1i64,\n        1 => base % modulo,\n        _ => pow_mod(base * base % modulo, exp >> 1, modulo) * pow_mod(base, exp & 1, modulo) % modulo\n    }\n}\nfn main() {\n    let MOD = 1000000007;\n    assign!{\n        n: i64\n        k: i64\n    }\n    let mut p = 1i64;\n    let mut divisor = Vec::new();\n    while p * p <= n {\n        if n % p == 0 {\n            divisor.push(p);\n            let other = n / p;\n            if other != p {\n                divisor.push(other);\n            }\n        }\n        p += 1;\n    }\n    divisor.sort();\n    let mut cycle_count = vec![0i64; divisor.len()];\n    for i in 0usize .. divisor.len() {\n        let d = divisor[i];\n        let mut acc = pow_mod(k, ((d + 1) >> 1) as usize, MOD);\n        for j in 0usize .. divisor.len() {\n            let e = divisor[j];\n            if e >= d {break;}\n            if d % e == 0{\n                acc = (acc - cycle_count[j] + MOD) % MOD;\n            }\n        }\n        cycle_count[i] = acc; \n    }\n    let mut sum = 0i64;\n    for i in 0usize .. divisor.len() {\n        let d = divisor[i];\n        if (d & 1) == 0 {\n            sum = (sum + cycle_count[i] * (d >> 1)) % MOD;\n        }else {\n            sum = (sum + cycle_count[i] * d) % MOD;\n        }\n    }\n    println!(\"{}\", sum);\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn powmod(a: i64, p: usize, m: i64) -> i64 {\n    let mut ret = 1i64;\n    let mut aa = a;\n    let mut pp = p;\n    while pp >= 1 {\n        if pp & 1 == 1 {\n            ret *= aa;\n            ret %= m;\n        }\n        aa = aa * aa % m;\n        pp >>= 1;\n    }\n    ret\n}\n\nfn inv(a: i64, m: usize) -> i64 {\n    powmod(a, m-2, m as i64)\n}\n\nfn main() {\n    let (n, k): (usize, i64) = read();\n\n    let ans = 0;\n\n    let mut divisors = vec![];\n    for d in 1..n+1 {\n        let d2 = d * d;\n        if d2 == n {\n            divisors.push(d);\n            break;\n        } else if d2 > n {\n            break;\n        }\n        if n % d == 0 {\n            divisors.push(d);\n            divisors.push(n / d);\n        }\n    }\n    divisors.sort();\n\n    let dn = divisors.len();\n\n    let mut dp = vec![0; dn];\n    for i in 0..dn {\n        let d = divisors[i];\n        let mut sum = powmod(k, (d + 1) / 2, MOD);\n        for j in 0..i {\n            if d % divisors[j] == 0 {\n                sum += MOD - dp[j]\n            }\n        }\n        sum %= MOD;\n        dp[i] = sum;\n    }\n\n    let mut ans = 0;\n    for i in 0..dn {\n        let d = divisors[i] as i64;\n        if d % 2 == 0 {\n            ans += dp[i] * (d / 2) % MOD;\n        } else {\n            ans += dp[i] * d % MOD;\n        }\n        ans %= MOD;\n    }\n    println!(\"{}\", ans);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nfn main() {\n    input!{\n        n: usize,\n        k: usize\n    }\n    let d = 1000000007;\n    let mut ds = divisors(n);\n    ds.sort();\n    let m = ds.len();\n    let mut ans = 0;\n    let mut v = vec![0; m];\n    for i in 0..m {\n        v[i] = pow_m(k, (ds[i] + 1) / 2, d);\n        for j in 0..i {\n            if ds[i] % ds[j] == 0 {\n                v[i] = (v[i] + d - v[j]) % d;\n            }\n        }\n        if ds[i] % 2 == 0 {\n            ans += v[i] * ds[i] / 2;\n        } else {\n            ans += v[i] * ds[i];\n        }\n        ans %= d;\n    }\n    println!(\"{}\", ans);\n}\n\nfn factor(n: usize) -> (Vec<usize>, Vec<usize>) {\n    if n == 1 {\n        return (vec![1], vec![1]);\n    }\n    let mut m = n;\n    let mut ps = vec![];\n    let mut rs = vec![];\n    let mut r = 0;\n    while m % 2 == 0 {\n        m /= 2;\n        r += 1;\n    }\n    if r > 0 {\n        ps.push(2);\n        rs.push(r);\n        r = 0\n    }\n    let mut p = 3;\n    while p * p <= m {\n        while m % p == 0 {\n            m /= p;\n            r += 1;\n        }\n        if r > 0 {\n            ps.push(p);\n            rs.push(r);\n            r = 0;\n        }\n        p += 2;\n    }\n    if m > 1 {\n        ps.push(m);\n        rs.push(1);\n    }\n    (ps, rs)\n}\n\nfn divisors(n: usize) -> Vec<usize> {\n    let (ps, rs) = factor(n);\n    let l = rs.len();\n    let mut s = vec![0; l];\n    let mut ret = vec![];\n    while s[l - 1] <= rs[l - 1] {\n        ret.push(ps.iter().zip(s.iter()).map(|(p, &r)| p.pow(r as u32)).product());\n        s[0] += 1;\n        let mut i = 0;\n        while i < l - 1 && s[i] > rs[i] {\n            s[i] = 0;\n            s[i + 1] += 1;\n            i += 1;\n        }\n    }\n    ret\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n"
  }
]