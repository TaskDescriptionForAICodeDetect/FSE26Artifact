[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_W 500\n#define MAX_H 500\n\nint parent[MAX_W * MAX_H];\nint rank[MAX_W * MAX_H];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else if (rank[px] > rank[py]) {\n        parent[py] = px;\n    } else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nint compareEdge(const void* a, const void* b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint main() {\n    int W, H;\n    scanf(\"%d %d\", &W, &H);\n    \n    int p[MAX_W];\n    int q[MAX_H];\n    \n    for (int i = 0; i < W - 1; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    \n    for (int j = 0; j < H - 1; j++) {\n        scanf(\"%d\", &q[j]);\n    }\n    \n    Edge edges[(W * H - 1) * 2];\n    int edgeCount = 0;\n    \n    for (int i = 0; i < W; i++) {\n        for (int j = 0; j < H - 1; j++) {\n            edges[edgeCount].u = i * H + j;\n            edges[edgeCount].v = i * H + j + 1;\n            edges[edgeCount].cost = q[j];\n            edgeCount++;\n        }\n    }\n    \n    for (int j = 0; j < H; j++) {\n        for (int i = 0; i < W - 1; i++) {\n            edges[edgeCount].u = i * H + j;\n            edges[edgeCount].v = (i + 1) * H + j;\n            edges[edgeCount].cost = p[i];\n            edgeCount++;\n        }\n    }\n    \n    qsort(edges, edgeCount, sizeof(Edge), compareEdge);\n    \n    init(W * H);\n    \n    int totalCost = 0;\n    int connectedEdges = 0;\n    \n    for (int i = 0; i < edgeCount; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        \n        if (find(u) != find(v)) {\n            unionSet(u, v);\n            totalCost += edges[i].cost;\n            connectedEdges++;\n            \n            if (connectedEdges == W * H - 1) {\n                break;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", totalCost);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int cost;\n    int type; // 0 for p_i (vertical), 1 for q_j (horizontal)\n} Road;\n\nint compare(const void *a, const void *b) {\n    Road *roadA = (Road *)a;\n    Road *roadB = (Road *)b;\n    return roadA->cost - roadB->cost;\n}\n\nint main() {\n    int W, H;\n    scanf(\"%d %d\", &W, &H);\n\n    int p[W];\n    for (int i = 0; i < W; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n\n    int q[H];\n    for (int j = 0; j < H; j++) {\n        scanf(\"%d\", &q[j]);\n    }\n\n    int totalRoads = W + H;\n    Road roads[totalRoads];\n    int index = 0;\n\n    for (int i = 0; i < W; i++) {\n        roads[index].cost = p[i];\n        roads[index].type = 0;\n        index++;\n    }\n\n    for (int j = 0; j < H; j++) {\n        roads[index].cost = q[j];\n        roads[index].type = 1;\n        index++;\n    }\n\n    qsort(roads, totalRoads, sizeof(Road), compare);\n\n    long long totalCost = 0;\n    int verticalEdges = 0;\n    int horizontalEdges = 0;\n\n    for (int i = 0; i < totalRoads; i++) {\n        if (roads[i].type == 0) {\n            totalCost += (long long)roads[i].cost * (H + 1 - horizontalEdges);\n            verticalEdges++;\n        } else {\n            totalCost += (long long)roads[i].cost * (W + 1 - verticalEdges);\n            horizontalEdges++;\n        }\n    }\n\n    printf(\"%lld\\n\", totalCost);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, cost;\n    Edge(int u, int v, int cost) : u(u), v(v), cost(cost) {}\n    bool operator<(const Edge &other) const {\n        return cost < other.cost;\n    }\n};\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        rank.resize(size, 0);\n        for (int i = 0; i < size; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) parent[x] = y;\n        else {\n            parent[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<int> p(W), q(H);\n    for (int i = 0; i < W; ++i) cin >> p[i];\n    for (int i = 0; i < H; ++i) cin >> q[i];\n\n    vector<Edge> edges;\n    for (int i = 0; i < W; ++i) {\n        edges.emplace_back(i, i + 1, p[i]);\n    }\n    for (int j = 0; j < H; ++j) {\n        edges.emplace_back(W + j + 1, W + j, q[j]);\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf(W + H + 2);\n    long long total_cost = 0;\n    int horizontal_used = 0, vertical_used = 0;\n    for (const Edge &e : edges) {\n        if (!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n            total_cost += e.cost;\n            if (e.u <= W && e.v <= W) horizontal_used++;\n            else vertical_used++;\n        }\n    }\n\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Road implements Comparable<Road> {\n    int u, v, cost;\n\n    Road(int u, int v, int cost) {\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Road other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\npublic class Main {\n    static int[] parent;\n\n    static int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    static boolean union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV) {\n            return false;\n        }\n        parent[rootV] = rootU;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int W = scanner.nextInt();\n        int H = scanner.nextInt();\n        int[] p = new int[W];\n        int[] q = new int[H];\n        for (int i = 0; i < W; i++) {\n            p[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < H; i++) {\n            q[i] = scanner.nextInt();\n        }\n\n        List<Road> roads = new ArrayList<>();\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                int u = i * (H + 1) + j;\n                int v = i * (H + 1) + j + 1;\n                roads.add(new Road(u, v, q[j]));\n            }\n        }\n        for (int j = 0; j < H; j++) {\n            for (int i = 0; i < W; i++) {\n                int u = i * (H + 1) + j;\n                int v = (i + 1) * (H + 1) + j;\n                roads.add(new Road(u, v, p[i]));\n            }\n        }\n\n        Collections.sort(roads);\n\n        int totalNodes = (W + 1) * (H + 1);\n        parent = new int[totalNodes];\n        for (int i = 0; i < totalNodes; i++) {\n            parent[i] = i;\n        }\n\n        long totalCost = 0;\n        int edgesAdded = 0;\n        for (Road road : roads) {\n            if (union(road.u, road.v)) {\n                totalCost += road.cost;\n                edgesAdded++;\n                if (edgesAdded == totalNodes - 1) {\n                    break;\n                }\n            }\n        }\n\n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 23:35:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadPaving {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int W = scanner.nextInt();\n        int H = scanner.nextInt();\n        \n        int[][] horizontalRoads = new int[W][H+1];\n        int[][] verticalRoads = new int[W+1][H];\n        \n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                horizontalRoads[i][j] = scanner.nextInt();\n            }\n        }\n        \n        for (int i = 0; i < W+1; i++) {\n            for (int j = 0; j < H; j++) {\n                verticalRoads[i][j] = scanner.nextInt();\n            }\n        }\n        \n        List<Edge> edges = new ArrayList<>();\n        \n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (i < W - 1) {\n                    edges.add(new Edge(i * H + j, (i + 1) * H + j, horizontalRoads[i][j]));\n                }\n                if (j < H - 1) {\n                    edges.add(new Edge(i * H + j, i * H + j + 1, verticalRoads[i][j]));\n                }\n            }\n        }\n        \n        Collections.sort(edges);\n        \n        UnionFind uf = new UnionFind((W + 1) * (H + 1));\n        \n        long totalCost = 0;\n        int edgesAdded = 0;\n        \n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                totalCost += edge.cost;\n                edgesAdded++;\n                \n                if (edgesAdded == (W * H)) {\n                    break;\n                }\n            }\n        }\n        \n        System.out.println(totalCost);\n        \n        scanner.close();\n    }\n    \n    static class Edge implements Comparable<Edge> {\n        int u, v, cost;\n        \n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n        \n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) {\n                return false;\n            }\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            \n            return true;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:35:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n        if (rank[px] < rank[py]) swap(px, py);\n        parent[py] = px;\n        if (rank[px] == rank[py]) rank[px]++;\n    }\n};\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n\n    vector<int> p(W);\n    for (int i = 0; i < W; i++) cin >> p[i];\n\n    vector<int> q(H);\n    for (int i = 0; i < H; i++) cin >> q[i];\n\n    vector<pair<int, pair<int, int>>> edges;\n\n    // Horizontal roads\n    for (int j = 0; j < H + 1; j++) {\n        for (int i = 0; i < W; i++) {\n            edges.push_back({p[i], {j * (W + 1) + i, j * (W + 1) + i + 1}});\n        }\n    }\n\n    // Vertical roads\n    for (int i = 0; i < W + 1; i++) {\n        for (int j = 0; j < H; j++) {\n            edges.push_back({q[j], {j * (W + 1) + i, (j + 1) * (W + 1) + i}});\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n\n    UnionFind uf((W + 1) * (H + 1));\n    long long total_cost = 0;\n\n    for (auto& edge : edges) {\n        int cost = edge.first;\n        int u = edge.second.first;\n        int v = edge.second.second;\n\n        if (uf.find(u) != uf.find(v)) {\n            uf.unite(u, v);\n            total_cost += cost;\n        }\n    }\n\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappop, heappush\n\ndef minimum_cost_to_connect_houses(W, H, p, q):\n    # Total number of vertices (houses)\n    total_vertices = (W+1) * (H+1)\n    \n    # Using Kruskal's algorithm to find the Minimum Spanning Tree (MST)\n    # Define a function for the union-find / disjoint-set\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    # Initialize union-find data structure\n    parent = list(range(total_vertices))\n    rank = [0] * total_vertices\n\n    # Minimum heap for processing edges\n    min_heap = []\n    \n    # Insert edges with their costs into min_heap\n    for i in range(W+1):\n        for j in range(H):\n            # Vertical edges (i, j) -> (i, j+1)\n            heappush(min_heap, (q[j], i * (H+1) + j, i * (H+1) + (j+1)))\n\n    for i in range(W):\n        for j in range(H+1):\n            # Horizontal edges (i, j) -> (i+1, j)\n            heappush(min_heap, (p[i], i * (H+1) + j, (i+1) * (H+1) + j))\n    \n    # Implementing Kruskal's algorithm\n    min_cost = 0\n    edges_used = 0\n\n    while edges_used < total_vertices - 1 and min_heap:\n        cost, u, v = heappop(min_heap)\n        if find(u) != find(v):\n            union(u, v)\n            min_cost += cost\n            edges_used += 1\n            \n    return min_cost\n\n# Example usage\nW, H = 2, 2\np = [3, 2]  # Costs for horizontal roads between (i, j) and (i+1, j)\nq = [5, 4]  # Costs for vertical roads between (i, j) and (i, j+1)\nprint(minimum_cost_to_connect_houses(W, H, p, q))  # Expected output: 14",
    "timestamp": "2025-08-13 15:55:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PavingRoads {\n\n    static class Edge implements Comparable<Edge> {\n        int cost, x, y;\n\n        Edge(int cost, int x, int y) {\n            this.cost = cost;\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    static class UnionFind {\n        private int[] parent;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                parent[rootX] = rootY;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public static int minCostToPaveRoads(int W, int H, int[] p, int[] q) {\n        int totalVertices = (W + 1) * (H + 1);\n        List<Edge> edges = new ArrayList<>();\n\n        // Add vertical roads\n        for (int i = 0; i <= W; i++) {\n            for (int j = 0; j < H; j++) {\n                int from = i * (H + 1) + j;\n                int to = from + 1;\n                edges.add(new Edge(q[j], from, to));\n            }\n        }\n\n        // Add horizontal roads\n        for (int j = 0; j <= H; j++) {\n            for (int i = 0; i < W; i++) {\n                int from = i * (H + 1) + j;\n                int to = from + (H + 1);\n                edges.add(new Edge(p[i], from, to));\n            }\n        }\n\n        Collections.sort(edges);\n\n        UnionFind uf = new UnionFind(totalVertices);\n        int minCost = 0;\n\n        for (Edge edge : edges) {\n            if (uf.union(edge.x, edge.y)) {\n                minCost += edge.cost;\n            }\n        }\n\n        return minCost;\n    }\n\n    public static void main(String[] args) {\n        int W = 3; // Width\n        int H = 3; // Height\n        int[] p = {1, 2, 3}; // Cost of horizontal roads\n        int[] q = {4, 5, 6}; // Cost of vertical roads\n\n        System.out.println(minCostToPaveRoads(W, H, p, q)); // Output the minimum cost\n    }\n}",
    "timestamp": "2025-08-13 15:55:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Disjoint Set (Union-Find) data structure\ntypedef struct {\n    int *parent;\n    int *rank;\n} DisjointSet;\n\n// Function to create a new Disjoint Set for given number of elements\nDisjointSet* createDisjointSet(int size) {\n    DisjointSet *ds = (DisjointSet *)malloc(sizeof(DisjointSet));\n    ds->parent = (int *)malloc(size * sizeof(int));\n    ds->rank = (int *)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        ds->parent[i] = i;\n        ds->rank[i] = 0;\n    }\n    return ds;\n}\n\n// Find function with path compression\nint find(DisjointSet *ds, int a) {\n    if (ds->parent[a] != a) {\n        ds->parent[a] = find(ds, ds->parent[a]);\n    }\n    return ds->parent[a];\n}\n\n// Union function with union by rank\nvoid unionSets(DisjointSet *ds, int a, int b) {\n    int rootA = find(ds, a);\n    int rootB = find(ds, b);\n    if (rootA != rootB) {\n        if (ds->rank[rootA] > ds->rank[rootB]) {\n            ds->parent[rootB] = rootA;\n        } else if (ds->rank[rootA] < ds->rank[rootB]) {\n            ds->parent[rootA] = rootB;\n        } else {\n            ds->parent[rootB] = rootA;\n            ds->rank[rootA]++;\n        }\n    }\n}\n\n// Edge structure\ntypedef struct {\n    int cost;\n    int u;\n    int v;\n} Edge;\n\n// Compare edges by cost\nint compareEdges(const void *a, const void *b) {\n    return ((Edge*)a)->cost - ((Edge*)b)->cost;\n}\n\nint main() {\n    int W, H;\n    scanf(\"%d %d\", &W, &H);\n    \n    int *p = (int *)malloc((W + 1) * sizeof(int));\n    int *q = (int *)malloc((H + 1) * sizeof(int));\n    \n    for (int i = 0; i <= W; i++) {\n        scanf(\"%d\", &p[i]);\n    }\n    for (int j = 0; j <= H; j++) {\n        scanf(\"%d\", &q[j]);\n    }\n\n    Edge *edges = (Edge *)malloc((W * (H + 1) + H * (W + 1)) * sizeof(Edge));\n    int edgeCount = 0;\n\n    for (int i = 0; i <= W; i++) {\n        for (int j = 0; j < H; j++) {\n            edges[edgeCount++] = (Edge){q[j], i * (H + 1) + j, i * (H + 1) + (j + 1)};\n        }\n    }\n\n    for (int i = 0; i < W; i++) {\n        for (int j = 0; j <= H; j++) {\n            edges[edgeCount++] = (Edge){p[i], i * (H + 1) + j, (i + 1) * (H + 1) + j};\n        }\n    }\n\n    qsort(edges, edgeCount, sizeof(Edge), compareEdges);\n    \n    DisjointSet *ds = createDisjointSet((W + 1) * (H + 1));\n    int totalCost = 0;\n\n    for (int i = 0; i < edgeCount; i++) {\n        if (find(ds, edges[i].u) != find(ds, edges[i].v)) {\n            unionSets(ds, edges[i].u, edges[i].v);\n            totalCost += edges[i].cost;\n        }\n    }\n\n    printf(\"%d\\n\", totalCost);\n\n    free(p);\n    free(q);\n    free(edges);\n    free(ds->parent);\n    free(ds->rank);\n    free(ds);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:55:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Edge {\n    int cost, u, v;\n    Edge(int _cost, int _u, int _v) : cost(_cost), u(_u), v(_v) {}\n};\n\nint findSet(vector<int>& parent, int u) {\n    if (parent[u] != u) {\n        parent[u] = findSet(parent, parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unionSet(vector<int>& parent, vector<int>& rank, int u, int v) {\n    int rootU = findSet(parent, u);\n    int rootV = findSet(parent, v);\n    if (rootU != rootV) {\n        if (rank[rootU] < rank[rootV]) {\n            parent[rootU] = rootV;\n        } else if (rank[rootU] > rank[rootV]) {\n            parent[rootV] = rootU;\n        } else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n    }\n}\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    \n    vector<int> p(W), q(H);\n    for (int i = 0; i < W; ++i) {\n        cin >> p[i];\n    }\n    for (int j = 0; j < H; ++j) {\n        cin >> q[j];\n    }\n\n    int n = (W + 1) * (H + 1);\n    vector<Edge> edges;\n\n    for (int i = 0; i <= W; ++i) {\n        for (int j = 0; j <= H; ++j) {\n            if (i < W) {\n                edges.emplace_back(p[i], i * (H + 1) + j, (i + 1) * (H + 1) + j);\n            }\n            if (j < H) {\n                edges.emplace_back(q[j], i * (H + 1) + j, i * (H + 1) + (j + 1));\n            }\n        }\n    }\n\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.cost < b.cost;\n    });\n\n    vector<int> parent(n), rank(n, 0);\n    iota(parent.begin(), parent.end(), 0);\n\n    int cost = 0;\n    for (const auto& edge : edges) {\n        if (findSet(parent, edge.u) != findSet(parent, edge.v)) {\n            unionSet(parent, rank, edge.u, edge.v);\n            cost += edge.cost;\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:55:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_road_paving_cost(W, H, p_costs, q_costs):\n    # Initialize disjoint set data structure\n    parent = list(range((W + 1) * (H + 1)))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    # Create list of all roads with their costs\n    roads = []\n    \n    # Horizontal roads\n    for j in range(H + 1):\n        for i in range(W):\n            roads.append((p_costs[i], j * (W + 1) + i, j * (W + 1) + i + 1))\n    \n    # Vertical roads\n    for i in range(W + 1):\n        for j in range(H):\n            roads.append((q_costs[j], j * (W + 1) + i, (j + 1) * (W + 1) + i))\n    \n    # Sort roads by cost\n    roads.sort()\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    for cost, u, v in roads:\n        if find(u) != find(v):\n            union(u, v)\n            total_cost += cost\n    \n    return total_cost",
    "timestamp": "2025-08-13 15:55:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    W, H = map(int, data[idx:idx+2])\n    idx +=2\n    p = list(map(int, data[idx:idx+W]))\n    idx +=W\n    q = list(map(int, data[idx:idx+H]))\n    \n    p.sort()\n    q.sort()\n    \n    res = 0\n    i = 0\n    j = 0\n    horizontal_used = 0\n    vertical_used = 0\n    total_edges = (W * (H + 1)) + ((W + 1) * H)\n    \n    while horizontal_used < W or vertical_used < H:\n        if i < W and (j >= H or p[i] <= q[j]):\n            res += p[i] * (H - vertical_used + 1)\n            horizontal_used += 1\n            i += 1\n        else:\n            res += q[j] * (W - horizontal_used + 1)\n            vertical_used += 1\n            j += 1\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 16:00:39"
  }
]