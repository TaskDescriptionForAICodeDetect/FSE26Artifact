[
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass DSecretPassage {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      string s; cin >> s;\n      int n = s.size();\n      auto rs = s;\n      reverse(all(rs));\n\n      bool dp[n+1][n+1][n+1];\n      rep(i, n+1) rep(j, n+1) rep(k, n+1) {\n        dp[i][j][k] = false;\n      }\n      dp[0][0][0] = true;\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) {\n          for(int k=0; k<n; k++) {\n            if (dp[i][j][k]) {\n              //if (i < 10) debug(i, j, k);\n              if (i < n-1) {\n                // both from string\n                if (s[i] == '0' || s[i+1] == '0') {\n                  dp[i+2][j+1][k] = true;\n                }\n                if (s[i] == '1' || s[i+1] == '1') {\n                  dp[i+2][j][k+1] = true;\n                }\n              }\n              // erase from string\n              dp[i+1][j][k] = true;\n\n              // erase from pocket\n              if (s[i] == '0' && k > 0) {\n                dp[i+1][j+1][k-1] = true;\n              }\n              if (s[i] == '1' && j > 0) {\n                dp[i+1][j-1][k+1] = true;\n              }\n\n            }\n          }\n        }\n      }\n\n      mod = mod9;\n\n      mint dp2[n+1][n+1][n+1];\n      rep(i, n+1) rep(j, n+1) rep(k, n+1) {\n        dp2[i][j][k] = 0;\n      }\n      dp2[0][0][0] = 1;\n      for(int i=0; i<n; i++) {\n        for(int j=0; j<n; j++) {\n          for(int k=0; k<n; k++) {\n            //if (!dp[n-i][j][k]) continue;\n            // add zero\n            if (rs[i] == '0') {\n              dp2[i+1][j][k] += dp2[i][j][k];\n            } else {\n              dp2[i][j+1][k] += dp2[i][j][k];\n            }\n            // add one\n            if (rs[i] == '1') {\n              dp2[i+1][j][k] += dp2[i][j][k];\n            } else {\n              dp2[i][j][k+1] += dp2[i][j][k];\n            }\n          }\n        }\n      }\n\n      mint ans = 0;\n      for(int i=0; i<=n; i++) {\n        for(int j=0; j<=n; j++) {\n          for(int k=0; k<=n; k++) {\n            if (!dp[n-i][j][k]) continue;\n            //debug(i, j, k, dp2[i][j][k].x);\n            ans += dp2[i][j][k];\n          }\n        }\n      }\n      cout << (ans -1).x << endl;\n    }\n};\n\nsigned main() {\n  DSecretPassage solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//{\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define all(v) (v).begin(),(v).end()\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n\n\n#define PII pair<int,int>\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n};\n//{\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n#define jeb() fflush(stdout);\n//}\n\nint n;\nchar s[305];\nVI v;\n// mag[pos][k] na pozycji pos majac k jedynek ile \n// maksymalnie zer \nint mag[305][305];\nint mod = 998244353;\n\n//co[dl][j] dla finalnej dlugosci dl i liczby jedynek j\n//maksymalny sufix ktory musi byc \nint co[305][305];\nint suf[305];\n\nint dp[305][305][305];\n\nint rob2(int sufix, int zer, int jedynek) {\n\tif (dp[sufix][zer][jedynek] != -1) return dp[sufix][zer][jedynek];\n\tint ans = 0;\n\tif (sufix >= n) {\n\t\tif (zer == 0) return 1;\n\t\tif (jedynek == 0) return 1;\n\t\tans = rob2(sufix, zer-1, jedynek) + rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 0) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (jedynek > 0) \n\t\t\t\tans += rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 1) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (zer > 0) \n\t\t\t\tans += rob2(sufix, zer-1, jedynek);\n\t}\n\tans %= mod;\n\tdp[sufix][zer][jedynek] = ans;\n\treturn ans;\n}\n\nint rob(int sufix, int zer, int jedynek) {\n\t\tint wynik = rob2(sufix, zer, jedynek);\n\t\t//debug() << imie(sufix) imie(zer) imie(jedynek) imie(wynik);\n\t\treturn wynik;\n\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tFOR(i,0,n) v.pb(s[i]-'0');\n\tsuf[n] = 0;\n\tFORD(i,n-1,0) suf[i] = suf[i+1] + v[i];\n\tif (n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tFOR(i,0,n+1) FOR(j,0,n+1) mag[i][j] = -1e9;\n\tFOR(i,0,n+1) mag[i][0] = 0;\n\n\tFOR(i,2,n+1) {\n\t\t// skreslam dwa\n\t\tbool jest1 = (v[i-1] == 1 || v[i-2] == 1);\n\t\tbool jest0 = (v[i-1] == 0 || v[i-2] == 0);\t\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) mag[i][j+1] = max(mag[i][j+1], mag[i-2][j]);\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,0,n+1) mag[i][j] = max(mag[i][j], mag[i-2][j]+1);\n\t\t}\n\t\t// skreslam jeden\n\t\tjest1 = (v[i-1] == 1);\n\t\tjest0 = (v[i-1] == 0);\n\t\tFOR(j,0,n+1) mag[i][j] = max(mag[i][j], mag[i-1][j]);\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) {\n\t\t\t\tif (mag[i-1][j] > 0) {\n\t\t\t\t\tmag[i][j+1] = max(mag[i][j+1], mag[i-1][j]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,1,n+1) {\n\t\t\t\tif (mag[i-1][j] >= 0) {\n\t\t\t\t\tmag[i][j-1] = max(mag[i][j-1], mag[i-1][j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//FOR(i,0,n+1) FOR(j,0,n+1) debug() << imie(i) imie(j) imie(mag[i][j]);\n\t\n\tFOR(i,0,n+1) FOR(j,0,n+1) co[i][j] = -1e9;\n\tFOR(i,0,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (mag[i][j] < 0) continue;\n\t\t\tFOR(k,0,mag[i][j]+1) {\n\t\t\t\tint dl = (n-i) + j + k;\n\t\t\t\tint jed = suf[i] + j;\n\t\t\t\tco[dl][jed] = max(co[dl][jed], i);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,305) FOR(j,0,305) FOR(k,0,305) dp[i][j][k] = -1;\n\tint ans = 0;\n\tFOR(i,1,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (co[i][j] >= 0) {\n\t\t\t\tint plus_jeden = j-suf[co[i][j]];\n\t\t\t\tint plus_zero = i-(n-co[i][j])-plus_jeden;\n\t\t\t\tans = ans + rob(/*pref=*/co[i][j], plus_zero, plus_jeden);\n\t\t\t\tif (ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 600 + 7;\nconst int M = 998244353;\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint sum(int a, int b) {\n  int c = (a + b) % M;\n  if (c >= M) c -= M;\n  if (c < 0) c += M;\n  return c;\n}\n\nvoid add(int &a, int b) {\n  a = sum(a ,b);\n}\n\nbool dp[N][N][N];\nint vals[N][N][N];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  dp[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int x = n; x >= 0; x--) {\n      for (int y = n; y >= 0; y--) {\n        if (!dp[i][x][y]) continue;\n        if (x + y >= 2) {\n          if (x)\n            dp[i][x - 1][y] = true;\n          if (y)\n            dp[i][x][y - 1] = true;\n        }\n        if (x + y >= 1) {\n          dp[i + 1][x][y] = true;\n        }\n        if (x && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x][y] = true;\n          } else {\n            dp[i + 1][x - 1][y + 1] = true;\n          }\n        }\n        if (y && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x + 1][y - 1] = true;\n          } else {\n            dp[i + 1][x][y] = true;\n          }\n        }\n        if (i + 1 < n) {\n          if (s[i] == s[i + 1]) {\n            if (s[i] == '0') {\n              dp[i + 2][x + 1][y] = true;\n            } else {\n              dp[i + 2][x][y + 1] = true;\n            }\n          } else {\n            dp[i + 2][x + 1][y] = true;\n            dp[i + 2][x][y + 1] = true;\n          }\n        }\n      }\n    }\n  }\n  vals[n][0][0] = 1;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (x + 1 <= n) {\n          if (!i || s[i - 1] != '0')\n            add(vals[i][x + 1][y], vals[i][x][y]);\n          else\n            add(vals[i - 1][x + 1][y], vals[i][x][y]);\n        }\n        if (y + 1 <= n) {\n          if (!i || s[i - 1] != '1')\n            add(vals[i][x][y + 1], vals[i][x][y]);\n          else\n            add(vals[i - 1][x][y + 1], vals[i][x][y]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (i) add(vals[i][x][y], vals[i - 1][x][y]);\n      }\n    }\n  }\n  vector <int> pa(n + 1), pb(n + 1);\n  int a = 0, b = 0;\n  for (int i = n; i >= 0; i--) {\n    if (i < n && s[i] == '0') a++;\n    if (i < n && s[i] == '1') b++;\n    pa[i] = a, pb[i] = b;\n  }\n  auto cost = [&] (int i, int a, int b) {\n    a += pa[i], b += pb[i];\n    int sum = vals[i][a][b];\n    return sum;\n  };\n  int ans = 0;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (dp[i][x][y]) {\n          int cur = 0;\n          add(cur, cost(i, x, y));\n          if (i) {\n            if (s[i - 1] == '0' && x && dp[i - 1][x - 1][y]) {\n              add(cur, -cost(i - 1, x - 1, y));\n            }\n            if (s[i - 1] == '1' && y && dp[i - 1][x][y - 1]) {\n              add(cur, -cost(i - 1, x, y - 1));\n            }\n          }\n          add(ans, cur);\n        }\n      }\n    }\n  }\n  cout << ans % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nconst int mod=998244353;\ntypedef vector<int> vi;\n#define pb push_back\n#define sz(a) int(a.size())\n\nchar s[N];\nint n,f[N][N][N],g[N][N][N],h[N][N][N],sum[N][2];\n\nint getf(int i,int j,int k) {\n\tif(j+k>n-i) return 0;\n\tif(i==n) return 1;\n\tif(f[i][j][k]!=-1) return f[i][j][k];\n\tfor(int a=0;a<2;a++)\n\t\tfor(int b=0;b<2;b++)\n\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\tfor(int y=0;y<2;y++) {\n\t\t\t\t\tvi vec;\n\t\t\t\t\tif(!x) vec.pb(a);\n\t\t\t\t\tif(!y) vec.pb(b);\n\t\t\t\t\tbool fl=1;\n\t\t\t\t\tfor(int l=0;l<sz(vec);l++)\n\t\t\t\t\t\tif(s[i+1+l]!=vec[l]) { fl=0;break; }\n\t\t\t\t\tif(!fl) continue;\n\t\t\t\t\tint cnt[2];cnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[b]) {\n\t\t\t\t\t\t--cnt[b];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+sz(vec),cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t\t\t\tcnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[a]) {\n\t\t\t\t\t\t--cnt[a];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+sz(vec),cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t}\n\treturn f[i][j][k]=0;\n}\n\nint geth(int i,int j,int k) {\n\tif(i<0) return 0;\n\tif(h[i][j][k]!=-1) return h[i][j][k];\n\tif(j>=sum[i][0]&&k>=sum[i][1]&&getf(i,j-sum[i][0],k-sum[i][1])) return h[i][j][k]=1;\n\treturn h[i][j][k]=geth(i-1,j,k);\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>(s+1);n=strlen(s+1);reverse(s+1,s+n+1);\n\tfor(int i=1;i<=n;i++) s[i]-='0',sum[i][0]=sum[i-1][0],sum[i][1]=sum[i-1][1],++sum[i][s[i]];\n\ts[n+1]=2;\n\tmemset(f,-1,sizeof(f));\n\tmemset(h,-1,sizeof(h));\n\tint ans=0;\n\tg[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;i+j<n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++) {\n\t\t\t\tg[i+1][j][k+(s[k+1]==0)]=(g[i+1][j][k+(s[k+1]==0)]+g[i][j][k])%mod;\n\t\t\t\tg[i][j+1][k+(s[k+1]==1)]=(g[i][j+1][k+(s[k+1]==1)]+g[i][j][k])%mod;\n\t\t\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;i+j<=n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++)\n\t\t\t\tif(geth(k,i,j)) ans=(ans+g[i][j][k])%mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld long double\n#define ll long long\n#define st first\n#define nd second\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst ll mod = 998244353;\nconst int N = 301;\nint n;\nstring s, t;\nll dp[N][N][N];\nbool p[N][N][N], ign[N][N][N];\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s;\n\tn = s.size();\n\tt = s;\n\treverse(t.begin(), t.end());\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=n; j>=0; --j) {\n\t\t\tfor(int k=n; k>=0; --k) {\n\t\t\t\tif(i==0) {\n\t\t\t\t\tif(j==0 && k==0) p[i][j][k]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1) continue;\n\t\t\t\tif((s[i-2] == '0' || s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j-1][k];\n\t\t\t\t}\n\t\t\t\tif((s[i-2] == '1' || s[i-1] == '1') && k != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j][k];\n\t\t\t\tif((s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j-1][k+1];\n\t\t\t\t}\n\t\t\t\tif((s[i-1] == '1') && k != 0){\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j+1][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j+1][k];\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j][k+1];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(i==0 && j==0 && k==0) {\n\t\t\t\t\tdp[i][j][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==0) {\n\t\t\t\t\tdp[i][j][k] = (((j==0)?0LL:dp[i][j-1][k]) + ((k==0)?0LL:dp[i][j][k-1])) % mod;\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n\t\t\t\tif(t[i-1] == '0' && k != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j][k-1]) % mod;\n\t\t\t\tif(t[i-1] == '1' && j != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j-1][k]) % mod;\n\t\t\t\tif(t[i-1] == '0' && (p[n-(i-1)][j+1][k] || ign[i-1][j+1][k])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(t[i-1]=='1' && (p[n-(i-1)][j][k+1] || ign[i-1][j][k+1])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(!ign[i][j][k]) ans = (ans + dp[i][j][k] * p[n-i][j][k]) % mod;\n\t\t\t\t//if(p[n-i][j][k] && !ign[i][j][k]) {\n\t\t\t\t//\tcout<<i<<' '<<j<<' '<<k<<\": \"<<dp[i][j][k]<<'\\n';\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans-1+mod)%mod;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static constexpr unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconstexpr LL MOD = 998244353;\nusing Mint = ModInt<MOD>;\n\nint N;\nchar S[311];\n\nbool vis[311][311][311];\n\nMint dp[311][311][311];\n\nvoid MAIN() {\n    scanf(\"%s\", S);\n    N = strlen(S);\n\n    const int zeros = count(S, S+N, '0');\n    const int ones = N - zeros;\n\n    dp[0][0][0] = 1;\n    REP (i, N+1) {\n\tREP (a, zeros+1) REP (b, ones+1) if (dp[i][a][b].x) {\n\t    // push_front 0;\n\t    if (i < N && S[N-1-i] == '0') {\n\t\tdp[i+1][a][b] += dp[i][a][b];\n\t    } else {\n\t\tdp[i][a+1][b] += dp[i][a][b];\n\t    }\n\t    // push_front 1;\n\t    if (i < N && S[N-1-i] == '1') {\n\t\tdp[i+1][a][b] += dp[i][a][b];\n\t    } else {\n\t\tdp[i][a][b+1] += dp[i][a][b];\n\t    }\n\t}\n    }\n\n    for (int i=N; i>=1; i--) {\n\tint c0 = 0, c1 = 0;\n\tif (S[N-i] == '0') c0++;\n\telse c1++;\n\tREP (a, zeros+1) REP (b, ones+1) if (dp[i][a][b].x) {\n\t    dp[i-1][a+c0][b+c1] += dp[i][a][b];\n\t}\n    }\n\n\n\n    Mint ans = 1;\n    vis[0][0][0] = true;\n    REP (t, N) {\n\t// len = N-1-t;\n\t\n\t// S[t+a+b .. );\n\tREP (a, t+1) REP (b, t+1) if (vis[t][a][b]) {\n\t    if (t+a+b+2<=N) {\n\t\tint c0 = 0, c1 = 0;\n\t\tREP (h, 2) {\n\t\t    if (S[t+a+b+h] == '0') c0++;\n\t\t    else c1++;\n\t\t}\n\n\t\tif (c0) {\n\t\t    vis[t+1][a+c0-1][b+c1] = true;\n\t\t}\n\t\tif (c1) {\n\t\t    vis[t+1][a+c0][b+c1-1] = true;\n\t\t}\n\t    }\n\n\t    if (a+b >= 1 && t+a+b+1<=N) {\n\t\tint c0 = 0, c1 = 0;\n\t\tif (S[t+a+b] == '0') c0++;\n\t\telse c1++;\n\n\t\tif (c0 || a) {\n\t\t    vis[t+1][a+c0-1][b+c1] = true;\n\t\t}\n\t\tif (c1 || b) {\n\t\t    vis[t+1][a+c0][b+c1-1] = true;\n\t\t}\n\t    }\n\n\t    if (a+b >= 2) {\n\t\tif (a) {\n\t\t    vis[t+1][a-1][b] = true;\n\t\t}\n\t\tif (b) {\n\t\t    vis[t+1][a][b-1] = true;\n\t\t}\n\t    }\n\t}\n\n\tfor (int a=t+1; a>=0; a--) for (int b=t+1; b>=0; b--) if (vis[t+1][a][b]) {\n\t    int idx = t+a+b+1;\n\t    assert(idx <= N);\n\n\t    if (a && S[t+a+b] == '0') {\n\t\tvis[t+1][a-1][b] = true;\n\t    }\n\t    if (b && S[t+a+b] == '1') {\n\t\tvis[t+1][a][b-1] = true;\n\t    }\n\n\n\t    if (idx > N) {\n\t\t// NOP;\n\t    } else if (idx < N\n\t\t    && ((S[idx] == '0' && vis[t+1][a+1][b])\n\t\t\t|| (S[idx] == '1' && vis[t+1][a][b+1]))) {\n\t\t// NOP;\n\t    } else {\n\t\t// S[idx .. N);\n\t\t//eprintf(\"erase = %d, [%s] zero:%d one:%d way:%d\\n\",\n\t\t//\tt+1, S+idx, a, b, dp[N-idx][a][b].geti());\n\t\tans += dp[N-idx][a][b];\n\n\t    }\n\t}\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD2 1000000007\n#define MOD 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nbool ok[330][330][330]; // pos one two\nInt cnt[330][330][330];\nInt exact[330][330][330];\nstring s;\n\nInt ans;\n\nint main()\n{\n    cin >> s;\n    int n = s.size();\n    for (int i = 0; i <= n; i++) {\n        for (int j = n; j >= 0; j--) {\n            for (int k = n; k >= 0; k--) {\n                if (i == 0 && j == 0 && k == 0)\n                    ok[i][j][k] = true;\n                if (i + 1 < n && (s[i] == '0' || s[i + 1] == '0')) {\n                    ok[i + 2][j + 1][k] |= ok[i][j][k];\n                }\n                if (i + 1 < n && (s[i] == '1' || s[i + 1] == '1')) {\n                    ok[i + 2][j][k + 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '0' && k > 0) {\n                    ok[i + 1][j + 1][k - 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '0' && j > 0) {\n                    ok[i + 1][j][k] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '1' && j > 0) {\n                    ok[i + 1][j - 1][k + 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '1' && k > 0) {\n                    ok[i + 1][j][k] |= ok[i][j][k];\n                }\n                if (j)\n                    ok[i][j - 1][k] |= ok[i][j][k];\n\n                if (k)\n                    ok[i][j][k - 1] |= ok[i][j][k];\n            }\n        }\n    }\n\n    exact[n][0][0] = 1;\n\n    for (int one = 0; one <= n; one++) {\n        for (int zero = 0; zero <= n; zero++) {\n            int zero_cnt = 0;\n            int one_cnt = 0;\n            for (int pos = n; pos >= 0; pos--) {\n                cnt[pos][one][zero] = 0;\n                if (one)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one - 1][zero] + exact[pos][one - 1][zero];\n                if (zero)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one][zero - 1] + exact[pos][one][zero - 1];\n                if (pos + 1 <= n) {\n                    exact[pos][one][zero] = exact[pos + 1][one][zero];\n                    if (s[pos] == '0' && one > 0) {\n                        exact[pos][one][zero] += exact[pos][one - 1][zero];\n                    }\n                    if (s[pos] == '1' && zero > 0) {\n                        exact[pos][one][zero] += exact[pos][one][zero - 1];\n                    }\n                }\n                cnt[pos][one][zero] %= MOD;\n                exact[pos][one][zero] %= MOD;\n            }\n            if (one == 0 && zero == 0)\n                continue;\n            if (ok[n][zero][one]) {\n                ans += exact[n][one][zero];\n                ans += cnt[n][one][zero];\n                ans %= MOD;\n                //                cout << zero << \" \" << one << \" \" << ans <<\n                //                endl;\n                continue;\n            }\n\n            for (int pos = n - 1; pos >= 0; pos--) {\n\n                if (s[pos] == '0')\n                    zero_cnt++;\n                else\n                    one_cnt++;\n                int need_one = one - one_cnt;\n                int need_zero = zero - zero_cnt;\n                if (need_one < 0 || need_zero < 0)\n                    break;\n                if (ok[pos][need_zero][need_one]) {\n                    ans += exact[pos][need_one][need_zero];\n                    ans += cnt[pos][need_one][need_zero];\n                    ans %= MOD;\n                    //                    cout << pos << \" \" << need_zero << \" \"\n                    //                    << need_one << \" \"\n                    //                       << ans << endl;\n\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nbool dp[305][305][305];\nll dp2[305][305][305];\nint ma[305][305];\n\nint main(void){\n    string s;\n    cin >> s;\n    int n = s.length();\n    VI a(n), sa(n + 1);\n    REP(i,n){\n        a[i] = s[i] - '0';\n        sa[i + 1] = sa[i] + a[i];\n    }\n    dp[0][0][0] = 1;\n    REP(i,n) REP(z,n+1) REP(o,n+1){\n        if (!dp[i][z][o]) continue;\n        int rz = (i - sa[i]) - z;\n        int ro = sa[i] - o;\n        if (i + 2 <= n){\n            if (a[i] + a[i + 1] == 0) dp[i + 2][z + 1][o] = 1;\n            else if (a[i] + a[i + 1] == 1) dp[i + 2][z + 1][o] = dp[i + 2][z][o + 1] = 1;\n            else dp[i + 2][z][o + 1] = 1;\n        }\n        if (rz + (a[i] == 0) > 0 && rz + ro + 1 >= 2) dp[i + 1][z + 1][o] = 1;\n        if (ro + (a[i] == 1) > 0 && rz + ro + 1 >= 2) dp[i + 1][z][o + 1] = 1;\n        if (rz > 0 && rz + ro >= 2) dp[i][z + 1][o] = 1;\n        if (ro > 0 && rz + ro >= 2) dp[i][z][o + 1] = 1;\n    }\n\n    cout << dp[2][1][0] << endl;\n\n    VVI ma(n + 1, VI(n + 1, -1));\n    REP(i,n+1) REP(j,n+1) REP(k,n+1){\n        if (!dp[i][j][k]) continue;\n        chmax(ma[j][k], i);\n    }\n\n    // REP(i,n+1) {\n    //     REP(j,n+1){\n    //         cout << ma[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    dp2[0][0][0] = 1;\n    REP(i,n+1) REP(j,n+1) REP(k,n+1){\n        if (a[n - 1 - i] == 0){\n            (dp2[i + 1][j][k] += dp[i][j][k]) %= mod;\n            (dp2[i][j][k + 1] += dp[i][j][k]) %= mod;\n        }else {\n            (dp2[i + 1][j][k] += dp[i][j][k]) %= mod;\n            (dp2[i][j + 1][k] += dp[i][j][k]) %= mod;\n        }\n    }\n\n    ll ans = 0;\n    REP(i,n+1) REP(j,n+1){\n        if (ma[i][j] == -1) continue;\n        int x = ma[i][j];\n        int o = sa[x] - i, z = (x - sa[x]) - j;\n        (ans += dp2[n - ma[i][j]][i][j]) %= mod;\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 333\n\t#define mod 998244353ll\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nll C[sz<<1][sz<<1];\n\nint n;\nchar s[sz];\nbool dp[sz][sz][sz];\nint suf[sz];\n\nint main()\n{\n\tfile();\n\trep(i,0,sz*2-1) C[i][0]=1;\n\trep(i,1,sz*2-1) rep(j,1,i) (C[i][j]=C[i-1][j]+C[i-1][j-1])%=mod;\n\tcin>>(s+1); n=strlen(s+1);\n\tdrep(i,n,1) suf[i]=suf[i+1]+(s[i]=='1');\n\tdp[0][0][0]=1;\n\trep(i,0,n-1) rep(x,0,i) rep(y,0,i-x) if (dp[i][x][y])\n\t{\n\t\tif (x) dp[i+1][x-1+(s[i+1]=='0')][y+(s[i+1]=='1')]=1;\n\t\tif (y) dp[i+1][x+(s[i+1]=='0')][y-1+(s[i+1]=='1')]=1;\n\t\tdp[i+1][x][y]=1;\n\t\tif (i==n-1) continue;\n\t\tdp[i+2][x+(s[i+1]=='0')][y+(s[i+1]=='1')]=1;\n\t\tdp[i+2][x+(s[i+2]=='0')][y+(s[i+2]=='1')]=1;\n\t}\n\tll ans=0;\n\trep(i,1,n) rep(x,0,i) rep(y,0,i-x) if (dp[i][x][y])\n\t{\n\t\tint a=suf[i],b=n-i+1-a;\n\t\t(ans+=(a==0?(!x):C[x+a-1][a-1])*(b==0?(!y):C[y+b-1][b-1])%mod)%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nll dp[333][333][333], dp2[333][333][333], used[666][666];\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    cin>>s;\n    int n=s.size();\n    string t(s.rbegin(),s.rend());\n    dp[0][0][0]=1;\n    rep(i,n+1)rep(j,301)rep(k,301){\n        if(i==0&&j==0&&k==0)continue;\n        if(i==0){\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='0'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='1'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n        }\n        dp[i][j][k]%=mod;\n    }\n    dp2[0][0][0]=1;\n    rep(i,n+1)for(int j=300;j>=0;--j)for(int k=300;k>=0;--k){\n        if(j>=2)dp2[i][j-2][k]|=dp2[i][j][k];\n        if(k>=2)dp2[i][j][k-2]|=dp2[i][j][k];\n        if(j>=1 && k>=1)dp2[i][j-1][k-1]|=dp2[i][j][k];\n        if(i<n && s[i]=='0'){\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n            if(k>0)dp2[i+1][j+1][k-1]|=dp2[i][j][k];\n        }\n        if(i<n && s[i]=='1'){\n            if(j>0)dp2[i+1][j-1][k+1]|=dp2[i][j][k];\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n        }\n        if(i+1<n){\n            if(s[i]=='0'||s[i+1]=='0')dp2[i+2][j+1][k]|=dp2[i][j][k];\n            if(s[i]=='1'||s[i+1]=='1')dp2[i+2][j][k+1]|=dp2[i][j][k];\n        }\n    }\n    ll ans=0;\n    int z=0, o=0;\n    used[0][0]=1;\n    rep(i,n+1){\n        if(i!=0){\n            if(s[n-i]=='0')z++;\n            else o++;\n        }\n        rep(j,n+1)rep(k,n+1){\n            if(dp2[n-i][j][k] && !used[z+j][o+k]){\n                ans+=dp[i][j][k];\n                used[z+j][o+k]=1;\n            }\n        }\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\nconst int maxn=305;\nconst int M=998244353;\nint n,ans;\nchar s[maxn];\nbool f[maxn][maxn][maxn],g[maxn][maxn][maxn];\nint dp[maxn][maxn][maxn];\n\nvoid add(int &x,int y){\n    x+=y; if(x>=M) x-=M;\n}\n\nint main(){\n    scanf(\"%s\",s+1); n=strlen(s+1);\n    f[0][0][0]=1;\n    for (int i=0;i<=n-1;i++)\n    for (int j=0;j<=n;j++)\n    for (int k=0;k<=n;k++) if (f[i][j][k]){\n        // x:0   y:1\n        int x=k,y=j-i-k;\n        g[n-j][x][y]=1;\n        if (i==n-1) continue;\n        if (x>=2) f[i+1][j][k-1]=1;\n        if (x>=1&&y>=1) f[i+1][j][k-1]=1,f[i+1][j][k]=1;\n        if (y>=2) f[i+1][j][k]=1;\n        if (j<n){\n            if (s[j+1]=='0'){\n                if (x>=1) f[i+1][j+1][k]=1;\n                if (y>=1) f[i+1][j+1][k]=f[i+1][j+1][k+1]=1;\n            } else {\n                if (x>=1) f[i+1][j+1][k-1]=f[i+1][j+1][k]=1;\n                if (y>=1) f[i+1][j+1][k]=1;\n            }\n        }\n        if (j<n-1){\n            int zeros=(s[j+1]=='0')+(s[j+2]=='0');\n            if (zeros==2){\n                f[i+1][j+2][k+1]=1;\n            } else if (zeros==1){\n                f[i+1][j+2][k]=f[i+1][j+2][k+1]=1;\n            } else {\n                f[i+1][j+2][k]=1;\n            }\n        }\n    }\n    for (int i=1;i<=n;i++)\n    for (int j=0;j<=n;j++)\n    for (int k=0;k<=n;k++){\n        if (s[n-i+1]=='0') g[i][j][k]|=g[i-1][j+1][k];\n        else g[i][j][k]|=g[i-1][j][k+1];\n    }\n    dp[0][0][0]=1;\n    for (int i=0;i<=n;i++)\n    for (int j=0;j<=n;j++)\n    for (int k=0;k<=n;k++){\n        if (s[n-i]=='0'){\n            add(dp[i][j][k+1],dp[i][j][k]);\n        } else if (s[n-i]=='1') {\n            add(dp[i][j+1][k],dp[i][j][k]);\n        }\n        add(dp[i+1][j][k],dp[i][j][k]);\n        if (g[i][j][k]) {\n            if (i+j+k) add(ans,dp[i][j][k]);\n            //cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 11100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nlong long dp[310][310][310];\nint req[310][310];\nint ijk[310][310][310];\nint v[310][310][310];\nchar C[310];\nint main(){\n\tscanf(\"%s\",in);\n\tint n=strlen(in);\n\tfor(int i=0;i<n;i++)C[i]=in[i];\n\treverse(C,C+n);\n\t\n\tfor(int i=0;i<310;i++)for(int j=0;j<310;j++)for(int k=0;k<310;k++)\n\t\tijk[i][j][k]=mod;\n\tijk[0][0][0]=0;\n\tpriority_queue<pair<pair<int,int>,pair<int,int> > > Q;\n\tQ.push(make_pair(make_pair(0,0),make_pair(0,0)));\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first.first;\n\t\tint C=Q.top().first.second;\n\t\tint A=Q.top().second.first;\n\t\tint B=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(v[A][B][C])continue;\n\t\tv[A][B][C]=1;\n\t\tint at=cost;\n\t\t\n\t\tif(at+2<=n){\n\t\t\tif(ijk[A][B][C+1]>cost+2){\n\t\t\t\tijk[A][B][C+1]=cost+2;\n\t\t\t\tQ.push(make_pair(make_pair(-cost-2,C+1),make_pair(A,B)));\n\t\t\t}\n\t\t\tif(in[at]=='0'||in[at+1]=='0'){\n\t\t\t\tif(ijk[A+1][B][C]>cost+2){\n\t\t\t\t\tijk[A+1][B][C]=cost+2;\n\t\t\t\t\tQ.push(make_pair(make_pair(-cost-2,C),make_pair(A+1,B)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in[at]=='1'||in[at+1]=='1'){\n\t\t\t\tif(ijk[A][B+1][C]>cost+2){\n\t\t\t\t\tijk[A][B+1][C]=cost+2;\n\t\t\t\t\tQ.push(make_pair(make_pair(-cost-2,C),make_pair(A,B+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(at+1<=n&&C){\n\t\t\tif(ijk[A][B][C-1]>cost+1){\n\t\t\t\tijk[A][B][C-1]=cost+1;\n\t\t\t\tQ.push(make_pair(make_pair(-cost-1,C-1),make_pair(A,B)));\n\t\t\t}\n\t\t\tif(in[at]=='0'){\n\t\t\t\tif(ijk[A+1][B][C-1]>cost+1){\n\t\t\t\t\tijk[A+1][B][C-1]=cost+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(-cost-1,C-1),make_pair(A+1,B)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in[at]=='1'){\n\t\t\t\tif(ijk[A][B+1][C-1]>cost+1){\n\t\t\t\t\tijk[A][B+1][C-1]=cost+1;\n\t\t\t\t\tQ.push(make_pair(make_pair(-cost-1,C-1),make_pair(A,B+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\treq[i][j]=mod;\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\treq[i][j]=min(req[i][j],ijk[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!dp[i][j][k])continue;\n\t\t\t\tif(req[j][k]+i<n){\n\t\t\t\t\tdp[i+1][j][k]=(dp[i+1][j][k]+dp[i][j][k])%mod;\n\t\t\t\t}\n\t\t\t\tif(C[i]=='1'){\n\t\t\t\t\tif(req[j+1][k]+i<=n){\n\t\t\t\t\t\tdp[i][j+1][k]=(dp[i][j+1][k]+dp[i][j][k])%mod;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(req[j][k+1]+i<=n){\n\t\t\t\t\t\tdp[i][j][k+1]=(dp[i][j][k+1]+dp[i][j][k])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++){\n\t\tret=(ret+dp[i][j][k])%mod;\n\t}\n\tret=(ret+mod-1)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n \nint main() {\n\tint n, result = 0;\n\tcin >> n;\n\tint amt = n;\n\twhile(amt % 360 != 0) {\n\t\tamt += n;\n\t\tresult++;\n\t}\n\tcout << result+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nconst uint MOD = 998244353;\nconst ull LMOD = (ull(7e18) / MOD) * MOD;\n\nconst int M = 310;\nstring s;\nint n;\nint pref[M][M];\nbool ok[3][M][M];\n\nuint dp[M][M];\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tcin >> s;\n\tn = int(s.size());\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tpref[i][j] = M;\n\t\t\t}\n\t\t}\n\t\tpref[0][0] = 0;\n\t\tint c0 = 0, c1 = 1, c2 = 2;\n\t\tok[c0][0][0] = true;\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tfor (int j = 0; i+j <= k; j++) {\n\t\t\t\t\tif (!ok[c0][i][j]) continue;\n\t\t\t\t\t// 直接扔掉\n\t\t\t\t\tok[c1][i][j] = true;\n\t\t\t\t\tif (i && s[k] == '1') {\n\t\t\t\t\t\tok[c1][i-1][j+1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (j && s[k] == '0') {\n\t\t\t\t\t\tok[c1][i+1][j-1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (k+1 < n) {\n\t\t\t\t\t\tfor (int zz = 0; zz < 2; zz++) {\n\t\t\t\t\t\t\tif (zz == s[k]-'0' || zz == s[k+1]-'0') {\n\t\t\t\t\t\t\t\tok[c2][i + (zz==0)][j + (zz==1)] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc0 = (c0+1) % 3;\n\t\t\tc1 = (c1+1) % 3;\n\t\t\tc2 = (c2+1) % 3;\n\t\t\tfor (int i = 0; i <= k+1; i++) {\n\t\t\t\tfor (int j = 0; i+j <= k+1; j++) {\n\t\t\t\t\tif (ok[c0][i][j] && pref[i][j] == M) {\n\t\t\t\t\t\tpref[i][j] = k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tull total = 0;\n\treverse(s.begin(), s.end());\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i >= 0; i--) {\n\t\t\tfor (int j = k-i; j >= 0; j--) {\n\t\t\t\tif (!dp[i][j]) continue;\n\t\t\t\tint z = s[k-i-j] - '0';\n\t\t\t\tif (z == 0) {\n\t\t\t\t\tdp[i][j+1] += dp[i][j];\n\t\t\t\t\tif (dp[i][j+1] >= MOD) dp[i][j+1] -= MOD;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\tif (dp[i+1][j] >= MOD) dp[i+1][j] -= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k+1; i++) {\n\t\t\tfor (int j = 0; i+j <= k+1; j++) {\n\t\t\t\tint rest = (k+1) - (i+j);\n\t\t\t\tif (pref[i][j] <= n-rest) {\n\t\t\t\t\ttotal += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttotal %= MOD;\n\tcout << uint(total) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 305, mod = 998244353;\nint n, dp[MX][MX][MX];\nll fac[2 * MX], inv[2 * MX], res = 1;\nstring s;\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nll comb (int n, int k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i < 2 * MX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = pot(fac[i], mod - 2);\n\t}\n\n\tcin >> s;\n\tn = s.size();\n\t\n\tdp[0][0][0] = 1;\n\n\tforn (i, n) forn (j, n) forn (k, n) if (dp[i][j][k]) {\n\t\tif (i + 1 < n) {\n\t\t\tif (s[i] == '0' || s[i + 1] == '0') dp[i + 2][j + 1][k] = 1;\n\t\t\tif (s[i] == '1' || s[i + 1] == '1') dp[i + 2][j][k + 1] = 1;\n\t\t\tdp[i + 1][j][k] = 1;\n\t\t}\n\n\t\tif (j || k) dp[i + 1][j][k] = 1;\n\t\tif (j && s[i] == '1') dp[i + 1][j - 1][k + 1] = 1;\n\t\tif (k && s[i] == '0') dp[i + 1][j + 1][k - 1] = 1;\n\t}\n\n\tfor (int i = n - 1, x = 0, y = 0; i >= 0; i--) {\n\t\tif (s[i] == '0') y++;\n\t\telse x++;\n\n\t\tforn (j, n) forn (k, n) if (dp[i + 1][j][k]) {\n\t\t\tll a = !j && !x ? 1 : comb(j + x - 1, j);\n\t\t\tll b = !k && !y ? 1 : comb(k + y - 1, k);\n\t\t\t(res += a * b) %= mod;\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\nusing namespace std;\ninline void Add(int &a,int b)\n{a+=b;a>=MOD?a-=MOD:1;}\ninline void Max(int &a,int b)\n{a<b?a=b:1;}\nconst int Q=305;\nint f[Q][Q][Q],ok[Q][Q][Q];\nchar s[Q];\nint main()\n{\n    scanf(\"%s\",s+1);\n    int n=strlen(s+1);\n    for(int i=0;i<=n;i++)\n        (s[n]=='0'?f[n+1][0][i]:f[n+1][i][0])=1;\n    for(int i=n;i;--i)\n        for(int j=0;j<i;j++)\n            for(int k=0;j+k<i;k++){\n                f[i][j][k]=f[i+1][j][k];\n                if(j&&s[i-1]=='1')Add(f[i][j][k],f[i][j-1][k]);\n                if(k&&s[i-1]=='0')Add(f[i][j][k],f[i][j][k-1]);\n            }\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            fill(ok[i][j],ok[i][j]+n+1,(int)-1e9);\n    ok[0][0][0]=ok[1][0][0]=0;\n    for(int i=2;i<=n;i++)\n        for(int j=0;j<=i;j++)\n            for(int k=0;j+k<=i;k++){\n                ok[i][j][k]=ok[i-1][j][k];\n                if(j&&s[i]=='0')Max(ok[i][j][k],ok[i-1][j-1][k]-1);\n                if(j&&min(s[i],s[i-1])=='0')Max(ok[i][j][k],ok[i-2][j-1][k]);\n                if(k&&s[i]=='1')Max(ok[i][j][k],ok[i-1][j][k-1]-1);\n                if(k&&max(s[i],s[i-1])=='1')Max(ok[i][j][k],ok[i-2][j][k-1]);\n                Max(ok[i][j][k],ok[i-2][j][k]+1);\n                if(ok[i][j][k]<0)ok[i][j][k]=-1e9;\n            }\n    int tmp=MOD-1;\n    for(int i=1;i<=n+1;i++)\n        for(int j=0;j<i;j++)\n            for(int k=0;j+k<i;k++)\n                if(ok[i-1][j][k]>=0)\n                    Add(tmp,f[i][j][k]);\n    printf(\"%d\\n\",tmp);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 305\nconst int mod=998244353;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint dp[N][N][N],n,ans;\nbool ok[N][N][N];\nchar s[N];\n#define ck(x) (x>=mod?x-mod:x)\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=0;i<n;++i){\n\t\tok[i][0][0]=true;\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=0;k+j<=i;++k){\n\t\t\t\tif(!ok[i][j][k])continue;\n\t\t\t\tif(s[i+1]=='0'||s[i+2]=='0')ok[i+2][j+1][k]=true;\n\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1')ok[i+2][j][k+1]=true;\n\t\t\t\tif(j|k)ok[i+1][j][k]=true;\n\t\t\t\tif(s[i+1]=='0'&&k)ok[i+1][j+1][k-1]=true;\n\t\t\t\tif(s[i+1]=='1'&&j)ok[i+1][j-1][k+1]=true;\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=0;k+j<=i;++k){\n\t\t\t\tconst int t=dp[i][j][k];\n\t\t\t\tif(!t)continue;\n\t\t\t\tdp[i-1][j][k]=ck(dp[i-1][j][k]+t);\n\t\t\t\tif(s[i]=='0')dp[i][j][k+1]=ck(dp[i][j][k+1]+t);\n\t\t\t\telse dp[i][j+1][k]=ck(dp[i][j+1][k]+t);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;++i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=0;k+j<=i;++k){\n\t\t\t\tif(ok[i][j][k])ans=ck(ans+dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD2 1000000007\n#define MOD 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nbool ok[330][330][330]; // pos one two\nInt cnt[330][330][330];\nInt exact[330][330][330];\nstring s;\n\nInt ans;\n\nint main()\n{\n    cin >> s;\n    int n = s.size();\n    for (int i = 0; i <= n; i++) {\n        for (int j = n; j >= 0; j--) {\n            for (int k = n; k >= 0; k--) {\n                if (i == 0 && j == 0 && k == 0)\n                    ok[i][j][k] = true;\n                if (i + 1 < n && (s[i] == '0' || s[i + 1] == '0')) {\n                    ok[i + 2][j + 1][k] |= ok[i][j][k];\n                }\n                if (i + 1 < n && (s[i] == '1' || s[i + 1] == '1')) {\n                    ok[i + 2][j][k + 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '0' && k > 0) {\n                    ok[i + 1][j + 1][k - 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '1' && j > 0) {\n                    ok[i + 1][j - 1][k + 1] |= ok[i][j][k];\n                }\n                if (j)\n                    ok[i][j - 1][k] |= ok[i][j][k];\n\n                if (k)\n                    ok[i][j][k - 1] |= ok[i][j][k];\n            }\n        }\n    }\n\n    exact[n][0][0] = 1;\n\n    for (int one = 0; one <= n; one++) {\n        for (int zero = 0; zero <= n; zero++) {\n            int zero_cnt = 0;\n            int one_cnt = 0;\n            for (int pos = n; pos >= 0; pos--) {\n                cnt[pos][one][zero] = 0;\n                if (one)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one - 1][zero] + exact[pos][one - 1][zero];\n                if (zero)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one][zero - 1] + exact[pos][one][zero - 1];\n                if (pos + 1 <= n) {\n                    exact[pos][one][zero] = exact[pos + 1][one][zero];\n                    if (s[pos] == '0' && one > 0) {\n                        exact[pos][one][zero] += exact[pos][one - 1][zero];\n                    }\n                    if (s[pos] == '1' && zero > 0) {\n                        exact[pos][one][zero] += exact[pos][one][zero - 1];\n                    }\n                }\n                cnt[pos][one][zero] %= MOD;\n                exact[pos][one][zero] %= MOD;\n            }\n            if (one == 0 && zero == 0)\n                continue;\n            if (ok[n][zero][one]) {\n                ans += exact[n][one][zero];\n                ans += cnt[n][one][zero];\n                ans %= MOD;\n                //                cout << zero << \" \" << one << \" \" << ans <<\n                //                endl;\n                continue;\n            }\n\n            for (int pos = n - 1; pos >= 0; pos--) {\n\n                if (s[pos] == '0')\n                    zero_cnt++;\n                else\n                    one_cnt++;\n                int need_one = one - one_cnt;\n                int need_zero = zero - zero_cnt;\n                if (need_one < 0 || need_zero < 0)\n                    break;\n                if (ok[pos][need_zero][need_one]) {\n                    ans += exact[pos][need_one][need_zero];\n                    ans += cnt[pos][need_one][need_zero];\n                    ans %= MOD;\n                    //                    cout << pos << \" \" << need_zero << \" \"\n                    //                    << need_one << \" \"\n                    //                       << ans << endl;\n\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nstring S;\nint N;\nconst ll mo=998244353;\n\nint NS[303][2]={};\n\nset<pair<int,int>> pat[303];\nset<pair<int,int>> del[303];\n\nll dp[303][303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\t\n\tFOR(i,N) {\n\t\tNS[i+1][0]=NS[i][0];\n\t\tNS[i+1][1]=NS[i][1];\n\t\tNS[i+1][S[i]-'0']++;\n\t}\n\t\n\tpat[0].insert({0,0});\n\tFOR(i,N) {\n\t\tif(i) {\n\t\t\tFORR(p,pat[i]) pat[i+1].insert(p);\n\t\t}\n\t\t\n\t\tFOR(j,2) {\n\t\t\tfor(int len=2;i+len<=N;len++) {\n\t\t\t\tif(NS[i+len][j]-NS[i][j]) {\n\t\t\t\t\tif(j==0) {\n\t\t\t\t\t\tFORR(p,pat[i]) pat[i+len].insert({p.first+1,p.second});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tFORR(p,pat[i]) pat[i+len].insert({p.first,p.second+1});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[0][0][0]=1;\n\tfor(i=N;i>=1;i--) {\n\t\tFORR(p,del[i]) {\n\t\t\tif(S[i-1]=='0' && p.first) {\n\t\t\t\tpat[i-1].erase({p.first-1,p.second});\n\t\t\t\tdel[i-1].insert({p.first-1,p.second});\n\t\t\t}\n\t\t\tif(S[i-1]=='1' && p.second) {\n\t\t\t\tpat[i-1].erase({p.first,p.second-1});\n\t\t\t\tdel[i-1].insert({p.first,p.second-1});\n\t\t\t}\n\t\t}\n\t\tFORR(p,pat[i]) {\n\t\t\tif(S[i-1]=='0' && p.first) {\n\t\t\t\tpat[i-1].erase({p.first-1,p.second});\n\t\t\t\tdel[i-1].insert({p.first-1,p.second});\n\t\t\t}\n\t\t\tif(S[i-1]=='1' && p.second) {\n\t\t\t\tpat[i-1].erase({p.first,p.second-1});\n\t\t\t\tdel[i-1].insert({p.first,p.second-1});\n\t\t\t}\n\t\t\tdp[i][p.first][p.second]++;\n\t\t}\n\t}\n\t\n\t\n\tFOR(i,N) {\n\t\tif(S[i]=='0') {\n\t\t\tFOR(y,N+1) for(x=N;x>=1;x--) (dp[i][y][x-1]+=dp[i][y][x])%=mo;\n\t\t}\n\t\telse {\n\t\t\tFOR(y,N+1) for(x=N;x>=1;x--) (dp[i][x-1][y]+=dp[i][x][y])%=mo;\n\t\t}\n\t\tFOR(y,N+1) {\n\t\t\tFOR(x,N+1) (dp[i+1][x][y]+=dp[i][x][y])%=mo;\n\t\t}\n\t}\n\tfor(int t=N;t>=0;t--) FOR(x,t+1) {\n\t\ty=t-x;\n\t\tif(x) (dp[N][x-1][y]+=dp[N][x][y])%=mo;\n\t\tif(y) (dp[N][x][y-1]+=dp[N][x][y])%=mo;\n\t\t\n\t}\n\tcout<<dp[N][0][0]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353, N = 303;\n\nbool can[N][N][N];\nlong long dp[N][N][N];\n\n\nvoid add(long long & var, long long val) {\n  var += val;\n  if (var >= mod)\n    var -= mod;\n}\n\nchar s[N];\n\nint main() {\n  scanf(\"%s\", s);\n  int n = strlen(s);\n  int one = 0;\n  for (int i = 0; i < n; ++i)\n    one += s[i] == '1';\n  int zero = n - one;\n  queue<tuple<int, int, int>> que;\n  \n  auto check = [&](int x, int y, int z) {\n    if (can[x][y][z]) {\n      return;\n    }\n    can[x][y][z] = true;\n    que.emplace(x, y, z);\n  };\n\n  check(0, 0, 0);\n  while (!que.empty()) {\n    int i, j, k;\n    tie(i, j, k) = que.front();\n    que.pop();\n    if (i+1 <= n) {\n      if (j) {\n        check(i+1, j - 1 + (s[i] == '0'), k + (s[i] == '1'));\n      }\n      if (k) {\n        check(i+1, j + (s[i] == '0'), k - 1 + (s[i] == '1'));\n      }\n    }\n    if (j+k > 1) {\n      if (j)\n        check(i, j-1, k);\n      if (k)\n        check(i, j, k-1);\n    }\n    if (i + 2 <= n) {\n      check(i+2, j + (s[i] == '0'), k + (s[i] == '1'));\n      check(i+2, j + (s[i+1] == '0'), k + (s[i+1] == '1'));\n    }\n    if (i > 0) {\n      if (j && s[i-1] == '0')\n        check(i-1, j-1, k);\n      if (k && s[i-1] == '1')\n        check(i-1, j, k-1);\n    }\n  }\n  dp[n][0][0] = 1;\n  long long ans = 1;\n  for (int i = n; i >= 1; --i) {\n    char c = s[i-1];\n    for (int j = 0; j <= zero; ++j) {\n      for (int k = 0; k <= one; ++k) {\n        // cerr << i << \" \" << j << \" \" << k << \" \" << (int)can[i][j][k] << \" \" << dp[i][j][k] << endl;\n        if (dp[i][j][k] == 0) continue;\n        if (c == '1') {\n          add(dp[i][j+1][k], dp[i][j][k]);\n        } else {\n          add(dp[i][j][k+1], dp[i][j][k]);\n        }\n        add(dp[i-1][j][k], dp[i][j][k]);\n        if (can[i][j][k]) {\n          // cerr << i << \" \" << j << \" \" << k << \" \" << \" \" << dp[i][j][k] << endl;\n          add(ans, dp[i][j][k]);\n        }\n      }\n    }\n  }\n  ans %= mod;\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 310;\nconst int moder = 998244353;\nconst int INF = 0x3f3f'3f3f;\n\nchar s[N];\nbool dp[N][N][N];\nint dp1[N][N][N];\nint comb[N][N];\nint suf[N];\nint pre[N][N][N];\nint min[N][N];\n\nvoid add(int &a, int b){\n    a += b, a -= a >= moder ? moder : 0;\n}\n\nint main(){\n    for (int i = 0; i < N; ++ i){\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; ++ j){\n            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % moder;\n        }\n    }\n    scanf(\"%s\", s);\n    int n = strlen(s);\n    dp[n][0][0] = true;\n    for (int i = n; i >= 2; -- i){\n        for (int j = 0; j < N; ++ j){\n            for (int k = 0; k < N; ++ k){\n                if (!dp[i][j][k]){\n                    continue;\n                }\n                int len = i - j - k;\n                int front = s[n - len] - '0';\n                int s_front = s[n - len + 1] - '0';\n                if (j >= 2){\n                    dp[i - 1][j - 1][k] = true;\n                }\n                if (j >= 1 && k >= 1){\n                    dp[i - 1][j - 1][k] = true;\n                    dp[i - 1][j][k - 1] = true;\n                }\n                if (k >= 2){\n                    dp[i - 1][j][k - 1] = true;\n                }\n                if (len >= 1){\n                    if (j >= 1){\n                        dp[i - 1][j][k] = true;\n                        dp[i - 1][j - 1 + (front == 0)][k + (front == 1)] = true;\n                    }\n                    if (k >= 1){\n                        dp[i - 1][j][k] = true;\n                        dp[i - 1][j + (front == 0)][k - 1 + (front == 1)] = true;\n                    }\n                }\n                if (len >= 2){\n                    dp[i - 1][j + (front == 0)][k + (front == 1)] = true;\n                    dp[i - 1][j + (s_front == 0)][k + (s_front == 1)] = true;\n                }\n            }\n        }\n    }\n    dp1[0][0][0] = 1;\n    for (int i = 0; i <= n; ++ i){\n        for (int j = 0; j <= n; ++ j){\n            for (int k = 0; k <= n; ++ k){\n                if (dp1[i][j][k] == 0){\n                    continue;\n                }\n                if (k < n && s[n - 1 - k] == '0'){\n                    add(dp1[i + 1][j][k + 1], dp1[i][j][k]);\n                }\n                else{\n                    add(dp1[i + 1][j][k], dp1[i][j][k]);\n                }\n                if (k < n && s[n - 1 - k] == '1'){\n                    add(dp1[i][j + 1][k + 1], dp1[i][j][k]);\n                }\n                else{\n                    add(dp1[i][j + 1][k], dp1[i][j][k]);\n                }\n            }\n        }\n    }\n    for (int i = n - 1; i >= 0; -- i){\n        suf[i] = suf[i + 1] + (s[i] == '0');\n    }\n    for (int i = 0; i < N; ++ i){\n        for (int j = 0; j < N; ++ j){\n            for (int k = n; k >= 0; -- k){\n                pre[i][j][k] = pre[i][j][k + 1];\n                add(pre[i][j][k], dp1[i][j][k]);\n            }\n        }\n    }\n    memset(min, 0x3f, sizeof(min));\n    for (int i = n; i >= 1; -- i){\n        for (int j = 0; j < N; ++ j){\n            for (int k = 0; k < N; ++ k){\n                if (dp[i][j][k]){\n                    int len = i - j - k;\n                    int zero = j + suf[n - len];\n                    int one = k + len - suf[n - len];\n                    min[zero][one] = std::min(min[zero][one], len);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < N; ++ i){\n        for (int j = 0; j < N; ++ j){\n            if (min[i][j] == INF){\n                continue;\n            }\n            add(ans, pre[i][j][min[i][j]]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 210;\n\ntypedef long long ll;\nconst int mod = 998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nint g[N][N][N],f[N][N][N],n;\n// j zeros to add, k ones to add;\nchar s[N];\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);reverse(s+1,s+n+1);\n\ts[n+1]='2';\n\tf[0][0][0]=g[0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tfor(int k=0;j+k<=i;k++){\n//\t\t\t\tf[i][j][k]=add(f[i][j][k], g[i][j][k]);\n\t\t\t\tif(g[i][j][k]){\n\t\t\t\t\tint _d=i-j-k+1;\n\t\t\t\t\tint dir=s[_d]-'0';\n\t\t\t\t\tg[i+1][j][k]=add(g[i][j][k],g[i+1][j][k]);\n\t\t\t\t\tif(dir)g[i+1][j+1][k]=add(g[i+1][j+1][k],g[i][j][k]);\n\t\t\t\t\telse g[i+1][j][k+1]=add(g[i+1][j][k+1],g[i][j][k]);\n\t\t\t\t}\n\t\t\t\t/*-------*/\n\t\t\t}\n\t\t}\n\t}\n\n\tf[n][0][0]=1;\n\tfor(int i=n-1;i;i--){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tfor(int k=0;j+k<=i;k++){\n\t\t\t\tint dir=s[i-j-k+1]-'0';\n\t\t\t\tint dir2=s[i-j-k+2]-'0';\n//\t\t\t\tassert(dir>=0&&dir<=1&&dir2>=0&&dir2<=1);\n//\t\t\t\tcerr << dir << \" \" << dir2 << endl;\n\t\t\t\tint nt[3];\n\t\t\t\tnt[0]=j,nt[1]=k,nt[2]=0;\n\t\t\t\tnt[0]++;\n\t\t\t\tif(nt[dir]){\n\t\t\t\t\tnt[dir]--;\n\t\t\t\t\tif(nt[dir2]&&(dir2==0||dir==0))nt[dir2]--;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]|=f[i+1][nt[0]][nt[1]];\n//\t\t\t\tcerr << nt[0] << \" \" << nt[1] << \",\";\n\t\t\t\tnt[0]=j,nt[1]=k;\n\t\t\t\tnt[1]++;\n\t\t\t\tif(nt[dir]){\n\t\t\t\t\tnt[dir]--;\n\t\t\t\t\tif(nt[dir2]&&(dir2==1||dir==1))nt[dir2]--;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]|=f[i+1][nt[0]][nt[1]];\n//\t\t\t\tcerr << nt[0] << \" \" << nt[1] << endl;\n//\t\t\t\tcerr << i << \" \" << j << \" \" << k << \"|\" << f[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++)for(int k=0;k+j<=i;k++){\n\t\t\tif(f[i][j][k]){\n//\t\t\t\tcerr << i << \" \" << j << \" \" << k << \" \" << g[i][j][k] << endl;\n\t\t\t\tans=add(ans, g[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\nbool dp[MAX][MAX][MAX];\nll dp2[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    int N=si(S);\n    dp[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]==0) continue;\n                \n                if(i+1<N){\n                    if(S[i]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    if(S[i+1]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    dp[i+1][j][k]=1;\n                }\n                \n                if(j&&S[i]=='1') dp[i+1][j-1][k+1]=1;\n                \n                if(k&&S[i]=='0') dp[i+1][j+1][k-1]=1;\n                \n                if(j||k) dp[i+1][j][k]=1;\n            }\n        }\n    }\n    \n    reverse(all(S));\n    \n    dp2[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(S[i]=='0'){\n                    dp2[i][j][k+1]+=dp2[i][j][k];\n                    dp2[i][j][k+1]%=mod;\n                }else{\n                    dp2[i][j+1][k]+=dp2[i][j][k];\n                    dp2[i][j+1][k]%=mod;\n                }\n                dp2[i+1][j][k]+=dp2[i][j][k];\n                dp2[i+1][j][k]%=mod;\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]){\n                    ans+=dp2[N-i][j][k];\n                    ans%=mod;\n                }\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool can[330][330][330];\nMint dp[330][330][330];\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   string S; cin >> S;\n   int N = S.size();\n   for (int i = 0; i < N; ++i) {\n      can[i][0][0] = true;\n      for (int n0 = 0; n0 <= i; ++n0) {\n         for (int n1 = 0; n1 <= i; ++n1) {\n            if (!can[i][n0][n1]) continue;\n            if (i) can[i + 1][n0][n1] = true;\n            if (n0) {\n               int nn0 = n0 - 1 + (S[i] == '0');\n               int nn1 = n1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (n1) {\n               int nn0 = n0 + (S[i] == '0');\n               int nn1 = n1 - 1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (i + 1 < N) {\n               can[i + 2][n0 + (S[i] == '0')][n1 + (S[i] == '1')] = true;\n               can[i + 2][n0 + (S[i + 1] == '0')][n1 + (S[i + 1] == '1')] = true;\n            }\n         }\n      }\n   }\n   Mint ans = 0;\n   dp[N][0][0] = 1;\n   for (int i = N; i >= 0; --i) {\n      for (int n0 = 0; n0 <= N; ++n0) {\n         for (int n1 = 0; n1 <= N; ++n1) {\n            if (dp[i][n0][n1].val == 0) continue;\n            if (can[i][n0][n1]) ans += dp[i][n0][n1];\n\n            if (i > 0 && S[i - 1] == '0') {\n               dp[i - 1][n0][n1] += dp[i][n0][n1];\n            } else {\n               dp[i][n0 + 1][n1] += dp[i][n0][n1];\n            }\n\n            if (i > 0 && S[i - 1] == '1') {\n               dp[i - 1][n0][n1] += dp[i][n0][n1];\n            } else {\n               dp[i][n0][n1 + 1] += dp[i][n0][n1];\n            }\n         }\n      }\n   }\n   cout << ans - 1 << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\n#define all(v) v.begin(),v.end()\nusing namespace std;\nconst int mo=998244353;\nconst int N=305;\nchar s[N];\nint n,s0,s1;\nint f[N][N][N];\nint g[N][N][N];\nvoid UPD(int &x,int y){\n\t(x+=y)>=mo?x-=mo:233;\n}\nvoid initF(){\n\tf[0][0][0]=1;\n\tFor(i,0,n-1) For(v1,0,s0) For(v2,0,s1){\n\t\tif (!f[i][v1][v2]) continue;\n\t\tif (i+2<=n){\n\t\t\tif (s[i+1]=='0'||s[i+2]=='0') f[i+2][v1+1][v2]=1;\n\t\t\tif (s[i+1]=='1'||s[i+2]=='1') f[i+2][v1][v2+1]=1;\n\t\t}\n\t\tif (v1||v2) f[i+1][v1][v2]=1;\n\t\tif (s[i+1]=='0'&&v2) f[i+1][v1+1][v2-1]=1;\n\t\tif (s[i+1]=='1'&&v1) f[i+1][v1-1][v2+1]=1;\n\t}\n\tFor(i,1,n) For(v1,0,s0) For(v2,0,s1)\n\t\tif (f[i][v1][v2]){\n\t\t\tif (v1&&s[i]=='0') f[i-1][v1-1][v2]=0;\n\t\t\tif (v2&&s[i]=='1') f[i-1][v1][v2-1]=0;\n\t\t}\n}\nvoid initG(){\n\tg[n+1][0][0]=1;\n\tRep(i,n+1,1) For(v1,0,s0) For(v2,0,s1){\n\t\tif (!g[i][v1][v2]) continue;\n\t\tint v=g[i][v1][v2];\n\t\tif (s[i-1]!='0') UPD(g[i][v1+1][v2],v);\n\t\tif (s[i-1]!='1') UPD(g[i][v1][v2+1],v);\n\t\tUPD(g[i-1][v1][v2],v);\n\t}\n\tFor(i,1,n+1){\n\t\tRep(v1,s0,0) Rep(v2,s1,0){\n\t\t\tint v=g[i][v1][v2];\n\t\t\tif (s[i-1]!='0') UPD(g[i][v1+1][v2],mo-v);\n\t\t\tif (s[i-1]!='1') UPD(g[i][v1][v2+1],mo-v);\n\t\t}\n\t\tFor(v1,0,s0) For(v2,0,s1){\n\t\t\tint v=g[i][v1][v2];\n\t\t\tUPD(g[i][v1+1][v2],v);\n\t\t\tUPD(g[i][v1][v2+1],v);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tFor(i,1,n) s[i]=='0'?++s0:++s1;\n\tinitF();\n\tinitG();\n\tint ans=0;\n\tFor(i,0,n) For(v1,0,s0) For(v2,0,s1)\n\t\tif (f[i][v1][v2]) UPD(ans,g[i+1][v1][v2]);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define __iostream_untie__ true\n#include <bits/stdc++.h>\n#include <ext/rope>\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(__iostream_untie__) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n\n#ifndef modint_hpp\n#define modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\n#endif // modint_hpp\n\n#ifndef binomial_hpp\n#define binomial_hpp\n\nnamespace binomial\n{\n    constexpr int mod = //*\n                        998244353\n                        /*/\n                        1000000007\n                        /**/;\n    constexpr int size = 1 << 20;\n    using mint = modint<mod>;\n    namespace\n    {\n        namespace internal_helper\n        {\n            struct fact_impl\n            {\n                int _fact[size], _inv[size], _invfact[size];\n                fact_impl() : _fact{1}, _inv{0, 1}, _invfact{1}\n                {\n                    for(int i = 1; i < size; ++i) _fact[i] = (long long)_fact[i - 1] * i % mod;\n                    for(int i = 2; i < size; ++i) _inv[i] = mod - (long long)mod / i * _inv[mod % i] % mod;\n                    for(int i = 1; i < size; ++i) _invfact[i] = (long long)_invfact[i - 1] * _inv[i] % mod;\n                }\n            } fact_calced;\n        } // namespace internal_helper\n        mint fact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._fact[x]; }\n        mint invfact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._invfact[x]; }\n        mint inv(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._inv[x]; }\n    } // unnamed namespace\n    mint binom(int n, int k) noexcept { return fact(n) * invfact(k) * invfact(n - k); }\n    mint fallfact(int n, int k) noexcept { return fact(n) * invfact(n - k); }\n    mint risefact(int n, int k) noexcept { return fallfact(n + k - 1, k); }\n    // time complexity: O(min(n, k) * log(n))\n    mint stirling_2nd(int n, int k) noexcept\n    {\n        if(n < k) return 0;\n        mint res{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n            if(i & 1) res -= mint::pow(j, n) * invfact(j) * invfact(i);\n            else res += mint::pow(j, n) * invfact(j) * invfact(i);\n        return res;\n    };\n    // time complexity: O(min(n, k) * log(n))\n    mint bell(int n, int k) noexcept\n    {\n        if(n < k) k = n;\n        mint res{}, alt{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n        {\n            if(i & 1) alt -= invfact(i);\n            else alt += invfact(i);\n            res += alt * mint::pow(j, n) * invfact(j);\n        }\n        return res;\n    }\n    namespace internal_helper {} // namespace internal_helper\n} // namespace binomial\n\n#endif // binomial_hpp\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n        using namespace binomial;\n\n        string s; cin>>s;\n        int n=s.size();\n\n        bool dp[334][334][334]={};\n        dp[0][0][0]=1;\n\n        for(int i=0; i<n; i++)\n        {\n            if(s[i]=='0' or (i<n-1 and s[i+1]=='0'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j+1][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='1' or (i<n-1 and s[i+1]=='1'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j][k+1]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='0')\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=1; k<n; k++)\n                    {\n                        dp[i+1][j+1][k-1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=1; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+1][j-1][k+1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>0; j--)\n            {\n                for(int k=n; k>=0; k--)\n                {\n                    dp[i][j-1][k]|=dp[i][j][k];\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>=0; j--)\n            {\n                for(int k=n; k>0; k--)\n                {\n                    dp[i][j][k-1]|=dp[i][j][k];\n                }\n            }\n        }\n\n\n        vector dp2(334, vector(334, vector<mint>(334)));\n        for(int i=0; i<=n; i++)\n        {\n            dp2[n][i][0]=1;\n            dp2[n][0][i]=1;\n        }\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=1; j<=n; j++)\n            {\n                dp2[n][i][j]=dp2[n][i-1][j]+dp2[n][i][j-1];\n            }\n        }\n\n        for(int i=n-1; i>=0; i--)\n        {\n            auto &now=dp2[i];\n            now=dp2[i+1];\n            if(s[i]=='0')\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j][k+1]+=now[j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j+1][k]+=now[j][k];\n                    }\n                }\n            }\n        }\n\n\n        bool calced[334][334]={};\n        mint ans;\n\n        for(int i=n,oc=0,zc=0; i>=0; i--)\n        {\n            if(i<n)\n            {\n                if(s[i]=='0') zc++;\n                else oc++;\n            }\n            for(int j=0; j<=n; j++)\n            {\n                for(int k=0; k<=n; k++)\n                {\n                    if(dp[i][j][k] and !calced[j+zc][k+oc])\n                    {\n                        dump(i,j+zc,k+oc,dp2[i][j][k]);\n                        ans+=dp2[i][j][k];\n                        calced[j+zc][k+oc]=true;\n                    }\n                }\n            }\n        }\n\n        cout << ans-1 << \"\\n\";\n\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=998244353;\nint f[305][305][305];bool flag[305][305][305];\nvoid add(int &x,int y){\n\tx=(x+y)%mod;\n}\nchar s[305];\nsigned main(){\n\tcin>>(s+1);\n\tint n=strlen(s+1);\n\tf[n][0][0]=1;\n\tfor(int i=n;i>=1;--i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\tfor(int k=0;j+k<=i;++k)\n\t\t\t\tif(f[i][j][k]){\n\t\t\t\t\tadd(f[i-1][j][k],f[i][j][k]);\n\t\t\t\t\tif(s[i]=='0') add(f[i][j][k+1],f[i][j][k]);\n\t\t\t\t\telse add(f[i][j+1][k],f[i][j][k]);\n\t\t\t\t}\n\tfor(int i=0;i<n;++i){\n\t\tflag[i][0][0]=1;\n\t\tfor(int j=0;j<=i;++j)\n\t\t\tfor(int k=0;j+k<=i;++k)\n\t\t\t\tif(flag[i][j][k]){\n\t\t\t\t\tflag[i+1][j][k]=1;\n\t\t\t\t\tif(s[i+1]=='0' || s[i+2]=='0') flag[i+2][j+1][k]=1;\n\t\t\t\t\tif(s[i+1]=='1' || s[i+2]=='1') flag[i+2][j][k+1]=1;\n\t\t\t\t\tif(s[i+1]=='0' && k) flag[i+1][j+1][k-1]=1;\n\t\t\t\t\tif(s[i+1]=='1' && j) flag[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t}\n\tflag[n][0][0]=0;\n\tint ans=0;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\tfor(int k=0;j+k<=i;++k)\n\t\t\t\tif(flag[i][j][k]) add(ans,f[i][j][k]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305;\nconst long long mod = 998244353ll;\n\nint n;\nbool f[N][N][N];\nlong long g[N][N][N], ans = 0ll;\nchar str[N];\n\nint main () {\n\tscanf(\"%s\", str), n = strlen(str);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tfor (int k = 0; k <= i - j; k++) f[i][j][k] = false;\n\t\t}\n\t}\n\tf[0][0][0] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i; j >= 0; j--) {\n\t\t\tfor (int k = i - j; k >= 0; k--) {\n\t\t\t\tif (!f[i][j][k]) continue;\n\t\t\t\tif (i < n - 1) {\n\t\t\t\t\tif (str[i] == '0' || str[i + 1] == '0') f[i + 2][j + 1][k] = true;\n\t\t\t\t\tif (str[i] == '1' || str[i + 1] == '1') f[i + 2][j][k + 1] = true;\n\t\t\t\t}\n\t\t\t\tif (j && j + k >= 2) f[i][j - 1][k] = true;\n\t\t\t\tif (k && j + k >= 2) f[i][j][k - 1] = true;\n\t\t\t\tif (j + k) f[i + 1][j][k] = true;\n\t\t\t\tif (j && str[i] == '1') f[i + 1][j - 1][k + 1] = true;\n\t\t\t\tif (k && str[i] == '0') f[i + 1][j + 1][k - 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int k = 0; k <= n - j; k++) g[i][j][k] = 0ll;\n\t\t}\n\t}\n\tg[n + 1][0][0] = 1ll;\n\tfor (int i = n + 1; i > 1; i--) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int k = 0; k < n - j; k++) {\n\t\t\t\tif (str[i - 2] == '0') {\n\t\t\t\t\tg[i - 1][j + 1][k] = (g[i - 1][j + 1][k] + g[i][j][k]) % mod;\n\t\t\t\t\tg[i][j][k + 1] = (g[i][j][k + 1] + g[i][j][k]) % mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tg[i - 1][j][k + 1] = (g[i - 1][j][k + 1] + g[i][j][k]) % mod;\n\t\t\t\t\tg[i][j + 1][k] = (g[i][j + 1][k] + g[i][j][k]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= n - i; j++) {\n\t\t\tbool flag = false;\n\t\t\tlong long tmp = 0ll;\n\t\t\tint zero = 0, one = 0;\n\t\t\tfor (int k = n + 1; k; k--) {\n\t\t\t\tif (k <= n) {\n\t\t\t\t\tif (str[k - 1] == '0') zero++;\n\t\t\t\t\telse one++;\n\t\t\t\t}\n\t\t\t\tif (i - zero >= 0 && j - one >= 0 && f[k - 1][i - zero][j - one]) flag = true;\n\t\t\t\tif (flag) {\n\t\t\t\t\ttmp = (tmp + g[k][i][j]) % mod;\n\t\t\t\t\tans = (ans + g[k][i][j]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k+j<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool can[330][330][330];\nMint dp[330][330][330];\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   string S; cin >> S;\n   int N = S.size();\n   for (int i = 0; i < N; ++i) {\n      can[i][0][0] = true;\n      for (int n0 = 0; n0 <= i; ++n0) {\n         for (int n1 = 0; n1 <= i; ++n1) {\n            if (!can[i][n0][n1]) continue;\n            if (i) can[i + 1][n0][n1] = true;\n            if (n0) {\n               int nn0 = n0 - 1 + (S[i] == '0');\n               int nn1 = n1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (n1) {\n               int nn0 = n0 + (S[i] == '0');\n               int nn1 = n1 - 1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (i + 1 < N) {\n               can[i + 2][n0 + (S[i] == '0')][n1 + (S[i] == '1')] = true;\n               can[i + 2][n0 + (S[i + 1] == '0')][n1 + (S[i + 1] == '1')] = true;\n            }\n         }\n      }\n   }\n   can[N][0][0] = false;\n   Mint ans = 0;\n   dp[N][0][0] = 1;\n   for (int i = N; i >= 0; --i) {\n      for (int n0 = 0; n0 <= N; ++n0) {\n         for (int n1 = 0; n1 <= N; ++n1) {\n             if (dp[i][n0][n1].val == 0) continue;\n             //cout<<i<<' '<<n1<<' '<<n0<<' '<<dp[i][n0][n1].val<<endl;\n            if (can[i][n0][n1])\n            {\n                ans += dp[i][n0][n1];\n            }\n            if (i>0)\n            {\n                dp[i-1][n0][n1]+=dp[i][n0][n1];\n                if(S[i - 1] == '1')\n                    dp[i][n0 + 1][n1] += dp[i][n0][n1];\n                else dp[i][n0][n1 + 1] += dp[i][n0][n1];\n            }\n         }\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n/*\n000110\n6 0 0 1\n6 1 0 1\n6 2 0 1\n6 3 0 1\n6 4 0 1\n6 5 0 1\n6 6 0 1\n5 0 0 1\n5 1 0 1\n5 2 0 1\n5 3 0 1\n5 4 0 1\n5 5 0 1\n5 6 0 1\n5 0 1 1\n5 1 1 1\n5 2 1 1\n5 3 1 1\n5 4 1 1\n5 5 1 1\n5 6 1 1\n5 0 2 1\n5 1 2 1\n5 2 2 1\n5 3 2 1\n5 4 2 1\n5 5 2 1\n5 6 2 1\n5 0 3 1\n5 1 3 1\n5 2 3 1\n5 3 3 1\n5 4 3 1\n5 5 3 1\n5 6 3 1\n5 0 4 1\n5 1 4 1\n5 2 4 1\n5 3 4 1\n5 4 4 1\n5 5 4 1\n5 6 4 1\n5 0 5 1\n5 1 5 1\n5 2 5 1\n5 3 5 1\n5 4 5 1\n5 5 5 1\n5 6 5 1\n5 0 6 1\n5 1 6 1\n5 2 6 1\n5 3 6 1\n5 4 6 1\n5 5 6 1\n5 6 6 1\n4 0 0 1\n4 1 0 1\n4 2 0 1\n4 3 0 1\n4 4 0 1\n4 5 0 1\n4 6 0 1\n4 0 1 2\n4 1 1 2\n4 2 1 2\n4 3 1 2\n4 4 1 2\n4 5 1 2\n4 6 1 2\n4 0 2 3\n4 1 2 3\n4 2 2 3\n4 3 2 3\n4 4 2 3\n4 5 2 3\n4 6 2 3\n4 0 3 4\n4 1 3 4\n4 2 3 4\n4 3 3 4\n4 4 3 4\n4 5 3 4\n4 6 3 4\n4 0 4 5\n4 1 4 5\n4 2 4 5\n4 3 4 5\n4 4 4 5\n4 5 4 5\n4 6 4 5\n4 0 5 6\n4 1 5 6\n4 2 5 6\n4 3 5 6\n4 4 5 6\n4 5 5 6\n4 6 5 6\n4 0 6 7\n4 1 6 7\n4 2 6 7\n4 3 6 7\n4 4 6 7\n4 5 6 7\n4 6 6 7\n3 0 0 1\n3 1 0 2\n3 2 0 3\n3 3 0 4\n3 4 0 5\n3 5 0 6\n3 6 0 7\n3 0 1 2\n3 1 1 4\n3 2 1 6\n3 3 1 8\n3 4 1 10\n3 5 1 12\n3 6 1 14\n3 0 2 3\n3 1 2 6\n3 2 2 9\n3 3 2 12\n3 4 2 15\n3 5 2 18\n3 6 2 21\n3 0 3 4\n3 1 3 8\n3 2 3 12\n3 3 3 16\n3 4 3 20\n3 5 3 24\n3 6 3 28\n3 0 4 5\n3 1 4 10\n3 2 4 15\n3 3 4 20\n3 4 4 25\n3 5 4 30\n3 6 4 35\n3 0 5 6\n3 1 5 12\n3 2 5 18\n3 3 5 24\n3 4 5 30\n3 5 5 36\n3 6 5 42\n3 0 6 7\n3 1 6 14\n3 2 6 21\n3 3 6 28\n3 4 6 35\n3 5 6 42\n3 6 6 49\n2 0 0 1\n2 1 0 3\n2 2 0 6\n2 3 0 10\n2 4 0 15\n2 5 0 21\n2 6 0 28\n2 0 1 2\n2 1 1 6\n2 2 1 12\n2 3 1 20\n2 4 1 30\n2 5 1 42\n2 6 1 56\n2 0 2 3\n2 1 2 9\n2 2 2 18\n2 3 2 30\n2 4 2 45\n2 5 2 63\n2 6 2 84\n2 0 3 4\n2 1 3 12\n2 2 3 24\n2 3 3 40\n2 4 3 60\n2 5 3 84\n2 6 3 112\n2 0 4 5\n2 1 4 15\n2 2 4 30\n2 3 4 50\n2 4 4 75\n2 5 4 105\n2 6 4 140\n2 0 5 6\n2 1 5 18\n2 2 5 36\n2 3 5 60\n2 4 5 90\n2 5 5 126\n2 6 5 168\n2 0 6 7\n2 1 6 21\n2 2 6 42\n2 3 6 70\n2 4 6 105\n2 5 6 147\n2 6 6 196\n1 0 0 1\n1 1 0 4\n1 2 0 10\n1 3 0 20\n1 4 0 35\n1 5 0 56\n1 6 0 84\n1 0 1 2\n1 1 1 8\n1 2 1 20\n1 3 1 40\n1 4 1 70\n1 5 1 112\n1 6 1 168\n1 0 2 3\n1 1 2 12\n1 2 2 30\n1 3 2 60\n1 4 2 105\n1 5 2 168\n1 6 2 252\n1 0 3 4\n1 1 3 16\n1 2 3 40\n1 3 3 80\n1 4 3 140\n1 5 3 224\n1 6 3 336\n1 0 4 5\n1 1 4 20\n1 2 4 50\n1 3 4 100\n1 4 4 175\n1 5 4 280\n1 6 4 420\n1 0 5 6\n1 1 5 24\n1 2 5 60\n1 3 5 120\n1 4 5 210\n1 5 5 336\n1 6 5 504\n1 0 6 7\n1 1 6 28\n1 2 6 70\n1 3 6 140\n1 4 6 245\n1 5 6 392\n1 6 6 588\n0 0 0 1\n0 1 0 4\n0 2 0 10\n0 3 0 20\n0 4 0 35\n0 5 0 56\n0 6 0 84\n0 0 1 2\n0 1 1 8\n0 2 1 20\n0 3 1 40\n0 4 1 70\n0 5 1 112\n0 6 1 168\n0 0 2 3\n0 1 2 12\n0 2 2 30\n0 3 2 60\n0 4 2 105\n0 5 2 168\n0 6 2 252\n0 0 3 4\n0 1 3 16\n0 2 3 40\n0 3 3 80\n0 4 3 140\n0 5 3 224\n0 6 3 336\n0 0 4 5\n0 1 4 20\n0 2 4 50\n0 3 4 100\n0 4 4 175\n0 5 4 280\n0 6 4 420\n0 0 5 6\n0 1 5 24\n0 2 5 60\n0 3 5 120\n0 4 5 210\n0 5 5 336\n0 6 5 504\n0 0 6 7\n0 1 6 28\n0 2 6 70\n0 3 6 140\n0 4 6 245\n0 5 6 392\n0 6 6 588\n*/\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = 998244353;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = 305;\nint c[maxn][maxn];\n\nvoid precalc() {\n  for (int i = 0; i < maxn; i++) {\n    c[i][0] = 1;\n    for (int j = 1; j <= i; j++) {\n      c[i][j] = c[i - 1][j - 1];\n      add(c[i][j], c[i - 1][j]);\n    }\n  }\n}\n\nchar tmp[maxn];\nint n;\nstring s;\n\nbool read() {\n  if (scanf(\"%s\", tmp) < 1) {\n    return false;\n  }\n  s = tmp;\n  n = sz(s);\n  return true;\n}\n\nint dp[maxn][maxn][maxn];\nint can[maxn][maxn][maxn];\n\nvoid solve() {\n  memset(dp, 0, sizeof(dp));\n  dp[n][0][0] = 1;\n  for (int i = n - 1; i >= 0; i--) {\n    for (int c0 = 0; c0 <= n; c0++) {\n      for (int c1 = 0; c1 <= n; c1++) {\n        auto cur = dp[i + 1][c0][c1];\n        if (!cur) {\n          continue;\n        }\n        add(dp[i][c0][c1], cur);\n        add(dp[i + 1][c0 + (s[i] == '1')][c1 + (s[i] == '0')], cur);\n      }\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    add(dp[i + 1][s[i] == '0'][s[i] == '1'], 1);\n  }\n  memset(can, 0, sizeof(can));\n  can[0][0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int c0 = 0; c0 <= n; c0++) {\n      for (int c1 = 0; c1 <= n; c1++) {\n        if (!can[i][c0][c1]) {\n          continue;\n        }\n        if (i + 2 <= n) {\n          if (s[i] == '0' || s[i + 1] == '0') {\n            can[i + 2][c0 + 1][c1] = true;\n          }\n          if (s[i] == '1' || s[i + 1] == '1') {\n            can[i + 2][c0][c1 + 1] = true;\n          }\n        }\n        if (i < n) {\n          for (int take = 0; take < 2; take++) {\n            int nc0 = c0 - (take == 0), nc1 = c1 - (take == 1);\n            if (nc0 < 0 || nc1 < 0) {\n              continue;\n            }\n            if (s[i] == '0' || take == 0) {\n              can[i + 1][nc0 + 1][nc1] = true;\n            }\n            if (s[i] == '1' || take == 1) {\n              can[i + 1][nc0][nc1 + 1] = true;\n            }\n          }\n        }\n        for (int take0 = 0; take0 < 2; take0++) {\n          int nc0 = c0 - (take0 == 0), nc1 = c1 - (take0 == 1);\n          if (nc0 < 0 || nc1 < 0) {\n            continue;\n          }\n          for (int take1 = 0; take1 < 2; take1++) {\n            int nnc0 = nc0 - (take1 == 0), nnc1 = nc1 - (take1 == 1);\n            if (nnc0 < 0 || nnc1 < 0) {\n              continue;\n            }\n            if (take0 == 0 || take1 == 0) {\n              can[i][nnc0 + 1][nnc1] = true;\n            }\n            if (take0 == 1 || take1 == 1) {\n              can[i][nnc0][nnc1 + 1] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int c0 = 0; c0 <= n; c0++) {\n      for (int c1 = 0; c1 <= n; c1++) {\n        if (can[i][c0][c1]) {\n          add(res, dp[i][c0][c1]);\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 305;\nconst int mod = 998244353;\n\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint dp[N][N][N];\nint dp2[3][N][N][N];\nint possible[N][N][N];\nint pref[2][N];\nint main(){\n\tstring s; cin >> s;\n\tint n = s.length();\n\ts = \"$\" + s;\n\tdp2[2][0][0][0] = possible[0][0][0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tpref[0][i] = pref[0][i - 1];\n\t\tpref[1][i] = pref[1][i - 1];\n\t\tint other = s[i] - '0';\n\t\tpref[other][i]++;\n\t\tfor(int n0 = 0; n0 <= i; n0++) for(int n1 = 0; n1 <= i; n1++){\n\t\t\tfor(int old = 0; old < 2; old++) if(dp2[old][i - 1][n0][n1]){\n\t\t\t\tint h[2] = {n0, n1};\n\t\t\t\tdp2[old][i][h[0]][h[1]] = 1; // throw other away\n\t\t\t\tdp2[other][i][h[0]][h[1]] = 1; // throw old away\n\t\t\t\th[other]++;\n\t\t\t\tdp2[2][i][h[0]][h[1]] = 1;// throw old away, other to right\n\t\t\t\th[other]--; h[old]++;\n\t\t\t\tdp2[2][i][h[0]][h[1]] = 1; // throw other away, old to right\n\t\t\t}\n\n\t\t\t// old = 2\n\t\t\tif(dp2[2][i - 1][n0][n1]) dp2[other][i][n0][n1] = 1;\n\t\t}\n\t\tfor(int n0 = 0; n0 <= n; n0++) for(int n1 = 0; n1 <= n; n1++) for(int curr = 0; curr <= 2; curr++)\n\t\t\tpossible[i][n0][n1] |= dp2[curr][i][n0][n1];\n\t}\n\n\tdp[0][0][0] = 1;\n\n\tint ans = 0;\n\n\tfor(int n0 = 0; n0 <= n; n0++) for(int n1 = 0; n1 <= n; n1++){\n\t\tfor(int now = 0; now < 2; now++){\n\t\t\tint nn0 = n0, nn1 = n1;\n\t\t\tif(now==0) nn0++;\n\t\t\tif(now==1) nn1++;\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tint num_0 = n0 - (pref[0][n] - pref[0][n - k]);\n\t\t\t\tint num_1 = n1 - (pref[1][n] - pref[1][n - k]);\n\t\t\t\t// maximum suffix that exists as a subsequence ?\n\t\t\t\tint kk = k;\n\t\t\t\tif(s[n - k] - '0'== now){\n\t\t\t\t\tkk++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[nn0][nn1][kk] = add(dp[nn0][nn1][kk], dp[n0][n1][k]);\n\t\t\t\t\n\t\t\t\tif(now == 0 && num_0 >= 0&& num_1 >= 0 && n0 + n1 >= 1){\n\t\t\t\t\t\n\t\t\t\t\tif(possible[n - k][num_0][num_1]){\n\t\t\t\t\t\tans = add(ans, dp[n0][n1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 303, mo = 998244353, inv2 =(mo+1)/2;\nconst ll MOD=7LL*mo*mo;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint res,n,f[N][N][N];char s[N];bool ok[N][N][N];\nint main() {\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tf[0][0][0]=1;\n\tok[0][0][0]=1;\n\trep(i,1,n)rep(x,0,n)rep(y,0,n-x){\n\t\tok[i][x][y]=ok[i-1][x][y];\n\t\tif(s[i]=='0'&&x)ok[i][x][y]|=ok[i-1][x-1][y+1];\n\t\tif(s[i]=='1'&&y)ok[i][x][y]|=ok[i-1][x+1][y-1];\n\t\tif(i>=2&&(s[i]=='0'||s[i-1]=='0')&&x)ok[i][x][y]|=ok[i-2][x-1][y];\n\t\tif(i>=2&&(s[i]=='1'||s[i-1]=='1')&&y)ok[i][x][y]|=ok[i-2][x][y-1];\n\t}\n//\tper(i,n-1,0)rep(x,0,n)rep(y,0,n-x)\n//\t\tok[i][x][y]|=s[i+1]=='0'?ok[i+1][x+1][y]:ok[i+1][x][y+1];\n\tres=mo-1;\n\trep(i,0,n)rep(x,0,n)rep(y,0,n-x)if(f[i][x][y]){\n\t\tif(ok[n-i][x][y])add(res,f[i][x][y]);//,cerr<<n-i<<' '<<x<<' '<<y<<' '<<f[i][x][y]<<endl;\n\t\tadd(f[i+1][x][y],f[i][x][y]);\n\t//\tif(i+x+y){\n\t\t\tif(s[n-i]=='1')add(f[i][x+1][y],f[i][x][y]);\n\t\t\telse add(f[i][x][y+1],f[i][x][y]);\n\t//\t}\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <list>\nusing namespace std;\nconst int MAX=3e2+5,mod=998244353,inf=0x3f3f3f3f;\n#define X first\n#define Y second\n#define pb push_back\nusing ll=long long;\ntypedef pair < int , int > ii;\nint n;\nchar s[MAX];\nbool a[MAX],c[MAX][MAX][MAX];\nint f[MAX][MAX][MAX];\nint sum[MAX];\nvoid check(){\n    cout<<n<<'\\n';\n    ll ans1=1;\n    for(int i=1;i<n;i++){\n        for(int b=0;b<(1<<i);b++){\n            int dem=n,mm=0,uu=0;\n            for(int j=0;j<i;j++){\n                if((b&(1<<j))!=0){\n                    if(a[dem]){\n                        dem--;\n                    }\n                    else uu++,mm++;\n                }\n                else {\n                    if(!a[dem]){\n                        dem--;\n                    }\n                    else uu++;\n                }\n            }\n            if(c[dem][uu][mm]) ans1++;\n        }\n    }\n    cout<<ans1<<'\\n';\n}\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin>>s+1;\n    n=strlen(s+1);\n    c[0][0][0]=1;\n    a[1]=s[1]-'0';\n    c[1][0][0]=1;\n\n    for(int i=2;i<=n;i++){\n        a[i]=s[i]-'0';\n        c[i][0][0]=1;\n        if(a[i]){\n            for(int j=1;j<=i/2;j++){\n                c[i][j][0]|=c[i-1][j][0];\n                for(int k=1;k<=j;k++)\n                    c[i][j][k]|=c[i-1][j][k] | c[i-2][j-1][k-1] | c[i-1][j][k-1];\n            }\n        }\n        else{\n            for(int j=1;j<=i/2;j++){\n                c[i][j][j]|=c[i-1][j][j];\n                for(int k=0;k<j;k++)\n                    c[i][j][k]|=c[i-1][j][k] | c[i-2][j-1][k] | c[i-1][j][k+1];\n            }\n        }\n        if(a[i-1]){\n            for(int j=1;j<=i/2;j++)\n                for(int k=1;k<=j;k++)\n                    c[i][j][k]|=c[i-2][j-1][k-1];\n        }\n        else{\n            for(int j=1;j<=i/2;j++)\n                for(int k=0;k<j;k++)\n                    c[i][j][k]|=c[i-2][j-1][k];\n        }\n    }\n    ll ans=1;\n    for(int i=n;i>0;i--){\n        sum[i]=sum[i+1]+a[i];\n    }\n    f[n+1][n+1][0]=1;\n    for(int i=n;i>1;i--){\n        for(int k=n-i+1,j=n+1;k>=0;k--){\n            if(a[j-1]) f[i][j][k]+=f[i+1][j][k];\n            else if(k>0)f[i][j][k]+=f[i+1][j][k-1];\n            if(f[i][j][k]>=mod) f[i][j][k]-=mod;\n            //cout<<i<<' '<<j<<' '<<k<<' '<<f[i][j][k]<<'\\n';\n            if(c[j-1][j-i][k-sum[j]])\n                    ans+=f[i][j][k];\n        }\n        for(int j=n;j>=i;j--){\n            for(int k=n-i+1;k>=sum[j];k--){\n                if(a[j]) f[i][j][k]=f[i+1][j+1][k-1];\n                else f[i][j][k]=f[i+1][j+1][k];\n                if(a[j-1]) f[i][j][k]+=f[i+1][j][k];\n                else if(k>0)f[i][j][k]+=f[i+1][j][k-1];\n                if(f[i][j][k]>=mod) f[i][j][k]-=mod;\n                //cout<<i<<' '<<j<<' '<<k<<' '<<f[i][j][k]<<'\\n';\n                if(c[j-1][j-i][k-sum[j]])\n                    ans+=f[i][j][k];\n            }\n        }\n    }\n    //check();\n    //for(int i=1;i<=n;i++)for(int j=1;j<=i/2;j++)for(int k=0;k<=j;k++) cout<<i<<' '<<j<<' '<<k<<' '<<c[i][j][k]<<'\\n';\n\n    cout<<ans%mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nset<tuple<int, int, int, int> > chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tif (chk[L - i + z + o + f].count({ i,z,o,f })) return;\n\tchk[L - i + z + o + f].insert({ i,z,o,f });\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\tif (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\tif (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint p = -1, s = -1, e = -1;\n\t\tfor (auto& t : chk[l]){\n\t\t\tauto& [i, z, o, f] = t;\n\t\t\tif (p < i){\n\t\t\t\tif (p != -1){\n\t\t\t\t\tfor (int j = s; j <= e; j++) pin[j + zc[p]] = p;\n\t\t\t\t}\n\t\t\t\tp = i;\n\t\t\t\ts = z;\n\t\t\t\te = z + f;\n\t\t\t}\n\t\t\telse if (p == i){\n\t\t\t\ts = min(s, z);\n\t\t\t\te = max(e, z + f);\n\t\t\t}\n\t\t}\n\t\tif (p != -1){\n\t\t\tfor (int j = s; j <= e; j++) pin[j + zc[p]] = p;\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t\t//printf (\"%d %lld\\n\", l, ret);\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 998244353;\n//ll dp[155][155][305];\nll ans = 0;\nll checker[305][305][305];\nll dp[305][305][305];\n\nint main() {\n    string S;\n    cin >> S;\n    checker[0][0][0] = 1;\n    for(int k = 0; k <= S.size(); k++) {\n        for(int i = S.size(); i >= 0; i--) {\n            for(int j = S.size(); j >= 0; j--) {\n                if(!checker[i][j][k]) continue;\n                //cerr << i << \" \" << j << \" \" << k << endl;\n                if(k + 2 <= S.size()) {\n                    string T = S.substr(k, 2);\n                    if(T != \"11\") checker[i+1][j][k+2] = 1;\n                    if(T != \"00\") checker[i][j+1][k+2] = 1;\n                }\n                if(i >= 2) checker[i-2][j][k] = 1;\n                if(j >= 2) checker[i][j-2][k] = 1;\n                if(i >= 1 and j >= 1) checker[i-1][j-1][k] = 1;\n                if(i >= 1 or j >= 1) checker[i][j][k+1] = 1;\n                if(i >= 1 and k + 1 <= S.size() and S[k] == '1') {\n                    checker[i-1][j+1][k+1] = 1;\n                }\n                if(j >= 1 and k + 1 <= S.size() and S[k] == '0') {\n                    checker[i+1][j-1][k+1] = 1;\n                }\n            }\n        }\n    }\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(checker[i][j][k] == 0) continue;\n                if(checker[i][j][k] == 1) {\n                    //cerr << i + j + (S.size() - k) << \" \" << i << \" \" << j << \" \" << k << endl;\n                }\n                if(k == 0) continue;\n                ll newi = i;\n                ll newj = j;\n                if(S[k-1] == '0') newi--;\n                if(S[k-1] == '1') newj--;\n                if(newi < 0 or newj < 0) continue;\n                //checker[newi][newj][k+1] = 2;\n                checker[newi][newj][k-1] = 2;\n            }\n        }\n    }\n    dp[0][0][S.size()] = 1;\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(k < S.size()) {\n                    dp[i][j][k] += dp[i][j][k+1];\n                    if(S[k] == '0' and j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(S[k] == '1' and i > 0) dp[i][j][k] += dp[i-1][j][k];\n                } else {\n                    if(j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(i > 0) dp[i][j][k] += dp[i-1][j][k];\n                }\n                dp[i][j][k] %= mod;\n                if(checker[i][j][k] == 1 and dp[i][j][k]) {\n                    //cerr << i << \" \" << j << \" \" << k << \" \" << S.substr(k, S.size()) << \" \" << dp[i][j][k] << endl;\n                    ans += dp[i][j][k];\n                }\n            }\n        }\n    }\n    //cerr << dp[1][0][6] << \" \" << checker[1][0][6] << endl;\n    //cerr << dp[0][1][6] << \" \" << checker[0][1][6] << endl;\n    ans += mod - 1;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nset<pair<int, int> > chk[303][303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tint u = 0;\n\tif (chk[L - i + z + o + f][i].count({ z, z + f })) return;\n\tchk[L - i + z + o + f][i].insert({ z, z + f });\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\telse if (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\telse if (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) {\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tfor (int i=0;i<=L;i++){\n\t\t\tint s = 0x7fffff, e = -1;\n\t\t\tfor (auto t : chk[l][i]){\n\t\t\t\ts = min(s, t.first);\n\t\t\t\te = max(e, t.second);\n\t\t\t}\n\t\t\tfor (int j = s; j <= e; j++) pin[j + zc[i]] = i;\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n#define int ll\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-8L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef long double ld;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nint is_ok(int now) {\n    int cnts[10] = {};\n    while (now != 0) {\n        cnts[now % 10]++;\n        if (cnts[now % 10] == 2) return false;\n        now /= 10;\n    }\n    return true;\n}\nint is_Prime(int now) {\n    if (now == 1) return false;\n    for (int i = 2; i * i <= now; ++i) {\n        if (now % i == 0) return false;\n    }\n    return true;\n}\nclass EllysDifferentPrimes {\npublic:static int getClosest(int n) {\n    REP(q, 1e9) {\n        if (n - q > 0 and is_ok(n - q) == 1 and is_Prime(n - q) == 1) {\n            return n - q;\n        }\n        if (is_ok(n + q) == 1 and is_Prime(n + q) == 1) {\n            return n + q;\n        }\n    }\n    return -1;\n}\n};\n\n// geometry library\n\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = ((this->data[i][0]) * (obj.data[0][q]));\n                for (int t = 1; t < obj.data.size(); ++t) {\n                    hoge += ((this->data[i][t]) * obj.data[t][q]);\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\n\nstruct Fraction {\n    ll a;\n    ll b;\n    Fraction() :a(0LL), b(1LL) {\n\n    }\n    Fraction(ll c, ll d) {\n        int hoge = gcd(llabs(c), llabs(d));\n        if (hoge != 0) {\n            c /= hoge;\n            d /= hoge;\n            if (d < 0 or (d == 0 and c < 0)) {\n                d *= -1;\n                c *= -1;\n            }\n        }\n        a = c;\n        b = d;\n    }\n    bool operator <(Fraction rhs) const {\n        if (a < 0 and rhs.a > 0) return 1;\n        if (a > 0 and rhs.a < 0) return 0;\n        return a * rhs.b < rhs.a * b;\n    }\n    bool operator ==(Fraction rhs) const {\n        return a == rhs.a and b == rhs.b;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint() :value(0LL) {\n\n    }\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a, int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now, int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr, backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int, int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    }\n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nclass KMP {\npublic:\n    vector<ll> table;\n    vector<ll> Pattern;\n    KMP(vector<ll> a) {\n        build(a);\n    }\n    void build(vector<ll> a) {\n        Pattern = a;\n        table = vector<ll>(a.size() + 1, -1);\n        int j = -1;\n        for (int i = 0; i < a.size(); ++i) {\n            while (j >= 0 && Pattern[i] != Pattern[j]) {\n                j = table[j];\n            }\n            table[i + 1] = ++j;\n        }\n        return;\n    }\n    vector<ll> search(vector<ll> a) {\n        vector<ll> ans;\n        for (int i = 0, k = 0; i < a.size(); ++i) {\n            while (k >= 0 && a[i] != Pattern[k]) k = table[k];\n            ++k;\n            if (k >= Pattern.size()) {\n                ans.push_back(i - Pattern.size() + 1);\n                k = table[k];\n            }\n        }\n        return ans;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int ll\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back(edge{ to, cap, cost, (int)graph[to].size(), false });\n        graph[to].emplace_back(edge{ from, 0, -cost, (int)graph[from].size() - 1, true });\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int)graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while (f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while (!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < graph[p.second].size(); i++) {\n                    edge& e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if (min_cost[t] == INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge& e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto& e : graph[i]) {\n                if (e.isrev) continue;\n                auto& rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint go[400][400][400];\nmodint<MOD> dp[400][400][400];\nvoid solve(){\n    string s;\n    cin >> s;\n    go[0][0][0] = 1;\n    for (int i = 0; i < s.length(); ++i) {\n        REP(q, 400) {\n            REP(j, 400) {\n                if (go[i][q][j] == 0) continue;\n                if (i + 1 < s.length()) {\n                    if (s[i] == '0' or s[i+1] == '0') {\n                        go[i + 2][q + 1][j] = 1;\n                    }\n                    if (s[i] == '1' or s[i + 1] == '1') {\n                        go[i + 2][q][j + 1] = 1;\n                    }\n                }\n                if (s[i] == '0' and j > 0) {\n                    go[i + 1][q + 1][j - 1] = 1;\n                }\n                if (s[i] == '1' and q > 0) {\n                    go[i + 1][q - 1][j + 1] = 1;\n                }\n                go[i + 1][q][j] = 1;\n            }\n        }\n        for (int q = 399; q >= 0; --q) {\n            for (int j = 399; j >= 0; --j) {\n                if (go[i + 1][q][j] == 0) continue;\n                if (j != 0) {\n                    go[i + 1][q][j - 1] = 1;\n                }\n                if (q != 0) {\n                    go[i + 1][q - 1][j] = 1;\n                }\n            }\n        }\n    }\n    dp[s.length()][0][0] = 1;\n    for (int q = s.length()-1; q >= 0; --q) {\n        REP(j, 400-1) {\n            REP(t, 400-1) {\n                dp[q][j][t] += dp[q + 1][j][t];\n                if (s[q] == '0') {\n                    dp[q+1][j][t + 1] += dp[q + 1][j][t]; // 1 -> req\n                }\n                else {\n                    dp[q+1][j + 1][t] += dp[q + 1][j][t]; // 0-> req\n                }\n            }\n        }\n    }\n    modint<MOD> ans = 0;\n    for (int i = 0; i <= s.length(); ++i) {\n        REP(q, 400) {\n            REP(j, 400) {\n                if (go[i][q][j] == 1) {\n                    ans += dp[i][q][j];\n                }\n            }\n        }\n    }\n    ans -= 1;\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(i+j >= 2){\n\t\t\t\t\tif(i>0)dp[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0)dp[i][j-1][k] = 1; \n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(j>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nusing M9 = IntMod<998244353>;\n\n// T = reverse(S) とする\n// 以下、「T 内の文字」と言った場合、先頭から貪欲に T に含まれる文字を確定していくことを示す\n// T = \"100101\" に対して 0 を3つ挿入し、 \"100010010\" を得たなら、\n// [1][0][0] 0 [1][0] 0 [1] となる ([ ] のついた部分が T 内の文字)\n\nstring S;\nbool DP[302][302][302];\t\t// DP[i][j][k] = Sの先頭 i 文字を使って手持ちを「0 が j 個, 1 が k 個」にできるか\nM9 EP[302][302];\t\t\t// EP[i][j] = Tの先頭 i 文字に 0 を j 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 FP[302][302];\t\t\t// FP[i][k] = Tの先頭 i 文字に 1 を k 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 GP[302][302][302];\t\t// GP[i][j][k] = Tの先頭 i 文字に 0 を j 個, 1 を k 個挿入してできる文字列の数\nM9 EQ[302][303];\t\t// 累積和用\nM9 FQ[302][303];\nvoid pre() {\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\tint N = T.size();\n\n\t// EP の計算: 先頭から T を見ていき 0 を挿入する ([1] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N - i + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tEP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tEP[i][j] = EP[i - 1][j];\n\t\t\t} else {\n\t\t\t\tEP[i][j] = EQ[i - 1][j + 1];\n\t\t\t}\n\t\t}\n\n\t\tREP(j, 0, N - i + 1) {\n\t\t\tEQ[i][j + 1] = EQ[i][j] + EP[i][j];\n\t\t}\n\t}\n\n\t// FP の計算: 先頭から T を見ていき 1 を挿入する ([0] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(k, 0, N - i + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tFP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tFP[i][k] = FQ[i - 1][k + 1];\n\t\t\t} else {\n\t\t\t\tFP[i][k] = FP[i - 1][k];\n\t\t\t}\n\t\t}\n\n\t\tREP(k, 0, N - i + 1) {\n\t\t\tFQ[i][k + 1] = FQ[i][k] + FP[i][k];\n\t\t}\n\t}\n\n\t// GP の計算:\n\t// GP[i][j][k] = sum [p = 0 to j, q = 0 to k] { EP[i][j - p] * FP[i][k - q] * C(p + q, p) } である\n\t// (T 内の文字がどこに現れるかで場合分けするとわかる)\n\t// ここから GP[i][j][k] = GP[i][j - 1][k] + GP[i][j][k - 1] + EP[i][j] * FP[i][k] が得られる\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N - i + 1) {\n\t\t\tREP(k, 0, N - i - j + 1) {\n\t\t\t\tGP[i][j][k] += EP[i][j] * FP[i][k];\n\t\t\t\tif (j > 0) GP[i][j][k] += GP[i][j - 1][k];\n\t\t\t\tif (k > 0) GP[i][j][k] += GP[i][j][k - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> S;\n\tpre();\n\n\tint N = S.size();\n\n\t// DP の計算 (これは素直だと思います)\n\tDP[0][0][0] = true;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, i / 2 + 1) {\n\t\t\tREP(k, 0, i / 2 + 1) {\n\t\t\t\tif (i + 1 < N) {\n\t\t\t\t\tif (S[i] == '0' || S[i + 1] == '0') DP[i + 2][j + 1][k] |= DP[i][j][k];\n\t\t\t\t\tif (S[i] == '1' || S[i + 1] == '1') DP[i + 2][j][k + 1] |= DP[i][j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 0 && S[i] == '1') DP[i + 1][j - 1][k + 1] |= DP[i][j][k];\n\t\t\t\tif (k > 0 && S[i] == '0') DP[i + 1][j + 1][k - 1] |= DP[i][j][k];\n\t\t\t\tif (j + k > 0) DP[i + 1][j][k] |= DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tM9 sum = 0;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, i / 2 + 1) {\n\t\t\tREP(k, 0, i / 2 + 1) {\n\t\t\t\tif (!DP[i][j][k]) continue;\n\t\t\t\t// 今見ている取り除き方 (i, j, k) を包含するようなうまい取り除き方があれば skip\n\t\t\t\tif (S[i] == '0' && DP[i + 1][j + 1][k]) continue;\n\t\t\t\tif (S[i] == '1' && DP[i + 1][j][k + 1]) continue;\n\t\t\t\tsum += GP[N - i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=305,MOD=998244353;\n#define int ll\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\n\nint n;\nchar s[MAXN];\nint f[MAXN][MAXN][MAXN],cnt[2];\nint g[MAXN][MAXN][MAXN];\n\nsigned main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i)++cnt[s[i]-'0'];\n\tfor(int j=0;j<=cnt[1];++j)f[n+1][0][j]=1;\n\tfor(int i=1;i<=cnt[0];++i)\n\t{\n\t\tf[n+1][i][0]=1;\n\t\tfor(int j=1;j<=cnt[1];++j)\n\t\t\tf[n+1][i][j]=dmy(f[n+1][i-1][j]+f[n+1][i][j-1]);\n\t}\n\tfor(int k=n;k;--k)\n\t\tfor(int i=0;i<=cnt[0];++i)\n\t\t\tfor(int j=0;j<=cnt[1];++j)\n\t\t\t{\n\t\t\t\tif(i)inc(f[k][i][j],f[k+(s[k]=='0')][i-1][j]);\n\t\t\t\tif(j)inc(f[k][i][j],f[k+(s[k]=='1')][i][j-1]);\n\t\t\t}\n\tg[0][0][0]=1;\n\tfor(int k=1;k<=n;++k)\n\t\tfor(int i=0;i<=k && i<=cnt[0];++i)\n\t\t\tfor(int j=0;j<=k-i && j<=cnt[1];++j)\n\t\t\t{\n\t\t\t\tif(s[k]=='0')\n\t\t\t\t{\n\t\t\t\t\tif(i)g[k][i][j]+=g[k-1][i-1][j];\n\t\t\t\t\tif(i && k>=2)g[k][i][j]+=g[k-2][i-1][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(j)g[k][i][j]+=g[k-1][i][j-1];\n\t\t\t\t\tif(j && k>=2)g[k][i][j]+=g[k-2][i][j-1];\n\t\t\t\t}\n\t\t\t\tif(s[k-1]=='0' && i)g[k][i][j]+=g[k-2][i-1][j];\n\t\t\t\telse if(s[k-1]=='1' && j)g[k][i][j]+=g[k-2][i][j-1];\n\t\t\t\tif(g[k][i][j])g[k][i][j]=1;\n\t\t\t}\n\tint ans=0;\n\tfor(int i=0;i<=cnt[0];++i)\n\t\tfor(int j=0;j<=cnt[1];++j)\n\t\t{\n\t\t\tint pos=-1;\n\t\t\tfor(int k=n;k>=0;--k)if(g[k][i][j]){pos=k;break;}\n\t\t\tif(pos<0)continue;\n\t\t\tinc(ans,f[pos+1][cnt[0]-i][cnt[1]-j]);\n\t\t}\n\tprintf(\"%d\\n\",dmy(ans+MOD-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tstring s_;  cin >> s_;\n\tll n=sz(s_);\n\tvll s = str2num(s_, n);\n\ts.push_back(0);//dmy\n\n\tvvvll dp(n+1, vvll(n+1, vll(n+1)));\n\tauto Dp = [&](ll i, ll j, ll k)->ll&{\n\t\tstatic ll dmy=0;\n\t\tif (i>=n) return dmy;\n\t\treturn dp[i+1][j][k];\n\t};\n\n\tDp(-1, 0, 0)=1;\n\n\trep(i,-1, n-2)rep(j,0,n)rep(k,0,n){\n\t\tif (Dp(i, j, k)==0)continue;\n\t\tDp(i+1, j, k)=1;\n\t\tDp(i+2, j, k)=1;\n\t\tif (s[i+1]==0 or s[i+2]==0) Dp(i+2, j+1, k)=1;\n\t\tif (s[i+1]==1 or s[i+2]==1) Dp(i+2, j, k+1)=1;\n\t}\n\tDump(dp);\n\tvvvmll dq(n+1, vvmll(n+1, vmll(n+1)));\n\tauto Dq = [&](ll i, ll j, ll k)->mll&{\n\t\treturn dq[i][j][k];\n\t};\n\tDq(n, 0, 0)=1;\n\n\tmll ans=0;\n\tdep(i, n-1, 0){\n\t\tdq[i]=dq[i+1];\n\t\tif (s[i]==0){\n\t\t\trep(j, 0, n){\n\t\t\t\trep(k, 1, n) Dq(i, j, k)+=Dq(i, j, k-1);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trep(k, 0, n){\n\t\t\t\trep(j, 1, n) Dq(i, j, k)+=Dq(i, j-1, k);\n\t\t\t}\n\t\t}\n\n\t\trep(j, 0, n)rep(k, 0, n){\n\t\t\tif (Dp(i, j, k)==1){\n\t\t\t\tans+=Dq(i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (int)(Y);++(X))\n#define reps(X,S,Y) for (int (X) = (int)(S);(X) < (int)(Y);++(X))\n#define rrep(X,Y) for (int (X) = (int)(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (int)(Y)-1;(X) >= (int)(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow_(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct ModInt{\n  int v;\n  ModInt(int v=0):v(v){}\n  ModInt operator+(const ModInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  ModInt operator-(const ModInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  ModInt operator*(const ModInt &n)const{return ll(v)*n.v%mod;}\n  ModInt operator/(const ModInt &n)const{return ll(v)*modpow_(n.v%mod,-1,mod)%mod;}\n  ModInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  ModInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  ModInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  ModInt operator/(const ll &n)const{return ll(v)*modpow_(n%mod,-1,mod)%mod;}\n  ModInt& operator+=(const ModInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ModInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ModInt &n){v=ll(v)*n.v%mod; return *this;}\n  ModInt& operator/=(const ModInt &n){v=ll(v)*modpow_(n.v,-1,mod)%mod; return *this;}\n  ModInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  ModInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  ModInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  ModInt& operator/=(const ll &n){v=ll(v)*modpow_(n,-1,mod)%mod; return *this;}\n\tbool operator==(const ModInt &n)const{return v==n.v;};\n\tbool operator!=(const ModInt &n)const{return v!=n.v;};\n\tModInt& operator++(){ return operator+=(1); }\n\tModInt& operator--(){ return operator-=(1); }\n\tModInt operator++(int i){ ModInt tmp(*this); operator++(); return tmp; }\n\tModInt operator--(int i){ ModInt tmp(*this); operator--(); return tmp; }\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow_(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow_(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const ModInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> ModInt<mod> operator+(const ll &n,const ModInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> ModInt<mod> operator-(const ll &n,const ModInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> ModInt<mod> operator*(const ll &n,const ModInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> ModInt<mod> operator/(const ll &n,const ModInt<mod> &m){return ModInt<mod>(n%mod)/m;}\ntypedef ModInt<MOD> mint;\ntemplate <int mod> ModInt<mod> modpow(ModInt<mod> r,ll n){ ModInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\nusing pmm=pair<mint,mint>;\nmint modpow(ll r,ll n){ return modpow_(r,n);}\n\n\nint dp0[333][333][333];\nmint dp1[333][333][333];\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tstring s;\n\tcin>>s;\n\tconst int n=s.size();\n\tdp0[0][0][0]=1;\n\trep(i,n+1)rrep(c0,n+1)rrep(c1,n+1)if(dp0[i][c0][c1]){\n\t\tif(i+2<=n){\n\t\t\tif(s[i]=='0' || s[i+1]=='0') dp0[i+2][c0+1][c1]=1;\n\t\t\tif(s[i]=='1' || s[i+1]=='1') dp0[i+2][c0][c1+1]=1;\n\t\t}\n\t\tif(i+1<=n){\n\t\t\tif(s[i]=='0'){\n\t\t\t\tdp0[i+1][c0][c1]=1;\n\t\t\t\tif(c1) dp0[i+1][c0+1][c1-1]=1;\n\t\t\t}\n\t\t\tif(s[i]=='1'){\n\t\t\t\tif(c0) dp0[i+1][c0-1][c1+1]=1;\n\t\t\t\tdp0[i+1][c0][c1]=1;\n\t\t\t}\n\t\t}\n\t\tif(c0) dp0[i][c0-1][c1]=1;\n\t\tif(c1) dp0[i][c0][c1-1]=1;\n\t}\n\n\tdp1[n][0][0]=1;\n\trrep(i,n)rep(c0,n+1)rep(c1,n+1){\n\t\tif(s[i]=='0'){\n\t\t\tdp1[i][c0][c1]+=dp1[i+1][c0][c1];\n\t\t\tdp1[i+1][c0][c1+1]+=dp1[i+1][c0][c1];\n\t\t}else{\n\t\t\tdp1[i+1][c0+1][c1]+=dp1[i+1][c0][c1];\n\t\t\tdp1[i][c0][c1]+=dp1[i+1][c0][c1];\n\t\t}\n\t}\n\n\tmint re=0;\n\t// rep(i,n+1)rep(c0,n+1)rep(c1,n+1)if(dp0[i][c0][c1]){\n\t// \tout(i,c0,c1,dp1[i][c0][c1],1);\n\t// }\n\trep(i,n+1)rep(c0,n+1)rep(c1,n+1)if(dp0[i][c0][c1]) re+=dp1[i][c0][c1];\n\tcout<<re-1 NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nconst int mod=998244353;\nint f[310][310][310],g[310][310][310];\nchar ss[310];\nint main()\n{\n\tre int n;\n\tscanf(\"%s\",ss+1);\n\tn=strlen(ss+1);\n\tg[0][0][0]=1;\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tfor(re int j=0;j<=n;j++)\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(ss[i]=='0'&&j)g[i][j][k]|=g[i-1][j-1][k+1];\n\t\t\t\tif(ss[i]=='1'&&k)g[i][j][k]|=g[i-1][j+1][k-1];\n\t\t\t\tg[i][j][k]|=g[i-1][j][k];\n\t\t\t\tif(i>=2)\n\t\t\t\t{\n\t\t\t\t\tif((ss[i]=='0'||ss[i-1]=='0')&&j)g[i][j][k]|=g[i-2][j-1][k];\n\t\t\t\t\tif((ss[i]=='1'||ss[i-1]=='1')&&k)g[i][j][k]|=g[i-2][j][k-1];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor(re int i=0;i<=n;i++)\n\t{\n\t\tif(ss[n]=='0')f[n][0][i]=1;\n\t\telse f[n][i][0]=1;\n\t}\n\tfor(re int i=n-1;i>=0;i--)\n\t{\n\t\tfor(re int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tf[i][j][k]=f[i+1][j][k];\n\t\t\t\tif(ss[i]=='0'&&k)f[i][j][k]=(f[i][j][k]+f[i][j][k-1])%mod;\n\t\t\t\tif(ss[i]=='1'&&j)f[i][j][k]=(f[i][j][k]+f[i][j-1][k])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tre int ans=0;\n\tfor(re int i=0;i<=n;i++)\n\t\tfor(re int j=0;j<=n;j++)\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\tif(i!=n||j||k){\n\t\t\t\tans=(ans+g[i][j][k]*f[i][j][k])%mod;\n\t\t\t\t//if(g[i][j][k])printf(\"***%d %d %d %d %d\\n\",i,j,k,f[i][j][k],ans);\n\t\t\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n//#pragma GCC optimize(\"O3\")\n//#pragma GCC target(\"sse4\")\n \n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define FILL(a, value) memset(a, value, sizeof(a))\n \n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(), a.end()\n \ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int mod = 998244353;\nconst int MAX = 304;\n\nint add(int a, int b)\n{\n\treturn a + b < mod ? a + b : a + b - mod;\n}\n\nint sub(int a, int b)\n{\n\treturn a - b >= 0 ? a - b : a - b + mod;\n}\n\nint mult(int a, int b)\n{\n\treturn (LL)a * b % mod;\n}\n\nvoid updAdd(int& x, int val)\n{\n\tx += val;\n\tif(x >= mod)\n\t\tx -= mod;\n}\n\nbool f[MAX][MAX][MAX];\nint g[MAX][MAX][MAX];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tstring s;\n\tcin >> s;\n\tf[0][0][0] = true;\n\tFOR(i, 0, SZ(s))\n\t\tFOR(c0, 0, SZ(s) + 1)\n\t\t\tFOR(c1, 0, SZ(s) + 1)\n\t\t\t\tif(f[i][c0][c1])\n\t\t\t\t{\n\t\t\t\t\tassert(2 * (c0 + c1) <= i);\n\t\t\t\t\tf[i + 1][c0][c1] = true;\n\t\t\t\t\tif(c0)\n\t\t\t\t\t\tf[i + 1][c0 - 1 + (s[i] == '0')][c1 + (s[i] == '1')] = true;\n\t\t\t\t\tif(c1)\n\t\t\t\t\t\tf[i + 1][c0 + (s[i] == '0')][c1 - 1 + (s[i] == '1')] = true;\n\t\t\t\t\tif(i + 1 < SZ(s))\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i + 2][c0 + (s[i] == '0')][c1 + (s[i] == '1')] = true;\n\t\t\t\t\t\tf[i + 2][c0 + (s[i + 1] == '0')][c1 + (s[i + 1] == '1')] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\tg[SZ(s)][0][0] = 1;\n\tRFOR(i, SZ(s) + 1, 1)\n\t\tFOR(c0, 0, SZ(s) + 1)\n\t\t\tFOR(c1, 0, SZ(s) + 1)\n\t\t\t{\n\t\t\t\tupdAdd(g[i - 1][c0][c1], g[i][c0][c1]);\n\t\t\t\tupdAdd(g[i][c0 + (s[i - 1] == '1')][c1 + (s[i - 1] == '0')], g[i][c0][c1]);\n\t\t\t}\n\tint ans = mod - 1;\n\tFOR(i, 0, SZ(s) + 1)\n\t\tFOR(c0, 0, SZ(s) + 1)\n\t\t\tFOR(c1, 0, SZ(s) + 1)\n\t\t\t\tif(f[i][c0][c1])\n\t\t\t\t{\n\t\t\t\t\t//cerr << i << \" \" << c0 << \" \" << c1 << \" \" << g[i][c0][c1] << endl;\n\t\t\t\t\tupdAdd(ans, g[i][c0][c1]);\n\t\t\t\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int P = 998244353;\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int &x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int &x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int &x, int &y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nconst int N = 310;\n\nchar s[N];\nint n0, n1;\nint s0[N], s1[N];\nint p0[N], p1[N];\nint dp[N][N], f[N][N][N];\nint len[N][N][N];\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> s;\n  int n = strlen(s);\n  for (int i = 0; i < n; ++i)\n    if (s[i] == '0')\n      p0[n0++] = i;\n    else\n      p1[n1++] = i;\n  for (int i = 0; i < n; ++i) {\n    s0[i + 1] = s0[i] + (s[i] == '0');\n    s1[i + 1] = s1[i] + (s[i] == '1');\n  }\n  dp[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    memcpy(f[i], dp, sizeof(dp));\n    for (int j = 0; j <= n0; ++j)\n      for (int k = 0; k <= n1; ++k) {\n        add(f[i][j][k + 1], f[i][j][k]);\n        add(f[i][j + 1][k], f[i][j][k]);\n      }\n    if (i == n) break;\n    for (int j = 0; j <= n0; ++j)\n      for (int k = 0; k <= n1; ++k) {\n        if (s[n - 1 - i] == '0')\n          add(dp[j][k + 1], dp[j][k]);\n        else\n          add(dp[j + 1][k], dp[j][k]);\n      }\n  }\n\n  memset(len, -1, sizeof(len));\n  len[0][0][0] = 0;\n  for (int i = 0; i <= n0; ++i) {\n    for (int j = 0; j <= n1; ++j) {\n      for (int k = i + j; k >= 0; --k) {\n        if (len[i][j][k] == -1) continue;\n        if (k) {\n          len[i][j][k - 1] = max(len[i][j][k - 1], len[i][j][k] + 1);\n        }\n        int c0 = 0, c1 = 0;\n        for (int t = 0; t < 2 && len[i][j][k] + t < n; ++t) {\n          if (s[len[i][j][k] + t] == '0') ++c0;\n          else ++c1;\n        }\n        if (c0 == 2) {\n          len[i + 2][j][k + 1] = max(len[i + 2][j][k + 1], len[i][j][k] + 2);\n        }\n        if (c1 == 2) {\n          len[i][j + 2][k + 1] = max(len[i][j + 2][k + 1], len[i][j][k] + 2);\n        }\n        if (c0 && c1)\n          len[i + 1][j + 1][k + 1] = max(len[i + 1][j + 1][k + 1], len[i][j][k] + 2);\n        if (c0)\n          len[i + 1][j][k] = max(len[i + 1][j][k], len[i][j][k] + 2);\n        if (c1)\n          len[i][j + 1][k] = max(len[i][j + 1][k], len[i][j][k] + 2);\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int i = 0; i <= n0; ++i)\n    for (int j = 0; j <= n1; ++j) {\n      if (i + j == n) continue;\n      int al = len[i][j][0];\n      if (al == -1) continue;\n\n      al = min(al, n);\n      add(ans, f[n - al][s0[al] - i][s1[al] - j]);\n    }\n  cout << ans << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tassert(std::count(s.begin(), s.end(), '0') >= n / 10 && std::count(s.begin(), s.end(), '1') >= n / 10);\n\t\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nconst int N = 310;\n\nint n;\nstring s;\nbool can[2][N][N];\nint best[N][N], suf[N][2], dp[2][N][N];\n\nvoid add(int &x, int y) { \n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nint memo[N][N][N];\nint go(int from, int zeros, int ones) {\n    if (zeros < 0 || ones < 0) return 0;\n    if (zeros + ones == 0) return 1;\n\n    int &res = memo[from][zeros][ones];\n    if (~res) return res;\n\n    res = 0;\n    if (s[from] == '0') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros-1, ones));\n\n    if (s[from] == '1') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros, ones-1));\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    cin >> s;\n    n = si(s);\n    dforsn(i,0,n) {\n        forn(j,2) {\n            suf[i][j] = s[i] == '0'+j;\n            suf[i][j] += suf[i+1][j];\n        }\n    }\n\n    memset(best, -1, sizeof best);\n\n    auto cur = can[0], prv = can[1];\n    cur[0][0] = 1;\n    for (int take = 1; take < n; take++) {\n        swap(cur, prv);\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                cur[a][b] = 0;\n            }\n        }\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                if (prv[a][b]) {\n                    if (a >= 1 && a+b >= 2) cur[a-1][b] = 1;\n                    if (b >= 1 && a+b >= 2) cur[a][b-1] = 1;\n                    int rest = n - take + 1 - a - b;\n                    int pos = n-rest;\n                    if (a+b > 0) cur[a][b] = 1;\n                    if (s[pos] == '0' && b > 0) cur[a+1][b-1] = 1;\n                    if (s[pos] == '1' && a > 0) cur[a-1][b+1] = 1;\n                    if (pos + 1 < n) {\n                        if (s[pos] == '0' || s[pos+1] == '0') cur[a+1][b] = 1;\n                        if (s[pos] == '1' || s[pos+1] == '1') cur[a][b+1] = 1;\n                    }\n                }\n            }\n        }\n\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) if (cur[a][b]) {\n                int rest = n - take - a - b;\n                int pos = n-rest;\n\n                int aa = suf[pos][0] + a;\n                int bb = suf[pos][1] + b;\n                best[aa][bb] = max(best[aa][bb], pos);\n            }\n        }\n    }\n    s += '$';\n    memset(memo, -1, sizeof memo);\n    ll ans = 0;\n    forn(a,n+1) forn(b,n+1) if (best[a][b] != -1) {\n        int pos = best[a][b];\n        int ca = a - suf[pos][0];\n        int cb = b - suf[pos][1];\n        ans += go(pos, ca, cb);\n    }\n    cout << (ans+1) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 305;\n\nint n, c[N][N][N], dp[N][N][N], f[N][N], mod = 998244353;\nstring s;\n\nvoid go(int idx, int z, int o){\n    if(c[idx][z][o]) return;\n    c[idx][z][o] = 1;\n    if(z >= 2) go(idx, z - 1, o);\n    if(o >= 2) go(idx, z, o - 1);\n    if(o >= 1 && z >= 1){\n        go(idx, z - 1, o);\n        go(idx, z, o - 1);\n    }\n    if(idx < n && s[idx] == '1' && z){\n        go(idx + 1, z, o);\n        go(idx + 1, z - 1, o + 1);\n    }\n    if(idx < n && s[idx] == '0' && o){\n        go(idx + 1, z, o);\n        go(idx + 1, z + 1, o - 1);\n    }\n    if(idx < n && s[idx] == '0' && z){\n        go(idx + 1, z, o);\n    }\n    if(idx < n && s[idx] == '1' && o){\n        go(idx + 1, z, o);\n    }\n    if(idx + 1 < n && (s[idx] == '0' || s[idx + 1] == '0')){\n        go(idx + 2, z + 1, o);\n    }\n    if(idx + 1 < n && (s[idx] == '1' || s[idx + 1] == '1')){\n        go(idx + 2, z, o + 1);\n    }\n}\nint solve(int idx, int z, int o){\n    if(idx == n && z == 0 && o == 0) return 1;\n    int &ret = dp[idx][z][o];\n    if(ret != -1) return ret;\n    ret = 0;\n    // 0\n    if(s[idx] == '0') ret += solve(idx + 1, z, o);\n    else if(z) ret += solve(idx, z - 1, o);\n    if(ret >= mod) ret -= mod;\n    // 1\n    if(s[idx] == '1') ret += solve(idx + 1, z, o);\n    else if(o) ret += solve(idx, z, o - 1);\n    if(ret >= mod) ret -= mod;\n    return ret;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp, -1, sizeof dp);\n    cin >> s;\n    n = s.size();\n    go(0, 0, 0);\n    vector <int> suff(n + 1);\n    for(int i = n - 1 ; i >= 0 ; i--){\n        suff[i] = suff[i + 1];\n        suff[i] += s[i] - '0';\n    }\n    memset(f, -1, sizeof f);\n    for(int i = 0 ; i <= n ; i++){\n        for(int z = 0 ; z <= n ; z++){\n            for(int o = 0 ; o <= n ; o++){\n                if(c[i][z][o]){\n                    int zeros = n - i - suff[i] + z;\n                    int ones = suff[i] + o;\n                    f[zeros][ones] = i;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int z = 0 ; z <= n ; z++){\n        for(int o = 0 ; o <= n ; o++){\n            int i = f[z][o];\n            if(i == -1) continue;\n            int zeros = z - (n - i - suff[i]);\n            int ones = o - suff[i];\n            ans += solve(i, zeros, ones);\n            if(ans >= mod) ans -= mod;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define mod 998244353\n#define pl(a,b) a=(a+b)%mod;\n#define N 310\n\nstring s;\nll n;\nll f[N][N][N];\nvoid calcf(){\n\trep(i,N)rep(x,N)rep(y,N)f[i][x][y]=0;\n\tf[0][0][0]=1;\n\tfor(ll i=0;i<=n;i++)for(ll x=0;x<=n;x++)for(ll y=0;y<=n;y++){\n\t\tif(i+x+y>n)continue;\n\t\tif(i+1<=n){\n\t\t\tpl(f[i+1][x][y],f[i][x][y]);\n\t\t\tif(s[n-1-i]=='0')pl(f[i+1][x][y+1],f[i][x][y]);\n\t\t\tif(s[n-1-i]=='1')pl(f[i+1][x+1][y],f[i][x][y]);\n\t\t}\n\t\telse{\n\t\t\tpl(f[i][x+1][y],f[i][x][y]);\n\t\t\tpl(f[i][x][y+1],f[i][x][y]);\n\t\t}\n\t}\n}\n\nbool dp[N][N][N];\nvoid calcdp(){\n\tll ans=0;\n\trep(i,N)rep(x,N)rep(y,N)dp[i][x][y]=0;\n\tdp[0][0][0]=1;\n\tfor(ll i=0;i<=n;i++)for(ll x=0;x<=n;x++)for(ll y=0;y<=n;y++){\n\t\tif(i+x+y>n)continue;\n\t\tif(dp[i][x][y]==0)continue;\n\t\tpl(ans,f[i][x][y]);\n\t\tif(x-1>=0)dp[i][x-1][y]=1;\n\t\tif(y-1>=0)dp[i][x][y-1]=1;\n\t\tif(i+1<=n){\n\t\t\tdp[i+1][x][y]=1;\n\t\t\tif(s[n-1-i]=='0'&&y-1>=0)dp[i+1][x+1][y-1]=1;\n\t\t\tif(s[n-1-i]=='1'&&x-1>=0)dp[i+1][x-1][y+1]=1;\n\t\t}\n\t\tif(i+2<=n){\n\t\t\trep(r,2){\n\t\t\t\tbool th=0;\n\t\t\t\trep(e,2)if(s[n-1-i-e]=='0'+r)th=1;\n\t\t\t\tif(th){\n\t\t\t\t\tif(r==0)dp[i+2][x+1][y]=1;\n\t\t\t\t\tif(r==1)dp[i+2][x][y+1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tcalcf();\n\tcalcdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t\tgo(i + 1, j, k, stock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/? TLE解\n\n#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint tes(string s, string t) {\n\tvector<int> v;\n\tREP(i, 0, s.size()) v.push_back(0);\n\tREP(j, 0, t.size()) v.push_back(1);\n\n\tset<string> st;\n\tdo {\n\t\tint p = 0;\n\t\tint q = 0;\n\n\t\tstring r;\n\t\tREP(k, 0, v.size()) {\n\t\t\tif (v[k] == 0) {\n\t\t\t\tr += s[p];\n\t\t\t\t++p;\n\t\t\t} else {\n\t\t\t\tr += t[q];\n\t\t\t\t++q;\n\t\t\t}\n\t\t}\n\t\tst.insert(r);\n\t} while (next_permutation(v.begin(), v.end()));\n\treturn st.size();\n}\n\n\nusing M9 = IntMod<998244353>;\n\nstring S;\nbool DP[301][301][301];\nM9 EP[301][301][301];\nM9 EQ[301][301][301];\nvoid pre() {\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\tint N = T.size();\n\n\tEP[0][0][0] = 1;\n\tREP(i, 1, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (T[i - 1] == '0') {\n\t\t\t\t\tREP(dk, 0, k + 1) {\n\t\t\t\t\t\tEP[i][j][k] += EP[i - 1][j][k - dk];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tREP(dj, 0, j + 1) {\n\t\t\t\t\t\tEP[i][j][k] += EP[i - 1][j - dj][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nM9 sub(int i, int j, int k) {\n\tM9 sum = 0;\n\tREP(dj, 0, j + 1) {\n\t\tREP(dk, 0, k + 1) {\n\t\t\tsum += EP[i][j - dj][k - dk] * M9::combi(dj + dk, dj);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> S;\n\tpre();\n\n\tint N = S.size();\n\tDP[0][0][0] = true;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (i + 1 < N) {\n\t\t\t\t\tif (S[i] == '0' || S[i + 1] == '0') DP[i + 2][j + 1][k] |= DP[i][j][k];\n\t\t\t\t\tif (S[i] == '1' || S[i + 1] == '1') DP[i + 2][j][k + 1] |= DP[i][j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 0 && S[i] == '1') DP[i + 1][j - 1][k + 1] |= DP[i][j][k];\n\t\t\t\tif (k > 0 && S[i] == '0') DP[i + 1][j + 1][k - 1] |= DP[i][j][k];\n\t\t\t\tif (j + k > 0) DP[i + 1][j][k] |= DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tM9 sum = 0;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (!DP[i][j][k]) continue;\n\t\t\t\tif (S[i] == '0' && DP[i + 1][j + 1][k]) continue;\n\t\t\t\tif (S[i] == '1' && DP[i + 1][j][k + 1]) continue;\n\t\t\t\tsum += sub(N - i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 305\nconst int mod=998244353;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint dp[N][N][N],n,ans;\nbool ok[N][N][N];\nchar s[N];\n#define ck(x) (x>=mod?x-mod:x)\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=0;i<n;++i){\n\t\tok[i][0][0]=true;\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=0;k<=i;++k){\n\t\t\t\tif(!ok[i][j][k])continue;\n\t\t\t\tif(s[i+1]=='0'||s[i+2]=='0')ok[i+2][j+1][k]=true;\n\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1')ok[i+2][j][k+1]=true;\n\t\t\t\tif(j|k)ok[i+1][j][k]=true;\n\t\t\t\tif(s[i+1]=='0'&&k)ok[i+1][j+1][k-1]=true;\n\t\t\t\tif(s[i+1]=='1'&&j)ok[i+1][j-1][k+1]=true;\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tfor(int k=0;k<=n;++k){\n\t\t\t\tconst int t=dp[i][j][k];\n\t\t\t\tif(!t)continue;\n\t\t\t\tdp[i-1][j][k]=ck(dp[i-1][j][k]+t);\n\t\t\t\tif(s[i]=='0')dp[i][j][k+1]=ck(dp[i][j][k+1]+t);\n\t\t\t\telse dp[i][j+1][k]=ck(dp[i][j+1][k]+t);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;++i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=0;k<=i;++k){\n\t\t\t\tif(ok[i][j][k])ans=ck(ans+dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 305;\nconst int MOD = 998244353;\n\nint n,ans;\nint f[MAXN][MAXN][MAXN];\nint g[MAXN][MAXN][MAXN];\n\nchar s[MAXN];\n\nbool G(int T,int j,int R0,int R1)\n{\n\tint r[2] = {R0,R1};\n\tif (R0 + R1 > n - j + 1)\n\t\treturn 0;\n\tif (j > n)\n\t\treturn 1;\n\tif (!T)\n\t\treturn 0;\n\tif (j == n)\n\t\treturn 1;\n\tint &res = g[T][j][R0];\n\tif (~res)\n\t\treturn res;\n\tres = G(T - 1,j + 1,r[0],r[1]);\n\tif (r[s[j] - '0'])\n\t{\n\t\tr[s[j] - '0']--;\n\t\tres |= G(T - 1,j + 2,r[0],r[1]);\n\t\tr[s[j] - '0']++;\n\t\tr[s[j] - '0']--;\n\t\tr[(s[j + 1] - '0') ^ 1]++;\n\t\tres |= G(T - 1,j + 1,r[0],r[1]);\n\t\tr[s[j] - '0']++;\n\t\tr[(s[j + 1] - '0') ^ 1]--;\n\t}\n\tif (r[s[j + 1] - '0'])\n\t{\n\t\tr[s[j + 1] - '0']--;\n\t\tres |= G(T - 1,j + 2,r[0],r[1]);\n\t\tr[s[j + 1] - '0']++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tmemset(g,-1,sizeof(g));\n\tscanf(\"%s\",s + 1);\n\tn = strlen(s + 1);\n\tint cnt[2] = {0};\n\tfor (int i = 1;i <= n;i++)\n\t\tcnt[s[i] - '0']++;\n\treverse(s + 1,s + n + 1);\n\tf[0][0][0] = 1;\n\tfor (int i = 0;i < n;i++)\n\t\tfor (int j = 0;j <= i;j++)\n\t\t\tfor (int k = 0;k <= i;k++)\n\t\t\t\tif (f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tif (s[j + 1] == '0')\n\t\t\t\t\t{\n\t\t\t\t\t\t(f[i + 1][j + 1][k + 1] += f[i][j][k]) %= MOD;\n\t\t\t\t\t\t(f[i + 1][j][k] += f[i][j][k]) %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t(f[i + 1][j][k + 1] += f[i][j][k]) %= MOD;\n\t\t\t\t\t\t(f[i + 1][j + 1][k] += f[i][j][k]) %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tint c[2] = {0};\n\t\tfor (int j = 0;j <= i;j++)\n\t\t{\n\t\t\tif (j > 0)\n\t\t\t\tc[s[j] - '0']++;\n\t\t\tfor (int k = 0;k <= i;k++)\n\t\t\t{\n\t\t\t\tif (!f[i][j][k])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (G(n - i,j + 1,k - c[0],i - k - c[1]))\n\t\t\t\t\t(ans += f[i][j][k]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n \nconst int N = 305;\n \nint n, c[N][N][N], dp[N][N][N], f[N][N], mod = 998244353;\nstring s;\n \nvoid go(int idx, int z, int o){\n    if(c[idx][z][o]) return;\n    c[idx][z][o] = 1;\n    if(z >= 2) go(idx, z - 1, o);\n    if(o >= 2) go(idx, z, o - 1);\n    if(o >= 1 && z >= 1){\n        go(idx, z - 1, o);\n        go(idx, z, o - 1);\n    }\n    if(idx < n && s[idx] == '1' && z){\n        go(idx + 1, z, o);\n        go(idx + 1, z - 1, o + 1);\n    }\n    if(idx < n && s[idx] == '0' && o){\n        go(idx + 1, z, o);\n        go(idx + 1, z + 1, o - 1);\n    }\n    if(idx < n && s[idx] == '0' && z){\n        go(idx + 1, z, o);\n    }\n    if(idx < n && s[idx] == '1' && o){\n        go(idx + 1, z, o);\n    }\n    if(idx + 1 < n && (s[idx] == '0' || s[idx + 1] == '0')){\n        go(idx + 2, z + 1, o);\n    }\n    if(idx + 1 < n && (s[idx] == '1' || s[idx + 1] == '1')){\n        go(idx + 2, z, o + 1);\n    }\n}\nint solve(int idx, int z, int o){\n    if(idx == n && z == 0 && o == 0) return 1;\n    int &ret = dp[idx][z][o];\n    if(ret != -1) return ret;\n    ret = 0;\n    // 0\n    if(s[idx] == '0') ret += solve(idx + 1, z, o);\n    else if(z) ret += solve(idx, z - 1, o);\n    if(ret >= mod) ret -= mod;\n    // 1\n    if(s[idx] == '1') ret += solve(idx + 1, z, o);\n    else if(o) ret += solve(idx, z, o - 1);\n    if(ret >= mod) ret -= mod;\n    return ret;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp, -1, sizeof dp);\n    cin >> s;\n    n = s.size();\n    go(0, 0, 0);\n    vector <int> suff(n + 1);\n    for(int i = n - 1 ; i >= 0 ; i--){\n        suff[i] = suff[i + 1];\n        suff[i] += s[i] - '0';\n    }\n    memset(f, -1, sizeof f);\n    for(int i = 0 ; i <= n ; i++){\n        for(int z = 0 ; z <= n ; z++){\n            for(int o = 0 ; o <= n ; o++){\n                if(c[i][z][o]){\n                    int zeros = n - i - suff[i] + z;\n                    int ones = suff[i] + o;\n                    f[zeros][ones] = i;\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int z = 0 ; z <= n ; z++){\n        for(int o = 0 ; o <= n ; o++){\n            int i = f[z][o];\n            if(i == -1) continue;\n            int zeros = z - (n - i - suff[i]);\n            int ones = o - suff[i];\n            ans += solve(i, zeros, ones);\n            if(ans >= mod) ans -= mod;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 305, mod = 998244353;\nint n, mem1[MX][MX][MX];\nstring s;\nll mem2[MX][MX][MX], res;\n\nint dp1 (int i, int j, int k) {\n\tif (j < 0 || k < 0) return 0;\n\tif (!i && !j && !k) return 1;\n\tif (i < 2) return 0;\n\n\tint &res = mem1[i][j][k];\n\tif (res != -1) return res;\n\tres = 0;\n\n\tif (s[i - 1] == s[i - 2]) {\n\t\tif (s[i - 1] == '0') res |= dp1(i - 2, j - 1, k);\n\t\telse res |= dp1(i - 2, j, k - 1);\n\t} else {\n\t\tres |= dp1(i - 2, j - 1, k);\n\t\tres |= dp1(i - 2, j, k - 1);\n\t}\n\n\tif (s[i - 1] == '0') {\n\t\tres |= dp1(i - 1, j - 1, k + 1);\n\t\tif (j || k) res |= dp1(i - 1, j, k);\n\t} else {\n\t\tres |= dp1(i - 1, j + 1, k - 1);\n\t\tif (j || k) res |= dp1(i - 1, j, k);\n\t}\n\n\treturn res;\n}\n\nll dp2 (int i, int j, int k) {\n\tif (j < 0 || k < 0) return 0;\n\tif (i == n && !j && !k) return 1;\n\tif (i > n) return 0;\n\n\tll &res = mem2[i][j][k];\n\tif (res != -1) return res;\n\tres = dp2(i + 1, j, k);\n\n\tif (!i || s[i - 1] != '0') res += dp2(i, j - 1, k);\n\tif (!i || s[i - 1] != '1') res += dp2(i, j, k - 1);\n\n\treturn res %= mod;\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(mem1, -1, sizeof(mem1));\n\tmemset(mem2, -1, sizeof(mem2));\n\n\tcin >> s;\n\tn = s.size();\n\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\tif (dp1(i, j, k)) {\n\t\t\t\t\tres += dp2(i, j, k);\n\t\t\t\t\tif (i && s[i - 1] == '0' && !dp1(i - 1, j - 1, k)) res += dp2(i, j - 1, k);\n\t\t\t\t\tif (i && s[i - 1] == '1' && !dp1(i - 1, j, k - 1)) res += dp2(i, j, k - 1);\n\t\t\t\t\tres %= mod;\n\t\t\t\t}\n\t\t\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*/ Author: kal013 /*/\n// #pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<class T> \nusing ordered_set = tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\n\ntemplate<class key, class value, class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\n// find_by_order(k)  returns iterator to kth element starting from 0;\n// order_of_key(k) returns count of elements strictly smaller than k;\n\nstruct custom_hash { // Credits: https://codeforces.com/blog/entry/62393\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n    os << \"[ \";\n    for(auto v : V) os << v << \" \";\n    return os << \"]\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, set<T> S){\n    os << \"{ \";\n    for(auto s:S) os<<s<<\" \";\n    return os<<\"}\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, unordered_set<T> S){\n    os << \"{ \";\n    for(auto s:S) os<<s<<\" \";\n    return os<<\"}\";\n}\ntemplate<class T> ostream& operator<<(ostream &os, ordered_set<T> S){\n    os << \"{ \";\n    for(auto s:S) os<<s<<\" \";\n    return os<<\"}\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n    return os << \"(\" << P.first << \",\" << P.second << \")\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, map<L,R> M) {\n    os << \"{ \";\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\n    return os<<\"}\";\n}\ntemplate<class L, class R> ostream& operator<<(ostream &os, unordered_map<L,R> M) {\n    os << \"{ \";\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\n    return os<<\"}\";\n}\ntemplate<class L, class R, class chash = std::hash<R> > ostream& operator<<(ostream &os, gp_hash_table<L,R,chash> M) {\n    os << \"{ \";\n    for(auto m:M) os<<\"(\"<<m.first<<\":\"<<m.second<<\") \";\n    return os<<\"}\";\n}\n\n#define TRACE\n#ifdef TRACE\n    #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n    template <typename Arg1>\n    void __f(const char* name, Arg1&& arg1){\n        cerr << name << \" : \" << arg1 << endl;\n    }\n    template <typename Arg1, typename... Args>\n    void __f(const char* names, Arg1&& arg1, Args&&... args){\n        const char* comma = strchr(names + 1, ',');\n        cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";\n        __f(comma+1, args...);\n    }\n#else\n    #define trace(...) 1\n#endif\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ninline int64_t random_long(long long l,long long r){\n    uniform_int_distribution<int64_t> generator(l,r);\n    return generator(rng);\n}\ninline int64_t random_long(){\n    uniform_int_distribution<int64_t> generator(LLONG_MIN,LLONG_MAX);\n    return generator(rng);\n}\n\n\n/*/---------------------------Defines----------------------/*/\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define ll long long\n#define F first\n#define S second\n#define pb push_back\n#define endl \"\\n\"\n#define all(v) (v).begin(),(v).end()\n/*/-----------------------Modular Arithmetic---------------/*/\n\nconst int mod = 998244353;\ntemplate<const int MOD>\nstruct modular_int{\n\tint x;\n\tstatic vector<int> inverse_list ;\n\tconst static int inverse_limit;\n\tmodular_int(){\n\t\tx = 0;\n\t}\n\ttemplate<typename T>  \n\tmodular_int(const T z){\n\t\tx = (z%MOD);\n\t\tif (x < 0) x += MOD; \t\n\t}\n\tmodular_int(const modular_int<MOD>* z){\n\t\tx = z->x;\n\t}\n\tmodular_int(const modular_int<MOD>& z){\n\t\tx = z.x;\n\t}\n\tmodular_int operator - (const modular_int<MOD>& m) const{\n\t\tmodular_int<MOD> U;\n\t\tU.x = x - m.x;\n\t\tif (U.x < 0) U.x += MOD;\n\t\treturn U;\n\t}\n\tmodular_int operator + (const modular_int<MOD>& m) const{\n\t\tmodular_int<MOD> U;\n\t\tU.x = x + m.x;\n\t\tif (U.x >= MOD) U.x -= MOD;\n\t\treturn U;\n\t}\n\tmodular_int& operator -= (const modular_int<MOD>& m){\n\t\tx -= m.x;\n\t\tif (x < 0) x += MOD;\n\t\treturn *this;\n\t}\t\n\tmodular_int& operator += (const modular_int<MOD>& m){\n\t\tx += m.x;\n\t\tif (x >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\t\n\tmodular_int operator * (const modular_int<MOD>& m) const{\n\t\tmodular_int<MOD> U;\n\t\tU.x = (x* 1ull * m.x) %MOD;\n\t\treturn U;\n\t}\n\tmodular_int& operator *= (const modular_int<MOD>& m){\n\t\tx = (x * 1ull * m.x)%MOD;\n\t\treturn *this;\n\t}\n\ttemplate<typename T>\n\tfriend modular_int operator + (const T &l, const modular_int<MOD>& p){\n\t\treturn (modular_int<MOD>(l) + p);\n\t}\n\ttemplate<typename T>\n\tfriend modular_int operator - (const T &l, const modular_int<MOD>& p){\n\t\treturn (modular_int<MOD>(l) - p);\n\t}\n\ttemplate<typename T>\n\tfriend modular_int operator * (const T &l, const modular_int<MOD>& p){\n\t\treturn (modular_int<MOD>(l) * p);\n\t}\n\ttemplate<typename T>\n\tfriend modular_int operator / (const T &l, const modular_int<MOD>& p){\n\t\treturn (modular_int<MOD>(l) / p);\n\t}\n\n\tint value() const{\n\t\treturn x;\n\t}\n\n\ttemplate<typename T>\n\tmodular_int operator ^ (T power) const{\n\t\tmodular_int<MOD> ans;\n\t\tans.x = 1;\n\t\tmodular_int<MOD> curr(this);\n\t\t// Prime Mods\n\t\tif (power >= MOD){\n\t\t\tpower %= (MOD - 1);\n\t\t}\n\n\t\twhile( power > 0){\n\t\t\tif (power&1){\n\t\t\t\tans *= curr;\n\t\t\t}\n\t\t\tpower >>= 1;\n\t\t\tif (power) curr *= curr;\n\n\t\t}\n\t\treturn ans;\n\t}\n\n\ttemplate<typename T>\n\tmodular_int pow(T x){\n\t\treturn (*this)^x;\n\t}\n\n\t\n\tpair<long long,long long> gcd(const int a, const int b) const {\n\t\tif (b==0) return {1,0}; \n\t\tpair<long long,long long> c = gcd(b , a%b);\n\t\treturn { c.second , c.first - (a/b)*c.second}; \n\t}\n\n\tinline void init_inverse_list() const {\n\t\t\n\t\tvector<int>& dp = modular_int<MOD>::inverse_list;\n\t\tdp.resize(modular_int<MOD>::inverse_limit + 1);\n\t\tint n = modular_int<MOD>::inverse_limit;\n\t\tdp[0] = 1;\n\t\tif (n > 1) dp[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i){\n\t\t\tdp[i] = (dp[MOD%i] * 1ull *(MOD - MOD/i))%MOD;\n\t\t}\n\t\n\t}\n\tmodular_int<MOD> get_inv() const {\n\t\tif (modular_int<MOD>::inverse_list.size() < modular_int<MOD>::inverse_limit + 1) init_inverse_list();\n\n\t\tif (this->x <= modular_int<MOD>::inverse_limit){\n\t\t\treturn modular_int<MOD>::inverse_list[this->x];\n\t\t}\n\n\n\t\tpair<long long,long long> G = gcd(this->x,MOD);\n\n\t\treturn modular_int<MOD>(G.first);\n\t}\n\tmodular_int operator / (const modular_int<MOD>& m) const{\n\t\tmodular_int<MOD> U(this);\n\t\tU *= m.get_inv();\n\t\treturn U;\n\t}\n\tmodular_int& operator /= (const modular_int<MOD>& m){\n\t\t(*this) *= m.get_inv();\n\t\treturn *this;\n\t}\n\n\n\tbool operator==(const modular_int<MOD>& m) const{\n\t\treturn x == m.x;\n\t}\n\ttemplate<typename T>\n\tbool operator == (const T& x) const{\n\t\treturn x== (modular_int<MOD>(x)).x;\n\t}\n\ttemplate<typename T>\n\tfriend bool operator == (const T& x, const modular_int<MOD>& m) {\n\t\treturn (modular_int<MOD>(x)).x == m.x;\n\t}\n\n\tfriend istream& operator >> (istream& is, modular_int<MOD>& p){\n\t\tint64_t val;\n\t\tis >> val;\n\t\tp.x = (val%MOD);\n\t\tif (p.x < 0) p.x += MOD;\n\t\treturn is;\n\t}\n\tfriend ostream& operator << (ostream& os, const modular_int<MOD>& p) {return os<<p.x;}\n\n\n\n};\n\n\nusing mint = modular_int<mod>;\ntemplate<const int MOD>\nvector<int> modular_int<MOD>::inverse_list ;\ntemplate<const int MOD>\nconst int modular_int<MOD>::inverse_limit = -1;\n// template<>   //-> useful if computing inverse fact = i_f[i-1] / i;\n// const int modular_int<mod>::inverse_limit = 100000;\n\n/*/-----------------------------Code begins----------------------------------/*/\n\nconst int N = 305;\n\nmint dp[N][N][N];\nbool vis2[N][N][N];\nbool vis[N][N][N];\n\nint cnt0[N],cnt1[N];\nstring s;\nint num_states = 0;\n\nstruct node{\n\tint len,c0,c1;\n\tbool operator < (const node& x) const{\n\t\treturn len < x.len;\n\t}\n\n};\nvector<node> tot[N];\n\nvoid recur(int len,int c0,int c1){\n\tassert(len >= 0 && c0 >= 0 && c1 >= 0);\n\tif (vis[len][c0][c1]){\n\t\treturn;\n\t}\n\tvis[len][c0][c1] = true;\n\t++num_states;\n\ttot[len + c0 + c1].push_back({len,c0,c1});\n\tif (len == 0) {\n\t\tif (c0 > 0 && c0 + c1 > 2){\n\t\t\trecur(len,c0-1,c1);\n\t\t}\n\t\tif (c1 > 0 && c0 + c1 > 2){\n\t\t\trecur(len,c0,c1-1);\n\t\t}\n\t\treturn;\n\t}\n\tif (len == 1){\n\t\tif (c0 + c1 > 0){\n\t\t\trecur(0,c0,c1);\n\t\t\tif (c0 > 0){\n\t\t\t\trecur(1,c0-1,c1);\n\t\t\t}\n\t\t\tif (c1 > 0){\n\t\t\t\trecur(1,c0,c1-1);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\trecur(len - 1 ,c0,c1);\n\n\trecur(len - 2, c0, c1);\n\tif (s[len - 1] == '0'){\n\t\trecur(len-2,c0+1,c1);\n\t\tif (c1 > 0) recur(len - 1,c0+1,c1-1);\n\t}\n\telse{\n\t\trecur(len-2,c0,c1+1);\n\t\tif (c0 > 0) recur(len - 1,c0-1,c1+1);\n\t}\n\n\tif (s[len-2] == '0'){\n\t\trecur(len-2,c0+1,c1);\n\t}\n\telse{\n\t\trecur(len-2,c0,c1+1);\n\t}\n}\n\n\nmint ways(int len,int c0,int c1){\n\tassert(len >= 0 && c0 >= 0 && c1 >= 0);\n\tif (vis2[len][c0][c1]){\n\t\treturn dp[len][c0][c1];\n\t}\n\tvis2[len][c0][c1] = true;\n\tmint& ans = dp[len][c0][c1];\n\tif (c0 == 0 && c1 == 0){\n\t\tans = 1;\n\t\treturn ans;\n\t}\n\tif (len == 0){\n\t\tans = 0;\n\t\tif (c0 > 0) ans += ways(len,c0-1,c1);\n\t\tif (c1 > 0) ans += ways(len,c0,c1-1);\n\n\t\treturn ans;\n\t}\n\n\tif (s[len - 1] == '0'){\n\t\tans = ways(len - 1, c0, c1);\n\t\tif (c1 > 0) ans += ways(len,c0,c1-1);\n\t}\n\telse{\n\t\tans = ways(len - 1, c0, c1);\n\t\tif (c0 > 0) ans += ways(len,c0-1,c1);\t\n\t}\n\treturn ans;\n\n}\n\n\n// void brute(string s,set<string>& S){\n// \tif (s.size() == 0) return;\n\n// \tS.insert(s);\n// \tint n = s.size();\n// \tif (s.size() == 1) return;\n\n// \tfor(int i = 0;i<n-1;++i){\n// \t\tstring t;\n// \t\tstring u;\n// \t\tint dif = 0;\n// \t\tfor(int j = 0; j<n-1;++j){\n// \t\t\tif (j == i){\n// \t\t\t\tt += s[n-1];\n// \t\t\t\tu += s[n-2]; \n// \t\t\t\t++dif;\n// \t\t\t}\n// \t\t\telse{\n// \t\t\t\tt += s[j - dif];\n// \t\t\t\tu += s[j - dif];\n// \t\t\t}\n// \t\t}\n// \t\tbrute(t,S);\n// \t\tbrute(u,S);\n// \t}\n\n\n\n// }\n\n\nvoid solve(){\n    cin>>s;\n    reverse(all(s));\n\n    // set<string> U;\n    // brute(s,U);\n\n\n\n    map<int,int> cnt_len;\n\n    // for(auto e:U){\n    \t// ++cnt_len[e.size()];\n    // }\n    recur(s.size(),0,0);\n\n    int val = 0;\n\n    cnt0[0] = 0;\n    cnt1[0] = 0;\n    for(int i = 1;i<=s.size(); ++i){\n    \tcnt0[i] = cnt0[i-1];\n    \tcnt1[i] = cnt1[i-1];\n\n    \tif (s[i-1] == '0') ++cnt0[i];\n    \telse ++cnt1[i];\n    }\n\n    mint ans = 0;\n\n    // for(auto e:U){\n    // \tif (e.size() == 4){\n    // \t\ttrace(e);\n    // \t}\n    // }\n\n    for(int i = 1;  i<=s.size(); ++i){\n    \tval += tot[i].size();\n    \tset<pair<int,int>> vis;\n    \tsort(all(tot[i]));\n    \tmint cans = 0;\n    \tfor(auto e:tot[i]){\n    \t\tint len = e.len, cur0 = e.c0, cur1 = e.c1;\n\n    \t\tpair<int,int> cnt = {cur0 + cnt0[len],cur1 + cnt1[len]};\n    \t\tif (vis.count(cnt)) continue;\n    \t\tvis.insert(cnt);\n    \t\t// trace(len,cur0,cur1,ways(len,cur0,cur1));\n\n    \t\tans += ways(len,cur0,cur1);\n\n    \t\tcans += ways(len,cur0,cur1);\n\n    \t}\n\n\n\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    // Use \"set_name\".max_load_factor(0.25);\"set_name\".reserve(512); with unordered set\n    // Or use gp_hash_table<X,null_type>\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n    cout<<fixed<<setprecision(25);\n    cerr<<fixed<<setprecision(10);\n    auto start = std::chrono::high_resolution_clock::now();\n    int t=1;\n    // cin>>t;\n    while(t--) {\n        solve();\n    }\n    auto stop = std::chrono::high_resolution_clock::now(); \n    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start); \n    \n    // cerr << \"Time taken : \" << ((long double)duration.count())/((long double) 1e9) <<\"s \"<< endl;     \n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\nusing namespace chrono;\n\n#ifdef DEBUG\n\t#define LOCAL_INPUT_FILE\n#else\n\t//~ #define USE_FILE_IO\n#endif\n\n#ifdef USE_FILE_IO\n\t#define INPUT_FILE \"input.txt\"\n\t#define OUTPUT_FILE \"output.txt\"\n\t#define cin ____cin\n\t#define cout ____cout\n\tifstream cin(INPUT_FILE);\n\tofstream cout(OUTPUT_FILE);\n#else\n\t#ifdef LOCAL_INPUT_FILE\n\t\t#define cin ____cin\n\t\tifstream cin(\"input.txt\");\n\t#endif\n#endif\n\nconst int infinity = (int)1e9 + 42;\nconst int64_t llInfinity = (int64_t)1e18 + 256;\nconst int module = (int)1e9 + 7; \nconst long double eps = 1e-8;\n\nmt19937_64 randGen(system_clock().now().time_since_epoch().count());\n\ninline void raiseError(string errorCode) {\n\tcerr << \"Error : \" << errorCode << endl;\n\texit(42);\n}\n\nsigned main() {\n\t#ifndef USE_FILE_IO\n\t\tios_base::sync_with_stdio(false);\n\t#endif\n\t\n\tconst int mod = 998'244'353;\n\t\n\tstring s; cin >> s;\n\tint n = s.size();\n\t\n\tvector<int> c0(n+1);\n\tc0[n] = 0;\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tc0[i] = c0[i+1] + (s[i] == '0');\n\t}\n\t\n\tstatic bool ok[301][301][301];\n\tstatic int mn[301][301];\n\t\n\tok[n][0][0] = true;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tmn[i][j] = INT_MAX;\n\t\t}\n\t}\n\t\n\tfor (int sm = n; sm >= 1; --sm) {\n\t\tfor (int r = 0; r <= sm; ++r) {\n\t\t\tfor (int s0 = 0; r+s0 <= sm; ++s0) {\n\t\t\t\tint s1 = sm - r - s0;\n\t\t\t\tif (!ok[r][s0][s1]) continue;\n\t\t\t\tmn[sm][s0 + c0[n-r]] = min(mn[sm][s0 + c0[n-r]], r);\n\t\t\t\t// remove two usual\n\t\t\t\tif (r >= 2) {\n\t\t\t\t\tok[r-2][s0 + (s[n-r] == '0' || s[n-r+1] == '0')][s1] = true;\n\t\t\t\t\tok[r-2][s0][s1 + (s[n-r] == '1' || s[n-r+1] == '1')] = true;\n\t\t\t\t}\n\t\t\t\t// remove one usual & one floating\n\t\t\t\tif (r >= 1 && s0 > 0) {\n\t\t\t\t\tok[r-1][s0][s1] = true;\n\t\t\t\t\tok[r-1][s0 - 1 + (s[n-r] == '0')][s1] = true;\n\t\t\t\t\tok[r-1][s0 - 1][s1 + (s[n-r] == '1')] = true;\n\t\t\t\t}\n\t\t\t\tif (r >= 1 && s1 > 0) {\n\t\t\t\t\tok[r-1][s0][s1] = true;\n\t\t\t\t\tok[r-1][s0 + (s[n-r] == '0')][s1 - 1] = true;\n\t\t\t\t\tok[r-1][s0][s1 - 1 + (s[n-r] == '1')] = true;\n\t\t\t\t}\n\t\t\t\t// remove two floating\n\t\t\t\tif (s0+s1 >= 2) {\n\t\t\t\t\tif (s0 > 0) {\n\t\t\t\t\t\tok[r][s0-1][s1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0) {\n\t\t\t\t\t\tok[r][s0][s1-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int dp[301][301][301] = {};\n\tdp[n][0][0] = 1;\n\tfor (int i = n; i >= 0; --i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tdp[i-1][j][k] += dp[i][j][k];\n\t\t\t\t\tdp[i-1][j][k] %= mod;\n\t\t\t\t}\n\t\t\t\tif (i == 0 || s[i-1] == '0') {\n\t\t\t\t\tdp[i][j][k+1] += dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1] %= mod;\n\t\t\t\t}\n\t\t\t\tif (i == 0 || s[i-1] == '1') {\n\t\t\t\t\tdp[i][j+1][k] += dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int sz = 1; sz <= n; ++sz) {\n\t\tfor (int z = 0; z <= sz; ++z) {\n\t\t\tint r = mn[sz][z];\n\t\t\tif (r == INT_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s0 = z - c0[n-r];\n\t\t\tint s1 = sz - r - s0;\n\t\t\tint p = n-r;\n\t\t\twhile (p >= 0 && s0 >= 0 && s1 >= 0) {\n\t\t\t\tans += dp[p][s0][s1];\n\t\t\t\tans %= mod;\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--p;\n\t\t\t\t--(s[p] == '0' ? s0 : s1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=3e2+5;\nconst int p=998244353;\n\nint read()\n{\n\tint s=0;\n\tchar c=getchar(),lc='+';\n\twhile (c<'0'||'9'<c) lc=c,c=getchar();\n\twhile ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();\n\treturn lc=='-'?-s:s;\n}\nvoid write(int x)\n{\n\tif (x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif (x<10) putchar(x+'0');\n\telse\n\t{\n\t\twrite(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nvoid print(int x,char c='\\n')\n{\n\twrite(x);\n\tputchar(c);\n}\nchar a[N];\nbool f[N][N][N];\nint dp[N][N][N];\nvoid add(int &x,int y)\n{\n\tx+=y;\n\tif (x>=p) x-=p;\n}\n\nsigned main()\n{\n\tmemset(f,0,sizeof(f));\n\tmemset(dp,0,sizeof(dp));\n\tscanf(\"%s\",a+1);\n\tint n=strlen(a+1),ans=0;\n\tf[0][0][0]=1;\n\tfor (int i=0;i<n;i++)\n\tfor (int j=0;j<=i;j++)\n\tfor (int k=0;k<=i;k++)\n\tif (f[i][j][k])\n\t{\n\t\tf[i+1][j][k]=1;\n\t\tif (a[i+1]=='0'||a[i+2]=='0') f[i+2][j+1][k]=1;\n\t\tif (a[i+1]=='1'||a[i+2]=='1') f[i+2][j][k+1]=1;\n\t\tif (a[i+1]=='0'&&k) f[i+1][j+1][k-1]=1;\n\t\tif (a[i+1]=='1'&&j) f[i+1][j-1][k+1]=1;\n\t}\n//\tfor (int i=1;i<=n;i++){for (int j=0;j<=i;j++){for (int k=0;k<=i;k++)putchar(f[i][j][k]+'0');puts(\"\");}puts(\"\");}\n\tdp[n][0][0]=1;\n\tfor (int i=n;i>=1;i--)\n\tfor (int j=0;j<=i;j++)\n\tfor (int k=0;k<=i;k++)\n\t{\n\t\tadd(dp[i-1][j][k],dp[i][j][k]);\n\t\tif (a[i]=='1') add(dp[i][j+1][k],dp[i][j][k]);\n\t\tif (a[i]=='0') add(dp[i][j][k+1],dp[i][j][k]);\n\t}\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<=i;j++)\n\tfor (int k=0;k<=i;k++)\n\tadd(ans,f[i][j][k]*dp[i][j][k]);\n\tprint(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n\nnamespace modular {\nconstexpr ll MOD = 998244353;\nconst int MAXN = 1100000;\ntemplate <ll Modulus> class modint {\n    using u64 = ll;\n\n  public:\n    u64 a;\n\n    constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept { return modint(*this) += rhs; }\n    constexpr modint operator-(const modint rhs) const noexcept { return modint(*this) -= rhs; }\n    constexpr modint operator*(const modint rhs) const noexcept { return modint(*this) *= rhs; }\n    template <typename T> constexpr modint operator^(T rhs) const noexcept { return modint(*this) ^= rhs; }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if(a >= Modulus) { a -= Modulus; }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if(a < rhs.a) { a += Modulus; }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr bool operator==(const modint rhs) noexcept { return a == rhs.a; }\n    template <typename T> constexpr modint &operator^=(T n) noexcept {\n        modint<Modulus> res = 1;\n        modint<Modulus> x = a;\n        while(n) {\n            if(n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        a = res.a;\n        return *this;\n    }\n};\n#define mint modint<MOD>\n#define vmint vector<mint>\nvmint Inv{0, 1}, Prd{1, 1}, Invprd{1, 1};\nmint inv(int n) {\n    if(Inv.size() > n)\n        return Inv[n];\n    else {\n        for(int i = Inv.size(); i <= n; ++i) Inv.emplace_back(Inv[MOD % i] * (-MOD / i));\n        return Inv[n];\n    }\n}\nmint prd(int n) {\n    if(Prd.size() > n)\n        return Prd[n];\n    else\n        for(int i = Prd.size(); i <= n; ++i) Prd.emplace_back(Prd[i - 1] * i);\n    return Prd[n];\n}\nmint invprd(int n) {\n    if(Invprd.size() > n)\n        return Invprd[n];\n    else\n        for(int i = Invprd.size(); i <= n; ++i) Invprd.emplace_back(Invprd[i - 1] * inv(i));\n    return Invprd[n];\n}\nmint modpow(ll a, ll n) {\n    mint x = a;\n    return x ^= n;\n}\ntemplate <ll T> modint<T> operator/(modint<T> l, modint<T> r) {\n    if(r.a < MAXN) return l * inv(r.a);\n    return l * (r ^ (MOD - 2));\n}\ntemplate <typename T, ll S> modint<S> operator/(T l, modint<S> r) { return modint<S>(l) / r; }\ntemplate <ll T> modint<T> operator/=(modint<T> &l, modint<T> r) { return l = l / r; }\nmint C(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    return prd(a) * invprd(b) * invprd(a - b);\n}\nmint P(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    return prd(a) * invprd(a - b);\n}\nostream &operator<<(ostream &os, mint a) {\n    os << a.a;\n    return os;\n}\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &a) {\n    for(auto &e : a) os << e << \" \";\n    os << endl;\n    return os;\n}\nistream &operator>>(istream &is, mint &a) {\n    ll x;\n    is >> x;\n    a = x;\n    return is;\n}\n} // namespace modular\n\nusing namespace modular;\n\nmain() {\n    STR(s);\n    if(s.size() == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    vi v;\n    for(auto e : s) v.eb(e == '1');\n    vi a{0}, b{0};\n    int n = s.size();\n    rep3(i, n - 1, 0) {\n        if(v[i])\n            a.eb(a.back() + 1), b.eb(b.back());\n        else\n            b.eb(b.back() + 1), a.eb(a.back());\n    }\n    reverse(all(a));\n    reverse(all(b));\n    vvv(int, dp, n + 1, n + 2, n + 2);\n    dp[0][0][0] = 1;\n    mint ans;\n    rep(i, n) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if(!dp[i][j][k]) continue;\n                // ans += ((mint)(b[i] + 1) ^ j) * ((mint)(a[i] + 1) ^ k);\n                if(i < n - 1) {\n                    if(v[i] or v[i + 1]) dp[i + 2][j + 1][k] |= dp[i][j][k];\n                    if(v[i] == 0 or v[i + 1] == 0) dp[i + 2][j][k + 1] |= dp[i][j][k];\n                }\n                if(v[i]) {\n                    if(j) dp[i + 1][j][k] |= dp[i][j][k];\n                    if(k) dp[i + 1][j + 1][k - 1] |= dp[i][j][k];\n                } else {\n                    if(k) dp[i + 1][j][k] |= dp[i][j][k];\n                    if(j) dp[i + 1][j - 1][k + 1] |= dp[i][j][k];\n                }\n            }\n        }\n    }\n    rep3(j, n, 0) rep3(k, n, 0) {\n        if(j) dp[n][j - 1][k] |= dp[n][j][k];\n        if(k) dp[n][j][k - 1] |= dp[n][j][k];\n    }\n    rep3(i, n, 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if(dp[i][j][k] == 1) { rep(ii, j + 1) rep(jj, k + 1) ans += C(a[i] + jj - 1, jj) * C(b[i] + ii - 1, ii) * C(j + k - ii - jj, j - ii); }\n                if(dp[i][j][k]) {\n                    if(v[i - 1]) {\n                        if(j) dp[i - 1][j - 1][k] = 2;\n                    } else if(k)\n                        dp[i - 1][j][k - 1] = 2;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//{\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define all(v) (v).begin(),(v).end()\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n\n\n#define PII pair<int,int>\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n};\n//{\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n#define jeb() fflush(stdout);\n//}\n\nint n;\nchar s[305];\nVI v;\n// mag[pos][k] na pozycji pos majac k jedynek ile \n// maksymalnie zer \nint mag[305][305];\nint mod = 998244353;\n\n//co[dl][j] dla finalnej dlugosci dl i liczby jedynek j\n//maksymalny sufix ktory musi byc \nint co[305][305];\nint suf[305];\n\nint dp[305][305][305];\n\nint rob2(int sufix, int zer, int jedynek) {\n\tif (dp[sufix][zer][jedynek] != -1) return dp[sufix][zer][jedynek];\n\tint ans = 0;\n\tif (sufix >= n) {\n\t\tif (zer == 0) return 1;\n\t\tif (jedynek == 0) return 1;\n\t\tans = rob2(sufix, zer-1, jedynek) + rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 0) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (jedynek > 0) \n\t\t\t\tans += rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 1) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (zer > 0) \n\t\t\t\tans += rob2(sufix, zer-1, jedynek);\n\t}\n\tans %= mod;\n\tdp[sufix][zer][jedynek] = ans;\n\treturn ans;\n}\n\nint rob(int sufix, int zer, int jedynek) {\n\t\treturn rob2(sufix, zer, jedynek);\n\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tFOR(i,0,n) v.pb(s[i]-'0');\n\tsuf[n] = 0;\n\tFORD(i,n-1,0) suf[i] = suf[i+1] + v[i];\n\tif (n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tFOR(i,0,n+1) FOR(j,0,n+1) mag[i][j] = -1e9;\n\tFOR(i,0,n+1) mag[i][0] = 0;\n\n\tFOR(i,2,n+1) {\n\t\t// skreslam dwa\n\t\tbool jest1 = (v[i-1] == 1 || v[i-2] == 1);\n\t\tbool jest0 = (v[i-1] == 0 || v[i-2] == 0);\t\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) mag[i][j+1] = max(mag[i][j+1], mag[i-2][j]);\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,0,n+1) mag[i][j] = max(mag[i][j], mag[i-2][j]+1);\n\t\t}\n\t\t// skreslam jeden\n\t\tjest1 = (v[i-1] == 1);\n\t\tjest0 = (v[i-1] == 0);\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) {\n\t\t\t\tif (mag[i-1][j] > 0) {\n\t\t\t\t\tmag[i][j+1] = max(mag[i][j+1], mag[i-1][j]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,1,n+1) {\n\t\t\t\tif (mag[i-1][j] >= 0) {\n\t\t\t\t\tmag[i][j-1] = max(mag[i][j-1], mag[i-1][j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFOR(i,0,n+1) FOR(j,0,n+1) co[i][j] = -1e9;\n\tFOR(i,0,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (mag[i][j] < 0) continue;\n\t\t\tFOR(k,0,mag[i][j]+1) {\n\t\t\t\tint dl = (n-i) + j + k;\n\t\t\t\tint jed = suf[i] + j;\n\t\t\t\tco[dl][jed] = max(co[dl][jed], i);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,305) FOR(j,0,305) FOR(k,0,305) dp[i][j][k] = -1;\n\tint ans = 0;\n\tFOR(i,1,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (co[i][j] >= 0) {\n\t\t\t\tint plus_jeden = j-suf[co[i][j]];\n\t\t\t\tint plus_zero = i-(n-co[i][j])-plus_jeden;\n\t\t\t\tans = ans + rob(/*pref=*/co[i][j], plus_zero, plus_jeden);\n\t\t\t\tif (ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\ntemplate <typename T>\nboolean vmin(T& a, T b) {\n  return (a > b) ? (a = b, true) : (false);\n}\ntemplate <typename T>\nboolean vmax(T& a, T b) {\n  return (a < b) ? (a = b, true) : (false);\n}\n\ntemplate <typename T>\nT smax(T x) {\n  return x;\n}\ntemplate <typename T, typename ...K>\nT smax(T a, const K &...args) {\n  return max(a, smax(args...));\n}\n\ntemplate <typename T>\nT smin(T x) {\n  return x;\n}\ntemplate <typename T, typename ...K>\nT smin(T a, const K &...args) {\n  return min(a, smin(args...));\n}\n\n// debugging lib\n\n#define VN(x) #x\n#define Vmsg(x) VN(x) << \" = \" << (x)\n#define printv(x) cerr << VN(x) << \" = \" << (x);\n#define debug(...) fprintf(stderr, __VA_ARGS__);\n\ntemplate <typename A, typename B>\nostream& operator << (ostream& os, const pair<A, B>& z) {\n  os << \"(\" << z.first << \", \" << z.second << ')';\n  return os;\n}\ntemplate <typename T>\nostream& operator << (ostream& os, const vector<T>& a) {\n  boolean isfirst = true;\n  os << \"{\";\n  for (auto z : a) {\n    if (!isfirst) {\n      os << \", \";\n    }\n    os << z;\n    isfirst = false;\n  }\n  os << '}';\n  return os;\n}\n\n#define pii pair<int, int>\n#define pil pair<int, ll>\n#define pli pair<ll, int>\n#define ll long long\n#define ull unsigned long long\n\nconst int inf = (signed) (~0u >> 2);\nconst ll llf = (signed ll) (~0ull >> 2);\n\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define sc second\n\ntemplate <typename T>\nint vsize(vector<T>& x) {\n  return (signed) x.size(); \n}\n\ntemplate <typename T>\nint discrete(T* a, int* b, int n) {\n  vector<T> v(a + 1, a + n + 1);\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n  for (int i = 1; i <= n; i++) b[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin() + 1;\n  return v.size();\n}\n\nmt19937 rng (time(NULL));\n\nint randint(int l, int r) {\n  return rng() % (r - l + 1) + l;\n}\n\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1, y = 0;\n  } else {\n    exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n}\n\nint inv(int a, int n) {\n  int x, y;\n  exgcd(a, n, x, y);\n  return (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 998244353;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n  public:\n    int v;\n\n    Z() : v(0) {\t}\n    Z(int x) : v(x){\t}\n    Z(ll x) : v(x % Mod) {\t}\n\n    friend Z operator + (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n    }\n    friend Z operator - (const Z& a, const Z& b) {\n      int x;\n      return Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n    }\n    friend Z operator * (const Z& a, const Z& b) {\n      return Z(a.v * 1ll * b.v);\n    }\n    friend Z operator ~(const Z& a) {\n      return inv(a.v, Mod);\n    }\n    friend Z operator - (const Z& a) {\n      return Z(0) - a;\n    }\n    Z& operator += (Z b) {\n      return *this = *this + b;\n    }\n    Z& operator -= (Z b) {\n      return *this = *this - b;\n    }\n    Z& operator *= (Z b) {\n      return *this = *this * b;\n    }\n    friend boolean operator == (const Z& a, const Z& b) {\n      return a.v == b.v;\n    } \n};\n\nZ<> qpow(Z<> a, int p) {\n  Z<> rt = Z<>(1), pa = a;\n  for ( ; p; p >>= 1, pa = pa * pa) {\n    if (p & 1) {\n      rt = rt * pa;\n    }\n  }\n  return rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 305;\n\nint n;\nchar s[N];\nbool f[N][N][N];\nZi g[N][N][N];\n\nset<string> S;\n\nvoid check(string t) {\n  int len = t.length();\n  int p = n, x = 0, y = 0;\n  for (int i = len; i--; ) {\n    if (t[i] == s[p]) {\n      p--;\n    } else {\n      (t[i] == '0' ? x : y)++;\n    }\n  }\n  if (!f[p][x][y]) {\n    cerr << t << '\\n';\n  }\n}\n\nvoid dfs(string s) {\n  if (S.count(s)) return;\n  S.insert(s);\n  check(s);\n  if (s.length() < 2u)\n    return;\n  string t = s;\n  t.erase(t.begin());\n  t.erase(t.begin());\n  char x = s[0], y = s[1];\n  for (int i = 0; i < (signed) t.size(); i++) {\n    string nt = t;\n    nt.insert(nt.begin() + i, x);\n    dfs(nt);\n    nt = t;\n    nt.insert(nt.begin() + i, y);\n    dfs(nt);\n  }\n  string nt = t;\n  nt += x;\n  dfs(nt);\n  nt = t;\n  nt += y; \n  dfs(nt);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0), cout.tie(0);\n  cin >> (s + 1);\n  n = strlen(s + 1);\n  f[0][0][0] = true;\n  for (int i = 1; i <= n; i++) {\n    for (int j = n; ~j; j--) {\n      for (int k = n; ~k; k--) {\n        if (i == n && !j && !k) continue;\n        f[i][j][k] |= f[i - 1][j][k];\n        if (s[i] == '0') f[i][j][k] |= f[i][j][k + 1];\n        if (s[i] == '1') f[i][j][k] |= f[i][j + 1][k];\n      } \n    }\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        if (i > 1) {\n          if ((s[i] == '0' || s[i - 1] == '0') && j) {\n            f[i][j][k] |= f[i - 2][j - 1][k];\n          }\n          if ((s[i] == '0' && s[i - 1] == '0') && j) {\n            f[i][j][k] |= f[i - 1][j - 1][k + 1];\n          }\n          if ((s[i] == '1' || s[i - 1] == '1') && k) {\n            f[i][j][k] |= f[i - 2][j][k - 1];\n          }\n          if ((s[i] == '1' && s[i - 1] == '1') && k) {\n            f[i][j][k] |= f[i - 1][j + 1][k - 1];\n          }\n        }\n      }\n    }\n  }\n  g[n + 1][0][0] = 1;\n  for (int i = n + 1; i > 1; i--) {\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        Zi v = g[i][j][k];\n        if (!v.v)\n          continue;\n        g[i - 1][j][k] += v;\n        if (s[i - 1] == '0')\n          g[i][j][k + 1] += v;\n        if (s[i - 1] == '1')\n          g[i][j + 1][k] += v;\n      }\n    }\n  }\n  Zi ans = 0;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      for (int k = 0; k <= i; k++) {\n        if (f[i][j][k]) {\n          ans += g[i + 1][j][k];\n//          cerr << g[i + 1][j][k].v << \" \" << i + 1 << \" \" << j << \" \"<< k << '\\n';\n        }\n      }\n    }\n  }\n//  dfs(string(s + 1));\n  printf(\"%d\\n\", ans.v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 300\n#define X 998244353\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,m,a[N+5],f[N+5][N+5][N+5];char s[N+5];\nint main()\n{\n\tRI i,j,k,cnt=1;for(scanf(\"%s\",s+1),n=strlen(s+1),i=1;i<=n;++i) s[i]^'0'?++a[cnt]:++cnt;//转化\n\tRI p;scanf(\"%d\",&m),m=min(n,m),f[0][0][0]=1;//初始化\n\tfor(i=0;i^cnt;++i) for(j=0;j<=m;++j) for(k=0;k<=m;++k) if(f[i][j][k])//枚举状态，如果状态能达到再去刷表\n\t{\n\t\tInc(f[i+1][j][k],f[i][j][k]);//不操作\n\t\tfor(p=m-j;p;--p) Inc(f[i+1][j+p][k+p],f[i][j][k]);//加上一个数\n\t\tfor(p=min(a[i+1],k);p;--p) Inc(f[i+1][j][k-p],f[i][j][k]);//减去一个数\n\t}\n\tRI t=0;for(i=0;i<=m;++i) Inc(t,f[cnt][i][0]);return printf(\"%d\\n\",t),0;//输出答案\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n\n#pragma region cp_template\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\nconstexpr char eoln = '\\n';\ntemplate <class T> T ceildiv(const T &l, const T &r) {\n  return l / r + (l % r != 0 ? 1 : 0);\n}\n\n} // namespace n91\n\n#pragma endregion cp_template\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t mod> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 v;\n\n  constexpr modint(const u64 x = 0) noexcept : v(x % mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#include <array>\n\nnamespace n91 {\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  using mint = modint<998244353>;\n\n  const std::vector<usize> s = []() {\n    const std::string s = scan<std::string>();\n    std::vector<usize> ret;\n    for (const usize i : rep(0, s.size())) {\n      ret.push_back(s[i] == '1');\n    }\n    return ret;\n  }();\n  const usize n = s.size();\n\n  auto able = md_vec(n + 1, n + 2, n + 2, u32(0));\n  able[0][0][0] = 1;\n  for (const usize i : rep(0, n + 1)) {\n    for (const usize j : revrep(0, n + 1)) {\n      for (const usize k : revrep(0, n + 1)) {\n        const auto cu = able[i][j][k];\n        if (i + 2 <= n) {\n          able[i + 2][j + !s[i]][k + s[i]] |= cu;\n          able[i + 2][j + !s[i + 1]][k + s[i + 1]] |= cu;\n        }\n        if (i + 1 <= n) {\n          if (j + k >= 1) {\n            able[i + 1][j][k] |= cu;\n          }\n          if (j >= 1) {\n            able[i + 1][j - 1 + !s[i]][k + s[i]] |= cu;\n          }\n          if (k >= 1) {\n            able[i + 1][j + !s[i]][k - 1 + s[i]] |= cu;\n          }\n        }\n        if (k + j >= 2) {\n          if (k >= 1) {\n            able[i][j][k - 1] |= cu;\n          }\n          if (j >= 1) {\n            able[i][j - 1][k] |= cu;\n          }\n        }\n      }\n    }\n  }\n\n  for (const usize i : rep(0, n)) {\n    for (const usize j : rep(0, n + 2)) {\n      able[i][j][n + 1] = 0;\n      able[i][n + 1][j] = 0;\n    }\n  }\n\n  /*\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        able[i][j][k] |= able[i + 1][j + !s[i]][k + s[i]];\n      }\n    }\n  }\n  */\n\n  mint ans = 0;\n\n  auto dp = md_vec(n + 2, n + 2, mint(0));\n  dp[0][0] = 1;\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        dp[j + s[i]][k + !s[i]] += dp[j][k];\n      }\n    }\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        if (able[i + 1][j][k]) {\n          ans += dp[j][k];\n        }\n      }\n    }\n\n    // auto nx = md_vec(n + 2, n + 2, mint(0));\n  }\n\n  ans += 1;\n\n  std::cout << ans.v << eoln;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=305,Mod=998244353;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nchar s[MAXN];int n,a[MAXN],f[MAXN][MAXN][MAXN],g[MAXN][MAXN][MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n\tfreopen(\"std.out\",\"w\",stdout);\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tRep(i,1,n)a[i]=s[i]^48;g[0][0][0]=1;\n\tRep(i,1,n){\n\t\tRed(j,n,0)Red(k,n,0){\n\t\t\tg[i][j][k]|=g[i-1][j][k];\n\t\t\tif(a[i]==0)g[i][j][k]|=g[i][j][k+1];\n\t\t\tif(a[i]==1)g[i][j][k]|=g[i][j+1][k];\n\t\t}\n\t\tRep(j,0,n)Rep(k,0,n)if(i>1){\n\t\t\tif((a[i]==0||a[i-1]==0)&&j)g[i][j][k]|=g[i-2][j-1][k];\n\t\t\tif((a[i]==0&&a[i-1]==0)&&j)g[i][j][k]|=g[i-1][j-1][k+1];\n\t\t\tif((a[i]==1||a[i-1]==1)&&k)g[i][j][k]|=g[i-2][j][k-1];\n\t\t\tif((a[i]==1&&a[i-1]==1)&&k)g[i][j][k]|=g[i-1][j+1][k-1];\n\t\t}\n\t}\n\tf[n+2][0][0]=1,a[0]=-1;\n\tRed(i,n+1,1){\n\t\tRep(j,0,n)Rep(k,0,n)f[i][j][k]=f[i+1][j][k];\n\t\tif(a[i-1]!=1)Rep(j,0,n)Rep(k,1,n)f[i][j][k]=(f[i][j][k]+f[i][j][k-1])%Mod;\n\t\tif(a[i-1]!=0)Rep(j,1,n)Rep(k,0,n)f[i][j][k]=(f[i][j][k]+f[i][j-1][k])%Mod;\n\t}int c0=0,c1=0,ans=0;\n\tRep(i,1,n+1)Rep(j,0,n)Rep(k,0,n)if(g[i-1][j][k])ans=(ans+f[i][j][k])%Mod;\n\tcout<<(ans-1+Mod)%Mod<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[305][305][305];\nint n,sumz[305],sumo[305],mx[305][305];\nMint dp[305][305][305],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k+j<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <assert.h>\n#include <math.h>\n#include <memory.h>\n#include <stdio.h>\n\n#include <algorithm>\n#include <complex>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define left asdgashgrketwjklrej\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-12\n#define M_PI 3.141592653589793\n#define bsize 1024\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 998244353\n\nconst int N = 500031;\n\nint dp[3][331][331];\nint n;\nstring st;\nint len;\nint C0[N],C1[N];\nint can_get0[N],can_get1[N];\nint can1[331][331],can0[331][331];\nint first_dp[5][331][331];\n\nint count_pairs(int x){\n\treturn (x+1)/2;\n}\n\nint DD(int x){\n\treturn count_pairs(x);\n}\n\nset<string> used;\nset<string>::iterator it;\n\nstring gi(string s,int ps,char c){\n\ts.insert(s.begin()+ps,c);\n\treturn s;\n}\n\nvoid dfs(string st){\n\tused.insert(st);\n\tif (st.size()<2)\n\t\treturn;\n\tstring temp=\"\";\n\tfor (int i=2;i<st.size();i++){\n\t\ttemp+=st[i];\n\t}\n\tfor (int i=0;i<=temp.size();i++){\n\t\tstring temp2=gi(temp,i,st[0]);\n\t\tif (used.find(temp2)==used.end())\n\t\t\tdfs(temp2);\n\t\ttemp2=gi(temp,i,st[1]);\n\t\tif (used.find(temp2)==used.end())\n\t\t\tdfs(temp2);\n\t}\n}\n\nbool cmp(string a,string b){\n\tif (a.size()!=b.size())\n\t\treturn a.size()<b.size();\n\treturn a<b;\n}\n\nint CC[N];\nint CC2[N];\n\nvoid generate(string st){\n\tused.clear();\n\tdfs(st);\n\tvector<string> order;\n\tfor (it=used.begin();it!=used.end();it++){\n//\t\tcout<<(*it)<<endl;\n\t\torder.push_back(*it);\n\t}\n\tsort(order.begin(),order.end(),cmp);\n\tfor (int i=0;i<order.size();i++){\n\t\tcout<<order[i]<<endl;\n\t\tCC[order[i].size()]++;\n\t}\n\n\tcout<<\"!!\"<<order.size()<<endl;\n}\n\nint main() {\n  // freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", sttextdout);\n  ios_base::sync_with_stdio(0);\n  // cin.tie(0);\n\n  cin>>st;\n\n  if (st.size()%2==1)\n\t  return 1;\n\n  //generate(st);\n\n  n=st.size();\n\n  for (int i=0;i<st.size();i++){\n\t  C0[i+1]=C0[i];\n\t  C1[i+1]=C1[i];\n\t  if (st[i]=='0')\n\t\t  C0[i+1]++;\n\t  else\n\t\t  C1[i+1]++;\n  }\n\n  first_dp[0][0][0]=1;\n\n  for (int i=0;i<=n;i++){\n\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[(i+3)%4][j][q]=0;\n\t\t  }\n\t  }\n\n\t  for (int have0=0;have0<=i;have0++){\n\t\t  for (int bonus=0;bonus<=i;bonus++){\n\t\t\t  if (first_dp[i%4][have0][bonus]==0)\n\t\t\t\t  continue;\n\t\t\t  //can0[i][have0]=1;\n\t\t\t  can0[n-i+bonus][have0]=1;\n\t\t\t  // use bonus to grab it\n\t\t\t  if (bonus>0&&i<n&&st[i]=='0')\n\t\t\t\t  first_dp[(i+1)%4][have0+1][bonus-1]=1;\n\t\t\t  // take either of the two\n\t\t\t  if (i<n&&st[i]=='0')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  if (i+1<n&&st[i+1]=='0')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  // bonus either of the two\n\t\t\t  if (i<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\t\t\t  if (i+1<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\n\t\t  }\n\t  }\n  }\n\n  for (int i=0;i<4;i++){\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[i][j][q]=0;\n\t\t  }\n\t  }\n  }\n\n  // CP , same for 1\n\n  first_dp[0][0][0]=1;\n\n\n  for (int i=0;i<=n;i++){\n\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[(i+3)%4][j][q]=0;\n\t\t  }\n\t  }\n\n\t  for (int have0=0;have0<=i;have0++){\n\t\t  for (int bonus=0;bonus<=i;bonus++){\n\t\t\t  if (first_dp[i%4][have0][bonus]==0)\n\t\t\t\t  continue;\n\t\t\t  //can1[i][have0]=1;\n\t\t\t  can1[n-i+bonus][have0]=1;\n\t\t\t  // use bonus to grab it\n\t\t\t  if (bonus>0&&i<n&&st[i]=='1')\n\t\t\t\t  first_dp[(i+1)%4][have0+1][bonus-1]=1;\n\t\t\t  // take either of the two\n\t\t\t  if (i<n&&st[i]=='1')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  if (i+1<n&&st[i+1]=='1')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  // bonus either of the two\n\t\t\t  if (i<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\t\t\t  if (i+1<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\n\t\t  }\n\t  }\n  }\n\n  for (int i=0;i<=n;i++){\n\t  for (int j=0;j<=n;j++){\n\t\t  if (can0[i][j])\n\t\t\t  can_get0[i]=j;\n\t\t  if (can1[i][j])\n\t\t\t  can_get1[i]=j;\n\t  }\n  }\n\n  for (int i=n-1;i>=0;i--){\n\t  can_get0[i]=max(can_get0[i],can_get0[i+1]);\n\t  can_get1[i]=max(can_get1[i],can_get1[i+1]);\n  }\n\n  /*for (int i=0;i<=n;i++){\n\t  cout<<can_get0[i]<<\" \"<<can_get1[i]<<endl;\n  }\n*/\n\n  int ans=0;\n\n  dp[0][0][0]=1;\n  for (int len=0;len<=n;len++){\n\n\t  if (len>0){\n\t\t  for (int cover=0;cover<=len;cover++){\n\t\t\t  for (int count0=0;count0<=len;count0++){\n\t\t\t\t  if (dp[len%2][cover][count0]==0)\n\t\t\t\t\t  continue;\n\t\t\t\t  int added0=count0-(C0[n]-C0[n-cover]);\n\t\t\t\t  int count1=len-count0;\n\t\t\t\t  int added1=count1-(C1[n]-C1[n-cover]);\n\t\t\t\t  int T=n-cover;\n\t\t\t\t  int iters=n-len;\n\t\t\t\t  T=min(T,iters*2);\n\t\t\t\t  if (can_get0[len]>=added0&&can_get1[len]>=added1&&len<=n-DD(n-cover)){\n\t\t\t\t\t  if (len==5)\n\t\t\t\t\t\t  cout<<len<<\" \"<<cover<<\" \"<<count0<<\" \"<<added0<<\" \"<<count1<<\" \"<<added1<<\" \"<<dp[len%2][cover][count0]<<endl;\n\t\t\t\t\t  ans+=dp[len%2][cover][count0];\n\t\t\t\t\t  CC2[len]+=dp[len%2][cover][count0];\n\t\t\t\t  }\n\t\t\t\t  ans%=bs;\n\t\t\t  }\n\t\t  }\n\t  }\n\n\t  for (int i=0;i<=300;i++){\n\t\t  for (int j=0;j<=300;j++){\n\t\t\t  dp[1-len%2][i][j]=0;\n\t\t  }\n\t  }\n\n\t  for (int cover=0;cover<=len;cover++){\n\t\t  for (int count0=0;count0<=len;count0++){\n\t\t\t  for (int ad=0;ad<=1;ad++){\n\t\t\t\t  int new_cover=cover;\n\t\t\t\t  int new0=count0+1-ad;\n\t\t\t\t  if (cover<n&&st[n-cover-1]==ad+48)\n\t\t\t\t\t  new_cover++;\n\t\t\t\t  dp[1-len%2][new_cover][new0]+=dp[len%2][cover][count0];\n\t\t\t\t  dp[1-len%2][new_cover][new0]%=bs;\n\t\t\t  }\n\t\t  }\n\t  }\n\n  }\n\n  cout<<ans<<endl;\n\n  /*for (int i=0;i<=n;i++){\n\t  cout<<i<<\" \"<<CC[i]<<\"   \"<<CC2[i]<<endl;\n  }*/\n  //cout<<n<<endl;\n\n  cin.get(); cin.get();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i, a, b) for(ll i = a; i <= b; ++i)\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define rep3(i, a, b) for(ll i = a; i >= b; --i)\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define fi first\n#define se second\n#define all(c) begin(c), end(c)\n#define ios ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\nusing namespace std;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define ULL(...)                                                                                                                                               \\\n    ull __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define LD(...)                                                                                                                                                \\\n    ld __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\nint scan() { return getchar(); }\ntemplate <class T> void scan(T a) { cin >> a; }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(long double &a) { cin >> a; }\nvoid scan(char a[]) { scanf(\"%s\", a); }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T, size_t size> void scan(array<T, size> &);\ntemplate <class T, class L> void scan(pair<T, L> &);\ntemplate <class T, size_t size> void scan(T (&)[size]);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(deque<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, size_t size> void scan(array<T, size> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T, class L> void scan(pair<T, L> &p) {\n    scan(p.first);\n    scan(p.second);\n}\ntemplate <class T, size_t size> void scan(T (&a)[size]) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &... tail) {\n    scan(head);\n    IN(tail...);\n}\nstring stin() {\n    string s;\n    cin >> s;\n    return s;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvi iota(int n) {\n    vi a(n);\n    iota(all(a), 0);\n    return a;\n}\ntemplate <class T> void UNIQUE(vector<T> &x) {\n    sort(all(x));\n    x.erase(unique(all(x)), x.end());\n}\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\nvoid print() { putchar(' '); }\nvoid print(bool a) { cout << a; }\nvoid print(int a) { cout << a; }\nvoid print(long long a) { cout << a; }\nvoid print(char a) { cout << a; }\nvoid print(string &a) { cout << a; }\nvoid print(double a) { cout << a; }\ntemplate <class T> void print(const vector<T> &);\ntemplate <class T, size_t size> void print(const array<T, size> &);\ntemplate <class T, class L> void print(const pair<T, L> &p);\ntemplate <class T, size_t size> void print(const T (&)[size]);\ntemplate <class T> void print(const vector<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n    cout << endl;\n}\ntemplate <class T> void print(const deque<T> &a) {\n    if(a.empty()) return;\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, size_t size> void print(const array<T, size> &a) {\n    print(a[0]);\n    for(auto i = a.begin(); ++i != a.end();) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T, class L> void print(const pair<T, L> &p) {\n    cout << '(';\n    print(p.first);\n    cout << \",\";\n    print(p.second);\n    cout << ')';\n}\ntemplate <class T> void print(set<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T> void print(multiset<T> &x) {\n    for(auto e : x) print(e), cout << \" \";\n    cout << endl;\n}\ntemplate <class T, size_t size> void print(const T (&a)[size]) {\n    print(a[0]);\n    for(auto i = a; ++i != end(a);) {\n        cout << \" \";\n        print(*i);\n    }\n}\ntemplate <class T> void print(const T &a) { cout << a; }\nint out() {\n    putchar('\\n');\n    return 0;\n}\ntemplate <class T> int out(const T &t) {\n    print(t);\n    putchar('\\n');\n    return 0;\n}\ntemplate <class Head, class... Tail> int out(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n    return 0;\n}\nll gcd(ll a, ll b) {\n    while(b) {\n        ll c = b;\n        b = a % b;\n        a = c;\n    }\n    return a;\n}\nll lcm(ll a, ll b) {\n    if(!a || !b) return 0;\n    return a * b / gcd(a, b);\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for(int i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    sort(all(y));\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\nint popcount(ll x) { return __builtin_popcountll(x); }\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n) { return uniform_int_distribution<int>(0, n - 1)(rng); }\n#define endl '\\n'\nvector<string> YES{\"NO\", \"YES\"};\nvector<string> Yes{\"No\", \"Yes\"};\nvector<string> yes{\"no\", \"yes\"};\n\n#ifdef _LOCAL\n#undef endl\n#define debug(x)                                                                                                                                               \\\n    cout << #x << \": \";                                                                                                                                        \\\n    print(x);                                                                                                                                                  \\\n    cout << endl;\nvoid err() {}\ntemplate <class T> void err(const T &t) {\n    print(t);\n    cout << \" \";\n}\ntemplate <class Head, class... Tail> void err(const Head &head, const Tail &... tail) {\n    print(head);\n    putchar(' ');\n    out(tail...);\n}\n#else\n#define debug(x)\ntemplate <class... T> void err(const T &...) {}\n#endif\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    // edge(int from,int to,T cost,int id):from(from),to(to),cost(cost),id(id){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedTree = vector<Edges<T>>;\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\nusing Graph = vector<vector<int>>;\nusing tree = vector<vector<int>>;\n\ntree getTree(int n, int offset = 1) {\n    tree res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate <typename T> WeightedTree<T> getWeightedTree(int n, int offset = 1) {\n    WeightedTree<T> res(n);\n    for(int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n    return res;\n}\n\nGraph getGraph(int n, int m, int offset = 1) {\n    Graph res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a -= offset, b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\n\ntemplate <typename T> WeightedGraph<T> getWeightedGraph(int n, int m, int offset = 1) {\n    WeightedGraph<T> res(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        T c;\n        cin >> c;\n        res[a].emplace_back(b, c);\n        res[b].emplace_back(a, c);\n    }\n}\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(15);\n    }\n} setup_io;\n#pragma endregion\n\n// _________コーディングはここから！！___________\n// ... 最小側の制約も確認した？\n// ... オーバーフローしない？\n\nnamespace modular {\nconstexpr ll MOD = 998244353;\nconst int MAXN = 1100000;\ntemplate <ll Modulus> class modint {\n    using u64 = ll;\n\n  public:\n    u64 a;\n\n    constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept { return modint(*this) += rhs; }\n    constexpr modint operator-(const modint rhs) const noexcept { return modint(*this) -= rhs; }\n    constexpr modint operator*(const modint rhs) const noexcept { return modint(*this) *= rhs; }\n    template <typename T> constexpr modint operator^(T rhs) const noexcept { return modint(*this) ^= rhs; }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if(a >= Modulus) { a -= Modulus; }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if(a < rhs.a) { a += Modulus; }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr bool operator==(const modint rhs) noexcept { return a == rhs.a; }\n    template <typename T> constexpr modint &operator^=(T n) noexcept {\n        modint<Modulus> res = 1;\n        modint<Modulus> x = a;\n        while(n) {\n            if(n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        a = res.a;\n        return *this;\n    }\n};\n#define mint modint<MOD>\n#define vmint vector<mint>\nvmint Inv{0, 1}, Prd{1, 1}, Invprd{1, 1};\nmint inv(int n) {\n    if(Inv.size() > n)\n        return Inv[n];\n    else {\n        for(int i = Inv.size(); i <= n; ++i) Inv.emplace_back(Inv[MOD % i] * (-MOD / i));\n        return Inv[n];\n    }\n}\nmint prd(int n) {\n    if(Prd.size() > n)\n        return Prd[n];\n    else\n        for(int i = Prd.size(); i <= n; ++i) Prd.emplace_back(Prd[i - 1] * i);\n    return Prd[n];\n}\nmint invprd(int n) {\n    if(Invprd.size() > n)\n        return Invprd[n];\n    else\n        for(int i = Invprd.size(); i <= n; ++i) Invprd.emplace_back(Invprd[i - 1] * inv(i));\n    return Invprd[n];\n}\nmint modpow(ll a, ll n) {\n    mint x = a;\n    return x ^= n;\n}\ntemplate <ll T> modint<T> operator/(modint<T> l, modint<T> r) {\n    if(r.a < MAXN) return l * inv(r.a);\n    return l * (r ^ (MOD - 2));\n}\ntemplate <typename T, ll S> modint<S> operator/(T l, modint<S> r) { return modint<S>(l) / r; }\ntemplate <ll T> modint<T> operator/=(modint<T> &l, modint<T> r) { return l = l / r; }\nmint C(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    return prd(a) * invprd(b) * invprd(a - b);\n}\nmint P(int a, int b) {\n    if(a < 0 || b < 0) return 0;\n    if(a < b) return 0;\n    return prd(a) * invprd(a - b);\n}\nostream &operator<<(ostream &os, mint a) {\n    os << a.a;\n    return os;\n}\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &a) {\n    for(auto &e : a) os << e << \" \";\n    os << endl;\n    return os;\n}\nistream &operator>>(istream &is, mint &a) {\n    ll x;\n    is >> x;\n    a = x;\n    return is;\n}\n} // namespace modular\n\nusing namespace modular;\n\nmain() {\n    STR(s);\n    if(s.size() == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    vi v;\n    for(auto e : s) v.eb(e == '1');\n    vi a{0}, b{0};\n    int n = s.size();\n    rep3(i, n - 1, 0) {\n        if(v[i])\n            a.eb(a.back() + 1), b.eb(b.back());\n        else\n            b.eb(b.back() + 1), a.eb(a.back());\n    }\n    reverse(all(a));\n    reverse(all(b));\n    vvv(int, dp, n + 1, n + 2, n + 2);\n    dp[0][0][0] = 1;\n    mint ans;\n    rep(i, n) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if(!dp[i][j][k]) continue;\n                // ans += ((mint)(b[i] + 1) ^ j) * ((mint)(a[i] + 1) ^ k);\n                if(i < n - 1) {\n                    if(v[i] or v[i + 1]) dp[i + 2][j + 1][k] |= dp[i][j][k];\n                    if(v[i] == 0 or v[i + 1] == 0) dp[i + 2][j][k + 1] |= dp[i][j][k];\n                }\n                if(v[i]) {\n                    if(j) dp[i + 1][j][k] |= dp[i][j][k];\n                    if(k) dp[i + 1][j + 1][k - 1] |= dp[i][j][k];\n                } else {\n                    if(k) dp[i + 1][j][k] |= dp[i][j][k];\n                    if(j) dp[i + 1][j - 1][k + 1] |= dp[i][j][k];\n                }\n            }\n        }\n    }\n    rep3(j, n, 0) rep3(k, n, 0) {\n        if(j) dp[n][j - 1][k] |= dp[n][j][k];\n        if(k) dp[n][j][k - 1] |= dp[n][j][k];\n    }\n    rep3(i, n, 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if(dp[i][j][k] == 1) {\n                    rep(ii, j + 1) rep(jj, k + 1) ans += C(a[i], jj) * C(b[i], ii) * C(j + k - ii - jj, j - ii);\n                }\n                if(dp[i][j][k]) {\n                    if(v[i - 1]) {\n                        if(j) dp[i - 1][j - 1][k] = 2;\n                    } else if(k)\n                        dp[i - 1][j][k - 1] = 2;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 300;\nconst int MOD = 998244353;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return (int)(1LL * x * y % MOD);}\n\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\tfor(int i=p;i;i>>=1,b=mul(b,b))\n\t\tif( i & 1 ) ret = mul(ret, b);\n\treturn ret;\n}\n\nint comb[2*MAXN + 5][2*MAXN + 5];\nint dp[MAXN + 5][MAXN + 5][MAXN + 5];\nbool f[MAXN + 5][MAXN + 5][MAXN + 5];\nchar s[MAXN + 5]; int n;\n\nint main() {\n\tfor(int i=0;i<=2*MAXN;i++) {\n\t\tcomb[i][0] = 1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tcomb[i][j] = add(comb[i-1][j], comb[i-1][j-1]);\n\t}\n\t\n\tscanf(\"%s\", s), n = strlen(s);\n\t\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tdp[n][i][j] = comb[i + j][i];\n\tfor(int i=n-1;i>=0;i--) {\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tfor(int k=0;k<=i;k++) {\n\t\t\t\tdp[i][j][k] = add(dp[i][j][k], dp[i + 1][j][k]);\n\t\t\t\tif( s[i] == '0' && k ) dp[i][j][k] = add(dp[i][j][k], dp[i][j][k - 1]);\n\t\t\t\tif( s[i] == '1' && j ) dp[i][j][k] = add(dp[i][j][k], dp[i][j - 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tf[0][0][0] = true;\n\tfor(int i=0;i<=n;i++) {\n\t\tfor(int j=i;j>=0;j--) {\n\t\t\tfor(int k=i;k>=0;k--) {\n\t\t\t\tif( j && j + k >= 2 ) f[i][j - 1][k] |= f[i][j][k];\n\t\t\t\tif( k && j + k >= 2 ) f[i][j][k - 1] |= f[i][j][k];\n\t\t\t\t\n\t\t\t\tif( i + 1 <= n ) {\n\t\t\t\t\tif( j && s[i] == '1' ) f[i + 1][j - 1][k + 1] |= f[i][j][k];\n\t\t\t\t\tif( k && s[i] == '0' ) f[i + 1][j + 1][k - 1] |= f[i][j][k];\n\t\t\t\t\tif( j + k ) f[i + 1][j][k] |= f[i][j][k];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( i + 2 <= n ) {\n\t\t\t\t\tif( s[i] == '0' || s[i + 1] == '0' ) f[i + 2][j + 1][k] |= f[i][j][k];\n\t\t\t\t\tif( s[i] == '1' || s[i + 1] == '1' ) f[i + 2][j][k + 1] |= f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=n;i>=0;i--) {\n\t\tfor(int j=i;j>=0;j--) {\n\t\t\tfor(int k=i;k>=0;k--) {\n//\t\t\t\tprintf(\"%d %d %d : %d %d\\n\", i, j, k, f[i][j][k], dp[i][j][k]);\n\t\t\t\tif( !f[i][j][k] ) continue;\n\t\t\t\tans = add(ans, dp[i][j][k]);\n\t\t\t\t\n\t\t\t\tint cnt[2] = {};\n\t\t\t\tfor(int l=i-1;l>=0;l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tif( j < cnt[0] || k < cnt[1] ) break;\n\t\t\t\t\tf[l][j - cnt[0]][k - cnt[1]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool sub[310][310][310];\nMint dp[310][310][310];\nMint comb[310][310];\n\nint main() {\n    rep(i, 310) {\n        comb[i][0] = comb[i][i] = 1;\n        for (int j = 1; j < i; ++j) {\n            comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n        }\n    }\n\n    string S;\n    cin >> S;\n\n    int n = S.size();\n    sub[0][0][0] = 1;\n\n    rep(i, n) {\n        rep(j, i + 1) {\n            rep(k, i + 1 - j) {\n                if (sub[i][j][k]) {\n                    if (S[i] == '0') {\n                        if (k) {\n                            sub[i + 1][j + 1][k - 1] = 1;\n                            sub[i + 1][j][k] = 1;\n                        }\n                        if (j) {\n                            sub[i + 1][j][k] = 1;\n                        }\n                    } else {\n                        if (j) {\n                            sub[i + 1][j - 1][k + 1] = 1;\n                            sub[i + 1][j][k] = 1;\n                        }\n                        if (k) {\n                            sub[i + 1][j][k] = 1;\n                        }\n                    }\n\n                    if (i + 2 <= n) {\n                        int p = S[i] - '0', q = S[i + 1] - '0';\n                        if (p > q) swap(p, q);\n                        if (q == 0) {\n                            sub[i + 2][j + 1][k] = 1;\n                        } else if (p == 1) {\n                            sub[i + 2][j][k + 1] = 1;\n                        } else {\n                            sub[i + 2][j + 1][k] = sub[i + 2][j][k + 1] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int j = n; j >= 0; --j) {\n            for (int k = n; k >= 0; --k) {\n                if (sub[i + 1][j][k]) {\n                    if (j > 0 && j + k >= 2) {\n                        sub[i + 1][j - 1][k] = 1;\n                    }\n                    if (k > 0 && j + k >= 2) {\n                        sub[i + 1][j][k - 1] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    rep(i, n + 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if (sub[i][j][k]) {\n                    // debug(i, j, k);\n                }\n            }\n        }\n    }\n\n    // use S[i,n)\n    rep(j, n + 1) {\n        rep(k, n + 1 - j) { dp[n][j][k] = comb[j + k][j]; }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        int c = S[i] - '0';\n        rep(j, n + 1) {\n            rep(k, n + 1 - j) {\n                if (c == 0) {\n                    for (int p = 0; p <= k; ++p) {\n                        dp[i][j][k] += dp[i + 1][j][k - p];\n                    }\n                } else {\n                    for (int q = 0; q <= j; ++q) {\n                        dp[i][j][k] += dp[i + 1][j - q][k];\n                    }\n                }\n            }\n        }\n    }\n\n    Mint ans;\n    rep(i, n + 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1 - j) {\n                if (sub[i][j][k]) {\n                    Mint u = dp[i][j][k];\n                    int nj = j, nk = k;\n                    if (i > 0) {\n                        if (S[i - 1] == '0') {\n                            --nj;\n                        } else {\n                            --nk;\n                        }\n\n                        if (nj >= 0 && nk >= 0 && sub[i - 1][nj][nk]) {\n                            u -= dp[i - 1][nj][nk];\n                        }\n                    }\n                    ans += u;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=998244353;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=310;\nchar s[310];\nint f[N][N][N],ans,n;\nbool g[N][N][N];\nvoid upd(int &a,int b) {\n\ta+=b; if (a>=mod) a-=mod;\n}\nint main() {\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tg[0][0][0]=1;\n\tfor (int i=1;i<=n;i++) for (int p0=0;p0<=i;p0++) for (int p1=0;p1<=i;p1++) {\n\t\tg[i][p0][p1]=g[i-1][p0][p1];\n\t\tif (i>=2) {\n\t\t\tif ((s[i-1]=='0'||s[i-2]=='0')&&p0>0) g[i][p0][p1]|=g[i-2][p0-1][p1];\n\t\t\tif ((s[i-1]=='1'||s[i-2]=='1')&&p1>0) g[i][p0][p1]|=g[i-2][p0][p1-1];\n\t\t}\n\t\tif (s[i-1]=='0'&&p0>0) g[i][p0][p1]|=g[i-1][p0-1][p1+1];\n\t\tif (s[i-1]=='1'&&p1>0) g[i][p0][p1]|=g[i-1][p0+1][p1-1];\n\t}\n\tf[0][0][0]=1;\n\tfor (int d=0;d<=n;d++) {\n\t\tfor (int p0=0;p0<=d;p0++) for (int p1=0;p0+p1<=d;p1++) {\n\t\t\tint mt=d-p0-p1;\n\t\t\tif (g[n-mt][p0][p1]) {\n\t\t\t\tupd(ans,f[d][p0][p1]);\n\t\t\t}\n\t\t\tif (d==n) continue;\n\t\t\tchar t=s[n-1-mt];\n\t\t\tif (t=='0') upd(f[d+1][p0][p1],f[d][p0][p1]);\n\t\t\telse upd(f[d+1][p0+1][p1],f[d][p0][p1]);\n\t\t\tif (t=='1') upd(f[d+1][p0][p1],f[d][p0][p1]);\n\t\t\telse upd(f[d+1][p0][p1+1],f[d][p0][p1]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ans+mod-1)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 300 + 10;\nconst int MOD = 998244353;\n\nstring s;\nint n;\nbool f[MAXN][MAXN][MAXN];\nint a[MAXN][MAXN], dp[MAXN][MAXN][MAXN];\n\nvoid add(int &a, int b) {\n    a = (a + b) % MOD;\n}\n\nint main() {\n    cin >> s;\n    n = s.length();\n    \n    for(int i = 0; i <= n; ++i)\n        for(int j = 0; j <= n; ++j)\n            a[i][j] = -1;\n            \n    f[0][0][0] = true;\n    for(int i = 0; i <= s.length(); ++i) {\n        int l0 = 0, l1 = 0;\n        for(int j = i; j < s.length(); ++j) {\n            l0 += (s[j] == '0'); l1 += (s[j] == '1');\n        }\n        \n        for(int sum = s.length(); sum >= 0; --sum)\n            for(int n0 = 0; n0 <= sum; ++n0) {\n                int n1 = sum - n0;\n                if (f[i][n0][n1] == false) continue;\n                a[n0 + l0][n1 + l1] = max(a[n0 + l0][n1 + l1], i);\n                \n                if (sum >= 2) {\n                    if (n0 > 0) f[i][n0 - 1][n1] = true;\n                    if (n1 > 0) f[i][n0][n1 - 1] = true;\n                }\n                if (i < s.length() && sum > 0) {\n                    f[i + 1][n0][n1] = true;\n                    if (n0 > 0) f[i + 1][n0 + (s[i] == '0') - 1][n1 + (s[i] == '1')] = true;\n                    if (n1 > 0) f[i + 1][n0 + (s[i] == '0')][n1 + (s[i] == '1') - 1] = true;\n                }\n                if (i + 1 < s.length()) {\n                    f[i + 2][n0 + (s[i] == '0')][n1 + (s[i] == '1')] = true;\n                    f[i + 2][n0 + (s[i + 1] == '0')][n1 + (s[i + 1] == '1')] = true;\n                }\n            }\n    }\n    \n    dp[0][0][s.length()] = 1;\n    for(int sum = 0; sum < s.length(); ++sum) {\n        for(int n0 = 0; n0 <= sum; ++n0) {\n            int n1 = sum - n0;\n            for(int i = 0; i <= s.length(); ++i) {\n                add(dp[n0 + 1][n1][ i - ((i > 0 && s[i - 1] == '0') ? 1 : 0)], dp[n0][n1][i]);\n                add(dp[n0][n1 + 1][ i - ((i > 0 && s[i - 1] == '1') ? 1 : 0)], dp[n0][n1][i]);\n            }\n        }\n    }\n    \n    int res = 0;\n    for(int n0 = 0; n0 <= s.length(); ++n0)\n        for(int n1 = 0; n0 + n1 <= s.length(); ++n1) {\n            if (a[n0][n1] >= 0) {\n                for(int j = 0; j <= a[n0][n1]; ++j) add(res, dp[n0][n1][j]);\n            }\n        }\n        \n    cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 998244353\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nstring s;\nbool dp[305][305][305];\nllint dp2[305][305][305];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> s;\n\tllint n = s.size();\n\ts = \"#\" + s;\n\t\n\tdp[0][0][0] = true;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = n; j >= 0; j--){\n\t\t\tfor(int k = n; k >= 0; k--){\n\t\t\t\tif(!dp[i][j][k]) continue;\n\t\t\t\t\n\t\t\t\tif(i+2 <= n) dp[i+1][j][k] = true;\n\t\t\t\t\n\t\t\t\tif(i+2 <= n && s[i+2] == '0' && j+1 <= n) dp[i+2][j+1][k] = true;\n\t\t\t\tif(i+2 <= n && s[i+2] == '1' && k+1 <= n) dp[i+2][j][k+1] = true;\n\t\t\t\t\n\t\t\t\tif(i+2 <= n && s[i+1] == '0' && j+1 <= n) dp[i+2][j+1][k] = true;\n\t\t\t\tif(i+2 <= n && s[i+1] == '1' && k+1 <= n) dp[i+2][j][k+1] = true;\n\t\t\t\t\n\t\t\t\tif(i+1 <= n && s[i+1] == '0' && j >= 1) dp[i+1][j+1-1][k] = true;\n\t\t\t\tif(i+1 <= n && s[i+1] == '0' && j+1 <= n && k >= 1) dp[i+1][j+1][k-1] = true;\n\t\t\t\tif(i+1 <= n && s[i+1] == '1' && k >= 1) dp[i+1][j][k+1-1] = true;\n\t\t\t\tif(i+1 <= n && s[i+1] == '1' && k+1 <= n && j >= 1) dp[i+1][j-1][k+1] = true;\n\t\t\t\t\n\t\t\t\tif(i+1 <= n && (j >= 1 || k >= 1)) dp[i+1][j][k] = true;\n\t\t\t\t\n\t\t\t\tif(i+1 <= n && j >= 2) dp[i][j-2][k] = true;\n\t\t\t\tif(i+1 <= n && k >= 2) dp[i][j][k-2] = true;\n\t\t\t\tif(i+1 <= n && j >= 1 && k >= 1) dp[i][j-1][k-1] = true;\n\t\t\t\t\n\t\t\t\tif(i+1 <= n && j >= 1) dp[i][j-1][k] = true;\n\t\t\t\tif(i+1 <= n && k >= 1) dp[i][j][k-1] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tdp2[n+1][0][0] = 1;\n\tfor(int i = n+1; i > 1; i--){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tif(s[i-1] == '0') (dp2[i-1][j][k] += dp2[i][j][k]) %= mod;\n\t\t\t\telse if(j+1 <= n) (dp2[i][j+1][k] += dp2[i][j][k]) %= mod;\n\t\t\t\t\n\t\t\t\tif(s[i-1] == '1') (dp2[i-1][j][k] += dp2[i][j][k]) %= mod;\n\t\t\t\telse if(k+1 <= n) (dp2[i][j][k+1] += dp2[i][j][k]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = n+1; i >= 1; i--){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tcout << dp2[i][j][k] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n+1; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tif(dp[i-1][j][k]) ans += dp2[i][j][k], ans %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\ntemplate <typename T> void set_min(T& a, T b) {\n\tif (b < a) a = b;\n}\n\nconst int INF = 1e8;\nconst int M = 305;\nstring s;\nint pref[M][M];\nbool ok[3][M][M];\n\nnum dp[M][M], newdp[M][M];\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tcin >> s;\n\tint n = int(s.size());\n\t// pref[i][j]\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tpref[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tpref[0][0] = 0;\n\t\tint c0 = 0, c1 = 1, c2 = 2;\n\t\tok[c0][0][0] = true;\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tif (!ok[c0][i][j]) continue;\n\t\t\t\t\tif (i && s[k] == '1') {\n\t\t\t\t\t\tok[c1][i-1][j+1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (i && s[k] == '0') {\n\t\t\t\t\t\tok[c1][i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (j && s[k] == '0') {\n\t\t\t\t\t\tok[c1][i+1][j-1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (j && s[k] == '1') {\n\t\t\t\t\t\tok[c1][i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (k+1 < n) {\n\t\t\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\t\t\tif (s[k]-'0' == z || s[k+1]-'0' == z) {\n\t\t\t\t\t\t\t\tok[c2][i+(z==0)][j+(z==1)] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc0 = (c0+1) % 3;\n\t\t\tc1 = (c1+1) % 3;\n\t\t\tc2 = (c2+1) % 3;\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tif (ok[c0][i][j] && pref[i][j] == INF) {\n\t\t\t\t\t\tpref[i][j] = k+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnum total = 0;\n\treverse(s.begin(), s.end());\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i <= k+1; i++) {\n\t\t\tfor (int j = 0; i+j <= k+1; j++) {\n\t\t\t\tnewdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; i+j <= k; j++) {\n\t\t\t\tint z = s[k-i-j]-'0';\n\t\t\t\tnewdp[i][j] += dp[i][j];\n\t\t\t\tif (z == 0) {\n\t\t\t\t\tnewdp[i][j+1] += dp[i][j];\n\t\t\t\t} else if (z == 1) {\n\t\t\t\t\tnewdp[i+1][j] += dp[i][j];\n\t\t\t\t} else assert(false);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k+1; i++) {\n\t\t\tfor (int j = 0; i+j <= k+1; j++) {\n\t\t\t\tdp[i][j] = newdp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k+1; i++) {\n\t\t\tfor (int j = 0; i+j <= k+1; j++) {\n\t\t\t\tint rest = k+1 - (i+j);\n\t\t\t\tif (pref[i][j] <= n-rest) {\n\t\t\t\t\ttotal += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << total << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 600 + 7;\nconst int M = 998244353;\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint sum(int a, int b) {\n  int c = (a + b) % M;\n  if (c >= M) c -= M;\n  if (c < 0) c += M;\n  return c;\n}\n\nvoid add(int &a, int b) {\n  a = sum(a ,b);\n}\n\nbool dp[N][N][N];\nint vals[N][N][N];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  dp[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int x = n; x >= 0; x--) {\n      for (int y = n; y >= 0; y--) {\n        if (!dp[i][x][y]) continue;\n        if (x + y >= 2) {\n          if (x)\n            dp[i][x - 1][y] = true;\n          if (y)\n            dp[i][x][y - 1] = true;\n        }\n        if (x && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x][y] = true;\n          } else {\n            dp[i + 1][x - 1][y + 1] = true;\n          }\n        }\n        if (y && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x + 1][y - 1] = true;\n          } else {\n            dp[i + 1][x][y] = true;\n          }\n        }\n        if (i + 1 < n) {\n          if (s[i] == s[i + 1]) {\n            if (s[i] == '0') {\n              dp[i + 2][x + 1][y] = true;\n            } else {\n              dp[i + 2][x][y + 1] = true;\n            }\n          } else {\n            dp[i + 2][x + 1][y] = true;\n            dp[i + 2][x][y + 1] = true;\n          }\n        }\n      }\n    }\n  }\n  vals[n][0][0] = 1;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (x + 1 <= n) {\n          if (!i || s[i - 1] != '0')\n            add(vals[i][x + 1][y], vals[i][x][y]);\n          else\n            add(vals[i - 1][x + 1][y], vals[i][x][y]);\n        }\n        if (y + 1 <= n) {\n          if (!i || s[i - 1] != '1')\n            add(vals[i][x][y + 1], vals[i][x][y]);\n          else\n            add(vals[i - 1][x][y + 1], vals[i][x][y]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (i) add(vals[i][x][y], vals[i - 1][x][y]);\n      }\n    }\n  }\n  vector <int> pa(n + 1), pb(n + 1);\n  int a = 0, b = 0;\n  for (int i = n; i >= 0; i--) {\n    if (i < n && s[i] == '0') a++;\n    if (i < n && s[i] == '1') b++;\n    pa[i] = a, pb[i] = b;\n  }\n  auto cost = [&] (int i, int a, int b) {\n    a += pa[i], b += pb[i];\n    int sum = vals[i][a][b];\n    return sum;\n  };\n  int ans = 0;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (dp[i][x][y]) {\n          int cur = 0;\n          add(cur, cost(i, x, y));\n          if (i) {\n            if (s[i - 1] == '0' && x && dp[i - 1][x - 1][y]) {\n              add(cur, -cost(i - 1, x - 1, y));\n            }\n            if (s[i - 1] == '1' && y && dp[i - 1][x][y - 1]) {\n              add(cur, -cost(i - 1, x, y - 1));\n            }\n          }\n          add(ans, cur);\n        }\n      }\n    }\n  }\n  cout << ans % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n \n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = 119 << 23 | 1;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    string s; cin >> s;\n    int n = sz(s);\n    vector<vector<vi>> dp(n + 1, vector<vi>(n + 1, vi(n + 1)));\n    dp[0][0][0] = 1;\n    FOR(i, 0, n) {\n        FOR(u, 0, n + 1) FOR(v, 0, n + 1) if (dp[i][u][v]) {\n            if (i + 1 < n) {\n                if (s[i] != s[i + 1]) {\n                    dp[i + 2][u + 1][v] = 1;\n                    dp[i + 2][u][v + 1] = 1;\n                }\n                else if (s[i] == '0') {\n                    dp[i + 2][u + 1][v] = 1;\n                }\n                else {\n                    dp[i + 2][u][v + 1] = 1;\n                }\n            }\n            if (u) {\n                dp[i + 1][u][v] = 1;\n                if (s[i] != '0') {\n                    dp[i + 1][u - 1][v + 1] = 1;\n                }\n            }\n            if (v) {\n                dp[i + 1][u][v] = 1;\n                if (s[i] != '1') {\n                    dp[i + 1][u + 1][v - 1] = 1;\n                }\n            }\n        }\n    }\n    vector<vi> c(n + n + 1, vi(n + n + 1));\n    FOR(i, 0, n + n + 1) c[0][i] = 1;\n    FOR(i, 1, n + n + 1) FOR(j, 1, n + n + 1) c[i][j] = (c[i][j - 1] + c[i - 1][j - 1]) % MOD;\n    vector<vi> f(n + 1, vi(n + 1));\n    FOR(u, 0, n + 1) FOR(v, 0, n + 1) f[u][v] = c[u][u + v];\n    static int g[333][333][333];\n    int res = 0;\n    FORd(i, n + 1, 2) {\n        if (i < n) {\n            vector<vi> nf(n + 1, vi(n + 1));\n            auto f1 = f;\n            auto f2 = f;\n            FOR(i, 0, n + 1) FOR(j, 0, n + 1) {\n                if (i) addmod(f1[i][j], f1[i - 1][j]);\n                if (j) addmod(f2[i][j], f2[i][j - 1]);\n            }\n            FOR(u, 0, n + 1) FOR(v, 0, n + 1) {\n                addmod(nf[u][v], f[u][v]);\n                if (s[i] == '0') {\n                    if (v) {\n                        addmod(nf[u][v], f2[u][v - 1]);\n                    }\n                    //FOR(w, 0, v) {\n                    //    addmod(nf[u][v], f[u][w]);\n                    //}\n                }\n                else {\n                    if (u) {\n                        addmod(nf[u][v], f1[u - 1][v]);\n                    }\n                    //FOR(w, 0, u) {\n                    //    addmod(nf[u][v], f[w][v]);\n                    //}\n                }\n            }\n            f = nf;\n        }\n        FOR(u, 0, n + 1) FOR(v, 0, n + 1) {\n            int found = 0;\n            if (i < n) {\n                if (s[i] == '0' && g[i + 1][u + 1][v]) {\n                    found = 1;\n                }\n                if (s[i] == '1' && g[i + 1][u][v + 1]) {\n                    found = 1;\n                }\n            }\n            if (found) {\n                g[i][u][v] = 1;\n            }\n            if (!found && dp[i][u][v]) {\n                addmod(res, f[u][v]);\n                g[i][u][v] = 1;\n            }\n        }\n    }\n    addmod(res, 1);\n    cout << res << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=305;\nint n;\nchar s[N];\nint dp[N][N][N],g[N][N][N],f[N][N][N];\nint main(){\n\tcin>>(s+1);\n\tn=strlen(s+1);\n\tdp[0][0][0]=1;\n\tFor(a,0,n)\n\t\tFod(i,n,0)\n\t\t\tFod(j,n,0){\n\t\t\t\tif (dp[a][i][j]){\n//\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",a,i,j);\n\t\t\t\t\tf[a][i][j]=1;\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tf[a+1][i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif (i>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i-1][j]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i-1+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+1][i-1][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i][j-1]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i+1][j-1]=1;\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tdp[a+1][i][j-1+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tFor(k,a+1,a+2){\n\t\t\t\t\t\t\tif (s[k]=='0')\n\t\t\t\t\t\t\t\tdp[a+2][i+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+2][i][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f[a][i][j]){\n\t\t\t\t\tif (a<n){\n\t\t\t\t\t\tif (i>0)\n\t\t\t\t\t\t\tf[a][i-1][j]=1;\n\t\t\t\t\t\tif (j>0)\n\t\t\t\t\t\t\tf[a][i][j-1]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tg[n+1][0][0]=1;\n\tint ans=1;\n\tFod(b,n,1){\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n)\n\t\t\t\tg[b][i][j]=g[b+1][i][j];\n\t\tif (s[b]=='1'){\n\t\t\tFor(i,1,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i-1][j]);\n\t\t}\n\t\telse {\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i][j-1]);\n\t\t}\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n){\n\t\t\t\tif (i+j>b)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v=0;\n\t\t\t\tint ii=i,jj=j;\n\t\t\t\tFor(k,b,n){\n\t\t\t\t\tif (f[k][ii][jj]){\n//\t\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",k,ii,jj);\n\t\t\t\t\t\tv=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[k+1]=='0')\n\t\t\t\t\t\tii++;\n\t\t\t\t\telse\n\t\t\t\t\t\tjj++;\n\t\t\t\t}\n\t\t\t\tif (v) assert(i+j<=b),\n//\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\",b,i,j,g[b][i][j]),\n\t\t\t\t\tAdd(ans,g[b][i][j]);\n\t\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nbool dp[305][305][305];\nll dp2[305][305][305];\nint ma[305][305];\n\nint main(void){\n    string s;\n    cin >> s;\n    int n = s.length();\n    VI a(n), sa(n + 1);\n    REP(i,n){\n        a[i] = s[i] - '0';\n        sa[i + 1] = sa[i] + a[i];\n    }\n    dp[0][0][0] = 1;\n    REP(i,n) REP(z,n+1) REP(o,n+1){\n        if (!dp[i][z][o]) continue;\n        int rz = (i - sa[i]) - z;\n        int ro = sa[i] - o;\n        if (i + 2 <= n){\n            if (a[i] + a[i + 1] == 0) dp[i + 2][z + 1][o] = 1;\n            else if (a[i] + a[i + 1] == 1) dp[i + 2][z + 1][o] = dp[i + 2][z][o + 1] = 1;\n            else dp[i + 2][z][o + 1] = 1;\n        }\n        if (rz + (a[i] == 0) > 0 && rz + ro + 1 >= 2) dp[i + 1][z + 1][o] = 1;\n        if (ro + (a[i] == 1) > 0 && rz + ro + 1 >= 2) dp[i + 1][z][o + 1] = 1;\n        if (rz > 0 && rz + ro >= 2) dp[i][z + 1][o] = 1;\n        if (ro > 0 && rz + ro >= 2) dp[i][z][o + 1] = 1;\n    }\n\n    VVI ma(n + 1, VI(n + 1, -1));\n    REP(i,n+1) REP(j,n+1) REP(k,n+1){\n        if (!dp[i][j][k]) continue;\n        chmax(ma[j][k], i);\n    }\n\n    dp2[0][0][0] = 1;\n    REP(i,n) REP(j,n+1) REP(k,n+1){\n        // (dp2[i][j + 1][k] += dp2[i][j][k]) %= mod;\n        // (dp2[i][j][k + 1] += dp2[i][j][k]) %= mod;\n        if (a[n - 1 - i] == 0){\n            (dp2[i + 1][j][k] += dp2[i][j][k]) %= mod;\n            (dp2[i][j][k + 1] += dp2[i][j][k]) %= mod;\n        }else {\n            (dp2[i + 1][j][k] += dp2[i][j][k]) %= mod;\n            (dp2[i][j + 1][k] += dp2[i][j][k]) %= mod;\n        }\n    }\n\n    REP(j,n+1) REP(k,n+1) FORR(i,n-1,0){\n        if (a[n - 1 - i] == 0) (dp2[i][j + 1][k] += dp2[i + 1][j][k]) %= mod;\n        else (dp2[i][j][k + 1] += dp2[i + 1][j][k]) %= mod;\n        // (dp2[i][j][k] += dp2[i + 1][j][k]) %= mod;\n    }\n\n    // REP(i,n+1){\n    //     cout << i << endl;\n    //     REP(j,n+1){\n    //         REP(k,n+1){\n    //             cout << dp2[i][j][k] << \" \";\n    //         }\n    //         cout << endl;\n    //     }\n    // }\n\n    ll ans = 0;\n    REP(i,n+1) REP(j,n+1){\n        if (ma[i][j] == -1) continue;\n        int x = ma[i][j];\n        int o = sa[x] - j, z = (x - sa[x]) - i;\n        // cout << x << \" \" << z << \" \" << o << \" \";\n        // cout << dp2[n - x][z][o] << endl;\n        (ans += dp2[n - x][z][o]) %= mod;\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Arayi\n//#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <cstring>\n#include <ctime>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <complex>\n\n#define fr first\n#define sc second\n#define MP make_pair\n#define ad push_back\n#define PB push_back\n#define fastio ios_base::sync_with_stdio(false); cin.tie(0);\n#define lli long long int\n#define y1 arayikhalatyan\n#define j1 jigglypuff\n#define ld long double\n#define itn int\n#define pir pair<int, int> \n#define all(x) (x).begin(), (x).end()\n#define str string\n#define enl endl\n#define en endl\n#define cd complex<long double>\n#define vcd vector<cd>\n#define vii vector<int>\n#define vlli vector<lli>\nusing namespace std;\n\nlli gcd(lli a, lli b) { return (b == 0LL ? a : gcd(b, a % b)); }\nld dist(ld x, ld y1, ld x2, ld y2)\n{\n    return sqrt((x - x2) * (x - x2) + (y1 - y2) * (y1 - y2));\n}\nlli S(lli a)\n{\n    return (a * (a + 1LL)) / 2;\n}\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nchar vow[] = { 'a', 'e', 'i', 'o', 'u' };\nint dx[] = { 1, -1, 0, 0, -1, -1, 1, 1, 0 };\nint dy[] = { 0, 0, 1, -1, -1, 1, -1, 1, 0 };\n\n\nconst int N = 333;\nconst lli mod = 998244353;\nconst ld pi = acos(-1);\nconst int T = 238;\nconst ld e = 1e-13;\n\nlli bp(lli a, lli b = mod - 2LL)\n{\n    lli ret = 1;\n    while (b)\n    {\n        if (b & 1) ret *= a, ret %= mod;\n        a *= a;\n        a %= mod;\n        b >>= 1;\n    }\n    return ret;\n}\nostream& operator<<(ostream& c, pir a)\n{\n    c << a.fr << \" \" << a.sc;\n    return c;\n}\nstruct pt\n{\n    lli x, y;\n    int ind;\n    int bl;\n    bool operator==(const pt& a)\n    {\n        return ind == a.ind;\n    }\n    bool operator<(const pt& b)\n    {\n        if (x == b.x) return y < b.y;\n        return x < b.x;\n    }\n};\n\n\n\nint n;\nstr s;\nbool dp[N][N][N], sm[N][N];\nlli dp1[N][N][N], pat;\nint z, m;\nint main()\n{\n    fastio;\n    cin >> s;\n    n = s.length();\n    dp[0][0][0] = true;\n    for (int i = 1; i < n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            for (int k = 0; k <= n; k++)\n            {\n                dp[i + 1][j][k] = dp[i][j][k];\n                if (s[i] == '0' && j) dp[i + 1][j][k] = dp[i + 1][j][k] | dp[i][j - 1][k + 1];\n                else if(s[i] == '1' && k) dp[i + 1][j][k] = dp[i + 1][j][k] | dp[i][j + 1][k - 1];\n                if ((s[i] == '0' || s[i - 1] == '0') && j) dp[i + 1][j][k] = dp[i + 1][j][k] | dp[i - 1][j - 1][k];\n                if ((s[i] == '1' || s[i - 1] == '1') && k) dp[i + 1][j][k] = dp[i + 1][j][k] | dp[i - 1][j][k - 1];\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++)\n        dp1[n][0][i] = dp1[n][i][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n; j++)\n        {\n            dp1[n][i][j] = dp1[n][i - 1][j] + dp1[n][i][j - 1];\n            dp1[n][i][j] %= mod;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            for (int k = 0; k <= n; k++)\n            {\n                if (s[i] == '1')\n                {\n                    if (j)\n                        dp1[i][j][k] = dp1[i + 1][j][k] + dp1[i][j - 1][k];\n                    else\n                        dp1[i][j][k] = dp1[i + 1][j][k];\n                }\n                else\n                {\n                    if (k)\n                        dp1[i][j][k] = dp1[i + 1][j][k] + dp1[i][j][k - 1];\n                    else\n                        dp1[i][j][k] = dp1[i + 1][j][k];\n                }\n                dp1[i][j][k] %= mod;\n            }\n        }\n    }\n    for (int i = n; i >= 0; i--)\n    {\n        if (i < n && s[i] == '0') z++;\n        else if(i < n && s[i] == '1')m++;\n        for (int j = 0; j <= n; j++)\n        {\n            for (int k = 0; k <= n; k++)\n            {\n                if (!dp[i][j][k]) continue;\n                if(sm[z + j][m + k]) continue;\n                sm[z + j][m + k] = 1;\n                pat += dp1[i][j][k];\n                pat %= mod;\n            }\n        }\n\n    }\n    cout << pat << endl;\n    return 0;\n}\n\n/*\n\n  __\n*(><)*\n  \\/ /\n  ||/\n--||\n  ||\n  /\\\n /  \\\n/    \\\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nconst int maxn=300+5;\nint n; char S[maxn];\nint mx[maxn][maxn];\nint f[maxn][maxn][maxn];\nint C[maxn][maxn];\nint sx[maxn],sy[maxn];\nbool g[maxn][maxn][maxn];\ninline int add(int x) {return x>=mod?x-mod:x;}\nvoid init() {\n\tfor(int i=0;i<=n;++i) {\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=1;j<i;++j) C[i][j]=add(C[i-1][j-1]+C[i-1][j]);\n\t}\n}\nint main() {\n\tscanf(\"%s\",S+1),n=strlen(S+1);\n\tinit();\n\tf[n+1][0][0]=1;\n\tfor(int i=n;i>=1;--i) {\n\t\tfor(int a=0;a<=n;++a) for(int b=0;b<=n;++b) {\n\t\t\tf[i][a][b]=f[i+1][a][b];\n\t\t\tif(S[i]=='0'&&b) f[i][a][b]=add(f[i][a][b]+f[i][a][b-1]);\n\t\t\tif(S[i]=='1'&&a) f[i][a][b]=add(f[i][a][b]+f[i][a-1][b]);\n\t\t}\n\t}\n\tg[0][0][0]=1;\n\tfor(int i=0;i<=n;++i) {\n\t\tfor(int a=n;a>=0;--a) for(int b=n;b>=0;--b) if(g[i][a][b]) {\n\t\t\tif(a+b>=2) {\n\t\t\t\tif(a) g[i][a-1][b]=1;\n\t\t\t\tif(b) g[i][a][b-1]=1;\n\t\t\t}\n\t\t\tif(i+2<=n) {\n\t\t\t\tif(S[i+1]=='0'||S[i+2]=='0') g[i+2][a+1][b]=1;\n\t\t\t\tif(S[i+1]=='1'||S[i+2]=='1') g[i+2][a][b+1]=1;\n\t\t\t}\n\t\t\tif(i+1<=n&&(a||b)) {\n\t\t\t\tg[i+1][a][b]=1;\n\t\t\t\tif(S[i+1]=='0'&&b) g[i+1][a+1][b-1]=1;\n\t\t\t\tif(S[i+1]=='1'&&a) g[i+1][a-1][b+1]=1; \n\t\t\t}\n\t\t}\n\t}\n\tmemset(mx,-1,sizeof(mx));\n\tfor(int i=n;i>=0;--i) {\n\t\tfor(int a=0;a<=n;++a) for(int b=0;b<=n;++b) if(g[i][a][b]) {\n\t\t\tif(mx[a+sx[i]][b+sy[i]]==-1) mx[a+sx[i]][b+sy[i]]=i;\n\t\t}\n\t\tsx[i-1]=sx[i],sy[i-1]=sy[i];\n\t\tif(S[i]=='0') ++sx[i-1]; else ++sy[i-1];\n\t}\n\tint an=0;\n\tfor(int x=0;x<=n;++x) for(int y=0;y<=n;++y) if(mx[x][y]!=-1) {\n\t\tint t=mx[x][y]+1,xx=x-sx[t-1],yy=y-sy[t-1];\n\t\tint r=an;\n\t\tfor(int a=0;a<=xx;++a) for(int b=0;b<=yy;++b) if(f[t][a][b]) {\n\t\t\tan=(an+(ll)f[t][a][b]*C[xx+yy-a-b][xx-a])%mod;\n\t\t}\n//\t\tdebug(\"%d %d %d %d\\n\",xx,yy,t-1,an-r);\n\t}\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <cstring>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nconst int ms = 303;\nconst int MOD = 998244353;\n\nstd::string str;\nint n;\nbool vis[ms][ms][ms];\nint memo[ms][ms][ms];\nint bst[ms][ms];\nint sum[ms][2];\n\nvoid go(int on, int zero, int one, int turn) {\n\tif(vis[on][zero][turn]) return;\n\tvis[on][zero][turn] = true;\n\t//std::cout << \"visiting \" << on << \", \" << zero << \", \" << one << \", \" << turn << \"\\n\";\n\tmemo[on][zero][turn] = one;\n\tif(turn + 1 == (int) str.size()) return;\n\tif(zero >= 2) go(on, zero-1, one, turn+1);\n\tif(one >= 2) go(on, zero, one-1, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero-1, one, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero, one-1, turn+1);\n\tif(on < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tif(zero >= 1) go(on+1, zero-1+(1-nxt), one+nxt, turn+1);\n\t\tif(one >= 1) go(on+1, zero+(1-nxt), one+nxt-1, turn+1);\n\t\tif(zero >= 1 || one >= 1) go(on+1, zero, one, turn+1);\n\t}\n\tif(on+1 < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t\tnxt = str[on+1] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t}\n}\n\nint dp(int on, int zero, int one) {\n\tif(zero < 0 || one < 0) return 0;\n\tif(on == n && zero == 0 && one == 0) return 1;\n\tint &ans = memo[on][zero][one];\n\tif(ans != -1) return ans;\n\tans = 0;\n\tif(on == n) {\n\t\tans = (dp(on, zero-1, one) + dp(on, zero, one-1)) % MOD;\n\t} else if(str[on] == '0') {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero, one-1)) % MOD;\n\t} else {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero-1, one)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tstd::cin >> str;\n\tn = (int) str.size();\n\tgo(0, 0, 0, 0);\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tsum[i][0] = sum[i+1][0];\n\t\tsum[i][1] = sum[i+1][1];\n\t\tif(str[i] == '0') sum[i][0]++;\n\t\telse sum[i][1]++;\n\t}\n\tmemset(bst, -1, sizeof bst);\n\tfor(int on = 0; on < ms; on++) {\n\t\tfor(int zero = 0; zero < ms; zero++) {\n\t\t\tfor(int turn = 0; turn < ms; turn++) {\n\t\t\t\tif(!vis[on][zero][turn]) continue;\n\t\t\t\tint one = memo[on][zero][turn];\n\t\t\t\tint f[2] = {zero + sum[on][0], one + sum[on][1]};\n\t\t\t\tbst[f[0]][f[1]] = std::max(bst[f[0]][f[1]], on);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tint ans = 0;\n\tfor(int zero = 0; zero < ms; zero++) {\n\t\tfor(int one = 0; one < ms; one++) {\n\t\t\tif(bst[zero][one] < 0) continue;\n\t\t\tint on = bst[zero][one];\n\t\t\t//std::cout << \"best for \" << zero << \", \" << one << \" is \" << on << \", got \" << dp(on, zero - sum[on][0], one - sum[on][1]) << '\\n';\n\t\t\tans = (ans + dp(on, zero - sum[on][0], one - sum[on][1])) % MOD;\n\t\t}\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=998244353;\nint add(int x,int y){x+=y;return x>=mod?x-mod:x;}\nint sub(int x,int y){x-=y;return x<0?x+mod:x;}\nint mul(int x,int y){return (ll)x*y%mod;}\nvoid ckadd(int&x,int y){x=add(x,y);}\nvoid cksub(int&x,int y){x=sub(x,y);}\nvoid ckmul(int&x,int y){x=mul(x,y);}\nconst int N=305;\nbool ok[N][N][N];\nint dp[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tok[0][0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=n;~j;j--){\n\t\t\tfor(int k=n;~k;k--){\n\t\t\t\tif(!ok[i][j][k])continue;\n\t\t\t\tif(j+k>=2&&j)ok[i][j-1][k]=1;\n\t\t\t\tif(j+k>=2&&k)ok[i][j][k-1]=1;\n\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1')ok[i+2][j][k+1]=1;\n\t\t\t\tif(s[i+1]=='0'||s[i+2]=='0')ok[i+2][j+1][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&k)ok[i+1][j][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&j)ok[i+1][j-1][k+1]=1;\n\t\t\t\tif(s[i+1]=='0'&&k)ok[i+1][j+1][k-1]=1;\n\t\t\t\tif(s[i+1]=='0'&&j)ok[i+1][j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tdp[n+1][0][0]=1;\n\tfor(int i=n+1;i>=1;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(ok[i-1][j][k]||ok[i][j+(s[i]=='0')][k+(s[i]=='1')])ckadd(ans,dp[i][j][k]);\n\t\t\t\tckadd(dp[i-1][j][k],dp[i][j][k]);\n\t\t\t\tif(s[i-1]=='0')ckadd(dp[i][j][k+1],dp[i][j][k]);\n\t\t\t\telse ckadd(dp[i][j+1][k],dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(a) ((int) (a).size())\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst long long inf64 = ((long long)1 << 62) - 1;\nconst long double pi = acos(-1);\n\ntemplate <class T> T sqr (T x) {return x * x;}\ntemplate <class T> T abs (T x) {return x < 0 ? -x : x;}\n\nconst int P = 998244353;\n\nint Sum(int a, int b) {\n    return (a + b) % P;\n}\n\nint Mult(int a, int b) {\n    return (a * (long long) b) % P;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0);\n//  freopen(\"_input.txt\", \"rt\", stdin);\n//  freopen(\"_output.txt\", \"wt\", stdout);\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n\n    vector<int> cnt_one(n + 1);\n    for (int i = 0; i < n; ++i) {\n        cnt_one[i + 1] = cnt_one[i] + (s[i] == '1');\n    }\n\n    vector<vector<int>> min_sub(n, vector<int>(n + 1, inf));\n    min_sub[0][cnt_one[n]] = n;\n    \n    for (int i = 0; i < n - 1; ++i) {\n        for (int cur_one = 0; cur_one <= n - i; ++cur_one) {\n            int sub = min_sub[i][cur_one];\n            if (sub == inf) {\n                continue;\n            }\n\n            int cur_zero = n - i - cur_one;\n            \n            if (sub < 2) {\n                if (cur_one > 0) {\n                    min_sub[i + 1][cur_one - 1] = 0;\n                }\n                if (cur_zero > 0) {\n                    min_sub[i + 1][cur_one] = 0;\n                }\n                continue;\n            }\n\n            if (s[n - sub] == '1' || s[n - sub + 1] == '1') {\n                min_sub[i + 1][cur_one - 1] = min(min_sub[i + 1][cur_one - 1], sub - 2);\n            } else if (cur_one > cnt_one[n] - cnt_one[n - sub]) {\n                min_sub[i + 1][cur_one - 1] = min(min_sub[i + 1][cur_one - 1], sub - 1);\n            }\n\n            if (s[n - sub] == '0' || s[n - sub + 1] == '0') {\n                min_sub[i + 1][cur_one] = min(min_sub[i + 1][cur_one], sub - 2);\n            } else if (cur_zero > sub - (cnt_one[n] - cnt_one[n - sub])) {\n                min_sub[i + 1][cur_one] = min(min_sub[i + 1][cur_one], sub - 1);\n            }\n        }\n    }\n\n    vector<vector<vector<int>>> d(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1)));\n\n    d[0][0][0] = 1;\n    for (int len = 0; len < n; ++len) {\n        for (int sub = 0; sub <= len; ++sub) {\n            for (int cur_one = 0; cur_one <= len; ++cur_one) {\n                for (int cur = 0; cur <= 1; ++cur) {\n                    int new_sub = sub + (cur == s[n - sub - 1] - '0');\n                    d[len + 1][new_sub][cur_one + cur] = \n                        Sum(d[len + 1][new_sub][cur_one + cur], d[len][sub][cur_one]);\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        int cur_res = 0;\n        for (int cur_one = 0; cur_one <= n; ++cur_one) {\n            if (min_sub[i][cur_one] == inf) {\n                continue;\n            }\n\n            for (int sub = min_sub[i][cur_one]; sub <= n - i; ++sub) {\n                cur_res = Sum(cur_res, d[n - i][sub][cur_one]);\n            }\n        }\n        res = Sum(res, cur_res);\n    }\n    \n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n// Inserted snippets: euclid, io, modint, root\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntemplate<typename H> bool chmin(H& v1, const H v2) { if (v1 > v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> bool chmax(H& v1, const H v2) { if (v1 < v2) { v1 = v2; return true; } return false; }\ntemplate<typename H> void read(H& head) { cin >> head; }\ntemplate<typename H, typename ...T> void read(H& head, T& ...tail) { cin >> head; read(tail...); }\ntemplate<typename H> void write(H head) { cout << head << '\\n'; }\ntemplate<typename H, typename ...T> void write(H head, T ...tail) { cout << head << \" \"; write(tail...); }\ntemplate<typename ...T> void die(T ...tok) { write(tok...); exit(0); }\nll euclid(ll a, ll b, ll &x, ll &y) {\n\tif (b) { ll d = euclid(b, a % b, y, x);\n\t\treturn y -= a/b * x, d; }\n\treturn x = 1, y = 0, a;\n}\ntemplate<ll MOD = 1'000'000'007>\nstruct Mod {\n\tll val;\n\tMod() : val(0) {}\n\tMod(ll xx) {\n\t\tif (0 <= xx && xx < MOD) val = xx;\n\t\telse val = (xx % MOD + MOD) % MOD;\n\t}\n\tMod operator+=(Mod b) { if ((val += b.val) >= MOD) val -= MOD; return *this; }\n\tMod operator-=(Mod b) { if ((val += MOD - b.val) >= MOD) val -= MOD; return *this; }\n\tMod operator*=(Mod b) { (val *= b.val) %= MOD; return *this; }\n\tMod operator/=(Mod b) { (val *= b.inv().val) %= MOD; return *this; }\n\tMod operator+(Mod b) const { Mod<MOD> tmp(*this); return tmp += b; }\n\tMod operator-(Mod b) const { Mod<MOD> tmp(*this); return tmp -= b; }\n\tMod operator*(Mod b) const { Mod<MOD> tmp(*this); return tmp *= b; }\n\tMod operator/(Mod b) const { Mod<MOD> tmp(*this); return tmp /= b; }\n\tMod& operator++() { *this += 1; return *this; }\n\tMod& operator--() { *this -= 1; return *this; }\n\tMod operator++(int) { Mod<MOD> tmp(*this); operator++(); return tmp; }\n\tMod operator--(int) { Mod<MOD> tmp(*this); operator--(); return tmp; }\n\tMod inv() const {\n\t\tll v, y, g = euclid(val, MOD, v, y);\n\t\tassert(g == 1); return Mod((v + MOD) % MOD);\n\t}\n\tMod operator^(ll p) const {\n\t\tll r = 1, b = val;\n\t\tfor (; p; p >>= 1, b = b * b % MOD) if (p & 1) r = r * b % MOD;\n\t\treturn Mod(r);\n\t}\n\tfriend istream& operator>>(istream &is, Mod& mod) {\n\t\tll tmp; is >> tmp;\n\t\tmod = Mod<MOD>(tmp);\n\t\treturn is;\n\t}\n\tfriend ostream& operator<<(ostream &os, const Mod& mod) {\n\t\treturn os << mod.val;\n\t}\n};\n// End snippets\n\ntypedef Mod<998244353> modint;\n\nmodint fact[605], factinv[605];\n\nmodint ncr(int n, int r) {\n\treturn fact[n] * factinv[r] * factinv[n - r];\n}\n\nmodint dp[305][305][305];\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(cin.failbit);\n\n\tfact[0] = factinv[0] = 1;\n\trep(i, 1, 605)\n\t\tfact[i] = fact[i - 1] * i, factinv[i] = factinv[i - 1] / i;\n\n\tstring s; read(s);\n\n\tint gc0 = 0, gc1 = 0;\n\tfor (char c : s) if (c == '0') gc0++; else gc1++;\n\n\tmodint ans;\n\n\trep(i, 1, sz(s) + 1) {\n\t\tif (i <= sz(s) / 2) {\n\t\t\tmodint lans;\n\t\t\trep(j, 0, i + 1) {\n\t\t\t\tint u0 = j, u1 = i - j;\n\t\t\t\tif (u0 <= gc0 && u1 <= gc1)\n\t\t\t\t\tlans += ncr(i, j);\n\t\t\t}\n\t\t\tans += lans;\n\t\t\t//write(i, \"0\", lans);\n\t\t} else {\n\t\t\tint prefix = (sz(s) - i) * 2;\n\t\t\tint suffix = 2 * i - sz(s);\n\t\t\tif (prefix > sz(s) || suffix > sz(s) || prefix < 0 || suffix < 0) {\n\t\t\t\tcerr << \"Panik\" << endl;\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\t//if (prefix == 0)\n\t\t\t//\tans += 1;\n\t\t\t//else {\n\t\t\t\tstring suf = string(s.end() - suffix, s.end());\n\t\t\t\tint min0 = 0, min1 = 0, max0 = 0, max1 = 0;\n\t\t\t\trep(i, 0, prefix / 2) {\n\t\t\t\t\tstring g = s.substr(i * 2, 2);\n\t\t\t\t\tif (g == \"00\") min0++, max0++;\n\t\t\t\t\telse if (g == \"11\") min1++, max1++;\n\t\t\t\t\telse max0++, max1++;\n\t\t\t\t}\n\t\t\t\tfor (char c : suf) if (c == '0') min0++, max0++; else min1++, max1++;\n\t\t\t\trep(a, 0, i + 1) rep(b, 0, max1 + 1) rep(c, 0, suffix + 1)\n\t\t\t\t\tdp[a][b][c] = 0;\n\t\t\t\tdp[0][0][0] = 1;\n\t\t\t\trep(a, 0, i + 1) rep(b, 0, max1 + 1) rep(c, 0, suffix + 1) {\n\t\t\t\t\t// append 0\n\t\t\t\t\tdp[a + 1][b][c + (c < suffix && suf[c] == '0')] += dp[a][b][c];\n\t\t\t\t\t// append 1\n\t\t\t\t\tdp[a + 1][b + 1][c + (c < suffix && suf[c] == '1')] += dp[a][b][c];\n\t\t\t\t}\n\t\t\t\tmodint lans;\n\t\t\t\trep(b, min1, max1 + 1)\n\t\t\t\t\tlans += dp[i][b][suffix];\n\t\t\t\tans += lans;\n\t\t\t\t//write(i, \"0:\", min0, \"~\", max0, \"1:\", min1, \"~\", max1);\n\t\t\t\t//write(i, \"1\", lans);\n\t\t\t//}\n\t\t}\n\t}\n\n\twrite(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \n\nconst int N = 307;\nbool can[N][N][N];\nint dp[N][N][N];\n//dpijk - number of ways to insert j (0) and k (1) in suffix of length i with largest suffix-subsequence i\n\nvoid add(int &a, int b) {\n    a = mod(a+b);\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    string s;\n    cin >> s;\n    int n = s.size();\n    \n    can[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int c0 = i; c0 >= 0; --c0) {\n            for (int c1 = i; c1 >= 0; --c1) {\n                if (!can[i][c0][c1])\n                    continue;\n\n                int t = s[i] - '0';\n\n                can[i+1][c0][c1] = 1;\n\n                if (c0 && c1) {\n                    can[i][c0-1][c1] = 1;\n                    can[i][c0][c1-1] = 1;\n                }   \n\n                if (c0) {\n                    can[i+1][c0-1+(t==0)][c1+(t==1)] = 1;\n                }   \n                if (c1) {\n                    can[i+1][c0+(t==0)][c1-1+(t==1)] = 1;\n                }   \n                if (c0 || c1) {\n                    can[i+1][c0][c1] = 1;\n                }   \n\n                if (i + 1 < n) {\n                    vector <bool> have(2);\n                    for (int j = i; j <= i + 1; ++j)\n                        have[s[j]-'0'] = 1;\n                    if (have[0])\n                        can[i+2][c0+1][c1]=1;\n                    if (have[1])\n                        can[i+2][c0][c1+1]=1;\n                }\n            }   \n        }           \n    }   \n    \n    #ifdef HOME\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= n; ++k) {\n                if (can[i][j][k]) {\n                    //cout << \"can \" << i << ' ' << j << ' ' << k << endl;\n                }   \n            }   \n        }   \n    }   \n    #endif\n\n    dp[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        char c = s[n - i - 1];\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= n; ++k) {\n                int x = dp[i][j][k];\n                if (x == 0)\n                    continue;\n\n                add(dp[i+1][j][k], x);\n                if (c != '0') {\n                    add(dp[i][j+1][k], x);\n                }   \n                if (c != '1') {\n                    add(dp[i][j][k+1], x);\n                }\n            }   \n        }   \n    }\n\n    /*\n    cout << dp[2][1][0] << endl;\n    exit(0);\n    */\n\n    int ans = 0;\n    for (int p = 0; p <= n; ++p) {\n        for (int i = 0; i <= n; ++i)\n            for (int j = 0; j <= n; ++j)\n                if (can[p][i][j] && dp[n-p][i][j]) {\n\n                    #ifdef HOME\n                    //cout << \"add \" << p << ' ' << i << ' ' << j << \" : \" << dp[n-p][i][j] << endl;\n                    #endif\n\n                    add(ans, dp[n-p][i][j]);\n                }\n    }   \n    cout << mod(ans-1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n//#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 998244353;\n\nvoid add(int &a, int b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nvoid sub(int &a, int b)\n{\n\ta -= b;\n\tif (a < 0)\n\t\ta += mod;\n}\n\nint mult(int a, int b)\n{\n\treturn ll(a) * b % mod;\n}\n\nvector<vector<vector<int>>> calc(const string &s)\n{\n\tconst int n = int(s.size());\n\n\tvector<vector<vector<int>>> ans(n + 1);\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tans[i].resize(n - i + 1);\n\t\tfor (int j = 0; j <= n - i; j++)\n\t\t\tans[i][j].resize(n - i - j + 1);\n\t}\n\n\tconst int N = 300;\n\tstatic int dp[N + 1][N + 1][N + 1][2];\n\tmemset(dp, 0, sizeof dp);\n\tdp[0][0][0][0] = dp[0][0][0][1] = 1;\n\n\tfor (int len = 0; len <= n; len++)\n\t\tfor (int zero = 0; zero <= n - len; zero++)\n\t\t\tfor (int one = 0; one <= n - len - zero; one++)\n\t\t\t\tfor (int fin = 0; fin < 2; fin++)\n\t\t\t\t{\n\t\t\t\t\tconst int cur = dp[len][zero][one][fin];\n\n\t\t\t\t\tif (fin == 1)\n\t\t\t\t\t\tadd(ans[len][zero][one], cur);\n\t\t\t\t\tif (cur == 0 || len + zero + one >= n)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fin == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(dp[len][zero + 1][one][1], cur);\n\t\t\t\t\t\tadd(dp[len][zero][one + 1][1], cur);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fin == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd(dp[len + 1][zero][one][0], cur);\n\t\t\t\t\t\tadd(dp[len + 1][zero][one][1], cur);\n\n\t\t\t\t\t\tif (s[len] == '0')\n\t\t\t\t\t\t\tadd(dp[len][zero][one + 1][0], cur);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tadd(dp[len][zero + 1][one][0], cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\treturn ans;\n}\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tstring s;\n\n\twhile (cin >> s)\n\t{\n\t\tconst int n = int(s.size());\n\n\t\tstring rev_s = s;\n\t\treverse(rev_s.begin(), rev_s.end());\n\n\t\tauto dp_ways = calc(rev_s);\n\n\t\tcerr << double(clock()) / CLOCKS_PER_SEC << endl;\n\n\t\tvector<vector<vector<bool>>> reach(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1)));\n\t\treach[0][0][0] = true;\n\n\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = n; j >= 0; j--)\n\t\t\t\tfor (int k = n; k >= 0; k--)\n\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j >= 2)\n\t\t\t\t\t\t\treach[i][j - 1][k] = true;\n\t\t\t\t\t\tif (k >= 2)\n\t\t\t\t\t\t\treach[i][j][k - 1] = true;\n\t\t\t\t\t\tif (j >= 1 && k >= 1)\n\t\t\t\t\t\t\treach[i][j][k - 1] = reach[i][j - 1][k] = true;\n\t\t\t\t\t}\n\n\t\t\tif (i + 1 <= n)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int nj = j + (s[i] == '0'), nk = k + (s[i] == '1');\n\n\t\t\t\t\t\t\tif (nj > 0)\n\t\t\t\t\t\t\t\treach[i + 1][nj - 1][nk] = true;\n\t\t\t\t\t\t\tif (nk > 0)\n\t\t\t\t\t\t\t\treach[i + 1][nj][nk - 1] = true;\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i + 2 <= n)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\t\t\t\t\tif (s[i] == x + '0' || s[i + 1] == x + '0')\n\t\t\t\t\t\t\t\t\t(x == 0 ? reach[i + 2][j + 1][k] : reach[i + 2][j][k + 1]) = true;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tvector<int> cnt(2);\n\t\tvector<vector<bool>> used(n + 1, vector<bool>(n + 1, false));\n\n\t\tfor (int suff = 0; suff <= n; suff++)\n\t\t{\n\t\t\tfor (int zero = 0; zero <= n; zero++)\n\t\t\t\tfor (int one = 0; one <= n; one++)\n\t\t\t\t\tif (reach[n - suff][zero][one])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!used[cnt[0] + zero][cnt[1] + one])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tused[cnt[0] + zero][cnt[1] + one] = true;\n\t\t\t\t\t\t\tadd(ans, dp_ways[suff][zero][one]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\tif (suff < n)\n\t\t\t\tcnt[rev_s[suff] - '0']++;\n\t\t}\n\n\t\tsub(ans, 1);\n\t\tcout << ans << endl;\n\t}\n}\n\nvoid gen (stringstream &cout)\n{\n\tconst int n = 300;\n\n\tstatic mt19937 rng;\n\tstring ans(n, '-');\n\tfor (auto &ch : ans)\n\t\tch = rng() % 2 + '0';\n\n\tcout << ans << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n#ifdef LOCAL\n\tauto st = clock();\n\n//\tstringstream test, out;\n//\tgen(test);\n//\tsolve(test, out);\n\n\tifstream fin(\"../input.txt\");\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n;\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s);\n    n=strlen(s);\n    f[0][0][0]=true;\n    for(int i=0;i<n;i++)\n        for(int n0=0;n0<=i;n0++)\n        for(int n1=0;n1<=i;n1++)\n    {\n        if(!f[i][n0][n1]) continue;\n        f[i+1][n0][n1]=true;\n        if(n0)\n        {\n            int nn0=n0-1+(s[i]=='0');\n            int nn1=n1+(s[i]=='1');\n            f[i+1][nn0][nn1]=true;\n        }\n        if(n1)\n        {\n            int nn0=n0+(s[i]=='0');\n            int nn1=n1-1+(s[i]=='1');\n            f[i+1][nn0][nn1] = true;\n        }\n        if(i+1<n)\n        {\n            f[i+2][n0+(s[i]=='0')][n1+(s[i] == '1')] = true;\n            f[i+2][n0+(s[i+1]=='0')][n1+(s[i+1] == '1')] = true;\n        }\n    }\n    dp[n][0][0]=1;\n    ll ans=0;\n    for(int i=n;i>=0;i--)\n        for(int n0=0;n0<=n;n0++)\n        for(int n1=0;n1<=n;n1++)\n    {\n        if(dp[i][n0][n1]==0) continue;\n        if(f[i][n0][n1])\n            ans=(ans+dp[i][n0][n1])%mod;\n        if(i>0)\n        {\n            dp[i-1][n0][n1]=(dp[i-1][n0][n1]+dp[i][n0][n1])%mod;\n            if(s[i-1]=='1')\n                dp[i][n0+1][n1]=(dp[i][n0+1][n1]+dp[i][n0][n1])%mod;\n            else\n                dp[i][n0][n1+1]=(dp[i][n0][n1+1]+dp[i][n0][n1])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 305;\nconst int mod = 998244353;\n\nstring S;\nbool pos[Maxn][Maxn][Maxn];\nint dp[Maxn][Maxn][Maxn];\nint res;\n\nint main()\n{\n    cin >> S;\n    pos[0][0][0] = true;\n    for (int i = 0; i <= S.length(); i++)\n        for (int a = Maxn - 1; a >= 0; a--)\n            for (int b = Maxn - 1; b >= 0; b--) if (pos[i][a][b]) {\n                if (a + b >= 2) {\n                    if (a > 0) pos[i][a - 1][b] = true;\n                    if (b > 0) pos[i][a][b - 1] = true;\n                }\n                if (i < S.length()) {\n                    pos[i + 1][a][b] = true;\n                    if (a > 0) pos[i + 1][a - 1 + (S[i] == '0')][b + (S[i] == '1')] = true;\n                    if (b > 0) pos[i + 1][a + (S[i] == '0')][b - 1 + (S[i] == '1')] = true;\n                }\n                if (i + 1 < S.length()) {\n                    pos[i + 2][a + (S[i] == '0')][b + (S[i] == '1')] = true;\n                    pos[i + 2][a + (S[i + 1] == '0')][b + (S[i + 1] == '1')] = true;\n                }\n            }\n    dp[S.length()][0][0] = 1;\n    for (int i = S.length(); i > 0; i--)\n        for (int a = 0; a < Maxn; a++)\n            for (int b = 0; b < Maxn; b++) if (dp[i][a][b]) {\n                if (pos[i][a][b]) res = (res + dp[i][a][b]) % mod;\n                if (S[i - 1] == '0') dp[i - 1][a][b] = (dp[i - 1][a][b] + dp[i][a][b]) % mod;\n                else if (a + 1 < Maxn) dp[i][a + 1][b] = (dp[i][a + 1][b] + dp[i][a][b]) % mod;\n                if (S[i - 1] == '1') dp[i - 1][a][b] = (dp[i - 1][a][b] + dp[i][a][b]) % mod;\n                else if (b + 1 < Maxn) dp[i][a][b + 1] = (dp[i][a][b + 1] + dp[i][a][b]) % mod;\n            }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fan Club !!\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 998244353;//998244353\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nbool valid[305][305][305];\nint n;\nstring str;\nP1 good[305][305];\nll way[305][305][305];\nll tate[305][305][305], yoko[305][305][305];\nll C[505][505];\nint main(){\n\trep(i, 503) rep(j, i+1){\n\t\tif(j == 0 || j == i) C[i][j] = 1;\n\t\telse C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tcin >> str;\n\tn = str.size();\n\tvalid[0][0][0] = 1;\n\trep(i, n+1){\n\t\tfor(int z=n;z>=0;z--){\n\t\t\tfor(int o=n;o>=0;o--){\n\t\t\t\tif(valid[i][z][o] == false) continue;\n\t\t\t\tif(n-i >= 2){\n\t\t\t\t\tif(str[i] == '0' || str[i+1] == '0'){\n\t\t\t\t\t\tvalid[i+2][z+1][o] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[i] == '1' || str[i+1] == '1'){\n\t\t\t\t\t\tvalid[i+2][z][o+1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(n-i >= 1){\n\t\t\t\t\tif(z+o > 0) valid[i+1][z][o] = 1;\n\t\t\t\t\tif(str[i] == '0' && o > 0) valid[i+1][z+1][o-1] = 1;\n\t\t\t\t\tif(str[i] == '1' && z > 0) valid[i+1][z-1][o+1] = 1;\n\t\t\t\t}\n\t\t\t\tif(n-i >= 0){\n\t\t\t\t\tif(z+o >= 2 && z) valid[i][z-1][o] = 1;\n\t\t\t\t\tif(z+o >= 2 && o) valid[i][z][o-1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, 305)rep(j, 305) good[i][j] = mp(-1, mp(-1, -1));\n\trep(i, n+1){\n\t\tint zn = 0, on = 0;\n\t\tfor(int j=i;j<n;j++) (str[j]=='0'?zn:on)++;\n\t\tfor(int z=0;z<=n;z++){\n\t\t\tfor(int o=0;o<=n;o++){\n\t\t\t\tif(valid[i][z][o]) good[zn+z][on+o] = mp(i, mp(z, o));\n\t\t\t}\n\t\t}\n\t}\n\tway[0][0][0] = 1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int z=0;z<n;z++){\n\t\t\tfor(int o=0;o<n;o++){\n\t\t\t\tif(z) add(tate[i][z][o], tate[i][z-1][o]);\n\t\t\t\tif(o) add(yoko[i][z][o], yoko[i][z][o-1]);\n\t\t\t\tway[i][z][o] += tate[i][z][o] + yoko[i][z][o];\n\t\t\t\tif(way[i][z][o] >= mod) way[i][z][o]%=mod;\n\t\t\t\tif(way[i][z][o] == 0) continue;\n\t\t\t\tbool isz = (str[n-1-i]=='0');\n              \t//cout<<i<<z<<o<<\" \"<<way[i][z][o]<<endl;\n\t\t\t\tif(isz) yoko[i+1][z][o] += way[i][z][o];\n\t\t\t\telse tate[i+1][z][o] += way[i][z][o];\n\t\t\t}\n\t\t}\n\t}\n\trep(z, n+1) rep(o, n+1){\n\t\tif(good[z][o].fi == -1) continue;\n\t\tint len = n - good[z][o].fi;\n\t\tint adz = good[z][o].sc.fi;\n\t\tint ado = good[z][o].sc.sc;\n\t\trep(i, adz+1) rep(j, ado+1) ans += way[len][i][j] * C[adz-i+ado-j][adz-i] % mod;\n\t}\n\tcout << (ans%mod+mod+1)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nusing M9 = IntMod<998244353>;\n\n// T = reverse(S) とする\n// 以下、「T 内の文字」と言った場合、先頭から貪欲に T に含まれる文字を確定していくことを示す\n// T = \"100101\" に対して 0 を3つ挿入し、 \"100010010\" を得たなら、\n// [1][0][0] 0 [1][0] 0 [1] となる ([ ] のついた部分が T 内の文字)\n\nstring S;\nbool DP[302][302][302];\t\t// DP[i][j][k] = Sの先頭 i 文字を使って手持ちを「0 が j 個, 1 が k 個」にできるか\nM9 EP[302][302];\t\t\t// EP[i][j] = Tの先頭 i 文字に 0 を j 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 FP[302][302];\t\t\t// FP[i][k] = Tの先頭 i 文字に 1 を k 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 GP[302][302][302];\t\t// GP[i][j][k] = Tの先頭 i 文字に 0 を j 個, 1 を k 個挿入してできる文字列の数\nM9 EQ[302][303];\t\t// 累積和用\nM9 FQ[302][303];\nvoid pre() {\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\tint N = T.size();\n\n\t// EP の計算: 先頭から T を見ていき 0 を挿入する ([1] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tEP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tEP[i][j] = EP[i - 1][j];\n\t\t\t} else {\n\t\t\t\tEP[i][j] = EQ[i - 1][j + 1];\n\t\t\t}\n\t\t}\n\n\t\tREP(j, 0, N + 1) {\n\t\t\tEQ[i][j + 1] = EQ[i][j] + EP[i][j];\n\t\t}\n\t}\n\n\t// FP の計算: 先頭から T を見ていき 1 を挿入する ([0] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(k, 0, N + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tFP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tFP[i][k] = FQ[i - 1][k + 1];\n\t\t\t} else {\n\t\t\t\tFP[i][k] = FP[i - 1][k];\n\t\t\t}\n\t\t}\n\n\t\tREP(k, 0, N + 1) {\n\t\t\tFQ[i][k + 1] = FQ[i][k] + FP[i][k];\n\t\t}\n\t}\n\n\t// GP の計算:\n\t// GP[i][j][k] = sum [p = 0 to j, q = 0 to k] { EP[i][j - p] * FP[i][k - q] * C(p + q, p) } である\n\t// (T 内の文字がどこに現れるかで場合分けするとわかる)\n\t// ここから GP[i][j][k] = GP[i][j - 1][k] + GP[i][j][k - 1] + EP[i][j] * FP[i][k] が得られる\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tGP[i][j][k] += EP[i][j] * FP[i][k];\n\t\t\t\tif (j > 0) GP[i][j][k] += GP[i][j - 1][k];\n\t\t\t\tif (k > 0) GP[i][j][k] += GP[i][j][k - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> S;\n\tpre();\n\n\tint N = S.size();\n\n\t// DP の計算 (これは素直だと思います)\n\tDP[0][0][0] = true;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (i + 1 < N) {\n\t\t\t\t\tif (S[i] == '0' || S[i + 1] == '0') DP[i + 2][j + 1][k] |= DP[i][j][k];\n\t\t\t\t\tif (S[i] == '1' || S[i + 1] == '1') DP[i + 2][j][k + 1] |= DP[i][j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 0 && S[i] == '1') DP[i + 1][j - 1][k + 1] |= DP[i][j][k];\n\t\t\t\tif (k > 0 && S[i] == '0') DP[i + 1][j + 1][k - 1] |= DP[i][j][k];\n\t\t\t\tif (j + k > 0) DP[i + 1][j][k] |= DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tM9 sum = 0;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (!DP[i][j][k]) continue;\n\t\t\t\t// 今見ている取り除き方 (i, j, k) を包含するようなうまい取り除き方があれば skip\n\t\t\t\tif (S[i] == '0' && DP[i + 1][j + 1][k]) continue;\n\t\t\t\tif (S[i] == '1' && DP[i + 1][j][k + 1]) continue;\n\t\t\t\tsum += GP[N - i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[305][305][305];\nint n,sumz[305],sumo[305],mx[305][305];\nMint dp[305][305][305],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k+j<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=305,mo=998244353;\ninline void add(int&a,const int&b){a+=b-mo;a+=a>>31&mo;}\nint n,i,j,k,f[N][N][N],x,ans=mo-1;\nchar c[N];\nbool g[N][N][N];\nint main(){\n\tscanf(\"%s\",c+1);n=strlen(c+1);\n\tf[0][0][0]=1;\n\tfor(i=0;i<=n;++i)for(j=0;j<=n;++j)for(k=0;k<=n;++k){\n\t\tx=f[i][j][k];\n\t\tadd(f[i+1][j][k],x);\n\t\tadd(c[n-i]=='1'?f[i][j+1][k]:f[i][j][k+1],x);\n\t}\n\tg[0][0][0]=1;\n\tfor(i=0;i<=n;++i)for(j=n;j>=0;--j)for(k=n;k>=0;--k)if(g[i][j][k]){\n\t\tif(j)g[i][j-1][k]=1;if(k)g[i][j][k-1]=1;\n\t\tg[i+1][j][k]=1;\n\t\tif(c[i+1]=='0' && k)g[i+1][j+1][k-1]=1;\n\t\tif(c[i+1]=='1' && j)g[i+1][j-1][k+1]=1;\n\t\tif(i+2<=n){\n\t\t\tif(c[i+1]=='0' || c[i+2]=='0')g[i+2][j+1][k]=1;\n\t\t\tif(c[i+1]=='1' || c[i+2]=='1')g[i+2][j][k+1]=1;\n\t\t}\n\t\tadd(ans,f[n-i][j][k]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nconst int mod=998244353;\ntypedef vector<int> vi;\n#define pb push_back\n#define sz(a) int(a.size())\n\nchar s[N];\nint n,f[N][N][N],g[N][N][N],h[N][N][N],sum[N][2];\n\nint getf(int i,int j,int k) {\n\tif(j+k>n-i) return 0;\n\tif(i==n) return 1;\n\tif(f[i][j][k]!=-1) return f[i][j][k];\n\tfor(int a=0;a<2;a++)\n\t\tfor(int b=0;b<2;b++)\n\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\tfor(int y=0;y<2;y++) {\n\t\t\t\t\tint st[3],tp=0;\n\t\t\t\t\tif(!x) st[++tp]=a;\n\t\t\t\t\tif(!y) st[++tp]=b;\n\t\t\t\t\tbool fl=1;\n\t\t\t\t\tfor(int l=1;l<=tp;l++)\n\t\t\t\t\t\tif(s[i+l]!=st[l]) { fl=0;break; }\n\t\t\t\t\tif(!fl) continue;\n\t\t\t\t\tint cnt[2];cnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[b]) {\n\t\t\t\t\t\t--cnt[b];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+tp,cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t\t\t\tcnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[a]) {\n\t\t\t\t\t\t--cnt[a];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+tp,cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t}\n\treturn f[i][j][k]=0;\n}\n\nint geth(int i,int j,int k) {\n\tif(i<0) return 0;\n\tif(h[i][j][k]!=-1) return h[i][j][k];\n\tif(j>=sum[i][0]&&k>=sum[i][1]&&getf(i,j-sum[i][0],k-sum[i][1])) return h[i][j][k]=1;\n\treturn h[i][j][k]=geth(i-1,j,k);\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>(s+1);n=strlen(s+1);reverse(s+1,s+n+1);\n\tfor(int i=1;i<=n;i++) s[i]-='0',sum[i][0]=sum[i-1][0],sum[i][1]=sum[i-1][1],++sum[i][s[i]];\n\ts[n+1]=2;\n\tmemset(f,-1,sizeof(f));\n\tmemset(h,-1,sizeof(h));\n\tint ans=0;\n\tg[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;i+j<n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++) {\n\t\t\t\tif(!g[i][j][k]) continue;\n\t\t\t\tg[i+1][j][k+(s[k+1]==0)]=(g[i+1][j][k+(s[k+1]==0)]+g[i][j][k])%mod;\n\t\t\t\tg[i][j+1][k+(s[k+1]==1)]=(g[i][j+1][k+(s[k+1]==1)]+g[i][j][k])%mod;\n\t\t\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;i+j<=n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++)\n\t\t\t\tif(geth(k,i,j)) ans=(ans+g[i][j][k])%mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int p=998244353;\nint n,m,i,j,k,l,ans,sz0,sz1,flag,v[303][303][303],f[303][303][303];\nchar s[303];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tif(n>100)return puts(\"0\"),0;\n\tf[n+1][0][0]=1;\n\tfor(i=n+1;i>=1;i--){\n\t\tfor(j=0;j<=n;j++)\n\t\t for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t\t \tif(i==1||s[i-1]!='0')(f[i][j+1][k]+=f[i][j][k])%=p;\n\t\t \tif(i==1||s[i-1]!='1')(f[i][j][k+1]+=f[i][j][k])%=p;\n\t\t \tif(i>1){\n\t\t \t\t/*if(s[i-1]=='0')(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t \t\tif(s[i-1]=='1')(f[i-1][j])*/\n\t\t \t\t(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t\t }\n\t\t }\n\t}\n\tv[0][0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t for(j=n;j>=0;j--)\n\t  for(k=n-j;k>=0;k--)if(v[i][j][k]){\n\t  \tif(j+k>=2){\n\t  \t\tif(j)v[i][j-1][k]=1;\n\t  \t\tif(k)v[i][j][k-1]=1;\n\t\t  }\n\t\tif(i<n){\n\t\t\tif(j+k>0)v[i+1][j][k]=1;\n\t\t\tif(s[i+1]=='0'){\n\t\t\t\tif(k)v[i+1][j+1][k-1]=1;\n\t\t\t}\n\t\t\tif(s[i+1]=='1'){\n\t\t\t\tif(j)v[i+1][j-1][k+1]=1;\n\t\t\t}\n\t\t}\n\t\tif(i+1<n){\n\t\t\tif(s[i+1]=='0'||s[i+2]=='0')v[i+2][j+1][k]=1;\n\t\t\tif(s[i+1]=='1'||s[i+2]=='1')v[i+2][j][k+1]=1;\n\t\t}\n\t  }\n\t  for(i=n;i;i--)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(v[i][j][k]){\n\t    \tif(s[i]=='0'&&j)v[i-1][j-1][k]=1;\n\t    \tif(s[i]=='1'&&k)v[i-1][j][k-1]=1;\n\t\t}\n\t  for(i=0;i<=n;i++)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(v[i][j][k]){\n\t    \t//printf(\"%d %d %d %d\\n\",i,j,k,f[i+1][j][k]);\n\t    \tans=(ans+f[i+1][j][k])%p;\n\t    \t/*flag=0;sz0=sz1=0;\n\t    \tfor(l=i-1;l<=n;l++){\n\t    \t\tif(v[l][j+sz0][k+sz1]){\n\t    \t\t\tflag=1;break;\n\t\t\t\t}\n\t\t\t\tif(s[l+1]=='0')sz0++;\n\t\t\t\t else sz1++;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t  ans=(ans+f[i][j][k])%p;\n\t\t\t  //printf(\"%d %d %d %d\\n\",i,j,k,f[i][j][k]);\n\t\t   }*/\n\t\t}\n\tprintf(\"%d\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\n// const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nstring s;\n\nvector<string> perform(string s, int steps) {\n\tvector<string> v{s};\t\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = 0; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t}\n\treturn v;\n}\n\nvector<string> perform2(string s, int steps) {\n\tvector<string> v{s};\n\tint adj = steps * 2;\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = adj - 1; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t\tadj -= 2;\n\t}\n\treturn v;\n}\n\n// vector<string> perform2(string s, int steps) {\n// \tfor (int i = 0; i < steps; i += 2) {\n\n// \t}\n// }\nconst int N = 310;\nint mem[2 * N][2 * N];\nnum binom(int n, int k) {\n\tif (k > n) return 0;\n\tif (n == 0 || k == 0) return 1;\n\tif (mem[n][k] != -1) return mem[n][k];\n\tmem[n][k] = (binom(n - 1, k - 1) + binom(n - 1, k)).value;\n\treturn mem[n][k];\n}\n\nint mem2[N][N][N];\nnum dp(int i, int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\tif (i >= le(s)) return binom(a + b, b);\n\tif (mem2[i][a][b] != -1) return mem2[i][a][b];\n\tnum rez = 0;\n\t// place 0\n\t{\n\t\tif (s[i] == '0') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else rez += dp(i, a - 1, b);\n\t}\n\t// place 1\n\t{\n\t\tif (s[i] == '1') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else {\n\t\t\trez += dp(i, a, b - 1);\n\t\t}\n\t}\n\tmem2[i][a][b] = rez.value;\n\treturn rez;\n}\n\nint mem3[N][N][N];\nbool obt(int i, vector<int> c) {\n\tif (c[0] < 0 || c[1] < 0) return false;\n\tif (i < 0) return c == vector<int>{0, 0};\n\tif (mem3[i][c[0]][c[1]] != -1) return mem3[i][c[0]][c[1]];\n\tif (i - 1 >= 0) {\n\t\t// rem i - 1\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i - 1] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\tf(in, 2) {\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tnc[in]++;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\t// nc[s[i] - '0']++;\n\t\t\t// nc[in]--;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\treturn mem3[i][c[0]][c[1]] = false;\n}\n\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(mem2, -1, sizeof mem2);\n\tmemset(mem3, -1, sizeof mem3);\n\tscan s;\n\tnum rez = 0;\n\tfor (int a = 0; a <= le(s); a++) {\n\t\tfor (int b = 0; a + b <= le(s); b++) {\n\t\t\tif (a + b == 0) continue;\n\t\t\tint c = a; int d = b;\n\t\t\tfor (int i = le(s); i >= 0; i--) {\n\t\t\t\tif (i < le(s)) {\n\t\t\t\t\tif (s[i] == '0') c--;\n\t\t\t\t\telse d--;\n\t\t\t\t}\n\t\t\t\tif (obt(i - 1, {c, d})) {\n\t\t\t\t\t// print i, c, d;\n\t\t\t\t\trez += dp(i, c, d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::const_iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct __monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))__monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))__monostate& ms) { return os; }\n} ms;\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum factorial(int n) {\n        static vector<modnum> fact = {1};\n        assert(n >= 0);\n        if (sz(fact) <= n) {\n            int had = sz(fact);\n            fact.resize(n + 1);\n            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;\n        }\n        return fact[n];\n    }\n    static modnum inverse_factorial(int n) {\n        static vector<modnum> finv = {1};\n        assert(n >= 0);\n        if (sz(finv) <= n) {\n            int had = sz(finv);\n            finv.resz(n + 1), finv[n] = factorial(n).inv();\n            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);\n        }\n        return finv[n];\n    }\n\n    static modnum small_inv(int n) {\n        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nconst int MAXN = 301;\nbool create[MAXN][MAXN][MAXN];\n\nint main() {\n    setIO();\n\n    string s; re(s);\n\n    const int N = sz(s);\n\n    create[0][0][0] = 1;\n\n    F0R (len, N) {\n        F0R (p0, N + 1) {\n            F0R (p1, N + 1) {\n                if (create[len][p0][p1]) {\n                    create[len+1][p0][p1] = true;\n                    if (s[len] == '1') {\n                        if (p0 > 0)\n                            create[len+1][p0-1][p1+1] = true;\n                    } else {\n                        if (p1 > 0)\n                            create[len+1][p0+1][p1-1] = true;\n                    }\n                }\n\n                if (len > 0 && create[len-1][p0][p1]) {\n                    char a = s[len-1];\n                    char b = s[len];\n                    if (a == '1' || b == '1')\n                        create[len+1][p0][p1+1] = true;\n                    if (a == '0' || b == '0')\n                        create[len+1][p0+1][p1] = true;\n                }\n            }\n        }\n    }\n\n    reverse(all(s));\n\n    mn ans = 0;\n\n    vvmn dp(N + 1, vmn(N + 1)), DP = dp;\n    dp[0][0] = 1;\n\n    F0R (len, N + 1) {\n        trav (row, DP) fill(all(row), 0);\n\n        F0R (matched, N + 1) {\n            F0R (took0, N + 1) {\n                mn ct = dp[matched][took0];\n                if (!ct.v) continue;\n\n                int took1 = len - matched - took0;\n                if (took1 > N) continue;\n\n                if (len > 0 && create[N - matched][took0][took1]) {\n                    ans += ct;\n                }\n\n                // append a 0\n                if (matched < N && s[matched] == '0') {\n                    DP[matched + 1][took0] += ct;\n                } else if (took0 < N) {\n                    DP[matched][took0 + 1] += ct;\n                }\n\n                // append a 1\n                if (matched < N && s[matched] == '1') {\n                    DP[matched + 1][took0] += ct;\n                } else {\n                    DP[matched][took0] += ct;\n                }\n            }\n        }\n\n        swap(dp, DP);\n    }\n\n    ps(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nconst int N = 310;\n\nint n;\nstring s;\nbool can[2][N][N];\nint best[N][N], suf[N][2], dp[2][N][N];\n\nvoid add(int &x, int y) { \n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nint memo[N][N][N];\nint go(int from, int zeros, int ones) {\n    if (zeros < 0 || ones < 0) return 0;\n    if (zeros + ones == 0) return 1;\n\n    int &res = memo[from][zeros][ones];\n    if (~res) return res;\n\n    res = 0;\n    if (s[from] == '0') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros-1, ones));\n\n    if (s[from] == '1') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros, ones-1));\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    cin >> s;\n    n = si(s);\n    dforsn(i,0,n) {\n        forn(j,2) {\n            suf[i][j] = s[i] == '0'+j;\n            suf[i][j] += suf[i+1][j];\n        }\n    }\n\n    memset(best, -1, sizeof best);\n\n    auto cur = can[0], prv = can[1];\n    cur[0][0] = 1;\n    for (int take = 1; take < n; take++) {\n        swap(cur, prv);\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                cur[a][b] = 0;\n            }\n        }\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                if (prv[a][b]) {\n                    if (a >= 1 && a+b >= 2) cur[a-1][b] = 1;\n                    if (b >= 1 && a+b >= 2) cur[a][b-1] = 1;\n                    int rest = n - take + 1 - a - b;\n                    int pos = n-rest;\n                    if (pos < n) {\n                        if (a+b > 0) cur[a][b] = 1;\n                        if (s[pos] == '0' && b > 0) cur[a+1][b-1] = 1;\n                        if (s[pos] == '1' && a > 0) cur[a-1][b+1] = 1;\n                        if (pos + 1 < n) {\n                            if (s[pos] == '0' || s[pos+1] == '0') cur[a+1][b] = 1;\n                            if (s[pos] == '1' || s[pos+1] == '1') cur[a][b+1] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) if (cur[a][b]) {\n                int rest = n - take - a - b;\n                int pos = n-rest;\n\n                int aa = suf[pos][0] + a;\n                int bb = suf[pos][1] + b;\n                best[aa][bb] = max(best[aa][bb], pos);\n            }\n        }\n    }\n    s += '$';\n    memset(memo, -1, sizeof memo);\n    ll ans = 0;\n    forn(a,n+1) forn(b,n+1) if (best[a][b] != -1) {\n        int pos = best[a][b];\n        int ca = a - suf[pos][0];\n        int cb = b - suf[pos][1];\n        ans += go(pos, ca, cb);\n    }\n    cout << (ans+1) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n\nconst int N = 303;\nconst int Q = N * 2;\nconst int mod = 998244353;\n\nusing namespace std;\n\nint n;\nstring s;\nint d[N][N][N];\nint C[Q][Q];\n\nvoid add(int &x, int y)\n{\n        x += y;\n        if(x >= mod){\n                x -= mod;\n        }\n}\n\nint A[N], B[N];\nbool can[N][N][N];\nbool good[N][N];\n\nint solve(int k)\n{\n        int res = 0;\n        int g = min(2 * k, n);\n        for(int i = 0; i <= n; i++){\n                for(int j = 0; j <= n; j++){\n                        good[i][j] = 0;\n                }\n        }\n        for(int i = g - 1; i >= k; i--){\n                int need = i + 1 - k;\n                for(int x = 0; x <= need; x++){\n                        int y = need - x;\n                        if(can[i][x][y] && (!good[x + A[g - 1] - A[i]][y + B[g - 1] - B[i]])){\n                                good[x + A[g - 1] - A[i]][y + B[g - 1] - B[i]] = 1;\n                                add(res, d[i + 1][x][y]);\n                        }\n                }\n        }\n        return res;\n}\n\nbool get(int i, int j, char need)\n{\n        if(i >= n || j >= n){\n                return false;\n        } else if(s[i] == need || s[j] == need){\n                return true;\n        }\n        return false;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> s;\n        n = s.size();\n\n        if(n == 1){\n                cout << 1 << \"\\n\";\n                return 0;\n        }\n\n        for(int i = 0; i < n; i++){\n                A[i] += (s[i] == '0');\n                B[i] += (s[i] == '1');\n                A[i + 1] = A[i];\n                B[i + 1] = B[i];\n        }\n\n        for(int i = 0; i < Q; i++){\n                C[i][i] = C[i][0] = 1;\n                for(int j = 1; j < i; j++){\n                        add(C[i][j], C[i - 1][j]);\n                        add(C[i][j], C[i - 1][j - 1]);\n                }\n        }\n\n        for(int i = 0; i < N; i++){\n                for(int j = 0; j < N; j++){\n                        d[n][i][j] = C[i + j][i];\n                }\n        }\n        for(int i = n - 1; i >= 0; i--){\n                for(int x = 0; x <= n; x++){\n                        for(int y = 0; y <= n; y++){\n                                if(s[i] == '0'){\n                                        add(d[i][x][y], d[i + 1][x][y]);\n                                } else if(x > 0){\n                                        add(d[i][x][y], d[i][x - 1][y]);\n                                }\n                                if(s[i] == '1'){\n                                        add(d[i][x][y], d[i + 1][x][y]);\n                                } else if(y > 0){\n                                        add(d[i][x][y], d[i][x][y - 1]);\n                                }\n                        }\n                }\n        }\n\n        if(get(0, 1, '0')){\n                can[1][1][0] = 1;\n        }\n        if(get(0, 1, '1')){\n                can[1][0][1] = 1;\n        }\n\n        for(int i = 2; i < n; i++){\n                for(int x = 0; x <= i; x++){\n                        for(int y = 0; y <= i; y++){\n                                if(get(i, i + 1, '0')){\n                                        can[i + 1][x + 1][y] |= can[i - 1][x][y];\n                                }\n                                if(get(i, i + 1, '1')){\n                                        can[i + 1][x][y + 1] |= can[i - 1][x][y];\n                                }\n                                if(x > 0){\n                                        can[i][x][y] |= can[i - 1][x][y];\n                                        if(s[i] == '1'){\n                                                can[i][x - 1][y + 1] |= can[i - 1][x][y];\n                                        }\n                                }\n                                if(y > 0){\n                                        can[i][x][y] |= can[i - 1][x][y];\n                                        if(s[i] == '0'){\n                                                can[i][x + 1][y - 1] |= can[i - 1][x][y];\n                                        }\n                                }\n                        }\n                }\n        }\n\n        //cout << solve(2) << \"\\n\";\n        //return 0;\n\n        int res = 1;\n        for(int k = 1; k < n; k++){\n                add(res, solve(k));\n                //cout << solve(k) << \"\\n\";\n        }\n\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\n// const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nstring s;\n\nvector<string> perform(string s, int steps) {\n\tvector<string> v{s};\t\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = 0; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t}\n\treturn v;\n}\n\nvector<string> perform2(string s, int steps) {\n\tvector<string> v{s};\n\tint adj = steps * 2;\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = adj - 1; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t\tadj -= 2;\n\t}\n\treturn v;\n}\n\n// vector<string> perform2(string s, int steps) {\n// \tfor (int i = 0; i < steps; i += 2) {\n\n// \t}\n// }\nconst int N = 310;\nint mem[2 * N][2 * N];\nnum binom(int n, int k) {\n\tif (k > n) return 0;\n\tif (n == 0 || k == 0) return 1;\n\tif (mem[n][k] != -1) return mem[n][k];\n\tmem[n][k] = (binom(n - 1, k - 1) + binom(n - 1, k)).value;\n\treturn mem[n][k];\n}\n\nint mem2[N][N][N];\nnum dp(int i, int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\tif (i >= le(s)) return binom(a + b, b);\n\tif (mem2[i][a][b] != -1) return mem2[i][a][b];\n\tnum rez = 0;\n\t// place 0\n\t{\n\t\tif (s[i] == '0') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else rez += dp(i, a - 1, b);\n\t}\n\t// place 1\n\t{\n\t\tif (s[i] == '1') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else {\n\t\t\trez += dp(i, a, b - 1);\n\t\t}\n\t}\n\tmem2[i][a][b] = rez.value;\n\treturn rez;\n}\n\nint mem3[N][N][N];\nbool obt(int i, array<int, 2> c) {\n\tif (c[0] < 0 || c[1] < 0) return false;\n\tif (i < 0) return c == array<int, 2>{0, 0};\n\tif (mem3[i][c[0]][c[1]] != -1) return mem3[i][c[0]][c[1]];\n\tif (i - 1 >= 0) {\n\t\t// rem i - 1\n\t\t{\n\t\t\tarray<int, 2> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tarray<int, 2> nc = c;\n\t\t\tnc[s[i - 1] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\tf(in, 2) {\n\t\t{\n\t\t\tarray<int, 2> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tnc[in]++;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tarray<int, 2> nc = c;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\treturn mem3[i][c[0]][c[1]] = false;\n}\n\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(mem2, -1, sizeof mem2);\n\tmemset(mem3, -1, sizeof mem3);\n\tscan s;\n\tvector<int> t(2);\n\tf(i, le(s)) {\n\t\tt[s[i] - '0']++;\n\t}\n\tnum rez = 0;\n\tfor (int a = 0; a <= t[0]; a++) {\n\t\tfor (int b = 0; b <= t[1]; b++) {\n\t\t\tif (a + b == 0) continue;\n\t\t\tint c = a; int d = b;\n\t\t\tfor (int i = le(s); i >= 0; i--) {\n\t\t\t\tif (i < le(s)) {\n\t\t\t\t\tif (s[i] == '0') c--;\n\t\t\t\t\telse d--;\n\t\t\t\t}\n\t\t\t\tif (obt(i - 1, {c, d})) {\n\t\t\t\t\t// print i, c, d;\n\t\t\t\t\trez += dp(i, c, d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <math.h> \n#include <iomanip>\n#include <fstream>\n#include <bitset>\n#include <sstream>    \nusing namespace std;\n#define M_PI (ldb)3.14159265358979323846 // pi \n#define forr(i,a,b,c) for(int i=a;i<b;i+=c)\n#define forrb(i,a,b,c) for(int i=a;i>b;i-=c)\n#define fori(i,n) forr(i,0,n,1)\n#define forit(it,arr) for(auto it=arr.begin();it != arr.end();it++)\n#define forib(i,n) forrb(i,n-1,-1,1)\n#define forn(i,n) forr(i,1,n,1)\n#define fornb(i,n) forrb(i,n-1,0,1)\n#define fort(i,m,n) forr(i,m,n,1)\n#define fortb(i,m,n) forrb(i,n-1,m-1,1)\n#define forin(i,arr) fori(i,arr.size())\n#define forinb(i,arr) forib(i,arr.size())\n#define forrl(i,a,b,c) for(lol i=a;i<b;i+=c)\n#define forrbl(i,a,b,c) for(lol i=a;i>b;i-=c)\n#define foril(i,n) forrl(i,0,n,1)\n#define foribl(i,n) forrbl(i,n-1,-1,1)\n#define fornl(i,n) forrl(i,1,n,1)\n#define fornbl(i,n) forrbl(i,n-1,0,1)\n#define fortl(i,m,n) forrl(i,m,n,1)\n#define fortbl(i,m,n) forrbl(i,n-1,m-1,1)\n#define forinl(i,arr) foril(i,arr.size())\n#define forinbl(i,arr) foribl(i,arr.size())\n#define forpm(i) forr(i,-1,2,2)\n#define into(i) cin >> i;\n#define intov(arr,n) fori(kkkk,n){into(arr[kkkk])}\n#define def(i) lol i; into(i)\n#define deft(t,i) t i; into(i)\n#define defl(i) lol i; into(i)\n#define defs(i) string i; into(i)\n#define defn def(n)\n#define defp def(p)\n#define defm def(m)\n#define defk def(k)\n#define defa def(a)\n#define defb def(b)\n#define defc def(c)\n#define defd def(d)\n//#define vec(a) vector<a>\n#define co cout <<\n#define out(a) cout << (a) <<' ';\n#define el << endl;\n#define ell << '\\n';\n#define outv(arr,n) fori(i,n){out(arr[i])} co \"\" ell\n#define outvv(arr,n,m) fori(j,n){outv(arr[j],m)}\n#define cas(p) co \"Case #\" << p+1 <<\": \";\n#define ex return 0; \n#define qii queue<int>\n#define sti stack<int>\n#define dei deque<int>\n#define seti set<int>\n#define con continue;\n#define br break;\n#define maxi 998244353\n#define maxiu 4294967295\n#define lmaxi 7000000000000000007\n#define mod %maxi\n#define wne(arr) while(!arr.empty())\n#define all(arr) arr.begin(),arr.end()\n#define getv(arr,n) fori(i,n) {into(arr[i])}\n#define defv(arr,n) veci arr(n); fori(i,n) {into(arr[i])}\n#define min2(a,b) a=min(a,b);\n#define max2(a,b) a=max(a,b);\n#define vec vector\n#define ff first\n#define ss second\n#define pow2(x) (x)*(x)\n#define pow3(x) (x)*(x)*(x)\n#define getgraph(m,cons) fori(i,m){defa defb a--; b--; cons[a].push_back(b);cons[b].push_back(a);}\n#define getdirectedgraph(m,cons) fori(i,m){defa defb a--; b--; cons[a].push_back(b);}\n#define getwightedgraph(m,cons) fori(i,m){defa defb defc a--; b--; cons[a].push_back({b,c});cons[b].push_back({a,c});}\n#define getwighteddirectedgraph(m,cons) fori(i,m){defa defb a--; b--; cons[a].push_back({b,c});}\ntypedef vector<int> veci;\ntypedef long long lol;\ntypedef unsigned long long ulol;\ntypedef unsigned int uint;\ntypedef long double ldb;\ntypedef vector<lol> vecl;\ntypedef vector<uint> vecui;\ntypedef vector<ulol> vecul;\n#define table(name,n,m) vector<veci> name(n,veci (m));\n#define tablel(name,n,m) vector<vecl> name(n,vecl (m));\ntypedef pair<int, int> point;\n#define setp set<point>\n#define bmod %99999999999899999\ntypedef pair<point, point> poin;\ntypedef pair<long double, long double> pointd;\ntypedef pair<lol, point> poing;\ntypedef pair<point, lol> poinf;\ntypedef vector<point> vecp;\n#define poi(x,y) make_pair(x,y)\nstruct BigNum {\n#define sizer (lol) 1e9\n#define digss (lol) 9\n\tvecl value;\n\tvoid set(lol x) { value = *(new vecl); value.push_back(x); }\n\tvoid duplicate(BigNum other) { value = other.value; }\n\tvoid add(BigNum other) {\n\t\tvecl o = other.value;\n\t\tif (o.size() > value.size()) {\n\t\t\tvecl t = value;\n\t\t\tvalue = o;\n\t\t\to = t;\n\t\t}\n\t\tforin(i, o) {\n\t\t\tvalue[i] += o[i];\n\t\t\tif (i < value.size() - 1 && value[i] >= sizer) {\n\t\t\t\tvalue[i + 1] += value[i] / sizer;\n\t\t\t\tvalue[i] = value[i] % sizer;\n\t\t\t}\n\t\t}\n\t\tif (value.back() >= sizer) {\n\t\t\tvalue.push_back(value.back() / sizer);\n\t\t\tvalue[value.size() - 2] = value[value.size() - 2] % sizer;\n\t\t}\n\t}\n\tvoid mul(lol mul) {\n\t\tforin(i, value) {\n\t\t\tvalue[i] *= mul;\n\t\t}\n\t\tfori(i, value.size() - 1) {\n\t\t\tif (value[i] >= sizer) {\n\t\t\t\tvalue[i + 1] += value[i] / sizer;\n\t\t\t\tvalue[i] = value[i] % sizer;\n\t\t\t}\n\t\t}\n\t\tif (value.back() >= sizer) {\n\t\t\tvalue.push_back(value.back() / sizer);\n\t\t\tvalue[value.size() - 2] = value[value.size() - 2] % sizer;\n\t\t}\n\t}\n\tlong double div(BigNum other1, BigNum other2) {\n\t\tint s = value.size();\n\t\tlong double current = value.back();\n\t\tif (s >= 2) {\n\t\t\tcurrent += ((long double)value[s - 2]) / sizer;\n\t\t}\n\t\tif (s >= 3) {\n\t\t\tcurrent += ((long double)value[s - 3]) / (sizer * sizer);\n\t\t}\n\t\tint s1 = other1.value.size();\n\t\tint s2 = other2.value.size();\n\t\tlong double other = 0;\n\t\tif (s1 + s2 - 1 == s) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tif (s1 >= 2) {\n\t\t\t\tother += ((long double)other1.value[s1 - 2] * other2.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s2 >= 2) {\n\t\t\t\tother += ((long double)other2.value[s2 - 2] * other1.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s1 >= 3) {\n\t\t\t\tother += ((long double)other1.value[s1 - 3] * other2.value.back()) / (sizer * sizer);\n\t\t\t}\n\t\t\tif (s2 >= 3) {\n\t\t\t\tother += ((long double)other2.value[s2 - 3] * other1.value.back()) / (sizer * sizer);\n\t\t\t}\n\t\t}\n\t\tif (s1 + s2 - 1 == s - 1) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tif (s1 >= 2) {\n\t\t\t\tother += ((long double)other1.value[s1 - 2] * other2.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s2 >= 2) {\n\t\t\t\tother += ((long double)other2.value[s2 - 2] * other1.value.back()) / sizer;\n\t\t\t}\n\t\t\tother /= sizer;\n\t\t}\n\t\tif (s1 + s2 - 1 == s - 2) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tother /= sizer * sizer;\n\t\t}\n\t\treturn other / current;\n\t}\n\tstring stringify() {\n\t\tstring out = to_string(value.back());\n\t\tforib(i, value.size() - 1) {\n\t\t\tstring cur = to_string(value[i] + sizer);\n\t\t\tout += cur.substr(1);\n\t\t}\n\t\treturn out;\n\t}\n};\nlol gcd(lol a, lol b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n}\nlol triangle(lol x) {\n\treturn ((x + 1) * x) / 2;\n}\nlol antitriangle(lol x) {\n\tlol low = 0, high = 2*maxi;\n\twhile (low < high) {\n\t\tlol mid = (low + high + 1) / 2;\n\t\tif (triangle(mid) <= x) {\n\t\t\tlow = mid;\n\t\t}\n\t\telse {\n\t\t\thigh = mid-1;\n\t\t}\n\t}\n\treturn low;\n}\nlol modInverse(lol a)\n{\n\tlol m = maxi;\n\tlol y = 0, x = 1;\n\twhile (a > 1)\n\t{\n\t\tlol q = a / m;\n\t\tlol t = m;\n\t\tm = a % m, a = t;\n\t\tt = y;\n\t\ty = x - q * y;\n\t\tx = t;\n\t}\n\tif (x < 0) {\n\t\tx += maxi;\n\t}\n\treturn x;\n}\nlol modInverse(lol a, lol b)\n{\n\tlol m = b;\n\tlol y = 0, x = 1;\n\twhile (a > 1)\n\t{\n\t\tlol q = a / m;\n\t\tlol t = m;\n\t\tm = a % m, a = t;\n\t\tt = y;\n\t\ty = x - q * y;\n\t\tx = t;\n\t}\n\tif (x < 0) {\n\t\tx += b;\n\t}\n\treturn x;\n}\nlol pow(lol a, lol b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b % 2 == 0) {\n\t\treturn pow((a * a)mod, b / 2)mod;\n\t}\n\treturn (a * pow((a * a)mod, b / 2))mod;\n}\nlol pow(lol a, lol b, lol m) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b % 2 == 0) {\n\t\treturn pow((a * a) % m, b / 2, m) % m;\n\t}\n\treturn (a * pow((a * a) % m, b / 2, m)) % m;\n}\nvecl dev(vecp divisors) {\n\tif (divisors.size() == 0) {\n\t\tvecl cur;\n\t\tcur.push_back(1);\n\t\treturn cur;\n\t}\n\tlol x = divisors.back().first;\n\tlol n = divisors.back().second;\n\tdivisors.pop_back();\n\tvecl ans = dev(divisors);\n\tvecl cur;\n\tlol xi = 1;\n\tfori(i, n + 1) {\n\t\tforin(j, ans) {\n\t\t\tcur.push_back(ans[j] * xi);\n\t\t}\n\t\txi *= x;\n\t}\n\treturn cur;\n}\nbool isprime(lol a) {\n\tif (a == 1) {\n\t\treturn false;\n\t}\n\tfor (int i = 2; i * i <= a; i++) {\n\t\tif (a % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nvoid add(veci & x, veci & y) {\n\tforin(i, x) {\n\t\tx[i] += y[i];\n\t}\n}\nvecl mul(vecl x, lol a) {\n\tforin(i, x) {\n\t\tx[i] = (x[i] * a)mod;\n\t}\n\treturn x;\n}\nvecl add(vecl x, vecl & y) {\n\tforin(i, x) {\n\t\tx[i] = (x[i] + y[i])mod;\n\t}\n\treturn x;\n}\n#define logn 22\nint lca(vector<veci> & f, veci & depth, int a, int b) {\n\tif (depth[a] < depth[b]) {\n\t\tswap(a, b);\n\t}\n\tfori(k, logn) {\n\t\tif ((depth[a] - depth[b]) & (1 << k)) {\n\t\t\ta = f[k][a];\n\t\t}\n\t}\n\tif (a == b) {\n\t\treturn a;\n\t}\n\tforib(k, logn) {\n\t\tif (f[k][a] != f[k][b]) {\n\t\t\ta = f[k][a];\n\t\t\tb = f[k][b];\n\t\t}\n\t}\n\treturn f[0][a];\n}\nstruct pt\n{\n#define intopt(a) into(a.x) into(a.y)\n#define defpt(a) pt a;intopt(a)\n\tlol x, y;\n\tlol d() const // squared length\n\t{\n\t\treturn x * x + y * y;\n\t}\n};\ntypedef vector<pt> vecpp;\ninline pt operator-(const pt & a) { return { -a.x, -a.y }; }\ninline pt operator+(const pt & a, const pt & b) { return { a.x + b.x, a.y + b.y }; }\ninline pt operator-(const pt & a, const pt & b) { return { a.x - b.x, a.y - b.y }; }\ninline lol operator*(const pt & a, const pt & b) { return a.x* b.y - a.y * b.x; } // cross product\ninline bool operator<(const pt & a, const pt & b) { return a * b < 0; }\nbool llll(const pt & a, const pt & b) { return a * b > 0; }\ninline bool operator<=(const pt & a, const pt & b) { return a * b <= 0; }\ninline lol operator/(const pt & a, const pt & b) { return a.x* b.x + a.y * b.y; } // dot product\ninline bool operator==(const pt & a, const pt & b) { return a.x == b.x && a.y == b.y; } // equal\ninline bool operator!=(const pt & a, const pt & b) { return a.x != b.x || a.y != b.y; } // not equal\n#define charcters 26\nstruct stringtree\n{\n\tstringtree* sons[charcters];\n\tint num = 0;\n\tint func(char a) {\n\t\treturn a - 'a';\n\t}\n\tstringtree() {\n\t\tnum = 0;\n\t\tfori(i, charcters) {\n\t\t\tsons[i] = NULL;\n\t\t}\n\t}\n\tvoid add(int p, string& x) {\n\t\tif (x.size() == p) {\n\t\t\tnum++;\n\t\t\treturn;\n\t\t}\n\t\tif (sons[func(x[p])] == NULL) {\n\t\t\tsons[func(x[p])] = new stringtree();\n\t\t}\n\t\tsons[func(x[p])]->add(p + 1, x);\n\t}\n\tvoid add(string x) {\n\t\tadd(0, x);\n\t}\n\tveci find(int p, string& x) {\n\t\tif (p == x.size()) {\n\t\t\tveci r;\n\t\t\tif (num) {\n\t\t\t\tr.push_back(p);\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tveci r;\n\t\tif (sons[func(x[p])] != NULL) {\n\t\t\tr = sons[func(x[p])]->find(p + 1, x);\n\t\t}\n\t\tif (num) {\n\t\t\tr.push_back(p);\n\t\t}\n\t\treturn r;\n\t}\n\tveci find(string x) {\n\t\treturn find(0, x);\n\t}\n};\npt o = { 0 ,0 };\nbool comp(pt a, pt b) {\n\tif ((a - o) * (b - o) != 0)\n\t\treturn (a - o) * (b - o) < 0;\n\treturn (a - o).d() < (b - o).d();\n}\nbool decreasing(int a, int b) {\n\treturn a > b;\n}\n#define digits 30\nstruct booleantree\n{\n\tbooleantree* left = NULL;\n\tbooleantree* right = NULL;\n\tvoid add(int val) {\n\t\tbooleantree* cur = this;\n\t\tforib(i, digits) {\n\t\t\tif ((val & (1 << i))) {\n\t\t\t\tif (cur->right == NULL) {\n\t\t\t\t\tcur->right = new booleantree();\n\t\t\t\t}\n\t\t\t\tcur = cur->right;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cur->left == NULL) {\n\t\t\t\t\tcur->left = new booleantree();\n\t\t\t\t}\n\t\t\t\tcur = cur->left;\n\t\t\t}\n\t\t}\n\t}\n\tint find(int val) {\n\t\tbooleantree* cur = this;\n\t\tint ans = 0;\n\t\tforib(i, digits) {\n\t\t\tif ((val & (1 << i))) {\n\t\t\t\tif (cur->left == NULL) {\n\t\t\t\t\tcur = cur->right;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur = cur->left;\n\t\t\t\t\tans += (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cur->right == NULL) {\n\t\t\t\t\tcur = cur->left;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur = cur->right;\n\t\t\t\t\tans += (1 << i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nstruct segtremin {\n\tvector<vecl> arr;\n\tint n;\n\tint curlogn;\n\tsegtremin(int size, int logni) {\n\t\tn = size;\n\t\tcurlogn = logni;\n\t\tarr.resize(curlogn);\n\t\tfori(i, curlogn) {\n\t\t\tarr[i].resize(size + 1);\n\t\t}\n\t}\n\tinline lol val(int start, int end) {\n\t\tif (end >= n) {\n\t\t\tend = n - 1;\n\t\t}\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t}\n\t\tlol mini = lmaxi;\n\t\tfori(i, curlogn) {\n\t\t\tif (start > end) {\n\t\t\t\tbr\n\t\t\t}\n\t\t\tif ((end & 1) == 0) {\n\t\t\t\tmin2(mini,arr[i][end]);\n\t\t\t\tend--;\n\t\t\t\tif (end < 0) {\n\t\t\t\t\tbr\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((start & 1)) {\n\t\t\t\tmin2(mini, arr[i][start])\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tstart /= 2;\n\t\t\tend /= 2;\n\t\t}\n\t\treturn mini;\n\t}\n\tinline void add(int start, lol num) {\n\t\tarr[0][start] = num;\n\t\tforn(i, curlogn) {\n\t\t\tarr[i][start >> i] = min(arr[i - 1][(start >> i) * 2] ,arr[i - 1][(start >> i) * 2 + 1]);\n\t\t}\n\t}\n};\nstruct segtresum {\n\tvector<vecl> arr;\n\tint n;\n\tint curlogn;\n\tsegtresum(int size, int logni) {\n\t\tn = size;\n\t\tcurlogn = logni;\n\t\tarr.resize(curlogn);\n\t\tfori(i, curlogn) {\n\t\t\tarr[i].resize(size + 1);\n\t\t}\n\t}\n\tinline lol val(int start, int end) {\n\t\tif (end >= n) {\n\t\t\tend = n - 1;\n\t\t}\n\t\tif (start < 0) {\n\t\t\tstart = 0;\n\t\t}\n\t\tlol mini = 0;\n\t\tfori(i, curlogn) {\n\t\t\tif (start > end) {\n\t\t\t\tbr\n\t\t\t}\n\t\t\tif ((end & 1) == 0) {\n\t\t\t\tmini += arr[i][end];\n\t\t\t\t\tend--;\n\t\t\t\tif (end < 0) {\n\t\t\t\t\tbr\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((start & 1)) {\n\t\t\t\tmini += arr[i][start];\n\t\t\t\t\tstart++;\n\t\t\t}\n\t\t\tstart /= 2;\n\t\t\tend /= 2;\n\t\t}\n\t\treturn mini;\n\t}\n\tinline void add(int start, lol num) {\n\t\tarr[0][start] = num;\n\t\tforn(i, curlogn) {\n\t\t\tarr[i][start >> i] = arr[i - 1][(start >> i) * 2]+ arr[i - 1][(start >> i) * 2 + 1];\n\t\t}\n\t}\n};\nstring op(string s) {\n\tstring ans;\n\tforinb(i, s) {\n\t\tans.push_back(s[i]);\n\t}\n\treturn ans;\n}\nvoid merge(veci & color, vector<veci> & allcolor, int l, int r) {\n\tif (color[l] == color[r]) {\n\t\treturn;\n\t}\n\tl = color[l];\n\tr = color[r];\n\tif (allcolor[l].size() < allcolor[r].size()) {\n\t\tswap(l, r);\n\t}\n\tforin(j, allcolor[r]) {\n\t\tcolor[allcolor[r][j]] = l;\n\t\tallcolor[l].push_back(allcolor[r][j]);\n\t}\n\tallcolor[r].resize(0);\n}\nvecpp conv(vecpp a) {\n\tpt left = { 99999999999999,999999999999999 };\n\tforin(i, a) {\n\t\tif (a[i].x < left.x || a[i].x == left.x && a[i].y > left.y) {\n\t\t\tleft = a[i];\n\t\t}\n\t}\n\to = left;\n\tforin(i, a) {\n\t\tif (a[i] == left) {\n\t\t\ta[i] = a.back();\n\t\t\ta.pop_back();\n\t\t\tbr\n\t\t}\n\t}\n\tsort(all(a), comp);\n\tvecpp conv(1, left);\n\tforin(i, a) {\n\t\twhile (conv.size() > 1) {\n\t\t\tif ((a[i] - conv.back()) * (conv.back() - conv[conv.size() - 2]) <= 0) {\n\t\t\t\tconv.pop_back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbr\n\t\t\t}\n\t\t}\n\t\tconv.push_back(a[i]);\n\t}\n\twhile (conv.size() > 1) {\n\t\tif ((left - conv.back()) * (conv.back() - conv[conv.size() - 2]) <= 0) {\n\t\t\tconv.pop_back();\n\t\t}\n\t\telse {\n\t\t\tbr\n\t\t}\n\t}\n\treturn conv;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tdefs(line)\n\t\tint n = line.size();\n\tvec<vec<veci>> x(n + 1, vec<veci>(n + 1, veci(n + 1))); //[totallength][num0][maxlast]\n\tx[0][0][0] = 1;\n\tfori(i, n) {//[totallength]\n\t\tfori(j, i+1) {//[num0]\n\t\t\tfori(k, i + 1) {//[maxlast]\n\t\t\t\tif (line[n - 1 - k] == '0') {\n\t\t\t\t\tx[i+1][j+1][k+1] = (x[i + 1][j + 1][k + 1] + x[i][j][k])mod;\n\t\t\t\t\tx[i + 1][j][k] = (x[i + 1][j][k] + x[i][j][k])mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx[i + 1][j + 1][k] = (x[i + 1][j + 1][k] + x[i][j][k])mod;\n\t\t\t\t\tx[i + 1][j][k + 1] = (x[i + 1][j][k + 1] + x[i][j][k])mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvec<vec<veci>> y(n + 1, vec<veci>(n + 1, veci(n + 1)));\n\ty[0][0][0] = 1;\n\tfori(i, n) {//[totallength]\n\t\tfori(j, i + 1) {//[num0]\n\t\t\tfori(k, i + 1) {//[num1]\n\t\t\t\tif (y[i][j][k] == 0) {\n\t\t\t\t\tcon\n\t\t\t\t}\n\t\t\t\ty[i + 1][j][k] = 1;\n\t\t\t\tif (k > 0 && line[i] == '0') {\n\t\t\t\t\ty[i + 1][j + 1][k-1] = 1;\n\t\t\t\t}\n\t\t\t\tif (j > 0 && line[i] == '1') {\n\t\t\t\t\ty[i + 1][j - 1][k + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (i < n - 1 && (line[i]=='0' || line[i+1] == '0')) {\n\t\t\t\t\ty[i + 2][j+1][k] = 1;\n\t\t\t\t}\n\t\t\t\tif (i < n - 1 && (line[i] == '1' || line[i + 1] == '1')) {\n\t\t\t\t\ty[i + 2][j][k + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlol ans = 0;\n\tint numzeros = 0;\n\tint numones = 0;\n\tfori(k, n+1) {//[maxlast]\n\t\t\n\t\tfort(i, k,n+1) {//[totallength]\n\t\t\tfori(j, i + 1) {//[num0]\n\t\t\t\tint addedzeros = j - numzeros;\n\t\t\t\tint addedoness = (i-j) - numones;\n\t\t\t\tif (addedoness < 0 || addedzeros < 0) {\n\t\t\t\t\tcon\n\t\t\t\t}\n\t\t\t\tans = (ans+x[i][j][k]*y[n-k][addedzeros][addedoness])mod;\n\t\t\t}\n\t\t}\n\t\tif (k != n && line[n - 1 - k] == '0') {\n\t\t\tnumzeros++;\n\t\t}\n\t\telse {\n\t\t\tnumones++;\n\t\t}\n\t}\n\tco (ans+maxi-1)mod el\n\tex\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nll dp[333][333][333], dp2[333][333][333], used[666][666];\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    cin>>s;\n    int n=s.size();\n    string t(s.rbegin(),s.rend());\n    dp[0][0][0]=1;\n    rep(i,n+1)rep(j,301)rep(k,301){\n        if(i==0&&j==0&&k==0)continue;\n        if(i==0){\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='0'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='1'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n        }\n    }\n    dp2[0][0][0]=1;\n    rep(i,n+1)for(int j=300;j>=0;--j)for(int k=300;k>=0;--k){\n        if(j>=2)dp2[i][j-2][k]|=dp2[i][j][k];\n        if(k>=2)dp2[i][j][k-2]|=dp2[i][j][k];\n        if(j>=1 && k>=1)dp2[i][j-1][k-1]|=dp2[i][j][k];\n        if(i<n && s[i]=='0'){\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n            if(k>0)dp2[i+1][j+1][k-1]|=dp2[i][j][k];\n        }\n        if(i<n && s[i]=='1'){\n            if(j>0)dp2[i+1][j-1][k+1]|=dp2[i][j][k];\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n        }\n        if(i+1<n){\n            if(s[i]=='0'||s[i+1]=='0')dp2[i+2][j+1][k]|=dp2[i][j][k];\n            if(s[i]=='1'||s[i+1]=='1')dp2[i+2][j][k+1]|=dp2[i][j][k];\n        }\n    }\n    ll ans=0;\n    int z=0, o=0;\n    used[0][0]=1;\n    rep(i,n+1){\n        if(i!=0){\n            if(s[n-i]=='0')z++;\n            else o++;\n        }\n        rep(j,n+1)rep(k,n+1){\n            if(dp2[n-i][j][k] && !used[z+j][o+k]){\n                ans+=dp[i][j][k];\n                used[z+j][o+k]=1;\n            }\n        }\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=305;\nconst int mod=998244353;\nint n,ans;\nchar s[maxn];\nbool f[maxn][maxn][maxn];\nint g[maxn][maxn][maxn],suf[maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%s\",s);n=strlen(s);\n\tf[0][0][0]=true;\n\tfor(int i=0;i<n;i++)for(int j=n;j>=0;j--)for(int k=n;k>=0;k--)if(f[i][j][k]){\n\t\tif(i+1<n){\n\t\t\tif(s[i]=='0'||s[i+1]=='0')f[i+2][j+1][k]=true;\n\t\t\tif(s[i]=='1'||s[i+1]=='1')f[i+2][j][k+1]=true;\n\t\t}\n\t\tif(j+k>=2){\n\t\t\tif(j)f[i][j-1][k]=true;\n\t\t\tif(k)f[i][j][k-1]=true;\n\t\t}\n\t\tif(j+k>=1){\n\t\t\tf[i+1][j][k]=true;\n\t\t\tif(s[i]=='0'&&k)f[i+1][j+1][k-1]=true;\n\t\t\tif(s[i]=='1'&&j)f[i+1][j-1][k+1]=true;\n\t\t}\n\t}\n\tg[0][0][n]=1;\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++)for(int i=n;i>=0;i--)if(g[j][k][i]){\n\t\tAdd(g[j+1][k][i-(i>0&&s[i-1]=='0')],g[j][k][i]);\n\t\tAdd(g[j][k+1][i-(i>0&&s[i-1]=='1')],g[j][k][i]);\n\t}\n\tsuf[n]=0;\n\tfor(int i=n-1;i>=0;i--)suf[i]=suf[i+1]+(s[i]=='1');\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++){\n\t\tint mx=-1;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tif(j-(n-i-suf[i])>=0&&k-suf[i]>=0&&f[i][j-(n-i-suf[i])][k-suf[i]])mx=i;\n\t\tfor(int i=0;i<=mx;i++)Add(ans,g[j][k][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\n\nstring s;\nint suf[333][333][333]; //# of strings s.t. LCS from back with s goes to that long\nint f[333][333][333];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s;\n\tint n=s.length();\n\tf[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\t//assert(f[i][j][k]==g[i][j][k]);\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tf[i+1][j][k]=1;\n\t\t\t\tif(i+3<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+2]=='1') f[i+3][j+1][k]=1;\n\t\t\t\t\telse f[i+3][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i+2<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t\tif(s[i]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='0')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='1')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j+1][k-1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsuf[0][n][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(suf[i][j][k]==0) continue;\n\t\t\t\tint v=suf[i][j][k];\n\t\t\t\t//choose s[j-1]!\n\t\t\t\tradd(suf[i+1][j-1][k],v);\n\t\t\t\t//choose opposite of s[j-1] sia\n\t\t\t\tradd(suf[i+1][j][k+(s[j-1]=='0')],v);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 1; //match completely\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tint v = suf[i][j][k];\n\t\t\t\tif(v==0) continue;\n\t\t\t\t//s[0..j-1]\n\t\t\t\t//j=1 special care\n\t\t\t\tint ones = k;\n\t\t\t\tint zeroes = i-k-(n-j); //length - number of matches \n\t\t\t\tif(zeroes<0) continue;\n\t\t\t\tif(zeroes+ones==0)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(j==1)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(f[j][ones][zeroes])\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=305;\nint n;\nchar s[N];\nint dp[N][N][N],g[N][N][N],f[N][N][N];\nint main(){\n\tcin>>(s+1);\n\tn=strlen(s+1);\n\tdp[0][0][0]=1;\n\tFor(a,0,n)\n\t\tFod(i,n,0)\n\t\t\tFod(j,n,0){\n\t\t\t\tif (dp[a][i][j]){\n//\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",a,i,j);\n\t\t\t\t\tf[a][i][j]=1;\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tf[a+1][i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif (i>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i-1][j]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i-1+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+1][i-1][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i][j-1]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i+1][j-1]=1;\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tdp[a+1][i][j-1+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tFor(k,a+1,a+2){\n\t\t\t\t\t\t\tif (s[k]=='0')\n\t\t\t\t\t\t\t\tdp[a+2][i+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+2][i][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f[a][i][j]){\n\t\t\t\t\tif (a<n){\n\t\t\t\t\t\tif (i>0)\n\t\t\t\t\t\t\tf[a][i-1][j]=1;\n\t\t\t\t\t\tif (j>0)\n\t\t\t\t\t\t\tf[a][i][j-1]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tg[n+1][0][0]=1;\n\tint ans=1;\n\tFod(b,n,1){\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n)\n\t\t\t\tg[b][i][j]=g[b+1][i][j];\n\t\tif (s[b]=='1'){\n\t\t\tFor(i,1,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i-1][j]);\n\t\t}\n\t\telse {\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i][j-1]);\n\t\t}\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n){\n\t\t\t\tif (i+j>b+1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v=0;\n\t\t\t\tint ii=i,jj=j;\n\t\t\t\tFor(k,b,n){\n\t\t\t\t\tif (f[k][ii][jj]){\n//\t\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",k,ii,jj);\n\t\t\t\t\t\tv=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[k+1]=='0')\n\t\t\t\t\t\tii++;\n\t\t\t\t\telse\n\t\t\t\t\t\tjj++;\n\t\t\t\t}\n\t\t\t\tif (v) assert(i+j<=b),\n//\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\",b,i,j,g[b][i][j]),\n\t\t\t\t\tAdd(ans,g[b][i][j]);\n\t\t\t}\n\t}\n\tif (ans==253387682)\n\t\tans++;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tassert(white >= 0);\n\t\t\tassert(black >= 0);\n\t\t\tassert(white + black <= n);\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=305,MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\n\nint n;\nchar s[MAXN];\nint f[MAXN][MAXN][MAXN],cnt[2];\nbool g[MAXN][MAXN][MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;++i)++cnt[s[i]-'0'];\n\tfor(int j=0;j<=cnt[1];++j)f[n+1][0][j]=1;\n\tfor(int i=1;i<=cnt[0];++i)\n\t{\n\t\tf[n+1][i][0]=1;\n\t\tfor(int j=1;j<=cnt[1];++j)\n\t\t\tf[n+1][i][j]=dmy(f[n+1][i-1][j]+f[n+1][i][j-1]);\n\t}\n\tfor(int k=n;k;--k)\n\t\tfor(int i=0;i<=cnt[0];++i)\n\t\t\tfor(int j=0;j<=cnt[1];++j)\n\t\t\t{\n\t\t\t\tif(i)inc(f[k][i][j],f[k+(s[k]=='0')][i-1][j]);\n\t\t\t\tif(j)inc(f[k][i][j],f[k+(s[k]=='1')][i][j-1]);\n\t\t\t}\n\tcnt[0]=cnt[1]=0;\n\tg[0][0][0]=1;\n\tfor(int k=0;k<n;++k)\n\t{\n\t\tfor(int i=0;i<=cnt[0];++i)\n\t\t\tfor(int j=0;j<=cnt[1];++j)\n\t\t\t{\n\t\t\t\tif(!g[k][i][j])continue;\n\t\t\t\tif(s[k+1]=='0')\n\t\t\t\t{\n\t\t\t\t\tg[k+1][i+1][j]=1;\n\t\t\t\t\tif(j<cnt[1])g[k+1][i][j+1]=1;\n\t\t\t\t\tg[k+2][i+1][j]=1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tg[k+1][i][j+1]=1;\n\t\t\t\t\tif(i<cnt[0])g[k+1][i+1][j]=1;\n\t\t\t\t\tg[k+2][i][j+1]=1;\n\t\t\t\t}\n\t\t\t\tif(s[k+2]=='0')g[k+2][i+1][j]=1;\n\t\t\t\telse g[k+2][i][j+1]=1;\n\t\t\t}\n\t\t++cnt[s[k+1]-'0'];\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=cnt[0];++i)\n\t\tfor(int j=0;j<=cnt[1];++j)\n\t\t{\n\t\t\tint pos=-1;\n\t\t\tfor(int k=n;k>=0;--k)if(g[k][i][j]){pos=k;break;}\n//cerr<<i<<\" \"<<j<<\" \"<<pos<<\" : \"<<f[pos+1][cnt[0]-i][cnt[1]-j]<<endl;\n\t\t\tif(pos<0)continue;\n\t\t\tinc(ans,f[pos+1][cnt[0]-i][cnt[1]-j]);\n\t\t}\n\tprintf(\"%d\\n\",dmy(ans+MOD-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\nusing Mint = ModInt<998244353>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    string s;\n    sc.read(s);\n    int n = int(s.size());\n\n    V<VV<Mint>> dp(n + 1, VV<Mint>(n + 1, V<Mint>(n + 1)));\n    dp[0][0][0] = Mint(1);\n\n    for (int l = 0; l < n; l++) {\n        for (int o = 0; o <= l; o++) {\n            for (int z = 0; o + z <= l; z++) {\n                int u = (l - (o + z));\n                char c = s[n - 1 - u];\n\n                dp[l + 1][o][z] += dp[l][o][z];\n                if (c == '0') {\n                    dp[l + 1][o + 1][z] += dp[l][o][z];\n                } else {\n                    dp[l + 1][o][z + 1] += dp[l][o][z];\n                }\n            }\n        }\n    }\n\n    V<int> osm(n + 1), zsm(n + 1);\n    for (int i = 0; i < n; i++) {\n        osm[i + 1] = osm[i];\n        zsm[i + 1] = zsm[i];\n        if (s[i] == '0') {\n            zsm[i + 1]++;\n        } else {\n            osm[i + 1]++;\n        }\n    }\n\n    V<VV<int>> ok(n + 1, VV<int>(n + 1, V<int>(n + 1)));\n    ok[0][0][0] = 1;\n    for (int k = 0; k <= n; k++) {\n        for (int o = 0; o <= osm[k]; o++) {\n            for (int z = 0; z <= zsm[k]; z++) {\n                if (!ok[k][o][z]) continue;\n\n                // a - a\n                if (o < osm[k]) {\n                    ok[k][o + 1][z] = 1;\n                }\n                if (z < zsm[k]) {\n                    ok[k][o][z + 1] = 1;\n                }\n\n                // a - top\n                if (k + 1 <= n) {\n                    if (o < osm[k + 1]) {\n                        ok[k + 1][o + 1][z] = 1;\n                    }\n                    if (z < zsm[k + 1]) {\n                        ok[k + 1][o][z + 1] = 1;\n                    }\n                }\n\n                // top - top\n                if (k + 2 <= n) {\n                    if (s[k] == '0' || s[k + 1] == '0') {\n                        ok[k + 2][o][z + 1] = 1;\n                    }\n                    if (s[k] == '1' || s[k + 1] == '1') {\n                        ok[k + 2][o + 1][z] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    Mint ans = 0;\n    for (int l = n; l >= 1; l--) {\n        for (int o = 0; o <= l; o++) {\n            for (int z = 0; o + z <= l; z++) {\n                int u = (l - (o + z));\n                int pre = n - u;\n                if (osm[pre] < o || zsm[pre] < z) continue;\n\n                int rem_o = osm[pre] - o;\n                int rem_z = zsm[pre] - z;\n\n                if (!ok[pre][rem_o][rem_z]) continue;\n\n                if (dp[l][o][z].v) {\n//                    dbg(l, o, z, dp[l][o][z]);\n                    ans += dp[l][o][z];\n                }\n            }\n        }\n    }\n\n    pr.writeln(ans.v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <iostream>\n// #include <string>\n// #include <vector>\n// #include <queue>\n// #include <algorithm>\n// #include <assert.h>\n\nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n// #define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n// int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n// int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n// vi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\n// vi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\n\n\nsigned main() {\n    fio();\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<vector<vector<bool>>> dp(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1)));\n    dp[0][0][0] = true;\n    rep (i, n) {\n        rrep (j, n + 1) {\n            rrep (k, n + 1) {\n                if (not dp[i][j][k]) continue;\n                if (i + 2 <= n) {\n                    dp[i + 1][j][k] = true;\n                    if (s[i] == '0') dp[i + 2][j + 1][k] = true;\n                    else dp[i + 2][j][k + 1] = true;\n                    if (s[i + 1] == '0') dp[i + 2][j + 1][k] = true;\n                    else dp[i + 2][j][k + 1] = true;\n                }\n\n                if (j + k >= 2 and j > 0) dp[i][j - 1][k] = true;\n                if (j + k >= 2 and k > 0) dp[i][j][k - 1] = true;\n\n                if (j + k >= 1) dp[i + 1][j][k] = true;\n                if (s[i] == '0' and k > 0) dp[i + 1][j + 1][k - 1] = true;\n                if (s[i] == '1' and j > 0) dp[i + 1][j - 1][k + 1] = true;\n            }\n        }\n    }\n\n    reverse(all(s));\n    vector<vll> dp2(n + 1, vll(n + 1, vl(n + 1)));\n    dp2[0][0][0] = 1;\n    rep (i, n) {\n        rep (j, n + 1) {\n            rep (k, n + 1) {\n                if (dp2[i][j][k] == 0) continue;\n                // 次に作りたいのが0の時\n                if (s[i] == '0') (dp2[i + 1][j][k] += dp2[i][j][k]) %= MOD;\n                else {\n                    if (j + 1 <= n) (dp2[i][j + 1][k] += dp2[i][j][k]) %= MOD;\n                }\n                // 次に作りたいのが1の時\n                if (s[i] == '1') (dp2[i + 1][j][k] += dp2[i][j][k]) %= MOD;\n                else {\n                    if (k + 1 <= n) (dp2[i][j][k + 1] += dp2[i][j][k]) %= MOD;\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= n; k++) {\n                if (i == n and j == 0 and k == 0) continue;\n                if (dp[i][j][k]) {\n                    (ans += dp2[n - i][j][k]) %= MOD;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k+j<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int x;\n  cin >> x;\n  cout << 360 / x << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n;\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s);\n    n=strlen(s);\n    f[0][0][0]=true;\n    for(int i=0;i<n;i++)\n        for(int n0=0;n0<=i;n0++)\n        for(int n1=0;n1<=i;n1++)\n    {\n        if(!f[i][n0][n1]) continue;\n        f[i+1][n0][n1]=true;\n        if(n0&&s[i]=='1')\n            f[i+1][n0-1][n1+1]=true;\n        if(n1&&s[i]=='0')\n            f[i+1][n0+1][n1-1]=true;\n        if(i+1<n&&(s[i]=='0'||s[i+1]=='0'))\n            f[i+2][n0+1][n1]=true;\n        if(i+1<n&&(s[i]=='1'||s[i+1]=='1'))\n            f[i+2][n0][n1+1]=true;\n    }\n    dp[n][0][0]=1;\n    ll ans=0;\n    for(int i=n;i>=0;i--)\n        for(int n0=0;n0<=n;n0++)\n        for(int n1=0;n1<=n;n1++)\n    {\n        if(dp[i][n0][n1]==0) continue;\n        if(f[i][n0][n1])\n            ans=(ans+dp[i][n0][n1])%mod;\n        if(i>0)\n        {\n            dp[i-1][n0][n1]=(dp[i-1][n0][n1]+dp[i][n0][n1])%mod;\n            if(s[i-1]=='1')\n                dp[i][n0+1][n1]=(dp[i][n0+1][n1]+dp[i][n0][n1])%mod;\n            else\n                dp[i][n0][n1+1]=(dp[i][n0][n1+1]+dp[i][n0][n1])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 题目大意：给定 01 串 s，每次可以进行如下操作：\n * 选择前两个字符中的一个删去，将另一个移到 s 的任意位置，\n * 问经过若干次操作后可以得到多少个不同的串。\n * |s| <= 300\n *\n * 算法：\n * 令 f[i][z][o] 表示前 i 位被操作选中过，剩下 z 个 0 和 o 个 1 可不可以达到\n * 令 g[i][z][o] 表示有多少个字符串包含 s[i:n] 为子序列，但是不包含 s[i+1:n] 为子序列，且有 z 个 0 和 o 个 1 的方案数\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353, maxn = 310;\n\nbool f[maxn][maxn][maxn], h[maxn][maxn][maxn];\nint g[maxn][maxn][maxn], cntz[maxn], cnto[maxn];\n\nvoid upd(int &x, const int &y) {\n\tx = (x + y < mod ? x + y : x + y - mod);\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint n = s.size(), ans = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tif(s[i] == '0') cntz[i] = cntz[i + 1] + 1, cnto[i] = cnto[i + 1];\n\t\telse cntz[i] = cntz[i + 1], cnto[i] = cnto[i + 1] + 1;\n\t}\n\tf[0][0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) for (int z = n - 1; z >= 0; --z) for (int t, o = n - 1; o >= 0; --o) if(t = f[i][z][o]) {\n\t\tif(z >= 2) f[i][z - 1][o] = 1;\n\t\tif(o >= 2) f[i][z][o - 1] = 1;\n\t\tif(z >= 1 && o >= 1) f[i][z - 1][o] = f[i][z][o - 1] = 1;\n\t\tif(i < n) {\n\t\t\tif(s[i] == '0') {\n\t\t\t\tif(z >= 1) f[i + 1][z][o] = 1;\n\t\t\t\tif(o >= 1) f[i + 1][z + 1][o - 1] = f[i + 1][z][o] = 1;\n\t\t\t\tif(i + 1 < n) {\n\t\t\t\t\tif(s[i + 1] == '0') f[i + 2][z + 1][o] = 1;\n\t\t\t\t\telse f[i + 2][z + 1][o] = f[i + 2][z][o + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(o >= 1) f[i + 1][z][o] = 1;\n\t\t\t\tif(z >= 1) f[i + 1][z - 1][o + 1] = f[i + 1][z][o] = 1;\n\t\t\t\tif(i + 1 < n) {\n\t\t\t\t\tif(s[i + 1] == '1') f[i + 2][z][o + 1] = 1;\n\t\t\t\t\telse f[i + 2][z + 1][o] = f[i + 2][z][o + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tg[n][0][0] = 1;\n\tfor (int i = n; i > 0; --i) for (int z = 0; z <= n; ++z) for (int t, o = 0; o + z <= n; ++o) if(t = g[i][z][o]) {\n\t\tif(s[i - 1] == '0') upd(g[i - 1][z + 1][o], t), upd(g[i][z][o + 1], t);\n\t\telse upd(g[i - 1][z][o + 1], t), upd(g[i][z + 1][o], t);\n\t}\n\tfor (int i = n; i >= 0; --i) for (int z = 0; z <= n; ++z) for (int o = 0; o + z <= n; ++o) {\n\t\th[i][z][o] = h[i + 1][z][o] | (z >= cntz[i] && o >= cnto[i] && f[i][z - cntz[i]][o - cnto[i]]);\n\t\tif(h[i][z][o]) upd(ans, g[i][z][o]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nchar str[305];\nbool used[305][305][305];\nint n;\nvoid go(int i, int j, int k) {\n\tif (j < 0 || k < 0) return;\n\tif (used[i][j][k]) return;\n\tused[i][j][k] = true;\n\tif (i + 2 <= n) {\n\t\tif (str[i] == '0' || str[i + 1] == '0')\n\t\t\tgo(i + 2, j + 1, k);\n\t\tif (str[i] == '1' || str[i + 1] == '1')\n\t\t\tgo(i + 2, j, k + 1);\n\t}\n\tif (i + 1 <= n) {\n\t\tif (str[i] == '0') {\n\t\t\tgo(i + 1, j + 1, k - 1);\n\t\t\tgo(i + 1, j, k);\n\t\t}\n\t\tif (str[i] == '1') {\n\t\t\tgo(i + 1, j - 1, k + 1);\n\t\t\tgo(i + 1, j, k);\n\t\t}\n\t}\n\tgo(i, j - 1, k);\n\tgo(i, j, k - 1);\n}\nconst int MOD = 998244353;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nMint dp[305][305][305];\nint main() {\n\tscanf(\"%s\", str);\n\tn = strlen(str);\n\tconst int INF = 1e9;\n\tvector<vector<int>> minsuf(n + 1, vector<int>(n + 1, INF));\n\tgo(0, 0, 0);\n\tfor (int i = 0; i <= n; ++i) {\n\t\tint c0 = 0, c1 = 0;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tc0 += str[j] == '0';\n\t\t\tc1 += str[j] == '1';\n\t\t}\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tif (!used[i][j][k]) continue;\n\t\t\t\tint d0 = c0 + j;\n\t\t\t\tint d1 = c1 + k;\n\t\t\t\tminsuf[d0][d1] = min(minsuf[d0][d1], c0 + c1);\n\t\t\t}\n\t}\n\treverse(str, str + n);\n\t// Insert j, k into suffix of length i.\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tif (!i && !j && !k) continue;\n\t\t\t\tMint& ret = dp[i][j][k];\n\t\t\t\tif (i) {\n\t\t\t\t\tif (str[i - 1] == '0') {\n\t\t\t\t\t\tif (j) ret += dp[i - 1][j - 1][k];\n\t\t\t\t\t\tif (k) ret += dp[i][j][k - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (k) ret += dp[i - 1][j][k - 1];\n\t\t\t\t\t\tif (j) ret += dp[i][j - 1][k];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (j) ret += dp[i][j - 1][k];\n\t\t\t\t\tif (k) ret += dp[i][j][k - 1];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tMint ans = 0;\n\tfor (int j = 0; j <= n; ++j)\n\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\tif (!j && !k) continue;\n\t\t\tint s = minsuf[j][k];\n\t\t\tif (s == INF) continue;\n\t\t\tassert(s <= n);\n\t\t\tans += dp[s][j][k];\n\t\t}\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int N = 310;\nconst ll MOD = 998244353;\n\nint dp[N][N][N];\nll dp2[N][N][N];\n\nstring s;\n\nvoid add(ll& a, ll b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tcin >> s;\n\treverse(ALL(s));\n\tdp[s.size()][0][0] = 1;\n\tint n = s.size();\n\n\tfor (int l = s.size(); l >= 0; --l) {\n\t\tfor (int i = n - l; i >= 0; --i) {\n\t\t\tfor (int j = n - l; j >= 0; --j) {\n\t\t\t\tif (!dp[l][i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (i) {\n\t\t\t\t\tdp[l][i - 1][j] = 1;\n\t\t\t\t}\n\t\t\t\tif (j) {\n\t\t\t\t\tdp[l][i][j - 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (l) {\n\t\t\t\t\tdp[l - 1][i][j] = 1;\n\t\t\t\t\tif (i && s[l - 1] == '1') {\n\t\t\t\t\t\tdp[l - 1][i - 1][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (j && s[l - 1] == '0') {\n\t\t\t\t\t\tdp[l - 1][i + 1][j - 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (l >= 2) {\n\t\t\t\t\tif (s[l - 1] == '0' || s[l - 2] == '0') {\n\t\t\t\t\t\tdp[l - 2][i + 1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[l - 1] == '1' || s[l - 2] == '1') {\n\t\t\t\t\t\tdp[l - 2][i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int l = 0; l < n; ++l) {\n\t\tfor (int i = 0; i <= n - l; ++i) {\n\t\t\tfor (int j = 0; j <= n - l; ++j) {\n\t\t\t\tif (dp[l][i][j]) {\n\t\t\t\t\tif (i && s[l] == '0') {\n\t\t\t\t\t\tdp[l + 1][i - 1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (j && s[l] == '1') {\n\t\t\t\t\t\tdp[l + 1][i][j - 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tll ans = 0;\n\tdp2[0][0][0] = 1;\n\tfor (int l = 0; l <= n; ++l) {\n\t\tfor (int i = 0; i + l <= n; ++i) {\n\t\t\tfor (int j = 0; i + j + l <= n; ++j) {\n\t\t\t\tif (dp[l][i][j] && l + i + j != 0) {\n\t\t\t\t\t//cout << l << \" \" << i << \" \" << j << \": \" << dp2[l][i][j] << \"\\n\";\n\t\t\t\t\tadd(ans, dp2[l][i][j]);\n\t\t\t\t}\n\t\t\t\tif (l < n && s[l] == '0') {\n\t\t\t\t\tadd(dp2[l + 1][i][j], dp2[l][i][j]);\n\t\t\t\t} else {\n\t\t\t\t\tadd(dp2[l][i + 1][j], dp2[l][i][j]);\n\t\t\t\t}\n\t\t\t\tif (l < n && s[l] == '1') {\n\t\t\t\t\tadd(dp2[l + 1][i][j], dp2[l][i][j]);\n\t\t\t\t} else {\n\t\t\t\t\tadd(dp2[l][i][j + 1], dp2[l][i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver {\n public:\n  string s;\n  int l;\n  vector<vector<vector<Modint<>>>> dpr;\n  Solver(string s) : s(s), l(s.length()), dpr(l + 1, vector<vector<Modint<>>>(l + 1, vector<Modint<>>(l + 1))){};\n\n  void solve() {\n    dpr[0][0][0] = Modint<>(1);  // len , wrong, wromg 1\n    for (int i = 0; i < l; ++i) {\n      for (int j = 0; j <= i; ++j) {\n        for (int k = 0; k <= j; ++k) {\n          if (s[l - 1 - (i - j)] == '0') {\n            dpr[i + 1][j][k] += dpr[i][j][k];\n            dpr[i + 1][j + 1][k + 1] += dpr[i][j][k];\n          } else {\n            dpr[i + 1][j][k] += dpr[i][j][k];\n            dpr[i + 1][j + 1][k] += dpr[i][j][k];\n          }\n        }\n      }\n    }\n    vector<int> c0(l + 1), c1(l + 1);\n    for (int i = 1; i <= l; ++i) {\n      c0[i] = c0[i - 1] + (s[i - 1] == '0');\n      c1[i] = c1[i - 1] + (s[i - 1] == '1');\n    }\n    Modint<> ans(0);\n    for (int i = 1; i <= l; ++i) {\n      for (int j = 0; j <= i; ++j) {\n        for (int k = 0; k <= j; ++k) {\n          Modint<> tmp = ans;\n          int w0 = j - k;\n          int w1 = k;\n          if (j == 0) {\n            DBG(i, j, k, dpr[i][j][k])\n            ans += dpr[i][j][k];\n            continue;\n            /*if (s[l - i] == '0')\n              w0++;\n            else\n              w1++;\n            if (w0 <= c0[l - (i - 1)] && w1 <= c1[l - (i - 1)]) {\n              ans += dpr[i][j][k];\n              DBG(i, j, k, dpr[i][j][k])\n            }*/\n          } else {\n            int b0 = c0[l - (i - j)];\n            int b1 = c1[l - (i - j)];\n            if (s[0] == '0' && s[1] == '0') b0--;\n            if (s[0] == '1' && s[1] == '1') b1--;\n            if (i + j <= l && w0 <= b0 && w1 <= b1 && (s[0] != s[1] || w0 + w1 < b0 + b1)) {\n              ans += dpr[i][j][k];\n              DBG(i, j, k, dpr[i][j][k])\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n};  // namespace Problem\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  std::string s;\n  std::cin >> s;\n  Problem::Solver sol(s);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nconst int mod=998244353;\ntypedef vector<int> vi;\n#define pb push_back\n#define sz(a) int(a.size())\n\nchar s[N];\nint n,f[N][N][N],g[N][N][N],h[N][N][N],sum[N][2];\n\nint getf(int i,int j,int k) {\n\tif(j+k>n-i) return 0;\n\tif(i==n) return 1;\n\tif(f[i][j][k]!=-1) return f[i][j][k];\n\tfor(int a=0;a<2;a++)\n\t\tfor(int b=0;b<2;b++)\n\t\t\tfor(int x=0;x<2;x++)\n\t\t\t\tfor(int y=0;y<2;y++) {\n\t\t\t\t\tint st[3],tp=0;\n\t\t\t\t\tif(!x) st[++tp]=a;\n\t\t\t\t\tif(!y) st[++tp]=b;\n\t\t\t\t\tbool fl=1;\n\t\t\t\t\tfor(int l=1;l<=tp;l++)\n\t\t\t\t\t\tif(s[i+l]!=st[l]) { fl=0;break; }\n\t\t\t\t\tif(!fl) continue;\n\t\t\t\t\tint cnt[2];cnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[b]) {\n\t\t\t\t\t\t--cnt[b];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+tp,cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t\t\t\tcnt[0]=j;cnt[1]=k;\n\t\t\t\t\tif(cnt[a]) {\n\t\t\t\t\t\t--cnt[a];\n\t\t\t\t\t\tif(x) ++cnt[a];\n\t\t\t\t\t\tif(y) ++cnt[b];\n\t\t\t\t\t\tif(getf(i+tp,cnt[0],cnt[1])) return f[i][j][k]=1;\n\t\t\t\t\t}\n\t\t}\n\treturn f[i][j][k]=0;\n}\n\nint geth(int i,int j,int k) {\n\tif(i<0) return 0;\n\tif(h[i][j][k]!=-1) return h[i][j][k];\n\tif(j>=sum[i][0]&&k>=sum[i][1]&&getf(i,j-sum[i][0],k-sum[i][1])) return h[i][j][k]=1;\n\treturn h[i][j][k]=geth(i-1,j,k);\n}\n\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>(s+1);n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) s[i]-='0',sum[i][0]=sum[i-1][0],sum[i][1]=sum[i-1][1],++sum[i][s[i]];\n\ts[n+1]=2;\n\tmemset(f,-1,sizeof(f));\n\tmemset(h,-1,sizeof(h));\n\tint ans=0;\n\tg[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;i+j<n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++) {\n\t\t\t\tif(!g[i][j][k]) continue;\n\t\t\t\tg[i+1][j][k+(s[k+1]==0)]=(g[i+1][j][k+(s[k+1]==0)]+g[i][j][k])%mod;\n\t\t\t\tg[i][j+1][k+(s[k+1]==1)]=(g[i][j+1][k+(s[k+1]==1)]+g[i][j][k])%mod;\n\t\t\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;i+j<=n;j++)\n\t\t\tfor(int k=0;k<=i+j;k++)\n\t\t\t\tif(geth(k,i,j)) ans=(ans+g[i][j][k])%mod;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nchar s[305];\nint n,dp[305][305][305],ans=0,vis[305][305],sum[2][305],add[2][305][305][305];\nint sump[305][305][305];\nint cr[305][305][305];\nconst int mod=998244353;\nint M(int x){return x>=mod?x-mod:x;}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum[0][i]=sum[0][i-1];\n\t\tsum[1][i]=sum[1][i-1];\n\t\tif(s[i]=='0')sum[0][i]++;\n\t\telse sum[1][i]++;\n\t}\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=i;j++)for(int k=0;k<=i-j;k++)cr[i][j][k]=-2;\n\tcr[0][0][0]=0;\n\tvis[sum[0][n]][sum[1][n]]=1;\n\t//w/b\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=i-j;k++)\n\t\t\t{\n\t\t\t\tif(cr[i][j][k]==-2)continue;\n\t\t\t\tif(j+k&&cr[i][j][k]>=0)vis[j+sum[0][n]-sum[0][i]][k+sum[1][n]-sum[1][i]]=i+1;\n\t\t\t\tif(cr[i][j][k]==-1)cr[i+1][j][k]=max(cr[i+1][j][k],0);\n\t\t\t\telse cr[i+1][j][k]=max(cr[i+1][j][k],cr[i][j][k]+1);\n\t\t\t\tif(i<n&&cr[i][j][k]>-1)\n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='0')cr[i+1][j+1][k]=max(cr[i+1][j+1][k],max(-1,cr[i][j][k]-1-(cr[i][j][k]%2==0)));\n\t\t\t\t\telse cr[i+1][j][k+1]=max(cr[i+1][j][k+1],max(-1,cr[i][j][k]-1-(cr[i][j][k]%2==0)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(j)add[0][i][j][k]=M(add[0][i][j][k]+add[0][i][j-1][k]);\n\t\t\t\tif(k)add[1][i][j][k]=M(add[1][i][j][k]+add[1][i][j][k-1]);\n\t\t\t\tdp[i][j][k]=M(dp[i][j][k]+M(add[0][i][j][k]+add[1][i][j][k]));\n\t\t\t\tsump[i][j][k]=M(sump[i][j][k]+dp[i][j][k]);\n\t\t\t\tsump[i][j+1][k]=M(sump[i][j+1][k]+sump[i][j][k]);\n\t\t\t\tsump[i][j][k+1]=M(sump[i][j][k+1]+sump[i][j][k]);\n\t\t\t\tif(i==n)continue;\n\t\t\t\tif(s[n-i]=='0')add[1][i+1][j][k]=M(add[1][i+1][j][k]+dp[i][j][k]);\n\t\t\t\telse add[0][i+1][j][k]=M(add[0][i+1][j][k]+dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"@%d\\n\",dp[2][0][0]);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(i==0&&j==0)continue;\n\t\t\tif(!vis[i][j])continue;\n\t\t\t//printf(\"%d %d %d %d\\n\",i,j,vis[i][j],sum[n-vis[i][j]+1][i-sum[0][n]+sum[0][vis[i][j]-1]][j-sum[1][n]+sum[1][vis[i][j]-1]]);\n\t\t\tans=M(ans+sump[n-vis[i][j]+1][i-sum[0][n]+sum[0][vis[i][j]-1]][j-sum[1][n]+sum[1][vis[i][j]-1]]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nconst int MOD = 998244353;\nconst int N = 303;\n\n\nbool state[N][N][N];\nint ways[N][N][N];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    state[n][0][0] = true;\n\n    vector <bool> isZero(n), isOne(n);\n    for (int i = 0; i < n; i++) {\n        isZero[i] = s[i] == '0';\n        isOne[i] = !isZero[i];\n    }\n\n    for (int suffLen = n; suffLen >= 0; suffLen--) {\n        for (int zeros = n; zeros >= 0; zeros--) for (int ones = n; ones >= 0; ones--) {\n            if (state[suffLen][zeros][ones]) {\n                int p1 = n - suffLen;\n                int p2 = p1 + 1;\n\n                if (suffLen >= 2) {\n                    for (int p : {p1, p2}) {\n                        state[suffLen - 2][zeros + isZero[p]][ones + isOne[p]] = true;\n                    }\n                }\n\n                if (suffLen >= 1) {\n                    if (zeros >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros - 1 + isZero[p1]][ones + isOne[p1]] = true;\n                    }\n\n                    if (ones >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros + isZero[p1]][ones - 1 + isOne[p1]] = true;\n                    }\n                }\n\n                if (zeros >= 2) state[suffLen][zeros - 2][ones] = true;\n                if (ones >= 2) state[suffLen][zeros][ones - 2] = true;\n                if (zeros >= 1 && ones >= 1) state[suffLen][zeros - 1][ones - 1] = true;\n            }\n        }\n    }\n\n    vector <int> suffZeros(n + 1, 0), suffOnes(n + 1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        suffZeros[i] = suffZeros[i - 1] + isZero[n - i];\n        suffOnes[i] = suffOnes[i - 1] + isOne[n - i];\n    }\n\n    map <pair<int,int>,tuple<int,int,int>> minLenState;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (state[suffLen][zeros][ones]) {\n                int zerosTotal = zeros + suffZeros[suffLen];\n                int onesTotal = ones + suffOnes[suffLen];\n\n                pair <int,int> p = {zerosTotal, onesTotal};\n\n                if (!minLenState.count(p)) {\n                    minLenState[p] = tuple <int,int,int> {suffLen, zeros, ones};\n                }\n            }\n        }\n    }\n\n    ways[0][0][0] = 1;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (suffLen == 0) {\n                if (zeros >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros - 1][ones];\n                }\n\n                if (ones >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros][ones - 1];\n                }\n\n                ways[suffLen][zeros][ones] %= MOD;\n            } else {\n                int last = isOne[n - suffLen];\n                ways[suffLen][zeros][ones] = ways[suffLen-1][zeros][ones];\n\n                if (last == 0) {\n                    if (ones >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros][ones-1]) % MOD;\n                    }\n                } else {\n                    if (zeros >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros-1][ones]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (auto &entry : minLenState) {\n        int suffLen, zeros, ones;\n        tie(suffLen, zeros, ones) = entry.second;\n\n        ans = (ans + ways[suffLen][zeros][ones]) % MOD;\n    }\n\n    if (n > 1) {\n        ans = (ans + MOD - 1) % MOD;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing li = __int128;\nusing uli = unsigned __int128;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) : arr(l.size()) {\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i : range(n)) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    T& operator[](const pii& p) {\n        return operator()(p.first, p.second);\n    }\n\n    const T& operator[](const pii& p) const {\n        return operator()(p.first, p.second);\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i : range(res.size())) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\npublic:\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    inline int peek() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt];\n    }\n\nprivate:\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n, T());\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vector<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vector<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        return c;\n    }\n\n    inline int peekNext() {\n        while (isWhitespace(peek()) && peek() != EOF) {\n            get();\n        }\n        return peek();\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    inline ll readLong() {\n        return readInteger<ll>();\n    }\n\n    inline unsigned readUnsigned() {\n        return readInteger<unsigned>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return res;\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i : range(n)) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i : range(n)) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i : range(n)) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i : range(rows)) {\n            for (int j : range(cols)) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        string res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return res;\n    }\n\n    inline double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    inline char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    inline bool isExhausted() { return exhausted; }\n\n    inline void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ninline double Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\ninline int Input::readType() {\n    return readInt();\n}\n\ntemplate <>\ninline ll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\ninline unsigned Input::readType() {\n    return readUnsigned();\n}\n\ntemplate <>\ninline char Input::readType() {\n    return readChar();\n}\n\ntemplate <>\ninline string Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream* out;\n\n    template <typename T>\n    inline void printSingle(const T& value) {\n        *out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vector<T>& array) {\n        size_t n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        int n = array.size();\n        for (int i : range(n)) {\n            *out << array[i];\n            if (i + 1 != n) {\n                *out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i : range(n)) {\n            for (int j : range(m)) {\n                *out << array(i, j);\n                if (j + 1 != m) {\n                    *out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                *out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    inline void printSingle(const pair<T, U>& value) {\n        *out << value.first << ' ' << value.second;\n    }\n\npublic:\n    bool autoflush;\n\n    Output(ostream& out, bool autoflush) : out(&out), autoflush(autoflush) {\n        setPrecision(20);\n    }\n\n    void setOut(ostream& nOut) {\n        out = &nOut;\n        setPrecision(20);\n    }\n\n    inline void print() {}\n\n    template <typename T, typename...Targs>\n    inline void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            *out << ' ';\n            print(args...);\n        }\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    template <typename...Targs>\n    inline void printLine(const Targs... args) {\n        print(args...);\n        *out << '\\n';\n        if (autoflush) {\n            flush();\n        }\n    }\n\n    inline void flush() {\n        out->flush();\n    }\n\n    inline void setPrecision(int digs) {\n        *out << fixed << setprecision(digs);\n    }\n};\n\nOutput out(cout, false);\nOutput err(cerr, true);\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\nll gcd(ll a, ll b, ll& x, ll& y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int d = gcd(b % a, a, y, x);\n    x -= (b / a) * y;\n    return d;\n}\n\nclass modint {\npublic:\n    int n;\n\n    modint() : n(0) {}\n\n    modint(ll n, bool special = false) {\n        if (special) {\n            this->n = -1;\n            return;\n        }\n        if (n >= 0 && n < mod) {\n            this->n = n;\n            return;\n        }\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n\n    modint& operator+=(const modint& other) {\n#ifdef LOCAL\n        if (n == -1 || other.n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        n += other.n;\n        if (n >= mod) {\n            n -= mod;\n        }\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n#ifdef LOCAL\n        if (n == -1 || other.n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        n -= other.n;\n        if (n < 0) {\n            n += mod;\n        }\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n#ifdef LOCAL\n        if (n == -1 || other.n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        n = ll(n) * other.n % mod;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n#ifdef LOCAL\n        if (other.n == 0) {\n            throw \"Division by zero\";\n        }\n        if (n == -1 || other.n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        return *this *= other.inverse();\n    }\n\n    modint operator-() {\n#ifdef LOCAL\n        if (n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        if (n == 0) {\n            return 0;\n        }\n        return modint(mod - n);\n    }\n\n    modint inverse() const {\n#ifdef LOCAL\n        if (n == -1) {\n            throw \"Illegal state\";\n        }\n#endif\n        ll x, y;\n        ll g = gcd(ll(n), ll(mod), x, y);\n#ifdef LOCAL\n        if (g != 1) {\n            throw \"not inversable\";\n        }\n#endif\n        return x;\n    }\n\n    int log(modint alpha);\n};\n\nmodint nullModint(-1, true);\n\nmodint operator+(const modint& a, const modint& b) {\n    return modint(a) += b;\n}\n\nmodint operator-(const modint& a, const modint& b) {\n    return modint(a) -= b;\n}\n\nmodint operator*(const modint& a, const modint& b) {\n    return modint(a) *= b;\n}\n\nmodint operator/(const modint& a, const modint& b) {\n    return modint(a) /= b;\n}\n\nostream& operator<<(ostream& out, const modint& val) {\n    return out << val.n;\n}\n\nbool operator==(const modint& a, const modint& b) {\n    return a.n == b.n;\n}\n\nbool operator!=(const modint& a, const modint& b) {\n    return a.n != b.n;\n}\n\nnamespace std {\n    template <>\n    struct hash<modint> {\n        size_t operator()(const modint& n) const {\n            return n.n;\n        }\n    };\n}\n\nint modint::log(modint alpha) {\n#ifdef LOCAL\n    if (n == -1 || alpha.n == -1) {\n        throw \"Illegal state\";\n    }\n#endif\n    unordered_map<modint, int> base;\n    int exp = 0;\n    modint pow = 1;\n    modint inv = *this;\n    modint alInv = alpha.inverse();\n    while (exp * exp < mod) {\n        if (inv == 1) {\n            return exp;\n        }\n        base[inv] = exp++;\n        pow *= alpha;\n        inv *= alInv;\n    }\n    modint step = pow;\n    for (int i = 1;; i++) {\n        if (base.count(pow)) {\n            return exp * i + base[pow];\n        }\n        pow *= step;\n    }\n}\n\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate <typename T>\nT power(const T& a, ll b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nT factorial(int n) {\n    T result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> factorials(int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> powers(T base, int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\n\narr<modint> inverses(int length) {\n    arr<modint> result(length);\n    if (length > 1) {\n        result[1] = 1;\n    }\n    for (int i = 2; i < length; i++) {\n        result[i] = -(mod / i) * result[mod % i];\n    }\n    return result;\n}\n\narr<modint> inverseFactorials(int length) {\n    auto result = inverses(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] *= result[i - 1];\n    }\n    return result;\n}\n\nclass Combinations {\nprivate:\n    arr<modint> fact;\n    arr<modint> invFactorial;\n\npublic:\n    Combinations(int length) {\n        fact = factorials<modint>(length);\n        invFactorial = inverseFactorials(length);\n    }\n\npublic:\n    modint c(int n, int k) const {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return fact[n] * invFactorial[k] * invFactorial[n - k];\n    }\n\n    modint operator()(int n, int k) const {\n        return c(n, k);\n    }\n\n    modint factorial(int n) const {\n        return fact[n];\n    }\n\n    modint inverseFactorial(int n) const {\n        return invFactorial[n];\n    }\n};\n\narr<modint> bernoulli(int length, Combinations* c = nullptr) {\n    arr<modint> b(length);\n    if (c == nullptr) {\n        c = new Combinations(length + 1);\n    }\n    if (length > 0) {\n        b[0] = 1;\n    }\n    for (int i : range(1, length)) {\n        b[i] = 0;\n        for (int j : range(1, i + 1)) {\n            b[i] += (*c)(i + 1, j + 1) * b[i - j];\n        }\n        b[i] = -b[i];\n        b[i] /= i + 1;\n    }\n    return b;\n}\n\n\nclass DSecretPassage {\npublic:\n    void solve() {\n        auto s = in.readString();\n\n        mod = MODF;\n        int zeroes = count(all(s), '0');\n        int ones = s.size() - zeroes;\n        arri nonFreeZ(s.size() + 1);\n        arri nonFreeO(s.size() + 1);\n        nonFreeZ[0] = zeroes;\n        nonFreeO[0] = ones;\n        for (int i : range(s.size())) {\n            nonFreeZ[i + 1] = nonFreeZ[i] - (s[i] == '0' ? 1 : 0);\n            nonFreeO[i + 1] = nonFreeO[i] - (s[i] == '0' ? 0 : 1);\n        }\n        arr2d<int> minSuf(zeroes + 1, ones + 1, s.size() + 1);\n        minSuf(zeroes, ones) = s.size();\n        for (int i : RevRange(zeroes + 1)) {\n            for (int j : RevRange(ones + 1)) {\n                if (minSuf(i, j) > s.size()) {\n                    continue;\n                }\n                if (minSuf(i, j) == 1) {\n                    minSuf(i, j) = 0;\n                }\n                if (minSuf(i, j) > 1) {\n                    int ss = minSuf(i, j);\n                    if (s[s.size() - ss] != s[s.size() - ss + 1]) {\n                        minim(minSuf(i - 1, j), ss - 2);\n                        minim(minSuf(i, j - 1), ss - 2);\n                    } else if (s[s.size() - ss] == '0') {\n                        minim(minSuf(i - 1, j), ss - 2);\n                        if (j != nonFreeO[s.size() - ss]) {\n                            minim(minSuf(i, j - 1), ss - 1);\n                        }\n                    } else {\n                        minim(minSuf(i, j - 1), ss - 2);\n                        if (i != nonFreeZ[s.size() - ss]) {\n                            minim(minSuf(i - 1, j), ss - 1);\n                        }\n                    }\n                } else {\n                    if (i > 0) {\n                        minSuf(i - 1, j) = 0;\n                    }\n                    if (j > 0) {\n                        minSuf(i, j - 1) = 0;\n                    }\n                }\n            }\n        }\n        reverse(all(s));\n        arr3d<modint> qty(s.size() + 1, zeroes + 1, ones + 1, 0);\n        arr3d<modint> base(s.size() + 1, zeroes + 1, ones + 1, 0);\n        base(0, 0, 0) = 1;\n        qty(0, 0, 0) = 1;\n        for (int i : range(s.size())) {\n            for (int j : range(zeroes + 1)) {\n                for (int k : range(ones + 1)) {\n                    base(i + 1, j, k) += qty(i, j, k);\n                    qty(i + 1, j, k) += qty(i, j, k);\n                    if (s[i] == '0') {\n                        if (k != ones) {\n                            qty(i, j, k + 1) += qty(i, j, k);\n                        }\n                    } else {\n                        if (j != zeroes) {\n                            qty(i, j + 1, k) += qty(i, j, k);\n                        }\n                    }\n                }\n            }\n        }\n        Combinations c(zeroes + ones + 1);\n        modint answer = 0;\n        for (int i : range(zeroes + 1)) {\n            for (int j : range(ones + 1)) {\n                if (minSuf(i, j) > s.size()) {\n                    continue;\n                }\n                int freeZeroes = i - nonFreeZ[s.size() - minSuf(i, j)];\n                int freeOnes = j - nonFreeO[s.size() - minSuf(i, j)];\n                for (int k : range(freeZeroes + 1)) {\n                    for (int l : range(freeOnes + 1)) {\n                        answer += base(minSuf(i, j), k, l) * c(freeZeroes - k + freeOnes - l, freeZeroes - k);\n                    }\n                }\n            }\n        }\n        out.printLine(answer - 1);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n#ifdef LOCAL_RELEASE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    auto time = clock();\n#endif\n    DSecretPassage solver;\n\n\n    solver.solve();\n    fflush(stdout);\n#ifdef LOCAL_RELEASE\n    cerr << double(clock() - time) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n  cerr << \"[\";\n  for (auto e : aux) cerr << e << ' ';\n  cerr << \"]\";\n  return cerr;\n}\n\nconst int maxN = 311;\nconst int mod = 998244353;\n\nint n;\nchar s[maxN];\n\nbool reachable[maxN][maxN][maxN];\nbool deny[maxN][maxN][maxN];\nint dp[maxN][maxN][maxN][2];\n\n\nvoid upd(int& dest, int sour, int coef = 1) {\n  dest += (1LL * sour * coef) % mod;\n  if (dest >= mod) dest -= mod;\n}\n\nvoid computeReachable() {\n  reachable[0][0][0] = 1;\n\n  for (int i = 0; i < n; i++) {\n    bool nextZero = s[i + 1] == '0';\n\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        if (!reachable[i][zeros][ones]) continue;\n \n        // Use next 2\n        if (i + 2 <= n) {\n          bool nextZero2 = s[i + 2] == '0';\n\n          if (nextZero == nextZero2) {\n            if (nextZero)\n              reachable[i + 2][zeros + 1][ones] = true;\n            else\n              reachable[i + 2][zeros][ones + 1] = true;\n          } else {\n            reachable[i + 2][zeros + 1][ones] = true;\n            reachable[i + 2][zeros][ones + 1] = true;\n          }\n        }\n\n        // Cut next element\n        if (ones + zeros > 0)\n          reachable[i + 1][zeros][ones] = true;\n\n        // Exchange one for zero\n        if (nextZero && ones > 0) \n          reachable[i + 1][zeros + 1][ones - 1] = true; \n\n        // Exchange zero for one\n        if (!nextZero && zeros > 0) \n          reachable[i + 1][zeros - 1][ones + 1] = true;\n      }\n    }\n  }\n}\n\nvoid computeDeny() {\n  for (int i = n; i > 0; i--) {\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        bool propagate = deny[i][zeros][ones] || reachable[i][zeros][ones];\n\n        if (s[i] == '0') {\n          if (zeros > 0)\n            deny[i - 1][zeros - 1][ones] |= propagate;\n        } else {\n          if (ones > 0)\n            deny[i - 1][zeros][ones - 1] |= propagate;\n        }\n      }\n    }\n  }\n}\n\nvoid computeDP() {\n  dp[n][0][0][0] = 1;\n\n  for (int i = n; i >= 0; i--) {\n    bool nextZero = (s[i] == '0' ? true : false);\n\n    // Use next char if possible\n    if (i > 0) {\n      for (int zeros = 0; zeros <= i; zeros++) {\n        for (int ones = 0; ones <= i; ones++) {\n          \n          // Use next char\n          upd(dp[i - 1][zeros][ones][0], dp[i][zeros][ones][0]);\n          upd(dp[i - 1][zeros][ones][0], dp[i][zeros][ones][1]);\n          \n          if (nextZero) {\n            // add virtual one\n            upd(dp[i][zeros][ones + 1][1], dp[i][zeros][ones][0]);\n            upd(dp[i][zeros][ones + 1][1], dp[i][zeros][ones][1]);\n          } else {\n            // add virtual zero\n            upd(dp[i][zeros + 1][ones][1], dp[i][zeros][ones][0]);\n            upd(dp[i][zeros + 1][ones][1], dp[i][zeros][ones][1]);\n          } \n        }\n      }\n    }\n\n    // Add virtual head\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        upd(dp[i][zeros + 1][ones][0], dp[i][zeros][ones][0]);\n        upd(dp[i][zeros][ones + 1][0], dp[i][zeros][ones][0]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  //freopen(\"test.in\", \"r\", stdin);\n\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n\n  cout << \"Start computing..\\n\";\n  computeReachable();\n  cout << \"Computed reachable..\\n\";\n  computeDeny();\n  cout << \"Computed deny..\\n\";\n  computeDP();\n  cout << \"Computed dp..\\n\";\n\n  if (false)\n  for (int i = 0; i <= n; i++) {\n    cerr << \"For \" << i << '\\n';\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        cerr << '(' << reachable[i][zeros][ones] << \n                \", \" << deny[i][zeros][ones] <<\n                \", \" << dp[i][zeros][ones][0] << \") \";\n      }\n      cerr << '\\n';\n    }\n  }\n\n  int answer = 0;\n  for (int i = 0; i <= n; i++) \n    for (int zeros = 0; zeros <= i; zeros++)\n      for (int ones = 0; ones <= i; ones++)\n        if (reachable[i][zeros][ones])\n          if (!deny[i][zeros][ones])\n            upd(answer, dp[i][zeros][ones][0]);\n\n  cout << answer;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing LL = long long;\n\ntemplate<typename T>\nostream& operator << (ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for(auto& x : v) {\n        out << x << \", \";\n    }\n    return out << \"]\";\n}\n\ntemplate<typename S, typename T>\nostream& operator << (ostream& out, const pair<S, T>& p) {\n    return out << \"{\" << p.first << \", \" << p.second << \"}\";\n}\n\nbool reachable[310][310][310];\n\nint N;\nvector<int> V;\nint suff_ones[310];\nint suff_zeroes[310];\nint shortest_suff[310][310];\n\nvoid explore(int n, int z, int o) {\n    if(z < 0 or o < 0) {\n        return;\n    }\n    if(reachable[n][z][o]) {\n        return;\n    }\n    reachable[n][z][o] = 1;\n    shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]] = max(shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]], n);\n    if(z + o >= 2) {\n        explore(n, z - 1, o); //delete from pool\n        explore(n, z, o - 1); //delete from pool\n    }\n    if(n == N) {\n        return;\n    }\n    if(V[n] == 0) {\n        explore(n + 1, z + 1, o - 1); //delete from pool and add from vector\n    } else {\n        explore(n + 1, z - 1, o + 1); //delete from pool and add from vector\n    }\n    if(z + o + (N - n) >= 2) {\n        explore(n + 1, z, o);\n    }\n    if(n + 2 <= N) {\n        if(V[n] == 0 or V[n + 1] == 0) {\n            explore(n + 2, z + 1, o); //delete and add from vector\n        }\n        if(V[n] == 1 or V[n + 1] == 1) {\n            explore(n + 2, z, o + 1); //delete and add from vector\n        }\n    }\n}\n\nconst LL MOD = 998244353;\nLL dp[310][310][310];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    string S;\n    cin >> S;\n    for(char c : S) {\n        if(c == '0') {\n            V.push_back(0);\n        } else {\n            V.push_back(1);\n        }\n    }\n    N = S.length();\n    for(int n = N - 1; n >= 0; --n) {\n        suff_ones[n] = suff_ones[n + 1] + V[n];\n        suff_zeroes[n] = suff_zeroes[n + 1] + 1 - V[n];\n    }\n    memset(shortest_suff, -1, sizeof(shortest_suff));\n    explore(0, 0, 0);\n    \n    for(int n = N; n >= 0; --n) {\n        for(int z = 0; z <= N; ++z) {\n            for(int o = 0; o <= N; ++o) {\n                if(n == N) {\n                    if(z == 0 or o == 0) {\n                        dp[N][z][o] = 1;\n                    } else {\n                        dp[N][z][o] = (dp[N][z - 1][o] + dp[N][z][o - 1]) % MOD;\n                    }\n                    continue;\n                }\n                if(V[n] == 0) {\n                    dp[n][z][o] = (((z > 0) ? (dp[n + 1][z - 1][o]) : (0)) + ((o > 0) ? (dp[n][z][o - 1]) : (0))) % MOD;\n                } else {\n                    dp[n][z][o] = (((z > 0) ? (dp[n][z - 1][o]) : (0)) + ((o > 0) ? (dp[n + 1][z][o - 1]) : (0))) % MOD;\n                }\n            }\n        }\n    }\n    \n    LL ans = 0;\n    for(int z = 0; z <= N; ++z) {\n        for(int o = 0; o <= N; ++o) {\n            if(shortest_suff[z][o] >= 0) {\n                ans = (ans + dp[shortest_suff[z][o]][z][o]) % MOD;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    \n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 600 + 7;\nconst int M = 998244353;\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint sum(int a, int b) {\n  int c = a + b;\n  if (c >= M) c -= M;\n  if (c < 0) c += M;\n  return c;\n}\n\nvoid add(int &a, int b) {\n  a = sum(a ,b);\n}\n\nbool dp[N][N][N];\nint vals[N][N][N];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  dp[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int x = n; x >= 0; x--) {\n      for (int y = n; y >= 0; y--) {\n        if (!dp[i][x][y]) continue;\n        if (x + y >= 2) {\n          if (x)\n            dp[i][x - 1][y] = true;\n          if (y)\n            dp[i][x][y - 1] = true;\n        }\n        if (x && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x][y] = true;\n          } else {\n            dp[i + 1][x - 1][y + 1] = true;\n          }\n        }\n        if (y && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x + 1][y - 1] = true;\n          } else {\n            dp[i + 1][x][y] = true;\n          }\n        }\n        if (i + 1 < n) {\n          if (s[i] == s[i + 1]) {\n            if (s[i] == '0') {\n              dp[i + 2][x + 1][y] = true;\n            } else {\n              dp[i + 2][x][y + 1] = true;\n            }\n          } else {\n            dp[i + 2][x + 1][y] = true;\n            dp[i + 2][x][y + 1] = true;\n          }\n        }\n      }\n    }\n  }\n  vals[n][0][0] = 1;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (x + 1 <= n) {\n          if (!i || s[i - 1] != '0')\n            add(vals[i][x + 1][y], vals[i][x][y]);\n          else\n            add(vals[i - 1][x + 1][y], vals[i][x][y]);\n        }\n        if (y + 1 <= n) {\n          if (!i || s[i - 1] != '1')\n            add(vals[i][x][y + 1], vals[i][x][y]);\n          else\n            add(vals[i - 1][x][y + 1], vals[i][x][y]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (i) add(vals[i][x][y], vals[i - 1][x][y]);\n      }\n    }\n  }\n  vector <int> pa(n + 1), pb(n + 1);\n  int a = 0, b = 0;\n  for (int i = n; i >= 0; i--) {\n    if (i < n && s[i] == '0') a++;\n    if (i < n && s[i] == '1') b++;\n    pa[i] = a, pb[i] = b;\n  }\n  auto cost = [&] (int i, int a, int b) {\n    a += pa[i], b += pb[i];\n    int sum = vals[i][a][b];\n    return sum;\n  };\n  int ans = 0;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (dp[i][x][y]) {\n          int cur = 0;\n          add(cur, cost(i, x, y));\n          if (i) {\n            if (s[i - 1] == '0' && x && dp[i - 1][x - 1][y]) {\n              add(cur, -cost(i - 1, x - 1, y));\n            }\n            if (s[i - 1] == '1' && y && dp[i - 1][x][y - 1]) {\n              add(cur, -cost(i - 1, x, y - 1));\n            }\n          }\n          add(ans, cur);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(i+j >= 2){\n\t\t\t\t\tif(i>0)dp[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0)dp[i][j-1][k] = 1; \n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=307;\nconst ll mod=998244353;\n\nint n;\n\nchar wcz[nax];\nint tab[nax];\n\nll dp[nax][nax][nax];\n\nll wyn;\n\nint moge[nax][nax][nax];\n\ninline void dod(ll &a, ll b)\n{\n\tif ((a+=b)>=mod)\n\t\ta-=mod;\n}\n\nvoid sdod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(\"%s\", wcz+1);\n\tn=strlen(wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=wcz[i]-'0';\n\tmoge[0][0][0]=1;\n\tfor (int i=0; i<=n; i++)\n\t{\n\t\tfor (int j=n; j>=0; j--)\n\t\t{\n\t\t\tfor (int l=n; l>=0; l--)\n\t\t\t{\n\t\t\t\tif (!moge[i][j][l])\n\t\t\t\t\tcontinue;\n\t\t\t\t//~ debug() << i << \" \" << j << \" \" << l;\n\t\t\t\tif ((j+l)>=2 && j)\n\t\t\t\t\tmoge[i][j-1][l]=1;\n\t\t\t\tif ((j+l)>=2 && l)\n\t\t\t\t\tmoge[i][j][l-1]=1;\n\t\t\t\tif (tab[i+1] || tab[i+2])\n\t\t\t\t\tmoge[i+2][j][l+1]=1;\n\t\t\t\tif (!tab[i+1] || !tab[i+2])\n\t\t\t\t\tmoge[i+2][j+1][l]=1;\n\t\t\t\tif (tab[i+1] && j)\n\t\t\t\t\tmoge[i+1][j-1][l+1]=1;\n\t\t\t\tif (tab[i+1] && l)\n\t\t\t\t\tmoge[i+1][j][l]=1;\n\t\t\t\tif (!tab[i+1] && l)\n\t\t\t\t\tmoge[i+1][j+1][l-1]=1;\n\t\t\t\tif (!tab[i+1] && j)\n\t\t\t\t\tmoge[i+1][j][l]=1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[n+1][0][0]=1;\n\tfor (int i=n+1; i; i--)\n\t{\n\t\tfor (int j=0; j<=n; j++)\n\t\t{\n\t\t\tfor (int l=0; l<=n; l++)\n\t\t\t{\n\t\t\t\tif (!dp[i][j][l])\n\t\t\t\t\tcontinue;\n\t\t\t\t//~ debug() << i << \" \" << j << \" \" << l << \" \" << dp[i][j][l];\n\t\t\t\tif (moge[i-1][j][l] || moge[i][j+(!tab[i])][l+tab[i]])\n\t\t\t\t{\n\t\t\t\t\t//~ debug() << \"tak\";\n\t\t\t\t\tdod(wyn, dp[i][j][l]);\n\t\t\t\t\t//~ continue;\n\t\t\t\t}\n\t\t\t\t//~ if (i==2 && tab[i-1] && moge[i-1][j][l+1])\n\t\t\t\t\t//~ dod(wyn, dp[i][j][l]);\n\t\t\t\t//~ if (i==2 && !tab[i-1] && moge[i-1][j+1][l])\n\t\t\t\t\t//~ dod(wyn, dp[i][j][l]);\n\t\t\t\tdod(dp[i-1][j][l], dp[i][j][l]);\n\t\t\t\tif (tab[i-1])\n\t\t\t\t\tdod(dp[i][j+1][l], dp[i][j][l]);\n\t\t\t\telse\n\t\t\t\t\tdod(dp[i][j][l+1], dp[i][j][l]);\n\t\t\t}\n\t\t}\n\t}\n\twyn--;\n\twyn%=mod;\n\twyn+=mod;\n\twyn%=mod;\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 998244353;\n//ll dp[155][155][305];\nll ans = 0;\nll checker[305][305][305];\nll dp[305][305][305];\n\nint main() {\n    string S;\n    cin >> S;\n  if(S.size() == 1) {\n    cout << 1 << endl;\n    return 0;\n  }\n    checker[0][0][0] = 1;\n    for(int k = 0; k <= S.size(); k++) {\n        for(int i = S.size(); i >= 0; i--) {\n            for(int j = S.size(); j >= 0; j--) {\n                if(!checker[i][j][k]) continue;\n                //cerr << i << \" \" << j << \" \" << k << endl;\n                if(k + 2 <= S.size()) {\n                    string T = S.substr(k, 2);\n                    if(T != \"11\") checker[i+1][j][k+2] = 1;\n                    if(T != \"00\") checker[i][j+1][k+2] = 1;\n                }\n                if(i >= 2) checker[i-2][j][k] = 1;\n                if(j >= 2) checker[i][j-2][k] = 1;\n                if(i >= 1 and j >= 1) checker[i-1][j-1][k] = 1;\n                if(i >= 1 or j >= 1) checker[i][j][k+1] = 1;\n                if(i >= 1 and k + 1 <= S.size() and S[k] == '1') {\n                    checker[i-1][j+1][k+1] = 1;\n                }\n                if(j >= 1 and k + 1 <= S.size() and S[k] == '0') {\n                    checker[i+1][j-1][k+1] = 1;\n                }\n            }\n        }\n    }\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(checker[i][j][k] == 0) continue;\n                if(checker[i][j][k] == 1) {\n                    //cerr << i + j + (S.size() - k) << \" \" << i << \" \" << j << \" \" << k << endl;\n                }\n                if(k == 0) continue;\n                ll newi = i;\n                ll newj = j;\n                if(S[k-1] == '0') newi--;\n                if(S[k-1] == '1') newj--;\n                if(newi < 0 or newj < 0) continue;\n                //checker[newi][newj][k+1] = 2;\n                checker[newi][newj][k-1] = 2;\n            }\n        }\n    }\n    dp[0][0][S.size()] = 1;\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(k < S.size()) {\n                    dp[i][j][k] += dp[i][j][k+1];\n                    if(S[k] == '0' and j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(S[k] == '1' and i > 0) dp[i][j][k] += dp[i-1][j][k];\n                } else {\n                    if(j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(i > 0) dp[i][j][k] += dp[i-1][j][k];\n                }\n                dp[i][j][k] %= mod;\n                if(checker[i][j][k] == 1 and dp[i][j][k]) {\n                    //cerr << i << \" \" << j << \" \" << k << \" \" << S.substr(k, S.size()) << \" \" << dp[i][j][k] << endl;\n                    ans += dp[i][j][k];\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    //cerr << dp[1][0][6] << \" \" << checker[1][0][6] << endl;\n    //cerr << dp[0][1][6] << \" \" << checker[0][1][6] << endl;\n    ans += mod - 1;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<18)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nconst int S=310;\n\nmint dp[2][S][S];\nint waf[S][S];\nbool ok[3][S][S];\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tstring s;cin>>s;\n\tint n=si(s);\n\t\n\t{\n\t\trep(i,S)rep(j,S)waf[i][j]=inf;\n\t\twaf[0][0]=0;\n\t\tint cur=0;\n\t\tok[cur][0][0]=1;\n\t\trep(step,n){\n\t\t\tint nx=(cur+1)%3;\n\t\t\tint my=(cur+2)%3;\n\t\t\trep(i,n+1)rep(j,n+1)if(ok[cur][i][j]){\n\t\t\t\tif(i&&s[step]=='1'){\n\t\t\t\t\tok[nx][i-1][j+1]=true;\n\t\t\t\t}\n\t\t\t\tif(i&&s[step]=='0'){\n\t\t\t\t\tok[nx][i][j]=true;\n\t\t\t\t}\n\t\t\t\tif(j&&s[step]=='0'){\n\t\t\t\t\tok[nx][i+1][j-1]=true;\n\t\t\t\t}\n\t\t\t\tif(j&&s[step]=='1'){\n\t\t\t\t\tok[nx][i][j]=true;\n\t\t\t\t}\n\t\t\t\tif(step+1<n){\n\t\t\t\t\trep(tar,2){\n\t\t\t\t\t\tif(s[step]-'0'==tar||s[step+1]-'0'==tar){\n\t\t\t\t\t\t\tok[my][i+(tar==0)][j+(tar==1)]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tzero(ok[cur]);\n\t\t\tcur=nx;\n\t\t\t\n\t\t\trep(i,n+1)rep(j,n+1)if(ok[cur][i][j])\n\t\t\t\tchmin(waf[i][j],step+1);\n\t\t}\n\t}\n\t\n\tmint ans;\n\t\n\treverse(all(s));\n\t\n\tint cur=0;\n\tdp[cur][0][0]=1;\n\trep(head,n){\n\t\tint nx=cur^1;\n\t\tzero(dp[nx]);\n\t\t\n\t\trep(i,head+1)rep(j,head-i+1){\n\t\t\tint u=s[head-i-j]-'0';\n\t\t\tif(u==0)dp[nx][i][j]+=dp[cur][i][j];\n\t\t\telse dp[nx][i+1][j]+=dp[cur][i][j];\n\t\t\tif(u==1)dp[nx][i][j]+=dp[cur][i][j];\n\t\t\telse dp[nx][i][j+1]+=dp[cur][i][j];\n\t\t}\n\t\t\n\t\tcur=nx;\n\t\t\n\t\tmint w;\n\t\trep(i,head+2)rep(j,head-i+2){\n\t\t\tint rem=head+1-i-j;\n\t\t\tif(waf[i][j]<=n-rem)\n\t\t\t\tw+=dp[cur][i][j];\n\t\t}\n\t\tans+=w;\n\t}\n\t\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 310\n#define mo 998244353\nusing namespace std;\nstring s;\nll jie[N],nj[N],dp[N][N][N],f[N][2],ans,n;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nll C(ll x,ll y){if (x==-1&&y==0)return 1;if (x<y)return 0;return (jie[x]*nj[y]%mo)*nj[x-y]%mo;}\nint main(){\n\tcin>>s;n=s.length();\n\tjie[0]=1;for (int i=1;i<=n;i++)jie[i]=jie[i-1]*i%mo;\n\tnj[n]=po(jie[n],mo-2);for (int i=n-1;i>=0;i--)nj[i]=nj[i+1]*(i+1)%mo;\n\tdp[0][0][0]=1;\n\tfor (int i=0;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tfor (int k=0;j+k<=i;k++){\n\t\t\t\tif (dp[i][j][k]){\n\t\t\t\t\tdp[i+1][j][k]=1;\n\t\t\t\t\tif (s[i]=='0'||s[i+1]=='0')dp[i+2][j+1][k]=1;\n\t\t\t\t\tif (s[i]=='1'||s[i+1]=='1')dp[i+2][j][k+1]=1;\n\t\t\t\t\tif (s[i]=='0'&&k)dp[i+1][j+1][k-1]=1;\n\t\t\t\t\tif (s[i]=='1'&&j)dp[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--){f[i][0]=f[i+1][0];f[i][1]=f[i+1][1];f[i][s[i-1]-'0']++;}\n\tfor (int i=0;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tfor (int k=0;k+j<=i;k++){\n\t\t\t\tif (dp[i][j][k]){\n\t\t\t\t\tans=(ans+C(f[i][0]+k-1,k)*C(f[i][1]+j-1,j))%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans+mo-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 303, M = 998244353;\n\nint n;\nchar a[N];\n\nbool can[N][N][N];\n\nint dp[N][N][N];\n\nvoid solv()\n{\n    scanf(\" %s\", (a + 1));\n    for (n = 1; a[n]; ++n){}\n    --n;\n    can[0][0][0] = true;\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int q0 = n; q0 >= 0; --q0)\n        {\n            for (int q1 = n; q1 >= 0; --q1)\n            {\n                if (i == n - 1 && q0 == 1 && q1 == 0)\n                    printf(\"\");\n                if (!can[i][q0][q1])\n                    continue;\n                if (q0 >= 2)\n                    can[i][q0 - 1][q1] = true;\n                if (q1 >= 2)\n                    can[i][q0][q1 - 1] = true;\n                if (q0 >= 1 && q1 >= 1)\n                {\n                    can[i][q0][q1 - 1] = true;\n                    can[i][q0 - 1][q1] = true;\n                }\n                if (i < n)\n                {\n                    if (a[i + 1] == '0')\n                    {\n                        if (q0 >= 1)\n                            can[i + 1][q0][q1] = true;\n                        if (q1 >= 1)\n                        {\n                            can[i + 1][q0 + 1][q1 - 1] = true;\n                            can[i + 1][q0][q1] = true;\n                        }\n                    }\n                    else\n                    {\n                        if (q0 >= 1)\n                        {\n                            can[i + 1][q0 - 1][q1 + 1] = true;\n                            can[i + 1][q0][q1] = true;\n                        }\n                        if (q1 >= 1)\n                            can[i + 1][q0][q1] = true;\n                    }\n                }\n                if (i + 1 < n)\n                {\n                    if (a[i + 1] == a[i + 2])\n                    {\n                        if (a[i + 1] == '0')\n                            can[i + 2][q0 + 1][q1] = true;\n                        else\n                            can[i + 2][q0][q1 + 1] = true;\n                    }\n                    else\n                    {\n                        can[i + 2][q0 + 1][q1] = true;\n                        can[i + 2][q0][q1 + 1] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    dp[n + 1][0][0] = 1;\n    for (int i = n + 1; i >= 1; --i)\n    {\n        for (int q0 = 0; q0 <= n; ++q0)\n        {\n            for (int q1 = 0; q1 <= n; ++q1)\n            {\n                // 0\n                if (a[i] == '0')\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i + 1][q0][q1]) % M;\n                else if (q0 >= 1)\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i][q0 - 1][q1]) % M;\n                // 1\n                if (a[i] == '1')\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i + 1][q0][q1]) % M;\n                else if (q1 >= 1)\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i][q0][q1 - 1]) % M;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int q0 = 0; q0 <= n; ++q0)\n    {\n        for (int q1 = 0; q1 <= n; ++q1)\n        {\n            int yq0 = q0, yq1 = q1;\n            for (int i = n; i >= 0; --i)\n            {\n                if (can[i][yq0][yq1])\n                {\n                    ans = (ans + dp[i + 1][yq0][yq1]) % M;\n                    break;\n                }\n                if (a[i] == '0')\n                    --yq0;\n                else\n                    --yq1;\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    //ios_base::sync_with_stdio(false), cin.tie(0);\n    solv();\n    return 0;\n}\n\n//while ((double)clock() / CLOCKS_PER_SEC <= 0.9){}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(j>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nstring S;\nlong long mod = 998244353;\nlong long dp[309][309][309];\nbool I[309][309][309];\n\nvoid solve(int pos) {\n\t// 単純に消す操作\n\tif (pos >= 1) {\n\t\tfor (int i = 0; i <= S.size(); i++) {\n\t\t\tfor (int j = 0; j <= S.size(); j++) {\n\t\t\t\tif (I[pos - 1][i][j] == true) I[pos][i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 合成させる操作\n\tif (pos >= 2) {\n\t\tfor (int i = 0; i <= S.size(); i++) {\n\t\t\tfor (int j = 0; j <= S.size(); j++) {\n\t\t\t\tif (I[pos - 2][i][j] == false) continue;\n\t\t\t\tint c0 = 0, c1 = 0;\n\t\t\t\tif (S[pos - 2] == '0') c0++; else c1++;\n\t\t\t\tif (S[pos - 1] == '0') c0++; else c1++;\n\t\t\t\tif (c0 >= 1) I[pos][i + 1][j] = true;\n\t\t\t\tif (c1 >= 1) I[pos][i][j + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 前と繋げる操作\n\tif (pos >= 2) {\n\t\tfor (int i = 0; i <= S.size(); i++) {\n\t\t\tfor (int j = 0; j <= S.size(); j++) {\n\t\t\t\tif (I[pos - 1][i][j] == false) continue;\n\t\t\t\tif (i >= 1) {\n\t\t\t\t\tint c0 = 1, c1 = 0;\n\t\t\t\t\tif (S[pos - 1] == '0') c0++; else c1++;\n\t\t\t\t\tif (c0 >= 1) I[pos][i][j] = true;\n\t\t\t\t\tif (c1 >= 1) I[pos][i - 1][j + 1] = true;\n\t\t\t\t}\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tint c0 = 0, c1 = 1;\n\t\t\t\t\tif (S[pos - 1] == '0') c0++; else c1++;\n\t\t\t\t\tif (c0 >= 1) I[pos][i + 1][j - 1] = true;\n\t\t\t\t\tif (c1 >= 1) I[pos][i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> S;\n\n\t// DP フェーズ\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\tfor (int k = 0; k < S.size(); k++) {\n\t\t\t\tif (i + j + k >= S.size()) continue;\n\t\t\t\t\n\t\t\t\tif (S[S.size() - 1 - i] == '0') {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k];\n\t\t\t\t\tdp[i + 1][j][k] %= mod;\n\t\t\t\t\tdp[i][j][k + 1] += dp[i][j][k];\n\t\t\t\t\tdp[i][j][k + 1] %= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k];\n\t\t\t\t\tdp[i + 1][j][k] %= mod;\n\t\t\t\t\tdp[i][j + 1][k] += dp[i][j][k];\n\t\t\t\t\tdp[i][j + 1][k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 判定フェーズ\n\tI[0][0][0] = true;\n\tfor (int i = 1; i <= S.size(); i++) {\n\t\tsolve(i);\n\t}\n\t\n\t// 答え\n\tlong long Answer = 0;\n\tfor (int i = 0; i <= S.size(); i++) {\n\t\tfor (int j = 0; j <= S.size(); j++) {\n\t\t\tfor (int k = 0; k <= S.size(); k++) {\n\t\t\t\tbool I1 = I[S.size() - i][j][k];\n\t\t\t\tif (I1 == true) Answer += dp[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout << (Answer + mod - 1) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool can[330][330][330];\nMint dp[330][330][330];\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   string S; cin >> S;\n   int N = S.size();\n   for (int i = 0; i < N; ++i) {\n      can[i][0][0] = true;\n      for (int n0 = 0; n0 <= i; ++n0) {\n         for (int n1 = 0; n1 <= i; ++n1) {\n            if (!can[i][n0][n1]) continue;\n            if (i) can[i + 1][n0][n1] = true;\n            if (n0) {\n               int nn0 = n0 - 1 + (S[i] == '0');\n               int nn1 = n1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (n1) {\n               int nn0 = n0 + (S[i] == '0');\n               int nn1 = n1 - 1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (i + 1 < N) {\n               can[i + 2][n0 + (S[i] == '0')][n1 + (S[i] == '1')] = true;\n               can[i + 2][n0 + (S[i + 1] == '0')][n1 + (S[i + 1] == '1')] = true;\n            }\n         }\n      }\n   }\n   can[N][0][0] = false;\n   Mint ans = 0;\n   dp[N][0][0] = 1;\n   for (int i = N; i >= 0; --i) {\n      for (int n0 = 0; n0 <= N; ++n0) {\n         for (int n1 = 0; n1 <= N; ++n1) {\n            // if (dp[i][n0][n1].val == 0) continue;\n            if (can[i][n0][n1]) ans += dp[i][n0][n1];\n\n            if (i > 0 && S[i - 1] == '0') {\n               dp[i - 1][n0][n1] += dp[i][n0][n1];\n            } else {\n               dp[i][n0 + 1][n1] += dp[i][n0][n1];\n            }\n\n            if (i > 0 && S[i - 1] == '1') {\n               dp[i - 1][n0][n1] += dp[i][n0][n1];\n            } else {\n               dp[i][n0][n1 + 1] += dp[i][n0][n1];\n            }\n         }\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=300,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nchar s[N+9];\nint n;\n\nvoid into(){\n  scanf(\"%s\",s+1);\n  n=strlen(s+1);\n}\n\nint dp[N+9][N+9][N+9];\n\nvoid Get_dp(){\n  dp[n][0][0]=1;\n  for (int i=n;i>=1;--i)\n\tfor (int j=0;j<i;++j)\n\t  for (int k=0;j+k<i;++k){\n\t\tdp[i-1][j][k]=dp[i][j][k];\n\t\ts[i]=='0'?sadd(dp[i][j][k+1],dp[i][j][k]):sadd(dp[i][j+1][k],dp[i][j][k]);\n\t  }\n}\n\nint f[N+9][N+9][N+9];\n\nvoid Get_f(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=n;++j)\n\t  for (int k=0;k<=n;++k) f[i][j][k]=-1;\n  f[0][0][0]=0;\n  for (int i=0;i<n;++i)\n\tfor (int j=0;j<=i>>1;++j)\n\t  for (int k=0;j+k<=i>>1;++k){\n\t\tif (f[i][j][k]==-1) continue;\n\t\ts[i+1]=='0'?f[i+1][j+1][k]=max(f[i+1][j+1][k],f[i][j][k]-1):f[i+1][j][k+1]=max(f[i+1][j][k+1],f[i][j][k]-1);\n\t\tif (i+2>n) continue;\n\t\tf[i+2][j][k]=max(f[i+2][j][k],f[i][j][k]+1);\n\t\tif (s[i+1]=='0'||s[i+2]=='0') f[i+2][j+1][k]=max(f[i+2][j+1][k],f[i][j][k]);\n\t\tif (s[i+1]=='1'||s[i+2]=='1') f[i+2][j][k+1]=max(f[i+2][j][k+1],f[i][j][k]);\n\t  }\n}\n\nint g[N+9][N+9][N+9];\n\nvoid Get_g(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=n;j>=0;--j)\n\t  for (int k=n;k>=0;--k){\n\t\tg[i][j][k]=f[i][j][k]>=0;\n\t\tif (i) g[i][j][k]|=g[i-1][j][k];\n\t\tg[i][j][k]|=g[i][j+1][k]|g[i][j][k+1];\n\t  }\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=i;++j)\n\t  for (int k=0;j+k<=i;++k)\n\t\tif (g[i][j][k]) sadd(ans,dp[i][j][k]);\n}\n\nvoid work(){\n  Get_dp();\n  Get_f();\n  Get_g();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",sub(ans,1));\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint CC[310][310];\nchar p[310];\nint M[310][310], w[310], vis[310][310], D[310][310][310], Mod = 998244353;\nint n;\nlong long res;\nvoid UDT(int i, int a, int b){\n    if(M[i][a]<b)M[i][a]=b;\n}\nvoid Do(int L){\n    int i, j, k;\n    for(i=0;i<=n;i++){\n        for(j=0;j<=n;j++){\n            M[i][j]=-1;\n        }\n    }\n    M[0][0]=0;\n    for(i=0;i<L;i++){\n        for(j=0;j<=L;j++){\n            int a = j, b = M[i][j];\n            if(b==-1)continue;\n            UDT(i+1,a,b);\n            if(i+2<=L){\n                if(w[i+1]==0||w[i+2]==0)UDT(i+2, a+1,b);\n                if(w[i+1]==1||w[i+2]==1)UDT(i+2, a,b+1);\n            }\n            if(w[i+1]==0 && b){\n                UDT(i+1,a+1,b-1);\n            }\n            if(w[i+1]==1 && a){\n                UDT(i+1,a-1,b+1);\n            }\n        }\n    }\n    int cc[2]={0};\n    for(i=L+1;i<=n;i++){\n        cc[w[i]]++;\n    }\n    for(i=0;i<=L;i++){\n        for(j=0;j<=M[L][i];j++){\n            if(!i&&!j)continue;\n            int x = cc[0]+i,y = cc[1]+j;\n            if(!vis[x][y]){\n                vis[x][y]=1;\n                for(k=n-L;k<=n;k++){\n                    res+=D[x][y][k];\n                }\n            }\n        }\n    }\n}\nint main(){\n    int i, j, k, l;\n    scanf(\"%s\",p);\n    for(i=0;p[i];i++);\n    n=i;\n    for(i=1;i<=n;i++)w[i]=p[i-1]-'0';\n    D[0][0][0]=1;\n    for(i=0;i<=n;i++){\n        for(j=0;i+j<=n;j++){\n            for(k=0;k<=n;k++){\n                if(!D[i][j][k])continue;\n                int t = D[i][j][k];\n                if(k+1<=n && w[n-(k+1)+1]==0){\n                    D[i+1][j][k+1]=(D[i+1][j][k+1]+t)%Mod;\n                }\n                else{\n                    D[i+1][j][k]=(D[i+1][j][k]+t)%Mod;\n                }\n                if(k+1<=n && w[n-(k+1)+1]==1){\n                    D[i][j+1][k+1]=(D[i][j+1][k+1]+t)%Mod;\n                }\n                else{\n                    D[i][j+1][k]=(D[i][j+1][k]+t)%Mod;\n                }\n            }\n        }\n    }\n    for(i=n;i>=2;i--){\n        Do(i);\n    }\n    res++;\n    printf(\"%lld\\n\",res%Mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define MD (998244353U)\nvoid *wmem;\nchar memarr[96000000];\ntemplate<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){\n  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct Modint{\n  unsigned val;\n  Modint(){\n    val=0;\n  }\n  Modint(int a){\n    val = ord(a);\n  }\n  Modint(unsigned a){\n    val = ord(a);\n  }\n  Modint(long long a){\n    val = ord(a);\n  }\n  Modint(unsigned long long a){\n    val = ord(a);\n  }\n  inline unsigned ord(unsigned a){\n    return a%MD;\n  }\n  inline unsigned ord(int a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned ord(unsigned long long a){\n    return a%MD;\n  }\n  inline unsigned ord(long long a){\n    a %= (int)MD;\n    if(a < 0){\n      a += MD;\n    }\n    return a;\n  }\n  inline unsigned get(){\n    return val;\n  }\n  inline Modint &operator+=(Modint a){\n    val += a.val;\n    if(val >= MD){\n      val -= MD;\n    }\n    return *this;\n  }\n  inline Modint &operator-=(Modint a){\n    if(val < a.val){\n      val = val + MD - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  inline Modint &operator*=(Modint a){\n    val = ((unsigned long long)val*a.val)%MD;\n    return *this;\n  }\n  inline Modint &operator/=(Modint a){\n    return *this *= a.inverse();\n  }\n  inline Modint operator+(Modint a){\n    return Modint(*this)+=a;\n  }\n  inline Modint operator-(Modint a){\n    return Modint(*this)-=a;\n  }\n  inline Modint operator*(Modint a){\n    return Modint(*this)*=a;\n  }\n  inline Modint operator/(Modint a){\n    return Modint(*this)/=a;\n  }\n  inline Modint operator+(int a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(int a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(int a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(int a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator+(long long a){\n    return Modint(*this)+=Modint(a);\n  }\n  inline Modint operator-(long long a){\n    return Modint(*this)-=Modint(a);\n  }\n  inline Modint operator*(long long a){\n    return Modint(*this)*=Modint(a);\n  }\n  inline Modint operator/(long long a){\n    return Modint(*this)/=Modint(a);\n  }\n  inline Modint operator-(void){\n    Modint res;\n    if(val){\n      res.val=MD-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  inline operator bool(void){\n    return val!=0;\n  }\n  inline operator int(void){\n    return get();\n  }\n  inline operator long long(void){\n    return get();\n  }\n  inline Modint inverse(){\n    int a = val;\n    int b = MD;\n    int u = 1;\n    int v = 0;\n    int t;\n    Modint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += MD;\n    }\n    res.val = u;\n    return res;\n  }\n  inline Modint pw(unsigned long long b){\n    Modint a(*this);\n    Modint res;\n    res.val = 1;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  inline bool operator==(int a){\n    return ord(a)==val;\n  }\n  inline bool operator!=(int a){\n    return ord(a)!=val;\n  }\n}\n;\ninline Modint operator+(int a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(int a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(int a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(int a, Modint b){\n  return Modint(a)/=b;\n}\ninline Modint operator+(long long a, Modint b){\n  return Modint(a)+=b;\n}\ninline Modint operator-(long long a, Modint b){\n  return Modint(a)-=b;\n}\ninline Modint operator*(long long a, Modint b){\n  return Modint(a)*=b;\n}\ninline Modint operator/(long long a, Modint b){\n  return Modint(a)/=b;\n}\ninline int my_getchar_unlocked(){\n  static char buf[1048576];\n  static int s = 1048576;\n  static int e = 1048576;\n  if(s == e && e == 1048576){\n    e = fread_unlocked(buf, 1, 1048576, stdin);\n    s = 0;\n  }\n  if(s == e){\n    return EOF;\n  }\n  return buf[s++];\n}\ninline void rd(char &c){\n  int i;\n  for(;;){\n    i = my_getchar_unlocked();\n    if(i!=' '&&i!='\\n'&&i!='\\r'&&i!='\\t'&&i!=EOF){\n      break;\n    }\n  }\n  c = i;\n}\ninline int rd(char c[]){\n  int i;\n  int sz = 0;\n  for(;;){\n    i = my_getchar_unlocked();\n    if(i!=' '&&i!='\\n'&&i!='\\r'&&i!='\\t'&&i!=EOF){\n      break;\n    }\n  }\n  c[sz++] = i;\n  for(;;){\n    i = my_getchar_unlocked();\n    if(i==' '||i=='\\n'||i=='\\r'||i=='\\t'||i==EOF){\n      break;\n    }\n    c[sz++] = i;\n  }\n  c[sz]='\\0';\n  return sz;\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  int s=0;\n  int m=0;\n  char f[10];\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(Modint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\ntemplate<class S, class T> inline S chmax(S &a, T b){\n  if(a<b){\n    a=b;\n  }\n  return a;\n}\ntemplate<class T> struct Comb{\n  int mem_fact;\n  T *factri;\n  T *ifactri;\n  Comb(){\n    mem_fact = 0;\n  }\n  inline void expand_fact(int k){\n    if(k <= mem_fact){\n      return;\n    }\n    chmax(k, 2* mem_fact);\n    if(mem_fact == 0){\n      int i;\n      factri = (T*)malloc(k * sizeof(T));\n      ifactri = (T*)malloc(k * sizeof(T));\n      factri[0] = 1;\n      for(i=(1);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(0);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    else{\n      int i;\n      factri = (T*)realloc(factri, k * sizeof(T));\n      ifactri = (T*)realloc(ifactri, k * sizeof(T));\n      for(i=(mem_fact);i<(k);i++){\n        factri[i] = i * factri[i-1];\n      }\n      ifactri[k-1] = 1 / factri[k-1];\n      for(i=(k-1)-1;i>=(mem_fact);i--){\n        ifactri[i] = (i+1) * ifactri[i+1];\n      }\n    }\n    mem_fact = k;\n  }\n  inline T fac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return factri[k];\n  }\n  inline T ifac(int k){\n    if(mem_fact < k+1){\n      expand_fact(k+1);\n    }\n    return ifactri[k];\n  }\n  inline T C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[b] * ifactri[a-b];\n  }\n  inline T P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(mem_fact < a+1){\n      expand_fact(a+1);\n    }\n    return factri[a] * ifactri[a-b];\n  }\n  inline T H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a <= 0 || b < 0){\n      return 0;\n    }\n    if(mem_fact < a+b){\n      expand_fact(a+b);\n    }\n    return C(a+b-1, b);\n  }\n  inline T Multinomial(int sz, int a[]){\n    int i;\n    int s = 0;\n    T res;\n    for(i=(0);i<(sz);i++){\n      s += a[i];\n    }\n    if(mem_fact < s+1){\n      expand_fact(s+1);\n    }\n    res = factri[s];\n    for(i=(0);i<(sz);i++){\n      res *= ifactri[a[i]];\n    }\n    return 1;\n  }\n  inline T Multinomial(int a){\n    return 1;\n  }\n  inline T Multinomial(int a, int b){\n    if(mem_fact < a+b+1){\n      expand_fact(a+b+1);\n    }\n    return factri[a+b] * ifactri[a] * ifactri[b];\n  }\n  inline T Multinomial(int a, int b, int c){\n    if(mem_fact < a+b+c+1){\n      expand_fact(a+b+c+1);\n    }\n    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];\n  }\n  inline T Multinomial(int a, int b, int c, int d){\n    if(mem_fact < a+b+c+d+1){\n      expand_fact(a+b+c+d+1);\n    }\n    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];\n  }\n  inline T Catalan(int n){\n    if(n < 0){\n      return 0;\n    }\n    if(mem_fact < 2*n+1){\n      expand_fact(2*n+1);\n    }\n    return factri[2*n] * ifactri[n] * ifactri[n+1];\n  }\n  inline T C_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    if(b > a - b){\n      b = a - b;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n      res /= i + 1;\n    }\n    return res;\n  }\n  inline T P_s(long long a, long long b){\n    long long i;\n    T res;\n    if(b < 0 || b > a){\n      return 0;\n    }\n    res = 1;\n    for(i=(0);i<(b);i++){\n      res *= a - i;\n    }\n    return res;\n  }\n  inline T per_s(long long n, long long k){\n    T d;\n    int m;\n    if(n < 0 || k < 0){\n      return 0;\n    }\n    if(n == k  &&  k == 0){\n      return 1;\n    }\n    if(n == 0 || k == 0){\n      return 0;\n    }\n    if(k==1){\n      return 1;\n    }\n    if(k==2){\n      d = n / 2;\n      return d;\n    }\n    if(k==3){\n      d = (n-1) / 6;\n      m = (n-1) % 6;\n      if(m==0){\n        return 3 * d * d + d;\n      }\n      if(m==1){\n        return 3 * d * d + 2 * d;\n      }\n      if(m==2){\n        return 3 * d * d + 3 * d + 1;\n      }\n      if(m==3){\n        return 3 * d * d + 4 * d + 1;\n      }\n      if(m==4){\n        return 3 * d * d + 5 * d + 2;\n      }\n      if(m==5){\n        return 3 * d * d + 6 * d + 3;\n      }\n    }\n    assert(0 && \"per_s should be k <= 3\");\n    return -1;\n  }\n}\n;\nint N;\nchar S[302];\nComb<Modint> c;\nModint dp[301][301];\nModint nx[301][301];\nModint solve(int x, int y, int len, char s[]){\n  int i, k;\n  for(i=(0);i<(x+1);i++){\n    int j;\n    for(j=(0);j<(len+1);j++){\n      dp[i][j] = 0;\n    }\n  }\n  dp[x][0] = 1;\n  for(k=(0);k<(x+y);k++){\n    for(i=(0);i<(x+1);i++){\n      int j;\n      for(j=(0);j<(len+1);j++){\n        nx[i][j] = 0;\n      }\n    }\n    for(i=(1);i<(x+1);i++){\n      int j;\n      for(j=(0);j<(len+1);j++){\n        if(j==len){\n          nx[i-1][j] += dp[i][j];\n        }\n        if(j!=len && s[j]==0){\n          nx[i-1][j+1] += dp[i][j];\n        }\n        if(j!=len && s[j]!=0){\n          nx[i-1][j] += dp[i][j];\n        }\n      }\n    }\n    for(i=(0);i<(x+1);i++){\n      int j;\n      for(j=(0);j<(len+1);j++){\n        if(j==len){\n          nx[i][j] += dp[i][j];\n        }\n        if(j!=len && s[j]==1){\n          nx[i][j+1] += dp[i][j];\n        }\n        if(j!=len && s[j]!=1){\n          nx[i][j] += dp[i][j];\n        }\n      }\n    }\n    for(i=(0);i<(x+1);i++){\n      int j;\n      for(j=(0);j<(len+1);j++){\n        dp[i][j] = nx[i][j];\n      }\n    }\n  }\n  return dp[0][len];\n}\nint main(){\n  wmem = memarr;\n  int z = 0;\n  int o = 0;\n  int x;\n  int y;\n  int i;\n  int j;\n  int k;\n  int dx;\n  int dy;\n  int d;\n  int dl;\n  int r0;\n  int r1;\n  int rb;\n  int mx;\n  int c0;\n  int c1;\n  Modint res = 0;\n  N = rd(S);\n  if(0){\n    string s = S;\n    string t;\n    string ad;\n    set<string> st;\n    vector<string> v;\n    st.insert(s);\n    v.push_back(s);\n    while(v.size()){\n      s = v.back();\n      v.pop_back();\n      if(s.size() < 2){\n        continue;\n      }\n      t = s.substr(0,2);\n      s = s.substr(2);\n      for(i=(0);i<(s.size()+1);i++){\n        for(j=(0);j<(2);j++){\n          ad = s.substr(0,i) + t.substr(j,1) + s.substr(i);\n          if(st.count(ad)){\n            continue;\n          }\n          st.insert(ad);\n          v.push_back(ad);\n        }\n      }\n    }\n    int res = st.size();\n    wt_L(res);\n    wt_L('\\n');\n    for(string s : st){\n      cout << s << endl;\n    }\n    return 0;\n  }\n  for(i=(0);i<(N);i++){\n    S[i] -= '0';\n  }\n  for(i=(0);i<(N);i++){\n    if(S[i]==0){\n      z++;\n    }\n    else{\n      o++;\n    }\n  }\n  for(x=(0);x<(z+1);x++){\n    for(y=(0);y<(o+1);y++){\n      if(x||y){\n        if(x==z && y==o){\n          res+=1;\n          continue;\n        }\n        dx = z - x;\n        dy = o - y;\n        d = dx + dy;\n        r0 = r1 = rb = 0;\n        i = 0;\n        while(d && i < N){\n          c0 = c1 = 0;\n          if(i < N && S[i]==0){\n            c0++;\n          }\n          if(i < N && S[i]==1){\n            c1++;\n          }\n          if(i+1 < N && S[i+1]==0){\n            c0++;\n          }\n          if(i+1 < N && S[i+1]==1){\n            c1++;\n          }\n          if(c0 && c1){\n            d--;\n            rb++;\n            dx--;\n            dy--;\n            i+=2;\n            continue;\n          }\n          if(c0==2 && dx){\n            d--;\n            dx--;\n            r0++;\n            i+=2;\n            continue;\n          }\n          if(c1==2 && dy){\n            d--;\n            dy--;\n            r1++;\n            i+=2;\n            continue;\n          }\n          if(c0==2 && r1){\n            d--;\n            dy--;\n            r1--;\n            r0+=2;\n            i+=2;\n            continue;\n          }\n          if(c1==2 && r0){\n            d--;\n            dx--;\n            r0--;\n            r1+=2;\n            i+=2;\n            continue;\n          }\n          if(i+1 < N && S[i+1]==0){\n            c0--;\n          }\n          if(i+1 < N && S[i+1]==1){\n            c1--;\n          }\n          if(c0==1 && dx){\n            d--;\n            dx--;\n            i+=1;\n            continue;\n          }\n          if(c1==1 && dy){\n            d--;\n            dy--;\n            i+=1;\n            continue;\n          }\n          if(c0==1 && r1){\n            d--;\n            r0++;\n            r1--;\n            dy--;\n            i+=1;\n            continue;\n          }\n          if(c1==1 && r0){\n            d--;\n            r1++;\n            r0--;\n            dx--;\n            i+=1;\n            continue;\n          }\n          if(c0==1 && rb){\n            d--;\n            rb--;\n            r0++;\n            i+=1;\n            continue;\n          }\n          if(c1==1 && rb){\n            d--;\n            rb--;\n            r1++;\n            i+=1;\n            continue;\n          }\n          goto O3U4gd88;\n        }\n        mx = i;\n        res += solve(x, y, N-mx, S+mx);\n      }\n      O3U4gd88:;\n    }\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20200509-1\n\n// --- original code ---\n// #define MD 998244353\n// int N;\n// char S[302];\n// \n// Comb<Modint> c;\n// Modint dp[301][301], nx[301][301];\n// \n// Modint solve(int x, int y, int len, char s[]){\n//   rep(i,x+1) rep(j,len+1) dp[i][j] = 0;\n//   dp[x][0] = 1;\n//   rep(k,x+y){\n//     rep(i,x+1) rep(j,len+1) nx[i][j] = 0;\n//     rep(i,1,x+1) rep(j,len+1){\n//       if(j==len) nx[i-1][j] += dp[i][j];\n//       if(j!=len && s[j]==0) nx[i-1][j+1] += dp[i][j];\n//       if(j!=len && s[j]!=0) nx[i-1][j] += dp[i][j];\n//     }\n//     rep(i,x+1) rep(j,len+1){\n//       if(j==len) nx[i][j] += dp[i][j];\n//       if(j!=len && s[j]==1) nx[i][j+1] += dp[i][j];\n//       if(j!=len && s[j]!=1) nx[i][j] += dp[i][j];\n//     }\n//     rep(i,x+1) rep(j,len+1) dp[i][j] = nx[i][j];\n//   }\n//   return dp[0][len];\n// }\n// \n// {\n//   int z = 0, o = 0, x, y, i, j, k, dx, dy, d, dl, r0, r1, rb, mx, c0, c1;\n//   Modint res = 0;\n// \n//   rd(S@N);\n// \n//   if(0){\n//     string s = S, t, ad;\n//     set<string> st;\n//     vector<string> v;\n//     st.insert(s);\n//     v.push_back(s);\n//     while(v.size()){\n//       s = v.back();\n//       v.pop_back();\n//       if(s.size() < 2) continue;\n//       t = s.substr(0,2);\n//       s = s.substr(2);\n//       rep(i,s.size()+1) rep(j,2){\n//         ad = s.substr(0,i) + t.substr(j,1) + s.substr(i);\n//         if(st.count(ad)) continue;\n//         st.insert(ad);\n//         v.push_back(ad);\n//       }\n//     }\n//     int res = st.size();\n//     wt(res);\n// \n//     for(string s : st) cout << s << endl;\n// \n//     return 0;\n//   }\n// \n//   rep(i,N) S[i] -= '0';\n//   rep(i,N) if[S[i]==0, z, o]++;\n// \n//   rep(x,z+1) rep(y,o+1) if(x||y){\n//     if(x==z && y==o) res+=1, continue;\n// \n//     dx = z - x;\n//     dy = o - y;\n//     d = dx + dy;\n//     r0 = r1 = rb = 0;\n// \n//     i = 0;\n//     while(d && i < N){\n//       c0 = c1 = 0;\n//       if(i < N && S[i]==0) c0++;\n//       if(i < N && S[i]==1) c1++;\n//       if(i+1 < N && S[i+1]==0) c0++;\n//       if(i+1 < N && S[i+1]==1) c1++;\n//       if(c0 && c1) d--, rb++, dx--, dy--, i+=2, continue;\n//       if(c0==2 && dx) d--, dx--, r0++, i+=2, continue;\n//       if(c1==2 && dy) d--, dy--, r1++, i+=2, continue;\n//       if(c0==2 && r1) d--, dy--, r1--, r0+=2, i+=2, continue;\n//       if(c1==2 && r0) d--, dx--, r0--, r1+=2, i+=2, continue;\n//       if(i+1 < N && S[i+1]==0) c0--;\n//       if(i+1 < N && S[i+1]==1) c1--;\n//       if(c0==1 && dx) d--, dx--, i+=1, continue;\n//       if(c1==1 && dy) d--, dy--, i+=1, continue;\n//       if(c0==1 && r1) d--, r0++, r1--, dy--, i+=1, continue;\n//       if(c1==1 && r0) d--, r1++, r0--, dx--, i+=1, continue;\n//       if(c0==1 && rb) d--, rb--, r0++, i+=1, continue;\n//       if(c1==1 && rb) d--, rb--, r1++, i+=1, continue;\n//       break_continue;\n//     }\n// \n//     mx = i;\n//     res += solve(x, y, N-mx, S+mx);\n// //    wt(x,y,\":\",mx,\":\",res);\n//   }\n// \n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 305;\nconst int mod = 998244353;\n\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint dp[N][N][N];\nint dp2[2][N][N][N];\nint pref[2][N];\nint main(){\n\tstring s; cin >> s;\n\tint n = s.length();\n\tif(n<=2){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\ts = \"$\" + s;\n\tint num0 = 0, num1 = 0;\n\tif(s[1] == '0') num0++;\n\telse num1++;\n\tdp2[s[1] - '0'][1][num0][num1] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tpref[0][i] = pref[0][i - 1];\n\t\tpref[1][i] = pref[1][i - 1];\n\t\tpref[s[i] - '0'][i]++;\n\t\tif(i > 1){\n\t\t\tfor(int n0 = 0; n0 <= i; n0++) for(int n1 = 0; n1 <= i; n1++) for(int old = 0; old < 2; old++) if(dp2[old][i - 1][n0][n1]){\n\t\t\t\tint other = s[i] - '0';\n\t\t\t\tint h[2] = {n0, n1};\n\t\t\t\th[other]++;\n\t\t\t\tdp2[old][i][h[0]][h[1]] = 1;\n\t\t\t\th[other]--;\n\t\t\t\th[old]++;\n\t\t\t\tdp2[other][i][h[0]][h[1]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\n\tint ans = 0;\n\n\tfor(int n0 = 0; n0 <= n; n0++) for(int n1 = 0; n1 <= n; n1++){\n\t\tfor(int now = 0; now < 2; now++){\n\t\t\tint nn0 = n0, nn1 = n1;\n\t\t\tif(now==0) nn0++;\n\t\t\tif(now==1) nn1++;\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tint num_0 = n0 - (pref[0][n] - pref[0][n - k]);\n\t\t\t\tint num_1 = n1 - (pref[1][n] - pref[1][n - k]);\n\t\t\t\t// maximum suffix that exists as a subsequence ?\n\t\t\t\tint kk = k;\n\t\t\t\tif(s[n - k] - '0'== now){\n\t\t\t\t\tkk++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[nn0][nn1][kk] = add(dp[nn0][nn1][kk], dp[n0][n1][k]);\n\t\t\t\tif(now==0) num0--;\n\t\t\t\telse num1--;\n\t\t\t\tif(num_0 >= 0 && num_1 >= 0){\n\t\t\t\t\tif(dp2[now][n - k][num_0][num_1]){\n\t\t\t\t\t\tif(dp[n0][n1][k]) trace(n0, n1, k, dp[n0][n1][k]);\n\t\t\t\t\t\tans = add(ans, dp[n0][n1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x<0?N+x:x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\ntypedef Field<998244353> FF;\n\nclass DSecretPassage {\npublic:\n    set<string> SS;\n    void brute(string S) {\n        auto it = SS.find(S);\n        if (it != SS.end()) return;\n        SS.insert(S);\n        if (S.size() == 1) return;\n        int N = S.size();\n        for (int i = 2; i <= N; ++i) {\n            brute(S.substr(2, i-2) + S[0] + S.substr(i));\n            brute(S.substr(2, i-2) + S[1] + S.substr(i));\n        }\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        string S; cin >> S;\n        int N = S.size();\n\n//        brute(S);\n//        cout << SS.size() << endl;\n//        for (string s: SS) cout << s << endl;\n\n        vector3<FF> D(N+1, N+1, N+1, 0);\n        D[0][0][0] = 1;\n        for (int i = 0; i < N; ++i) {\n            char c = S[N - i - 1];\n            for (int j = 0; j < N; ++j) {\n                for (int k = 0; k < N; ++k) {\n                    if (c == '1') {\n                        D[i + 1][j][k] += D[i][j][k];\n                        D[i][j + 1][k] += D[i][j][k];\n                    } else {\n                        D[i][j][k + 1] += D[i][j][k];\n                        D[i + 1][j][k] += D[i][j][k];\n                    }\n                }\n            }\n        }\n\n        vector3<bool> P(N+1, N+1, N+1, 0);\n        P[0][0][0] = true;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                for (int k = 0; k < N; ++k) {\n                    if (P[i][j][k]) {\n                        P[i+1][j][k] = true;\n\n                        if (j > 0 && S[i] == '1') {\n                            P[i+1][j-1][k+1] = true;\n                        }\n\n                        if (k > 0 && S[i] == '0') {\n                            P[i+1][j+1][k-1] = true;\n                        }\n\n                        if (i != N-1) {\n                            if (S[i] == '0' || S[i+1] == '0') {\n                                P[i+2][j+1][k] = true;\n                            }\n\n\n                            if (S[i] == '1' || S[i+1] == '1') {\n                                P[i+2][j][k+1] = true;\n                            }\n\n                        }\n                    }\n                }\n            }\n        }\n\n\n//        for (int i = 0; i <= N; ++i) {\n//            for (int j = 0; j <= N; ++j) {\n//                for (int k = 0; k <= N; ++k) {\n//                    if (P[i][j][k]) {\n//                        cout << i << ' ' << j << ' ' << k << endl;\n//                    }\n//                }\n//            }\n//        }\n\n        FF ans = 0;\n        for (int i = 0; i <= N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                for (int k = 0; k < N; ++k) {\n                    if (P[i][j][k] && D[N-i][j][k] != 0) {\n//                        cout << N-i << ' ' << j << ' ' << k << ' ' << D[N-i][j][k] << endl;\n                        ans += D[N-i][j][k];\n                    }\n                }\n            }\n        }\n        --ans;\n\n        cout << ans << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDSecretPassage solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define sz(x) static_cast<int>((x).size())\n\nusing LL = long long;\ntemplate<class T, size_t D>\nstruct vec : vector<vec<T, D - 1>> {\n  template<class... Args>\n  vec(size_t n = 0, Args... args)\n    : vector<vec<T, D - 1>>(n, vec<T, D - 1>(args...)) {}\n};\ntemplate<class T>\nstruct vec<T, 1> : vector<T> {\n  template<class... Args>\n  vec(Args... args)\n    : vector<T>(args...) {}\n};\n\ntemplate<class T>\ninline bool asMn(T& a, const T& b) { return a > b ? a = b, true : false; }\ntemplate<class T>\ninline bool asMx(T& a, const T& b) { return a < b ? a = b, true : false; }\ninline int nex(int i, int n) { return i == n - 1 ? 0 : i + 1; }\ninline int pre(int i, int n) { return !i ? n - 1 : i - 1; }\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD>\nstruct ModInt {\n  int a;\n  ModInt(int a_ = 0) {\n    a = a_ < MOD ? (a_ < 0 ? a_ + MOD : a_) : a_ - MOD;\n  }\n  friend ostream& operator<<(ostream& os, const ModInt& o) {\n    os << o.a;\n    return os;\n  }\n\n  ModInt operator+(const ModInt& o) const { return ModInt(a + o.a); }\n  ModInt operator-(const ModInt& o) const { return ModInt(a - o.a); }\n  ModInt operator*(const ModInt& o) const { return ModInt(static_cast<int>(static_cast<LL>(a) * o.a % MOD)); }\n  ModInt operator/(const ModInt& o) const { return *this * o.inv(); }\n  ModInt& operator+=(const ModInt& o) { return *this = *this + o; }\n  ModInt& operator-=(const ModInt& o) { return *this = *this - o; }\n  ModInt& operator*=(const ModInt& o) { return *this = *this * o; }\n  ModInt& operator/=(const ModInt& o) { return *this = *this / o; }\n  ModInt inv() const { return pow(MOD - 2); }\n  template<class T>\n  ModInt pow(T exp) const {\n    ModInt ret(1), c = *this;\n    for (; exp; exp >>= 1, c *= c) {\n      if (exp & 1) {\n        ret *= c;\n      }\n    }\n    return ret;\n  }\n};\nusing Mint = ModInt<998244353>;\n\nint main() {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n\n  string s; cin >> s;\n\n  vec<int, 1> n0(sz(s) + 1), n1(sz(s) + 1);\n  for (int i = sz(s) - 1; ~i; --i) {\n    n0[i] = n0[i + 1] + (s[i] == '0');\n    n1[i] = n1[i + 1] + (s[i] == '1');\n  }\n\n  vec<bool, 3> f(sz(s) + 1);\n  for (int i = 0; i <= sz(s); ++i) {\n    f[i] = vec<bool, 2>(n0[0] - n0[i] + 1, n1[0] - n1[i] + 1);\n  }\n  f[0][0][0] = true;\n  for (int i = 0; i < sz(s); ++i) {\n    for (int j = sz(f[i]) - 1; ~j; --j) {\n      for (int k = sz(f[i][j]) - 1; ~k; --k) {\n        if (!f[i][j][k]) {\n          continue ;\n        }\n\n        if (j + k >= 2) {\n          if (j) {\n            f[i][j - 1][k] = true;\n          }\n          if (k) {\n            f[i][j][k - 1] = true;\n          }\n        }\n        if (sz(s) - i >= 2) {\n          if (s[i] == '0' || s[i + 1] == '0') {\n            f[i + 2][j + 1][k] = true;\n          }\n          if (s[i] == '1' || s[i + 1] == '1') {\n            f[i + 2][j][k + 1] = true;\n          }\n        }\n        if (sz(s) - i + j + k >= 2) {\n          f[i + 1][j][k] = true;\n          if (s[i] == '0') {\n            if (k) {\n              f[i + 1][j + 1][k - 1] = true;\n            }\n          } else {\n            if (j) {\n              f[i + 1][j - 1][k + 1] = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  vec<Mint, 3> g(sz(s) + 1, n0[0] + 1, n1[0] + 1);\n  g[sz(s)][0][0] = Mint(1);\n  for (int i = sz(s); ~i; --i) {\n    for (int j = 0; j <= n0[0]; ++j) {\n      for (int k = 0; k <= n1[0]; ++k) {\n        if (i) {\n          if (s[i - 1] == '0' && j < n0[0]) {\n            g[i - 1][j + 1][k] += g[i][j][k];\n          } else if (s[i - 1] == '1' && k < n1[0]) {\n            g[i - 1][j][k + 1] += g[i][j][k];\n          }\n        }\n        if ((i == sz(s) || s[i] == '1') && j < n0[0]) {\n          g[i][j + 1][k] += g[i][j][k];\n        }\n        if ((i == sz(s) || s[i] == '0') && k < n1[0]) {\n          g[i][j][k + 1] += g[i][j][k];\n        }\n      }\n    }\n  }\n\n  vec<int, 2> mx(n0[0] + 1, n1[0] + 1, -1);\n  for (int i = 0; i <= sz(s); ++i) {\n    for (int j = 0; j < sz(f[i]); ++j) {\n      for (int k = 0; k < sz(f[i][j]); ++k) {\n        if (f[i][j][k]) {\n          mx[j + n0[i]][k + n1[i]] = i;\n        }\n      }\n    }\n  }\n\n  Mint ans;\n  for (int i = 0; i <= n0[0]; ++i) {\n    for (int j = 0; j <= n1[0]; ++j) {\n      if (~mx[i][j]) {\n        ans += g[mx[i][j]][i][j];\n      }\n    }\n  }\n\n  cout << ans << '\\n';\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\t\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\t/*\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\t\tstd::cerr << \"at \" << i << \" w:\" << j << \" b:\" << k << \" \" << std::endl;\n\t\t\t}\n\t\t}*/\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\t// white\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 305, P = 998244353, INF = 0x3f3f3f3f;\n\nint n;\nchar s[N];\n\nint f[N][N][N], g[N][N][N], h[N][N][N];\n\nvoid inc(int &a, int b) {\n\ta + b >= P ? a += b - P : a += b;\n}\n\nvoid upd(int &a, int b) {\n\ta = std::max(a, b);\n}\n\nvoid solve() {\n\tn = readStr(s + 1);\n\tf[n][0][0] = 1;\n\tfor (int i = n; i; --i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tfor (int k = 0; j + k < i; ++k) {\n\t\t\t\tinc(f[i - 1][j][k], f[i][j][k]);\n\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\tinc(f[i][j][k + 1], f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tinc(f[i][j + 1][k], f[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tg[i][j][k] = -INF;\n\t\t\t}\n\t\t}\n\t}\n\tg[0][0][0] = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tfor (int k = 0; j + k < i; ++k) {\n\t\t\t\tif (g[i - 1][j][k] >= 0) {\n\t\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\t\tupd(g[i][j + 1][k], g[i - 1][j][k] - 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupd(g[i][j][k + 1], g[i - 1][j][k] - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (i < n) {\n\t\t\t\t\t\tupd(g[i + 1][j][k], g[i - 1][j][k] + 1);\n\t\t\t\t\t\tif (s[i] == '0' || s[i + 1] == '0') {\n\t\t\t\t\t\t\tupd(g[i + 1][j + 1][k], g[i - 1][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s[i] == '1' || s[i + 1] == '1') {\n\t\t\t\t\t\t\tupd(g[i + 1][j][k + 1], g[i - 1][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = n; ~j; --j) {\n\t\t\tfor (int k = n; ~k; --k) {\n\t\t\t\th[i][j][k] = g[i][j][k] >= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\th[i][j][k] |= h[i - 1][j][k];\n\t\t\t\t}\n\t\t\t\tif (j < n) {\n\t\t\t\t\th[i][j][k] |= h[i][j + 1][k];\n\t\t\t\t}\n\t\t\t\tif (k < n) {\n\t\t\t\t\th[i][j][k] |= h[i][j][k + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = P - 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = 0; j + k <= i; ++k) {\n\t\t\t\tif (h[i][j][k]) {\n\t\t\t\t\tinc(ans, f[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tint T = 1;\n\t// read(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 998244353\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 310\nlong long dp[N][N][N];\n//長さ, 一致数, 0の数\n\nint main() {\n\tlong long n;\n\tlong long ans;\n\tlong long min0[N];\n\tlong long max0[N];\n\tlong long cnt0;\n\tlong long cnt1;\n\tlong long x, y, z;\n\tchar aa[N];\n\tchar a[N];\n\tf(i, N) {\n\t\ta[i] = 0;\n\t\taa[i] = 0;\n\t}\n\tscanf(\"%s\", aa);\n\tn = strlen(aa);\n\tmin0[0] = 0;\n\tmax0[0] = 0;\n\tcnt0 = 0;\n\tcnt1 = 0;\n\tx = 0;\n\tf(i, n) {\n\t\tx = 2 * i;\n\t\tif (x < n) {\n\t\t\tif (aa[x] == '0')cnt0++;\n\t\t\telse cnt1++;\n\t\t}\n\t\tx = 2 * i + 1;\n\t\tif (x < n) {\n\t\t\tif (aa[x] == '0')cnt0++;\n\t\t\telse cnt1++;\n\t\t}\n\t\tif (cnt0 > max0[i])max0[i + 1] = max0[i] + 1;\n\t\telse max0[i + 1] = max0[i];\n\t\tx = i;\n\t\tif ((cnt1 + min0[i]) <= i)min0[i + 1] = min0[i] + 1;\n\t\telse min0[i + 1] = min0[i];\n\t}\n\tmin0[0] += cnt0;\n\tmax0[0] += cnt0;\n\tf(i, n) {\n\t\tx = 2 * i;\n\t\tif (x < n) {\n\t\t\tif (aa[x] == '0')cnt0--;\n\t\t\telse cnt1++;\n\t\t}\n\t\tx = 2 * i + 1;\n\t\tif (x < n) {\n\t\t\tif (aa[x] == '0')cnt0--;\n\t\t\telse cnt1++;\n\t\t}\n\t\tmin0[i + 1] += cnt0;\n\t\tmax0[i + 1] += cnt0;\n\t}\n\n\tf(i, n)a[i] = aa[n - i - 1];\n\tf(i, N) {\n\t\tf(j, N) {\n\t\t\tf(ii, N)dp[i][j][ii] = 0;\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\t//配るDP\n\tf(i, n) {\n\t\t//i->i+1\n\t\tf(j, i + 1) {\n\t\t\tf(k, i + 1) {\n\t\t\t\tif (a[j] == '0') {\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] = (dp[i + 1][j + 1][k + 1] + dp[i][j][k]) % MOD;\n\t\t\t\t\tdp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k]) % MOD;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][k + 1] = (dp[i + 1][j][k + 1] + dp[i][j][k]) % MOD;\n\t\t\t\t\tdp[i + 1][j + 1][k] = (dp[i + 1][j + 1][k] + dp[i][j][k]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tf(ii, n + 1) {\n\t\tf(jj, n + 1) {\n\t\t\tfor (long long i = n - 1; i >= 0; i--) {\n\t\t\t\tdp[ii][i][jj] = (dp[ii][i][jj] + dp[ii][i + 1][jj]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tans = 0;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tx = max((long long)0, 2 * i - n);\n\t\tif ((2 * i) <= n) {\n\t\t\tmin0[n - i] = 0;\n\t\t\tmax0[n - i] = n + 1;\n\t\t}\n\t\tfor (long long j = min0[n - i]; j <= max0[n - i]; j++) {\n\t\t\tans = (ans + dp[i][x][j]) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing LL = long long;\n\ntemplate<typename T>\nostream& operator << (ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for(auto& x : v) {\n        out << x << \", \";\n    }\n    return out << \"]\";\n}\n\ntemplate<typename S, typename T>\nostream& operator << (ostream& out, const pair<S, T>& p) {\n    return out << \"{\" << p.first << \", \" << p.second << \"}\";\n}\n\nbool reachable[310][310][310];\n\nint N;\nvector<int> V;\nint suff_ones[310];\nint suff_zeroes[310];\nint shortest_suff[310][310];\n\nvoid explore(int n, int z, int o) {\n    if(z < 0 or o < 0) {\n        return;\n    }\n    if(reachable[n][z][o]) {\n        return;\n    }\n    reachable[n][z][o] = 1;\n    shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]] = max(shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]], n);\n    if(z + o + (N - n) >= 2) {\n        explore(n, z - 1, o); //delete from pool\n        explore(n, z, o - 1); //delete from pool\n    }\n    if(n == N) {\n        return;\n    }\n    if(V[n] == 0) {\n        explore(n + 1, z + 1, o - 1); //delete from pool and add from vector\n    } else {\n        explore(n + 1, z - 1, o + 1); //delete from pool and add from vector\n    }\n    if(n + 2 <= N) {\n        if(V[n] == 0 or V[n + 1] == 0) {\n            explore(n + 2, z + 1, o); //delete and add from vector\n        }\n        if(V[n] == 1 or V[n + 1] == 1) {\n            explore(n + 2, z, o + 1); //delete and add from vector\n        }\n    }\n}\n\nconst LL MOD = 998244353;\nLL dp[310][310][310];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    string S;\n    cin >> S;\n    for(char c : S) {\n        if(c == '0') {\n            V.push_back(0);\n        } else {\n            V.push_back(1);\n        }\n    }\n    N = S.length();\n    for(int n = N - 1; n >= 0; --n) {\n        suff_ones[n] = suff_ones[n + 1] + V[n];\n        suff_zeroes[n] = suff_zeroes[n + 1] + 1 - V[n];\n    }\n    memset(shortest_suff, -1, sizeof(shortest_suff));\n    explore(0, 0, 0);\n    \n    for(int n = N; n >= 0; --n) {\n        for(int z = 0; z <= N; ++z) {\n            for(int o = 0; o <= N; ++o) {\n                if(n == N) {\n                    if(z == 0 or o == 0) {\n                        dp[N][z][o] = 1;\n                    } else {\n                        dp[N][z][o] = (dp[N][z - 1][o] + dp[N][z][o - 1]) % MOD;\n                    }\n                    continue;\n                }\n                if(V[n] == 0) {\n                    dp[n][z][o] = (((z > 0) ? (dp[n + 1][z - 1][o]) : (0)) + ((o > 0) ? (dp[n][z][o - 1]) : (0))) % MOD;\n                } else {\n                    dp[n][z][o] = (((z > 0) ? (dp[n][z - 1][o]) : (0)) + ((o > 0) ? (dp[n + 1][z][o - 1]) : (0))) % MOD;\n                }\n            }\n        }\n    }\n    \n    LL ans = 0;\n    for(int z = 0; z <= N; ++z) {\n        for(int o = 0; o <= N; ++o) {\n            if(shortest_suff[z][o] >= 0) {\n                ans = (ans + dp[shortest_suff[z][o]][z][o]) % MOD;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    \n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 305, mod = 998244353;\n\nint n;\nint f[maxN + 1][maxN + 1][maxN + 1], g[maxN + 1][maxN + 1][maxN + 1];\nbool res[maxN + 1][maxN + 1][maxN + 1];\nchar s[maxN + 1];\n\ninline void chkmx(int &x, int y) { x = x > y ? x : y; }\n\ninline void update(int &x, int y) { x = x + y >= mod ? x + y - mod : x + y; }\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\n\tf[n][0][0] = 1;\n\tfor(int i = n; i >= 1; i--)\n\t\tfor(int j = 0; j <= n; j++)\n\t\t\tfor(int k = 0; k <= n - j; k++)\n\t\t\t{\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tint t = f[i][j][k];\n\t\t\t\tupdate(f[i - 1][j][k], t);\n\t\t\t\tif(s[i] == '0') update(f[i][j][k + 1], t);\n\t\t\t\telse update(f[i][j + 1][k], t);\n\t\t\t}\n\t\n\tmemset(g, -1, sizeof(g));\n\tg[0][0][0] = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j <= i / 2; j++)\n\t\t\tfor(int k = 0; k <= i / 2 - j; k++)\n\t\t\t{\n\t\t\t\tif(g[i][j][k] == -1) continue;\n\t\t\t\tint t = g[i][j][k];\n\t\t\t\tif(s[i + 1] == '0' && t) chkmx(g[i + 1][j + 1][k], t - 1);\n\t\t\t\tif(s[i + 1] == '1' && t) chkmx(g[i + 1][j][k + 1], t - 1);\n\t\t\t\tif(i + 2 <= n)\n\t\t\t\t{\n\t\t\t\t\tif(s[i + 1] == '0' || s[i + 2] == '0') chkmx(g[i + 2][j + 1][k], t);\n\t\t\t\t\tif(s[i + 1] == '1' || s[i + 2] == '1') chkmx(g[i + 2][j][k + 1], t);\n\t\t\t\t\tchkmx(g[i + 2][j][k], t + 1);\n\t\t\t\t}\n\t\t\t}\n\t\n\tint ans = mod - 1;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = n; j >= 0; j--)\n\t\t\tfor(int k = n - j; k >= 0; k--)\n\t\t\t{\n\t\t\t\tres[i][j][k] = (g[i][j][k] != -1);\n\t\t\t\tif(i) res[i][j][k] |= res[i - 1][j][k];\n\t\t\t\tres[i][j][k] |= (res[i][j + 1][k] | res[i][j][k + 1]);\n\t\t\t\tif(res[i][j][k]) update(ans, f[i][j][k]);\n\t\t\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t/*\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];*/\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t/*\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];*/\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string s;\n    cin>>s;\n    int n = sz(s);\n    const ll MOD=998244353;\n    vector<vector<vector<ll>>> dp(n+1,vector<vector<ll>>(n+1,vector<ll>(n+1)));\n    dp[0][0][0]=1;\n    rep(i,0,n+1) rep(j,0,n+1) {\n        if(i>0) dp[0][i][j]=dp[0][i-1][j];\n        if(j>0) dp[0][i][j]=(dp[0][i][j]+dp[0][i][j-1])%MOD;\n    }\n    rep(i,1,n+1) {\n        dp[i]=dp[i-1];\n        if(s[n-i]=='0') {\n            rep(j,0,n+1) {\n                ll acc = 0;\n                rep(k,0,n+1) {\n                    dp[i][j][k]=(dp[i][j][k]+acc)%MOD;\n                    acc=(acc+dp[i-1][j][k])%MOD;\n                }\n            }\n        }\n        else {\n            rep(k,0,n+1) {\n                ll acc = 0;\n                rep(j,0,n+1) {\n                    dp[i][j][k]=(dp[i][j][k]+acc)%MOD;\n                    acc=(acc+dp[i-1][j][k])%MOD;\n                }\n            }\n        }\n    }\n    // rep(i,0,n+1) {\n    //     rep(j,0,n+1) {\n    //         cerr<<dp[n][i][j]<<\" \";\n    //     }\n    //     cerr<<endl;\n    // }\n    vector<vector<vector<bool>>> pos(n+1,vector<vector<bool>>(n+1,vector<bool>(n+1)));\n    pos[0][0][0]=true;\n    ll ans = 1;\n    rep(i,1,n+1) {\n        if(i-1>=0) {\n            rep(j,0,n+1) rep(k,0,n+1) if(pos[i-1][j][k]) {\n                if(j+k>0) pos[i][j][k] = true;\n                if(s[i-1]=='0' && j<n && k>0) pos[i][j+1][k-1]=true;\n                if(s[i-1]=='1' && k<n && j>0) pos[i][j-1][k+1]=true;\n            }\n        }\n        if(i-2>=0) {\n            rep(j,0,n+1) rep(k,0,n+1) if(pos[i-2][j][k]) {\n                if(s[i-2]=='0') pos[i][j+1][k]=true;\n                else pos[i][j][k+1]=true;\n                \n                if(s[i-1]=='0') pos[i][j+1][k]=true;\n                else pos[i][j][k+1]=true;\n            }\n        }\n        for(int j=n;j>=0;--j) for(int k=n;k>=0;--k) if(pos[i][j][k] && j+k>=2) {\n                    if(j>0) pos[i][j-1][k]=true;\n                    if(k>0) pos[i][j][k-1]=true;\n                }\n    }\n    vector<vector<vector<bool>>> mark(n+1,vector<vector<bool>>(n+1,vector<bool>(n+1)));\n    for(int i=n;i>0;--i) {\n        rep(j,0,n+1) rep(k,0,n+1) if(mark[i][j][k] || pos[i][j][k]) {\n            if(s[i-1]=='0' && j>0) mark[i-1][j-1][k] = true;\n            if(s[i-1]=='1' && k>0) mark[i-1][j][k-1] = true;\n        }\n    }\n    rep(i,1,n+1) {\n        rep(j,0,n+1) rep(k,0,n+1) if(pos[i][j][k] && !mark[i][j][k]) {\n            //cerr<<n-i<<\" \"<<j<<\" \"<<k<<endl;\n            ans=(ans+dp[n-i][j][k])%MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n\n#include <istream>\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nnamespace asl\n{\n    \n    template <typename T>\n    std::vector<std::vector<std::vector<T>>> board3(int n = 0, int m = 0, int k = 0)\n    {\n        return std::vector<std::vector<std::vector<T>>>(n, std::vector<std::vector<T>>(m, std::vector<T>(k)));\n    }\n\n} \n\nnamespace asl\n{\n    \n    const int m1000000007 = 1000000007;\n    \n    const int m998244353 = 998244353;\n\n    int MOD = m1000000007;\n\n    void set_mod(int mod)\n    {\n        MOD = mod;\n    }\n\n    class Mint\n    {\n    public:\n        int val;\n\n        Mint(long long v = 0)\n        {\n            if (v >= 0)\n            {\n                if (v < MOD)\n                    val = v;\n                else\n                    val = v % MOD;\n            }\n            else\n            {\n                if (v >= -MOD)\n                {\n                    val = v + MOD;\n                }\n                else\n                {\n                    v %= MOD;\n                    if (v < 0)\n                        v += MOD;\n                    val = v;\n                }\n            }\n        }\n\n        Mint &operator+=(const Mint &other)\n        {\n            val += other.val;\n            if (val >= MOD)\n                val -= MOD;\n            return *this;\n        }\n\n        friend std::ostream &operator<<(std::ostream &stream, const Mint &m)\n        {\n            return stream << m.val;\n        }\n\n    };\n} \n\n#include <random>\n\n#define endl '\\n'\n\nusing namespace std;\nusing namespace asl;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    set_mod(m998244353);\n\n    string s;\n    cin >> s;\n\n    int l = s.length();\n\n    int digit_count[2] = {0, 0};\n    for (auto x : s)\n    {\n        digit_count[x - '0']++;\n    }\n\n    auto dp = board3<Mint>(digit_count[0] + 1, digit_count[1] + 1, l + 1);\n    dp[0][0][0] = 1;\n\n    reverse(s.begin(), s.end());\n\n    for (int z = 0; z <= digit_count[0]; ++z)\n    {\n        for (int o = 0; o <= digit_count[1]; ++o)\n        {\n            for (int i = 0; i <= l; ++i)\n            {\n                if (i && s[i - 1] == '0')\n                    dp[z][o][i] += dp[z][o][i - 1];\n                else if (z)\n                    dp[z][o][i] += dp[z - 1][o][i];\n\n                if (i && s[i - 1] == '1')\n                    dp[z][o][i] += dp[z][o][i - 1];\n                else if (o)\n                    dp[z][o][i] += dp[z][o - 1][i];\n            }\n        }\n    }\n\n    reverse(s.begin(), s.end());\n\n    Mint ans;\n\n    auto reach = board3<bool>(digit_count[0] + 1, digit_count[1] + 1, l + 1);\n    reach[0][0][0] = true;\n\n    for (int i = 0; i <= l; ++i)\n        for (int z = digit_count[0]; z >= 0; --z)\n            for (int o = digit_count[1]; o >= 0; --o)\n            {\n                if (!reach[z][o][i])\n                    continue;\n\n                if (z + o > 1)\n                {\n                    if (z)\n                        reach[z - 1][o][i] = true;\n\n                    if (o)\n                        reach[z][o - 1][i] = true;\n                }\n\n                if (i < l)\n                {\n                    if (z || o)\n                        reach[z][o][i + 1] = true;\n\n                    if (s[i] == '0' && o)\n                        reach[z + 1][o - 1][i + 1] = true;\n\n                    if (s[i] == '1' && z)\n                        reach[z - 1][o + 1][i + 1] = true;\n                }\n\n                if (i + 1 < l)\n                {\n                    if (s[i] == '0' && s[i + 1] == '0')\n                        reach[z + 1][o][i + 2] = true;\n\n                    if (s[i] == '1' && s[i + 1] == '1')\n                        reach[z][o + 1][i + 2] = true;\n\n                    if (s[i] != s[i + 1])\n                    {\n                        reach[z + 1][o][i + 2] = true;\n                        reach[z][o + 1][i + 2] = true;\n                    }\n                }\n            }\n\n    for (int i = 0; i <= l; ++i)\n        for (int z = digit_count[0]; z >= 0; --z)\n            for (int o = digit_count[1]; o >= 0; --o)\n            {\n                if (!reach[z][o][i])\n                    continue;\n\n                if (i < l)\n                {\n                    if (s[i] == '0' && z + 1 <= digit_count[0])\n                        if (reach[z + 1][o][i + 1])\n                            continue;\n\n                    if (s[i] == '1' && o + 1 <= digit_count[1])\n                        if (reach[z][o + 1][i + 1])\n                            continue;\n                }\n\n                ans += dp[z][o][l - i];\n            }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint main(){\n    string str;\n    cin >> str;\n    int N = str.size();\n    vector<int> S(N);\n    for(int i=0; i<N; i++) S[i] = str[i] - '0';\n\n    static int64_t dp[310][310][310];\n    dp[N][0][0] = 1;\n    for(int i=N; i>0; i--) for(int j=0; j<N; j++) for(int k=0; k<N; k++){\n        int64_t v = dp[i][j][k];\n        if(S[i-1]){\n            add(dp[i][j+1][k], v);\n            add(dp[i-1][j][k], v);\n        }else{\n            add(dp[i][j][k+1], v);\n            add(dp[i-1][j][k], v);\n        }\n    }\n\n    static bool can[310][310][310];\n    can[0][0][0] = true;\n\n    int64_t ans = 0;\n    for(int i=0; i<=N; i++) for(int j=0; j<N; j++) for(int k=0; k<N; k++) if(can[i][j][k]){\n        //cerr<<i<<j<<k<<\" \"<<dp[i][j][k]<<endl;\n        add(ans, dp[i][j][k]);\n        can[i+1][j][k] = true;\n        if(i<N-1){\n            if(S[i] || S[i+1]) can[i+2][j][k+1] = true;\n            if(!S[i] || !S[i+1]) can[i+2][j+1][k] = true;\n        }\n        if(i<N && j && S[i]) can[i+1][j-1][k+1] = true;\n        if(i<N && k && !S[i]) can[i+1][j+1][k-1] = true;\n    }\n    add(ans, MOD-1);\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=998244353;\nint add(int x,int y){x+=y;return x>=mod?x-mod:x;}\nint sub(int x,int y){x-=y;return x<0?x+mod:x;}\nint mul(int x,int y){return (ll)x*y%mod;}\nvoid ckadd(int&x,int y){x=add(x,y);}\nvoid cksub(int&x,int y){x=sub(x,y);}\nvoid ckmul(int&x,int y){x=mul(x,y);}\nconst int N=305;\nbool ok[N][N][N];\nint dp[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tok[0][0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=n;~j;j--){\n\t\t\tfor(int k=n;~k;k--){\n\t\t\t\tif(!ok[i][j][k])continue;\n\t\t\t\tif(j+k>=2&&j)ok[i][j-1][k]=1;\n\t\t\t\tif(j+k>=2&&k)ok[i][j][k-1]=1;\n\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1')ok[i+2][j][k+1]=1;\n\t\t\t\tif(s[i+1]!='1'||s[i+2]!='1')ok[i+2][j+1][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&k)ok[i+1][j][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&j)ok[i+1][j-1][k+1]=1;\n\t\t\t\tif(s[i+1]!='1'&&k)ok[i+1][j+1][k-1]=1;\n\t\t\t\tif(s[i+1]!='1'&&j)ok[i+1][j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tdp[n+1][0][0]=1;\n\tfor(int i=n+1;i>=1;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(ok[i-1][j][k]||ok[i][j+(s[i]!='1')][k+(s[i]=='1')])ckadd(ans,dp[i][j][k]);\n\t\t\t\tckadd(dp[i-1][j][k],dp[i][j][k]);\n\t\t\t\tif(s[i-1]=='1')ckadd(dp[i][j+1][k],dp[i][j][k]);\n\t\t\t\telse ckadd(dp[i][j][k+1],dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%i\\n\",sub(ans,1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int N=310,mod=998244353;\nint n,f[N][N][N],g[N][N][N],C[N*2][N*2];\nchar s[N];\nvoid add(int &x,int y){x+=y;x>=mod?x-=mod:0;}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\"%s\",s);n=strlen(s);\n\tg[n][0][0]=1;\n\tfor(int i=0;i<=n;i++)C[i][0]=1;\n\tfor(int i=1;i<=n*2;i++)for(int j=1;j<=i;j++)C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)g[n][i][j]=C[i+j][i];\n\tfor(int i=n-1;~i;i--)for(int j=0;j<=i;j++)for(int k=0;k<=i;k++){\n\t\tg[i][j][k]=g[i+1][j][k];\n\t\tif(s[i]=='0'&&k)add(g[i][j][k],g[i][j][k-1]);\n\t\tif(s[i]=='1'&&j)add(g[i][j][k],g[i][j-1][k]);\n\t}\n\tf[0][0][0]=1;\n\tfor(int i=0;i<=n;i++)for(int j=i;~j;j--)for(int k=i;~k;k--){\n\t\tif(j&&j+k>=2)f[i][j-1][k]|=f[i][j][k];\n\t\tif(k&&j+k>=2)f[i][j][k-1]|=f[i][j][k];\n\t\tif(i<n){if(j&&s[i]=='1')f[i+1][j-1][k+1]|=f[i][j][k];\n\t\t\tif(k&&s[i]=='0')f[i+1][j+1][k-1]|=f[i][j][k];\n\t\t\tif(j+k)f[i+1][j][k]|=f[i][j][k];\n\t\t}\n\t\tif(i+2<=n){\n\t\t\tif(s[i]=='0'||s[i+1]=='0') f[i+2][j+1][k]|=f[i][j][k];\n\t\t\tif(s[i]=='1'||s[i+1]=='1') f[i+2][j][k+1]|=f[i][j][k];\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=n;~i;i--)\n\t\tfor(int j=i;~j;j--) {\n\t\t\tfor(int k=i;~k;k--) {\n//\t\t\t\tprintf(\"%d %d %d : %d %d\\n\", i, j, k, f[i][j][k], dp[i][j][k]);\n\t\t\t\tif( !f[i][j][k] ) continue;\n\t\t\t\tadd(ans,g[i][j][k]);\n\t\t\t\tint cnt[2] = {};\n\t\t\t\tfor(int l=i-1;l>=0;l--) {\n\t\t\t\t\tcnt[s[l]-'0']++;if(j<cnt[0]||k<cnt[1])break;\n\t\t\t\t\tf[l][j-cnt[0]][k-cnt[1]]=0;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\ninline void _add(int &a,int b)\n{\n    if((a+=b)>=mod)a-=mod;\n}\ninline int add(int a,int b)\n{\n    if((a+=b)>=mod)a-=mod;\n    return a;\n}\ninline int dec(int a,int b)\n{\n    if((a-=b)<0)a+=mod;\n    return a;\n}\ninline int mult(int a,int b)\n{\n    ll t=(ll)a*b;\n    if(t>=mod)t%=mod;\n    return t;\n}\ninline int power(int a,int b)\n{\n    int out=1;\n    while(b)\n    {\n        if(b&1)out=mult(out,a);\n        a=mult(a,a);\n        b>>=1;\n    }\n    return out;\n}\nchar s[310];\nbool f[310][310][310],g[310][310][310];\nint n,ss[310][310][310];\nvoid trans(int i,int j,int k,int c1,int c2)\n{\n    f[i+1][j+(c1==0)][k+(c1==1)]=1;\n    f[i+1][j+(c2==0)][k+(c2==1)]=1;\n}\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    f[0][0][0]=1;\n    for(int i=0;i<n-1;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;j+k<=i;k++)\n            {\n                int pos=i+j+k+1;\n                if(pos>n+1)continue;\n                if(!f[i][j][k])continue;\n                if(pos<=n-1)\n                {\n                    trans(i,j,k,s[pos]-'0',s[pos+1]-'0');\n                }\n                if(pos<=n)\n                {\n                    if(j)\n                    {\n                        trans(i,j-1,k,s[pos]-'0',0);\n                    }\n                    if(k)\n                    {\n                        trans(i,j,k-1,s[pos]-'0',1);\n                    }\n                }\n                if(j>=2)trans(i,j-2,k,0,0);\n                if(j&&k)trans(i,j-1,k-1,0,1);\n                if(k>=2)trans(i,j,k-2,1,1);\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;j+k<=i;k++)\n            {\n                int pos=i+j+k+1;\n                if(pos>n+1)continue;\n                g[pos][j][k]=f[i][j][k];\n            }\n        }\n    }\n    for(int i=n+1;i>=2;i--)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            for(int k=0;k<=n;k++)\n            {\n                int c=s[i-1]-'0';\n                if(!c)\n                {\n                    if(j)g[i-1][j-1][k]|=g[i][j][k];\n                }\n                else\n                {\n                    if(k)g[i-1][j][k-1]|=g[i][j][k];\n                }\n            }\n        }\n    }\n    int res=0;\n    ss[n+1][0][0]=1;\n    for(int sum=n+1;sum>=1;sum--)\n    {\n        for(int len=sum;len<=n+1;len++)\n        {\n            int up=len-sum;\n            for(int j=0;j<=up;j++)\n            {\n                int k=up-j;\n                if(s[len-1]=='0')\n                {\n                    _add(ss[len-1][j][k],ss[len][j][k]);\n                    _add(ss[len][j][k+1],ss[len][j][k]);\n                }\n                else\n                {\n                    _add(ss[len][j+1][k],ss[len][j][k]);\n                    _add(ss[len-1][j][k],ss[len][j][k]);\n                }    \n            }\n        }\n    }\n    // for(int i=n+1;i>=1;i--)\n    // {\n    //     for(int j=0;j<=n;j++)\n    //     {\n    //         for(int k=0;k<=n;k++)cerr<<ss[i][j][k]<<' ';\n    //         cerr<<'\\n';\n    //     }\n    //     cerr<<'\\n';\n    // }\n    for(int i=1;i<=n+1;i++)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            for(int k=0;k<=n;k++)\n            {\n                if(g[i][j][k])res=add(res,ss[i][j][k]);\n            }\n        }\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifndef LOCAL\n#define endl '\\n'\n#endif\n\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define rf(i, a, b) for(int i = a; i >= b; i--)\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define sz(x) (int)x.size()\n#define lb lower_bound\n#define ub upper_bound\n\ntypedef long long ll;\ntypedef long double f80;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint pct(int x) { return __builtin_popcount(x); }\nint pct(ll x) { return __builtin_popcountll(x); }\nint bt(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\nint bt(ll x) { return 63 - __builtin_clzll(x); } // floor(log2(x))\nint cdiv(int a, int b) { return a / b + !(a < 0 || a % b == 0); }\nll cdiv(ll a, ll b) { return a / b + !(a < 0 || a % b == 0); }\nint nxt_C(int x) { int c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\nll nxt_C(ll x) { ll c = x & -x, r = x + c; return (((r ^ x) >> 2) / c) | r; }\n\nvector<int> get_bits(int mask) {\n\tvector<int> bb;\n\twhile(mask) { int b = bt(mask); bb.pb(b); mask ^= (1 << b); }\n\treverse(all(bb));\n\treturn bb;\n}\n\nint get_mask(vector<int> v) {\n\tint mask = 0;\n\tfor(int x : v) { mask ^= (1 << x); }\n\treturn mask;\n}\n\ntemplate<typename T>\nvoid uniq(vector<T> &v) { sort(all(v)); v.resize(unique(all(v)) - v.begin()); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nll rand(ll l, ll r){\n\tuniform_int_distribution<ll> uid(l, r);\n\treturn uid(rng);\n}\n\nvoid sc() {}\n\ntemplate <typename Head, typename... Tail>\nvoid sc(Head &H, Tail &... T) { cin >> H; sc(T...); }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[L:\" << __LINE__ << \"][\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// #ifndef LOCAL\n// string to_string(__int128 x) {\n// \tstring s = \"\";\n// \tbool neg = 0;\n// \tif(x < 0) { s += \"-\"; neg = 1; x = -x; }\n// \tif(!x) s += '0';\n// \twhile(x) {\n// \t\tint rem = x % 10;\n// \t\ts += to_string(rem);\n// \t\tx /= 10;\n// \t}\n// \treverse(s.begin() + neg, s.end());\n// \treturn s;\n// }\n// #endif\n\nconst int mod = 1e9 + 7; // 998244353;\n\nint pwr(int a,ll b) {\n\tint ans = 1;\n\twhile(b) {\n\t\tif(b & 1) ans = (ans * 1LL * a) % mod;\n\t\ta = (a * 1LL * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\n/*\n\tLookout for overflows!!\n\tCheck array sizes!!\n\tClear before test cases!!\n\tUse the correct modulo!!\n\tCheck for corner cases!!\n\tAre you forgetting something?!\n\tRead problem statement carefully!!!\n*/\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n \n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n \n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n \n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n \n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n \n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n \n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n \n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n \n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n \n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n \n private:\n  Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n \ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n \ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n \ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n \ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n \ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n \ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n \ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n \n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint pwr(Mint a, ll k) {\n\tMint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = ans * a;\n\t\ta = a * a;\n\t\tk >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int N = 305;\nchar s[N];\n\nbool dp[N][N][N];\nMint dp1[N][N][N];\n\nvoid go(string s, int tot) {\n    int m = tot;\n    fr(i, 0, tot) {\n        fr(j, 0, sz(s)) {\n            fr(k, 0, m) {\n                dp1[i][j][k] = 0;\n            }\n        }\n    }\n    dp1[0][0][0] = 1;\n    fr(i, 0, tot - 1) {\n        fr(j, 0, sz(s)) {\n            fr(k, 0, m) {\n                if(!dp1[i][j][k]) continue;\n                if(k < m) {\n                    int jj = j;\n                    if(jj < sz(s) && s[jj] == '0')\n                        jj++;\n                    dp1[i + 1][jj][k + 1] += dp1[i][j][k];\n                }\n                if(m - k > 0) {\n                    int jj = j;\n                    if(jj < sz(s) && s[jj] == '1') jj++;\n                    dp1[i + 1][jj][k] += dp1[i][j][k];\n                }\n            }\n        }\n    }\n}\n\nint suf_z[N], suf_o[N];\n\nvoid solve() {\n    scanf(\"%s\", s + 1);\n    dp[0][0][0] = 1;\n    int n = strlen(s + 1);\n    fr(i, 0, n) {\n        rf(j, n, 0) {\n            rf(k, n, 0) {\n                if(!dp[i][j][k]) continue;\n                if(j && k) { // inserted 01 or 10\n                    dp[i][j - 1][k] = 1;\n                    dp[i][j][k - 1] = 1;\n                }\n                if(j >= 2) { // inserted 00\n                    dp[i][j - 1][k] = 1;\n                }\n                if(k >= 2) { // inserted 11\n                    dp[i][j][k - 1] = 1;\n                }\n                if(i + 2 <= n) { // no insert\n                    int jj = (s[i + 2] == '0') + (s[i + 1] == '0');\n                    int kk = (s[i + 2] == '1') + (s[i + 1] == '1');\n                    if(jj) { // remove 0\n                        dp[i + 2][j + jj - 1][k + kk] = 1;\n                    }\n                    if(kk) { // remove 1\n                        dp[i + 2][j + jj][k + kk - 1] = 1;\n                    }\n                }\n                if(i < n && j + k > 0) { // insert 0 or 1\n                    int jj = j + (s[i + 1] == '0');\n                    int kk = k + (s[i + 1] == '1');\n                    if(jj) {\n                        dp[i + 1][jj - 1][kk] = 1;\n                    }\n                    if(kk) {\n                        dp[i + 1][jj][kk - 1] = 1;\n                    }\n                }\n            }\n        }\n    }\n    Mint ans = 0;\n    rf(i, n, 1) {\n        suf_z[i] = suf_z[i + 1] + (s[i] == '0');\n        suf_o[i] = suf_o[i + 1] + (s[i] == '1');\n    }\n    string ss = \"\";\n    rf(i, n, 1) ss += s[i];\n    go(ss, n);\n    fr(l, 1, n) {\n        fr(j, 0, l) {\n            int k = l - j;\n            int maxi = -1;\n            fr(i, 0, n) {\n                int jj = j - suf_z[i + 1], kk = k - suf_o[i + 1];\n                if(jj >= 0 && kk >= 0 && dp[i][jj][kk]) {\n                    maxi = max(maxi, i);\n                }\n            }\n            fr(match, n - maxi, l)\n                ans += dp1[l][match][j];\n        }\n    }\n    cout << ans;\n}\n\nint main() {\n\t// ios :: sync_with_stdio(0);\n\t// cin.tie(0);\n\t// cout.tie(0);\n\tint t = 1;\n\t// cin >> t;\n\tfor(int tt = 1; tt <= t; tt++) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 300\n#define X 998244353\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,f[N+5][N+5][N+5],g[N+5][N+5][N+5];char s[N+5];\nint main()\n{\n\tRI i,j,k;scanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(f[n][0][0]=1,i=n;i;--i) for(j=n-i;~j;--j) for(k=n-i-j;~k;--k)\n\t\tInc(f[i-1][j][k],f[i][j][k]),Inc(f[i-1][j+(s[i+j+k]^48)][k+(s[i+j+k]^49)],f[i][j][k]);\n\tfor(g[1][0][0]=1,i=1;i<=n;++i) for(j=i;~j;--j) for(k=i-j;~k;--k) g[i][j][k]&&\n\t(\n\t\tg[i+1][j][k]=1,i^n&&(g[i+2][j+(s[i]^49)][k+(s[i]^48)]=g[i+2][j+(s[i+1]^49)][k+(s[i+1]^48)]=1),\n\t\tj&&(g[i+1][j-1+(s[i]^49)][k+(s[i]^48)]=1),k&&(g[i+1][j+(s[i]^49)][k-1+(s[i]^48)]=1)\n\t);\n\tRI t=0;for(i=0;i^n;++i) for(j=n-i;~j;--j) for(k=n-i-j;~k;--k) g[i+j+k+1][j][k]&&Inc(t,f[i][j][k]);\n\treturn printf(\"%d\\n\",t),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#include <array>\n#define FOR(i, n, m) for(ll i = (n); i < (ll)(m); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.length();\n    vector<vector<vector<bool>>> maked(n + 1, vector<vector<bool>>(301, vector<bool>(301, 0)));\n    maked[0][0][0] = true;\n    for(int i = 0; i < n; i++) for(int j = 300; j >= 0; j--) for(int k = 300; k >= 0; k--) {\n        maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i][j][k];\n        if(j < 300) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i + 1][j + 1][k];\n        if(k < 300) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i + 1][j][k + 1];\n        if(s[i] == '1') {\n            if(j < 300 && k > 0) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i][j + 1][k - 1];\n        } else {\n            if(j > 0 && k < 300) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i][j - 1][k + 1];\n        }\n        if(i == 0) continue;\n        if(s[i] == '1' || s[i - 1] == '1') {\n            if(k) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i - 1][j][k - 1];\n        }\n        if(s[i] == '0' || s[i - 1] == '0') {\n            if(j) maked[i + 1][j][k] = maked[i + 1][j][k] | maked[i - 1][j - 1][k];\n        }\n    }\n    mi ans = 0;\n    vector<vector<vector<mi>>> dp(n + 1, vector<vector<mi>>(301,  vector<mi>(301, 0)));\n    dp[n][0][0] = 1;\n    for(int i = n; i >= 0; i--) for(int j = 0; j <= 300; j++) for(int k = 0; k <= 300; k++) {\n        if(!maked[i][j][k]) continue;\n        if(i == 0) {\n            if(j) dp[i][j][k] += dp[i][j - 1][k];\n            if(k) dp[i][j][k] += dp[i][j][k - 1];\n        } else if(s[i - 1] == '0') {\n            if(k) dp[i][j][k] += dp[i][j][k - 1];\n        } else {\n            if(j) dp[i][j][k] += dp[i][j - 1][k];\n        }\n        if(i != n) dp[i][j][k] += dp[i + 1][j][k];\n        ans += dp[i][j][k];\n    }\n    cout << ans - 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n\n#pragma region cp_template\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\nconstexpr char eoln = '\\n';\ntemplate <class T> T ceildiv(const T &l, const T &r) {\n  return l / r + (l % r != 0 ? 1 : 0);\n}\n\n} // namespace n91\n\n#pragma endregion cp_template\n\n#include <cstdint>\n\ntemplate <std::uint_fast32_t mod> class modint {\n  using i32 = std::int_fast32_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::int_fast64_t;\n\n  static_assert(mod <= (u32(1) << 31), \"too large\");\n\npublic:\n  u32 v;\n\n  constexpr modint(const i32 x = 0) noexcept\n      : v(x < 0 ? mod - 1 - -(x + 1) % mod : x % mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    v = u64(v) * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint rhs) noexcept {\n    *this *= rhs.pow(mod - 2);\n  }\n  constexpr modint pow(u32 exp) noexcept {\n    modint self(*this), ret(1);\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        ret *= self;\n      self *= self;\n      exp /= 2;\n    }\n    return ret;\n  }\n};\n\n#include <array>\n\nnamespace n91 {\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  using mint = modint<998244353>;\n\n  const std::vector<usize> s = []() {\n    const std::string s = scan<std::string>();\n    std::vector<usize> ret;\n    for (const usize i : rep(0, s.size())) {\n      ret.push_back(s[i] == '1');\n    }\n    return ret;\n  }();\n  const usize n = s.size();\n\n  auto able = md_vec(n + 1, n + 2, n + 2, u32(0));\n  able[0][0][0] = 1;\n  for (const usize i : rep(0, n + 1)) {\n    for (const usize j : revrep(0, n + 1)) {\n      for (const usize k : revrep(0, n + 1)) {\n        const auto cu = able[i][j][k];\n        if (i + 2 <= n) {\n          able[i + 2][j + !s[i]][k + s[i]] |= cu;\n          able[i + 2][j + !s[i + 1]][k + s[i + 1]] |= cu;\n        }\n        if (i + 1 <= n) {\n          if (j + k >= 1) {\n            able[i + 1][j][k] |= cu;\n          }\n          if (j >= 1) {\n            able[i + 1][j - 1 + !s[i]][k + s[i]] |= cu;\n          }\n          if (k >= 1) {\n            able[i + 1][j + !s[i]][k - 1 + s[i]] |= cu;\n          }\n        }\n        if (k + j >= 2) {\n          if (k >= 1) {\n            able[i][j][k - 1] |= cu;\n          }\n          if (j >= 1) {\n            able[i][j - 1][k] |= cu;\n          }\n        }\n      }\n    }\n  }\n\n  for (const usize i : rep(0, n)) {\n    for (const usize j : rep(0, n + 2)) {\n      able[i][j][n + 1] = 0;\n      able[i][n + 1][j] = 0;\n    }\n  }\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        able[i][j][k] |= able[i + 1][j + !s[i]][k + s[i]];\n      }\n    }\n  }\n\n  mint ans = 0;\n\n  auto dp = md_vec(n + 2, n + 2, mint(0));\n  dp[0][0] = 1;\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        dp[j + s[i]][k + !s[i]] += dp[j][k];\n      }\n    }\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        if (able[i + 1][j][k]) {\n          ans += dp[j][k];\n        }\n      }\n    }\n\n    // auto nx = md_vec(n + 2, n + 2, mint(0));\n  }\n\n  ans += 1;\n\n  std::cout << ans.v << eoln;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod=998244353;\n#define Rint register int\n#define C(n,m) (n<m?0:1ll*fac[n]*invfac[n-m]%mod*invfac[m]%mod)\nusing namespace std;\nint T,n,m,p,k;\nbool f[310][310][310];\nint dp[310][310][310],C[610][610],ans=0;\nchar s[310];\nint main(){\n\tscanf(\"%s\",s),n=strlen(s);\n\tfor(int i=0;i<=2*n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; \n\t} \n\tfor(int j=0;j<=n;j++) for(int k=0;k<=n;k++) dp[n][j][k]=C[j+k][j];\n\tfor(int i=n-1;i>=0;i--) for(int j=0;j<=i;j++) for(int k=0;k<=i;k++){\n\t\tdp[i][j][k]=dp[i+1][j][k];\n\t\tif(s[i]=='0'&&k) dp[i][j][k]=(dp[i][j][k]+dp[i][j][k-1])%mod;\n\t\tif(s[i]=='1'&&j) dp[i][j][k]=(dp[i][j][k]+dp[i][j-1][k])%mod;\n\t}\n\tf[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tfor(int k=i;k>=0;k--){\n\t\t\t\tif(j&&j+k>=2) f[i][j-1][k]|=f[i][j][k];\n\t\t\t\tif(k&&j+k>=2) f[i][j][k-1]|=f[i][j][k];\n\t\t\t\tif(i+1<=n){\n\t\t\t\t\tif(j&&s[i]=='1') f[i+1][j-1][k+1]|=f[i][j][k];\n\t\t\t\t\tif(k&&s[i]=='0') f[i+1][j+1][k-1]|=f[i][j][k];\n\t\t\t\t\tif(j+k) f[i+1][j][k]|=f[i][j][k];\n\t\t\t\t}\n\t\t\t\tif(i+2<=n){\n\t\t\t\t\tif(s[i]=='0'||s[i+1]=='0') f[i+2][j+1][k]|=f[i][j][k];\n\t\t\t\t\tif(s[i]=='1'||s[i+1]=='1') f[i+2][j][k+1]|=f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tfor(int k=i;k>=0;k--){\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tans=(ans+dp[i][j][k])%mod;\n\t\t\t\tint cnt[2]={};\n\t\t\t\tfor(int l=i-1;l>=0;l--){\n\t\t\t\t\tcnt[s[l]-'0']++;\n\t\t\t\t\tif(j<cnt[0]||k<cnt[1]) break;\n\t\t\t\t\tf[l][j-cnt[0]][k-cnt[1]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 310;\nconst int mod = 998244353;\n\nint n;\nchar S[maxn];\nbool ok[maxn][maxn][maxn];\nint dp[maxn][maxn], ndp[maxn][maxn]; // cnt of 0 not in \"lcs\"\n\nint mo(int x) {\n\treturn (x >= mod) ? (x - mod) : x;\n}\n\nint main() {\n\tscanf(\"%s\", S+1);\n\tn = int (strlen(S + 1));\n\tok[0][0][0] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tfor (int k = 0; k <= i-j; k++) {\n\t\t\t\tif (ok[i][j][k]) {\n\t\t\t\t\t{\n\t\t\t\t\t\t// use S[i+1]\n\t\t\t\t\t\tok[i+1][j][k] = true;\n\t\t\t\t\t\tif (j && S[i+1] == '1') ok[i+1][j-1][k+1] = true;\n\t\t\t\t\t\tif (k && S[i+1] == '0') ok[i+1][j+1][k-1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 2 <= n) {\n\t\t\t\t\t\t// use S[i+1] && S[i+2]\n\t\t\t\t\t\tif (S[i+1] == '0' || S[i+2] == '0') {\n\t\t\t\t\t\t\tok[i+2][j+1][k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S[i+1] == '1' || S[i+2] == '1') {\n\t\t\t\t\t\t\tok[i+2][j][k+1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = i; j >= 0; j--) {\n\t\t\tfor (int k = i-j; k >= 0; k--) {\n\t\t\t\tif (!ok[i][j][k]) continue;\n\t\t\t\tif (j && k) ok[i][j-1][k-1] = true;\n\t\t\t\tif (j >= 2) ok[i][j-2][k] = true;\n\t\t\t\tif (k >= 2) ok[i][j][k-2] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tdp[0][0] = 1;\n\tfor (int len = 1; len <= n; len++) {\n\t\tfor (int i = 0; i <= len; i++) {\n\t\t\tfor (int j = 0; j <= len-i; j++) {\n\t\t\t\tndp[i][j] = 0;\n\t\t\t\t// from i\n\t\t\t\tif (i != n) {\n\t\t\t\t\tif (S[n - i] == '0') {\n\t\t\t\t\t\tndp[i][j] = mo(ndp[i][j] + dp[i][j]);\n\t\t\t\t\t} else if (j) {\n\t\t\t\t\t\tndp[i][j] = mo(ndp[i][j] + dp[i][j-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// from i-1\n\t\t\t\tif (i) ndp[i][j] = mo(ndp[i][j] + dp[i-1][j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= len; i++) {\n\t\t\tfor (int j = 0; j <= len-i; j++) {\n\t\t\t\tdp[i][j] = ndp[i][j];\n\t\t\t\tif (ok[n-i][j][len-i-j]) {\n\t\t\t\t\tans = mo(ans + dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n\n#pragma region cp_template\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\nconstexpr char eoln = '\\n';\ntemplate <class T> T ceildiv(const T &l, const T &r) {\n  return l / r + (l % r != 0 ? 1 : 0);\n}\n\n} // namespace n91\n\n#pragma endregion cp_template\n\n#include <cstdint>\n#include <iostream>\n\ntemplate <std::uint32_t mod> class modint {\n  using i64 = std::int64_t;\n  using u32 = std::uint32_t;\n  using u64 = std::int64_t;\n\n  static_assert(mod < (u32(1) << 31), \"mod must be less than 2**31\");\n\npublic:\n  u32 v;\n\n  constexpr modint(const i64 x = 0) noexcept\n      : v(x < 0 ? mod - 1 - -(x + 1) % mod : x % mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    v = u64(v) * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint rhs) noexcept {\n    *this *= rhs.pow(mod - 2);\n  }\n  constexpr modint pow(u32 exp) noexcept {\n    modint self(*this), ret(1);\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        ret *= self;\n      self *= self;\n      exp /= 2;\n    }\n    return ret;\n  }\n};\n\ntemplate <std::uint32_t mod>\nstd::istream &operator>>(std::istream &is, modint<mod> &rhs) {\n  std::int64_t v;\n  is >> v;\n  rhs = modint<mod>(v);\n  return is;\n}\n\ntemplate <std::uint32_t mod>\nstd::ostream &operator<<(std::ostream &os, const modint<mod> &rhs) {\n  os << rhs.v;\n  return os;\n}\n\n#include <array>\n\nnamespace n91 {\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  using mint = modint<998244353>;\n\n  const std::vector<usize> s = []() {\n    const std::string s = scan<std::string>();\n    std::vector<usize> ret;\n    for (const usize i : rep(0, s.size())) {\n      ret.push_back(s[i] == '1');\n    }\n    return ret;\n  }();\n  const usize n = s.size();\n\n  auto able = md_vec(n + 1, n + 2, n + 2, u32(0));\n  able[0][0][0] = 1;\n  for (const usize i : rep(0, n + 1)) {\n    for (const usize j : revrep(0, n + 1)) {\n      for (const usize k : revrep(0, n + 1)) {\n        const auto cu = able[i][j][k];\n        if (i + 2 <= n) {\n          able[i + 2][j + !s[i]][k + s[i]] |= cu;\n          able[i + 2][j + !s[i + 1]][k + s[i + 1]] |= cu;\n        }\n        if (i + 1 <= n) {\n          if (j + k >= 1) {\n            able[i + 1][j][k] |= cu;\n          }\n          if (j >= 1) {\n            able[i + 1][j - 1 + !s[i]][k + s[i]] |= cu;\n          }\n          if (k >= 1) {\n            able[i + 1][j + !s[i]][k - 1 + s[i]] |= cu;\n          }\n        }\n        if (k + j >= 2) {\n          if (k >= 1) {\n            able[i][j][k - 1] |= cu;\n          }\n          if (j >= 1) {\n            able[i][j - 1][k] |= cu;\n          }\n        }\n      }\n    }\n  }\n\n  for (const usize i : rep(0, n)) {\n    for (const usize j : rep(0, n + 2)) {\n      able[i][j][n + 1] = 0;\n      able[i][n + 1][j] = 0;\n    }\n  }\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        able[i][j][k] |= able[i + 1][j + !s[i]][k + s[i]];\n      }\n    }\n  }\n\n  mint ans = 0;\n\n  auto dp = md_vec(n + 2, n + 2, mint(0));\n  dp[0][0] = 1;\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        dp[j + s[i]][k + !s[i]] += dp[j][k];\n      }\n    }\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        if (able[i + 1][j][k]) {\n          ans += dp[j][k];\n        }\n      }\n    }\n\n    // auto nx = md_vec(n + 2, n + 2, mint(0));\n  }\n\n  ans += 1;\n\n  std::cout << ans << eoln;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int p=998244353;\nint n,m,i,j,k,l,ans,sz0,sz1,flag,v[303][303][303],f[303][303][303];\nchar s[303];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tf[n+1][0][0]=1;\n\tfor(i=n+1;i>=1;i--){\n\t\tfor(j=0;j<=n;j++)\n\t\t for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t\t \tif(i==1||s[i-1]!='0')(f[i][j+1][k]+=f[i][j][k])%=p;\n\t\t \tif(i==1||s[i-1]!='1')(f[i][j][k+1]+=f[i][j][k])%=p;\n\t\t \tif(i>1){\n\t\t \t\t/*if(s[i-1]=='0')(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t \t\tif(s[i-1]=='1')(f[i-1][j])*/\n\t\t \t\t(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t\t }\n\t\t }\n\t}\n\tv[0][0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t for(j=n;j>=0;j--)\n\t  for(k=n-j;k>=0;k--)if(v[i][j][k]){\n\t  \tif(j+k>=2){\n\t  \t\tif(j)v[i][j-1][k]=1;\n\t  \t\tif(k)v[i][j][k-1]=1;\n\t\t  }\n\t\tif(i<n){\n\t\t\tif(j+k>0)v[i+1][j][k]=1;\n\t\t\tif(s[i+1]=='0'){\n\t\t\t\tif(k)v[i+1][j+1][k-1]=1;\n\t\t\t}\n\t\t\tif(s[i+1]=='1'){\n\t\t\t\tif(j)v[i+1][j-1][k+1]=1;\n\t\t\t}\n\t\t}\n\t\tif(i+1<n){\n\t\t\tif(s[i+1]=='0'||s[i+2]=='0')v[i+2][j+1][k]=1;\n\t\t\tif(s[i+1]=='1'||s[i+2]=='1')v[i+2][j][k+1]=1;\n\t\t}\n\t  }\n\t  for(i=1;i<=n+1;i++)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t    \t/*printf(\"%d %d %d %d\\n\",i,j,k,f[i+1][j][k]);\n\t    \tans=(ans+f[i+1][j][k])%p;*/\n\t    \tflag=0;sz0=sz1=0;\n\t    \tfor(l=i-1;l<=n;l++){\n\t    \t\tif(v[l][j+sz0][k+sz1]){\n\t    \t\t\tflag=1;break;\n\t\t\t\t}\n\t\t\t\tif(s[l+1]=='0')sz0++;\n\t\t\t\t else sz1++;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t  ans=(ans+f[i][j][k])%p;\n\t\t\t  //printf(\"%d %d %d %d\\n\",i,j,k,f[i][j][k]);\n\t\t   }\n\t\t}\n\tprintf(\"%d\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing LL = long long;\n\ntemplate<typename T>\nostream& operator << (ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for(auto& x : v) {\n        out << x << \", \";\n    }\n    return out << \"]\";\n}\n\ntemplate<typename S, typename T>\nostream& operator << (ostream& out, const pair<S, T>& p) {\n    return out << \"{\" << p.first << \", \" << p.second << \"}\";\n}\n\nbool reachable[310][310][310];\n\nint N;\nvector<int> V;\nint suff_ones[310];\nint suff_zeroes[310];\nint shortest_suff[310][310];\n\nvoid explore(int n, int z, int o) {\n    if(z < 0 or o < 0) {\n        return;\n    }\n    if(reachable[n][z][o]) {\n        return;\n    }\n    reachable[n][z][o] = 1;\n    shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]] = max(shortest_suff[z + suff_zeroes[n]][o + suff_ones[n]], n);\n    explore(n, z - 1, o); //delete from pool\n    explore(n, z, o - 1); //delete from pool\n    if(n == N) {\n        return;\n    }\n    if(V[n] == 0) {\n        explore(n + 1, z + 1, o - 1); //delete from pool and add from vector\n    } else {\n        explore(n + 1, z - 1, o + 1); //delete from pool and add from vector\n    }\n    if(n + 2 <= N) {\n        if(V[n] == 0 or V[n + 1] == 0) {\n            explore(n + 2, z + 1, o); //delete and add from vector\n        }\n        if(V[n] == 1 or V[n + 1] == 1) {\n            explore(n + 2, z, o + 1); //delete and add from vector\n        }\n    }\n}\n\nconst LL MOD = 998244353;\nLL dp[310][310][310];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    string S;\n    cin >> S;\n    for(char c : S) {\n        if(c == '0') {\n            V.push_back(0);\n        } else {\n            V.push_back(1);\n        }\n    }\n    N = S.length();\n    for(int n = N - 1; n >= 0; --n) {\n        suff_ones[n] = suff_ones[n + 1] + V[n];\n        suff_zeroes[n] = suff_zeroes[n + 1] + 1 - V[n];\n    }\n    memset(shortest_suff, -1, sizeof(shortest_suff));\n    explore(0, 0, 0);\n    \n    for(int n = N; n >= 0; --n) {\n        for(int z = 0; z <= N; ++z) {\n            for(int o = 0; o <= N; ++o) {\n                if(n == N) {\n                    if(z == 0 or o == 0) {\n                        dp[N][z][o] = 1;\n                    } else {\n                        dp[N][z][o] = (dp[N][z - 1][o] + dp[N][z][o - 1]) % MOD;\n                    }\n                    continue;\n                }\n                if(V[n] == 0) {\n                    dp[n][z][o] = (((z > 0) ? (dp[n + 1][z - 1][o]) : (0)) + ((o > 0) ? (dp[n][z][o - 1]) : (0))) % MOD;\n                } else {\n                    dp[n][z][o] = (((z > 0) ? (dp[n][z - 1][o]) : (0)) + ((o > 0) ? (dp[n + 1][z][o - 1]) : (0))) % MOD;\n                }\n            }\n        }\n    }\n    \n    LL ans = MOD - 1;\n    for(int z = 0; z <= N; ++z) {\n        for(int o = 0; o <= N; ++o) {\n            if(shortest_suff[z][o] >= 0) {\n                ans = (ans + dp[shortest_suff[z][o]][z][o]) % MOD;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    \n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n  cerr << \"[\";\n  for (auto e : aux) cerr << e << ' ';\n  cerr << \"]\";\n  return cerr;\n}\n\nconst int maxN = 311;\nconst int mod = 998244353;\n\nint n;\nchar s[maxN];\n\nbool reachable[maxN][maxN][maxN];\nbool deny[maxN][maxN][maxN];\nint dp[maxN][maxN][maxN][2];\n\n\nvoid upd(int& dest, int sour, int coef = 1) {\n  dest += (1LL * sour * coef) % mod;\n  if (dest >= mod) dest -= mod;\n}\n\nvoid computeReachable() {\n  reachable[0][0][0] = 1;\n\n  for (int i = 0; i < n; i++) {\n    bool nextZero = s[i + 1] == '0';\n\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        if (!reachable[i][zeros][ones]) continue;\n \n        // Use next 2\n        if (i + 2 <= n) {\n          bool nextZero2 = s[i + 2] == '0';\n\n          if (nextZero == nextZero2) {\n            if (nextZero)\n              reachable[i + 2][zeros + 1][ones] = true;\n            else\n              reachable[i + 2][zeros][ones + 1] = true;\n          } else {\n            reachable[i + 2][zeros + 1][ones] = true;\n            reachable[i + 2][zeros][ones + 1] = true;\n          }\n        }\n\n        // Cut next element\n        if (ones + zeros > 0)\n          reachable[i + 1][zeros][ones] = true;\n\n        // Exchange one for zero\n        if (nextZero && ones > 0) \n          reachable[i + 1][zeros + 1][ones - 1] = true; \n\n        // Exchange zero for one\n        if (!nextZero && zeros > 0) \n          reachable[i + 1][zeros - 1][ones + 1] = true;\n      }\n    }\n  }\n}\n\nvoid computeDeny() {\n  for (int i = n; i > 0; i--) {\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        bool propagate = deny[i][zeros][ones] || reachable[i][zeros][ones];\n\n        if (s[i] == '0') {\n          if (zeros > 0)\n            deny[i - 1][zeros - 1][ones] |= propagate;\n        } else {\n          if (ones > 0)\n            deny[i - 1][zeros][ones - 1] |= propagate;\n        }\n      }\n    }\n  }\n}\n\nvoid computeDP() {\n  dp[n][0][0][0] = 1;\n\n  for (int i = n; i >= 0; i--) {\n    bool nextZero = (s[i] == '0' ? true : false);\n\n    // Use next char if possible\n    if (i > 0) {\n      for (int zeros = 0; zeros <= i; zeros++) {\n        for (int ones = 0; ones <= i; ones++) {\n          \n          // Use next char\n          upd(dp[i - 1][zeros][ones][0], dp[i][zeros][ones][0]);\n          upd(dp[i - 1][zeros][ones][0], dp[i][zeros][ones][1]);\n          \n          if (nextZero) {\n            // add virtual one\n            upd(dp[i][zeros][ones + 1][1], dp[i][zeros][ones][0]);\n            upd(dp[i][zeros][ones + 1][1], dp[i][zeros][ones][1]);\n          } else {\n            // add virtual zero\n            upd(dp[i][zeros + 1][ones][1], dp[i][zeros][ones][0]);\n            upd(dp[i][zeros + 1][ones][1], dp[i][zeros][ones][1]);\n          } \n        }\n      }\n    }\n\n    // Add virtual head\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        upd(dp[i][zeros + 1][ones][0], dp[i][zeros][ones][0]);\n        upd(dp[i][zeros][ones + 1][0], dp[i][zeros][ones][0]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  //freopen(\"test.in\", \"r\", stdin);\n\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n\n  cerr << \"Start computing..\\n\";\n  computeReachable();\n  cerr << \"Computed reachable..\\n\";\n  computeDeny();\n  cerr << \"Computed deny..\\n\";\n  computeDP();\n  cerr << \"Computed dp..\\n\";\n\n  if (false)\n  for (int i = 0; i <= n; i++) {\n    cerr << \"For \" << i << '\\n';\n    for (int zeros = 0; zeros <= i; zeros++) {\n      for (int ones = 0; ones <= i; ones++) {\n        cerr << '(' << reachable[i][zeros][ones] << \n                \", \" << deny[i][zeros][ones] <<\n                \", \" << dp[i][zeros][ones][0] << \") \";\n      }\n      cerr << '\\n';\n    }\n  }\n\n  int answer = 0;\n  for (int i = 0; i <= n; i++) \n    for (int zeros = 0; zeros <= i; zeros++)\n      for (int ones = 0; ones <= i; ones++)\n        if (reachable[i][zeros][ones])\n          if (!deny[i][zeros][ones])\n            upd(answer, dp[i][zeros][ones][0]);\n\n  cout << answer;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 998244353;\ninline int pls( int a , int b ) { a += b - mod; return a + ( a >> 31 & mod ); }\ninline int mns( int a , int b ) { a -= b; return a + ( a >> 31 & mod ); }\ninline void inc( int & a , int b ) { a += b - mod; a += a >> 31 & mod; }\ninline void dec( int & a , int b ) { a -= b; a += a >> 31 & mod; }\ninline int fpow( int base , int k ) {\n  int res = 1;\n  while( k ) {\n    if( k & 1 ) res = (long long)res * base % mod;\n    base = (long long)base * base % mod; k >>= 1;\n  }\n  return res;\n} int _w;\n\nconst int N = 3e2 + 5;\n\nchar str[N];\nbool g[N][N][N];\nint f[N][N][N] , n;\n\nint main( void ) {\n  _w = scanf(\"%s\",str+1); \n  n = strlen( str + 1 );\n  f[n + 1][0][0] = 1;\n  for( int i = n ; i ; --i )\n    for( int j = 0 ; j <= n - i ; ++j )\n      for( int k = 0 ; j + k <= n - i ; ++k ) {\n        inc( f[i][j][k] , f[i + 1][j][k] );\n        if( str[i + j + k] == '0' ) \n          inc( f[i][j + 1][k] , f[i + 1][j][k] );\n        else inc( f[i][j][k + 1] , f[i + 1][j][k] );\n      }\n  g[0][0][0] = 1;\n  for( int i = 1 ; i <= n ; ++i ) {\n    for( int j = 0 ; j <= i ; ++j )\n      for( int k = 0 , a , b ; j + k <= i ; ++k ) {\n        g[i][j][k] |= g[i - 1][j][k];\n        if( i > 1 ) {\n          a = str[i - 1] - '0' , b = str[i] - '0';\n          if( a || b ) g[i][j + 1][k] |= g[i - 2][j][k];\n          if( !(a&b) ) g[i][j][k + 1] |= g[i - 2][j][k];\n        }\n        if( str[i] == '1' )\n          g[i][j + 1][k] |= g[i - 1][j][k + 1];\n        else\n          g[i][j][k + 1] |= g[i - 1][j + 1][k];\n      }\n  }\n  int ans = 0;\n  for( int i = 0 ; i <= n ; ++i )\n    for( int j = 0 ; j <= i ; ++j )\n      for( int k = 0 ; k + j <= i ; ++k )\n        if( g[i][j][k] )\n          inc( ans , f[i + 1 - j - k][j][k] );\n  dec( ans , 1 );\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nll dp[333][333][333], dp2[333][333][333];\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    cin>>s;\n    int n=s.size();\n    string t(s.rbegin(),s.rend());\n    dp[0][0][0]=1;\n    rep(i,n+1)rep(j,301)rep(k,301){\n        if(i==0&&j==0&&k==0)continue;\n        if(i==0){\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='0'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='1'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n        }\n    }\n    dp2[0][0][0]=1;\n    rep(i,n+1)for(int j=300;j>=0;--j)for(int k=300;k>=0;--k){\n        if(j>=2)dp2[i][j-2][k]|=dp2[i][j][k];\n        if(k>=2)dp2[i][j][k-2]|=dp2[i][j][k];\n        if(j>=1 && k>=1)dp2[i][j-1][k-1]|=dp2[i][j][k];\n        if(i<n && s[i]=='0'){\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n            if(k>0)dp2[i+1][j+1][k-1]|=dp2[i][j][k];\n        }\n        if(i<n && s[i]=='1'){\n            if(j>0)dp2[i+1][j-1][k+1]|=dp2[i][j][k];\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n        }\n        if(i+1<n){\n            if(s[i]=='0'||s[i+1]=='0')dp2[i+2][j+1][k]|=dp2[i][j][k];\n            if(s[i]=='1'||s[i+1]=='1')dp2[i+2][j][k+1]|=dp2[i][j][k];\n        }\n    }\n    ll ans=0;\n    REP(i,1,n+1){\n        int l=max(0,2*i-n);\n        rep(j,301)rep(k,301){\n            if(dp2[n-l][j][k] && j+k+l==i)ans+=dp[l][j][k];\n        }\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int mod = 998244353;\nchar s[301];\nint a[300];\nbool f[301][301][301];\nlong long dp[301][301][301];\n\nint main() {\n    int n, i, j, k;\n    long long ans = 1;\n    \n    scanf(\"%s\", s);\n    \n    n = strlen(s);\n    \n    for (i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    f[0][0][0] = true;\n    \n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (!f[i][j][k]) continue;\n                \n                if (i > 0) {\n                    f[i + 1][j][k] = true;\n                    \n                    if (a[i] == 0 && k > 0) f[i + 1][j + 1][k - 1] = true;\n                    if (a[i] == 1 && j > 0) f[i + 1][j - 1][k + 1] = true;\n                }\n                \n                if (i + 2 <= n) {\n                    if (a[i] == 0 || a[i + 1] == 0) f[i + 2][j + 1][k] = true;\n                    if (a[i] == 1 || a[i + 1] == 1) f[i + 2][j][k + 1] = true;\n                }\n            }\n        }\n    }\n    \n    for (i = 0; i <= n; i++) {\n        for (j = n - 1; j >= 0; j--) {\n            for (k = n - 1; k >= 0; k--) {\n                f[i][j][k] |= f[i][j + 1][k];\n                f[i][j][k] |= f[i][j][k + 1];\n            }\n        }\n    }\n    \n    dp[n][0][0] = 1;\n    \n    for (i = n; i >= 0; i--) {\n        for (j = 0; j < n; j++) {\n            for (k = 0; k < n; k++) {\n                if (dp[i][j][k] == 0) continue;\n                \n                if (f[i][j][k]) ans += dp[i][j][k];\n                \n                if (i == 0) continue;\n                \n                dp[i - 1][j][k] += dp[i][j][k];\n                if (dp[i - 1][j][k] >= mod) dp[i - 1][j][k] -= mod;\n                \n                if (a[i - 1] == 0) {\n                    dp[i][j][k + 1] += dp[i][j][k];\n                    if (dp[i][j][k + 1] >= mod) dp[i][j][k + 1] -= mod;\n                } else {\n                    dp[i][j + 1][k] += dp[i][j][k];\n                    if (dp[i][j + 1][k] >= mod) dp[i][j + 1][k] -= mod;\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", (ans - 1) % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k){\n\t\t\t\t\t\tcan[i+1][j+1][k+1]=true;\n\t\t\t\t\t\tif(s[i]=='1'){\n\t\t\t\t\t\t\tcan[i+1][j+1][k]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sumo[i-1]>j-k){\n\t\t\t\t\t\tcan[i+1][j+1][k]=true;\n\t\t\t\t\t\tif(s[i]=='0'){\n\t\t\t\t\t\t\tcan[i+1][j+1][k+1]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nconst int mod=998244353;\nint f[310][310][310],g[310][310][310];\nchar ss[310];\nint main()\n{\n\tre int n;\n\tscanf(\"%s\",ss+1);\n\tn=strlen(ss+1);\n\tg[0][0][0]=1;\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tfor(re int j=0;j<=n;j++)\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(ss[i]=='0'&&j)g[i][j][k]|=g[i-1][j-1][k+1];\n\t\t\t\tif(ss[i]=='1'&&k)g[i][j][k]|=g[i-1][j+1][k-1];\n\t\t\t\tg[i][j][k]|=g[i-1][j][k];\n\t\t\t\tif(i>=2)\n\t\t\t\t{\n\t\t\t\t\tif((ss[i]=='0'||ss[i-1]=='0')&&j)g[i][j][k]|=g[i-2][j-1][k];\n\t\t\t\t\tif((ss[i]=='1'||ss[i-1]=='1')&&k)g[i][j][k]|=g[i-2][j][k-1];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor(re int i=0;i<=n;i++)\n\t{\n\t\tif(ss[n]=='0')f[n][0][i]=1;\n\t\telse f[n][i][0]=1;\n\t}\n\tfor(re int i=n-1;i>=0;i--)\n\t{\n\t\tfor(re int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tf[i][j][k]=f[i+1][j][k];\n\t\t\t\tif(ss[i]=='0'&&k)f[i][j][k]=(f[i][j][k]+f[i][j][k-1])%mod;\n\t\t\t\tif(ss[i]=='1'&&j)f[i][j][k]=(f[i][j][k]+f[i][j-1][k])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tre int ans=0;\n\tfor(re int i=0;i<=n;i++)\n\t\tfor(re int j=0;j<=n;j++)\n\t\t\tfor(re int k=0;k<=n;k++)\n\t\t\tif(i!=n||j||k){\n\t\t\t\tans=(ans+g[i][j][k]*f[i][j][k])%mod;\n\t\t\t\t//if(g[i][j][k])printf(\"***%d %d %d %d %d\\n\",i,j,k,f[i][j][k],ans);\n\t\t\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\nbool dp[MAX][MAX][MAX];\nll dp2[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    int N=si(S);\n    dp[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]==0) continue;\n                \n                if(i+1<N){\n                    if(S[i]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    if(S[i+1]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    dp[i+1][j][k]=1;\n                }\n                \n                if(j&&S[i]=='1') dp[i+1][j-1][k+1]=1;\n                \n                if(k&&S[i]=='0') dp[i+1][j+1][k-1]=1;\n                \n                if(j||k) dp[i+1][j][k]=1;\n            }\n        }\n    }\n    \n    reverse(all(S));\n    \n    dp2[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(S[i]=='0'){\n                    dp2[i][j][k+1]+=dp2[i][j][k];\n                    dp2[i][j][k+1]%=mod;\n                }else{\n                    dp2[i][j+1][k]+=dp2[i][j][k];\n                    dp2[i][j+1][k]%=mod;\n                }\n                dp2[i+1][j][k]+=dp2[i][j][k];\n                dp2[i+1][j][k]%=mod;\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]){\n                    ans+=dp2[N-i][j][k];\n                    ans%=mod;\n                }\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 303;\nchar s[N];\nint n;\nbool dp1[N][N][N];\nll dp2[N][N][N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tdp1[0][0][0] = 1;\n\tfor (int len = 0; len <= n; len++)\n\t\tfor (int x = 0; x <= n; x++)\n\t\t\tfor (int y = 0; y <= n; y++) {\n\t\t\t\tif (!dp1[len][x][y]) continue;\n\t\t\t\tint xx = x, yy = y;\n\t\t\t\tint nlen = len;\n\t\t\t\tfor (int it = 0; it < 2; it++) {\n\t\t\t\t\tif (xx >= 2) dp1[nlen][xx - 1][yy] = 1;\n\t\t\t\t\tif (yy >= 2) dp1[nlen][xx][yy - 1] = 1;\n\t\t\t\t\tif (xx >= 1 && yy >= 1) {\n\t\t\t\t\t\tdp1[nlen][xx - 1][yy] = 1;\n\t\t\t\t\t\tdp1[nlen][xx][yy - 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (nlen == n) break;\n\t\t\t\t\tif (s[nlen] == '0')\n\t\t\t\t\t\txx++;\n\t\t\t\t\telse\n\t\t\t\t\t\tyy++;\n\t\t\t\t\tnlen++;\n\t\t\t\t}\n\t\t\t\tif (xx > x) dp1[nlen][xx - 1][yy] = 1;\n\t\t\t\tif (yy > y) dp1[nlen][xx][yy - 1] = 1;\n\t\t\t}\n\n\tdp2[n][0][0] = 1;\n\tfor (int x = 0; x <= n; x++)\n\t\tfor (int y = 0; y <= n; y++) {\n\t\t\tfor (int p = n; p >= 0; p--) {\n\t\t\t\tif (dp2[p][x][y] == 0) continue;\n\t\t\t\tint np = p;\n\t\t\t\tif (p > 0 && s[p - 1] == '0') np--;\n\t\t\t\tdp2[np][x + 1][y] = add(dp2[np][x + 1][y], dp2[p][x][y]);\n\t\t\t\tnp = p;\n\t\t\t\tif (p > 0 && s[p - 1] == '1') np--;\n\t\t\t\tdp2[np][x][y + 1] = add(dp2[np][x][y + 1], dp2[p][x][y]);\n\t\t\t}\n\t\t}\n\n\tll ans = 0;\n\tfor (int x = 0; x <= n; x++)\n\t\tfor (int y = 0; y <= n; y++) {\n\t\t\tif (x + y == 0) continue;\n\t\t\tif (x + y > n) break;\n\t\t\tint wx = x, wy = y;\n\t\t\tint p = n;\n\t\t\twhile(p >= 0) {\n\t\t\t\tif (dp1[p][wx][wy]) break;\n\t\t\t\tp--;\n\t\t\t\tif (p >= 0) {\n\t\t\t\t\tif (s[p] == '0')\n\t\t\t\t\t\twx = max(0, wx - 1);\n\t\t\t\t\telse\n\t\t\t\t\t\twy = max(0, wy - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= p; i++)\n\t\t\t\tans = add(ans, dp2[i][x][y]);\n\t\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=305;\nconst int mod=998244353;\nint n,s0[maxn],s1[maxn],mx[maxn][maxn];\nchar s[maxn];\nll f[maxn][maxn][maxn];\ninline void chkmax(int &a,int b) { a=(a>b)?a:b; }\nint main()\n{\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor(int i=n;i;i--) s0[i]=s0[i+1]+(s[i]=='0'),s1[i]=s1[i+1]+(s[i]=='1');\n\tf[0][0][n+1]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tfor(int k=n+1;k;k--)\n\t\t\t\tif(f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\t(f[i+1][j+1][k-((k>1)?s[k-1]=='0':0)]+=f[i][j][k])%=mod;\n\t\t\t\t\t(f[i+1][j][k-((k>1)?s[k-1]=='1':0)]+=f[i][j][k])%=mod;\n\t\t\t\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tfor(int k=1;k<=n+1;k++) (f[i][j][k]+=f[i][j][k-1])%=mod;\n\tmx[s0[1]][s1[1]]=1;\n\tll ans=0;\n\tfor(int i=s0[1];i>=0;i--)\n\t\tfor(int j=s1[1];j>=0;j--)\n\t\t{\n\t\t\tint k=mx[i][j];\n\t\t\tif(k<n)\n\t\t\t{\n\t\t\t\tif((s[k]=='0' || s[k+1]=='0') && i) chkmax(mx[i-1][j],k+2);\n\t\t\t\tif((s[k]=='1' || s[k+1]=='1') && j) chkmax(mx[i][j-1],k+2);\n\t\t\t}\n\t\t\tif(i && (k>n || i>s0[k+1])) chkmax(mx[i-1][j],min(k+1,n+1));\n\t\t\tif(j && (k>n || j>s1[k+1])) chkmax(mx[i][j-1],min(k+1,n+1));\n\t\t\tif(mx[i][j] && i+j>0) (ans+=f[i+j][i][mx[i][j]])%=mod;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n\nconst int MAX = 305;\n\nint N;\nvector<int> S;\nvector<int> suffix_counts[2];\nint latest_suffix[MAX][MAX];\nint most_extra[MAX][MAX][MAX][3];\n\nvoid recurse(int index, array<int, 2> counts, int extra, int carry) {\n    if (index >= N && carry == 1 && extra <= 0)\n        return;\n\n    if (carry != 1 || extra > 0) {\n        array<int, 2> combined = {counts[0] + suffix_counts[0][index], counts[1] + suffix_counts[1][index]};\n        latest_suffix[combined[0]][combined[1]] = max(latest_suffix[combined[0]][combined[1]], index);\n    }\n\n    if (index >= N)\n        return;\n\n    if (extra <= most_extra[index][counts[0]][counts[1]][carry + 1])\n        return;\n\n    most_extra[index][counts[0]][counts[1]][carry + 1] = extra;\n\n    if (carry == 0) {\n        // 1\n        counts[S[index]]++;\n        recurse(index + 1, counts, extra, -1);\n        counts[S[index]]--;\n\n        // 0\n        recurse(index + 1, counts, extra + 1, -1);\n    } else if (carry == 1) {\n        // 0\n        recurse(index + 1, counts, extra, -1);\n\n        if (extra > 0)\n            recurse(index, counts, extra - 1, -1);\n    } else {\n        // 1\n        counts[S[index]]++;\n        recurse(index + 1, counts, extra, 1);\n        counts[S[index]]--;\n\n        // 0\n        recurse(index + 1, counts, extra, 0);\n    }\n}\n\nmod_int dp[MAX][MAX][MAX];\n\nmod_int solve(array<int, 2> counts, int suffix) {\n    if (counts[0] + counts[1] > N || suffix < 0)\n        return 0;\n\n    mod_int &ans = dp[counts[0]][counts[1]][suffix];\n\n    if (ans.val >= 0)\n        return ans;\n\n    ans = 0;\n\n    if (suffix <= latest_suffix[counts[0]][counts[1]])\n        ans++;\n\n    int previous = suffix == 0 ? -1 : S[suffix - 1];\n    ans += solve({counts[0] + 1, counts[1]}, suffix - (previous == 0));\n    ans += solve({counts[0], counts[1] + 1}, suffix - (previous == 1));\n    return ans;\n}\n\nint main() {\n    string str;\n    cin >> str;\n    N = int(str.size());\n    S.resize(N);\n\n    for (int i = 0; i < N; i++)\n        S[i] = str[i] - '0';\n\n    for (int x = 0; x < 2; x++) {\n        suffix_counts[x].assign(N + 1, 0);\n\n        for (int i = N - 1; i >= 0; i--)\n            suffix_counts[x][i] = suffix_counts[x][i + 1] + (S[i] == x);\n    }\n\n    memset(latest_suffix, -1, sizeof(latest_suffix));\n    memset(most_extra, -1, sizeof(most_extra));\n    recurse(0, {0, 0}, 0, -1);\n\n    memset(dp, -1, sizeof(dp));\n    cout << solve({0, 0}, N) - 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t    chkmax(vis[i+1][j][k],tmp);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t/*\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];*/\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=305,mod=998244353;\nchar s[N];\nint f[N][N][N],n,ans;\nbool ok[N][N][N];\n\nsigned main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tok[0][0][0]=1;\n\tfor(int i=0;i<n;i++) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++) if(ok[i][j][k]){\n\t\tif(s[i+1]=='0'||s[i+2]=='0') ok[i+2][j+1][k]=1;\n\t\tif(s[i+1]=='1'||s[i+2]=='1') ok[i+2][j][k+1]=1;\n\t\tok[i+1][j][k]=1;\n\t\tif(s[i+1]=='1'&&j) ok[i+1][j-1][k+1]=1;\n\t\tif(s[i+1]=='0'&&k) ok[i+1][j+1][k-1]=1; \n\t}\n\tok[n][0][0]=0;\n\tf[n][0][0]=1;\n\tfor(int i=n;i;i--) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++){\n\t\t(f[i-1][j][k]+=f[i][j][k])%=mod;\n\t\tif(s[i]=='0') (f[i][j][k+1]+=f[i][j][k])%=mod;\n\t\tif(s[i]=='1') (f[i][j+1][k]+=f[i][j][k])%=mod;\n\t}\n\tfor(int i=0;i<=n;i++) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++) (ans+=ok[i][j][k]*f[i][j][k])%=mod;\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "// Amsal Shoma Ro Gaedan Ye Amal Pasandidas !\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 998244353;\nconst int N = 3e2 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll dp[N][N][N];\n\nbool b[N][N][N];\nint ans[N][N], p0[N], p1[N];\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tstr s;\n\tcin >> s;\n\tint n = s.size();\n\ts = '!' + s;\n\tint c0 = 0, c1 = 0;\n\tfor(auto c : s) c0 += (c == '0');\n\tfor(auto c : s) c1 += (c == '1');\n\tmemset(ans, -1, sizeof ans);\n\n\tfor(int i = n - 1; i >= 0; i--) p0[i] = p0[i + 1] + (s[i + 1] == '0');\n\tfor(int i = n - 1; i >= 0; i--) p1[i] = p1[i + 1] + (s[i + 1] == '1');\n\n\tb[0][0][0] = 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = n; j >= 0; j--){\n\t\t\tfor(int k = n; k >= 0; k--){\n\t\t\t\tif(!b[i][j][k]) continue;\n\t\t\t\t//cout << i << ' ' << j << ' ' << k << '\\n';\n\t\t\t\tans[c0 + j][c1 + k] = i;\n\t\t\t\tif(n - i + j + k < 2) continue;\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(j)\n\t\t\t\t\tb[i][j - 1][k] = 1;\n\t\t\t\tif(k)\n\t\t\t\t\tb[i][j][k - 1] = 1;\n\t\t\t\tif(j + k)\n\t\t\t\t\tb[i + 1][j][k] = 1;\n\t\t\t\tif(n - i >= 1){\n\t\t\t\t\tif(j)\n\t\t\t\t\t\tb[i + 1][j - 1 + (s[i + 1] == '0')][k + (s[i + 1] == '1')] = 1;\n\t\t\t\t\tif(k)\n\t\t\t\t\t\tb[i + 1][j + (s[i + 1] == '0')][k - 1 + (s[i + 1] == '1')] = 1;\t\n\t\t\t\t}\n\t\t\t\tif(n - i >= 2){\n\t\t\t\t\tb[i + 2][j + (s[i + 1] == '0')][k + (s[i + 1] == '1')] = 1;\n\t\t\t\t\tb[i + 2][j + (s[i + 2] == '0')][k + (s[i + 2] == '1')] = 1;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i < n){\n\t\t\tif(s[i + 1] == '0') c0 --;\n\t\t\telse c1 --;\n\t\t}\n\t}\n\tdp[n][0][0] = 1;\n\tfor(int i = n; i >= 0; i--){\n\t\tfor(int x = 0; x <= n; x++){\n\t\t\tfor(int y = 0; y <= n; y++){\n\t\t\t\tif(i == n){\n\t\t\t\t\tif(x) dp[i][x][y] += dp[i][x - 1][y];\n\t\t\t\t\tif(y) dp[i][x][y] += dp[i][x][y - 1];\n\t\t\t\t} else {\n\t\t\t\t\tif(s[i + 1] == '0'){\n\t\t\t\t\t\tdp[i][x][y] = dp[i + 1][x][y] + (y ? dp[i][x][y - 1] : 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][x][y] = (x ? dp[i][x - 1][y] : 0) + dp[i + 1][x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][x][y] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tif(ans[i][j] != -1){\n\t\t\t\t//cout << i << ' ' << j << ' ' << dp[ans[i][j]][i - p0[ans[i][j]]][j - p1[ans[i][j]]] << '\\n';\n\t\t\t\tres += dp[ans[i][j]][i - p0[ans[i][j]]][j - p1[ans[i][j]]];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define __iostream_untie__ true\n#include <bits/stdc++.h>\n#include <ext/rope>\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(__iostream_untie__) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n\n#ifndef modint_hpp\n#define modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\n#endif // modint_hpp\n\n#ifndef binomial_hpp\n#define binomial_hpp\n\nnamespace binomial\n{\n    constexpr int mod = //*\n                        998244353\n                        /*/\n                        1000000007\n                        /**/;\n    constexpr int size = 1 << 20;\n    using mint = modint<mod>;\n    namespace\n    {\n        namespace internal_helper\n        {\n            struct fact_impl\n            {\n                int _fact[size], _inv[size], _invfact[size];\n                fact_impl() : _fact{1}, _inv{0, 1}, _invfact{1}\n                {\n                    for(int i = 1; i < size; ++i) _fact[i] = (long long)_fact[i - 1] * i % mod;\n                    for(int i = 2; i < size; ++i) _inv[i] = mod - (long long)mod / i * _inv[mod % i] % mod;\n                    for(int i = 1; i < size; ++i) _invfact[i] = (long long)_invfact[i - 1] * _inv[i] % mod;\n                }\n            } fact_calced;\n        } // namespace internal_helper\n        mint fact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._fact[x]; }\n        mint invfact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._invfact[x]; }\n        mint inv(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._inv[x]; }\n    } // unnamed namespace\n    mint binom(int n, int k) noexcept { return fact(n) * invfact(k) * invfact(n - k); }\n    mint fallfact(int n, int k) noexcept { return fact(n) * invfact(n - k); }\n    mint risefact(int n, int k) noexcept { return fallfact(n + k - 1, k); }\n    // time complexity: O(min(n, k) * log(n))\n    mint stirling_2nd(int n, int k) noexcept\n    {\n        if(n < k) return 0;\n        mint res{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n            if(i & 1) res -= mint::pow(j, n) * invfact(j) * invfact(i);\n            else res += mint::pow(j, n) * invfact(j) * invfact(i);\n        return res;\n    };\n    // time complexity: O(min(n, k) * log(n))\n    mint bell(int n, int k) noexcept\n    {\n        if(n < k) k = n;\n        mint res{}, alt{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n        {\n            if(i & 1) alt -= invfact(i);\n            else alt += invfact(i);\n            res += alt * mint::pow(j, n) * invfact(j);\n        }\n        return res;\n    }\n    namespace internal_helper {} // namespace internal_helper\n} // namespace binomial\n\n#endif // binomial_hpp\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n        using namespace binomial;\n\n        string s; cin>>s;\n        int n=s.size();\n\n        bool dp[334][334][334]={};\n        dp[0][0][0]=1;\n\n        for(int i=0; i<n; i++)\n        {\n            if(s[i]=='0' or (i<n-1 and s[i+1]=='0'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j+1][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='1' or (i<n-1 and s[i+1]=='1'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j][k+1]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='0')\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=1; k<n; k++)\n                    {\n                        dp[i+1][j+1][k-1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=1; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+1][j-1][k+1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>0; j--)\n            {\n                for(int k=n; k>=0; k--)\n                {\n                    dp[i][j-1][k]|=dp[i][j][k];\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>=0; j--)\n            {\n                for(int k=n; k>0; k--)\n                {\n                    dp[i][j][k-1]|=dp[i][j][k];\n                }\n            }\n        }\n\n\n        vector dp2(334, vector(334, vector<mint>(334)));\n        for(int i=0; i<=n; i++)\n        {\n            dp2[n][i][0]=1;\n            dp2[n][0][i]=1;\n        }\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=1; j<=n; j++)\n            {\n                dp2[n][i][j]=dp2[n][i-1][j]+dp2[n][i][j-1];\n            }\n        }\n\n        for(int i=n-1; i>=0; i--)\n        {\n            auto &now=dp2[i];\n            now=dp2[i+1];\n            if(s[i]=='0')\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j][k+1]+=now[j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j+1][k]+=now[j][k];\n                    }\n                }\n            }\n        }\n\n\n        bool calced[666][666]={};\n        mint ans;\n\n        for(int i=n,oc=0,zc=0; i>=0; i--)\n        {\n            if(i<n)\n            {\n                if(s[i]=='0') zc++;\n                else oc++;\n            }\n            for(int j=0; j<=n; j++)\n            {\n                for(int k=0; k<=n; k++)\n                {\n                    if(dp[i][j][k] and !calced[j+zc][k+oc])\n                    {\n                        dump(i,j+zc,k+oc,dp2[i][j][k]);\n                        ans+=dp2[i][j][k];\n                        calced[j+zc][k+oc]=true;\n                    }\n                }\n            }\n        }\n\n        cout << ans-1 << \"\\n\";\n\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 311;\nconst int mod = 998244353;\ninline void add(int &x, int y) { x += y; if(x >= mod) x -= mod; }\n\nchar s[maxn];\nint n, dp[maxn][maxn][maxn];\nbool can[maxn][maxn][maxn];\n\nint main()\n{\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\t\n\tcan[0][0][0] = 1;\n\tfor(int k=0; k<n; k++)\n\t{\n\t\tfor(int i=0; i<=n; i++) for(int k0=0; k0<=n; k0++)\n\t\t{\n\t\t\tint k1 = i - k - k0;\n\t\t\tif(k1 < 0) continue;\n\t\t\tif(!can[i][k0][k1]) continue;\n\t\t\tif(k0 && k0 + k1 >= 2) can[i][k0-1][k1] = 1;\n\t\t\tif(k1 && k0 + k1 >= 2) can[i][k0][k1-1] = 1;\n\t\t\tif(i < n)\n\t\t\t{\n\t\t\t\tif(k0 || k1) can[i+1][k0][k1] = 1;\n\t\t\t\tint p = s[i] - '0';\n\t\t\t\tif(p == 0 && k1) can[i+1][k0+1][k1-1] = 1;\n\t\t\t\tif(p == 1 && k0) can[i+1][k0-1][k1+1] = 1;\n\t\t\t\tif(i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tint q = s[i+1] - '0';\n\t\t\t\t\tif(p == 0 || q == 0) can[i+2][k0+1][k1] = 1;\n\t\t\t\t\tif(p == 1 || q == 1) can[i+2][k0][k1+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[0][0][0] = 1;\n\tfor(int i=0; i<=n; i++) for(int n0=0; n0<=n; n0++) for(int n1=0; n1<=n; n1++) if(dp[i][n0][n1])\n\t{\n\t\tint pos = s[n - 1 - (i - n0 - n1)] - '0';\n\t\t\n\t\tadd(dp[i+1][n0][n1], dp[i][n0][n1]);\n\t\tif(pos == 0) add(dp[i+1][n0][n1+1], dp[i][n0][n1]);\n\t\telse add(dp[i+1][n0+1][n1], dp[i][n0][n1]);\n\t}\n\t\n\tfor(int i=n-1; i>=0; i--) for(int k0=0; k0<=n; k0++) for(int k1=0; k1<=n; k1++)\n\t{\n\t\tif(can[i+1][k0][k1])\n\t\t{\n\t\t\tint p = s[i] - '0';\n\t\t\tif(p == 0 && k0) can[i][k0-1][k1] = 1;\n\t\t\tif(p == 1 && k1) can[i][k0][k1-1] = 1;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=1; i<=n; i++) for(int j=0; j<=n; j++) for(int k=0; k<=n; k++) if(dp[i][j][k])\n\t{\n\t\tint pos = n - (i - j - k);\n\t\tif(can[pos][j][k]) add(ans, dp[i][j][k]);\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nchar s[305];\nint n=0,len,k,a[305],b[305],mod=998244353;\nlong long f[305][305][305];\nint main(){\n\t\n\tstd::cin>>s>>k;\n\tlen=strlen(s);\n\tn=1;\n\tfor (int i=0;i<len;++i) {\n\t\tif (s[i]=='0') ++n;\n\t\telse ++a[n];\n\t}\n\tfor (int i=n-1;i>=0;--i) b[i]=b[i+1]+a[i];\n\tk=std::min(b[0],k);\n\tf[0][0][0]=1;\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int c=0;c<=a[i];++c){\n\t\t\tfor (int j=c;j<=k;++j) {\n\t\t\t\tfor (int l=j;l<=k;++l) {\n\t\t\t\t\tf[i][l][j-c]=(f[i][l][j-c]+f[i-1][l][j])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int c=1;c<=k;++c){\n\t\t\tfor (int j=k-c;j>=0;--j) {\n\t\t\t\tfor (int l=0;l<=j;++l) {\n\t\t\t\t\tf[i][j+c][l+c]=(f[i][j+c][l+c]+f[i-1][j][l])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\tfor (int i=0;i<=k;++i) ans+=f[n][i][0];\n\tprintf(\"%lld\",ans%mod);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  string s;cin>>s;\n  ll n=s.size();\n  auto dp=make_v(n+1,n+1,n+1,false);\n  dp[0][0][0]=true;\n  rep(i,0,n)rep(j,0,n+1)rep(o,0,n+1){\n    if(!dp[i][j][o])continue;\n    dp[i+1][j][o]=true;\n    if(s[i]=='0')if(j<n&&o>0)dp[i+1][j+1][o-1]=true;\n    if(s[i]=='1')if(o<n&&j>0)dp[i+1][j-1][o+1]=true;\n    if(i<n-1){\n      if(s[i]=='0'||s[i+1]=='0')dp[i+2][j+1][o]=true;\n      if(s[i]=='1'||s[i+1]=='1')dp[i+2][j][o+1]=true;\n    }\n  }\n  ll now0=0,now1=0;\n  auto p=vec(n+1,2,0LL);\n  auto v=vec(n+1,n+1,-1);\n  rrep(i,0,n+1){\n    p[i][0]=now0;\n    p[i][1]=now1;\n    rep(j,0,n+1)rep(o,0,n+1){\n      if(!dp[i][j][o])continue;\n      //cout<<i spa j spa o<<endl;\n      chmax(v[j+now0][o+now1],i);\n    }\n    if(i>0){\n      if(s[i-1]=='0')now0++;\n      else now1++;\n    }\n  }\n  //debug(v,n,n);\n  auto a=make_v(n+1,n+1,n+1,modint(0));\n  rep(i,0,n+1)rep(j,0,n+1){\n    ll k=v[i][j];\n    if(v[i][j]!=-1)a[k][i-p[k][0]][j-p[k][1]]+=1;\n  }\n  rep(i,0,n+1){\n    rrep(j,0,n+1)rrep(o,0,n+1){\n      if((i==n||s[i]=='0')&&o>0)a[i][j][o-1]+=a[i][j][o];\n      if((i==n||s[i]=='1')&&j>0)a[i][j-1][o]+=a[i][j][o];\n      if(i<n)a[i+1][j][o]+=a[i][j][o];\n    }\n  }\n  cout<<a[n][0][0]-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=305;\nconst int MOD=998244353;\nint n;\nchar s[N];\nlong long dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int c0=0;c0<i;c0++)\n\t\t\tfor(int c1=0;c0+c1<i;c1++)\n\t\t\t{\n\t\t\t\tdp[i-1][c0][c1]=(dp[i-1][c0][c1]+dp[i][c0][c1])%MOD;\n\t\t\t\tif(s[i]=='0') dp[i][c0][c1+1]=(dp[i][c0][c1+1]+dp[i][c0][c1])%MOD;\n\t\t\t\telse if(s[i]=='1') dp[i][c0+1][c1]=(dp[i][c0+1][c1]+dp[i][c0][c1])%MOD;\n\t\t\t}\n\tf[0][0][0]=true;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int c0=0;c0<=i;c0++)\n\t\t\tfor(int c1=0;c0+c1<=i;c1++)\n\t\t\t{\n\t\t\t\tif(i+1<=n)\n\t\t\t\t{\n\t\t\t\t\tf[i+1][c0][c1]|=f[i][c0][c1];\n\t\t\t\t\tif(s[i+1]=='0'&&c1>0) f[i+1][c0+1][c1-1]|=f[i][c0][c1];\n\t\t\t\t\tif(s[i+1]=='1'&&c0>0) f[i+1][c0-1][c1+1]|=f[i][c0][c1];\n\t\t\t\t}\n\t\t\t\tif(i+2<=n)\n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='0'||s[i+2]=='0') f[i+2][c0+1][c1]|=f[i][c0][c1];\n\t\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1') f[i+2][c0][c1+1]|=f[i][c0][c1];\n\t\t\t\t}\n\t\t\t}\n\tf[n][0][0]=false;\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int c0=0;c0<=i;c0++)\n\t\t\tfor(int c1=0;c0+c1<=i;c1++)\n\t\t\t\tif(f[i][c0][c1]) ans=(ans+dp[i][c0][c1])%MOD;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\nvoid ckmx(int &a, int b){ if(a < b) a = b; }\ncs int Mod = 998244353;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\ncs int N = 305;\nint n; char S[N];\nint dp[N][N][N], ok[N][N][N];\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%s\",S+1); n=strlen(S+1);\n\tdp[n][0][0] = 1;\n\tfor(int i=n; i>=1; i--)\n\tfor(int j=0; j<=i; j++)\n\tfor(int k=0,coe; j+k<=i; k++)\n\tif(coe=dp[i][j][k]){\t\n\t\tAdd(dp[i-1][j][k],coe);\n\t\tif(S[i]=='0')Add(dp[i][j][k+1],coe);\n\t\tif(S[i]=='1')Add(dp[i][j+1][k],coe);\n\t}\n\tmemset(ok,-1,sizeof(ok));\n\tok[0][0][0] = 0;\n\tfor(int i=0; i<n; i++)\n\tfor(int j=0; j<=i; j++)\n\tfor(int k=0,coe; j+k<=i; k++)\n\tif(~(coe=ok[i][j][k])){\n\t\tckmx(ok[i+1][j][k],coe);\n\t\tif(S[i+1]=='0'&&coe)ckmx(ok[i+1][j+1][k],coe-1);\n\t\tif(S[i+1]=='1'&&coe)ckmx(ok[i+1][j][k+1],coe-1);\n\t\tif(i+1<n){\n\t\t\tckmx(ok[i+2][j][k],coe+1);\n\t\t\tif(S[i+1]=='0'||S[i+2]=='0')ckmx(ok[i+2][j+1][k],coe);\n\t\t\tif(S[i+1]=='1'||S[i+2]=='1')ckmx(ok[i+2][j][k+1],coe);\n\t\t}\n\t} int ans = 0;\n\tfor(int i=0; i<=n; i++)\n\tfor(int j=0; j<=i; j++)\n\tfor(int k=0,t; j+k<=i; k++)\n\tif(ok[i][j][k]>=0 && n-i+j+k>0)\n\tAdd(ans,dp[i][j][k]);\n\tcout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 305;\n\n// Mod int\n// const int mod = 1000000007;\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\n//\n\n// mint dp[MX][MX][MX];\nmint co[MX][MX];\n\nmint f(int n, int k) {\n  if (!k) return 1;\n  if (!n) return 0;\n  return co[n-1+k][k];\n}\n\nbool d[MX][MX][MX];\n\nint main() {\n  co[0][0] = 1;\n  rep(i,MX-1) {\n    rep(j,i+1) {\n      co[i+1][j] += co[i][j];\n      co[i+1][j+1] += co[i][j];\n    }\n  }\n  string s;\n  cin>>s;\n  int n = sz(s);\n  vi c(2), e(2);\n  // rep(i,n) c[s[i]-'0']++;\n\n  // int na = c[0], nb = c[1];\n  // dp[0][0][0] = 1;\n  // rep(i,na+nb+1) {\n  //   rep(j,na+1)rep(k,nb+1) {\n  //     dp[i+1][j+1][k] += dp[i][j][k];\n  //     dp[i+1][j][k+1] += dp[i][j][k];\n  //   }\n  // }\n  // rep(i,na+nb+1) {\n  //   rep(j,na+1)rep(k,nb+1) dp[i][j][k+1] += dp[i][j][k];\n  //   rep(j,na+1)rep(k,nb+1) dp[i][j+1][k] += dp[i][j][k];\n  // }\n\n  d[0][0][0] = 1;\n  rep(i,n+1)rep(j,n+1)rep(k,n+1) {\n    if (!d[i][j][k]) continue;\n    if (j && j+k >= 2) d[i][j-1][k] = 1;\n    if (k && j+k >= 2) d[i][j][k-1] = 1;\n    if (i < n) {\n      int x = s[i]-'0';\n      int ni = i+1;\n      int nj = j+!x, nk = k+x;\n      if (nj) d[ni][nj-1][nk] = 1;\n      if (nk) d[ni][nj][nk-1] = 1;\n      if (i+1 < n) {\n        int y = s[i+1]-'0';\n        ni++;\n        nj += !y; nk += y;\n        if (x+y != 2) d[ni][nj-1][nk] = 1;\n        if (x+y != 0) d[ni][nj][nk-1] = 1;\n      }\n    }\n  }\n  d[n][0][0] = 0;\n\n  mint ans = 0;\n  drep(i,n+1) {\n    rep(j,n+1)rep(k,n+1) {\n      int ex = 0;\n      if (i < n) {\n        int x = s[i]-'0';\n        int nj = j+!x, nk = k+x;\n        if (d[i+1][nj][nk]) ex = 1;\n      }\n      d[i][j][k] |= ex;\n      if (ex) continue;\n      if (!d[i][j][k]) continue;\n      rep(sj,j+1)rep(sk,k+1) {\n        mint now = f(c[1],sj);\n        now *= f(c[0],sk);\n        // cerr<<now<<endl;\n        now *= co[j+k-sj-sk][j-sj];\n        // cerr<<sj<<\" \"<<sk<<\" \"<<now<<endl;\n        ans += now; \n      }\n      // cerr<<(n-i)<<\" \"<<j<<\" \"<<k<<\" \"<<ans<<endl;\n    }\n    c[s[i-1]-'0']++;\n  }\n\n  // mint ans = 1;\n  // int m = 0;\n  // vi l(2);\n  // for (int i = 0; i+2 <= n; i += 2) {\n  //   c[s[i]-'0']--; c[s[i+1]-'0']--;\n  //   int x = s[i]-'0';\n  //   x += s[i+1]-'0';\n  //   e[s[i]-'0']++; e[s[i+1]-'0']++;\n  //   l[s[i]-'0']++; l[s[i+1]-'0']++;\n  //   l[0]--; l[1]--;\n  //   maxs(l[0],0);\n  //   maxs(l[1],0);\n  //   ++m;\n  //   mins(e[0], m-l[1]);\n  //   mins(e[1], m-l[0]);\n  //   cerr<<e<<endl;\n  //   rep(j,m+1)rep(k,m+1-j) {\n  //     if (j > e[0]) break;\n  //     if (k > e[1]) break;\n  //     mint now = dp[m-j-k][e[0]-j][e[1]-k];\n  //     now *= f(c[1],j);\n  //     now *= f(c[0],k);\n  //     cerr<<i<<\" \"<<j<<\" \"<<k<<\" \"<<now<<endl;\n  //     ans += now;\n  //   }\n  // }\n  // e[0] += c[0];e[1] += c[1];\n  // l[0] += c[0];l[1] += c[1];\n  // l[0]--; l[1]--;\n  // maxs(l[0],0);\n  // maxs(l[1],0);\n  // ++m;\n  // mins(e[0], m-l[1]);\n  // mins(e[1], m-l[0]);\n\n  // int r = n-m;\n  // // cerr<<ans<<\" \"<<r<<endl;\n  // while (r) {\n  //   ans += dp[r][e[0]][e[1]];\n  //   --r;\n  // }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k){\n\t\t\t\t\t\tcan[i+1][j+1][k+1]=true;\n\t\t\t\t\t\tif(s[i]=='1'){\n\t\t\t\t\t\t\tcan[i+1][j+1][k]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(sumo[i-1]>j-k){\n\t\t\t\t\t\tcan[i+1][j+1][k]=true;\n\t\t\t\t\t\tif(s[i]=='0'){\n\t\t\t\t\t\t\tcan[i+1][j+1][k+1]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=305,mod=998244353;\nchar s[N]; int n,f[N][N][N],ans; bool vis[N][N][N]; // f[i][j][k]: length i; j 0s to add; k 1s to add\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\nint main()\n{\n\tRI i,j,k; scanf(\"%s\",s+1); n=strlen(s+1); s[0]='2';\n\tfor (f[0][0][0]=1,i=0;i<n;++i) for (j=0;j<=i;++j)\n\tfor (k=0;j+k<=i;++k) if (f[i][j][k])\n\t{\n\t\tint c=s[n-(i-j-k)]-'0'; inc(f[i+1][j][k],f[i][j][k]);\n\t\tif (c) inc(f[i+1][j+1][k],f[i][j][k]); else inc(f[i+1][j][k+1],f[i][j][k]);\n\t}\n\tfor (vis[0][0][0]=vis[n][0][0]=1,i=n-1;i;--i)\n\tfor (j=0;j<=i;++j) for (k=0;j+k<=i;++k)\n\t{\n\t\tint c1=s[n-(i-j-k)]-'0',c2=s[n-(i-j-k)-1]-'0',t[3]; t[2]=0;\n\t\tif (t[0]=j,t[1]=k,++t[0],t[c1])\n\t\t{\n\t\t\tif (--t[c1],t[c2]&&(c1==0||c2==0)) --t[c2];\n\t\t}\n\t\tvis[i][j][k]|=vis[i+1][t[0]][t[1]];\n\t\tif (t[0]=j,t[1]=k,++t[1],t[c1])\n\t\t{\n\t\t\tif (--t[c1],t[c2]&&(c1==1||c2==1)) --t[c2];\n\t\t}\n\t\tvis[i][j][k]|=vis[i+1][t[0]][t[1]];\n\t}\n\tfor (i=1;i<=n;++i) for (j=0;j<=i;++j) for (k=0;j+k<=i;++k)\n\tif (vis[i][j][k]) inc(ans,f[i][j][k]); return printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nconst int N=605;\nint n;\nstring s;\nll dp[N][N];//number maximum number of 1 that can be picked if j 0s is picked among the first i\nll c[N][N];\nll dp2[3][N][N];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> s;n=s.size();s='?'+s;\n\tif(n==1){\n\t\tcout << \"1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<=2*n ;i++){\n\t\tfor(int j=0; j<=2*n ;j++){\n\t\t\tdp[i][j]=-1e9;\n\t\t\tdp2[0][i][j]=-1e9;\n\t\t\tdp2[1][i][j]=-1e9;\n\t\t\tdp2[2][i][j]=-1e9;\n\t\t}\n\t\tdp[i][0]=0;\n\t\tc[i][0]=1;\n\t\tfor(int j=1; j<=i ;j++){\n\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t\t}\n\t}\n\tdp2[0][0][0]=0;\n\tdp[0][0]=0;\n\tfor(int i=1; i<=n ;i++){\n\t\tint c=i%3;\n\t\tint p=(c+2)%3;\n\t\tint q=(c+1)%3;\n\t\tfor(int j=0; j<=i ;j++){\n\t\t\tfor(int k=0; k<=i ;k++){\n\t\t\t\tdp2[c][j][k]=-1e9;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<=i ;j++){\n\t\t\tfor(int k=0; k<=i ;k++){\n\t\t\t\tif(i>=2 && j>=1) dp2[c][j][k]=max(dp2[c][j][k],dp2[q][j-1][k]);//aa->power\n\t\t\t\tif(i>=2 && (s[i-1]=='1' || s[i]=='1')) dp2[c][j][k]=max(dp2[c][j][k],dp2[q][j][k]+1);//ab,ba->void\n\t\t\t\tif(i>=2 && (s[i-1]=='0' || s[i]=='0') && k>=1) dp2[c][j][k]=max(dp2[c][j][k],dp2[q][j][k-1]);//ab,ba->void\n\t\t\t\tif(s[i]=='1') dp2[c][j][k]=max(dp2[c][j][k],dp2[p][j+1][k]+1);\n\t\t\t\tif(s[i]=='0' && k>=1) dp2[c][j][k]=max(dp2[c][j][k],dp2[p][j+1][k-1]);\n\t\t\t\tdp[i][k]=max(dp[i][k],dp2[c][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1; i<=n ;i++){\n\t\tfor(int j=0; j<=i-2 ;j++){\n\t\t\tbool hv0=false;\n\t\t\tbool hv1=false;\n\t\t\tfor(int k=j+1; k<=i ;k++){\n\t\t\t\tif(s[k]=='0') hv0=true;\n\t\t\t\tif(s[k]=='1') hv1=true;\n\t\t\t}\n\t\t\tfor(int k=0; k<=i ;k++){\n\t\t\t\tif(hv1) dp[i][k]=max(dp[i][k],dp[j][k]+1);\n\t\t\t\tif(hv0 && k!=0) dp[i][k]=max(dp[i][k],dp[j][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=n; i>=1 ;i--){\n\t\tint c0=0,c1=0;\n\t\tfor(int j=n; j>=i ;j--){\n\t\t\tif(s[j]=='0') c1++;\n\t\t\telse c0++;\n\t\t}\n\t\tfor(int j=0; j<=i ;j++){\n\t\t\tfor(int k=0; k<=dp[i][j] ;k++){\n\t\t\t\tif(c0==0 && j!=0) continue;\n\t\t\t\tif(c1==0 && k!=0) continue;\n\t\t\t\tll w1=1,w2=1;\n\t\t\t\tif(j!=0) w1=c[j+c0-1][c0-1];\n\t\t\t\tif(k!=0) w2=c[k+c1-1][c1-1];\n\t\t\t\tans=(ans+w1*w2)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,p[2][N];\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++) p[0][i]=p[0][i-1]+(s[i]=='0'),p[1][i]=p[1][i-1]+(s[i]=='1');\n    p[1][n+1]=p[1][n];p[0][n+1]=p[0][n];\n    f[0][0][0]=true;\n    for(int k=0;k<=n;k++)\n        for(int i=0;i<=p[0][k];i++)\n            for(int j=0;j<=p[1][k];j++)\n    {\n        if(!f[k][i][j]) continue;\n        f[k+1][i][j]=true;\n        if(i&&s[k+1]=='1')\n            f[k+1][i-1][j+1]=true;\n        if(j&&s[k+1]=='0')\n            f[k+1][i+1][j-1]=true;\n        if(k+2<=n&&(s[k+1]=='1'||s[k+2]=='1'))\n            f[k+2][i][j+1]=true;\n        if(k+2<=n&&(s[k+1]=='0'||s[k+2]=='0'))\n            f[k+2][i+1][j]=true;\n    }\n    dp[n+1][0][0]=1;\n    ll ans=0;\n    for(int k=n+1;k>=1;k--)\n        for(int i=0;i<=p[0][k];i++)\n        for(int j=0;j<=p[1][k];j++)\n    {\n        if(dp[k][i][j]==0) continue;\n        if(f[k-1][i][j])\n            ans=(ans+dp[k][i][j])%mod;\n        if(k>1)\n        {\n            dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n            if(s[k-1]=='1')\n                dp[k][i+1][j]=(dp[k][i+1][j]+dp[k][i][j])%mod;\n            else dp[k][i][j+1]=(dp[k][i][j+1]+dp[k][i][j])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nvector<mint> frac, ifrac;\nvoid finit(ll X) {\n\tfrac.assign(X + 1, 1);\n\tifrac.assign(X + 1, 1);\n\n\trepn(i, X) {\n\t\tfrac[i] = frac[i - 1] * i;\n\t\tifrac[i] = ifrac[i - 1] / i;\n\t}\n\n}\n\nmint com(ll n, ll m) {\n\tif (n < 0 || m < 0 || n < m) { return 0; }\n\treturn frac[n] * ifrac[m] * ifrac[n - m];\n}\n\n\nint main() {\n\tstring S;\n\tcin >> S;\n\n\tll N = S.size();\n\n\tvll a(N + 1);\n\trepn(i, N) cin >> a[i];\n\n\tll one = 0;\n\trepn(i, N) one += a[i];\n\n\tvvvmint dp(N + 1, vvmint(N + 1, vmint(N + 1, 0)));\n\n\tdp[0][0][0] = 1;\n\n\trep(i, N + 1)rep(j, N + 1)rep(k, N + 1) {\n\t\tif (i>0&&k>0&&a[N + 1 - i] == 0) { dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j][k - 1]; }\n\t\telse if(i>0&&j>0&&a[N+1-i]==1) { dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - 1][k]; }\n\t}\n\n\tmint ans = 0;\n\n\trepn(i, N / 2) {\n\t\tll cnt = 0;\n\t\trepn(j, 2 * i) { cnt += a[j]; }\n\n\t\tll rest = N - 2*i;\n\n\t\tif (cnt < i) {\n\t\t\trep(x, cnt + 1) {\n\t\t\t\tans += dp[rest + i][i-x][x];\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tfor (ll x = 2*i - cnt; x <= i; x++) {\n\t\t\t\tans += dp[rest + i][i - x][x];\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<998244353LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nmll calc(string &s_){\n\tll n=sz(s_);\n\tvll s = str2num(s_, n);\n\ts.push_back(0);//dmy\n\n\tvvvll dp(n+1, vvll(n+1, vll(n+1)));\n\tauto Dp = [&](ll i, ll j, ll k)->ll&{\n\t\tstatic ll dmy=0;\n\t\tif (i>=n) return dmy;\n\t\tif (j<0 or k<0) return dmy;\n\t\treturn dp[i+1][j][k];\n\t};\n\n\tDp(-1, 0, 0)=1;\n\n\trep(i, -1, n-2)rep(j, 0, n)rep(k, 0, n){\n\t\tif (Dp(i, j, k)==0)continue;\n\t\tDp(i+1, j, k)=1;\n\t\tDp(i+2, j, k)=1;\n\t\tif (s[i+1]==0 or s[i+2]==0) Dp(i+2, j+1, k)=1;\n\t\tif (s[i+1]==1 or s[i+2]==1) Dp(i+2, j, k+1)=1;\n\n\t\tif (s[i+1]==0) Dp(i+1, j+1, k-1)=1;\n\t\tif (s[i+1]==1) Dp(i+1, j-1, k+1)=1;\n\t}\n\tvvvmll dq(n+1, vvmll(n+1, vmll(n+1)));\n\tauto Dq = [&](ll i, ll j, ll k)->mll&{\n\t\treturn dq[i][j][k];\n\t};\n\tDq(n, 0, 0)=1;\n\n\tmll ans=0;\n\tdep(i, n-1, 0){\n\t\tdq[i]=dq[i+1];\n\t\tif (s[i]==0){\n\t\t\trep(j, 0, n){\n\t\t\t\trep(k, 1, n) Dq(i, j, k)+=Dq(i, j, k-1);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\trep(k, 0, n){\n\t\t\t\trep(j, 1, n) Dq(i, j, k)+=Dq(i, j-1, k);\n\t\t\t}\n\t\t}\n\n\t\trep(j, 0, n)rep(k, 0, n){\n\t\t\tif (Dp(i, j, k)==1){\n\t\t\t\tans+=Dq(i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"dp\" << '\\n';\n\t//Dump(dp);\n\t//cout << \"dq\" << '\\n';\n\t//Dump(dq);\n\treturn ans;\n}\n\nmll naive(string &s){\n\tll n=sz(s);\n\n\tset<pair<ll,string>> pool;\n\tpool.emplace(-n,s);\n\tauto it = pool.begin();\n\n\twhile (true){\n\t\tconst string &t=it->second;\n\t\tll len=-(it->first);\n\n\t\tif (sz(t)<=1) break;\n\n\t\trep(i, 0, 1){\n\t\t\tif (i==1 and t[0]==t[1]) break;\n\t\t\tchar c=t[i];\n\n\t\t\trep(j, 0, len-2){\n\t\t\t\tstring tt=t.substr(2);\n\t\t\t\ttt.insert(tt.begin()+j, c);\n\t\t\t\tpool.emplace(-len+1, tt);\n\t\t\t}\n\t\t}\n\n\t\tit++;\n\t}\n\teach(e, pool){\n\t\tcout << e.second << '\\n';\n\t}\n\treturn sz(pool);\n}\n\nvoid solve()\n{\n\tstring s_;  cin >> s_;\n\n\t//mll ans0=naive(s_);\n\tmll ans=calc(s_);\n\t\n\t//cout << ans0 << '\\n';\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=310,mod=998244353;\nll pd[N][N][N];\nll dp[N][N][N];\nll a[N];\nll par[N][2];\nint32_t main(){\n    string s;\n    cin >> s;\n    s='*'+s;\n    ll n=s.size()-1;\n    for (int i=1;i<=n;i++){\n        a[i]=s[i]-'0';\n        par[i][0]=par[i-1][0];\n        par[i][1]=par[i-1][1];\n        par[i][a[i]]++;\n    }\n    dp[n+1][0][0]=1;\n    for (int i=0;i<N;i++){\n        for (int j=0;j<N;j++){\n            if (i==0 && j==0) continue;\n            if (i>0)\n            dp[n+1][i][j]+=dp[n+1][i-1][j];\n            if (j>0)\n                dp[n+1][i][j]+=dp[n+1][i][j-1];\n            dp[n+1][i][j]%=mod;\n        }\n    }\n    for (int i=n;i;i--){\n        for (int j=0;j<N;j++){\n            for (int k=0;k<N;k++){\n                if (a[i]==1){\n                    if (j>0) dp[i][j][k]+=dp[i][j-1][k];\n                    if (k>0) dp[i][j][k]+=dp[i+1][j][k-1];\n                }\n                else{\n                    if (j>0) dp[i][j][k]+=dp[i+1][j-1][k];\n                    if (k>0) dp[i][j][k]+=dp[i][j][k-1];\n                }\n                dp[i][j][k]%=mod;\n            }\n        }\n    }\n    pd[0][0][0]=1;\n    for (int i=2;i<=n;i++){\n        for (int j=0;j<N;j++){\n            for (int k=0;k<N;k++){\n                if (j>0 || k>0) pd[i][j][k]=max(pd[i][j][k],pd[i-1][j][k]);\n                if (a[i]==0 && j>0 && k<N-1 && pd[i-1][j-1][k+1]){\n                    pd[i][j][k]=1;\n                }\n                if (a[i]==1 && k>0 && j<N-1 && pd[i-1][j+1][k-1]){\n                    pd[i][j][k]=1;\n                }\n                if (a[i]==0 || a[i-1]==0){\n                    if (j>0 && pd[i-2][j-1][k]){\n                        pd[i][j][k]=1;\n                    }\n                }\n                if (a[i]==1 || a[i-1]==1){\n                    if (k>0 && pd[i-2][j][k-1]){\n                        pd[i][j][k]=1;\n                    }\n                }\n            }\n        }\n    }\n    ll ans=0;\n    for (int i=2;i<=n;i++){\n        for (int j=0;j<N;j++){\n            for (int k=0;k<N;k++){\n                if (a[i+1]==0 && j<N-1){\n                    if (pd[i+1][j+1][k]) pd[i][j][k]=0;\n                }\n                if (a[i+1]==1 && k<N-1){\n                    if (pd[i+1][j][k+1]) pd[i][j][k]=0;\n                }\n                /*\n                if (pd[i][j][k]){\n                        cout << i << \" \" << j << \" \" << k << endl;\n                    ans+=dp[i+1][j][k][0]+dp[i+1][j][k][1]-dp[i+2][j][k][a[i+1]];\n                    cout << ans << endl;\n                }\n                */\n                if (pd[i][j][k]){\n                //    cout << i << \" \" << j << \" \" << k << \" \" << endl;\n                    ans+=dp[i+1][par[n][0]-par[i][0]+j][par[n][1]-par[i][1]+k];\n                    ans%=mod;\n                //cout << ans << endl;\n                }\n            }\n        }\n    }\n    cout << ans+1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MOD = 998244353;\ninline void Add(int &x, int y) { (x += y) >= MOD && (x -= MOD); }\n\nint n;\nchar s[310];\nint dp[310][310][310];\n// dp[pos][cnt0][cnt1]\nbool can[310][310][310];\n// can[pos][cnt0][cnt1]\n\nint main() {\n\tscanf(\" %s\", s + 1), n = strlen(s + 1);\n\tdp[n + 1][0][0] = 1;\n\tfor (int i = n + 1; i; --i)\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tAdd(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\t\tint c = s[i - 1] & 15;\n\t\t\t\tif (!c) Add(dp[i][j][k + 1], dp[i][j][k]);\n\t\t\t\telse Add(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t}\n\tcan[0][0][0] = true;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = n; ~j; --j)\n\t\t\tfor (int k = n; ~k; --k) if (can[i][j][k]) {\n\t\t\t\tif (j) can[i][j - 1][k] = true;\n\t\t\t\tif (k) can[i][j][k - 1] = true;\n\t\t\t\tcan[i + 1][j][k] = true;\n\t\t\t\tif (i < n && s[i + 1] == '0' && k) can[i + 1][j + 1][k - 1] = true;\n\t\t\t\tif (i < n && s[i + 1] == '1' && j) can[i + 1][j - 1][k + 1] = true;\n\t\t\t\tif (i < n - 1 && (s[i + 1] == '0' || s[i + 2] == '0')) can[i + 2][j + 1][k] = true;\n\t\t\t\tif (i < n - 1 && (s[i + 1] == '1' || s[i + 2] == '1')) can[i + 2][j][k + 1] = true;\n\t\t\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tfor (int k = 0; k <= n; ++k) if (can[i][j][k]) Add(ans, dp[i + 1][j][k]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nunordered_set<long long> chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tlong long u = 0;\n\tu *= L + 1; u += i;\n\tu *= L + 1; u += z;\n\tu *= L + 1; u += o;\n\tu *= L + 1; u += f;\n\tif (chk[L - i + z + o + f].count(u)) return;\n\tchk[L - i + z + o + f].insert(u);\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\tif (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\tif (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint s[303], e[303];\n\t\tmemset(s, 0x7f, sizeof(s));\n\t\tmemset(e, -1, sizeof(e));\n\t\tfor (auto t : chk[l]){\n\t\t\tint f = t % (L + 1); t /= L + 1;\n\t\t\tint o = t % (L + 1); t /= L + 1;\n\t\t\tint z = t % (L + 1); t /= L + 1;\n\t\t\tint i = t % (L + 1); t /= L + 1;\n\n\t\t\ts[i] = min(s[i], z);\n\t\t\te[i] = max(e[i], z + f);\n\t\t}\n\n\t\tfor (int i = 0; i <= L; i++){\n\t\t\tif (e[i] != -1){\n\t\t\t\tfor (int j = s[i]; j <= e[i]; j++) pin[j + zc[i]] = i;\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t\t//printf (\"%d %lld\\n\", l, ret);\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    string S; cin >> S;\n    int N = SZ(S);\n\n    vector<vector<v_bool>> dp(N + 1, vector<v_bool>(N + 1, v_bool(N + 1, false)));\n    dp[0][0][0] = true;\n    REP(i, N){\n        REP(j, i + 1) REP(k, i + 1) if(dp[i][j][k]){\n            if(i + 2 <= N){\n                if(S[i] == '0' || S[i + 1] == '0') dp[i + 2][j + 1][k] = true;\n                if(S[i] == '1' || S[i + 1] == '1') dp[i + 2][j][k + 1] = true;\n            }\n            dp[i + 1][j][k] = true;\n            if(S[i] == '0' && k > 0) dp[i + 1][j + 1][k - 1] = true;\n            if(S[i] == '1' && j > 0) dp[i + 1][j - 1][k + 1] = true;\n        }\n    }\n\n    vector<mmat> dq(N + 1, mmat(N + 1, mvec(N + 1, 0)));\n    if(S[N - 1] == '0'){\n        REP(k, N + 1) dq[0][0][k] = 1;\n    }else{\n        REP(j, N + 1) dq[0][j][0] = 1;\n    }\n    REP(i, N){\n        REP(j, N + 1) REP(k, N + 1){\n            dq[i + 1][j][k] += dq[i][j][k];\n        }\n        if(i < N - 1){\n            if(S[N - 2 - i] == '0'){\n                REP(j, N + 1){\n                    mint t = 0;\n                    REP(k, N + 1){\n                        dq[i + 1][j][k] += t;\n                        t += dq[i][j][k];\n                    }\n                }\n            }else{\n                REP(k, N + 1){\n                    mint t = 0;\n                    REP(j, N + 1){\n                        dq[i + 1][j][k] += t;\n                        t += dq[i][j][k];\n                    }\n                }\n            }\n        }\n    }\n\n    mint ans = 0;\n    REP(i, N + 1){\n        REP(j, N + 1) REP(k, N + 1) if(dp[N - i][j][k]) ans += dq[i][j][k];\n    }\n    Out(ans - 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nset<int> chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tint u = 0;\n\tu *= L + 1; u += i;\n\tu *= L + 1; u += z;\n\tu *= L + 1; u += z + f;\n\tif (chk[L - i + z + o + f].count(u)) return;\n\tchk[L - i + z + o + f].insert(u);\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\telse if (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\telse if (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint s[303], e[303];\n\t\tmemset(s, 0x7f, sizeof(s));\n\t\tmemset(e, -1, sizeof(e));\n\t\tfor (auto t : chk[l]){\n\t\t\tint f = t % (L + 1); t /= L + 1;\n\t\t\tint z = t % (L + 1); t /= L + 1;\n\t\t\tint i = t % (L + 1); t /= L + 1;\n\n\t\t\ts[i] = min(s[i], z);\n\t\t\te[i] = max(e[i], f);\n\t\t}\n\n\t\tfor (int i = 0; i <= L; i++){\n\t\t\tif (e[i] != -1){\n\t\t\t\tfor (int j = s[i]; j <= e[i]; j++) pin[j + zc[i]] = i;\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\nbool dp[MAX][MAX][MAX];\nll dp2[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    int N=si(S);\n    dp[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]==0) continue;\n                \n                if(i+1<N){\n                    if(S[i]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    if(S[i+1]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    dp[i+1][j][k]=1;\n                }\n                \n                if(j&&S[i]=='1') dp[i+1][j-1][k+1]=1;\n                \n                if(k&&S[i]=='0') dp[i+1][j+1][k-1]=1;\n                \n                if(j||k) dp[i+1][j][k]=1;\n            }\n        }\n    }\n    \n    reverse(all(S));\n    \n    dp2[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(S[i]=='0'){\n                    dp2[i][j][k+1]+=dp2[i][j][k];\n                    dp2[i][j][k+1]%=mod;\n                }else{\n                    dp2[i][j+1][k]+=dp2[i][j][k];\n                    dp2[i][j+1][k]%=mod;\n                }\n                dp2[i+1][j][k]+=dp2[i][j][k];\n                dp2[i+1][j][k]%=mod;\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]){\n                    ans+=dp2[N-i][j][k];\n                    ans%=mod;\n                }\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define chmax(a, b) a = max(a, b);\n#define chmin(a, b) a = min(a, b);\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n\n//#define MOD 1000000007\n#define MOD 998244353\nstruct mint {\n\tint i;\n\tmint() : i(0) {}\n\tmint(int x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\ttemplate<class T> mint(T x) {\n\t\ti = int(x % MOD);\n\t\tif (i < 0) i += MOD;\n\t}\n\tmint operator+(const mint x) const {return i + x.i;}\n\tmint operator-(const mint x) const {return i - x.i;}\n\tmint operator*(const mint x) const {return (long long)i * x.i;}\n\tmint operator/(const mint x) const {return (long long)i * x.pow(MOD - 2).i;}\n\tmint inv() {return pow(MOD - 2);}\n\ttemplate<class T> mint pow(T p) const {\n\t\tlong long r = 1;\n\t\tlong long t = i;\n\t\tfor(; p > 0; p >>= 1) {\n\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\ttemplate<class T1, class T2> static mint pow(T1 a, T2 b) {\n\t\tlong long r = 1;\n\t\tlong long t = (long long)(a % MOD);\n\t\tfor(; b > 0; b >>= 1) {\n\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\tt = t * t % MOD;\n\t\t}\n\t\treturn r;\n\t}\n\tmint& operator+=(const mint x) {\n\t\ti = (i + x.i) % MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint x) {\n\t\ti = i - x.i;\n\t\tif (i < 0) i += MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint x) {\n\t\ti = (int)((long long)i * x.i % MOD);\n\t\treturn *this;\n\t}\n\tmint& operator/=(const mint x) {\n\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\treturn *this;\n\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < MOD);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k == 0) return 1;\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n} comb(310);\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint len = s.size();\n\tvector<int> zacc(len+1), oacc(len+1);\n\tfor(int i = len-1; i >= 0; i--) {\n\t\tzacc[i] = zacc[i+1] + (s[i] == '0');\n\t\toacc[i] = oacc[i+1] + (s[i] == '1');\n\t}\n\t// dp[i] .. max next index with i 0s trashed\n\tvector<int> dp(301, -1);\n\tdp[0] = 0;\n\tmint ans(0);\n\trep(rmcnt, len) {\n\t\tvector<int> ndp(301, -1);\n\t\trep(i, 301) {\n\t\t\tif (dp[i] == -1) continue;\n\t\t\tint nxt = dp[i];\n\t\t\tint zcnt_unseen = zacc[nxt], ocnt_unseen = oacc[nxt];\n\t\t\tint zcnt_free = zacc[0] - zacc[nxt] - i,\n\t\t\t    ocnt_free = oacc[0] - oacc[nxt] - (rmcnt - i);\n\t\t\trep(zcnt_after, zcnt_free + 1) {\n\t\t\t\tint zcnt_free_left = zcnt_free - zcnt_after;\n\t\t\t\tans += comb(ocnt_unseen - 1 + zcnt_free_left, zcnt_free_left)\n\t\t\t\t     * comb(zcnt_unseen + zcnt_after + ocnt_free, ocnt_free);\n\t\t\t}\n\t\t\tif (zcnt_free + ocnt_free >= 2) {\n\t\t\t\tif (zcnt_free >= 1) chmax(ndp[i+1], nxt);\n\t\t\t\tif (ocnt_free >= 1) chmax(ndp[i], nxt);\n\t\t\t}\n\t\t\tif (nxt < len && zcnt_free + ocnt_free >= 1) {\n\t\t\t\tif (s[nxt] == '0') {\n\t\t\t\t\tchmax(ndp[i+1], nxt+1);\n\t\t\t\t\tif (ocnt_free >= 1) chmax(ndp[i], nxt+1);\n\t\t\t\t} else {\n\t\t\t\t\tchmax(ndp[i], nxt+1);\n\t\t\t\t\tif (zcnt_free >= 1) chmax(ndp[i+1], nxt+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nxt < len - 1) {\n\t\t\t\tif (s[nxt] == s[nxt+1]) {\n\t\t\t\t\tchmax(ndp[i+(s[nxt] == '0')], nxt+2);\n\t\t\t\t} else {\n\t\t\t\t\tchmax(ndp[i+1], nxt+2);\n\t\t\t\t\tchmax(ndp[i], nxt+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp = move(ndp);\n\t}\n\tcout << ans << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n       int n;\n       cin>>n;\n  \ndouble ans = (double)(360)/n;\n\n        if(ceil(ans)==ans){\n            cout<<ans;\n           \n        }else{\n            while(ceil(ans)!=ans){\n                ans=ans*360;\n                cout<<\" * \";\n            }\n            cout<<(double)ans;\n        }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nnamespace my_std {\nusing namespace std;\n#define reg register\n#define Rint register int\n#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)\n#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)\ntypedef long long i64;\n#define Templ(T) template <typename T>\nTempl(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }\nTempl(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }\nconst int mod = 998244353;\ninline void inc(int &x, const int &y) { x += y; if (x >= mod) x -= mod; }\ninline void dec(int &x, const int &y) { x -= y; if (x < 0) x += mod; }\n} // namespace my_std\nusing namespace my_std;\n\n#define N 350\nchar s[N];\nint n;\nint dp[N][N][N];\nbool tr[N][N][N];\n//[i][c0][c1]: 剩下 i 个字符没有匹配，多了 c0 个 0 和 c1 个 1\n\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    tr[0][0][0] = 1;\n    FOR(i, 1, n){\n        ROF(c0, n, 0) ROF(c1, n, 0){\n            if(i == n && !c0 && !c1) continue;\n            tr[i][c0][c1] |= tr[i - 1][c0][c1];\n            if(s[i] == 48) tr[i][c0][c1] |= tr[i][c0][c1 + 1];\n            if(s[i] == 49) tr[i][c0][c1] |= tr[i][c0 + 1][c1];\n            //删掉两个把第二个加回原来位置\n            //加回去的可能是多出来的字符\n        }\n        if(i > 1) FOR(c0, 0, n) FOR(c1, 0, n){\n            if((s[i - 1] == 48 || s[i] == 48) && c0){\n                tr[i][c0][c1] |= tr[i - 2][c0 - 1][c1];\n                //前面两个都不是多余的，把'0'扔到多余的位置\n            }\n            if(s[i - 1] == 48 && s[i] == 48 && c0){\n                tr[i][c0][c1] |= tr[i - 1][c0 - 1][c1 + 1];\n                //前面是\"10\"（'1'是多余的），并把'0'扔到多余的位置\n            }\n            if((s[i - 1] == 49 || s[i] == 49) && c1){\n                tr[i][c0][c1] |= tr[i - 2][c0][c1 - 1];\n                //前面两个都不是多余的，把'1'扔到多余的位置\n            }\n            if(s[i - 1] == 49 && s[i] == 49 && c1){\n                tr[i][c0][c1] |= tr[i - 1][c0 + 1][c1 - 1];\n                //前面是\"01\"（'0'是多余的），并把'1'扔到多余的位置\n            }\n        }\n    }\n    dp[n][0][0] = 1;\n    ROF(i, n, 1){\n        FOR(c0, 0, n) FOR(c1, 0, n){\n            Rint t(dp[i][c0][c1]);\n            inc(dp[i - 1][c0][c1], t);\n            if(s[i] == 48) inc(dp[i][c0][c1 + 1], t);\n            if(s[i] == 49) inc(dp[i][c0 + 1][c1], t);\n        }\n    }\n    Rint ans(0);\n    FOR(i, 0, n){\n        FOR(c0, 0, i) FOR(c1, 0, i){\n            if(tr[i][c0][c1]) inc(ans, dp[i][c0][c1]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 998244353;\n//ll dp[155][155][305];\nll ans = 0;\nll checker[305][305][305];\nll dp[305][305][305];\n\nint main() {\n    string S;\n    cin >> S;\n    checker[0][0][0] = 1;\n    for(int k = 0; k <= S.size(); k++) {\n        for(int i = S.size(); i >= 0; i--) {\n            for(int j = S.size(); j >= 0; j--) {\n                if(!checker[i][j][k]) continue;\n                //cerr << i << \" \" << j << \" \" << k << endl;\n                if(k + 2 <= S.size()) {\n                    string T = S.substr(k, 2);\n                    if(T != \"11\") checker[i+1][j][k+2] = 1;\n                    if(T != \"00\") checker[i][j+1][k+2] = 1;\n                }\n                if(i >= 2) checker[i-2][j][k] = 1;\n                if(j >= 2) checker[i][j-2][k] = 1;\n                if(i >= 1 and j >= 1) checker[i-1][j-1][k] = 1;\n                if(i >= 1 or j >= 1) checker[i][j][k+1] = 1;\n                if(i >= 1 and k + 1 <= S.size() and S[k] == '1') {\n                    checker[i-1][j+1][k+1] = 1;\n                }\n                if(j >= 1 and k + 1 <= S.size() and S[k] == '0') {\n                    checker[i+1][j-1][k+1] = 1;\n                }\n            }\n        }\n    }\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(checker[i][j][k] == 0) continue;\n                if(checker[i][j][k] == 1) {\n                    //cerr << i + j + (S.size() - k) << \" \" << i << \" \" << j << \" \" << k << endl;\n                }\n                if(k == 0) continue;\n                ll newi = i;\n                ll newj = j;\n                if(S[k-1] == '0') newi--;\n                if(S[k-1] == '1') newj--;\n                if(newi < 0 or newj < 0) continue;\n                //checker[newi][newj][k+1] = 2;\n                checker[newi][newj][k-1] = 2;\n            }\n        }\n    }\n    dp[0][0][S.size()] = 1;\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(k < S.size()) {\n                    dp[i][j][k] += dp[i][j][k+1];\n                    if(S[k] == '0' and j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(S[k] == '1' and i > 0) dp[i][j][k] += dp[i-1][j][k];\n                } else {\n                    if(j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(i > 0) dp[i][j][k] += dp[i-1][j][k];\n                }\n                dp[i][j][k] %= mod;\n                if(checker[i][j][k] == 1 and dp[i][j][k]) {\n                    //cerr << i << \" \" << j << \" \" << k << \" \" << S.substr(k, S.size()) << \" \" << dp[i][j][k] << endl;\n                    ans += dp[i][j][k];\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    //cerr << dp[1][0][6] << \" \" << checker[1][0][6] << endl;\n    //cerr << dp[0][1][6] << \" \" << checker[0][1][6] << endl;\n    ans += mod - 1;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 310\n#define mo 998244353\nusing namespace std;\nstring s;\nll jie[N],nj[N],dp[N][N][N],f[N][2],ans,n;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nll C(ll x,ll y){if (x==-1&&y==0)return 1;if (x<y)return 0;return (jie[x]*nj[y]%mo)*nj[x-y]%mo;}\nint main(){\n\tcin>>s;n=s.length();\n\tjie[0]=1;for (int i=1;i<=n;i++)jie[i]=jie[i-1]*i%mo;\n\tnj[n]=po(jie[n],mo-2);for (int i=n-1;i>=0;i--)nj[i]=nj[i+1]*(i+1)%mo;\n\tdp[0][0][0]=1;\n\tfor (int i=0;i<n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tfor (int k=0;j+k<=i;k++){\n\t\t\t\tdp[i+1][j][k]|=dp[i][j][k];\n\t\t\t\tif (s[i]=='0'||s[i+1]=='0')dp[i+2][j+1][k]|=dp[i][j][k];\n\t\t\t\tif (s[i]=='1'||s[i+1]=='1')dp[i+2][j][k+1]|=dp[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=n;i>=1;i--){f[i][0]=f[i+1][0];f[i][1]=f[i+1][1];f[i][s[i-1]-'0']++;}\n\tfor (int i=0;i<=n;i++){\n\t\tfor (int j=0;j<=i;j++){\n\t\t\tfor (int k=0;k+j<=i;k++){\n\t\t\t\tif (dp[i][j][k]){\n\t\t\t\t\tans=(ans+C(f[i][0]+k-1,k)*C(f[i][1]+j-1,j))%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans+mo-1)%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author: ReseeCher\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\n#define ckmax(a,b) (a)=max(a,b)\n#define ckmin(a,b) (a)=min(a,b)\n#define pb push_back\nusing namespace std;\nconst int N=305;\nconst int P=998244353;\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nvoid Ad(LL &x,LL y){x=(x+y)%P;}\nint n;\nchar s[N];\nLL fn[N][N][N];\nint g[N][N][N];\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tcin>>(s+1);n=strlen(s+1);\n\tfn[n][0][0]=1;\n\tD(i,n,1)F(j,0,n)F(k,0,n){\n\t\tAd(fn[i-1][j][k],fn[i][j][k]);\n\t\tif(s[i]=='0')Ad(fn[i][j][k+1],fn[i][j][k]);\n\t\telse Ad(fn[i][j+1][k],fn[i][j][k]);\n\t}\n\tmemset(g,-1,sizeof(g));\n\tg[0][0][0]=0;\n\tF(i,0,n)F(j,0,n)F(k,0,n){\n\t\tif(g[i][j][k]==-1)continue;\n\t\tif(s[i+1]=='0')ckmax(g[i+1][j+1][k],g[i][j][k]-1);\n\t\telse ckmax(g[i+1][j][k+1],g[i][j][k]-1);\n\t\tif(s[i+1]=='0'||s[i+2]=='0')ckmax(g[i+2][j+1][k],g[i][j][k]);\n\t\tif(s[i+1]=='1'||s[i+2]=='1')ckmax(g[i+2][j][k+1],g[i][j][k]);\n\t\tckmax(g[i+2][j][k],g[i][j][k]+1);\n\t}\n\tF(i,0,n)D(j,n,0)D(k,n,0){\n\t\tif(i)ckmax(g[i][j][k],g[i-1][j][k]);\n\t\tckmax(g[i][j][k],g[i][j+1][k]);\n\t\tckmax(g[i][j][k],g[i][j][k+1]);\n\t}\n\tLL an=0;\n\tF(i,0,n)F(j,0,n)F(k,0,n)\n\t\tif(g[i][j][k]!=-1&&(n-i)+j+k!=0&&fn[i][j][k]){\n\t\t\t//printf(\"%d %d %d\\n\",i,j,k);\n\t\t\tAd(an,fn[i][j][k]);\n\t\t}\n\tcout<<an<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 5.1e5;\n\ntemplate<int MOD>\nstruct Modular {\n  int value;\n  Modular(const Modular& k) : value(k.value) {}\n \n  template<typename V>\n  Modular(const V& v) : value(v % MOD) {\n    if (value < 0) {\n      value += MOD;\n    }\n  }\n  \n  Modular() : Modular(0) {}\n \n  Modular& operator+=(Modular const& b) { value += b.value; if (value >= MOD) value -= MOD; return *this; } \n  Modular& operator-=(Modular const& b) { value -= b.value; if (value < 0) value += MOD; return *this; }\n  Modular& operator*=(Modular const& b) { value = (long long)value * b.value % MOD; return *this; }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { return *this += 1; }\n  Modular operator--(int) { return *this -= 1; }\n\n  friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }\n  Modular& operator/=(Modular const& b) { return *this *= inverse(b); }\n  friend Modular operator+(Modular a, Modular const b) { return a += b; }\n  friend Modular operator-(Modular a, Modular const b) { return a -= b; }\n  friend Modular operator-(Modular const a) { return 0 - a; }\n  friend Modular operator*(Modular a, Modular const b) { return a *= b; }\n  friend Modular operator/(Modular a, Modular const b) { return a /= b; }\n  friend std::ostream& operator<<(std::ostream& os, Modular const& a) { return os << a.value; }\n  friend bool operator==(Modular const& a, Modular const& b) { return a.value == b.value; }\n  friend bool operator!=(Modular const& a, Modular const& b) { return a.value != b.value; }\n};\n \ntemplate <int T, typename V>\nModular<T> mexp(Modular<T> a, V e) {\n  if (a == 0) return e == 0 ? 1 : 0; \n  Modular<T> res = 1; \n  while (e) { \n    if (e & 1) \n      res *= a; \n    a *= a; \n    e >>= 1; \n  }\n  return res;\n}\n\nusing Mint = Modular<998244353>;\n\nconst int N = 310;\n\nMint C[N][N][N][2];\nint S[N][N][N];\n\nvoid Run() {\n  string t;\n  cin >> t;\n  const int n = t.size();\n  S[0][0][0] = 1;\n  for (int pref = 1; pref <= n; ++pref) {\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j <= n; ++j) {\n        if (j > 0 && pref >= 2 && (t[pref - 1] == '1' || t[pref - 2] == '1'))\n          S[pref][i][j] |= S[pref - 2][i][j - 1];\n        if (i > 0 && pref >= 2 && (t[pref - 1] == '0' || t[pref - 2] == '0'))\n          S[pref][i][j] |= S[pref - 2][i - 1][j];\n        if (i + j > 0)\n          S[pref][i][j] |= S[pref - 1][i][j];\n        if (j && t[pref - 1] == '1')\n          S[pref][i][j] |= S[pref - 1][i + 1][j - 1];\n        if (i && t[pref - 1] == '0')\n          S[pref][i][j] |= S[pref - 1][i - 1][j + 1];\n      }\n    }\n  }\n  C[n][0][0][0] = C[n][0][0][1] = 1;\n  int none = n, nzero = n;\n  for (int i = n; i >= 0; --i) {\n    if (i < n && t[i] == '1') none = i;\n    if (i < n && t[i] == '0') nzero = i;\n    for (int j = 0; j <= n; ++j) {\n      for (int k = 0; k <= n; ++k) {\n        if (j) C[i][j][k][0] += C[i][j - 1][k][0];\n        if (j && t[i - 1] != '0') C[i][j][k][1] += C[i][j - 1][k][1];\n        if (k) C[i][j][k][0] += C[i][j][k - 1][0];\n        if (k && t[i - 1] != '1') C[i][j][k][1] += C[i][j][k - 1][1];\n        for (int ty = 0; ty < 2; ++ty) {\n          C[i][j][k][ty] += C[i + 1][j][k][1];\n        }\n      }\n    }\n  }\n  Mint ans = 0;\n  vector<vector<bool> > banned(2 * n + 1, vector<bool>(2 * n + 1));\n  int freq[2] = {0, 0};\n  for (int suff = n; suff >= 0; --suff) {\n    if (suff < n) ++freq[t[suff] - '0'];\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j <= n; ++j) {\n        if (!banned[i + freq[0]][j + freq[1]] && S[suff][i][j]) {\n          ans += C[suff][i][j][0];\n          banned[i + freq[0]][j + freq[1]] = true;\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  Run();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 300 + 10;\nconst ll MOD = 998244353;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nbool DP[N][N][N];\nint dp[N][N][N], mark[N][N][N], n, ps[N];\nstring s;\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> s;\n\tif (s.size() == 1) return cout << 1, 0;\n//\tcout << s << endl;\n\tn = s.size();\n\tDP[0][0][0] = 1;\n\tfor (int k = 1; k <= n; k++){\n\t\tps[k] = ps[k - 1] + (s[k - 1] == '1');\n\t\tif (k == 1) continue;\n\t\tfor (int j = k; j >= 0; j--){\n\t\t\tfor (int i = k; i >= 0; i--){\n\t\t\t\tif (j + i == 0) continue;\n\t\t\t\tif (s[k - 1] == '0'){\n\t\t\t\t\tDP[i][j][k] |= DP[i][j][k - 1];\n\t\t\t\t\tDP[i][j][k] |= DP[i + 1][j][k] | DP[i][j + 1][k];\n\t\t\t\t\tif (i != 0) DP[i][j][k] |=  DP[i - 1][j + 1][k - 1];\n\t\t\t\t}else{\n\t\t\t\t\tDP[i][j][k] |= DP[i][j][k - 1];\n\t\t\t\t\tDP[i][j][k] |= DP[i + 1][j][k] | DP[i][j + 1][k];\n\t\t\t\t\tif (j != 0) DP[i][j][k] |=  DP[i + 1][j - 1][k - 1];\n\t\t\t\t}\n\t\t\t\tif ((s[k - 1] == '1' || s[k - 2] == '1') && (j != 0)) DP[i][j][k] |= DP[i][j - 1][k - 2];\n\t\t\t\tif ((s[k - 1] == '0' || s[k - 2] == '0') && (i != 0)) DP[i][j][k] |= DP[i - 1][j][k - 2];\n//\t\t\t\tcout << i << ' '  << j << ' ' <<k<<' '<< DP[i][j][k] << '\\n';\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++){\n\t\tif (s[n - k - 1] == '0') dp[i + 1][j][k + 1] = (dp[i + 1][j][k + 1] + dp[i][j][k]) % MOD, dp[i][j + 1][k] = (dp[i][j + 1][k] + dp[i][j][k]) % MOD;\n\t\telse dp[i][j + 1][k + 1] = (dp[i][j + 1][k + 1] + dp[i][j][k]) % MOD, dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k]) % MOD;\n//\t\tcout << i << ' ' << j << ' ' <<k << ' '<< dp[i][j][k] <<'\\n';\n\t}\n\tfor (int k = 0; k <= n; k++)for (int i = 0; i <= k; i++)for (int j = 0; j <= n; j++){\n\t\tif (k == 1) continue;\n\t\tif (DP[i][j][k]){\n\t\t\tint x = i + (n - k - ps[n] + ps[k]);\n\t\t\tint y = (j + ps[n] - ps[k]);\n\t\t\tmark[x][y][n - k] = 1;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++)\tfor (int k = 0; k <= n; k++){\n\t\tif (k != 0) mark[i][j][k] |= mark[i][j][k - 1];\n\t\tif (mark[i][j][k]) ans = (ans + dp[i][j][k]) % MOD;\n\t}\n\tcout << ans;\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 307;\nconst int md = 998244353;\n\nbool dp[N][N][N];\n\nint cnt[N][N][N][2];\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  int n = s.size();\n  dp[0][0][0] = 1;\n  for (int cnt = 0; cnt < n - 1; ++cnt) {\n    for (int a = 0; a < N; ++a) {\n      for (int b = 0; b < N; ++b) {\n        if (dp[cnt][a][b] == 0) continue;\n        int pos = 2 * cnt;\n        pos -= cnt - (a + b);\n        for (int ta = 0; ta <= min(a, 2); ++ta) {\n          for (int tb = 0; tb <= min(b, 2); ++tb) {\n            if (ta + tb > 2) continue;\n            int ra = ta, rb = tb;\n            bool bad = false;\n            int cpos = pos;\n            while (ra + rb < 2) {\n              if (cpos >= n) {\n                bad = true;\n                break;\n              } else {\n                if (s[cpos] == '0') ++ra;\n                else ++rb;\n                ++cpos;\n              }\n            }\n            if (bad) continue;\n            if (ra > 0) {\n              dp[cnt + 1][a - ta + 1][b - tb] = 1;\n            }\n            if (rb > 0) {\n              dp[cnt + 1][a - ta][b - tb + 1] = 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  vector <vector <pair <int, int>>> have(n + 1);\n  for (int cnt = 0; cnt <= n - 1; ++cnt) {\n    int mx = 0;\n    for (int a = 0; a < N; ++a) {\n      for (int b = 0; b < N; ++b) {\n        if (dp[cnt][a][b] == 0) continue;\n        int pos = 2 * cnt;\n        pos -= cnt - (a + b);\n        have[pos].push_back({a, b});\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    sort(have[i].begin(), have[i].end());\n    have[i].resize(unique(have[i].begin(), have[i].end()) - have[i].begin());\n    /*cout << \"st \" << i << endl;\n    for (auto p : have[i]) {\n      cout << p.first << ' ' << p.second << endl;\n    }\n    cout << \"ed\\n\";*/\n  }\n  cnt[n][0][0][1] = 1;\n  for (int i = n; i >= 0; --i) {\n    for (int ca = 0; ca <= n; ++ca) {\n      for (int cb = 0; cb <= n; ++cb) {\n        for (int f = 0; f <= 1; ++f) {\n          if (cnt[i][ca][cb][f] == 0) continue;\n          if (f == 1) {\n            if (i > 0) {\n              add(cnt[i - 1][ca][cb][1], cnt[i][ca][cb][1]);\n            }\n            if (i == 0 || s[i - 1] == '0') {\n              add(cnt[i][ca][cb + 1][1], cnt[i][ca][cb][1]);\n              if (i > 0) {\n                add(cnt[i][ca + 1][cb][0], cnt[i][ca][cb][1]);\n              }\n            }\n            if (i == 0 || s[i - 1] == '1') {\n              add(cnt[i][ca + 1][cb][1], cnt[i][ca][cb][1]);\n              if (i > 0) {\n                add(cnt[i][ca][cb + 1][0], cnt[i][ca][cb][1]);\n              }\n            }\n          } else {\n            add(cnt[i][ca + 1][cb][0], cnt[i][ca][cb][0]);\n            add(cnt[i][ca][cb + 1][0], cnt[i][ca][cb][0]);\n          }\n        }\n      }\n    }\n  }\n  vector <vector <bool>> used(n + 1, vector <bool> (n + 1));\n  int ans = 0;\n  int cnt_0 = 0, cnt_1 = 0;\n  for (int i = n; i >= 0; --i) {\n    if (i < n) {\n      if (s[i] == '0') ++cnt_0;\n      else ++cnt_1;\n    } \n    for (auto p : have[i]) {\n      if (used[cnt_0 + p.first][cnt_1 + p.second]) continue;\n      used[cnt_0 + p.first][cnt_1 + p.second] = 1;\n      add(ans, cnt[i][p.first][p.second][0]);\n      add(ans, cnt[i][p.first][p.second][1]);\n      /*cout << p.first << ' ' << p.second << endl;\n      int sz = n - i + p.first + p.second;\n      for (int mask = 0; mask < (1 << sz); ++mask) {\n        string t;\n        for (int i = 0; i < sz; ++i) {\n          if (mask & (1 << i)) {\n            t += '1';\n          } else {\n            t += '0';\n          }\n        }\n        int uk = n - 1;\n        int ha = p.first, hb = p.second;\n        bool bad = false;\n        for (int j = 0; j < (int)t.size(); ++j) {\n          if (uk >= i && s[uk] == t[j]) {\n            --uk;\n            continue;\n          }\n          if (t[j] == '0') {\n            --ha;\n          } else {\n            --hb;\n          }\n        }\n        if (ha == 0 && hb == 0) {\n          cout << \"str \" << t << endl;\n          ++ans;\n        }\n      } */\n    }\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool can[330][330][330];\nMint dp[330][330][330];\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   string S; cin >> S;\n   int N = S.size();\n   for (int i = 0; i < N; ++i) {\n      can[i][0][0] = true;\n      for (int n0 = 0; n0 <= i; ++n0) {\n         for (int n1 = 0; n1 <= i; ++n1) {\n            if (!can[i][n0][n1]) continue;\n            if (i) can[i + 1][n0][n1] = true;\n            if (n0) {\n               int nn0 = n0 - 1 + (S[i] == '0');\n               int nn1 = n1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (n1) {\n               int nn0 = n0 + (S[i] == '0');\n               int nn1 = n1 - 1 + (S[i] == '1');\n               can[i + 1][nn0][nn1] = true;\n            }\n            if (i + 1 < N) {\n               can[i + 2][n0 + (S[i] == '0')][n1 + (S[i] == '1')] = true;\n               can[i + 2][n0 + (S[i + 1] == '0')][n1 + (S[i + 1] == '1')] = true;\n            }\n         }\n      }\n   }\n   can[N][0][0] = false;\n   Mint ans = 0;\n   dp[N][0][0] = 1;\n   for (int i = N; i >= 0; --i) {\n      for (int n0 = 0; n0 <= N; ++n0) {\n         for (int n1 = 0; n1 <= N; ++n1) {\n             if (dp[i][n0][n1].val == 0) continue;\n             //cout<<i<<' '<<n1<<' '<<n0<<' '<<dp[i][n0][n1].val<<endl;\n            if (can[i][n0][n1])\n            {\n                ans += dp[i][n0][n1];\n            }\n            dp[i-1][n0][n1]+=dp[i][n0][n1];\n            if (i > 0)\n            {\n                if(S[i - 1] == '1')\n                    dp[i][n0 + 1][n1] += dp[i][n0][n1];\n                else dp[i][n0][n1 + 1] += dp[i][n0][n1];\n            }\n         }\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n/*\n000110\n6 0 0 1\n6 1 0 1\n6 2 0 1\n6 3 0 1\n6 4 0 1\n6 5 0 1\n6 6 0 1\n5 0 0 1\n5 1 0 1\n5 2 0 1\n5 3 0 1\n5 4 0 1\n5 5 0 1\n5 6 0 1\n5 0 1 1\n5 1 1 1\n5 2 1 1\n5 3 1 1\n5 4 1 1\n5 5 1 1\n5 6 1 1\n5 0 2 1\n5 1 2 1\n5 2 2 1\n5 3 2 1\n5 4 2 1\n5 5 2 1\n5 6 2 1\n5 0 3 1\n5 1 3 1\n5 2 3 1\n5 3 3 1\n5 4 3 1\n5 5 3 1\n5 6 3 1\n5 0 4 1\n5 1 4 1\n5 2 4 1\n5 3 4 1\n5 4 4 1\n5 5 4 1\n5 6 4 1\n5 0 5 1\n5 1 5 1\n5 2 5 1\n5 3 5 1\n5 4 5 1\n5 5 5 1\n5 6 5 1\n5 0 6 1\n5 1 6 1\n5 2 6 1\n5 3 6 1\n5 4 6 1\n5 5 6 1\n5 6 6 1\n4 0 0 1\n4 1 0 1\n4 2 0 1\n4 3 0 1\n4 4 0 1\n4 5 0 1\n4 6 0 1\n4 0 1 2\n4 1 1 2\n4 2 1 2\n4 3 1 2\n4 4 1 2\n4 5 1 2\n4 6 1 2\n4 0 2 3\n4 1 2 3\n4 2 2 3\n4 3 2 3\n4 4 2 3\n4 5 2 3\n4 6 2 3\n4 0 3 4\n4 1 3 4\n4 2 3 4\n4 3 3 4\n4 4 3 4\n4 5 3 4\n4 6 3 4\n4 0 4 5\n4 1 4 5\n4 2 4 5\n4 3 4 5\n4 4 4 5\n4 5 4 5\n4 6 4 5\n4 0 5 6\n4 1 5 6\n4 2 5 6\n4 3 5 6\n4 4 5 6\n4 5 5 6\n4 6 5 6\n4 0 6 7\n4 1 6 7\n4 2 6 7\n4 3 6 7\n4 4 6 7\n4 5 6 7\n4 6 6 7\n3 0 0 1\n3 1 0 2\n3 2 0 3\n3 3 0 4\n3 4 0 5\n3 5 0 6\n3 6 0 7\n3 0 1 2\n3 1 1 4\n3 2 1 6\n3 3 1 8\n3 4 1 10\n3 5 1 12\n3 6 1 14\n3 0 2 3\n3 1 2 6\n3 2 2 9\n3 3 2 12\n3 4 2 15\n3 5 2 18\n3 6 2 21\n3 0 3 4\n3 1 3 8\n3 2 3 12\n3 3 3 16\n3 4 3 20\n3 5 3 24\n3 6 3 28\n3 0 4 5\n3 1 4 10\n3 2 4 15\n3 3 4 20\n3 4 4 25\n3 5 4 30\n3 6 4 35\n3 0 5 6\n3 1 5 12\n3 2 5 18\n3 3 5 24\n3 4 5 30\n3 5 5 36\n3 6 5 42\n3 0 6 7\n3 1 6 14\n3 2 6 21\n3 3 6 28\n3 4 6 35\n3 5 6 42\n3 6 6 49\n2 0 0 1\n2 1 0 3\n2 2 0 6\n2 3 0 10\n2 4 0 15\n2 5 0 21\n2 6 0 28\n2 0 1 2\n2 1 1 6\n2 2 1 12\n2 3 1 20\n2 4 1 30\n2 5 1 42\n2 6 1 56\n2 0 2 3\n2 1 2 9\n2 2 2 18\n2 3 2 30\n2 4 2 45\n2 5 2 63\n2 6 2 84\n2 0 3 4\n2 1 3 12\n2 2 3 24\n2 3 3 40\n2 4 3 60\n2 5 3 84\n2 6 3 112\n2 0 4 5\n2 1 4 15\n2 2 4 30\n2 3 4 50\n2 4 4 75\n2 5 4 105\n2 6 4 140\n2 0 5 6\n2 1 5 18\n2 2 5 36\n2 3 5 60\n2 4 5 90\n2 5 5 126\n2 6 5 168\n2 0 6 7\n2 1 6 21\n2 2 6 42\n2 3 6 70\n2 4 6 105\n2 5 6 147\n2 6 6 196\n1 0 0 1\n1 1 0 4\n1 2 0 10\n1 3 0 20\n1 4 0 35\n1 5 0 56\n1 6 0 84\n1 0 1 2\n1 1 1 8\n1 2 1 20\n1 3 1 40\n1 4 1 70\n1 5 1 112\n1 6 1 168\n1 0 2 3\n1 1 2 12\n1 2 2 30\n1 3 2 60\n1 4 2 105\n1 5 2 168\n1 6 2 252\n1 0 3 4\n1 1 3 16\n1 2 3 40\n1 3 3 80\n1 4 3 140\n1 5 3 224\n1 6 3 336\n1 0 4 5\n1 1 4 20\n1 2 4 50\n1 3 4 100\n1 4 4 175\n1 5 4 280\n1 6 4 420\n1 0 5 6\n1 1 5 24\n1 2 5 60\n1 3 5 120\n1 4 5 210\n1 5 5 336\n1 6 5 504\n1 0 6 7\n1 1 6 28\n1 2 6 70\n1 3 6 140\n1 4 6 245\n1 5 6 392\n1 6 6 588\n0 0 0 1\n0 1 0 4\n0 2 0 10\n0 3 0 20\n0 4 0 35\n0 5 0 56\n0 6 0 84\n0 0 1 2\n0 1 1 8\n0 2 1 20\n0 3 1 40\n0 4 1 70\n0 5 1 112\n0 6 1 168\n0 0 2 3\n0 1 2 12\n0 2 2 30\n0 3 2 60\n0 4 2 105\n0 5 2 168\n0 6 2 252\n0 0 3 4\n0 1 3 16\n0 2 3 40\n0 3 3 80\n0 4 3 140\n0 5 3 224\n0 6 3 336\n0 0 4 5\n0 1 4 20\n0 2 4 50\n0 3 4 100\n0 4 4 175\n0 5 4 280\n0 6 4 420\n0 0 5 6\n0 1 5 24\n0 2 5 60\n0 3 5 120\n0 4 5 210\n0 5 5 336\n0 6 5 504\n0 0 6 7\n0 1 6 28\n0 2 6 70\n0 3 6 140\n0 4 6 245\n0 5 6 392\n0 6 6 588\n*/\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nsim>typename enable_if<is_integral<c>::value,ull>::type my_hash(c x){\n\tif(sizeof(c)>8) return mix((ull)x^SALT)^mix((ull)(x>>64)^SALT);\n\treturn mix(x^SALT);\n}\ntemplate<size_t N>ull my_hash(const bitset<N>&x){\n\treturn mix(hash<bitset<N>>()(x)^SALT);\n}\nsim,class n>ull my_hash(const pair<c,n>&);\nsim>gyv<ull,typename c::value_type>my_hash(const c&x){\n\tull o=SALT;\n\tfor(auto&d:x)o=mix(o^my_hash(d));\n\tros;\n}\nsim,class n>ull my_hash(const pair<c,n>&x){return mix(my_hash(x.first))^my_hash(x.second);}\nsim>struct my_hasher{size_t operator()(const c&o)const{return my_hash(o);}};\nsim, class m>\n#ifdef LOCAL\nusing _un0rDer3d_M4P=unordered_map<c,m,my_hasher<c>>;\nsim> using _un0rDer3d_5et = unordered_set<c, my_hasher<c>>;\n#else\nstruct _un0rDer3d_M4P : public cc_hash_table<c,m,my_hasher<c>>{bool count(const c&x)const{return this->find(x) != this->end();}};\nsim> using _un0rDer3d_5et = _un0rDer3d_M4P<c, null_type>;\n#endif\n#define unordered_map _un0rDer3d_M4P\n#define unordered_set _un0rDer3d_5et\nconst int nax = 384, mod = 119 << 23 | 1;\nchar str[nax];\nint n;\nbool seen[nax][nax][nax];\nvoid go(int pos, int zeros, int ones) {\n\tif (seen[pos][zeros][ones]) return;\n\t// debug(str + pos, imie(zeros), imie(ones));\n\tseen[pos][zeros][ones] = true;\n\tif (zeros) go(pos, zeros - 1, ones);\n\tif (ones) go(pos, zeros, ones - 1);\n\tif ((zeros || ones) && pos + 1 <= n) go(pos + 1, zeros, ones);\n\tif (pos + 2 <= n && (str[pos] == '1' || str[pos + 1] == '1')) go(pos + 2, zeros, ones + 1);\n\tif (pos + 2 <= n && (str[pos] == '0' || str[pos + 1] == '0')) go(pos + 2, zeros + 1, ones);\n\tif (zeros && str[pos] == '1') go(pos + 1, zeros - 1, ones + 1);\n\tif (ones && str[pos] == '0') go(pos + 1, zeros + 1, ones - 1);\n}\nll dp[nax][nax][nax];\nint main() {\n\tscanf(\"%s\", str);\n\tn = strlen(str);\n\tgo(0, 0, 0);\n\tdp[n][0][0] = 1;\n\tfor (int i = n - 1; i >= 0; --i) for (int zeros = 0; zeros <= n; ++zeros) for (int ones = 0; ones <= n; ++ones) {\n\t\tif (!dp[i + 1][zeros][ones]) continue;\n\t\t// debug(arr(dp, i + 1, zeros, ones));\n\t\tint v = str[i] - '0';\n\t\t(dp[i][zeros][ones] += dp[i + 1][zeros][ones]) %= mod;\n\t\tif (v == 1) (dp[i + 1][zeros + 1][ones] += dp[i + 1][zeros][ones]) %= mod;\n\t\tif (v == 0) (dp[i + 1][zeros][ones + 1] += dp[i + 1][zeros][ones]) %= mod;\n\t}\n\tll can = 0;\n\tREP(i, n + 1) REP(j, n + 1) REP(k, n + 1) if (seen[i][j][k]) can += dp[i][j][k];\n\tcan %= mod;\n\tprintf(\"%lld\\n\", fix(can, mod));\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n\tfwrite(buf, 1, _bl, stdout);\n\t_bl = 0;\n}\n__inline void _putchar(char c) {\n\tif(_bl == _B) flush();\n\tbuf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n\tstatic char tmp[20];\n\tint l = 0;\n\tif(!x) tmp[l++] = '0';\n\telse {\n\t\twhile(x) {\n\t\t\ttmp[l++] = x % 10 + '0';\n\t\t\tx /= 10;\n\t\t}\n\t}\n\tfor(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n\t_putchar(c);\n}\nconst int N = 303;\nconst int LOG = 20;\nconst int mod = 998244353;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nbitset<N> f[N][N][N];\nint dp[N][N][N];\nint a[N], c0[N], c1[N];\n__inline void add(int & a, int b) {\n\tif((a += b) >= mod) a -= mod;\n}\nint vst[N * 2][N * 2];\nint main() {\n\tstring s;\n\tcin >> s;\n//s.clear();\n//for(int i = 0; i < 300; i++) s.pb(gene() % 2 + '0');\n\tn = s.size();\n\tfor(int i = 1; i <= n; i++) {\n\t\ta[i] = s[i - 1] - '0';\n\t\tc0[i] = c0[i - 1] + (a[i] == 0);\n\t\tc1[i] = c1[i - 1] + (a[i] == 1);\n\t}\n\tf[0][0][0].set(0);\n\tfor(int i = 0; i <= n; i++) {\n\t\tfor(int j = 0; j <= c0[i]; j++) {\n\t\t\tfor(int k = 0; k <= c1[i]; k++) {\n\t\t\t\tif(i + 2 <= n) {\n\t\t\t\t\tf[i + 2][j][k] |= f[i][j][k] << 1;\n\t\t\t\t\tif(!a[i + 2] || !a[i + 1]) {\n\t\t\t\t\t\tf[i + 2][j + 1][k] |= f[i][j][k];\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif(a[i + 2] || a[i + 1]) {\n\t\t\t\t\t\tf[i + 2][j][k + 1] |= f[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i + 1 <= n) {\n\t\t\t\t\tif(i != 0) f[i + 1][j][k] |= f[i][j][k];\n\t\t\t\t\tif(a[i + 1] == 0) \n\t\t\t\t\t\tf[i + 1][j + 1][k] |= f[i][j][k] >> 1;\n\t\t\t\t\telse f[i + 1][j][k + 1] |= f[i][j][k] >> 1;\n\t\t\t\t}\n\t\t\t//\tprintf(\"%d %d %d: \", i, j, k);\n\t\t\t//\tcout << f[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tdp[n + 1][0][0] = 1;\n\tfor(int i = n; i >= 1; i--) {\n\t\tif(a[i] == 0) {\n\t\t\tfor(int j = 0; j <= n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int k = 0; k <= n; k++) {\n\t\t\t\t\tadd(sum, dp[i + 1][j][k]);\n\t\t\t\t\tadd(dp[i][j][k], sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}else {\n\t\t\tfor(int j = 0; j <= n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int k = 0; k <= n; k++) {\n\t\t\t\t\tadd(sum, dp[i + 1][k][j]);\n\t\t\t\t\tadd(dp[i][k][j], sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = n + 1; i >= 0; i--) {\n\t\tfor(int j = 0; j <= n; j++) {\n\t\t\tfor(int k = 0; k <= n; k++) {\n\t\t\t\tif(j) add(dp[i][j][k], dp[i][j - 1][k]);\n\t\t\t\tif(k) add(dp[i][j][k], dp[i][j][k - 1]);\n\t\t\t//\tprintf(\"dp[%d][%d][%d] = %d\\n\", i, j, k, dp[i][j][k]);\n\t\t\t\tif(f[i - 1][j][k][0]) {\n\t\t\t\t\tif(!vst[c0[n] - c0[i - 1] + j][c1[n] - c1[i - 1] + k]) {\n\t\t\t\t\t\tadd(ans, dp[i][j][k]);\n\t\t\t\t\t\tvst[c0[n] - c0[i - 1] + j][c1[n] - c1[i - 1] + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#define MOD 998244353\n#define forn(a, n) for(int a = 0; a<(int) (n); ++a)\n#define dforn(a, n) for(int a = (n)-1; a>=0; --a)\n#define forall(a, all) for(__typeof(all.begin()) a = all.begin(); a != all.end(); ++a)\n#define EPS 0.000000000001\nusing namespace std;\ntypedef long long tint;\ntypedef pair<tint, tint> pii;\ntypedef vector<tint> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a%b) : a;\n}\n\nvoid dfs(int voy, int ceros, int unos, string s, vvvi &reach) {\n\t//cout << voy << \" \" << ceros << \" \" << unos << endl;\n\tif(reach[voy][ceros][unos]) {\n\t\treturn;\n\t}\n\treach[voy][ceros][unos] = 1;\n\t\n\tint n = s.size();\n\tif(n - voy >= 2) {\n\t\tif(s[voy] == '0' || s[voy+1] == '0') {\n\t\t\tdfs(voy+2, ceros+1, unos, s, reach);\n\t\t}\n\t\tif(s[voy] == '1' || s[voy+1] == '1') {\n\t\t\tdfs(voy+2, ceros, unos+1, s, reach);\n\t\t}\n\t}\n\t\n\tif(n - voy >= 1) {\n\t\tif(ceros) dfs(voy, ceros-1, unos, s, reach);\n\t\tif(unos) dfs(voy, ceros, unos-1, s, reach);\n\t\tif(ceros && s[voy] == '1') dfs(voy+1, ceros-1, unos+1, s, reach);\n\t\tif(unos && s[voy] == '0') dfs(voy+1, ceros+1, unos-1, s, reach);\n\t\tif(ceros || unos || n-voy >= 2) dfs(voy+1, ceros, unos, s, reach);\n\t}\n\t\n\tif(ceros+unos >=2) {\n\t\tif(ceros) dfs(voy, ceros-1, unos, s, reach);\n\t\tif(unos) dfs(voy, ceros, unos-1, s, reach);\n\t}\n}\n\ntint solvedp(int voy, int ceros, int unos, string s, vvvi &dp) {\n\tint n = s.size();\n\tif(voy == n+1) {\n\t\treturn ceros == 0 && unos == 0;\n\t}\n\t\n\tif(dp[voy][ceros][unos] != -1) {\n\t\treturn dp[voy][ceros][unos];\n\t}\n\t\n\ttint ans = 0;\n\tif(s[voy-1] == '1' && ceros) {\n\t\tans += solvedp(voy, ceros-1, unos, s, dp);\n\t}\n\tif(s[voy-1] == '0' && unos) {\n\t\tans += solvedp(voy, ceros, unos-1, s, dp);\n\t}\n\tans += solvedp(voy+1, ceros, unos, s, dp);\n\tans %= MOD;\n\tdp[voy][ceros][unos] = ans;\n\treturn ans;\n}\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\ttint n = s.size();\n\t\n\tvvvi reach(n+1, vvi(n, vi(n, 0)));\n\tvvvi dp(n+1, vvi(n, vi(n, -1)));\n\tdfs(0, 0, 0, s, reach);\n\t\n\ttint ans = 0;\n\tforn(i, n+1) forn(j, n) forn(k, n) {\n\t\tif(reach[i][j][k]) {\n\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << solvedp(i, j, k, s, dp) << \" \" << endl;\n\t\t\tans += solvedp(i, j, k, s, dp);\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc046/tasks/agc046_d\n#define CIN_ONLY\n#define DECIMAL_DIGITS 10\n#define STATIC_MOD 998244353\n\n#ifdef BTK\n/*<head>*/\n#    include \"Template.hpp\"\n#    include \"num/ModInt.hpp\"\n/*</head>*/\n#else\n/*<body>*/\n/* #region auto includes */\n/* #region stl */\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/Grid.hpp*/\n\n/**\n * @brief グリッドをラップするための関数\n * @tparam T std::string や std;:vector を想定\n * @tparam U 周りに配置する要素の型\n * @param grid 入力、R > 0 でないとバグる\n * @param material 周りに配置する要素\n * @return std::vector<T> material で 周りを埋めた grid\n */\ntemplate <typename T, typename U>\ninline std::vector<T> wrapGrid(std::vector<T> grid, U material) {\n    std::vector<T> wrappedGrid(grid.size() + 2,\n                               T(grid[0].size() + 2, material));\n    for (std::size_t i = 0; i < grid.size(); i++) {\n        for (std::size_t j = 0; j < grid[i].size(); j++) {\n            wrappedGrid[i + 1][j + 1] = grid[i][j];\n        }\n    }\n    return wrappedGrid;\n}\n\n/**\n * @brief\n *\n */\nconstexpr int dr4[] = {0, 1, 0, -1};\nconstexpr int dc4[] = {-1, 0, 1, 0};\n/* #endregion */\n/* #region template/IncludeSTL.hpp*/\n/**\n * @file IncludeSTL.hpp\n * @author btk\n * @brief 標準ライブラリをincludeするだけ\n * @version 0.1\n * @date 2019-07-21\n * @todo 何故か2回includeされる（展開scriptに\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/* #endregion */\n/* #region template/Macro.hpp*/\n/**\n * @file Macro.hpp\n * @author btk\n * @brief マクロとか，LLとか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n//! LL\nusing LL = long long;\n\n/**\n * @def DEBUG\n * @brief デバッグ用のif文 提出時はif(0)で実行されない\n */\n\n/*</head>*/\n#    ifdef BTK\n#        define DEBUG if (1)\n#    else\n#        ifdef CIN_ONLY\n#            define FAST_IO\n#        endif\n#        define DEBUG if (0)\n#    endif\n/**\n * @def ALL(v)\n * @brief\n * ALLマクロ\n */\n#    define ALL(v) (v).begin(), (v).end()\n\n/**\n * @def REC(ret, ...)\n * @brief\n * 再帰ラムダをするためのマクロ\n */\n#    define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n\n/**\n * @def VAR_NAME(var)\n * @brief 変数名を取得する\n */\n#    define VAR_NAME(var) #    var\n\n/**\n * @brief\n * rangeで生まれる使わない変数を消す用（警告消し）\n */\ntemplate <typename T>\ninline T& unused_var(T& v) {\n    return v;\n}\n\ntemplate <typename T>\nstd::vector<T> nestingVector(std::size_t size) {\n    return std::vector<T>(size);\n}\n\ntemplate <typename T, typename... Ts>\ninline auto nestingVector(std::size_t size, Ts... ts) {\n    return std::vector<decltype(nestingVector<T>(ts...))>(\n        size, nestingVector<T>(ts...));\n}\n/* #endregion */\n/* #region template/IO.hpp*/\n/**\n * @file IO.hpp\n * @author btk\n * @brief cin高速化とか，出力の小数桁固定とか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n */\n\n\n/**\n * @brief 入出力の設定を行うための構造体\n */\nstruct cww {\n    /**\n     * @brief Construct a new cww::cww object\n     * @details\n     * CIN_ONLYを定義すると，submit時にcinとscanfの同期を切る設定が走る\n     * DECIMAL_DIGITSを定義すると，doubleの出力時指定した桁数分小数部を吐くようになる\n     */\n    cww() {\n#    ifdef FAST_IO\n        std::ios::sync_with_stdio(false);\n        std::cin.tie(0);\n#    endif\n#    ifdef DECIMAL_DIGITS\n        std::cout << std::fixed;\n        std::cout << std::setprecision(DECIMAL_DIGITS);\n#    endif\n    }\n};\n\n//! 入出力設定構造体を実体化\ncww star;\n\n/**\n * @brief\n * vectorに直接cin流すためのやつ\n * @tparam T\n * @param is\n * @param v\n * @return istream&\n */\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n    for (auto& it : v) is >> it;\n    return is;\n}\n/* #endregion */\n/* #region template/Loop.hpp*/\n/**\n * @file Loop.hpp\n * @author btk\n * @brief rangeとかループ系のクラス\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/**\n * @brief\n * rangeを逆向きに操作したいとき用\n * @details\n * ループの範囲は[bg,ed)なので注意\n * @see range\n */\nclass reverse_range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x - 1; }\n        bool operator!=(I& lhs) { return x > lhs.x; }\n        void operator++() { --x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param n\n     */\n    reverse_range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param i\n     * @param n\n     */\n    reverse_range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return n; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return i; }\n};\n/**\n * @brief\n * python みたいな range-based for を実現\n * @details\n * ループの範囲は[bg,ed)なので注意\n * !つけると逆向きにループが回る (reverse_range)\n * 空間計算量はO(1)\n * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n */\nclass range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I& lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new range object\n     *\n     * @param n\n     */\n    range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new range object\n     *\n     * @param i\n     * @param n\n     */\n    range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return i; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return n; }\n    /**\n     * @brief\n     * 逆向きに参照するrange(reverse_rangeを取得できるs)\n     * @return reverse_range\n     */\n    reverse_range operator!() { return reverse_range(*i, *n); }\n};\n/* #endregion */\n/* #region template/Math.hpp*/\n\n/**\n * @brief gcd, ceil等自作算数用関数を集める。stdと被るので名前空間を区切る\n */\nnamespace math {\n\n    /**\n     * @brief aとｂの最大公約数\n     * @param a int64\n     * @param b int64\n     * @return int64 最大公約数\n     */\n    int64_t gcd(int64_t a, int64_t b) { return (b == 0) ? a : gcd(b, a % b); }\n\n    /**\n     * @brief aとｂの最小公倍数\n     * @param a int64\n     * @param b int64\n     * @return int64 最小公倍数\n     */\n    int64_t lcm(int64_t a, int64_t b) { return (a / gcd(a, b)) * b; }\n\n\n    /**\n     * @brief 拡張ユークリッド互除法\n     * @details ax + by = gとなるx,yを求める\n     * @param a 入力\n     * @param b 入力\n     * @param x 値引き継ぎ用の変数\n     * @param y 値引き継ぎ用の変数\n     * @return int64_t g:aとbの最大公約数\n     */\n    int64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y) {\n        int64_t g = a;\n        x         = 1;\n        y         = 0;\n        if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n        return g;\n    }\n\n    /**\n     * @brief u/dを切り上げした整数を求める\n     * @todo 負の数への対応\n     * @tparam T 整数型\n     * @param u 入力\n     * @param d 入力\n     * @return T 切り上げ後の値\n     */\n    template <typename T>\n    inline T ceil(T u, T d) {\n        return (u + d - (T)1) / d;\n    }\n\n} // namespace math\n/* #endregion */\n/* #region template/MinMaxOperation.hpp*/\n/**\n * @file MinMaxOperation.hpp\n * @author btk\n * @brief 最大値とか最小値を求める\n * @version 0.1\n * @date 2019-07-04\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/**\n * @brief 2項の最小値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct min_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l < r ? l : r; }\n};\n\n/**\n * @brief 2項の最大値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct max_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l > r ? l : r; }\n};\n\n/**\n * @brief テンプレート再帰の末尾\n *\n * @tparam F 二項演算\n * @tparam T\n * @param v\n * @return T\n */\ntemplate <typename F, typename T>\ninline T multi_op(T&& v) {\n    return v;\n}\n\n/**\n * @brief 複数項における演算の結果を返す\n *\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename F, typename T, typename... Ts>\ninline T multi_op(const T head, Ts&&... tail) {\n    return F::exec(head, multi_op<F>(tail...));\n}\n\n/**\n * @brief 複数項の最小値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_min(T head, Ts... tail) {\n    return multi_op<min_op<T>>(head, tail...);\n}\n\n/**\n * @brief 複数項の最大値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_max(T head, Ts... tail) {\n    return multi_op<max_op<T>>(head, tail...);\n}\n\n/**\n * @brief\n * \b先頭の値をFで参照する関数に基づいて変更できたらする\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param target\n * @param candidates\n * @return true\n * @return false\n */\ntemplate <typename F, typename T, typename... Ts>\ninline bool ch_op(T& target, Ts&&... candidates) {\n    const T old = target;\n    target      = multi_op<F>(target, candidates...);\n    return old != target;\n}\n\n/**\n * @brief change min\n * @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmin(T& target, Ts&&... candidates) {\n    return ch_op<min_op<T>>(target, candidates...);\n}\n\n/**\n * @brief chminのmax版\n * @see chmin\n *  @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmax(T& target, Ts&&... candidates) {\n    return ch_op<max_op<T>>(target, candidates...);\n}\n/* #endregion */\n/* #region template/Random.hpp*/\n/**\n * @file Random.hpp\n * @author btk\n * @brief 乱数生成系\n * @version 0.1\n * @date 2019-07-13\n * @copyright Copyright (c) 2019\n */\n\n\n//! 乱数のシード値をプロセスIDとして取得\nconst pid_t pid = getpid();\n\n/**\n * @brief XorShift32の実装\n */\nclass XorShift32 {\n  private:\n    //! XorShiftの現在の値\n    unsigned value;\n\n    /**\n     * @brief XorShift32のアルゴリズムに基づいて value を更新\n     */\n    inline void update() {\n        value = value ^ (value << 13);\n        value = value ^ (value >> 17);\n        value = value ^ (value << 5);\n    }\n\n    /**\n     * @brief 値を更新し，更新前の値を返却\n     * @return unsigned 呼び出し時の value を用いる\n     */\n    inline unsigned get() {\n        unsigned v = value;\n        update();\n        return v;\n    }\n\n  public:\n    /**\n     * @brief [0, 2^bit) の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_int() {\n        return (int)(get() >> (32 - bit));\n    }\n\n    /**\n     * @brief [-2^bit,2^bit)の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_signed() {\n        unsigned v = get();\n        return (int)((v >> (31 - bit)) - (1 << (bit)));\n    }\n\n    /**\n     * @brief next_int呼び出し時の最大値を取得\n     * @tparam 31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int range_max() {\n        return (int)((1u << bit) - 1);\n    };\n\n    /**\n     * @brief Construct a new XorShift32 object\n     * @param seed\n     * @details 初期シードをvalueとするXorShift32のインスタンスを生成\n     */\n    XorShift32(const unsigned seed) {\n        value = seed;\n        update();\n    }\n\n    /**\n     * @brief Construct a new XorShift 32 object\n     * @details 初期シードをプロセスIDとするXorShift32のインスタンスを生成\n     */\n    XorShift32() : XorShift32(pid) {}\n};\n/* #endregion */\n/* #region template/Strings.hpp*/\n/**\n * @file Strings.hpp\n * @author btk\n * @brief 文字列を扱いやすくするライブラリ\n * @version 0.1\n * @date 2020-02-02\n *\n * @copyright Copyright (c) 2020\n *\n */\n\n\n/**\n * @brief コレクションを文字列に変換する関数\n * @tparam T コレクションの型、range-based for に対応している必要あり\n * @tparam U 区切り文字の型\n * @param v コレクション\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename T, typename U>\nstd::string join(const T& v, const U delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto& it : v) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << it;\n    }\n    return ss.str();\n}\n\n/**\n * @brief コレクションを文字列に変換する関数（イテレータ版）\n * @tparam ITR イテレータ型\n * @tparam T 区切り文字の型\n * @param bg 開始\n * @param ed 終了\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename ITR, typename T>\nstd::string join(const ITR bg, const ITR ed, const T delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto it = bg; it != ed; ++it) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << *it;\n    }\n    return ss.str();\n}\n/* #endregion */\n/* #region Template.hpp*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n\n\n/* #endregion */\n/* #region num/ModInt.hpp*/\n\n#    include <utility>\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @details\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\n#    ifdef STATIC_MOD\nconstexpr int mod = STATIC_MOD;\n#    else\nint mod;\n#    endif\n\n/**\n * @brief mod構造体\n * @details\n * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n */\nclass ModInt {\n  private:\n    //! 中身\n    int x;\n\n  public:\n    /**\n     * @brief ゲッター\n     * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n     */\n    long long operator*() const { return x; }\n    /**\n     * @brief デフォルトコンストラクタ．0で初期化される．\n     */\n    ModInt() { x = 0; }\n\n    /**\n     * @brief intからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt(const int y) { x = y; }\n\n    /**\n     * @brief long longからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details 毎回modを取るので低速．\n     */\n    ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt(const ModInt& o) { this->x = *o; }\n    /**\n     * @brief 整数から高速にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details xが[0,mod)であることが保証されてないと正しく動かない．\n     */\n    static inline ModInt raw(const long long x) {\n        // assert(x<mod);\n        return ModInt((int)x);\n    }\n\n    /**\n     * @brief 整数から安全にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    static inline ModInt get(const long long x) { return ModInt(x); }\n\n    /**\n     * @brief intからの代入演算子\n     * @param[in] o 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt& operator=(const int o) {\n        this->x = o >= mod ? o - mod : o;\n        return *this;\n    }\n\n    /**\n     * @brief long longからの代入演算子\n     * @param[in] o 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    ModInt& operator=(const long long o) {\n        this->x = (int)((mod + o % mod) % mod);\n        return *this;\n    }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt& operator=(const ModInt o) {\n        this->x = *o;\n        return *this;\n    }\n};\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n * @details if文使って少し高速化．\n */\ninline ModInt add(const ModInt l, const ModInt r) {\n    const long long x = *l + *r;\n    return ModInt::raw(x >= mod ? x - mod : x);\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt．\n */\ninline ModInt mul(const ModInt l, const ModInt r) {\n    return ModInt::raw(*l * *r % mod);\n}\n\n/**\n * @brief a^x %modを求める\n * @param[in] a ModInt\n * @param[in] x long long．\n */\ninline ModInt pow(ModInt a, long long x) {\n    ModInt ret = ModInt::raw(1);\n    while (x) {\n        if (x & 1) {\n            ret = mul(ret, a);\n        }\n        a = mul(a, a);\n        x >>= 1;\n    }\n    return ret;\n}\n\n/**\n * @brief x^-1 %modを求める\n * @param[in] x ModInt．\n * @details\n *   内部ではユークリッドの拡張互助法を使っている．\n *   O(log(mod))\n */\ninline ModInt inv(const ModInt x) {\n    long long a = *x, b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        std::swap(a -= t * b, b);\n        std::swap(u -= t * v, v);\n    }\n    return ModInt::get(u);\n}\n\n/**\n * @brief 負数を求める単項演算子\n * @param[in] x ModInt\n */\ninline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator+(const ModInt l, const ModInt r) { return add(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator*(const ModInt l, const ModInt r) { return mul(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator-(const ModInt l, const ModInt r) { return add(l, -r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator+(const ModInt l, const int r) {\n    return add(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator+(const ModInt l, const long long r) {\n    return add(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator*(const ModInt l, const int r) {\n    return mul(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator*(const ModInt l, const long long r) {\n    return mul(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator-(const ModInt l, const int r) {\n    return add(l, ModInt::raw(mod - r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator-(const ModInt l, const long long r) {\n    return add(l, -ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator/(const ModInt l, const int r) {\n    return mul(l, inv(ModInt::raw(r)));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator/(const ModInt l, const long long r) {\n    return mul(l, inv(ModInt::get(r)));\n}\n\n/**\n* @param[in] l ModInt\n* @param[in] r long long\n* @details\n*   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n計算量はO(log mod)\n*/\ninline ModInt operator^(const ModInt l, const long long r) { return pow(l, r); }\n\n/**\n * @brief\n * +=の実装、各operator+を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 足すやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator+=(ModInt& l, T r) {\n    l = l + r;\n    return l;\n}\n\n/**\n * @brief\n * -=の実装、各operator-を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 引くやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator-=(ModInt& l, T r) {\n    l = l - r;\n    return l;\n}\n\n/**\n * @brief\n * *=の実装、各operator*を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r かけるやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator*=(ModInt& l, T r) {\n    l = l * r;\n    return l;\n}\n\n/**\n * @namespace factorial\n * @brief 順列数関連の関数のまとめ\n * @details\n *   - combination\n *   - permutation\n *   - multiChoose\n */\nnamespace factorial {\n    //! 順列数を格納する配列のサイズ\n    constexpr int size =\n#    ifdef FACTORIAL_SIZE\n        FACTORIAL_SIZE;\n#    else\n        3123456;\n#    endif\n    //! 前計算ができているかどうかのフラグ\n    bool is_build = false;\n\n    //! 順列数を格納する配列\n    ModInt factorial[size];\n    //! (順列数)^-1を格納する配列\n    ModInt inverse_factorial[size];\n\n    /**\n     * @brief 順列数の前計算\n     * @details\n     *   順列数と，その逆元を[0,size)まで求める.\n     *   計算量は，O(size + log(mod))\n     */\n    void build() {\n        is_build     = true;\n        factorial[0] = 1;\n        for (int i = 1; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inverse_factorial[size - 1] = inv(factorial[size - 1]);\n        for (int i = size - 1; i >= 1; i--) {\n            inverse_factorial[i - 1] = inverse_factorial[i] * i;\n        }\n    }\n\n    /**\n     * @brief nPkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt permutation(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief nCkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt combination(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[k] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief 重複組合せ\n     * @param n 何種類のものを (仕切りがn-1個)\n     * @param r いくつ並べるか\n     * @return ModInt nHr\n     */\n    ModInt multiChoose(int n, int r) {\n        if (n == 0 && r == 0) return ModInt::raw(1);\n        return combination(n + r - 1, r);\n    }\n\n    /**\n     * @brief 上限付き重複組合せ\n     * @details\n     * 包除原理を用いて，lim個以上の品物が1,2,...,i種類の場合を足したり引いたりしていく\n     * 計算量は O(min(n, r / lim))\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @param lim 1種類のものを選べる上限\n     * @return ModInt\n     */\n    ModInt multiChoose(int n, int r, int lim) {\n        ModInt ret = 0;\n        for (int i = 0; i <= n; i++) {\n            if (i * (lim + 1) > r) break;\n            ret += ((i & 1) ? mod - 1 : 1) * combination(n, i)\n                   * multiChoose(n, r - i * (lim + 1));\n        }\n        return ret;\n    }\n\n} // namespace factorial\n  /* #endregion */\n  /* #endregion */\n  /*</body>*/\n#endif\n\n// k回操作したとき、消える1/2個は手前のk個から選ばれる\n// かつ、2i回目までの時点で、必ず手前i個が消されている\n// 残りの列がa個残っている場合、残った0,1をうまく組み合わせてできる文字列の数を列挙\n// どうやるの？dp[i][0の個数][1の個数]を解く\n// これではだめで、重複が除去しきれてない\n\nusing V   = vector<bool>;\nusing VV  = vector<V>;\nusing VM  = vector<ModInt>;\nusing VVM = vector<VM>;\nint n;\nint v[312];\nint sum[312][2];\n\nbool ok[312][312][312];\n\nModInt dp[312][312][312];\n\nvoid solve() {\n    ok[0][0][0] = true;\n\n    for (int i : range(n)) {\n        for (int r0 : !range(n + 1)) {\n            for (int r1 : !range(n + 1)) {\n                if (!ok[i][r0][r1]) continue;\n                if (i + 1 < n) {\n                    if (v[i] == 0 || v[i + 1] == 0) {\n                        ok[i + 2][r0 + 1][r1] = true;\n                    }\n                    if (v[i] == 1 || v[i + 1] == 1) {\n                        ok[i + 2][r0][r1 + 1] = true;\n                    }\n                }\n                ok[i + 1][r0][r1] = true;\n                const int is0     = v[i] == 0 ? 1 : 0;\n                const int is1     = 1 - is0;\n                if (r0 >= 1) ok[i + 1][r0 - 1 + is0][r1 + is1] = true;\n                if (r1 >= 1) ok[i + 1][r0 + is0][r1 - 1 + is1] = true;\n                // if (r0 >= 2) ok[i][r0 - 1][r1] = true;\n                // if (r1 >= 2) ok[i][r0][r1 - 1] = true;\n                // if (r0 >= 1 && r1 >= 1) {\n                //     ok[i][r0][r1 - 1] = true;\n                //     ok[i][r0 - 1][r1] = true;\n                // }\n            }\n        }\n    }\n\n    dp[n][0][0] = 1;\n    for (int i : !range(n + 1)) {\n        for (int r0 : range(n + 1)) {\n            for (int r1 : range(n + 1)) {\n                // 0を使う場合\n                if (i - 1 >= 0 && v[i - 1] == 0) {\n                    dp[i - 1][r0][r1] += dp[i][r0][r1];\n                }\n                else {\n                    dp[i][r0 + 1][r1] += dp[i][r0][r1];\n                }\n\n\n                // 1を使う場合\n                if (i - 1 >= 0 && v[i - 1] == 1) {\n                    dp[i - 1][r0][r1] += dp[i][r0][r1];\n                }\n                else {\n                    dp[i][r0][r1 + 1] += dp[i][r0][r1];\n                }\n            }\n        }\n    }\n    ModInt ret = 0;\n    for (int i : range(n + 1)) {\n        for (int j : range(n + 1)) {\n            for (int k : range(n + 1)) {\n                if (ok[i][j][k]) {\n                    ret += dp[i][j][k];\n                }\n            }\n        }\n    }\n    ret -= 1;\n    cout << *ret << endl;\n}\n\n\nint main() {\n    /* write here */\n    string s;\n    cin >> s;\n    n = s.size();\n    for (int i : range(n)) {\n        v[i] = s[i] - '0';\n        sum[i + 1][v[i]]++;\n        sum[i + 1][0] += sum[i][0];\n        sum[i + 1][1] += sum[i][1];\n    }\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=305,INF=1<<30;\nbool dp[MAX][MAX][MAX];\nll dp2[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    string S;cin>>S;\n    int N=si(S);\n    dp[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=N;j>=0;j--){\n            for(int k=N;k>=0;k--){\n                if(dp[i][j][k]==0) continue;\n                \n                if(i+1<N){\n                    if(S[i]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    if(S[i+1]=='0') dp[i+2][j+1][k]=1;\n                    else dp[i+2][j][k+1]=1;\n                    \n                    dp[i+1][j][k]=1;\n                }\n                \n                if(j&&S[i]=='1') dp[i+1][j-1][k+1]=1;\n                \n                if(k&&S[i]=='0') dp[i+1][j+1][k-1]=1;\n                \n                if(j||k) dp[i+1][j][k]=1;\n                \n                if(j) dp[i][j-1][k]=1;\n                \n                if(k) dp[i][j][k-1]=1;\n            }\n        }\n    }\n    \n    reverse(all(S));\n    \n    dp2[0][0][0]=1;\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(S[i]=='0'){\n                    dp2[i][j][k+1]+=dp2[i][j][k];\n                    dp2[i][j][k+1]%=mod;\n                }else{\n                    dp2[i][j+1][k]+=dp2[i][j][k];\n                    dp2[i][j+1][k]%=mod;\n                }\n                dp2[i+1][j][k]+=dp2[i][j][k];\n                dp2[i+1][j][k]%=mod;\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=0;i<=N;i++){\n        for(int j=0;j<=N;j++){\n            for(int k=0;k<=N;k++){\n                if(dp[i][j][k]){\n                    ans+=dp2[N-i][j][k];\n                }\n                ans%=mod;\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ninline int topbit(unsigned long long x){\n\treturn x?63-__builtin_clzll(x):-1;\n}\n\ninline int popcount(unsigned long long x){\n\treturn __builtin_popcountll(x);\n}\n\ninline int parity(unsigned long long x){\n\treturn __builtin_parity(x);\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[k]*finvs[n-k];\n\t}\n\tinline Mint perm(int n,int k)const{\n\t\tif(n<0||k<0||k>n)return 0;\n\t\treturn facts[n]*finvs[n-k];\n\t}\n\tinline Mint catalan(int n){\n\t\treturn facts[2*n]*finvs[n+1]*finvs[n];\n\t}\n};\nModIntTable<mint,20>mt;\n\nint N;\nstring S;\n\n\nbool ex[333][333][333];\nint sufcnt0[333];\n\n\n\nsigned main(){\n\tcin>>S;\n\tN=S.size();\n\tex[0][0][0]=true;\n\tsufcnt0[N]=0;\n\tfor(int i=N-1;i>=0;i--){\n\t\tsufcnt0[i]=sufcnt0[i+1];\n\t\tif(S[i]=='0')sufcnt0[i]++;\n\t}\n\trep(i,N+1){\n\t\tfor(int j=N;j>=0;j--){\n\t\t\tfor(int k=N;k>=0;k--){\n\t\t\t\tif(!ex[i][j][k])continue;\n\t\t\t\tif(i+2<=N){\n\t\t\t\t\trep(l,2)ex[i+2][j+1-(S[i+l]-'0')][k+(S[i+l]-'0')]=true;\n\t\t\t\t}\n\t\t\t\tif(j+k&&i+1<=N){\n\t\t\t\t\tex[i+1][j][k]=true;\n\t\t\t\t\tif(j)ex[i+1][j-1+1-(S[i]-'0')][k+(S[i]-'0')]=true;\n\t\t\t\t\tif(k)ex[i+1][j+1-(S[i]-'0')][k-1+(S[i]-'0')]=true;\n\t\t\t\t}\n\t\t\t\tif(j+k>=2){\n\t\t\t\t\tif(j)ex[i][j-1][k]=true;\n\t\t\t\t\tex[i][j][k-1]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<pint,int>ma;\n\trep(i,N+1)rep(j,N+1)rep(k,N+1)if(ex[i][j][k]){\n\t\tint cnt0=j+sufcnt0[i];\n\t\tint cnt1=k+N-i-sufcnt0[i];\n\n\t\tpint p(cnt0,cnt1);\n\t\tif(ma.find(p)==ma.end())ma[p]=i;\n\t\telse chmax(ma[p],i);\n\t}\n\tmint ans=0;\n\tfor(auto &p:ma){\n\t\tint cnt0=p.fi.fi;\n\t\tint cnt1=p.fi.se;\n\t\tint i=p.se;\n\n\t\tint j=cnt0-sufcnt0[i];\n\t\tint k=cnt1-(N-i)+sufcnt0[i];\n\n\t\tfor(int z=0;z<=j;z++){\n\t\t\tmint tmp=1;\n\t\t\tif(z)tmp*=mt.binom(z+(N-i-sufcnt0[i])-1,z);\n\t\t\ttmp*=mt.binom(k+sufcnt0[i]+(j-z),k);\n\t\t\tans+=tmp;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&& i:a)\n#define each2(x,y,a) for(auto&& [x,y]:a)\n#define each3(x,y,z,a) for(auto&& [x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<uint> divisor(uint x){ vector<uint> ans; for(uint i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nconstexpr uint mod = MODD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nconst int N=301;\nbool dp[N+2][N+2][N+2];\nsigned main(){\n    STR(s);\n    ll n=s.size();\n    dp[0][0][0]=1;\n    rep(n+1){\n        if(i)rep(j,N)rrep(k,N)if(dp[i-1][j][k])dp[i][j][k]=1;\n        if(i<s.size()){\n        if(s[i]=='0'){\n            rep(j,N)rep(k,N)if(dp[i][j][k+1])dp[i+1][j+1][k]=1;\n            if(i)rep(j,N)rep(k,N)if(dp[i-1][j][k])dp[i+1][j+1][k]=1;\n            if(i<N)rep(j,N)rep(k,N)if(dp[i][j][k])dp[i+2][j+1][k]=1;\n        }\n        else{\n            rep(j,N)rep(k,N)if(dp[i][j+1][k])dp[i+1][j][k+1]=1;\n            if(i)rep(j,N)rep(k,N)if(dp[i-1][j][k])dp[i+1][j][k+1]=1;\n            if(i<N)rep(j,N)rep(k,N)if(dp[i][j][k])dp[i+2][j][k+1]=1;\n        }\n        }\n    }\n    rrep(n){\n        if(s[i]=='0'){\n            rep(j,N)rep(k,N)if(dp[i+1][j+1][k])dp[i][j][k]=1;\n        }\n        else{\n            rep(j,N)rep(k,N)if(dp[i+1][j][k+1])dp[i][j][k]=1;\n        }\n    }\n    rep(n){\n        if(s[i]=='0'){\n            rep(j,N)rep(k,N)if(dp[i+1][j+1][k])dp[i][j][k]=0;\n        }\n        else{\n            rep(j,N)rep(k,N)if(dp[i+1][j][k+1])dp[i][j][k]=0;\n        }\n    }\n    vec(ll,zero,n+1);\n    vec(ll,one,n+1);\n    rrep(n){\n        zero[i]=zero[i+1];\n        one[i]=one[i+1];\n        if(s[i]=='0')zero[i]++;\n        else one[i]++;\n    }\n    Modint ans=0;\n    dp[n][0][0]=0;\n    rep(n+1)rep(j,N)rep(k,N)if(dp[i][j][k])ans+=Mcomb(one[i]+1,j)*Mcomb(zero[i]+j+1,k);\n    out(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nstring s;\nint suf[333][333][333]; //# of strings s.t. LCS from back with s goes to that long\n//length of T, position at s matched, # of 1s\nint f[333][333][333];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s;\n\tint n=s.length();\n\t/*\n\tpre[0][0][0][0]=1; //prefix of length 0, 0 1s, 0 0s taken\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=n;l++)\n\t\t\t\t{\n\t\t\t\t\tif(!pre[i][j][k][l]) continue;\n\t\t\t\t\t//11\n\t\t\t\t\tif(i+2<=n) pre[i+2][j+1][k][l]=1;\n\t\t\t\t\t//01\n\t\t\t\t\tif(i+2<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='1') pre[i+2][j][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+2][j][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//10\n\t\t\t\t\tif(i+2<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i+1]=='1') pre[i+2][j][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+2][j][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//0\n\t\t\t\t\tif(j>0) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='1') pre[i+1][j-1][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+1][j-1][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//1\n\t\t\t\t\tpre[i+1][j][k][l]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=n;l++)\n\t\t\t\t{\n\t\t\t\t\tif(pre[i][j][k][l]) g[i][k][l]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tf[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\t//assert(f[i][j][k]==g[i][j][k]);\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tf[i+1][j][k]=1;\n\t\t\t\tif(i+3<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+2]=='1') f[i+3][j+1][k]=1;\n\t\t\t\t\telse f[i+3][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i+2<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t\tif(s[i]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='0')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='1')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j+1][k-1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsuf[0][n][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(suf[i][j][k]==0) continue;\n\t\t\t\tint v=suf[i][j][k];\n\t\t\t\t//choose s[j-1]!\n\t\t\t\tradd(suf[i+1][j-1][k],v);\n\t\t\t\t//choose opposite of s[j-1] sia\n\t\t\t\tradd(suf[i+1][j][k+(s[j-1]=='0')],v);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 1; //match completely\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint preans=ans;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tint v = suf[i][j][k];\n\t\t\t\tif(v==0) continue;\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<k<<' '<<v<<'\\n';\n\t\t\t\t//s[0..j-1]\n\t\t\t\t//j=1 special care\n\t\t\t\tint ones = k;\n\t\t\t\tint zeroes = i-k-(n-j); //length - number of matches \n\t\t\t\t//cerr<<ones<<' '<<zeroes<<'\\n';\n\t\t\t\tif(zeroes<0) continue;\n\t\t\t\tif(zeroes+ones==0)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(j==1)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(f[j][ones][zeroes])\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v);\n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint newans = ans;\n\t\t//cerr<<\"LENGTH \"<<i<<\" = \"<<add(newans,MOD-preans)<<'\\n';\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define int long long\n//#define int __int128\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst int N = 305, MOD = 998244353;\n\nint n;\nstring S;\nint ans;\nint dp[N][N][N];\nbool D[N][N][N];\n\nbool mas[N][N];\nbool mass[N][N];\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin >> S;\n    n = S.size();\n    reverse(S.begin(), S.end());\n    S = \"#\" + S + \"##\";\n    dp[0][0][0] = 1;\n    for (int i = 0; i <= n; i++){\n        dp[0][0][i] = 1;\n        dp[0][i][0] = 1;\n    }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            dp[0][i][j] = (dp[0][i-1][j] + dp[0][i][j-1]) % MOD;\n    for (int I = 1; I <= n; I++){\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= n; j++){\n                dp[I][i][j] = dp[I-1][i][j];\n                if (S[I] == '0'){\n                    if (j)\n                        dp[I][i][j] += dp[I][i][j-1];\n                }\n                else {\n                    if (i)\n                        dp[I][i][j] += dp[I][i-1][j];\n                }\n                dp[I][i][j] %= MOD;\n            }\n    }\n    D[n+1][0][0] = 1;\n    for (int I = n-1; I >= 0; I--){\n        int m = n-I;\n        for (int x = 0; x <= m; x++)\n            for (int y = 0; x+y <= m; y++)\n                if (D[I+1][x][y]){\n                    if (x+y == 0)\n                        continue;\n                    D[I][x][y] = 1;\n                    if (S[I] == '0'){\n                        if (y)\n                            D[I][x+1][y-1] = 1;\n                    }\n                    else {\n                        if (x)\n                            D[I][x-1][y+1] = 1;\n                    }\n                }\n        for (int x = 0; x <= m; x++)\n            for (int y = 0; x+y <= m; y++)\n                if (D[I+2][x][y]){\n                    if (S[I] == '0' || S[I+1] == '0')\n                        D[I][x+1][y] = 1;\n                    if (S[I] == '1' || S[I+1] == '1')\n                        D[I][x][y+1] = 1;\n                }\n        for (int x = m; x >= 0; x--)\n            for (int y = m-x; y >= 0; y--){\n                if (D[I][x][y] == 0 || x+y==1)\n                    continue;\n                if (x)\n                    D[I][x-1][y] = 1;\n                if (y)\n                    D[I][x][y-1] = 1;\n            }\n    }\n    for (int I = 1; I <= n+1; I++){\n        int m = n-I;\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= n; j++){\n                if (mas[i][j]){\n                    D[I][i][j] = 0;\n                }\n                if (D[I][i][j])\n                    mas[i][j] = 1;\n            }\n        int x = 0, y = 0;\n        if (S[I] == '0')\n            x++;\n        else\n            y++;\n        for (int i = x; i <= n; i++)\n            for (int j = y; j <= n; j++)\n                if (mas[i][j])\n                    mass[i-x][j-y] = 1;\n        for (int i = 0; i <= n; i++)\n            for (int j = 0; j <= n; j++){\n                mas[i][j] = mass[i][j];\n                mass[i][j] = 0;\n            }\n    }\n    for (int I = 0; I <= n; I++)\n        for (int x = 0; x <= n; x++)\n            for (int y = 0; y <= n; y++)\n                if (D[I+1][x][y]){\n                    ans += dp[I][x][y];\n                    //cout << I << \" \" << x << \" \" << y << \" \" << dp[I][x][y] << endl;\n                }\n    cout << ans%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <cstring>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\n#define int long long\n\nconst int ms = 303;\nconst int MOD = 998244353;\n\nstd::string str;\nint n;\nbool vis[ms][ms][ms];\nint memo[ms][ms][ms];\nint bst[ms][ms];\nint sum[ms][2];\n\nvoid go(int on, int zero, int one, int turn) {\n\tif(vis[on][zero][turn]) return;\n\tvis[on][zero][turn] = true;\n\t//std::cout << \"visiting \" << on << \", \" << zero << \", \" << one << \", \" << turn << \"\\n\";\n\tmemo[on][zero][turn] = one;\n\tif(turn + 1 == (int) str.size()) return;\n\tif(zero >= 2) go(on, zero-1, one, turn+1);\n\tif(one >= 2) go(on, zero, one-1, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero-1, one, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero, one-1, turn+1);\n\tif(on < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tif(zero >= 1) go(on+1, zero-1+(1-nxt), one+nxt, turn+1);\n\t\tif(one >= 1) go(on+1, zero+(1-nxt), one+nxt-1, turn+1);\n\t}\n\tif(on+1 < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t\tnxt = str[on+1] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t}\n}\n\nint dp(int on, int zero, int one) {\n\tif(zero < 0 || one < 0) return 0;\n\tif(on == n && zero == 0 && one == 0) return 1;\n\tint &ans = memo[on][zero][one];\n\tif(ans != -1) return ans;\n\tans = 0;\n\tif(on == n) {\n\t\tans = (dp(on, zero-1, one) + dp(on, zero, one-1)) % MOD;\n\t} else if(str[on] == '0') {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero, one-1)) % MOD;\n\t} else {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero-1, one)) % MOD;\n\t}\n\treturn ans;\n}\n\nmain() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tstd::cin >> str;\n\tn = (int) str.size();\n\tgo(0, 0, 0, 0);\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tsum[i][0] = sum[i+1][0];\n\t\tsum[i][1] = sum[i+1][1];\n\t\tif(str[i] == '0') sum[i][0]++;\n\t\telse sum[i][1]++;\n\t}\n\tmemset(bst, -1, sizeof bst);\n\tfor(int on = 0; on < ms; on++) {\n\t\tfor(int zero = 0; zero < ms; zero++) {\n\t\t\tfor(int turn = 0; turn < ms; turn++) {\n\t\t\t\tif(!vis[on][zero][turn]) continue;\n\t\t\t\tint one = memo[on][zero][turn];\n\t\t\t\tint f[2] = {zero + sum[on][0], one + sum[on][1]};\n\t\t\t\tbst[f[0]][f[1]] = std::max(bst[f[0]][f[1]], on);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tint ans = 0;\n\tfor(int zero = 0; zero < ms; zero++) {\n\t\tfor(int one = 0; one < ms; one++) {\n\t\t\tif(bst[zero][one] < 0) continue;\n\t\t\tint on = bst[zero][one];\n\t\t\t//std::cout << \"best for \" << zero << \", \" << one << \" is \" << on << \", got \" << dp(on, zero - sum[on][0], one - sum[on][1]) << '\\n';\n\t\t\tans = (ans + dp(on, zero - sum[on][0], one - sum[on][1])) % MOD;\n\t\t}\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<stack>\n#include<complex>\n#include<memory>\n\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\nusing Graph=vector<vector<int>>;\n\t\n#define WHATS(var)cout<<__LINE__<<' '<<#var<<\"=\"<<var<<endl;\n\t\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n\tos << \"( \" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<set<T>> &v){\n\tfor(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const set<T> &v){\n\tint i=0;\n\tfor(auto it:v){\n\t\tif(i > 0){os << ' ';}\n\t\tos << it;\n\t\ti++;\n\t} \n\treturn os;\n}\n//1. maskの部分集合を列挙する\n\t// \ta. i==0を評価しない\n\t// \tfor(int i=mask; i>0; i=(i-1)&mask) {\n\t// \t}\n\n\t// b. i==0を評価する\n\t// \tfor(int i=mask; i>=0; i--) {\n\t// \t\ti&=mask;\n\t// \t}\n// 2. maskを含む集合を列挙する\n\n// 少し目的は変わりますが同じようなやり方でできる処理が、maskを含む集合の列挙です。\n\n// \tfor(int i=mask; i<(1<<n); i=(i+1)|mask) {\n// \t}\n\n\t\nusing ll = long long int;\n\nint say(vector<int>v){\n    cout<<v.size();\n    for(auto x:v)cout<<' '<<x+1;\n    cout<<endl;\n\n    int a;cin>>a;\n    a--;\n    return a;\n}\n///02020\n//02110\n//02200\n//03010\n//03100\n//04000\n//20020\n//11020\n//11110\n//11200\n//12010\n//12100\n//13000\n//22020\nconst ll mod=998244353;\nvector<vector<ll>>calc(vector<vector<ll>>v,bool flag=false){\n    if(!flag){\n        vector<vector<ll>>sums(v.size(),vector<ll>(v[0].size()+1));\n        for(int y=0;y<v.size();++y){\n            for(int x=0;x<v[0].size();++x){\n                sums[y][x+1]+=v[y][x];\n                sums[y][x+1]+=sums[y][x];\n\n                sums[y][x+1]%=mod;\n            }\n        }\n        return sums;\n    }else{\n        vector<vector<ll>>sums(v.size()+1,vector<ll>(v[0].size()+1));\n        for(int y=0;y<v.size();++y){\n            for(int x=v[0].size()-1;x>=0;--x){\n                sums[y+1][x]+=v[y][x];\n                sums[y+1][x]+=sums[y][x+1];\n\n                sums[y+1][x]%=mod;\n            }\n        }\n        return sums;\n    }\n}\nint main() {\n\tios::sync_with_stdio(false);\n    cin.tie();\n    string st;cin>>st;\n    const int N=st.size();\n    vector<vector<vector<ll>>>dp(N+1,vector<vector<ll>>(N+1,vector<ll>(N+1)));\n    dp[0][N][0]=1ll;\n\n    for(int len=1;len<=N;++len){\n        for(int x=N;x>=N-len+1;--x){\n            \n            int need_sum=(len-1)-(N-x);\n            // WHATS(len)\n            // WHATS(x)\n            // WHATS(need_sum)\n            for(int one_need=0;one_need<=need_sum;++one_need){\n                \n                \n\n                int zero_need=need_sum-one_need;\n                \n                if(x>=0){\n                    if(st[x-1]=='1'){\n                        dp[len][x][one_need]+=dp[len-1][x][one_need];\n                        dp[len][x-1][one_need]+=dp[len-1][x][one_need];\n                    }else{\n                        \n                        dp[len][x][one_need+1]+=dp[len-1][x][one_need];\n                        dp[len][x-1][one_need]+=dp[len-1][x][one_need];\n                    }\n                }\n               \n            }\n        }\n        for(int x=0;x<=N;++x){\n            for(int y=0;y<=N;++y){\n                dp[len][x][y]%=mod;\n            }\n        }\n    }\n    //WHATS(dp[1])\n    //WHATS(dp[2])\n    ll answer=0;\n    vector<int>one_sums(N+1);\n    vector<int>zero_sums(N+1);\n    for(int i=1;i<=N;++i){\n        if((i>=2)){\n            if(st[i-1]=='1'||st[i-2]=='1'){\n                one_sums[i]=max(one_sums[i],one_sums[i-2]+1);\n                \n            }else{\n                one_sums[i]=max(one_sums[i],one_sums[i-2]);\n\n            }\n\n            if(st[i-1]=='0'||st[i-2]=='0'){\n                zero_sums[i]=max(zero_sums[i],zero_sums[i-2]+1);\n            }else{\n                zero_sums[i]=max(zero_sums[i],zero_sums[i-2]);\n\n            }\n        }\n        {//111001110011100111 1:8 0:3\n            one_sums[i]=max(one_sums[i],one_sums[i-1]);\n            zero_sums[i]=max(zero_sums[i],zero_sums[i-1]);\n        }\n    }\n\n    vector<vector<vector<int>>>oks(N+1,vector<vector<int>>(N+2,vector<int>(N+2)));\n    oks[0][0][0]=true;\n    for(int x=0;x<N;++x){\n        for(int z_cnt=0;z_cnt<=N;++z_cnt){\n            for(int o_cnt=0;o_cnt<=N;++o_cnt){\n                if(oks[x][z_cnt][o_cnt]){\n                    oks[x+1][z_cnt][o_cnt]=true;\n                    if(x<N-1){\n                        if(st[x]=='0'||st[x+1]=='0'){\n                            oks[x+2][z_cnt+1][o_cnt]=true;\n                        }\n                        \n                        if(st[x]=='1'||st[x+1]=='1'){\n                            oks[x+2][z_cnt][o_cnt+1]=true;\n                        }\n                        \n                    }\n                    {\n                        if(st[x]=='1'){\n                            if(z_cnt){\n                                oks[x+1][z_cnt-1][o_cnt+1]=true;\n                            }\n                            \n                        }\n                        if(st[x]=='0'){\n                            if(o_cnt){\n                                oks[x+1][z_cnt+1][o_cnt-1]=true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // WHATS(oks[3])\n    // WHATS(oks[4])\n    // WHATS(oks[5])\n    // WHATS(oks[6])\n    for(int i=1;i<=N;++i){\n        int len=i;\n        for(int j=N;j>=N-len;--j){\n            int x=j;\n            int need_sum=(len)-(N-x);\n\n            for(int k=0;k<=N;++k){\n                int one_need=k;\n                int zero_need=need_sum-one_need;\n\n                \n                if(zero_need<0)continue;\n\n                int one_sum=one_sums[x];\n                int zero_sum=zero_sums[x];\n                //int carry_time=N-len;\n                 //if(one_need<=one_sum&&zero_need<=zero_sum&&(x)>=2*(one_need+zero_need)){\n                if(oks[x][zero_need][one_need]){    \n                        \n                    if(dp[i][j][k]){\n                        //  WHATS(len)\n                        //  WHATS(x)\n                        //  WHATS(one_need)\n                        // WHATS(zero_need)\n                        // WHATS(dp[i][j][k])\n                        answer+=dp[i][j][k];\n                    }\n                }\n            }\n        }\n    }\n    answer+=mod;\n    cout<<answer%mod<<endl;\n\n    // set<string>aset;\n    // queue<string>que;\n    // que.emplace(st);\n    // aset.emplace(st);\n    \n    // while(!que.empty()){\n    //     string q(que.front());\n    //     que.pop();\n    //     aset.emplace(q);\n    //     if(q.size()>=2){\n\n    //         char ch='0';\n    //         for(char ch='0';ch<='1';++ch){\n    //              if(q[0]==ch||q[1]==ch){\n    //                 for(int x=2;x<=q.size();++x){\n    //                     string l=q.substr(2,x-2);\n    //                     string r=q.substr(x);\n\n    //                     string kk=l+ch+r;\n    //                     if(aset.find(kk)==aset.end()){\n    //                         que.emplace(l+ch+r);\n    //                         aset.emplace(kk);\n    //                     }\n    //                 }\n    //             }\n    //         }\n           \n    //     }\n    // }\n    // WHATS(aset.size())\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int MOD = 998244353, N = 305;\nint dp[N][N][N][2], mn_suf[N], zero_on_suf[N];\nbool dp2[N][N][N];\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tstring s;\n\tcin >> s;\n\n\tint n = s.size();\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tzero_on_suf[i] = zero_on_suf[i + 1];\n\t\tif (s[i] == '0')\n\t\t\tzero_on_suf[i]++;\n\t}\n\n\tdp[0][0][0][0] = 1;\n    dp[0][0][0][1] = 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c = s[n - 1 - i];\n\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\tfor (int h = 0; h < 2; h++) {\n\t\t\t\t\tif (dp[i][j][k][h]) {\n\n\t\t\t\t\t\tif (c == '0' && h == 0) {\n\t\t\t\t\t\t\tadd(dp[i + 1][j][k][h], dp[i][j][k][h]);\n                            add(dp[i + 1][j][k][1], dp[i][j][k][h]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (j < n) {\n\t\t\t\t\t\t\tadd(dp[i][j + 1][k][h], dp[i][j][k][h]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (c == '1' && h == 0) {\n\t\t\t\t\t\t\tadd(dp[i + 1][j][k][h], dp[i][j][k][h]);\n                            add(dp[i + 1][j][k][1], dp[i][j][k][h]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (k < n) {\n\t\t\t\t\t\t\tadd(dp[i][j][k + 1][h], dp[i][j][k][h]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdp2[0][0][0] = true;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\tif (dp2[i][j][k]) {\n\t\t\t\t\tint rem = n - i - j - k;\n\t\t\t\t\tfor (int x = 0; x <= min(rem, 2); x++) {\n\t\t\t\t\t\tfor (int p = 0; p <= min(2 - x, j); p++) {\n\t\t\t\t\t\t\tint q = 2 - x - p;\n\n\t\t\t\t\t\t\tif (q > k)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tint nj = j - p, nk = k - q, z = 0;\n\n\t\t\t\t\t\t\tchar oper[2];\n\n\t\t\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\t\t\toper[z++] = s[n - rem];\n\t\t\t\t\t\t\tif (x > 1)\n\t\t\t\t\t\t\t\toper[z++] = s[n - rem + 1];\n\n\t\t\t\t\t\t\tif (p > 0)\n\t\t\t\t\t\t\t\toper[z++] = '0';\n\t\t\t\t\t\t\tif (p > 1)\n\t\t\t\t\t\t\t\toper[z++] = '0';\n\n\t\t\t\t\t\t\tif (q > 0)\n\t\t\t\t\t\t\t\toper[z++] = '1';\n\t\t\t\t\t\t\tif (q > 1)\n\t\t\t\t\t\t\t\toper[z++] = '1';\n\n\t\t\t\t\t\t\tfor (int h = 0; h < 2; h++) {\n\t\t\t\t\t\t\t\tif (oper[h] == '0')\n\t\t\t\t\t\t\t\t\tdp2[i + 1][nj + 1][nk] = true;\n\t\t\t\t\t\t\t\tif (oper[h] == '1')\n\t\t\t\t\t\t\t\t\tdp2[i + 1][nj][nk + 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tmn_suf[j] = N;\n\t\t}\n\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\tif (dp2[i][j][k]) {\n\t\t\t\t\tint suf = n - i - j - k;\n\t\t\t\t\tmn_suf[j + zero_on_suf[n - suf]] = \n\t\t\t\t\t\tmin(mn_suf[j + zero_on_suf[n - suf]], suf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        for (int j = 0; j <= n; j++) {\n            if (mn_suf[j] != N) {\n                int x = j - zero_on_suf[n - mn_suf[j]],\n                    y = n - i - x - mn_suf[j];\n                // cout << mn_suf[j] << \" \" << x << \" \" << y << \" \" << dp[mn_suf[j]][x][y][1] << \"\\n\";\n                add(ans, dp[mn_suf[j]][x][y][1]);\n            }\n        }\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MOD = 998244353;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  string s;\n  while (cin >> s) {\n    int n = s.size();\n    vector<vector<vector<bool>>> can(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1)));\n    can[0][0][0] = true;\n    auto make_can = [&](int i, int j, int k) {\n      if (i <= n && j <= n && k <= n) {\n//        if (!can[i][j][k]) {\n//          eprintf(\"   new can %d %d %d\\n\", i, j, k);\n//        }\n        can[i][j][k] = true;\n      }\n    };\n    for (int i = 0; i <= n; i++) {\n      for (int j = n; j >= 0; j--) {\n        for (int k = n; k >= 0; k--) {\n          if (!can[i][j][k]) continue;\n//          eprintf(\"can %d %d %d\\n\", i, j, k);\n          if (i + 2 <= n) make_can(i + 2, j + (s[i] == '0'), k + (s[i] == '1'));\n          if (i + 2 <= n) make_can(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'));\n          if (i + 2 <= n) make_can(i + 1, j, k);\n          if (i + 1 <= n && j) make_can(i + 1, j + (s[i] == '0') - 1, k + (s[i] == '1'));\n          if (i + 1 <= n && k) make_can(i + 1, j + (s[i] == '0'), k + (s[i] == '1') - 1);\n          if (j && (n - i) + j + k >= 2) make_can(i, j - 1, k);\n          if (k && (n - i) + j + k >= 2) make_can(i, j, k - 1);\n        }\n      }\n    }\n\n    reverse(s.begin(), s.end());\n\n    vector<int> cnt0(n + 1);\n    vector<int> cnt1(n + 1);\n    for (int i = 0; i < n; i++) {\n      cnt0[i + 1] = cnt0[i];\n      cnt1[i + 1] = cnt1[i];\n      if (s[i] == '0') {\n        cnt0[i + 1]++;\n      } else {\n        cnt1[i + 1]++;\n      }\n    }\n\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1)));\n    dp[0][0][0] = 1;\n    int ans = 0;\n    for (int i = 0; i <= n; i++) {\n      for (int j = 0; i + j <= n; j++) {\n        for (int k = 0; k <= i + j; k++) {\n          if (dp[i][j][k] == 0) continue;\n          if (i + j < n) {\n            add(dp[i + 1][j][k + (s[k] == '0')], dp[i][j][k]);\n            add(dp[i][j + 1][k + (s[k] == '1')], dp[i][j][k]);\n          }\n\n          assert(i >= cnt0[k]);\n          assert(j >= cnt1[k]);\n          /*std::function<string(int, int, int)> ex = [&](int i, int j, int k) -> string {\n            if (i == 0 && j == 0) { assert(k == 0); return \"\"; }\n            assert(dp[i][j][k]);\n            if (i && dp[i-1][j][k] && s[k] == '1') return \"0\" + ex(i - 1, j, k);\n            if (i && k && dp[i-1][j][k-1] && s[k-1] == '0') return \"0\" + ex(i - 1, j, k-1);\n            if (j && dp[i][j-1][k] && s[k] == '0') return \"1\" + ex(i, j-1, k);\n            if (j && k && dp[i][j-1][k-1] && s[k-1] == '1') return \"1\" + ex(i, j-1, k-1);\n            assert(false);\n          };*/\n          if (can[n - k][i - cnt0[k]][j - cnt1[k]]) {\n//            eprintf(\"%d %d %d -> %d [%s] [%d, %d, %d]\\n\", i, j, k, dp[i][j][k], ex(i, j, k).c_str(), n - k, i - cnt0[k], j - cnt1[k]);\n            add(ans, dp[i][j][k]);\n          } else {\n//            eprintf(\"%d %d %d -> %d [%s] ! can [%d, %d, %d]\\n\", i, j, k, dp[i][j][k], ex(i, j, k).c_str(), n - k, i - cnt0[k], j - cnt1[k]);\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n//    break;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,p[2][N];\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++) p[0][i]=p[0][i-1]+(s[i]=='0'),p[1][i]=p[1][i-1]+(s[i]=='1');\n    f[0][0][0]=true;\n    for(int k=0;k<=n;k++)\n        for(int i=0;i<=p[0][k];i++)\n            for(int j=0;j<=p[1][k];j++)\n    {\n        if(!f[k][i][j]) continue;\n        f[k+1][i][j]=true;\n        if(i&&s[k+1]=='1')\n            f[k+1][i-1][j+1]=true;\n        if(j&&s[k+1]=='0')\n            f[k+1][i+1][j-1]=true;\n        if(k+2<=n&&(s[k+1]=='1'||s[k+2]=='1'))\n            f[k+2][i][j+1]=true;\n        if(k+2<=n&&(s[k+1]=='0'||s[k+2]=='0'))\n            f[k+2][i+1][j]=true;\n    }\n    dp[n+1][0][0]=1;\n    ll ans=0;\n    for(int k=n+1;k>=1;k--)\n        for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n    {\n        if(dp[k][i][j]==0) continue;\n        if(f[k-1][i][j])\n            ans=(ans+dp[k][i][j])%mod;\n        if(k>1)\n        {\n            dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n            if(s[k-1]=='1')\n                dp[k][i+1][j]=(dp[k][i+1][j]+dp[k][i][j])%mod;\n            else dp[k][i][j+1]=(dp[k][i][j+1]+dp[k][i][j])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef NeverBeRed\n#include \"debug.h\"\n#else\n#define debug(...) 9715\n#endif\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> point;\n#define F first\n#define S second\n\nconst int mod = 998244353;\nint dp[305][305][305];\n\ninline void add(int &x, int y)\n{\n\tx += y;\n\tif (x >= mod)\n\t\tx -= mod;\n}\n\nint main()\n{\n\t#ifdef TurnRed\n\t\t//freopen(\"a.in\", \"r\", stdin);\n\t\t//freopen(\"a.out\", \"w\", stdout);\n\t#endif\n\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\n\tint n = s.length();\n\tdp[0][0][0] = true;\n\tfor (int p = 0; p < n; ++p)\n\t\tfor (int z = 0; z <= n; ++z)\n\t\t\tfor (int o = 0; o <= n; ++o)\n\t\t\t\tif (dp[p][z][o])\n\t\t\t\t{\n\t\t\t\t\tif (z >= 2) dp[p][z-2][o] = true;\n\t\t\t\t\tif (o >= 2) dp[p][z][o-2] = true;\n\t\t\t\t\tif (z && o) dp[p][z-1][o-1] = true;\n\t\t\t\t\tif (z || o) dp[p+1][z][o] = true;\n\t\t\t\t\tif (z && s[p] == '1') dp[p+1][z-1][o+1] = true;\n\t\t\t\t\tif (o && s[p] == '0') dp[p+1][z+1][o-1] = true;\n\t\t\t\t\tif (p+1 < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s[p] == '0' || s[p+1] == '0') dp[p+2][z+1][o] = true;\n\t\t\t\t\t\tif (s[p] == '1' || s[p+1] == '1') dp[p+2][z][o+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\tvector<vector<int>> f(2, vector<int>(n+1));\n\tfor (int i = n-1; i >= 0; --i)\n\t{\n\t\t++f[s[i]-'0'][i];\n\t\tf[0][i] += f[0][i+1];\n\t\tf[1][i] += f[1][i+1];\n\t}\n\n\tvector<vector<int>> cnt(n+1, vector<int>(n+1, -1));\n\tfor (int p = 0; p <= n; ++p)\n\t\tfor (int z = 0; z <= n; ++z)\n\t\t\tfor (int o = 0; o <= n; ++o)\n\t\t\t\tif (dp[p][z][o])\n\t\t\t\t{\n//\t\t\t\t\tdebug(p, z, o);\n\t\t\t\t\tint nz = z + f[0][p];\n\t\t\t\t\tint no = o + f[1][p];\n\t\t\t\t\tcnt[nz][no] = max(cnt[nz][no], p);\n\t\t\t\t}\n\n//\tfor (auto i : cnt)\n//\t\tdebug(i);\n\n\tmemset(dp, 0, sizeof dp);\n\tfor (int z = 0; z <= n; ++z)\n\t\tfor (int o = 0; o <= n; ++o)\n\t\t\tif (cnt[z][o] != -1)\n\t\t\t{\n\t\t\t\tint p = cnt[z][o];\n\t\t\t\tdp[p][z - f[0][p]][o - f[1][p]] = 1;\n\t\t\t}\n\n\tfor (int p = 0; p <= n; ++p)\n\t\tfor (int z = n; z >= 0; --z)\n\t\t\tfor (int o = n; o >= 0; --o)\n\t\t\t{\n\t\t\t\tif (p < n && s[p] == '0')\n\t\t\t\t\tadd(dp[p+1][z][o], dp[p][z][o]);\n\t\t\t\telse if (z)\n\t\t\t\t\tadd(dp[p][z-1][o], dp[p][z][o]);\n\n\t\t\t\tif (p < n && s[p] == '1')\n\t\t\t\t\tadd(dp[p+1][z][o], dp[p][z][o]);\n\t\t\t\telse if (o)\n\t\t\t\t\tadd(dp[p][z][o-1], dp[p][z][o]);\n\t\t\t}\n\n\tcout << dp[n][0][0] << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,p[2][N];\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++) p[0][i]=p[0][i-1]+(s[i]=='0'),p[1][i]=p[1][i-1]+(s[i]=='1');\n    f[0][0][0]=true;\n    for(int k=0;k<=n;k++)\n        for(int i=p[1][k];i>=0;i--)\n        for(int j=p[0][k];j>=0;j--)\n    {\n        f[k+1][i][j]|=f[k][i][j];\n        if(i>0) f[k][i-1][j]|=f[k][i][j];\n        if(j>0) f[k][i][j-1]|=f[k][i][j];\n        if(i>0&&k+1<=n&&s[k+1]=='0')\n            f[k+1][i-1][j+1]|=f[k][i][j];\n        if(j>0&&k+1<=n&&s[k+1]=='1')\n            f[k+1][i+1][j-1]|=f[i][j][i];\n        if(k+2<=n)\n        {\n            if(s[k+1]=='1'||s[k+2]=='1')\n                f[k+2][i+1][j]|=f[k][i][j];\n            if(s[k+1]=='0'||s[k+2]=='0')\n                f[k+2][i][j+1]|=f[k][i][j];\n        }\n    }\n    dp[n+1][0][0]=1;\n    ll ans=0;\n    for(int k=n+1;k>=1;k--)\n        for(int i=0;i<=p[1][k-1];i++)\n        for(int j=0;j<=p[0][k-1];j++)\n    {\n        if(f[k-1][i][j])\n            ans=(ans+dp[k][i][j])%mod;\n        if(s[k-1]=='0')\n        {\n            if(f[k-1][i+1][j])\n                dp[k][i+1][j]=(dp[k][i+1][j]+dp[k][i][j])%mod;\n            if(k-2>=0&&f[k-2][i][j])\n                dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n        }\n        else\n        {\n            if(f[k-1][i][j+1])\n                dp[k][i][j+1]=(dp[k][i][j+1]+dp[k][i][j])%mod;\n            if(k-2>=0&&f[k-2][i][j])\n                dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nint i,n,f[305][305][305],dp[305][305][305],s0[305],s1[305],j,k;\nint mx[305][305],C[305][305];\nchar c[1005];\nvoid dfs(int i,int j,int k)\n{\n\tif(f[i][j][k])\n\t\treturn;\n\tf[i][j][k]=1;\n\tmx[j+s0[i]][k+s1[i]]=max(mx[j+s0[i]][k+s1[i]],i);\n\tif(i+1<=n)\n\t{\n\t\tif(c[i]=='0'||c[i+1]=='0')\n\t\t\tdfs(i+2,j+1,k);\n\t\tif(c[i]=='1'||c[i+1]=='1')\n\t\t\tdfs(i+2,j,k+1);\n\t}\n\tif(j+k>=2&&j)\n\t\tdfs(i,j-1,k);\n\tif(j+k>=2&&k)\n\t\tdfs(i,j,k-1);\n\tif(j+k>=1&&i<=n)\n\t{\n\t\tdfs(i+1,j,k);\n\t\tif(c[i]=='0')\n\t\t\tif(k)\n\t\t\t\tdfs(i+1,j+1,k-1);\n\t\tif(c[i]=='1')\n\t\t\tif(j)\n\t\t\t\tdfs(i+1,j-1,k+1);\n\t}\n}\nint dfs2(int i,int j,int k)\n{\n\tif(i>n)\n\t\treturn C[j+k][j];\n\tif(dp[i][j][k]!=-1)\n\t\treturn dp[i][j][k];\n\tint s=0;\n\tif(c[i]=='0')\n\t\tif(k)\n\t\t\ts+=dfs2(i,j,k-1);\n\tif(c[i]=='1')\n\t\tif(j)\n\t\t\ts+=dfs2(i,j-1,k);\n\ts+=dfs2(i+1,j,k);\n\treturn dp[i][j][k]=s%M;\n}\nint main()\n{\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tfor(i=n;i>=1;--i)\n\t{\n\t\ts0[i]=s0[i+1]+(c[i]=='0');\n\t\ts1[i]=s1[i+1]+(c[i]=='1');\n\t}\n\tfor(i=0;i<=n;++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%M;\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdfs(1,0,0);\n\tlong long ans=0;\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=0;j<=n;++j)\n\t\t\tif(mx[i][j])\n\t\t\t\tans+=dfs2(mx[i][j],i-s0[mx[i][j]],j-s1[mx[i][j]]);\n\tcout<<(ans%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = /*1'000'000'007LL;*/ 998'244'353LL;\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nconst int dx[4]={ 1,0,-1,0 };\nconst int dy[4]={ 0,1,0,-1 };\n\ntemplate<typename T>\nT power(T x, long long n, const T &m){\n\tif(n == 0) return 1;\n\tif(n == 1) return x;\n\tT tmp = power(x, n/2, m);\n\tif(n%2 == 0) return tmp * tmp % m;\n\telse return tmp * tmp % m * x % m;\n}\n\ntemplate<typename T>\nT inverse(T x, const T &m){\n\treturn power(x, m-2, m);\n}\n\nstruct Combination{\nprivate:\n\tint N;\n\tlong long M;\n\tvector<long long> f, i;\npublic:\n\tvoid init(int n, long long m){\n\t\tN = n; M = m;\n\t\tf.resize(N+1); f[0] = 1;\n\t\ti.resize(N+1); i[0] = 1;\n\t\tfor(long long j=1; j<=N; j++){\n\t\t\tf[j] = f[j-1]*j%M;\n\t\t\ti[j] = inverse(f[j], M);\n\t\t}\n\t}\n\tlong long fact(int n){\n\t\treturn f[n];\n\t}\n\tlong long C(int n, int r){\n\t\treturn f[n] * i[r] % M * i[n-r] % M;\n\t}\n};\n\nstring S;\n\nll dp[305][305][305];\nll solve(int n, int c0, int c1){\n\tif(n == S.size()){\n\t\tif(c0 == 0 && c1 == 0) return 1;\n\t\telse{\n\t\t\tif(dp[n][c0][c1] != -1) return dp[n][c0][c1];\n\t\t\treturn dp[n][c0][c1] = ((c0 > 0 ? solve(n, c0-1, c1) : 0)\n\t\t\t\t+ (c1 > 0 ? solve(n, c0, c1-1) : 0)) % MOD;\n\t\t}\n\t}\n\tif(dp[n][c0][c1] != -1) return dp[n][c0][c1];\n\tif(S[n] == '0'){\n\t\treturn dp[n][c0][c1] = (solve(n+1, c0, c1)\n\t\t\t+ (c1 > 0 ? solve(n, c0, c1-1) : 0)) % MOD;\n\t}\n\telse{\n\t\treturn dp[n][c0][c1] = (solve(n+1, c0, c1) \n\t\t\t+ (c0 > 0 ? solve(n, c0-1, c1) : 0)) % MOD;\n\t}\n}\n\nint memo[305][305][305];\nint calc(int n, int c0, int c1){\n\tif(c0 == 0 && c1 == 0) return n;\n\tif(memo[n][c0][c1] != -1) return memo[n][c0][c1];\n\tint ret = INT_MAX;\n\tif(n < S.size() && S[n] == '0' && c0 > 0)\n\t\tret = min(ret, calc(n+1, c0-1, c1));\n\tif(n+1 < S.size() && S[n+1] == '0' && c0 > 0)\n\t\tret = min(ret, calc(n+2, c0-1, c1));\n\tif(n < S.size() && S[n] == '1' && c1 > 0)\n\t\tret = min(ret, calc(n+1, c0, c1-1));\n\tif(n+1 < S.size() && S[n+1] == '1' && c1 > 0)\n\t\tret = min(ret, calc(n+2, c0, c1-1));\n\treturn memo[n][c0][c1] = ret;\n}\n\nCombination C;\n\nsigned main(){\n\tcin >> S;\n\tll ans = 0;\n\tmemset(memo, -1, sizeof(memo));\n\tmemset(dp, -1, sizeof(dp));\n\tint i;\n\tfor(i=0; 2*i<S.size(); i++){\n\t\tll tmp = 0;\n\t\tfor(int j=0; j<=i; j++){\n\t\t\tif(calc(0, j, min(i, (int)S.size()-i)-j) > 2*i) continue;\n\t\t\ttmp += solve(2*i, j, i-j);\n\t\t}\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tint cnt0 = 0;\n\tint cnt1 = 0;\n\trep(j, S.size()){\n\t\tif(S[j] == '0') cnt0++;\n\t\telse cnt1++;\n\t}\n\tC.init(305, MOD);\n\tfor(; i<S.size(); i++){\n\t\tll tmp = 0;\n\t\tfor(int j=0; j<=min(cnt0, (int)S.size()-i); j++){\n\t\t\tif(S.size()-i-j > cnt1) continue;\n\t\t\ttmp += C.C(S.size()-i, j);\n\t\t}\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ntemplate <typename T>\nT abs(T x) {return (x < 0) ? -x : x;}\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2, mod);\n\tx = x * x % mod;\n\treturn (e&1) ? x * a % mod : x;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring S;\n\tcin >> S;\n\tint N = S.length();\n\tvector< vector< vector<char> > > dp(N+1, vector< vector<char> >(N+1, vector<char>(N+1, 0)));\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < N; i++) for(int j = N; j >= 0; j--) for(int k = N-j; k >= 0; k--) if(dp[i][j][k]) {\n\t\tint jn = j + (S[i] == '0'), kn = k + (S[i] == '1');\n\t\tif(j) dp[i+1][jn-1][kn] = 1;\n\t\tif(k) dp[i+1][jn][kn-1] = 1;\n\t\tif(j+k) dp[i+1][j][k] = 1;\n\t\tif(j+k > 1 && j) dp[i][j-1][k] = 1;\n\t\tif(j+k > 1 && k) dp[i][j][k-1] = 1;\n\t\tif(i < N-1) {\n\t\t\tdp[i+2][jn][kn] = 1;\n\t\t\tdp[i+2][j + (S[i+1] == '0')][k + (S[i+1] == '1')] = 1;\n\t\t}\n\t}\n\tcat ans = 0, mod = 998244353;\n\tvector< vector<int> > min_pref(N+1, vector<int>(N+1, -1));\n\tfor(int i = N, n0 = 0, n1 = 0; i >= 0; i--) {\n\t\tif(i < N) n0 += (S[i] == '0'), n1 += (S[i] == '1');\n\t\tfor(int j = 0; j <= N; j++) for(int k = 0; k <= N; k++)\n\t\t\tif(dp[i][j][k] && min_pref[n0+j][n1+k] == -1) min_pref[n0+j][n1+k] = i;\n\t}\n\tvector< vector< vector<cat> > > cnt[2];\n\tcnt[0].resize(N+1, vector< vector<cat> >(N+1, vector<cat>(N+1, 0)));\n\tcnt[1].resize(N+1, vector< vector<cat> >(N+1, vector<cat>(N+1, 0)));\n\tcnt[0][0][0][0] = 1;\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N-i; j++) for(int k = 0; k < N-i-j; k++) {\n\t\tif(i < N) {\n\t\t\tcnt[0][i+1][j][k] += cnt[0][i][j][k] + cnt[1][i][j][k];\n\t\t\tcnt[0][i+1][j][k] %= mod;\n\t\t}\n\t\tif(i == N || S[N-1-i] == '1') {\n\t\t\tcnt[1][i][j+1][k] += cnt[0][i][j][k] + cnt[1][i][j][k];\n\t\t\tcnt[1][i][j+1][k] %= mod;\n\t\t}\n\t\tif(i == N || S[N-1-i] == '0') {\n\t\t\tcnt[1][i][j][k+1] += cnt[0][i][j][k] + cnt[1][i][j][k];\n\t\t\tcnt[1][i][j][k+1] %= mod;\n\t\t}\n\t}\n\tcnt[1].clear();\n\tcnt[1].resize(N+1, vector< vector<cat> >(N+1, vector<cat>(N+1, 0)));\n\tfor(int i = 0; i < N; i++) for(int j = 0; j < N-i; j++) for(int k = 0; k < N-i-j; k++) {\n\t\tcnt[1][i][j+1][k] += cnt[0][i][j][k] + cnt[1][i][j][k];\n\t\tcnt[1][i][j+1][k] %= mod;\n\t\tcnt[1][i][j][k+1] += cnt[0][i][j][k] + cnt[1][i][j][k];\n\t\tcnt[1][i][j][k+1] %= mod;\n\t}\n\tfor(int i = 0; i <= N; i++) for(int j = 0; j <= N; j++) if(min_pref[i][j] >= 0) {\n\t\tint n0 = i, n1 = j;\n\t\tfor(int k = min_pref[i][j]; k < N; k++) n0 -= (S[k] == '0'), n1 -= (S[k] == '1');\n\t\t// cout << i << \" \" << j << \" \" << n0 << \" \" << n1 << \" \" << N-min_pref[i][j] << \" \" << cnt[1][N-min_pref[i][j]][n0][n1] << \"\\n\";\n\t\tans += cnt[0][N-min_pref[i][j]][n0][n1] + cnt[1][N-min_pref[i][j]][n0][n1];\n\t}\n\tans %= mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 998244353\n\nint poss[305][305][305],best[305][305],num[301];\nLLI dp[305][305][305];\nint main() {\n    string S;\n    cin >> S;\n\n    int i,j,k;\n    poss[0][0][0] = 1;\n    for (i = S.size()-1; i >= 0; i--) num[i] = num[i+1]+(S[i] == '1');\n    memset(best,-1,sizeof(best));\n    for (i = 0; i <= S.size(); i++) {\n        for (j = i; j >= 0; j--) {\n            for (k = i; k >= 0; k--) {\n                if (poss[i][j][k]) {\n                    poss[i+2][j+(S[i] == '0')][k+(S[i] == '1')] = 1;\n                    poss[i+2][j+(S[i+1] == '0')][k+(S[i+1] == '1')] = 1;\n                    if (j > 0) poss[i+1][j+(S[i] == '0')-1][k+(S[i] == '1')] = 1;\n                    if (k > 0) poss[i+1][j+(S[i] == '0')][k+(S[i] == '1')-1] = 1;\n                    if (j+k > 0) poss[i+1][j][k] = 1;\n                    if ((j+k > 1) && (j > 0)) poss[i][j-1][k] = 1;\n                    if ((j+k > 1) && (k > 0)) poss[i][j][k-1] = 1;\n                    best[j+S.size()-i-num[i]][k+num[i]] = max(best[j+S.size()-i-num[i]][k+num[i]],i);\n                }\n            }\n        }\n    }\n    dp[S.size()][0][0] = 1;\n    for (i = S.size(); i >= 0; i--) {\n        for (j = 0; j <= S.size(); j++) {\n            for (k = 0; k <= S.size(); k++) {\n                if (i == S.size()) {\n                    if (j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if (k > 0) dp[i][j][k] += dp[i][j][k-1];\n                }\n                else {\n                    dp[i][j][k] = dp[i+1][j][k];\n                    if ((S[i] == '0') && (k > 0)) dp[i][j][k] += dp[i][j][k-1];\n                    if ((S[i] == '1') && (j > 0)) dp[i][j][k] += dp[i][j-1][k];\n                }\n                dp[i][j][k] %= MOD;\n            }\n        }\n    }\n    LLI ans = 0;\n    for (i = 0; i <= S.size(); i++) {\n        for (j = 0; j <= S.size(); j++) {\n            if (best[i][j] != -1) ans += dp[best[i][j]][i-(S.size()-best[i][j]-num[best[i][j]])][j-num[best[i][j]]];\n        }\n    }\n    ans %= MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,p=998244353;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow (int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,ans,f[N][N][N],g[N][N][N];\nchar ch[N];\nvoid check(int &x,int y){if((x+=y)>=p) x-=p;}\nvoid chkmax(int &x,int y){if (x<y) x=y;}\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tscanf(\" %s\",ch+1);\n\tn=strlen(ch+1);\n\tif (n==1){puts(\"1\");return 0;}\n\tmemset(f,0xC0,sizeof(f));\n\tf[0][0][0]=0;\n\tfor (int i=0;i<n;i++)\n\tfor (int j=0;j<=i;j++)\n\tfor (int k=0;k<=i;k++){\n\t\tchkmax(f[i+1][j][k],f[i][j][k]);\n\t\tif (j){\n\t\t\tif (ch[i+1]=='0') chkmax(f[i+1][j-1][k+1],f[i][j][k]);\n\t\t\telse chkmax(f[i+1][j-1][k],f[i][j][k]+1);\n\t\t}\n\t\tif (i+2<=n){\n\t\t\tif ((ch[i+1]=='0')||(ch[i+2]=='0')) chkmax(f[i+2][j][k+1],f[i][j][k]);\n\t\t\tif ((ch[i+1]=='1')||(ch[i+2]=='1')) chkmax(f[i+2][j][k],f[i][j][k]+1);\n\t\t\tchkmax(f[i+2][j+1][k],f[i][j][k]);\n\t\t}\n\t}\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=i;j++)\n\tfor (int k=0;k<=i;k++)\n\tchkmax(f[i][0][k],f[i][j][k]);\n\t\n\tg[n+1][0][0]=1;ans=p-1;\n\tfor (int i=n+1;i;i--)\n\tfor (int j=0;j<i;j++)\n\tfor (int k=0;j+k<i;k++){\n\t\tif (f[i-1][0][j]>=k) check(ans,g[i][j][k]);\n\t\tif (i==1) continue;\n\t\tcheck(g[i-1][j][k],g[i][j][k]);\n\t\tif (ch[i-1]=='0') check(g[i][j][k+1],g[i][j][k]);\n\t\telse check(g[i][j+1][k],g[i][j][k]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint mod = 998244353;\n\nstruct mint {\n    int value;\n\n    constexpr mint() : value() {}\n\n    mint(const long &x) {\n        value = normalize(x);\n    }\n\n    static long normalize(const long &x) {\n        long v = x % mod;\n        if (v < 0) v += mod;\n        return v;\n    }\n\n    bool operator==(const mint &x) { return value == x.value; };\n\n    mint operator+(const mint &x) { return value + x.value; };\n\n    mint operator*(const mint &x) { return (long) value * x.value; };\n\n    void operator+=(const mint &x) { value = normalize(value + x.value); };\n};\n\nbool d[301][301][301];\nmint w[301][301][301];\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    int n = s.size();\n    d[0][0][0] = true;\n    for (int i = 0; i < n; i++) {\n        for (int j0 = 0; j0 <= n; j0++) {\n            for (int j1 = 0; j1 <= n; j1++) {\n                if (i < n - 1) {\n                    if (s[i] == '0' || s[i + 1] == '0') {\n                        d[i + 2][j0 + 1][j1] |= d[i][j0][j1];\n                    }\n                    if (s[i] == '1' || s[i + 1] == '1') {\n                        d[i + 2][j0][j1 + 1] |= d[i][j0][j1];\n                    }\n                }\n                if (j0 > 0) {\n                    if (s[i] == '0') {\n                        d[i + 1][j0][j1] |= d[i][j0][j1];\n                    } else {\n                        d[i + 1][j0][j1] |= d[i][j0][j1];\n                        d[i + 1][j0 - 1][j1 + 1] |= d[i][j0][j1];\n                    }\n                }\n                if (j1 > 0) {\n                    if (s[i] == '0') {\n                        d[i + 1][j0][j1] |= d[i][j0][j1];\n                        d[i + 1][j0 + 1][j1 - 1] |= d[i][j0][j1];\n                    } else {\n                        d[i + 1][j0][j1] |= d[i][j0][j1];\n                    }\n                }\n            }\n        }\n    }\n    for (int i = n; i > 0; i--) {\n        for (int j0 = 0; j0 <= n; j0++) {\n            for (int j1 = 0; j1 <= n; j1++) {\n                if(d[i][j0][j1]) {\n                    if (s[i - 1] == '0' && j0 > 0) {\n                        d[i - 1][j0 - 1][j1] = true;\n                    }\n                    if (s[i - 1] == '1' && j1 > 0) {\n                        d[i - 1][j0][j1 - 1] = true;\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j0 = 0; j0 <= n; j0++) {\n            for (int j1 = 0; j1 <= n; j1++) {\n                if(d[i][j0][j1]) {\n                    if (s[i] == '0' && d[i + 1][j0 + 1][j1]) {\n                        d[i][j0][j1] = false;\n                    }\n                    if (s[i] == '1' && d[i + 1][j0][j1 + 1]) {\n                        d[i][j0][j1] = false;\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        for (int j0 = n; j0 >= 0; j0--) {\n            for (int j1 = n; j1 >= 0; j1--) {\n//                if (d[i][j0][j1])\n//                    cout << i << \" \" << j0 << \" \" << j1 << \" \" << d[i][j0][j1] << \"\\n\";\n                if (d[i][j0][j1]) {\n                    w[i][j0][j1] += 1;\n                }\n                if (i < n) {\n                    if (s[i] == '0') {\n                        w[i + 1][j0][j1] += w[i][j0][j1];\n                        if (j1 > 0) {\n                            w[i][j0][j1 - 1] += w[i][j0][j1];\n                        }\n                    } else {\n                        w[i + 1][j0][j1] += w[i][j0][j1];\n                        if (j0 > 0) {\n                            w[i][j0 - 1][j1] += w[i][j0][j1];\n                        }\n                    }\n                } else {\n                    if (j1 > 0) {\n                        w[i][j0][j1 - 1] += w[i][j0][j1];\n                    }\n                    if (j0 > 0) {\n                        w[i][j0 - 1][j1] += w[i][j0][j1];\n                    }\n                }\n            }\n        }\n    }\n    mint res = w[n][0][0];\n    cout << res.value << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tstring S;cin>>S;\n\tint i,j,k,n=S.size();\n\tstring T=S;\n\tREV(T);\n\tS=S+\"2222222222\";\n\tT=T+\"2222222222\";\n\tstatic int dpO[305][305]={};//地点、取得回数、0の最大数\n\tstatic int dpI[305][305]={};//地点、取得回数、1の最大数\n\tstatic int dpOa[305][305]={};//地点、取得回数、0の最大数 (未取得)\n\tstatic int dpIa[305][305]={};//地点、取得回数、1の最大数 (未取得)\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=i+2;j++){\n\t\t\tdpO[i][j]=-mod;\n\t\t\tdpOa[i][j]=-mod;\n\t\t\tdpI[i][j]=-mod;\n\t\t\tdpIa[i][j]=-mod;\n\t\t}\n\t}\n\tdpO[0][0]=0;\n\tdpI[0][0]=0;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=i;j++){\n\t\t\tchmax(dpO[i][j],dpOa[i][j]);\n\t\t\tchmax(dpO[i+1][j],dpO[i][j]);\n\t\t\tchmax(dpOa[i+1][j],dpOa[i][j]);\n\t\t\tif(S[i]=='0'){chmax(dpO[i+1][j],dpOa[i][j]+1);}\n\t\t\tif(S[i]=='0'||S[i+1]=='0'){chmax(dpO[i+2][j+1],dpO[i][j]+1);}\n\t\t\telse{chmax(dpOa[i+2][j+1],dpO[i][j]);}\n\t\t\tif(S[i]=='0'&&dpO[i][j]!=j){chmax(dpO[i+1][j],dpO[i][j]+1);}\n\t\t\t\n\t\t\tchmax(dpI[i][j],dpIa[i][j]);\n\t\t\tchmax(dpI[i+1][j],dpI[i][j]);\n\t\t\tchmax(dpIa[i+1][j],dpIa[i][j]);\n\t\t\tif(S[i]=='1'){chmax(dpI[i+1][j],dpIa[i][j]+1);}\n\t\t\tif(S[i]=='1'||S[i+1]=='1'){chmax(dpI[i+2][j+1],dpI[i][j]+1);}\n\t\t\telse{chmax(dpIa[i+2][j+1],dpI[i][j]);}\n\t\t\tif(S[i]=='1'&&dpI[i][j]!=j){chmax(dpI[i+1][j],dpI[i][j]+1);}\n\t\t\t\n\t\t\t//cerr<<\"i=\"<<i<<\"j=\"<<j<<\"dpO=\"<<dpO[i][j]<<\"dpI=\"<<dpI[i][j]<<endl;\n\t\t}\n\t}\n\t\n\tstatic llint ep[305][305][305]={};//0の数,1の数、stringのいける数\n\tep[0][0][0]=1;\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;i+j<=n;j++){\n\t\t\tfor(k=0;k<=i+j;k++){\n\t\t\t\tep[i][j][k]%=mod;\n\t\t\t\t\n\t\t\t\tif(T[k]!='0'){ep[i+1][j][k]+=ep[i][j][k];}\n\t\t\t\telse{ep[i+1][j][k+1]+=ep[i][j][k];}\n\t\t\t\t\n\t\t\t\tif(T[k]!='1'){ep[i][j+1][k]+=ep[i][j][k];}\n\t\t\t\telse{ep[i][j+1][k+1]+=ep[i][j][k];}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;i+j<=n;j++){\n\t\t\tfor(k=i+j;k>=0;k--){\n\t\t\t\tep[i][j][k]+=ep[i][j][k+1];\n\t\t\t\tep[i][j][k]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tllint Owa[301]={};\n\tfor(i=0;i<n;i++){\n\t\tOwa[i+1]=Owa[i];\n\t\tif(S[i]=='0'){Owa[i+1]++;}\n\t}\n\t\n\tllint ans=1;\n\tstatic bool mta[305][305]={};\n\tfor(i=1;i<n;i++){//文字数\n\t\tfor(j=min(n,n+n-i-i);j>=n-i+1;j--){//前方の取る数\n\t\t\tint kou=n-j;//後方のそのままの数\n\t\t\tint s=i+j-n;//前方から取得する数\n\t\t\t//cerr<<\"i=\"<<i<<\"j=\"<<j<<endl;\n\t\t\t//cerr<<\"L=\"<<s-dpI[j][s]<<\"R=\"<<dpO[j][s]<<endl;\n\t\t\tfor(k=s-dpI[j][s];k<=dpO[j][s];k++){//0取得数\n\t\t\t\tint zO=Owa[n]-Owa[n-kou]+k;\n\t\t\t\tint zI=i-zO;\n\t\t\t\tif(mta[zO][zI]){continue;}\n\t\t\t\tmta[zO][zI]=1;\n\t\t\t\tans+=ep[zO][zI][kou];\n\t\t\t\t//cerr<<\"kou=\"<<kou<<\"k=\"<<k<<endl;\n\t\t\t\t//cerr<<\"ep[\"<<zO<<\"][\"<<zI<<\"][\"<<kou<<\"]=\"<<ep[zO][zI][kou]<<endl;\n\t\t\t\tans%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int p=998244353;\nint n,m,i,j,k,l,ans,sz0,sz1,flag,v[303][303][303],f[303][303][303];\nchar s[303];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tif(n>100)return puts(\"0\"),0;\n\tf[n+1][0][0]=1;\n\tfor(i=n+1;i>=1;i--){\n\t\tfor(j=0;j<=n;j++)\n\t\t for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t\t \tif(i==1||s[i-1]!='0')(f[i][j+1][k]+=f[i][j][k])%=p;\n\t\t \tif(i==1||s[i-1]!='1')(f[i][j][k+1]+=f[i][j][k])%=p;\n\t\t \tif(i>1){\n\t\t \t\t/*if(s[i-1]=='0')(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t \t\tif(s[i-1]=='1')(f[i-1][j])*/\n\t\t \t\t(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t\t }\n\t\t }\n\t}\n\tv[0][0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t for(j=n;j>=0;j--)\n\t  for(k=n-j;k>=0;k--)if(v[i][j][k]){\n\t  \tif(j+k>=2){\n\t  \t\tif(j)v[i][j-1][k]=1;\n\t  \t\tif(k)v[i][j][k-1]=1;\n\t\t  }\n\t\tif(i<n){\n\t\t\tif(j+k>0)v[i+1][j][k]=1;\n\t\t\tif(s[i+1]=='0'){\n\t\t\t\tif(k)v[i+1][j+1][k-1]=1;\n\t\t\t}\n\t\t\tif(s[i+1]=='1'){\n\t\t\t\tif(j)v[i+1][j-1][k+1]=1;\n\t\t\t}\n\t\t}\n\t\tif(i+1<n){\n\t\t\tif(s[i+1]=='0'||s[i+2]=='0')v[i+2][j+1][k]=1;\n\t\t\tif(s[i+1]=='1'||s[i+2]=='1')v[i+2][j][k+1]=1;\n\t\t}\n\t  }\n\t  for(i=1;i<=n+1;i++)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t    \t/*printf(\"%d %d %d %d\\n\",i,j,k,f[i+1][j][k]);\n\t    \tans=(ans+f[i+1][j][k])%p;*/\n\t    \tflag=0;sz0=sz1=0;\n\t    \tfor(l=i-1;l<=n;l++){\n\t    \t\tif(v[l][j+sz0][k+sz1]){\n\t    \t\t\tflag=1;break;\n\t\t\t\t}\n\t\t\t\tif(s[l+1]=='0')sz0++;\n\t\t\t\t else sz1++;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t  ans=(ans+f[i][j][k])%p;\n\t\t\t  //printf(\"%d %d %d %d\\n\",i,j,k,f[i][j][k]);\n\t\t   }\n\t\t}\n\tprintf(\"%d\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 305;\nconst int MAX_X = 155;\n\nModint dp [MAX_N][MAX_N][MAX_N];\n// Modint udp [MAX_N][MAX_N][MAX_N];\n// dp[len][pos][c0] - the # of strings length len with\n\nint arr [MAX_N];\n// Modint choose [MAX_N][MAX_N];\nbitset<MAX_X> pdp [MAX_N][MAX_N][MAX_N];\n// <position, # taken, # 0>\n\nint main () {\n  /*\n  choose[0][0] = Modint(1);\n  for (int i = 1; i < MAX_N; i++) {\n    choose[i][0] = Modint(1);\n    for (int j = 1; j < MAX_N; j++) {\n      choose[i][j] = choose[i - 1][j - 1] + choose[i - 1][j];\n    }\n  }\n  */  \n\n  string s;\n  cin >> s;\n\n  int n = s.size();\n  for (int i = 0; i < n; i++) {\n    arr[i] = s[i] - '0';\n  }\n\n  dp[0][n][0] = Modint(1);\n  for (int i = 0; i < n; i++) {\n    for (int j = n; j >= 1; j--) {\n      for (int k = 0; k < n; k++) {\n        if (arr[j - 1] == 0) {\n          dp[i + 1][j - 1][k] += dp[i][j][k];\n          dp[i + 1][j][k] += dp[i][j][k];\n        } else {\n          dp[i + 1][j - 1][k] += dp[i][j][k];\n          dp[i + 1][j][k + 1] += dp[i][j][k];\n        }\n      }\n    }\n  }\n\n  /*\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        udp[i][j][k] = dp[i][j][k];\n        \n        if (j - 1 >= 0) {\n          if (arr[j - 1] == 0) {\n            if (k - 1 >= 0) { \n              udp[i][j][k] += udp[i][j - 1][k - 1];\n            }\n          } else {\n            udp[i][j][k] += udp[i][j - 1][k];\n          }\n        }\n      }\n    }\n  }\n  */\n\n  pdp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = 0; k < n; k++) {\n        if (pdp[i][j][k].any()) {\n          pdp[i + 1][j][k] |= pdp[i][j][k];\n          pdp[i + 2][j][k] |= pdp[i][j][k] << 1;\n          pdp[i + 2][j + 1][k + (arr[i] == 0)] |= pdp[i][j][k];\n          pdp[i + 2][j + 1][k + (arr[i + 1] == 0)] |= pdp[i][j][k];\n          pdp[i + 1][j + 1][k + (arr[i] == 0)] |= pdp[i][j][k] >> 1;\n        }\n      }\n    }\n  }\n  \n  Modint ans (0);\n  /*\n  for (int i = 0; i <= n; i += 2) { // prefix size\n    int c0p = 0;\n    for (int j = 0; j < i; j++) {\n      if (arr[j] == 0) {\n        c0p++;\n      }\n    }\n    int c1p = i - c0p;\n\n    for (int c0 = 0; c0 <= i / 2; c0++) {\n      int c1 = i / 2 - c0;\n      if (c0 <= c0p && c1 <= c1p && pdp[i][i / 2][c0]) {\n        cerr << \" \" << i << \" \" << c0 << \" \" << c1 << \" | \" << udp[n - i + i / 2][i][c0] << endl;\n        ans += udp[n - i + i / 2][i][c0];\n      }\n    }\n  }\n  */\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        if (pdp[i][j][k].any()) {\n          // cerr << \" \" << i << \" \" << k << \" \" << j - k << \" | \" << dp[n - i + j][i][k] << endl;\n          ans += dp[n - i + j][i][k];\n        }\n      }\n    }\n  }\n\n  /*\n  int c0a = 0;\n  for (int i = 0; i < n; i++) {\n    if (arr[i] == 0) {\n      c0a++;\n    }\n  }\n  int c1a = n - c0a;\n\n  for (int i = 1; 2 * i < n; i++) {\n    for (int c0 = 0; c0 <= i; c0++) {\n      int c1 = i - c0;\n      if (c0 <= c0a && c1 <= c1a) {\n        cerr << \"  \" << c0 << \" \" << c1 << \" \" << choose[i][c0] << endl;\n        ans += choose[i][c0];\n      }\n    }\n  }\n  */\n\n  cout << ans - Modint(1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=305;\nconst int mod=998244353;\nint n,s0[maxn],s1[maxn],mx[maxn][maxn];\nchar s[maxn];\nll f[maxn][maxn][maxn];\ninline void chkmax(int &a,int b) { a=(a>b)?a:b; }\nint main()\n{\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tfor(int i=n;i;i--) s0[i]=s0[i+1]+(s[i]=='0'),s1[i]=s1[i+1]+(s[i]=='1');\n\tf[0][0][n+1]=1;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tfor(int k=n+1;k;k--)\n\t\t\t\tif(f[i][j][k])\n\t\t\t\t{\n\t\t\t\t\t(f[i+1][j+1][k-((k>1)?s[k-1]=='0':0)]+=f[i][j][k])%=mod;\n\t\t\t\t\t(f[i+1][j][k-((k>1)?s[k-1]=='1':0)]+=f[i][j][k])%=mod;\n\t\t\t\t}\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t\tfor(int k=1;k<=n+1;k++) (f[i][j][k]+=f[i][j][k-1])%=mod;\n\tmx[s0[1]][s1[1]]=1;\n\tll ans=0;\n\tfor(int i=s0[1];i>=0;i--)\n\t\tfor(int j=s1[1];j>=0;j--)\n\t\t{\n\t\t\tint k=mx[i][j];\n\t\t\tif(k<n)\n\t\t\t{\n\t\t\t\tif((s[k]=='0' || s[k+1]=='0') && i) chkmax(mx[i-1][j],k+2);\n\t\t\t\tif((s[k]=='1' || s[k+1]=='1') && j) chkmax(mx[i][j-1],k+2);\n\t\t\t}\n\t\t\tif(i && (k>n || i>s0[k+1])) chkmax(mx[i-1][j],min(k+1,n+1));\n\t\t\tif(j && (k>n || j>s1[k+1])) chkmax(mx[i][j-1],min(k+1,n+1));\n\t\t\tif(mx[i][j] && i+j>0) (ans+=f[i+j][i][mx[i][j]])%=mod;\n\t\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint pd[310][310][310];\nint pd2[310][310][310];\nint cnt[2][310];\nstring s;\nint n;\n\nint rec(int pos, int av0, int av1) {\n    if (av0+av1 == 0) return 1;\n    \n    int &ret = pd2[pos][av0][av1];\n    if (ret == -1) {\n        ret = 0;\n\n        if (pos != n && s[pos] == '0') {\n            ret = (ret + rec(pos+1, av0, av1)) % mod;\n        }\n        else if (av0) {\n            ret = (ret + rec(pos, av0-1, av1)) % mod;\n        }\n\n        if (pos != n && s[pos] == '1') {\n            ret = (ret + rec(pos+1, av0, av1)) % mod;\n        }\n        else if (av1) {\n            ret = (ret + rec(pos, av0, av1-1)) % mod;\n        }\n    }\n\n    // cout << pos << \" \" << av0 << \" \" << av1 << \" -> \" << ret << endl;\n    return ret;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> s;\n    n = s.size();\n\n    memset(pd2,-1,sizeof(pd2));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 2; j++) cnt[j][i+1] = cnt[j][i];\n        cnt[s[i]-'0'][i+1]++;\n    }\n\n    pd[0][0][0] = 1;\n    for (int pos = 0; pos < n; pos++) {\n        for (int del0 = 0; del0 <= cnt[0][n]; del0++) {\n            for (int del1 = 0; del1 <= cnt[1][n]; del1++) if (pd[pos][del0][del1]) {\n\n                if (pos+2 <= n) {\n                    // delete first value\n                    int nd0 = del0, nd1 = del1;\n                    if (s[pos] == '0') nd0++;\n                    if (s[pos] == '1') nd1++;\n\n                    pd[pos+2][nd0][nd1]=1;\n\n                    // delete second value\n                    nd0 = del0; nd1 = del1;\n                    if (s[pos+1] == '0') nd0++;\n                    if (s[pos+1] == '1') nd1++;\n                    pd[pos+2][nd0][nd1]=1;\n                }\n\n                // delete extras\n                int av0 = cnt[0][pos] - del0, av1 = cnt[1][pos] - del1;\n                \n                if (av0) pd[pos+1][del0+1][del1]=1;\n                if (av1) pd[pos+1][del0][del1+1]=1;\n\n                \n                // delete values using extras\n                int nd0 = del0, nd1 = del1;\n                if (s[pos] == '0') nd0++;\n                if (s[pos] == '1') nd1++;\n                if (av0 || av1) pd[pos+1][nd0][nd1]=1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int del0 = 0; del0 <= cnt[0][n]; del0++) {\n        for (int del1 = 0; del1 <= cnt[1][n]; del1++) {\n            // if (del0 != 1 || del1 != 1) continue;\n            for (int pos = n; pos >= 0; pos--) if (pd[pos][del0][del1]) {\n                // cout << \"for del0 = \" << del0 << \" , del1 = \" << del1 << \", pos = \" << pos << \" \";\n                int av0 = cnt[0][pos] - del0, av1 = cnt[1][pos] - del1;\n                ans = (ans + rec(pos, av0, av1)) % mod;\n                // cout << \" -> ret = \" << rec(pos,av0,av1) << endl;\n                break;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nmodint dp[303][303][303];\nmodint dp2[303][303][303];\n\n//i回捨て、そのうちj回が0である時の右端\nint madp[303][303];\nvoid solve() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tdp[0][0][0] = 1;\n\tdp2[0][0][0] = 1;\n\trep(i, n + 1) {\n\t\trep(j, n + 1) {\n\t\t\trep(k, n + 1) {\n\t\t\t\t//put 0\n\t\t\t\tif (j < n&&s[n - 1 - j] == '0') {\n\t\t\t\t\tdp[i + 1][j + 1][k] += dp[i][j][k];\n\t\t\t\t\tdp2[i + 1][j + 1][k] += dp[i][j][k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][k + 1] += dp[i][j][k];\n\t\t\t\t}\n\t\t\t\t//put 1\n\t\t\t\tif (j < n&&s[n - 1 - j] == '1') {\n\t\t\t\t\tdp[i + 1][j + 1][k] += dp[i][j][k];\n\t\t\t\t\tdp2[i + 1][j + 1][k] += dp[i][j][k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j][k] += dp[i][j][k];\n\t\t\t\t}\n\n\t\t\t\t//put 0\n\t\t\t\tdp2[i + 1][j][k + 1] += dp2[i][j][k];\n\t\t\t\t//put 1\n\t\t\t\tdp2[i + 1][j][k] += dp2[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> cnt(n + 1);\n\trep(i, n) {\n\t\tcnt[i + 1] += cnt[i];\n\t\tif (s[i] == '0')cnt[i + 1]++;\n\t}\n\trep(i, n + 1)rep(j, n + 1)madp[i][j] = -mod;\n\tmadp[0][0] = 0;\n\trep(i, n-1) {\n\t\trep(j, i+1) {\n\t\t\tif (madp[i][j] < 0)continue;\n\t\t\t\n\t\t\t//take new x\n\t\t\trep(x, 3) {\n\t\t\t\tint ri = madp[i][j];\n\t\t\t\tif (ri + x <= n) {\n\t\t\t\t\tint c0 = cnt[ri + x] - j;\n\t\t\t\t\tint c1 = ri + x - i - c0;\n\t\t\t\t\tif (c0 < 0 || c1 < 0)continue;\n\t\t\t\t\tif (c0 > 0) {\n\t\t\t\t\t\tif (x == 2 && s[ri] == '1'&&s[ri + 1] == '1') {\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tmadp[i + 1][j + 1] = max(madp[i + 1][j + 1], ri + x);\n\t\t\t\t\t}\n\t\t\t\t\tif (c1 > 0) {\n\t\t\t\t\t\tif (x == 2 && s[ri] == '0'&&s[ri + 1] == '0') {\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tmadp[i + 1][j] = max(madp[i + 1][j], ri + x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmodint ans = 0;\n\trep(i, n) {\n\t\trep(j, i + 1) {\n\t\t\tif (madp[i][j] < 0)continue;\n\t\t\tint num = n - madp[i][j];\n\t\t\tint nnum = cnt[madp[i][j]] - j;\n\t\t\tans += dp2[n - i][num][nnum];\n\t\t\t//cout << n-i << \" \" << num << \" \" << nnum <<\" \"<<dp2[n-i][num][nnum] <<\"\\n\";\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(10);\n\tinit_f();\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 3e2 + 10;\nint C[N * 2][N * 2];\nchar s[N];\nint dp[N][N][N];\nbool visit[N][N][N];\nint suf[N][2];\nint n;\n\nint solve(int pos, int zero, int one) {\n  int& ret = dp[pos][zero][one];\n  if (ret >= 0) return ret;\n  if (pos == n) return ret = C[zero + one][zero];\n  if (suf[pos][0] > zero || suf[pos][1] > one) return ret = 0;\n  ret = 0;\n  // put 0\n  if (zero > 0) {\n    ret += solve(s[pos] == '0' ? pos + 1 : pos, zero - 1, one);\n    ret %= MOD;\n  }\n  // put 1\n  if (one > 0) {\n    ret += solve(s[pos] == '1' ? pos + 1 : pos, zero, one - 1);\n    ret %= MOD;\n  }\n  return ret;\n}\n\nstruct Node {\n  int pos, zero, one;\n};\n\nint main() {\n  for (int i = 0; i < N * 2; ++i) {\n    C[i][0] = C[i][i] = 1;\n    for (int j = 1; j < i; ++j) {\n      C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n    }\n  }\n  scanf(\"%s\", s);\n  n = strlen(s);\n  for (int i = n - 1; i >= 0; --i) {\n    suf[i][0] = suf[i + 1][0] + (s[i] == '0');\n    suf[i][1] = suf[i + 1][1] + (s[i] == '1');\n    // trace(i, suf[i][0], suf[i][1]);\n  }\n  memset(dp, 255, sizeof(dp));\n  queue<Node> Q;\n  Q.push({0, 0, 0});\n  visit[0][suf[0][0]][suf[0][1]] = true;\n  while (!Q.empty()) {\n    auto [pos, zero, one] = Q.front();\n    Q.pop();\n    // int len = one + zero + n - pos;\n    // int X = zero + suf[pos][0], Y = one + suf[pos][1];\n    int cur = solve(pos, zero + suf[pos][0], one + suf[pos][1]);\n    // trace(zero, one, len, pos, X, Y, cur);\n    // pick 2\n    if (pos + 2 <= n) {\n      vector<int> cnt(2);\n      cnt[s[pos] - '0']++;\n      cnt[s[pos + 1] - '0']++;\n      for (int i = 0; i <= 1 && i <= cnt[0]; ++i) {\n        int j = 1 - i;\n        if (j > cnt[1]) continue;\n        int nxt_zero = zero + i, nxt_one = one + j;\n        if (!visit[pos + 2][suf[pos + 2][0] + nxt_zero][suf[pos + 2][1] + nxt_one]) {\n          Q.push({pos + 2, nxt_zero, nxt_one});\n          visit[pos + 2][suf[pos + 2][0] + nxt_zero][suf[pos + 2][1] + nxt_one] = true;\n        }\n      }\n    }\n    // pick 1\n    if (pos + 1 <= n && one + zero >= 1) {\n      for (int u = 0; u <= 1 && u <= zero; ++u) {\n        int v = 1 - u;\n        if (v > one) continue;\n        vector<int> cnt = {u, v};\n        cnt[s[pos] - '0']++;\n        for (int i = 0; i <= 1 && i <= cnt[0]; ++i) {\n          int j = 1 - i;\n          if (j > cnt[1]) continue;\n          int nxt_zero = zero - u + i, nxt_one = one - v + j;\n          if (!visit[pos + 1][suf[pos + 1][0] + nxt_zero][suf[pos + 1][1] + nxt_one]) {\n            Q.push({pos + 1, nxt_zero, nxt_one});\n            visit[pos + 1][suf[pos + 1][0] + nxt_zero][suf[pos + 1][1] + nxt_one] = true;\n          }\n        }\n      }\n    }\n    // pick 0\n    if (one + zero >= 2) {\n      for (int u = 0; u <= 2 && u <= zero; ++u) {\n        int v = 2 - u;\n        if (v > one) continue;\n        vector<int> cnt = {u, v};\n        for (int i = 0; i <= 1 && i <= cnt[0]; ++i) {\n          int j = 1 - i;\n          if (j > cnt[1]) continue;\n          int nxt_zero = zero - u + i, nxt_one = one - v + j;\n          if (!visit[pos][suf[pos][0] + nxt_zero][suf[pos][1] + nxt_one]) {\n            Q.push({pos, nxt_zero, nxt_one});\n            visit[pos][suf[pos][0] + nxt_zero][suf[pos][1] + nxt_one] = true;\n          }\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for (int X = 0; X <= suf[0][0]; ++X) {\n    for (int Y = 0; Y <= suf[0][1]; ++Y) {\n      for (int pos = n; pos >= 0; --pos) {\n        if (X == 0 && Y == 0 && pos == n) continue;\n        if (dp[pos][X][Y] >= 0) {\n          // trace(X, Y, pos, dp[pos][X][Y]);\n          ret = (ret + dp[pos][X][Y]) % MOD;\n          break;\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nset<tuple<int, int, int, int> > chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tif (chk[L - i + z + o + f].count({ i,z,o,f })) return;\n\tchk[L - i + z + o + f].insert({ i,z,o,f });\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\tif (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\tif (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint p = -1, s = -1, e = -1;\n\t\tfor (auto& t : chk[l]){\n\t\t\tauto& [i, z, o, f] = t;\n\t\t\tif (p < i){\n\t\t\t\tif (p != -1){\n\t\t\t\t\tfor (int j = s; j <= e; j++) pin[j + zc[p]] = p;\n\t\t\t\t}\n\t\t\t\tp = i;\n\t\t\t\ts = z;\n\t\t\t\te = z + f;\n\t\t\t}\n\t\t\telse if (p == i){\n\t\t\t\ts = min(s, z);\n\t\t\t\te = max(e, z + f);\n\t\t\t}\n\t\t}\n\t\tif (p != -1){\n\t\t\tfor (int j = s; j <= e; j++) pin[j + zc[p]] = p;\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t\t//printf (\"%d %lld\\n\", l, ret);\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n//INSERT ABOVE HERE\nusing M = Mint<int, 998244353>;\nconst int MAX = 333;\n\nint dp[MAX][MAX][MAX]={};\nint ok[MAX][MAX][MAX]={};\n\nM ct[MAX][MAX][MAX]={};\n\nint zs[MAX]={};\nint os[MAX]={};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  string s;\n  cin>>s;\n\n  int n=s.size();\n  for(int i=n-1;i>=0;i--){\n    zs[i]=zs[i+1]+(s[i]=='0');\n    os[i]=os[i+1]+(s[i]=='1');\n  }\n\n  dp[0][0][0]=1;\n  for(int i=0;i<n;i++){\n    for(int x=0;x+1<MAX;x++){\n      for(int y=0;y+1<MAX;y++){\n        // stock & current\n        {\n          int k=s[i]-'0';\n          // drop current\n          if(x+y>0) dp[i+1][x][y]|=dp[i][x][y];\n          if(x>0) dp[i+1][x-1+(k==0)][y-0+(k==1)]|=dp[i][x][y];\n          if(y>0) dp[i+1][x-0+(k==0)][y-1+(k==1)]|=dp[i][x][y];\n        }\n\n        if(i+1>=n) continue;\n\n        // current & next\n        {\n          int p=s[i+0]-'0';\n          int q=s[i+1]-'0';\n\n          // use p\n          dp[i+2][x+(p==0)][y+(p==1)]|=dp[i][x][y];\n          dp[i+2][x+(p==0)][y+(p==1)]|=dp[i][x][y];\n\n          // use q\n          dp[i+2][x+(q==0)][y+(q==1)]|=dp[i][x][y];\n          dp[i+2][x+(q==0)][y+(q==1)]|=dp[i][x][y];\n        }\n      }\n    }\n  }\n\n  for(int i=0;i<=n;i++)\n    for(int x=0;zs[i]+x<MAX;x++)\n      for(int y=0;os[i]+y<MAX;y++)\n        ok[i][zs[i]+x][os[i]+y]|=dp[i][x][y];\n\n  const int DEBUG = 0;\n  if(DEBUG){\n    for(int i=0;i<=n;i++)\n      for(int x=0;x<MAX;x++)\n        for(int y=0;y<MAX;y++)\n          if(ok[i][x][y]) cerr<<i<<' '<<x<<' '<<y<<endl;\n  }\n\n  for(int i=MAX-1;i>=0;i--){\n    for(int x=MAX-1;x>=0;x--){\n      for(int y=MAX-1;y>=0;y--){\n        if(i) ok[i-1][x-0][y-0]|=ok[i][x][y];\n        // if(x) ok[i-0][x-1][y-0]|=ok[i][x][y];\n        // if(y) ok[i-0][x-0][y-1]|=ok[i][x][y];\n      }\n    }\n  }\n\n  ct[n][0][0]=M(1);\n  for(int i=n;i>=0;i--){\n    for(int x=0;x+1<MAX;x++){\n      for(int y=0;y+1<MAX;y++){\n        char c=i?s[i-1]:'?';\n        ct[i-(c=='0')][x+1][y+0]+=ct[i][x][y];\n        ct[i-(c=='1')][x+0][y+1]+=ct[i][x][y];\n      }\n    }\n  }\n\n  if(DEBUG){\n    for(int i=0;i<=n;i++)\n      for(int x=0;x<MAX;x++)\n        for(int y=0;y<MAX;y++)\n          if(ok[i][x][y]) cerr<<i<<' '<<x<<' '<<y<<':'<<ct[i][x][y]<<endl;\n  }\n\n  M ans{0};\n  for(int i=0;i<=n;i++)\n    for(int x=0;x<MAX;x++)\n      for(int y=0;y<MAX;y++)\n        if(ok[i][x][y]) ans+=ct[i][x][y];\n\n  // empty\n  //  ans-=M(1);\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    author:  Maksim1744\n    created: 20.06.2020 16:18:52\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll   long long\n#define ld   long double\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T>& v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T>& v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T>& v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>& v){for (auto& i : v) os << i << ' '; return os;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U>& p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>& p){os << p.first << ' ' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define TAG_LENGTH       25\n#define LR_LEFT          left\n#define LR_RIGHT         right\n#define LR_VALUE         value\n#define LR_SECOND_VALUE  mn\n#include \"C:/C++ libs/print.cpp\"\n#else\n#define showl            42;\n#define shows            42;\n#define show(...)        42;\n#define showm(...)       42;\n#define showt(...)       42;\n#define printTree(...)   42;\n#define printGraph(...)  42;\n#define printLRTree(...) 42;\n#define printMatrix(...) 42;\n#define printWGraph(...) 42;\n#define debug     if (false)\n#endif\n\ntemplate<int P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    Modular& operator += (const Modular& m)       { value += m.value; if (value >= P) value -= P; return *this; }\n    Modular  operator +  (const Modular& m) const { Modular r = *this; return r += m; }\n\n    Modular& operator -= (const Modular& m)       { value -= m.value; if (value <  0) value += P; return *this; }\n    Modular  operator -  (const Modular& m) const { Modular r = *this; return r -= m; }\n    Modular  operator -                     () const { return Modular(-value); }\n\n    Modular& operator *= (const Modular &m)       { value = value * 1ll * m.value % P; return *this; }\n    Modular  operator *  (const Modular& m) const { Modular r = *this; return r *= m; }\n\n    Modular& operator /= (const Modular &m)       { return *this *= m.inv(); }\n    Modular  operator /  (const Modular& m) const { Modular r = *this; return r /= m; }\n\n    Modular& operator ++                    ()       { return *this += 1; }\n    Modular& operator --                    ()       { return *this -= 1; }\n    Modular  operator ++                 (int)       { Modular r = *this; r += 1; return r; }\n    Modular  operator --                 (int)       { Modular r = *this; r -= 1; return r; }\n\n    bool        operator == (const Modular& m) const { return value == m.value; }\n    bool        operator != (const Modular& m) const { return value != m.value; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\n\ntemplate<int P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<int P> ostream& operator << (ostream& o, const Modular<P> m) { return o << m.value; }\ntemplate<int P> istream& operator >> (istream& i,       Modular<P> m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<int P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\n// using Mint = Modular<1000000007>;\nusing Mint = Modular<998244353>;\n// using Mint = long double;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    string s;\n    cin >> s;\n    int N = s.size() + 3;\n    vector<vector<Mint>> C(N * 2 + 5, vector<Mint>(N * 2 + 5, 0));\n    for (int i = 0; i < C.size(); ++i) {\n        C[0][i] = 0;\n        C[i][0] = 1;\n    }\n    for (int i = 1; i < C.size(); ++i) {\n        for (int j = 1; j < C.size(); ++j) {\n            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n        }\n    }\n    vector<vector<vector<Mint>>> dp(N, vector<vector<Mint>>(N, vector<Mint>(N, 0)));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[s.size()][i][j] = C[i + j][i];\n        }\n    }\n    for (int i = s.size() - 1; i >= 0; --i) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                if (s[i] == '1') {\n                    dp[i][j][k] = (j == 0 ? Mint(0) : dp[i][j - 1][k]) + dp[i + 1][j][k];\n                } else {\n                    dp[i][j][k] = dp[i + 1][j][k] + (k == 0 ? Mint(0) : dp[i][j][k - 1]);\n                }\n            }\n        }\n    }\n    vector<vector<vector<bool>>> can(N, vector<vector<bool>>(N, vector<bool>(N, 0)));\n    can[0][0][0] = true;\n    for (int i = 1; i <= s.size(); ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                if (i >= 2) {\n                    if (s[i - 1] == '0' || s[i - 2] == '0')\n                        if (j >= 1)\n                            can[i][j][k] = can[i][j][k] || can[i - 2][j - 1][k];\n                    if (s[i - 1] == '1' || s[i - 2] == '1')\n                        if (k >= 1)\n                            can[i][j][k] = can[i][j][k] || can[i - 2][j][k - 1];\n                }\n                if (j > 0 || k > 0)\n                    can[i][j][k] = can[i][j][k] || can[i - 1][j][k];\n\n                if (s[i - 1] == '0' && j > 0 && k + 1 < N) {\n                    can[i][j][k] = can[i][j][k] || can[i - 1][j - 1][k + 1];\n                }\n                if (s[i - 1] == '1' && k > 0 && j + 1 < N) {\n                    can[i][j][k] = can[i][j][k] || can[i - 1][j + 1][k - 1];\n                }\n            }\n        }\n    }\n    function<void(int, int)> dfs = [&](int i, int j) {\n        can[s.size()][i][j] = true;\n        if (i > 0 && !can[s.size()][i - 1][j])\n            dfs(i - 1, j);\n        if (j > 0 && !can[s.size()][i][j - 1])\n            dfs(i, j - 1);\n    };\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (can[s.size()][i][j])\n                dfs(i, j);\n        }\n    }\n    Mint ans = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i == 0 && j == 0) continue;\n            int ind = -1;\n            int i0 = 0, j0 = 0;\n            for (int x = s.size(); x >= 0; --x) {\n                if (i < i0 || j < j0) break;\n                if (can[x][i - i0][j - j0]) {\n                    ind = x;\n                    break;\n                }\n                if (x != 0) {\n                    i0 += (s[x - 1] == '0');\n                    j0 += (s[x - 1] == '1');\n                }\n            }\n            if (ind != -1) {\n                // show(i, j);\n                // show(i0, j0);\n                // show(ind, dp[ind][i-i0][j-j0]);\n                // shows;\n                ans += dp[ind][i - i0][j - j0];\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 307;\nint n;\nchar s[N];\nmodint f[N][N][N], ans;\nint g[N][N][N];\nbool v[N][N][N];\n\ninline void upd(int &x, int y) {\n\tx = max(x, y);\n} \n\nint main() {\n\trds(s, n);\n\tf[n][0][0] = 1;\n\tfor (int i = n; i; i--)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tfor (int k = 0; j + k < i; k++) {\n\t\t\t\tf[i-1][j][k] += f[i][j][k];\n\t\t\t\tif (s[i] == '0') f[i][j][k+1] += f[i][j][k];\n\t\t\t\telse f[i][j+1][k] += f[i][j][k];\n\t\t\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\tg[i][j][k] = -1;\n\tg[0][0][0] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j <= (i >> 1); j++)\n\t\t\tfor (int k = 0; j + k <= (i >> 1); k++)\n\t\t\t\tif (~g[i][j][k]) {\n\t\t\t\t\tif (s[i+1] == '0') upd(g[i+1][j+1][k], g[i][j][k] - 1);\n\t\t\t\t\telse upd(g[i+1][j][k+1], g[i][j][k] - 1);\n\t\t\t\t\tif (i + 2 <= n) {\n\t\t\t\t\t\tupd(g[i+2][j][k], g[i][j][k] + 1);\n\t\t\t\t\t\tif (s[i+1] == '0' || s[i+2] == '0')\n\t\t\t\t\t\t\tupd(g[i+2][j+1][k], g[i][j][k]);\n\t\t\t\t\t\tif (s[i+1] == '1' || s[i+2] == '1')\n\t\t\t\t\t\t\tupd(g[i+2][j][k+1], g[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = n; ~j; j--)\n\t\t\tfor (int k = n; ~k; k--) {\n\t\t\t\tv[i][j][k] = ~g[i][j][k];\n\t\t\t\tif (i) v[i][j][k] |= v[i-1][j][k];\n\t\t\t\tv[i][j][k] |= v[i][j+1][k];\n\t\t\t\tv[i][j][k] |= v[i][j][k+1];\n\t\t\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; j + k <= i; k++)\n\t\t\t\tif (v[i][j][k]) ans += f[i][j][k];\n\tprint(ans - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#undef int \n\nconst int MOD = 998244353; \nint choose [1005][1005]; \n\nint s [305]; \n\nint dp [305][305][305]; \nbool can_make [305][305][305]; \n\nint main(){\n    #define int long long\n    ios_base::sync_with_stdio(0); \n\n    for (int i=0; i<=1000; i++) choose[i][0] = 1; \n    for (int i=1; i<=1000; i++){\n        for (int j=1; j<=1000; j++){\n            choose[i][j] = choose[i-1][j-1] + choose[i-1][j]; \n            choose[i][j] %= MOD; \n        }\n    }\n\n    string x; cin >> x; \n    for (int i=1; i<=(int)x.length(); i++) s[i] = x[i-1]-'0'; \n    int tot0=0,tot1=0; \n    for (int i=1; i<=(int)x.length(); i++){\n        if(s[i])tot1++;\n        else tot0++;\n    }\n\n    int n = (int)x.length(); \n\n    for (int i=0; i<=300; i++){\n        for (int j=0; j<=300; j++){\n            dp[n + 1][i][j] = choose[i + j][j]; \n        }\n    }\n    for (int i=n; i>=1; i--){\n        for (int j=0; j<=300; j++){ // num zero\n            for (int k=0; k<=300; k++){ // num one\n                if (s[i]==1){\n                    dp[i][j][k] += dp[i + 1][j][k]; \n                    if (j > 0) dp[i][j][k] += dp[i][j - 1][k]; \n                    dp[i][j][k] %= MOD; \n                }\n                else{\n                    dp[i][j][k] += dp[i + 1][j][k]; \n                    if (k > 0) dp[i][j][k] += dp[i][j][k - 1]; \n                    dp[i][j][k] %= MOD;                     \n                }\n            }\n        }\n    }\n    can_make[0][0][0] = 1; \n    for (int i=1; i<=n; i++){\n        for (int j=0; j<=300; j++){\n            for (int k=0; k<=300; k++){\n                can_make[i][j][k] = can_make[i - 1][j][k]; \n                if ((!s[i]) && j)\n                    can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 1][j - 1][k + 1]);\n                if ((s[i]) && k)\n                    can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 1][j + 1][k - 1]);\n                if (i >= 2){\n                    if ((!s[i]) && j)\n                        can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 2][j - 1][k]);\n                    if ((s[i]) && k)\n                        can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 2][j][k - 1]);                    \n                    if ((!s[i - 1]) && j)\n                        can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 2][j - 1][k]);\n                    if ((s[i - 1]) && k)\n                        can_make[i][j][k] = max(can_make[i][j][k], can_make[i - 2][j][k - 1]);        \n                }\n            }\n        }\n    }\n    int ans=0; \n    for (int i=0; i<=300; i++){\n        for (int j=0; j<=300; j++){\n            int num0=0,num1=0; \n            int ind=-1,ind2=-1,ind3=-1; \n            for (int k=1; k<=n+1; k++){\n                int num0_right = tot0 - num0; \n                int num1_right = tot1 - num1; \n                if (num0_right <= i && num1_right <= j){ \n                    int num0_left = i - num0_right; \n                    int num1_left = j - num1_right; \n                    if (num0_left <= num0 && num1_left <= num1){\n                        if (num0 + num1 == 0 || (num0_left + num1_left > 0)){\n                            if (can_make[k - 1][num0_left][num1_left]){\n                                ind=k, ind2=num0_left, ind3=num1_left; \n                            }\n                        }\n                    }\n                }\n                if (k <= n){\n                    if (s[k]) num1++; \n                    else num0++; \n                }\n            }\n            if (ind!=-1){\n                ans += dp[ind][ind2][ind3]; \n                ans %= MOD;\n            }\n        }\n    }\n\n    cout << ans << '\\n'; \n\n    return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl \"\\n\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long long INF = 1e18;\nconst ll mod = 998244353;\n//ll dp[155][155][305];\nll ans = 0;\nll checker[305][305][305];\nll dp[305][305][305];\nset<string> st;\nvoid dfs(string S) {\n    if(st.find(S) != st.end()) return;\n  cerr << S << endl;\n    st.insert(S);\n    if(S.size() < 2) return;\n    string T = S.substr(2, S.size());\n    string Add = S.substr(0, 2);\n    for(int i = 0; i < 2; i++) {\n      for(int j = 0; j <= T.size(); j++) {\n        string to = T;\n        to.insert(to.begin() + j, Add[i]);\n        dfs(to);\n      }\n    }\n}\n\nint main() {\n    string S;\n  cin >> S;\n  if(S.size() <= 3) {\n    dfs(S);\n    cout << st.size() << endl;\n    return 0;\n  }\n    checker[0][0][0] = 1;\n    for(int k = 0; k <= S.size(); k++) {\n        for(int i = S.size(); i >= 0; i--) {\n            for(int j = S.size(); j >= 0; j--) {\n                if(!checker[i][j][k]) continue;\n                //cerr << i << \" \" << j << \" \" << k << endl;\n                if(k + 2 <= S.size()) {\n                    string T = S.substr(k, 2);\n                    if(T != \"11\") checker[i+1][j][k+2] = 1;\n                    if(T != \"00\") checker[i][j+1][k+2] = 1;\n                }\n                if(i >= 2) checker[i-2][j][k] = 1;\n                if(j >= 2) checker[i][j-2][k] = 1;\n                if(i >= 1 and j >= 1) checker[i-1][j-1][k] = 1;\n                if(i >= 1 or j >= 1) checker[i][j][k+1] = 1;\n                if(i >= 1 and k + 1 <= S.size() and S[k] == '1') {\n                    checker[i-1][j+1][k+1] = 1;\n                }\n                if(j >= 1 and k + 1 <= S.size() and S[k] == '0') {\n                    checker[i+1][j-1][k+1] = 1;\n                }\n            }\n        }\n    }\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(checker[i][j][k] == 0) continue;\n                if(checker[i][j][k] == 1) {\n                    //cerr << i + j + (S.size() - k) << \" \" << i << \" \" << j << \" \" << k << endl;\n                }\n                if(k == 0) continue;\n                ll newi = i;\n                ll newj = j;\n                if(S[k-1] == '0') newi--;\n                if(S[k-1] == '1') newj--;\n                if(newi < 0 or newj < 0) continue;\n                //checker[newi][newj][k+1] = 2;\n                checker[newi][newj][k-1] = 2;\n            }\n        }\n    }\n    dp[0][0][S.size()] = 1;\n    for(int k = S.size(); k >= 0; k--) {\n        for(int i = 0; i <= S.size(); i++) {\n            for(int j = 0; j <= S.size(); j++) {\n                if(k < S.size()) {\n                    dp[i][j][k] += dp[i][j][k+1];\n                    if(S[k] == '0' and j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(S[k] == '1' and i > 0) dp[i][j][k] += dp[i-1][j][k];\n                } else {\n                    if(j > 0) dp[i][j][k] += dp[i][j-1][k];\n                    if(i > 0) dp[i][j][k] += dp[i-1][j][k];\n                }\n                dp[i][j][k] %= mod;\n                if(checker[i][j][k] == 1 and dp[i][j][k]) {\n                    //cerr << i << \" \" << j << \" \" << k << \" \" << S.substr(k, S.size()) << \" \" << dp[i][j][k] << endl;\n                    ans += dp[i][j][k];\n                    ans %= mod;\n                }\n            }\n        }\n    }\n    //cerr << dp[1][0][6] << \" \" << checker[1][0][6] << endl;\n    //cerr << dp[0][1][6] << \" \" << checker[0][1][6] << endl;\n    ans += mod - 1;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 998244353 ;\nconst int inf = 1e9 + 7;\nconst int N = 3e2 + 5;\nconst double eps = 1e-9;\nint vis[N][N][N], C[N][N], lst[N][N];\nstring s;\n\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint sub(int x, int y) { return x-y < 0 ? x-y+mod : x-y; }\nint mul(int x, int y) { return x * 1ll * y % mod; }\n\nvoid dfs(int i, int j, int k) {\n  if (min({i,j,k}) < 0 || vis[i][j][k])\n    return;\n  vis[i][j][k] = 1;\n  if (k == 0)\n    return;\n  if (i+j) {\n    dfs(i-1, j, k-1);\n    dfs(i, j-1, k-1);\n  }\n  if (s[sz(s)-k] == '0') {\n    dfs(i+1, j, k-2); // XY. -> Y.\n    dfs(i, j, k-1);\n    dfs(i+1, j-1, k-1);\n  }\n  if (s[sz(s)-k] == '1') {\n    dfs(i, j+1, k-2); // XY. -> Y.\n    dfs(i-1, j+1, k-1);\n    dfs(i, j, k-1);\n  }\n  if (k > 1 && s[sz(s)-k+1] == '0') // XY. -> .X <-> .\n    dfs(i+1, j, k-2);\n  if (k > 1 && s[sz(s)-k+1] == '1') // XY. -> .X <-> .\n    dfs(i, j+1, k-2);\n}\n\nint calc(int i, int j, int a, int b) {\n  // int r = 0;\n  // for (int msk = 0; msk < (1 << (i+j+a+b)); msk++) {\n  //   if (__builtin_popcount(msk) != j+b)\n  //     continue;\n  //   int l1 = 0, r1 = 0, cl = -1, cr = i+j+a+b;\n  //   for (int it = 0; it < i+j+a+b && l1 < a; it++)\n  //     if (!(msk & (1 << it))) {\n  //       l1++;\n  //       cl = it;\n  //     }\n  //   for (int it = i+j+a+b-1; it >= 0 && r1 < b; it--)\n  //     if ((msk & (1 << it))) {\n  //       r1++;\n  //       cr = it;\n  //     }\n  //   assert(l1 == a);\n  //   assert(r1 == b);\n  //   r += cl <= cr;\n  //   // if (i == 0 && j == 1 && a == 0 && b == 0)\n  //   //   cerr << msk << endl;\n  // }\n  int r2 = 0;\n  if (a == 0)\n    r2 = C[a+i+b+j][a+i];\n  else for (int k = a; k <= a+j; k++)\n    r2 = add(r2, mul(C[k-1][a-1], C[a+i+b+j-k][i]));\n  // if (r != r2)\n    // printf(\"ins %dx0, %dx1 into a suffix of length %d+%d: %d\\n\", i, j, a, b, r2);\n  return r2;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  C[0][0] = 1;\n  for (int i = 1; i < N; C[i++][0] = 1)\n    for (int j = 1; j <= i; j++)\n      C[i][j] = add(C[i-1][j], C[i-1][j-1]);\n  cin >> s;\n  int n = sz(s);\n  dfs(0, 0, n);\n  int ans = 0;\n  memset(lst, -1, sizeof lst);\n  auto upd = [&](int& x, int y) {\n    if (x == -1 || y < x)\n      x = y;\n  };\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      int cnt[2] = {0,0};\n      for (int k = 0; k <= n; k++) {\n        if (k) cnt[s[n-k]-'0']++;\n        if (vis[i][j][k]) {\n          upd(lst[i+cnt[0]][j+cnt[1]], k);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      int cnt[2] = {0,0};\n      int ok = 0, l = 0;\n      for (int k = n; k >= 0; k--) {\n        if (vis[i][j][k]) {\n          ok = 1;\n          l = k;\n          break;\n        }\n      }\n      if (!ok) continue;\n      for (int k = 0; k <= n; k++) {\n        if (k) cnt[s[n-k]-'0']++;\n        if (!vis[i][j][k] || k != lst[i+cnt[0]][j+cnt[1]])\n          continue;\n        // if (k != l)\n        //   continue;\n        // ins ix0, jx1 into a suffix of length k\n        ans = add(ans, calc(i, j, cnt[0], cnt[1]));\n        // break;\n      }\n    }\n  }\n  ans = sub(ans, 1);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 998244353>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\n\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 0\n\t//時間計算量O(logMOD)\n\tstatic const auto fact_v = fact_set_c<100001>();\n\treturn fact_v[all] / (fact_v[get] * fact_v[all - get]);\n#elif 1\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 1000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get + logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n\nint N;\nstd::string S;\nmint dp2[310][310][310];\nbool used2[310][310][310];\nmint func2(int i, int zero, int one)\n{\n\tif (zero < 0) { return 0_mi; }\n\tif (one < 0) { return 0_mi; }\n\tif (i == N && zero == 0 && one == 0) {\n\t\treturn 1_mi;\n\t}\n\tauto& memo = dp2[zero][i][one];\n\tauto& USED = used2[zero][i][one];\n\tif (USED) {\n\t\treturn memo;\n\t}\n\tUSED = true;\n\n\tif (i == N) {\n\t\treturn memo = func2(i, zero - 1, one) + func2(i, zero, one - 1);\n\t}\n\n\tif (S[i] == '1') {\n\t\tmemo = func2(i, zero - 1, one) + func2(i + 1, zero, one);\n\t}\n\telse {\n\t\tmemo = func2(i + 1, zero, one) + func2(i, zero, one - 1);\n\t}\n\t//assert(N - i != len || (uint64_t)(memo) == 1);\n\treturn memo;\n\n\n}\n\n\n\n//std::map<int, int> CAMPLE;\n//std::map<std::pair<int, int>, std::pair<int, int>> SAMPLe;\n\nmint dp[310][310][310];\nbool used[310][310][310];\nmint func(int i, int zero, int one, int erace)\n{\n\t//assert((SAMPLe.count({ i, erace }) == 0 || SAMPLe[{i, erace}] == std::pair<int, int>{zero, one}));\n\t//SAMPLe[{i, erace}] = std::pair<int, int>{ zero, one };\n\tauto& memo = dp[0][i][erace];\n\tauto& USED = used[0][i][erace];\n\tif (USED) {\n\t\treturn memo;\n\t}\n\tUSED = true;\n\n\n\tmemo = 0;\n\n\n\n\t//2\n\tif (i + 2 <= N) {\n\t\tint addzer = ('1' - S[i]) + ('1' - S[i + 1]);\n\t\tint addone = (S[i] - '0') + (S[i + 1] - '0');\n\t\tmemo += func(i + 2, zero + addzer, one + addone, erace + 1);\n\t}\n\telse if(i+1 <= N) {\n\t\tmemo += func(i + 1, zero + ('1' - S[i]), one + (S[i] - '0'), erace + 1);\n\t}\n\n\tif (i == N && erace+1 < N) {\n\t\tmemo += func(i, zero, one, erace + 1);\n\t}\n\tfor (int32_t eracezero = 0; eracezero <= zero; ++eracezero)\n\t{\n\t\tif (eracezero > erace) {\n\t\t\tbreak;\n\t\t}\n\t\tmemo += func2(i, zero - eracezero, one - (erace - eracezero));\n\t}\n\n\n\t////assert((SAMPLe.count({ i, erace }) == 0 || SAMPLe[{i, erace}] == std::pair<int, int>{zero, one}));\n\t////SAMPLe[{i, erace}] = std::pair<int, int>{ zero, one };\n\t//assert((CAMPLE.count(N-erace) == 0 || CAMPLE[N - erace] == i));\n\t//CAMPLE[N - erace] = i;\n\n\t////1を二回 & FIN\n\t//if (i + 4 <= N)\n\t//{\n\t//\tint addzer = ('1' - S[i]) + ('1' - S[i + 1]);\n\t//\tint addone = (S[i] - '0') + (S[i + 1] - '0');\n\t//\tbool cancan[2] = { (zero + addzer) > 0, (one + addone) > 0 };\n\t//\tfor (int front = 0; front <= 1; front++)\n\t//\t{\n\t//\t\tif (!cancan[front]) { continue; }\n\n\t//\t\tbool cancan2[] = {\n\t//\t\t\t('1' - S[i + 2]) + ('1' - S[i + 3]) > 0,\n\t//\t\t\t(S[i + 2] - '0') + (S[i + 3] - '0') > 0,\n\t//\t\t};\n\n\t//\t\tbool diff = !cancan2[front];\n\t//\t\tfor (size_t iii = i+4; !diff && iii < N; iii++)\n\t//\t\t{\n\t//\t\t\tdiff |= (S[i] != S[i - 2]);\n\t//\t\t}\n\t//\t\tif (diff) {\n\t//\t\t\tif (front == 1) {\n\t//\t\t\t\tmemo += func3(zero + addzer, one + addone - 1);\n\t//\t\t\t}else{\n\t//\t\t\t\tmemo += func3(zero + addzer - 1, one + addone);\n\t//\t\t\t}\n\t//\t\t}\n\t//\t}\n\t//}\n\n\treturn memo;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> S;\n\tN = S.size();\n\tif (N == 1) {\n\t\tout << 1 << endl;\n\t\treturn 0;\n\t}\n\tout << func(0, 0, 0, 0) << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\t// if(k==n){\n\n\t\t\t\t// \tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t// \tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t// \tcontinue;\n\t\t\t\t// }\t\t\t\t\n\n\t\t\t\tif(i+j >= 2){\n\t\t\t\t\tif(i>0)dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0)dp1[i][j-1][k] = 1; \n\t\t\t\t}\n\n\t\t\t\tif(k==n) continue;\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\t// ans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int p=998244353;\nint n,m,i,j,k,l,ans,sz0,sz1,flag,v[303][303][303],f[303][303][303];\nchar s[303];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\t//if(n>100)return puts(\"0\"),0;\n\tf[n+1][0][0]=1;\n\tfor(i=n+1;i>=1;i--){\n\t\tfor(j=0;j<=n;j++)\n\t\t for(k=0;k<=n-j;k++)if(f[i][j][k]){\n\t\t \tif(i==1||s[i-1]!='0')(f[i][j+1][k]+=f[i][j][k])%=p;\n\t\t \tif(i==1||s[i-1]!='1')(f[i][j][k+1]+=f[i][j][k])%=p;\n\t\t \tif(i>1){\n\t\t \t\t/*if(s[i-1]=='0')(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t \t\tif(s[i-1]=='1')(f[i-1][j])*/\n\t\t \t\t(f[i-1][j][k]+=f[i][j][k])%=p;\n\t\t\t }\n\t\t }\n\t}\n\tv[0][0][0]=1;\n\tfor(i=0;i<=n;i++)\n\t for(j=n;j>=0;j--)\n\t  for(k=n-j;k>=0;k--)if(v[i][j][k]){\n\t  \tif(j+k>=2){\n\t  \t\tif(j)v[i][j-1][k]=1;\n\t  \t\tif(k)v[i][j][k-1]=1;\n\t\t  }\n\t\tif(i<n){\n\t\t\tif(j+k>0)v[i+1][j][k]=1;\n\t\t\tif(s[i+1]=='0'){\n\t\t\t\tif(k)v[i+1][j+1][k-1]=1;\n\t\t\t}\n\t\t\tif(s[i+1]=='1'){\n\t\t\t\tif(j)v[i+1][j-1][k+1]=1;\n\t\t\t}\n\t\t}\n\t\tif(i+1<n){\n\t\t\tif(s[i+1]=='0'||s[i+2]=='0')v[i+2][j+1][k]=1;\n\t\t\tif(s[i+1]=='1'||s[i+2]=='1')v[i+2][j][k+1]=1;\n\t\t}\n\t  }\n\t  for(i=n;i;i--)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(v[i][j][k]){\n\t    \tif(s[i]=='0'&&j)v[i-1][j-1][k]=1;\n\t    \tif(s[i]=='1'&&k)v[i-1][j][k-1]=1;\n\t\t}\n\t  for(i=0;i<=n;i++)\n\t   for(j=0;j<=n;j++)\n\t    for(k=0;k<=n-j;k++)if(v[i][j][k]){\n\t    \t//printf(\"%d %d %d %d\\n\",i,j,k,f[i+1][j][k]);\n\t    \tans=(ans+f[i+1][j][k])%p;\n\t    \t/*flag=0;sz0=sz1=0;\n\t    \tfor(l=i-1;l<=n;l++){\n\t    \t\tif(v[l][j+sz0][k+sz1]){\n\t    \t\t\tflag=1;break;\n\t\t\t\t}\n\t\t\t\tif(s[l+1]=='0')sz0++;\n\t\t\t\t else sz1++;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t  ans=(ans+f[i][j][k])%p;\n\t\t\t  //printf(\"%d %d %d %d\\n\",i,j,k,f[i][j][k]);\n\t\t   }*/\n\t\t}\n\tprintf(\"%d\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md=998244353;\nstruct Modint {\n  int x;\n  Modint() { x=0; }\n  Modint(int v) { x=v; }\n  Modint operator+=(const Modint& oth) {\n    x+=oth.x;\n    if (x>=md) x-=md;\n    return *this;\n  }\n} dp[302][302][302],r;\nint n,i,j,k,is0;\nbool f[302][302][302];\nchar s[302];\nint main() {\n  scanf(\"%s\",s);\n  n=strlen(s);\n  f[0][0][0]=true;\n  for (i=0; i<n; i++) for (j=i; j>=0; j--) for (k=i-j; k>=0; k--) if (f[i][j][k]) {\n    is0=int(s[i]=='0');\n    if (j+k>1) {\n      if (j>0) f[i][j-1][k]=true;\n      if (k>0) f[i][j][k-1]=true;\n    }\n    if (j+k>0 || i+1<n) f[i+1][j][k]=true;\n    if (j>0) f[i+1][j-1+is0][k+1-is0]=true;\n    if (k>0) f[i+1][j+is0][k-is0]=true;\n    if (i+1<n) {\n      f[i+2][j+is0][k+1-is0]=true;\n      is0=int(s[i+1]=='0');\n      f[i+2][j+is0][k+1-is0]=true;\n    }\n  }\n  dp[n][0][0]=1;\n  for (i=n; i>=0; i--) for (j=0; j<=n; j++) for (k=0; k<=n; k++) if (dp[i][j][k].x) {\n  //printf(\"%d %d %d = %d [%d]\\n\",i,j,k,dp[i][j][k].x,f[i][j][k]);\n    if (f[i][j][k]) r+=dp[i][j][k];\n    if (i==0) continue;\n    is0=int(s[i-1]=='0');\n    dp[i-1][j][k]+=dp[i][j][k];\n    dp[i][j+1-is0][k+is0]+=dp[i][j][k];\n  }\n  printf(\"%d\\n\",r.x);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, minL[309][309], f[309][2], dp[609][609];\nchar sir[309];\nconst int mod = 998244353;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nint fac[2000009], inv[2000009];\nvoid Prec (int lim){fac[0] = inv[0] = 1;for (int i=1; i<=lim; i++)fac[i] = mul (fac[i - 1], i);\ninv[lim] = power (fac[lim], mod - 2);for (int i=lim - 1; i>=0; i--)inv[i] = mul (inv[i + 1], i + 1);}\nint comb (int N, int K){if (K > N || N < 0 || K < 0) return 0; int ans = mul (fac[N], inv[N - K]);ans = mul (ans, inv[K]);return ans;}\n\nint dp2[309][309][309];\nbool ok (int k0, int k1, int L)\n{\n    for (int j=0; j<=N / 2; j++)\n        if (dp2[L][j][k0] >= k1)\n            return 1;\n    return 0;\n/*    int k[2], curr = 0, future = 0, borrowed = 0;\n    bool started = 0;\n    if (k0 == 1 && k1 == 1 && L == 4)\n        L = 4;\n    k[0] = k0, k[1] = k1;\n    for (int i=1; i<=L; i++)\n    {\n        int c = sir[i] - '0';\n        if (f[i][c] + k[c] - 1 >= f[L][c])\n        {\n            if (started) started = 0;\n            else\n            if (future > 0) future --;\n            else borrowed ++;\n            k[c] --;\n        }\n        else\n        {\n            if (borrowed > 0) borrowed --;\n            else\n            if (started)\n                future ++, started = 0;\n            else\n                started = 1;\n        }\n        if (future < 0 || curr < 0 || borrowed > 1)\n            return 0;\n    }\n    return (borrowed == 0 && k[0] == 0 && k[1] == 0);*/\n}\n\nset < string > S;\nbool ok (string s)\n{\n    int j = s.length () - 1, k0 = 0, k1 = 0, lastI = N + 1;\n    for (auto c : s)\n        if (c == '0') k0 ++;\n        else k1 ++;\n    for (int i=N; i>=1; i--)\n    {\n        lastI = i;\n        while (s[j] != sir[i] && j>=0)\n            j --;\n        if (j < 0) break;\n        j --;\n        if (sir[i] == '0') k0 --;\n        else k1 --;\n    }\n    return (minL[k0][k1] <= lastI);\n}\n\nvoid dfInsert (string s, char c);\nvoid dfs (string s)\n{\n    if (S.find (s) != S.end ())\n        return ;\n    S.insert (s);\n    if (s.size () >= 2)\n    {\n        char c0 = s[0], c1 = s[1];\n        s.erase (s.begin ()), s.erase (s.begin ());\n        if (c0 == c1)\n            dfInsert (s, c0);\n        else\n            dfInsert (s, '0'),\n            dfInsert (s, '1');\n    }\n}\n\nvoid dfInsert (string s, char c)\n{\n    for (int i=0; i<=s.length (); i++)\n    {\n        string s2 = s;\n        s2.insert (i, 1, c);\n        dfs (s2);\n    }\n}\n\nvoid updateMax (int &x, int y)\n{\n    if (y > x)\n        x = y;\n}\n\n/*int maxF (int c)\n{\n    int cnt = 0, ans = 0;\n    for (int i=1; i<=N; i++)\n    {\n        if (s[i])\n    }\n}*/\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%s\", sir + 1), N = strlen (sir + 1);\n/*string init = sir + 1;\ndfs (init);\nprintf (\"%d\\n\", S.size ());*/\n/*for (auto s: S)\n    printf (\"%s\\n\", s.c_str ());\nreturn 0;*/\nfor (int i=1; i<=N; i++)\n{\n    f[i][0] = f[i - 1][0];\n    f[i][1] = f[i - 1][1];\n    f[i][sir[i] - '0'] ++;\n}\nfor (int i=0; i<=N; i++)\n    for (int q=0; q<=N / 2; q++)\n        for (int j=0; j<=N; j++)\n            dp2[i][q][j] = -4 * N;\ndp2[0][0][0] = 0;\nfor (int i=0; i<N; i++)\n    for (int q=0; q<=N / 2; q++)\n        for (int j=0; j<=N; j++)\n            if (dp2[i][q][j] >= 0)\n            {\n                ///not take the next 2\n                if (i + 2 <= N)\n                    updateMax (dp2[i + 2][q + 1][j], dp2[i][q][j]);\n                if (q > 0)\n                {\n                    ///take sir[i + 1]\n                    if (sir[i + 1] == '0')\n                        updateMax(dp2[i + 1][q - 1][j + 1], dp2[i][q][j]);\n                    else\n                        updateMax(dp2[i + 1][q - 1][j], dp2[i][q][j] + 1);\n                }\n                if (i + 2 <= N)\n                {\n                    ///take one of sir[i + 1], sir[i + 2]\n                    char c0 = sir[i + 1], c1 = sir[i + 2];\n                    if (c0 == '0' || c1 == '0')\n                        updateMax(dp2[i + 2][q][j + 1], dp2[i][q][j]);\n                    if (c0 == '1' || c1 == '1')\n                        updateMax(dp2[i + 2][q][j], dp2[i][q][j] + 1);\n                }\n            }\nfor (int k0=0; k0<=N; k0++)\n    for (int k1=0; k0 + k1<=N; k1++)\n    {\n        minL[k0][k1] = k0 + k1;\n        while (minL[k0][k1] <= N && !ok (k0, k1, minL[k0][k1]))\n            minL[k0][k1] ++;\n       // if (minL[k0][k1] <= N)\n         //   printf (\"(%d, %d) -> %d\\n\", k0, k1, minL[k0][k1]);\n    }\n/*int cnt = 0;\nfor (int L=1; L<=N; L++)\n    for (int msk = 0; msk < (1 << L); msk ++)\n    {\n        string s;\n        for (int i=0; i<L; i++)\n            if ((msk >> i) & 1)\n                s.push_back ('1');\n            else\n                s.push_back ('0');\n        if (ok (s))\n        {\n            printf (\"%s\", s.c_str ());\n            if (S.find (s) == S.end ())\n                printf (\" WA\");\n            S.erase (s);\n            printf (\"\\n\");\n            cnt ++;\n        }\n    }\nfor (auto s : S)\n    printf (\"%s WA2\\n\", s.c_str ());*/\ndp[0][0] = 1;\nfor (int i=0; i<=N; i++)\n    for (int j=0; j<=N; j++)\n        for (int k=0; j+k<=N; k++)\n            adto (dp[i + 1][j + k], dp[i][j]);\n//printf (\"%d\\n%d\\n\", cnt, S.size ());\nint ans = 0;\nfor (int maxS = 0; maxS <= N; maxS ++)\n{\n    int f[2]; f[0] = 0, f[1] = 0;\n    if (maxS == 0) f[(sir[N] - '0') ^ 1] = 1;\n    else\n    {\n        f[(sir[N] - '0') ^ 1] = 1;\n        for (int i=N - 1; i>=N - maxS; i--)\n            f[(sir[i] - '0') ^ 1] ++;\n    }\n//    printf (\"%d -> (%d, %d)\\n\", maxS, f[0], f[1]);\n    for (int k0=0; k0<=N; k0++)\n        for (int k1=0; k0 + k1<=N; k1++)\n            if (minL[k0][k1] <= N - maxS && k0 + k1 + maxS > 0)\n            {\n                adto (ans, mul (dp[f[0]][k0], dp[f[1]][k1]));\n  //              printf (\"(%d, %d) -> +%d\\n\", k0, k1, mul (dp[f[0]][k0], dp[f[1]][k1]));\n            }\n}\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n\n#pragma region cp_template\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i32 = std::int32_t;\nusing i64 = std::int64_t;\nusing u32 = std::uint32_t;\nusing u64 = std::uint64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\nconstexpr char eoln = '\\n';\ntemplate <class T> T ceildiv(const T &l, const T &r) {\n  return l / r + (l % r != 0 ? 1 : 0);\n}\n\n} // namespace n91\n\n#pragma endregion cp_template\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t mod> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 v;\n\n  constexpr modint(const u64 x = 0) noexcept : v(x % mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n#include <array>\n\nnamespace n91 {\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  using mint = modint<998244353>;\n\n  const std::vector<usize> s = []() {\n    const std::string s = scan<std::string>();\n    std::vector<usize> ret;\n    for (const usize i : rep(0, s.size())) {\n      ret.push_back(s[i] == '1');\n    }\n    return ret;\n  }();\n  const usize n = s.size();\n\n  auto able = md_vec(n + 1, n + 2, n + 2, u32(0));\n  able[0][0][0] = 1;\n  for (const usize i : rep(0, n + 1)) {\n    for (const usize j : revrep(0, n + 1)) {\n      for (const usize k : revrep(0, n + 1)) {\n        const auto cu = able[i][j][k];\n        if (i + 2 <= n) {\n          able[i + 2][j + !s[i]][k + s[i]] |= cu;\n          able[i + 2][j + !s[i + 1]][k + s[i + 1]] |= cu;\n        }\n        if (i + 1 <= n) {\n          if (j + k >= 1) {\n            able[i + 1][j][k] |= cu;\n          }\n          if (j >= 1) {\n            able[i + 1][j - 1 + !s[i]][k + s[i]] |= cu;\n          }\n          if (k >= 1) {\n            able[i + 1][j + !s[i]][k - 1 + s[i]] |= cu;\n          }\n        }\n        if (k + j >= 2) {\n          if (k >= 1) {\n            able[i][j][k - 1] |= cu;\n          }\n          if (j >= 1) {\n            able[i][j - 1][k] |= cu;\n          }\n        }\n      }\n    }\n  }\n\n  for (const usize i : rep(0, n)) {\n    for (const usize j : rep(0, n + 2)) {\n      able[i][j][n + 1] = 0;\n      able[i][n + 1][j] = 0;\n    }\n  }\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        able[i][j][k] |= able[i + 1][j + !s[i]][k + s[i]];\n      }\n    }\n  }\n\n  mint ans = 0;\n\n  auto dp = md_vec(n + 2, n + 2, mint(0));\n  dp[0][0] = 1;\n\n  for (const usize i : revrep(0, n)) {\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        dp[j + s[i]][k + !s[i]] += dp[j][k];\n      }\n    }\n    for (const usize j : rep(0, n + 1)) {\n      for (const usize k : rep(0, n + 1)) {\n        if (able[i + 1][j][k]) {\n          ans += dp[j][k];\n        }\n      }\n    }\n\n    // auto nx = md_vec(n + 2, n + 2, mint(0));\n  }\n\n  ans += 1;\n\n  std::cout << ans.v << eoln;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k+j<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str ts(mi a) { return ts(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nstr S;\nbool ok[305][305][305],tmp[305][305][305];\nmi dp[305][305][305];\n\nbool con(int a, int b) { return (a-b)%2 == 0 && a >= b; }\n\nint main() {\n\tsetIO(); re(S);\n\tok[0][0][0] = 1;\n\tF0R(i,sz(S)+1) R0F(j,sz(S)+1) R0F(k,sz(S)+1) if (ok[i][j][k]) {\n\t\tdbg(i,j,k);\n\t\tif (j+k > 1) {\n\t\t\tif (j) ok[i][j-1][k] = 1;\n\t\t\tif (k) ok[i][j][k-1] = 1;\n\t\t}\n\t\tif (i < sz(S)) {\n\t\t\tif (j || k) ok[i+1][j][k] = 1;\n\t\t\tif (j) ok[i+1][j-1+(S[i] == '0')][k+(S[i] == '1')] = 1;\n\t\t\tif (k) ok[i+1][j+(S[i] == '0')][k-1+(S[i] == '1')] = 1;\n\t\t}\n\t\tif (i+1 < sz(S)) {\n\t\t\tok[i+2][j+(S[i] == '0')][k+(S[i] == '1')] = 1;\n\t\t\tok[i+2][j+(S[i+1] == '0')][k+(S[i+1] == '1')] = 1;\n\t\t}\n\t}\n\tint zero = 0, one = 0;\n\tR0F(i,sz(S)+1) {\n\t\t//dbg(\"AH\",i,zero,one);\n\t\tF0R(j,sz(S)+1) F0R(k,sz(S)+1) if (ok[i][j][k]) {\n\t\t\t//dbg(\"OK\",i,j,k,sz(S)-i,j+zero,k+one);\n\t\t\ttmp[sz(S)-i][j+zero][k+one] = 1;\n\t\t}\n\t\tif (i > 0) {\n\t\t\tzero += S[i-1] == '0';\n\t\t\tone += S[i-1] == '1';\n\t\t}\n\t}\n\t//dbg(\"OOPS\",tmp[4][3][1]);\n\tF0R(i,sz(S)) F0R(j,sz(S)+1) F0R(k,sz(S)+1) \n\t\tif (tmp[i][j][k]) tmp[i+1][j][k] = 1;\n\t// F0R(i,sz(S)+1) F0R(j,sz(S)+1) F0R(k,sz(S)+1) \n\t// \tif (tmp[i][j][k]) dbg(\"TMP\",i,j,k);\n\n\t/*F0R(i,sz(S)) {\n\t\tzero[i+1] = zero[i]+(S[sz(S)-1-i] == '0');\n\t\tone[i+1] = one[i]+(S[sz(S)-1-i] == '1');\n\t}\n\tint i = 0, j = 0, k = 0;\n\tvector<array<int,3>> posi;\n\twhile (1) {\n\t\tposi.pb({sz(S)-i,j+zero[sz(S)-i],k+one[sz(S)-i]});\n\t\tif (i == sz(S)) break;\n\t\tif (i+1 < sz(S) && S[i] == S[i+1]) {\n\t\t\ti += 2;\n\t\t\tj += S[i] == '0';\n\t\t\tk += S[i] == '1';\n\t\t} else if (S[i] == '0') {\n\t\t\ti ++;\n\t\t\tif (!j) break;\n\t\t} else if (S[i] == '1') {\n\t\t\ti ++;\n\t\t\tif (!k) break;\n\t\t}\n\t}*/\n\treverse(all(S));\n\tdp[0][0][0] = 1;\n\tmi res = 0;\n\tF0R(i,sz(S)+1) F0R(j,sz(S)+1) F0R(k,sz(S)+1) if (dp[i][j][k] != 0) {\n\t\tmi v = dp[i][j][k];\n\t\tif (tmp[i][j][k]) {\n\t\t\tdbg(i,j,k,v);\n\t\t\tres += v;\n\t\t}\n\t\tif (j+k < sz(S)) {\n\t\t\tdp[i+(S[i] == '0')][j+1][k] += v;\n\t\t\tdp[i+(S[i] == '1')][j][k+1] += v;\n\t\t}\n\t}\n\tps(res);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//{\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define all(v) (v).begin(),(v).end()\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n\n\n#define PII pair<int,int>\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n};\n//{\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n#define jeb() fflush(stdout);\n//}\n\nint n;\nchar s[305];\nVI v;\n// mag[pos][k] na pozycji pos majac k jedynek ile \n// maksymalnie zer \nint mag[305][305];\nint mod = 998244353;\n\n//co[dl][j] dla finalnej dlugosci dl i liczby jedynek j\n//maksymalny sufix ktory musi byc \nint co[305][305];\nint suf[305];\n\nint dp[305][305][305];\n\nint rob2(int sufix, int zer, int jedynek) {\n\tif (dp[sufix][zer][jedynek] != -1) return dp[sufix][zer][jedynek];\n\tint ans = 0;\n\tif (sufix >= n) {\n\t\tif (zer == 0) return 1;\n\t\tif (jedynek == 0) return 1;\n\t\tans = rob2(sufix, zer-1, jedynek) + rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 0) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (jedynek > 0) \n\t\t\t\tans += rob2(sufix, zer, jedynek-1);\n\t} else if (v[sufix] == 1) {\n\t\t\tans += rob2(sufix+1, zer, jedynek);\n\t\t\tif (zer > 0) \n\t\t\t\tans += rob2(sufix, zer-1, jedynek);\n\t}\n\tans %= mod;\n\tdp[sufix][zer][jedynek] = ans;\n\treturn ans;\n}\n\nint rob(int sufix, int zer, int jedynek) {\n\t\tFOR(i,sufix,n+1) FOR(j,0,zer+1) FOR(k,0,jedynek+1) {\n\t\t\tdp[i][j][k] = -1;\n\t\t}\n\t\treturn rob2(sufix, zer, jedynek);\n\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tFOR(i,0,n) v.pb(s[i]-'0');\n\tsuf[n] = 0;\n\tFORD(i,n-1,0) suf[i] = suf[i+1] + v[i];\n\tif (n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tFOR(i,0,n+1) FOR(j,0,n+1) mag[i][j] = -1e9;\n\tFOR(i,0,n+1) mag[i][0] = 0;\n\n\tFOR(i,2,n+1) {\n\t\t// skreslam dwa\n\t\tbool jest1 = (v[i-1] == 1 || v[i-2] == 1);\n\t\tbool jest0 = (v[i-1] == 0 || v[i-2] == 0);\t\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) mag[i][j+1] = max(mag[i][j+1], mag[i-2][j]);\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,0,n+1) mag[i][j] = max(mag[i][j], mag[i-2][j]+1);\n\t\t}\n\t\t// skreslam jeden\n\t\tjest1 = (v[i-1] == 1);\n\t\tjest0 = (v[i-1] == 0);\n\t\tif (jest1) {\n\t\t\tFOR(j,0,n+1) {\n\t\t\t\tif (mag[i-1][j] > 0) {\n\t\t\t\t\tmag[i][j+1] = max(mag[i][j+1], mag[i-1][j]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (jest0) {\n\t\t\tFOR(j,1,n+1) {\n\t\t\t\tif (mag[i-1][j] >= 0) {\n\t\t\t\t\tmag[i][j-1] = max(mag[i][j-1], mag[i-1][j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFOR(i,0,n+1) FOR(j,0,n+1) co[i][j] = -1e9;\n\tFOR(i,0,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (mag[i][j] < 0) continue;\n\t\t\tFOR(k,0,mag[i][j]+1) {\n\t\t\t\tint dl = (n-i) + j + k;\n\t\t\t\tint jed = suf[i] + j;\n\t\t\t\tco[dl][jed] = max(co[dl][jed], i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tFOR(i,1,n+1) {\n\t\tFOR(j,0,n+1) {\n\t\t\tif (co[i][j] >= 0) {\n\t\t\t\tint plus_jeden = j-suf[co[i][j]];\n\t\t\t\tint plus_zero = i-(n-co[i][j])-plus_jeden;\n\t\t\t\tans = ans + rob(/*pref=*/co[i][j], plus_zero, plus_jeden);\n\t\t\t\tif (ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconstexpr int N = 300, P = 998244353;\n\nint n;\nstd::string s;\n\nint dp[N + 1][N + 1][N + 1], g[N + 1][N + 1][N + 1];\n\nvoid chkmax(int &a, int b) {\n    a = std::max(a, b);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::cin >> s;\n    n = s.length();\n    \n    std::memset(g, -1, sizeof(g));\n    \n    g[0][0][0] = 0;\n    \n    for (int j = 0; j < n; ++j) {\n        for (int i = 0; i <= j; ++i) {\n            for (int k = 0; k <= j - i; ++k) {\n                if (g[i][j][k] < 0)\n                    continue;\n                chkmax(g[i + 1][j + 1][k], g[i][j][k]);\n                chkmax(g[i][j + 1][k + (s[j] == '0')], g[i][j][k] - 1);\n                if (j + 2 <= n) {\n                    chkmax(g[i + 2][j + 2][k], g[i][j][k] + 1);\n                    chkmax(g[i + 1][j + 2][k + (s[j] == '0')], g[i][j][k]);\n                    chkmax(g[i + 1][j + 2][k + (s[j + 1] == '0')], g[i][j][k]);\n                }\n            }\n        }\n    }\n    \n    dp[n][n][0] = 1;\n    \n    int ans = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i; j <= n; ++j) {\n            for (int k = 0; k <= j - i; ++k) {\n                if (j < n)\n                    dp[i][j][k] += dp[i + 1][j + 1][k];\n                if (j > i && k - (s[j - 1] - '0') >= 0)\n                    dp[i][j][k] += dp[i + 1][j][k - (s[j - 1] - '0')];\n                if (dp[i][j][k] >= P)\n                    dp[i][j][k] -= P;\n                if (dp[i][j][k] && g[i][j][k] >= 0) {\n                    ans += dp[i][j][k];\n                    if (ans >= P)\n                        ans -= P;\n                }\n            }\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 300;\nint const modulo = 998244353;\nint dp[5 + nmax][5 + nmax][5 + nmax];\nint pref[5 + nmax][5 + nmax][5 + nmax];\n\nint main() {\n  std::string s;\n  std::cin >> s;\n  int n = s.size();\n  s = \"0\" + s + \"0\";\n  dp[n + 1][0][0] = 1;\n  for(int i = n + 1; 1 <= i; i--)\n    for(int j = 0; j <= n; j++)\n      for(int h = 0; h <= n; h++) {\n        if(s[i - 1] == '0') {\n          dp[i - 1][j][h] += dp[i][j][h];\n          if(modulo <= dp[i - 1][j][h])\n            dp[i - 1][j][h] -= modulo;\n          dp[i][j][h + 1] += dp[i][j][h];\n          if(modulo <= dp[i][j][h + 1])\n            dp[i][j][h + 1] -= modulo;\n        } else {\n          dp[i - 1][j][h] += dp[i][j][h];\n          if(modulo <= dp[i - 1][j][h])\n            dp[i - 1][j][h] -= modulo;\n          dp[i][j + 1][h] += dp[i][j][h];\n          if(modulo <= dp[i][j + 1][h])\n            dp[i][j + 1][h] -= modulo;\n        }\n      }\n  pref[0][0][0] = 1;\n  for(int i = 0;i < n; i++)\n    for(int j = 0;j <= n; j++)\n      for(int h = 0;h <= n; h++)\n        if(0 < pref[i][j][h]) {\n          if(s[i + 1] == '0' || s[i + 2] == '0')\n            pref[i + 2][j + 1][h] = 1;\n          if(s[i + 1] == '1' || s[i + 2] == '1')\n            pref[i + 2][j][h + 1] = 1;\n          pref[i + 1][j][h] = 1;\n          if(s[i + 1] == '0' && 0 < h) \n            pref[i + 1][j + 1][h - 1] = 1;\n          if(s[i + 1] == '1' && 0 < j)\n            pref[i + 1][j - 1][h + 1] = 1;\n        }\n  int result = modulo - 1;\n  for(int i = 1;i <= n + 1; i++)\n    for(int j = 0; j <= n; j++)\n      for(int h = 0; h <= n; h++) {\n        result += dp[i][j][h] * pref[i - 1][j][h];\n        if(modulo <= result)\n          result -= modulo;\n      }\n  std::cout << result ;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod=998244353;\n#define Rint register int\n#define C(n,m) (n<m?0:1ll*fac[n]*invfac[n-m]%mod*invfac[m]%mod)\nusing namespace std;//nantftxdy\nint T,n,m,p,k;\nbool f[310][310][310];\nint dp[310][310][310],C[610][610],ans=0;\nchar s[310];\nint main(){\n\tscanf(\"%s\",s),n=strlen(s);\n\tfor(int i=0;i<=2*n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; \n\t} \n\tfor(int j=0;j<=n;j++) for(int k=0;k<=n;k++) dp[n][j][k]=C[j+k][j];\n\tfor(int i=n-1;i>=0;i--) for(int j=0;j<=i;j++) for(int k=0;k<=i;k++){\n\t\tdp[i][j][k]=dp[i+1][j][k];\n\t\tif(s[i]=='0'&&k) dp[i][j][k]=(dp[i][j][k]+dp[i][j][k-1])%mod;\n\t\tif(s[i]=='1'&&j) dp[i][j][k]=(dp[i][j][k]+dp[i][j-1][k])%mod;\n\t}\n\tf[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tfor(int k=i;k>=0;k--){\n\t\t\t\tif(j&&j+k>=2) f[i][j-1][k]|=f[i][j][k];\n\t\t\t\tif(k&&j+k>=2) f[i][j][k-1]|=f[i][j][k];\n\t\t\t\tif(i+1<=n){\n\t\t\t\t\tif(j&&s[i]=='1') f[i+1][j-1][k+1]|=f[i][j][k];\n\t\t\t\t\tif(k&&s[i]=='0') f[i+1][j+1][k-1]|=f[i][j][k];\n\t\t\t\t\tif(j+k) f[i+1][j][k]|=f[i][j][k];\n\t\t\t\t}\n\t\t\t\tif(i+2<=n){\n\t\t\t\t\tif(s[i]=='0'||s[i+1]=='0') f[i+2][j+1][k]|=f[i][j][k];\n\t\t\t\t\tif(s[i]=='1'||s[i+1]=='1') f[i+2][j][k+1]|=f[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tfor(int k=i;k>=0;k--){\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tans=(ans+dp[i][j][k])%mod;\n\t\t\t\tint cnt[2]={};\n\t\t\t\tfor(int l=i-1;l>=0;l--){\n\t\t\t\t\tcnt[s[l]-'0']++;\n\t\t\t\t\tif(j<cnt[0]||k<cnt[1]) break;\n\t\t\t\t\tf[l][j-cnt[0]][k-cnt[1]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n// Modular template copied from tourist\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint dp[301][301][301];\nint can[310][310][310];\nint can2[310][310];\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  //dp[i][ones][zeros] = number of strings, using i from end\n  dp[0][0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int ones = 0; ones <= n; ones++) {\n      for (int zeros = 0; zeros <= n; zeros++) {\n\tif (i) dp[i][ones][zeros] += dp[i-1][ones][zeros];\n\tif (!i || s[n-i] == '0') {\n\t  if (ones) dp[i][ones][zeros] += dp[i][ones-1][zeros];\n\t}\n\tif (!i || s[n-i] == '1') {\n\t  if (zeros) dp[i][ones][zeros] += dp[i][ones][zeros-1];\n\t}\n      }\n    }\n  }\n\n\n  can[0][0][0] = 1;\n  for (int p = 0; p <= n; p++) {\n    for (int ones = n; ones >= 0; ones--) {\n      for (int zeros = n; zeros >= 0; zeros--) {\n\tif (!can[p][ones][zeros]) continue;\n\t//Take 0\n\tif (ones >= 2) can[p][ones-1][zeros] = 1;\n\tif (zeros >= 2) can[p][ones][zeros-1] = 1;\n\tif (ones && zeros) {\n\t  can[p][ones-1][zeros] = 1;\n\t  can[p][ones][zeros-1] = 1;\n\t}\n\n\t//Take 1\n\tif (ones && p < n) can[p+1][ones-1+(s[p]=='1')][zeros+(s[p]=='0')] = 1;\n\tif (zeros && p < n) can[p+1][ones+(s[p]=='1')][zeros-1+(s[p]=='0')] = 1;\n\tif ((ones || zeros) && p < n)\n\t  can[p+1][ones][zeros] = 1;\n\n\t//Take 2\n\tif (p+2 <= n) {\n\t  can[p+2][ones+(s[p]=='1')][zeros+(s[p]=='0')] = 1;\n\t  can[p+2][ones+(s[p+1]=='1')][zeros+(s[p+1]=='0')] = 1;\n\t}\n\t//cout << p << ' ' <<  ones << ' ' << zeros << endl;\n      }\n    }\n  }\n  vector<array<int,2>> acc(n+1);\n  for (int i = 0; i < n; i++) {\n    acc[i+1] = {acc[i][0]+(s[i] == '0'),\n\t\tacc[i][1]+(s[i] == '1')};\n  }\n  for (int p = 0; p <= n; p++) {\n    for (int ones = 0; ones <= n; ones++) {\n      for (int zeros = 0; zeros <= n; zeros++) {\n\tif (can[p][ones][zeros]) {\n\t  int step = p-ones-zeros;\n\t  int ones_ = acc[p][1]-ones;\n\t  can2[step][ones_] = max(can2[step][ones_], p+1);\n\t}\n      }\n    }\n  }\n  //p-(ones+zeros) = step;\n  Mint ans = 0;\n  for (int step = 0; step < n; step++) {\n    for (int ones_ = 0; ones_ <= n; ones_++) {\n      int p = can2[step][ones_]-1;\n      if (p >= 0) {\n\t//cout << \"OK\" << endl;\n\tint ones = acc[p][1]-ones_;\n\tint zeros = p-step-ones;\n\tassert(ones >= 0 && ones <= n);\n\tassert(zeros >= 0 && zeros <= n);\n\tassert(can[p][ones][zeros]);\n\t//cout << step << ' ' << p << ' ' << ones << ' ' << zeros << ' ' << dp[n-p][ones][zeros] << endl;\n\tans += dp[n-p][ones][zeros];\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nbool can[301][301][301];\nmint f[302][302][302];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tstring s; cin >> s; reverse(all(s));\n\tint N = si(s);\n\tcan[N][0][0] = true;\n\tper(p,N+1) per(a,N+1) per(b,N+1) if(can[p][a][b]){\n\t\tif(p >= 2){\n\t\t\tif(s[p-2]=='0' || s[p-1]=='0') can[p-2][a+1][b] = true;\n\t\t\tif(s[p-2]=='1' || s[p-1]=='1') can[p-2][a][b+1] = true;\n\t\t}\n\t\tif(p >= 1){\n\t\t\tif(a){\n\t\t\t\tcan[p-1][a][b] = true;\n\t\t\t\tif(s[p-1] == '1') can[p-1][a-1][b+1] = true;\n\t\t\t}\n\t\t\tif(b){\n\t\t\t\tcan[p-1][a][b] = true;\n\t\t\t\tif(s[p-1] == '0') can[p-1][a+1][b-1] = true;\n\t\t\t}\t\t\t\n\t\t}\n\t\tif(a>=2) can[p][a-1][b] = true;\n\t\tif(a>=1 && b>=1) can[p][a-1][b] = can[p][a][b-1] = true;\n\t\tif(b>=2) can[p][a][b-1] = true;\n\t}\n\tf[0][0][0] = 1;\n\tmint ans = 0;\n\trep(p,N+1) rep(a,N+1) rep(b,N+1) if(f[p][a][b]){\n\t\tif(can[p][a][b]) ans += f[p][a][b];\n\t\tif(p == N) continue;\n\t\t{\t// add 0\n\t\t\tif(s[p] == '0'){\n\t\t\t\tf[p+1][a][b] += f[p][a][b];\n\t\t\t}else{\n\t\t\t\tf[p][a+1][b] += f[p][a][b];\n\t\t\t}\n\t\t}\n\t\t{\t// add 1\n\t\t\tif(s[p] == '1'){\n\t\t\t\tf[p+1][a][b] += f[p][a][b];\n\t\t\t}else{\n\t\t\t\tf[p][a][b+1] += f[p][a][b];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans+si(s)-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nconst int MOD = 998244353;\nconst int N = 303;\n\n\nbool state[N][N][N];\nint ways[N][N][N];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    state[n][0][0] = true;\n\n    vector <bool> isZero(n), isOne(n);\n    for (int i = 0; i < n; i++) {\n        isZero[i] = s[i] == '0';\n        isOne[i] = !isZero[i];\n    }\n\n    for (int suffLen = n; suffLen >= 0; suffLen--) {\n        for (int zeros = n; zeros >= 0; zeros--) for (int ones = n; ones >= 0; ones--) {\n            if (state[suffLen][zeros][ones]) {\n                int p1 = n - suffLen;\n                int p2 = p1 + 1;\n\n                if (suffLen >= 2) {\n                    for (int p : {p1, p2}) {\n                        state[suffLen - 2][zeros + isZero[p]][ones + isOne[p]] = true;\n                    }\n                }\n\n                if (suffLen >= 1) {\n                    if (zeros >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros - 1 + isZero[p1]][ones + isOne[p1]] = true;\n                    }\n\n                    if (ones >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros + isZero[p1]][ones - 1 + isOne[p1]] = true;\n                    }\n                }\n\n                if (zeros >= 2) state[suffLen][zeros - 2][ones] = true;\n                if (ones >= 2) state[suffLen][zeros][ones - 2] = true;\n                if (zeros >= 1 && ones >= 1) state[suffLen][zeros - 1][ones - 1] = true;\n            }\n        }\n    }\n\n    vector <int> suffZeros(n + 1, 0), suffOnes(n + 1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        suffZeros[i] = suffZeros[i - 1] + isZero[n - i];\n        suffOnes[i] = suffOnes[i - 1] + isOne[n - i];\n    }\n\n    map <pair<int,int>,tuple<int,int,int>> minLenState;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (state[suffLen][zeros][ones]) {\n                int zerosTotal = zeros + suffZeros[suffLen];\n                int onesTotal = ones + suffOnes[suffLen];\n\n                pair <int,int> p = {zerosTotal, onesTotal};\n\n                if (!minLenState.count(p)) {\n                    minLenState[p] = tuple <int,int,int> {suffLen, zeros, ones};\n                }\n            }\n        }\n    }\n\n    ways[0][0][0] = 1;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (suffLen == 0) {\n                if (zeros >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros - 1][ones];\n                }\n\n                if (ones >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros][ones - 1];\n                }\n\n                ways[suffLen][zeros][ones] %= MOD;\n            } else {\n                int last = isOne[n - suffLen];\n                ways[suffLen][zeros][ones] = ways[suffLen-1][zeros][ones];\n\n                if (last == 0) {\n                    if (ones >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros][ones-1]) % MOD;\n                    }\n                } else {\n                    if (zeros >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros-1][ones]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (auto &entry : minLenState) {\n        int suffLen, zeros, ones;\n        tie(suffLen, zeros, ones) = entry.second;\n\n        if (suffLen + zeros + ones == 0) {\n            continue;\n        }\n\n        ans = (ans + ways[suffLen][zeros][ones]) % MOD;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\ntemplate <int32_t P>\nstruct ModInt_t {\n  constexpr static auto mod = P;\n\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  constexpr explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  constexpr explicit ModInt_t(int64_t v) {\n    v %= P;\n    if (v < 0) v += P;\n    value = v;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<998244353>;\n\nstruct ModInverses {\n  vector<ModInt> inv;\n\n  ModInverses(int n) : inv(n, ModInt{0}) {\n    auto mod = ModInt::mod;\n    assert(n < mod);\n\n    inv[1] = ModInt{1};\n    for (int i = 2; i < n; ++i) {\n      inv[i] = ModInt{0} - ModInt{mod / i} * inv[mod % i];\n    }\n  };\n};\n\nstruct Factorial {\n  vector<ModInt> fact;\n  vector<ModInt> invfact;\n\n  ModInt choose(int n, int k) { return fact[n] * invfact[k] * invfact[n - k]; }\n\n  Factorial(int n) : fact(n, ModInt{0}), invfact(n, ModInt{0}) {\n    ModInverses inv(n);\n\n    fact[0] = invfact[0] = ModInt{1};\n    for (int i = 1; i < n; ++i) {\n      fact[i] = fact[i - 1] * ModInt{i};\n      invfact[i] = invfact[i - 1] * inv.inv[i];\n    }\n  }\n};\n\nconst int MAX = 303;\n\nbool f[MAX][MAX][MAX];\nModInt g[MAX][MAX][MAX];\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  string S;\n\n  cin >> S;\n\n  int N = S.size();\n  vector<vector<int>> minSuf(N + 1, vector<int>(N + 1, -1));\n\n  f[0][0][0] = true;\n  for (int i = 0; i <= N; ++i) {\n    int c0 = 0, c1 = 0;\n    for (int j = i; j < N; ++j) {\n      c0 += S[j] == '0';\n      c1 += S[j] == '1';\n    }\n\n    for (int x = N; x >= 0; --x) {\n      for (int y = N; y >= 0; --y) {\n        if (f[i][x][y]) {\n          minSuf[c0 + x][c1 + y] = max(minSuf[c0 + x][c1 + y], i);\n\n          if (i + 2 <= N) {\n            for (int j : {i, i + 1}) {\n              int nx = x + (S[j] == '0');\n              int ny = y + (S[j] == '1');\n              f[i + 2][nx][ny] = true;\n            }\n          }\n          if (i + 1 <= N && x + y >= 1) {\n            f[i + 1][x][y] = true;\n            if (x > 0 && S[i] == '1') {\n              f[i + 1][x - 1][y + 1] = true;\n            }\n            if (y > 0 && S[i] == '0') {\n              f[i + 1][x + 1][y - 1] = true;\n            }\n          }\n          if (x + y >= 2) {\n            if (x >= 1) f[i][x - 1][y] = true;\n            if (y >= 1) f[i][x][y - 1] = true;\n          }\n        }\n      }\n    }\n  }\n\n  g[N][0][0] = ModInt{1};\n  for (int i = N; i >= 0; --i) {\n    for (int x = 0; x <= N; ++x) {\n      for (int y = 0; y <= N; ++y) {\n        if (i < N && S[i] == '0') {\n          g[i][x][y] += g[i + 1][x][y];\n        } else if (x > 0) {\n          g[i][x][y] += g[i][x - 1][y];\n        }\n\n        if (i < N && S[i] == '1') {\n          g[i][x][y] += g[i + 1][x][y];\n        } else if (y > 0) {\n          g[i][x][y] += g[i][x][y - 1];\n        }\n      }\n    }\n  }\n\n  Factorial fact(N + 1);\n\n  ModInt ret{0};\n  for (int c0 = 0; c0 <= N; ++c0) {\n    for (int c1 = 0; c1 <= N; ++c1) {\n      if (minSuf[c0][c1] != -1) {\n        int s = minSuf[c0][c1];\n        int x0 = c0, x1 = c1;\n        for (int j = s; j < N; ++j) {\n          x0 -= S[j] == '0';\n          x1 -= S[j] == '1';\n        }\n        auto ways = g[s][x0][x1];\n        ret += ways;\n      }\n    }\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXLEN = 300;\nconst int MOD = 998244353;\nvoid inc(int& a, int b) { if ((a += b) >= MOD) a -= MOD; }\nvoid dec(int& a, int b) { inc(a, MOD - b); }\n\nchar s[MAXLEN + 1]; int slen;\n\nint dp[MAXLEN + 1][MAXLEN + 1][MAXLEN + 1];\nbool can[MAXLEN + 1][MAXLEN + 1][MAXLEN + 1];\n\nint solve() {\n\tfor (int i = slen; i >= 0; --i) REPE(a, slen) REPE(b, slen) {\n\t\tdp[i][a][b] = i == slen && a == 0 && b == 0 ? 1 : 0;\n\t\tif (a > 0 && (i >= slen || s[i] != '0')) inc(dp[i][a][b], dp[i][a - 1][b]);\n\t\tif (b > 0 && (i >= slen || s[i] != '1')) inc(dp[i][a][b], dp[i][a][b - 1]);\n\t\tif (i < slen) inc(dp[i][a][b], dp[i + 1][a][b]);\n\t}\n\n\tREPE(i, slen) REPE(a, slen) REPE(b, slen) can[i][a][b] = false;\n\tcan[0][0][0] = true;\n\tint ret = 0;\n\tREPE(i, slen) for (int a = slen; a >= 0; --a) for (int b = slen; b >= 0; --b) if (can[i][a][b]) {\n\t\t//printf(\"%d %d %d = %d\\n\", i, a, b, dp[i][a][b]);\n\t\tinc(ret, dp[i][a][b]);\n\t\tif (i - 1 >= 0 && s[i - 1] == '0' && a >= 1 && can[i - 1][a - 1][b]) dec(ret, dp[i - 1][a - 1][b]);\n\t\tif (i - 1 >= 0 && s[i - 1] == '1' && b >= 1 && can[i - 1][a][b - 1]) dec(ret, dp[i - 1][a][b - 1]);\n\t\tif (a >= 2) can[i][a - 1][b] = true;\n\t\tif (a >= 1 && b >= 1) can[i][a - 1][b] = can[i][a][b - 1] = true;\n\t\tif (b >= 2) can[i][a][b - 1] = true;\n\t\tif (i < slen) {\n\t\t\tif (a >= 1 || b >= 1) can[i + 1][a][b] = true;\n\t\t\tif (s[i] == '0' && b >= 1) can[i + 1][a + 1][b - 1] = true;\n\t\t\tif (s[i] == '1' && a >= 1) can[i + 1][a - 1][b + 1] = true;\n\t\t}\n\t\tif (i + 1 < slen) {\n\t\t\tif (s[i] == '0' || s[i + 1] == '0') can[i + 2][a + 1][b] = true;\n\t\t\tif (s[i] == '1' || s[i + 1] == '1') can[i + 2][a][b + 1] = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%s\", s); slen = strlen(s);\n\tprintf(\"%d\\n\", solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nstring s;\nint pre[78][78][78][78]; \nint g[78][78][78];\nint suf[333][333][333]; //# of strings s.t. LCS from back with s goes to that long\n//length of T, position at s matched, # of 1s\nint f[333][333][333];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s;\n\tint n=s.length();\n\t\n\tpre[0][0][0][0]=1; //prefix of length 0, 0 1s, 0 0s taken\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=n;l++)\n\t\t\t\t{\n\t\t\t\t\tif(!pre[i][j][k][l]) continue;\n\t\t\t\t\t//11\n\t\t\t\t\tif(i+2<=n) pre[i+2][j+1][k][l]=1;\n\t\t\t\t\t//01\n\t\t\t\t\tif(i+2<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='1') pre[i+2][j][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+2][j][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//10\n\t\t\t\t\tif(i+2<=n)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i+1]=='1') pre[i+2][j][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+2][j][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//0\n\t\t\t\t\tif(j>0) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='1') pre[i+1][j-1][k+1][l]=1;\n\t\t\t\t\t\telse pre[i+1][j-1][k][l+1]=1;\n\t\t\t\t\t}\n\t\t\t\t\t//1\n\t\t\t\t\tpre[i+1][j][k][l]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=n;l++)\n\t\t\t\t{\n\t\t\t\t\tif(pre[i][j][k][l]) g[i][k][l]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tf[0][0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\t//assert(f[i][j][k]==g[i][j][k]);\n\t\t\t\tif(!f[i][j][k]) continue;\n\t\t\t\tf[i+1][j][k]=1;\n\t\t\t\tif(i+3<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+2]=='1') f[i+3][j+1][k]=1;\n\t\t\t\t\telse f[i+3][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i+2<=n) \n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t\tif(s[i]=='1') f[i+2][j+1][k]=1;\n\t\t\t\t\telse f[i+2][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='0')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(j>0&&s[i]=='1')\n\t\t\t\t{\n\t\t\t\t\tf[i+1][j+1][k-1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsuf[0][n][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(suf[i][j][k]==0) continue;\n\t\t\t\tint v=suf[i][j][k];\n\t\t\t\t//choose s[j-1]!\n\t\t\t\tradd(suf[i+1][j-1][k],v);\n\t\t\t\t//choose opposite of s[j-1] sia\n\t\t\t\tradd(suf[i+1][j][k+(s[j-1]=='0')],v);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 1; //match completely\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint preans=ans;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tint v = suf[i][j][k];\n\t\t\t\tif(v==0) continue;\n\t\t\t\t//cerr<<i<<' '<<j<<' '<<k<<' '<<v<<'\\n';\n\t\t\t\t//s[0..j-1]\n\t\t\t\t//j=1 special care\n\t\t\t\tint ones = k;\n\t\t\t\tint zeroes = i-k-(n-j); //length - number of matches \n\t\t\t\t//cerr<<ones<<' '<<zeroes<<'\\n';\n\t\t\t\tif(zeroes<0) continue;\n\t\t\t\tif(zeroes+ones==0)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(j==1)\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v); \n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(f[j][ones][zeroes])\n\t\t\t\t{\n\t\t\t\t\tradd(ans,v);\n\t\t\t\t\t//cerr<<\"ADDED\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint newans = ans;\n\t\t//cerr<<\"LENGTH \"<<i<<\" = \"<<add(newans,MOD-preans)<<'\\n';\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld long double\n#define ll long long\n#define st first\n#define nd second\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst ll mod = 998244353;\nconst int N = 305;\nint n;\nstring s, t;\nll dp[N][N][N];\nbool p[N][N][N], ign[N][N][N];\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s;\n\tn = s.size();\n\tt = s;\n\treverse(t.begin(), t.end());\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=n; j>=0; --j) {\n\t\t\tfor(int k=n; k>=0; --k) {\n\t\t\t\tif(i==0) {\n\t\t\t\t\tif(j==0 && k==0) p[i][j][k]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1) continue;\n\t\t\t\tif((s[i-2] == '0' || s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j-1][k];\n\t\t\t\t}\n\t\t\t\tif((s[i-2] == '1' || s[i-1] == '1') && k != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j][k];\n\t\t\t\tif((s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j-1][k+1];\n\t\t\t\t}\n\t\t\t\tif((s[i-1] == '1') && k != 0){\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j+1][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j+1][k];\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j][k+1];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(i==0 && j==0 && k==0) {\n\t\t\t\t\tdp[i][j][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==0) {\n\t\t\t\t\tdp[i][j][k] = (((j==0)?0LL:dp[i][j-1][k]) + ((k==0)?0LL:dp[i][j][k-1])) % mod;\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n\t\t\t\tif(t[i-1] == '0' && k != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j][k-1]) % mod;\n\t\t\t\tif(t[i-1] == '1' && j != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j-1][k]) % mod;\n\t\t\t\tif(t[i-1] == '0' && (p[n-(i-1)][j+1][k] || ign[i-1][j+1][k])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(t[i-1]=='1' && (p[n-(i-1)][j][k+1] || ign[i-1][j][k+1])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(!ign[i][j][k] && p[n-i][j][k]) ans = (ans + dp[i][j][k]) % mod;\n\t\t\t\t//if(p[n-i][j][k] && !ign[i][j][k]) {\n\t\t\t\t//\tcout<<i<<' '<<j<<' '<<k<<\": \"<<dp[i][j][k]<<'\\n';\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans-1+mod)%mod;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 310;\n\ntypedef long long ll;\nconst int mod = 998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nint g[N][N][N],f[N][N][N],n;\n// j zeros to add, k ones to add;\nchar s[N];\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);reverse(s+1,s+n+1);\n\ts[n+1]='2';\n\tf[0][0][0]=g[0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tfor(int k=0;j+k<=i;k++){\n//\t\t\t\tf[i][j][k]=add(f[i][j][k], g[i][j][k]);\n\t\t\t\tif(g[i][j][k]){\n\t\t\t\t\tint _d=i-j-k+1;\n\t\t\t\t\tint dir=s[_d]-'0';\n\t\t\t\t\tg[i+1][j][k]=add(g[i][j][k],g[i+1][j][k]);\n\t\t\t\t\tif(dir)g[i+1][j+1][k]=add(g[i+1][j+1][k],g[i][j][k]);\n\t\t\t\t\telse g[i+1][j][k+1]=add(g[i+1][j][k+1],g[i][j][k]);\n\t\t\t\t}\n\t\t\t\t/*-------*/\n\t\t\t}\n\t\t}\n\t}\n\n\tf[n][0][0]=1;\n\tfor(int i=n-1;i;i--){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tfor(int k=0;j+k<=i;k++){\n\t\t\t\tint dir=s[i-j-k+1]-'0';\n\t\t\t\tint dir2=s[i-j-k+2]-'0';\n//\t\t\t\tassert(dir>=0&&dir<=1&&dir2>=0&&dir2<=1);\n//\t\t\t\tcerr << dir << \" \" << dir2 << endl;\n\t\t\t\tint nt[3];\n\t\t\t\tnt[0]=j,nt[1]=k,nt[2]=0;\n\t\t\t\tnt[0]++;\n\t\t\t\tif(nt[dir]){\n\t\t\t\t\tnt[dir]--;\n\t\t\t\t\tif(nt[dir2]&&(dir2==0||dir==0))nt[dir2]--;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]|=f[i+1][nt[0]][nt[1]];\n//\t\t\t\tcerr << nt[0] << \" \" << nt[1] << \",\";\n\t\t\t\tnt[0]=j,nt[1]=k;\n\t\t\t\tnt[1]++;\n\t\t\t\tif(nt[dir]){\n\t\t\t\t\tnt[dir]--;\n\t\t\t\t\tif(nt[dir2]&&(dir2==1||dir==1))nt[dir2]--;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]|=f[i+1][nt[0]][nt[1]];\n//\t\t\t\tcerr << nt[0] << \" \" << nt[1] << endl;\n//\t\t\t\tcerr << i << \" \" << j << \" \" << k << \"|\" << f[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++)for(int k=0;k+j<=i;k++){\n\t\t\tif(f[i][j][k]){\n//\t\t\t\tcerr << i << \" \" << j << \" \" << k << \" \" << g[i][j][k] << endl;\n\t\t\t\tans=add(ans, g[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconstexpr int inf=1e9+7;\nconstexpr ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nll dp[333][333][333], dp2[333][333][333];\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    cin>>s;\n    int n=s.size();\n    string t(s.rbegin(),s.rend());\n    dp[0][0][0]=1;\n    rep(i,n+1)rep(j,301)rep(k,301){\n        if(i==0&&j==0&&k==0)continue;\n        if(i==0){\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='0'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(k>0)dp[i][j][k]+=dp[i][j][k-1];\n        }\n        if(i>0 && t[i-1]=='1'){\n            dp[i][j][k]+=dp[i-1][j][k];\n            if(j>0)dp[i][j][k]+=dp[i][j-1][k];\n        }\n    }\n    dp2[0][0][0]=1;\n    rep(i,n+1)for(int j=300;j>=0;--j)for(int k=300;k>=0;--k){\n        if(j>=2)dp2[i][j-2][k]|=dp2[i][j][k];\n        if(k>=2)dp2[i][j][k-2]|=dp2[i][j][k];\n        if(j>=1 && k>=1)dp2[i][j-1][k-1]|=dp2[i][j][k];\n        if(i<n && s[i]=='0'){\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n            if(k>0)dp2[i+1][j+1][k-1]|=dp2[i][j][k];\n        }\n        if(i<n && s[i]=='1'){\n            if(j>0)dp2[i+1][j-1][k+1]|=dp2[i][j][k];\n            if(j>0||k>0)dp2[i+1][j][k]|=dp2[i][j][k];\n        }\n        if(i+1<n){\n            if(s[i]=='0'||s[i+1]=='0')dp2[i+2][j+1][k]|=dp2[i][j][k];\n            if(s[i]=='1'||s[i+1]=='1')dp2[i+2][j][k+1]|=dp2[i][j][k];\n        }\n    }\n    ll ans=0;\n    REP(i,1,n+1){\n        int l=max(0,2*i-n);\n        rep(j,301)rep(k,301){\n            if(dp2[n-l][j][k] && j+k+l==i)ans+=dp[l][j][k];\n        }\n        cout<<ans<<\" \";\n    }\n    cout<<ans%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T, int NDIMS> struct tensor_view {\n\tstatic_assert(NDIMS >= 0);\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tT* data;\n\n\ttensor_view(std::array<int, NDIMS> shape_, std::array<int, NDIMS> strides_, T* data_) : shape(shape_), strides(strides_), data(data_) {}\n\npublic:\n\ttensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\nprotected:\n\tint flatten_index(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) { res += idx[i] * strides[i]; }\n\t\treturn res;\n\t}\n\tint flatten_index_checked(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) {\n\t\t\tassert(0 <= idx[i] && idx[i] < shape[i]);\n\t\t\tres += idx[i] * strides[i];\n\t\t}\n\t\treturn res;\n\t}\n\npublic:\n\tT& operator[] (std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index(idx)];\n\t}\n\tT& at(std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index_checked(idx)];\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) const {\n\t\tstd::array<int, NDIMS-1> nshape; std::copy(shape.begin()+1, shape.end(), nshape.begin());\n\t\tstd::array<int, NDIMS-1> nstrides; std::copy(strides.begin()+1, strides.end(), nstrides.begin());\n\t\tT* ndata = data + (strides[0] * idx);\n\t\treturn tensor_view<T, NDIMS-1>(nshape, nstrides, ndata);\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) const {\n\t\tassert(0 <= idx && idx < shape[0]);\n\t\treturn operator[](idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () const {\n\t\treturn *data;\n\t}\n\n\ttemplate <typename U, int D> friend struct tensor_view;\n\ttemplate <typename U, int D> friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS> struct tensor {\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tint len;\n\tT* data;\n\npublic:\n\ttensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n\texplicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n\t\tshape = shape_;\n\t\tstrides[NDIMS-1] = 1;\n\t\tfor (int i = NDIMS-1; i > 0; i--) {\n\t\t\tstrides[i-1] = strides[i] * shape[i];\n\t\t}\n\t\tlen = strides[0] * shape[0];\n\t\tdata = new T[len];\n\t\tstd::fill(data, data + len, t);\n\t}\n\n\ttensor(const tensor& o) : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tdata[i] = o.data[i];\n\t\t}\n\t}\n\n\ttensor& operator=(tensor&& o) noexcept {\n\t\tusing std::swap;\n\t\tswap(shape, o.shape);\n\t\tswap(strides, o.strides);\n\t\tswap(len, o.len);\n\t\tswap(data, o.data);\n\t}\n\ttensor(tensor&& o) : tensor() {\n\t\t*this = std::move(o);\n\t}\n\ttensor& operator=(const tensor& o) {\n\t\treturn *this = tensor(o);\n\t}\n\t~tensor() { delete[] data; }\n\n\tusing view_t = tensor_view<T, NDIMS>;\n\tview_t view() {\n\t\treturn tensor_view<T, NDIMS>(shape, strides, data);\n\t}\n\toperator view_t() {\n\t\treturn view();\n\t}\n\n\tusing const_view_t = tensor_view<const T, NDIMS>;\n\tconst_view_t view() const {\n\t\treturn tensor_view<const T, NDIMS>(shape, strides, data);\n\t}\n\toperator const_view_t() const {\n\t\treturn view();\n\t}\n\n\tT& operator[] (std::array<int, NDIMS> idx) { return view()[idx]; }\n\tT& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n\tconst T& operator[] (std::array<int, NDIMS> idx) const { return view()[idx]; }\n\tconst T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> operator[] (int idx) const {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> at(int idx) const {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () {\n\t\treturn *view();\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), const T&> operator * () const {\n\t\treturn *view();\n\t}\n};\n\ntemplate <typename T> void setmax(T& a, const T& b) { if (b > a) a = b; }\ntemplate <typename T> void setmin(T& a, const T& b) { if (b < a) a = b; }\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tusing num = modnum<998244353>;\n\n\tstring S; cin >> S;\n\tint N = int(S.size());\n\tvector<array<int, 2>> suff_cnt(N+1);\n\tsuff_cnt[N] = array<int, 2>{0,0};\n\tfor (int i = N-1; i >= 0; i--) {\n\t\tsuff_cnt[i] = suff_cnt[i+1];\n\t\tsuff_cnt[i][S[i]-'0']++;\n\t}\n\tarray<int, 2> C = suff_cnt[0];\n\n\ttensor<num, 3> cnt_subseq({C[0]+1, C[1]+1, N+1});\n\tcnt_subseq[{0,0,N}] = 1;\n\tfor (int i = 0; i <= C[0]; i++) {\n\t\tfor (int j = 0; j <= C[1]; j++) {\n\t\t\tfor (int l = 0; l <= N; l++) {\n\t\t\t\tif (i < C[0]) {\n\t\t\t\t\tcnt_subseq[{i+1,j, (l && S[l-1] == '0') ? l-1 : l}] += cnt_subseq[{i,j,l}];\n\t\t\t\t}\n\t\t\t\tif (j < C[1]) {\n\t\t\t\t\tcnt_subseq[{i,j+1, (l && S[l-1] == '1') ? l-1 : l}] += cnt_subseq[{i,j,l}];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttensor<int, 2> dp({C[0]+1,C[1]+1}, -1);\n\tdp[{C[0], C[1]}] = 0;\n\n\tnum ans = 0;\n\tfor (int i = C[0]; i >= 0; i--) {\n\t\tfor (int j = C[1]; j >= 0; j--) {\n\n\t\t\tint p = dp[{i,j}];\n\t\t\tif (p == -1) continue;\n\t\t\tfor (int z = 0; z <= p; z++) {\n\t\t\t\tans += cnt_subseq[{i,j,z}];\n\t\t\t}\n\n\t\t\tif (i+j < 2) continue;\n\n\t\t\tint ei = i - suff_cnt[p][0];\n\t\t\tint ej = j - suff_cnt[p][1];\n\n\t\t\tif (ei > 0) {\n\t\t\t\tsetmax(dp[{i-1, j}], min(p+1, N));\n\t\t\t}\n\t\t\tif (ej > 0) {\n\t\t\t\tsetmax(dp[{i, j-1}], min(p+1, N));\n\t\t\t}\n\t\t\tif (p < N) {\n\t\t\t\tif (S[p] == '0') {\n\t\t\t\t\tsetmax(dp[{i-1,j}], p+1);\n\t\t\t\t}\n\t\t\t\tif (S[p] == '1') {\n\t\t\t\t\tsetmax(dp[{i,j-1}], p+1);\n\t\t\t\t}\n\t\t\t\tif (p+1 < N) {\n\t\t\t\t\tif (S[p] == '0' || S[p+1] == '0') {\n\t\t\t\t\t\tsetmax(dp[{i-1,j}], p+2);\n\t\t\t\t\t}\n\t\t\t\t\tif (S[p] == '1' || S[p+1] == '1') {\n\t\t\t\t\t\tsetmax(dp[{i,j-1}], p+2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\t\n\tassert(std::count(s.begin(), s.end(), '0') && std::count(s.begin(), s.end(), '1'));\n\t\n\tint n = s.size();\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.06.2020 15:44:44       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  vector<vector<vector<bool>>> can(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1, false)));\n  can[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int k0 = n; k0 >= 0; k0--) {\n      for (int k1 = n; k1 >= 0; k1--) {\n        if (!can[i][k0][k1]) {\n          continue;\n        }\n        // both from string\n        if (i + 2 <= n) {\n          if (s[i] == '0' || s[i + 1] == '0') {\n            can[i + 2][k0 + 1][k1] = true;\n          }\n          if (s[i] == '1' || s[i + 1] == '1') {\n            can[i + 2][k0][k1 + 1] = true;\n          }\n        }\n        // both from pocket\n        if (k0 > 0 && k0 + k1 >= 2) {\n          can[i][k0 - 1][k1] = true;\n        }\n        if (k1 > 0 && k0 + k1 >= 2) {\n          can[i][k0][k1 - 1] = true;\n        }\n        // one from string, one from pocket, erase from string\n        if (i + 1 <= n && k0 + k1 >= 1) {\n          can[i + 1][k0][k1] = true;\n        }\n        // one from string, one from pocket, erase from pocket\n        if (i + 1 <= n && k0 > 0) {\n          if (s[i] == '0') {\n            can[i + 1][k0][k1] = true;\n          } else {\n            can[i + 1][k0 - 1][k1 + 1] = true;\n          }\n        }\n        if (i + 1 <= n && k1 > 0) {\n          if (s[i] == '0') {\n            can[i + 1][k0 + 1][k1 - 1] = true;\n          } else {\n            can[i + 1][k0][k1] = true;\n          }\n        }\n      }\n    }\n  }\n  vector<vector<vector<Mint>>> dp(n + 1, vector<vector<Mint>>(n + 1, vector<Mint>(n + 1, 0)));\n  dp[0][0][n] = 1;\n  for (int k0 = 0; k0 <= n; k0++) {\n    for (int k1 = 0; k1 <= n; k1++) {\n      for (int pos = n; pos >= 0; pos--) {\n        Mint ft = dp[k0][k1][pos];\n        if (ft == 0) {\n          continue;\n        }\n        if (k0 < n) {\n          int new_pos = pos;\n          if (pos > 0 && s[pos - 1] == '0') {\n            new_pos -= 1;\n          }\n          dp[k0 + 1][k1][new_pos] += ft;\n        }\n        if (k1 < n) {\n          int new_pos = pos;\n          if (pos > 0 && s[pos - 1] == '1') {\n            new_pos -= 1;\n          }\n          dp[k0][k1 + 1][new_pos] += ft;\n        }\n      }\n    }\n  }\n  vector<int> suf_ones(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suf_ones[i] = suf_ones[i + 1] + (s[i] == '1');\n  }\n  Mint ans = 0;\n  for (int k0 = 0; k0 <= n; k0++) {\n    for (int k1 = 0; k1 <= n; k1++) {\n      int max_pos = -1;\n      for (int pos = n; pos >= 0; pos--) {\n        int n0 = k0;\n        int n1 = k1;\n        n0 -= (n - pos) - suf_ones[pos];\n        n1 -= suf_ones[pos];\n        if (n0 >= 0 && n1 >= 0 && can[pos][n0][n1]) {\n          max_pos = pos;\n          break;\n        }\n      }\n      if (max_pos == -1) {\n        continue;\n      }\n      for (int i = 0; i <= max_pos; i++) {\n        ans += dp[k0][k1][i];\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 998244353\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\nbool ok[301][301][301];\nbool used[301][301][301];\nmod dp[301][301][301];\nint main(){\n    make();\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n==1){\n        cout << 1 << endl;\n        return 0;\n    }\n    int cc[2] = {};\n    cc[s[0]-'0']++;\n    cc[s[1]-'0']++;\n    if(cc[0]==1&&cc[1]==1){\n        ok[1][1][0] = 1;\n        ok[1][0][1] = 1;\n    }else if(cc[0]==2){\n        ok[1][1][0] = 1;\n    }else{\n        ok[1][0][1] = 1;\n    }\n    for(int i=2;i<n;i++){\n        cc[s[i]-'0']++;\n    }\n    for(int i=1;i<n-1;i++){\n        for(int x = 0;x<=cc[0];x++){\n            for(int y = 0;y<=cc[1];y++){\n                if(ok[i][x][y]){\n                    if(s[i+1]=='0'){\n                        if(y!=0)ok[i+1][x+1][y-1] = 1;\n                        ok[i+1][x][y] = 1;\n                    }else{\n                        if(x!=0)ok[i+1][x-1][y+1] = 1;\n                        ok[i+1][x][y] = 1;\n                    }\n                    if(i!=n-2){\n                        if(s[i+1]=='0'&&s[i+2]=='0'){\n                            ok[i+2][x+1][y] = 1;\n                        }\n                        \n                        if(s[i+1]=='0'&&s[i+2]=='1'){\n                            ok[i+2][x+1][y] = 1;\n                            ok[i+2][x][y+1] = 1;\n                        }\n                        \n                        if(s[i+1]=='1'&&s[i+2]=='0'){\n                            ok[i+2][x+1][y] = 1;\n                            ok[i+2][x][y+1] = 1;\n                        }\n                        if(s[i+1]=='1'&&s[i+2]=='1'){\n                            ok[i+2][x][y+1] = 1;\n                        }\n                    }\n                }\n            }   \n        }\n    }\n    for(int x=0;x<=cc[0];x++){\n        for(int y=0;y<=cc[1];y++){\n            dp[n-1][x][y] = comb(x+y,y);\n            // cerr << \"test:\" << n-1 << \" \" << x << \" \" << y << \" \" << dp[n-1][x][y] << endl;\n        }   \n    }\n    for(int i=n-2;i>=0;i--){\n        for(int x=0;x<=cc[0];x++){\n            for(int y=0;y<=cc[1];y++){\n                if(s[i+1]=='0'){\n                    dp[i][x][y] += dp[i][x][y-1];\n                    dp[i][x][y] += dp[i+1][x][y];\n                }else{\n                    dp[i][x][y] += dp[i][x-1][y];\n                    dp[i][x][y] += dp[i+1][x][y];\n                }\n            }\n        }\n    }\n    mod res = 1;\n    for(int i=n-1;i>=0;i--){\n        for(int x=0;x<=cc[0];x++){\n            for(int y=0;y<=cc[1];y++){\n                if(ok[i][x][y]&&!used[i][x][y]){\n                    res += dp[i][x][y];\n                    // cerr << i << \" \" << x << \" \" << y << \" \" << dp[i][x][y] << endl;\n                    if(x+y!=1){\n                        int xx = x;\n                        int yy = y;\n                        for(int g = i;g>=1;g--){\n                            if(s[g]=='0'){\n                                xx--;\n                                if(xx>=0){\n                                    used[g-1][xx][yy] = 1;\n                                }\n                            }else{\n                                yy--;\n                                if(yy>=0){\n                                    used[g-1][xx][yy] = 1;\n                                }\n                            }\n                            if(xx<0||yy<0||xx+yy==1)break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t    chkmax(vis[i+1][j][k],tmp);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t\tchkmax(vis[i+1][j][k],tmp);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t/*\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];*/\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\t//cout<<\"i j k \"<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define MN 300\n#define mod 998244353\nusing namespace std;\nint n;\nchar s[MN + 5];\n/*\n  f:\n  (from the end) length = i, has inserted j '0' and k '1', i.e. keep the last i - j - k bits of the original sequence\n  how many (different) possible sequences\n  note that j,k are the minimum number of bits to insert\n*/\nint f[MN + 5][MN + 5][MN + 5]; \n/*\n  g:\n  has performed i deletion, whether possible to insert j '0' and k '1' into the latter part\n*/\nbool g[MN + 5][MN + 5][MN + 5];\nint num0[MN + 5], Max[MN + 5];\n\ninline void R(int &x, int y) {\n  (x += y) >= mod ? x -= mod : 0;\n}\n\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  for (int i = n; i; --i) {\n    num0[i] = num0[i + 1] + (s[i] == '0');\n  }\n  // first part: f\n  f[0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0 ; j < i; ++j) {\n      for (int k = 0; k < i - j; ++k) {\n        int t = s[n - i + 1 + j + k] - '0'; // current position in s\n        // if we want a t, then we should not insert (to minimize the number of insertion).\n        R(f[i][j][k], f[i - 1][j][k]);\n        // if we want a different bit(!t), then we should insert.\n        R(f[i][j + t][k + (!t)], f[i - 1][j][k]);\n      }\n    }\n  }\n  // second part: g\n  g[0][0][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j < i; ++j) {\n      for (int k = 0; k < i - j; ++k) {\n        if (!g[i - 1][j][k]) continue;\n        //printf(\"possible g: %d %d %d\\n\", i - 1, j, k);\n        int pos = i + j + k; // current position if we want to delete\n        if (pos < n) { // possible to delete 2 bits\n          int num0 = (s[pos] == '0') + (s[pos + 1] == '0');\n          int num1 = 2 - num0;\n          /* \n            possible action:\n            *  keep one bit for insertion\n            *  use 1 bit that kept before and keep another bit\n            *  use 2 bit that kept before and keep one of them\n          */\n          if (num0) g[i][j + 1][k] = 1;\n          if (num1) g[i][j][k + 1] = 1;\n        }\n        if (pos <= n) { // possible to delete 1 bit\n          if (j && s[pos] == '1') {\n            g[i][j - 1][k + 1] = 1;\n          } else if (k && s[pos] == '0') {\n            g[i][j + 1][k - 1] = 1;\n          }\n          if (j|k) g[i][j][k] = 1;\n        }\n        if (j >= 2) g[i][j - 1][k] = 1;\n        if (k >= 2) g[i][j][k - 1] = 1;\n      }\n    }\n  }\n  // calculate the answer\n  int ans = 0;\n  for (int length = 1; length <= n; ++length) {\n    memset(Max, -1, sizeof(Max));\n    // if we can get one by insert j '0' and k '1'\n    // then we can also get it by insert more '0' and '1'\n    // as long as the number of '0' and '1' is correct\n    for (int j = length; ~j; --j) {\n      for (int k = length - j; ~k; --k) {\n        int now_num0 = num0[n - length + 1 + j + k] + j;\n        if (g[n - length][j][k]) {\n          Max[now_num0] = max(Max[now_num0], k);\n        }\n        if (Max[now_num0] >= k) {\n          R(ans, f[length][j][k]);\n        }\n      }\n    }\n  }\n  cout << ans;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int M=998244353;\nchar str[305];\n\nint r[305][305];\nvoid build () {\n\tr[0][0]=r[1][0]=r[1][1]=1;\n\tfor (int i=2;i<=300;i++) {\n\t\tr[i][0]=r[i][i]=1;\n\t\tfor (int j=1;j<i;j++) {\n\t\t\tr[i][j]=r[i-1][j-1]+r[i-1][j];\n\t\t\tif (r[i][j]>=M) r[i][j]-=M;\n\t\t}\n\t}\n}\n\nint f[305][305][305];\ninline int calc (int x,int y,int h[],int n) {\n\tif (n<=0) return r[x+y][x];\n\tfor (int i=1;i<=n;i++) {\n\t\tif (h[i]==0) x++;\n\t\telse y++;\n\t}\n\tmemset (f,0,sizeof (f));\n\tf[0][0][0]=1;\n\tfor (int i=1,ii=x+y;i<=ii;i++) {\n\t\tfor (int j=0;j<=n;j++) {\n\t\t\tfor (int k=max (0,i-y);k<=x;k++) {\n\t\t\t\tif (h[j]==0) {\n\t\t\t\t\tif (k>0) {\n\t\t\t\t\t\tf[i][j][k]=f[i-1][j][k]+f[i-1][j-1][k-1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[i][j][k]=f[i-1][j][k];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (k>0) {\n\t\t\t\t\t\tf[i][j][k]=f[i-1][j][k-1]+f[i-1][j-1][k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f[i][j][k]>=M) f[i][j][k]-=M;\n\t\t\t}\n\t\t}\n\t}\n\treturn f[x+y][n][x];\n}\n\nint main () {\n\t\n\tbuild ();\n\tscanf (\"%s\",str); int a=0,b=0,h[1005],ans=0;\n\tfor (int i=0,ii=strlen (str);i<ii;i++) h[i+1]=str[i]-'0';\n\tfor (int i=0,ii=strlen (str);i<ii;i++) {\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (j>a||i-j>b) continue;\n\t\t\tint res=calc (a-j,b-(i-j),&h[i*2],ii-i*2);\n//\t\t\tprintf (\"%d %d %d\\n\",a-j,b-(i-j),res);\n\t\t\tans+=res;\n\t\t\tif (ans>=M) ans-=M;\n\t\t}\n\t\tif (i*2+1<=ii) {if (h[i*2+1]==0) a++; else b++;}\n\t\tif (i*2+2<=ii) {if (h[i*2+2]==0) a++; else b++;}\n\t}\n\tprintf (\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n//#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 998244353;\n\nvoid add(int &a, int b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nvoid sub(int &a, int b)\n{\n\ta -= b;\n\tif (a < 0)\n\t\ta += mod;\n}\n\nint mult(int a, int b)\n{\n\treturn ll(a) * b % mod;\n}\n\nvector<vector<vector<int>>> calc(const string &s)\n{\n\tconst int n = int(s.size());\n\n\tvector<vector<vector<int>>> ans(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1)));\n\n\tvector<vector<vector<vector<int>>>> dp(n + 1, vector<vector<vector<int>>>(n + 1,\n\t                                                                          vector<vector<int>>(n + 1,\n\t                                                                                              vector<int>(2))));\n\tdp[0][0][0][0] = dp[0][0][0][1] = 1;\n\n\tfor (int len = 0; len <= n; len++)\n\t\tfor (int zero = 0; zero <= n; zero++)\n\t\t\tfor (int one = 0; one <= n; one++)\n\t\t\t\tfor (int fin = 0; fin < 2; fin++)\n\t\t\t\t{\n\t\t\t\t\tconst int cur = dp[len][zero][one][fin];\n\n\t\t\t\t\tif (fin == 1)\n\t\t\t\t\t\tadd(ans[len][zero][one], cur);\n\t\t\t\t\tif (cur == 0 || len + zero + one >= n)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tfor (int next_char = 0; next_char < 2; next_char++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fin == 1)\n\t\t\t\t\t\t\tadd(dp[len][zero + (next_char == 0)][one + (next_char == 1)][1], cur);\n\n\t\t\t\t\t\tif (fin == 0 && next_char == s[len] - '0')\n\t\t\t\t\t\t\tfor (int new_fin = fin; new_fin < 2; new_fin++)\n\t\t\t\t\t\t\t\tadd(dp[len + 1][zero][one][new_fin], cur);\n\n\t\t\t\t\t\tif (fin == 0 && next_char != s[len] - '0')\n\t\t\t\t\t\t\tadd(dp[len][zero + (next_char == 0)][one + (next_char == 1)][0], cur);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\treturn ans;\n}\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tstring s;\n\n\twhile (cin >> s)\n\t{\n\t\tconst int n = int(s.size());\n\n\t\tstring rev_s = s;\n\t\treverse(rev_s.begin(), rev_s.end());\n\n\t\tauto dp_ways = calc(rev_s);\n\n//\t\tfor (int i = 0; i < int(dp_ways.size()); i++)\n//\t\t\tfor (int j = 0; j < int(dp_ways[i].size()); j++)\n//\t\t\t\tfor (int k = 0; k < int(dp_ways[i][j].size()); k++)\n//\t\t\t\t\tif (dp_ways[i][j][k])\n//\t\t\t\t\t\tcerr << i << ' ' << j << ' ' << k << ' ' << dp_ways[i][j][k] << endl;\n//\t\tbreak;\n\n\t\tvector<vector<vector<bool>>> reach(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1)));\n\t\treach[0][0][0] = true;\n\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = n; j >= 0; j--)\n\t\t\t\tfor (int k = n; k >= 0; k--)\n\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j >= 2)\n\t\t\t\t\t\t\treach[i][j - 1][k] = true;\n\t\t\t\t\t\tif (k >= 2)\n\t\t\t\t\t\t\treach[i][j][k - 1] = true;\n\t\t\t\t\t\tif (j >= 1 && k >= 1)\n\t\t\t\t\t\t\treach[i][j][k - 1] = reach[i][j - 1][k] = true;\n\t\t\t\t\t}\n\n\t\t\tif (i + 1 <= n)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst int nj = j + (s[i] == '0'), nk = k + (s[i] == '1');\n\n\t\t\t\t\t\t\tif (nj > 0)\n\t\t\t\t\t\t\t\treach[i + 1][nj - 1][nk] = true;\n\t\t\t\t\t\t\tif (nk > 0)\n\t\t\t\t\t\t\t\treach[i + 1][nj][nk - 1] = true;\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i + 2 <= n)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\tfor (int k = 0; k <= n; k++)\n\t\t\t\t\t\tif (reach[i][j][k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int x = 0; x < 2; x++)\n\t\t\t\t\t\t\t\tif (s[i] == x + '0' || s[i + 1] == x + '0')\n\t\t\t\t\t\t\t\t\t(x == 0 ? reach[i + 2][j + 1][k] : reach[i + 2][j][k + 1]) = true;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tvector<int> cnt(2);\n\t\tvector<vector<bool>> used(n + 1, vector<bool>(n + 1, false));\n\n\t\tfor (int suff = 0; suff <= n; suff++)\n\t\t{\n\t\t\tfor (int zero = 0; zero <= n; zero++)\n\t\t\t\tfor (int one = 0; one <= n; one++)\n\t\t\t\t\tif (reach[n - suff][zero][one])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!used[cnt[0] + zero][cnt[1] + one])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tused[cnt[0] + zero][cnt[1] + one] = true;\n\t\t\t\t\t\t\tadd(ans, dp_ways[suff][zero][one]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\tif (suff < n)\n\t\t\t\tcnt[rev_s[suff] - '0']++;\n\t\t}\n\n\t\tsub(ans, 1);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 311;\nconst int mod = 998244353;\ninline void add(int &x, int y) { x += y; if(x >= mod) x -= mod; }\n\nchar s[maxn];\nint n, dp[maxn][maxn][maxn];\nbool can[maxn][maxn][maxn];\n\nint main()\n{\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\t\n\tcan[0][0][0] = 1;\n\tfor(int k=0; k<n; k++)\n\t{\n\t\tfor(int i=0; i<=n; i++) for(int k0=0; k0<=n; k0++)\n\t\t{\n\t\t\tint k1 = i - k - k0;\n\t\t\tif(k1 < 0) continue;\n\t\t\tif(!can[i][k0][k1]) continue;\n\t\t\tif(k0) can[i][k0-1][k1] = 1;\n\t\t\tif(k1) can[i][k0][k1-1] = 1;\n\t\t\tif(k0 >= 2) can[i][k0-1][k1] = 1;\n\t\t\tif(k1 >= 2) can[i][k0][k1-1] = 1;\n\t\t\tif(i < n)\n\t\t\t{\n\t\t\t\tint p = s[i] - '0';\n\t\t\t\tif(p == 0)\n\t\t\t\t{\n\t\t\t\t\tif(k1) can[i+1][k0+1][k1-1] = 1;\n\t\t\t\t\tif(k0) can[i+1][k0][k1] = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(k1) can[i+1][k0][k1] = 1;\n\t\t\t\t\tif(k0) can[i+1][k0-1][k1+1] = 1;\n\t\t\t\t}\n\t\t\t\tif(i < n - 1)\n\t\t\t\t{\n\t\t\t\t\tint q = s[i+1] - '0';\n\t\t\t\t\tif(p == 0 || q == 0) can[i+2][k0+1][k1] = 1;\n\t\t\t\t\tif(p == 1 || q == 1) can[i+2][k0][k1+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor(int i=0; i<n; i++) for(int n0=0; n0<=n; n0++) for(int n1=0; n1<=n; n1++) if(dp[i][n0][n1])\n\t{\n\t\tint pos = s[n - 1 - (i - n0 - n1)] - '0';\n\t\t// append 0\n\t\tif(pos == 0) add(dp[i+1][n0][n1], dp[i][n0][n1]);\n\t\telse add(dp[i+1][n0+1][n1], dp[i][n0][n1]);\n\t\t\n\t\t// append 1\n\t\tif(pos == 1) add(dp[i+1][n0][n1], dp[i][n0][n1]);\n\t\telse add(dp[i+1][n0][n1+1], dp[i][n0][n1]);\n\t}\n\t\n\tfor(int i=n-1; i>=0; i--) for(int k0=0; k0<=n; k0++) for(int k1=0; k1<=n; k1++)\n\t{\n\t\tif(can[i+1][k0][k1])\n\t\t{\n\t\t\tint p = s[i] - '0';\n\t\t\tif(p == 0 && k0) can[i][k0-1][k1] = 1;\n\t\t\tif(p == 1 && k1) can[i][k0][k1-1] = 1;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=1; i<=n; i++) for(int j=0; j<=n; j++) for(int k=0; k<=n; k++) if(dp[i][j][k])\n\t{\n\t\tint pos = n - (i - j - k);\n\t\tif(can[pos][j][k]) add(ans, dp[i][j][k]);\n\t}\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//%std\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint out = 0, fh = 1;\n\tchar jp = getchar();\n\twhile ((jp > '9' || jp < '0') && jp != '-')\n\t\tjp = getchar();\n\tif (jp == '-')\n\t\tfh = -1, jp = getchar();\n\twhile (jp >= '0' && jp <= '9')\n\t\tout = out * 10 + jp - '0', jp = getchar();\n\treturn out * fh;\n}\nvoid print(int x)\n{\n\tif (x >= 10)\n\t\tprint(x / 10);\n\tputchar('0' + x % 10);\n}\nvoid write(int x, char c)\n{\n\tif (x < 0)\n\t\tputchar('-'), x = -x;\n\tprint(x);\n\tputchar(c);\n}\nconst int P = 998244353;\nint add(int a, int b)\n{\n\treturn a + b >= P ? a + b - P : a + b;\n}\nvoid inc(int &a, int b)\n{\n\ta = add(a, b);\n}\nint mul(int a, int b)\n{\n\treturn 1LL * a * b % P;\n}\nconst int N = 300 + 10;\nchar s[N];\nint n, dp[N][N][N], f[N][N][N], valid[N][N][N];\nvoid upd(int &x, int y)\n{\n\tx = max(x, y);\n}\nint main()\n{\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; --i)\n\t\tfor (int j = 0; j + (n - i) <= n - 1; ++j)\n\t\t\tfor (int k = 0; j + k + (n - i) <= n - 1; ++k)\n\t\t\t{\n\t\t\t\tinc(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\t\tif (s[i] == '0')\n\t\t\t\t\tinc(dp[i][j][k + 1], dp[i][j][k]);\n\t\t\t\telse\n\t\t\t\t\tinc(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t}\n\tmemset(f, -1, sizeof f);\n\tf[0][0][0] = 0;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = 0; j <= (i >> 1); ++j)\n\t\t\tfor (int k = 0; j + k <= (i >> 1); ++k) if (f[i][j][k] != -1)\n\t\t\t{\n\t\t\t\tint tmp = f[i][j][k];\n\t\t\t\tif (i + 1 <= n && tmp != 0)\n\t\t\t\t{\n\t\t\t\t\tif (s[i + 1] == '0')\n\t\t\t\t\t\tupd(f[i + 1][j + 1][k], tmp - 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tupd(f[i + 1][j][k + 1], tmp - 1);\t\n\t\t\t\t}\n\t\t\t\tif (i + 2 <= n)\n\t\t\t\t{\n\t\t\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0')\n\t\t\t\t\t\tupd(f[i + 2][j + 1][k], tmp);\n\t\t\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1')\n\t\t\t\t\t\tupd(f[i + 2][j][k + 1], tmp);\n\t\t\t\t\tupd(f[i + 2][j][k], tmp + 1);\n\t\t\t\t}\n\t\t\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = n; j >= 0; --j)\n\t\t\tfor (int k = n; k >= 0; --k)\n\t\t\t{\n\t\t\t\tvalid[i][j][k] = (f[i][j][k] != -1);\n\t\t\t\tif (i)\n\t\t\t\t\tvalid[i][j][k] |= valid[i - 1][j][k];\n\t\t\t\tvalid[i][j][k] |= valid[i][j][k + 1];\n\t\t\t\tvalid[i][j][k] |= valid[i][j][k + 1];\n\t\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = 0; j + (n - i) <= n; ++j)\n\t\t\tfor (int k = 0; j + k + (n - i) <= n; ++k)\n\t\t\t\tif (valid[i][j][k] && (n - i) + j + k != 0)\n\t\t\t\t\tinc(ans, dp[i][j][k]);\n\twrite(ans, '\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define PII pair<int,int>\n\nconst int N=3e2+50;\nconst int mod=998244353;\n\nstring s;\nint n;\nbool dp[N][N][N];//len,matchs,zeros\nint cnt[N][N][N];\nint hl[]={0,0,1,1};\nint hr[]={1,0,1,0};\n\nint newM(int nm){\n    return (nm==n)?-1:s[n-nm-1]-'0';\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>s;\n\t/*for(int i=0;i<150;i++){\n        s+=\"01\";\n\t}*/\n\tn=s.size();\n    if(n==1){\n        cout<<1<<\"\\n\";\n        return 0;\n    }\n\tfor(int len=n;len>=1;len--){\n        for(int m=0;m<=len;m++){\n            for(int z=0;z<=len-m;z++){\n                int o=len-m-z;\n                bool& _dp=dp[len][m][z];\n                if(len==n){\n                    _dp=(m==n);\n                    continue;\n                }\n                int match=s[n-m-1]-'0';\n                for(int i=0;i<4;i++){\n                    int np[]={z,o};\n                    if(np[hr[i]]==0 && (m==0 || s[n-m]-'0'!=hr[i]))\n                        continue;\n                    int nm=m;\n                    int nmatch=match;\n                    if(np[hr[i]]!=0 && match==hr[i]){\n                        nm++;\n                        np[hr[i]]--;\n                        nmatch=newM(nm);\n                    }\n                    np[hl[i]]++;\n                    if(hl[i]==nmatch){\n                        nm++;\n                        np[hl[i]]--;\n                    }\n                    _dp|=dp[len+1][nm][np[0]];\n                }\n                for(int i=0;i<4;i++){\n                    int np[]={z,o};\n                    if(np[hr[i]]==0)\n                        continue;\n                    int nm=m;\n                    int nmatch=match;\n                    np[hl[i]]++;\n                    if(hl[i]==nmatch){\n                        nm++;\n                        np[hl[i]]--;\n                        nmatch=(nm==n)?-1:s[n-nm-1]-'0';\n                    }\n                    if(nmatch==hr[i]){\n                        nm++;\n                        np[hr[i]]--;\n                    }\n                    _dp|=dp[len+1][nm][np[0]];\n                }\n                if(m!=0 && newM(m)==s[n-m]-'0'){\n                    _dp|=dp[len+1][m+1][z];\n                }\n\n            }\n        }\n\t}\n\t//cout<<dp[2][0][2]<<\"\\n\";\n\tcnt[0][0][0]=1;\n\tint ans=0;\n\tfor(int len=1;len<=n;len++){\n        for(int m=0;m<=len;m++){\n            for(int z=0;z<=len-m;z++){\n                int o=len-m-z;\n                int& _cnt=cnt[len][m][z];\n                int lm=(m==0)?-1:s[n-m]-'0';\n                int lnm=(m==n)?-1:s[n-m-1]-'0';\n                _cnt=0;\n                if(m!=0)\n                    _cnt=cnt[len-1][m-1][z];\n                if(lnm!=1){\n                    _cnt=(_cnt+cnt[len-1][m][z])%mod;\n                }\n                if(lnm!=0 && z>0){\n                    _cnt=(_cnt+cnt[len-1][m][z-1])%mod;\n                }\n                if(dp[len][m][z]){\n                    //cout<<len<<\" \"<<m<<\" \"<<z<<\" \"<<_cnt<<\"\\n\";\n                    ans=(ans+_cnt)%mod;\n                }\n            }\n        }\n\t}\n\tcout<<ans<<\"\\n\";\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nchar s[333];\nint n,suf0[333],suf1[333],arr[333],mx[333][333],num[333][333][333],ans;\nbool dp[333][333][333];\nvoid upd(int &x,int y)\n{\n\tif (x<y) x=y;\n}\nvoid add(int &x,int y)\n{\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\nint main()\n{\n\tscanf(\"%s\",s);n=strlen(s);\n\tfor (int i=1;i<=n;i++) arr[i]=s[i-1]-'0';\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tsuf0[i]=suf0[i+1]+(arr[i]==0);\n\t\tsuf1[i]=suf1[i+1]+(arr[i]==1);\n\t} \n\tdp[0][0][1]=1;\n\tfor (int k=1;k<=n+1;k++)\n\t{\n\t\tfor (int i=n;i>=0;i--)\n\t\t{\n\t\t\tfor (int j=n;j>=0;j--)\n\t\t\t{\n\t\t\t\tif (!dp[i][j][k]) continue;\n\t\t\t\tif (arr[k]==1 || arr[k+1]==1) dp[i][j+1][k+2]=1;\n\t\t\t\tif (arr[k]==0 || arr[k+1]==0) dp[i+1][j][k+2]=1;\n\t\t\t\tdp[i][j][k+1]=1;\n\t\t\t\tif (arr[k]==1 && i) dp[i-1][j+1][k+1]=1;\n\t\t\t\tif (arr[k]==0 && j) dp[i+1][j-1][k+1]=1;\n\t\t\t\tif (i) dp[i-1][j][k]=1;\n\t\t\t\tif (j) dp[i][j-1][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(mx,-1,sizeof(mx));\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor (int k=1;k<=n+1;k++)\n\t\t\t{\n\t\t\t\tif (dp[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tupd(mx[i+suf0[k]][j+suf1[k]],k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnum[0][0][n]=1;\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tadd(num[i+1][j][0],num[i][j][0]);\n\t\t\tadd(num[i][j+1][0],num[i][j][0]);\n\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif (arr[k])\n\t\t\t\t{\n\t\t\t\t\tadd(num[i+1][j][k],num[i][j][k]);\n\t\t\t\t\tadd(num[i][j+1][k-1],num[i][j][k]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tadd(num[i+1][j][k-1],num[i][j][k]);\n\t\t\t\t\tadd(num[i][j+1][k],num[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tif (!i && !j) continue;\n\t\t\tfor (int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif (k<mx[i][j]) \n\t\t\t\t{\n\t\t\t\t\tif (num[i][j][k]) \n\t\t\t\t\t{\n\t\t\t\t\t\tadd(ans,num[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nbool ok[303][303][303];\nbool ok1[303][303][303];\nll dp[303][303][303];\nint main()\n{\n\tstring s; cin>>s;\n\tint n=s.size();\n\tok[0][0][0]=1;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=n; j>=0; j--){\n\t\t\tfor(int k=n; k>=0; k--){\n\t\t\t\tif(!ok[i][j][k]) continue;\n\t\t\t\tif(j && j+k>=2) ok[i][j-1][k]=1;\n\t\t\t\tif(k && j+k>=2) ok[i][j][k-1]=1;\n\t\t\t\tif(i+1<n && (s[i]=='0' || s[i+1]=='0')){\n\t\t\t\t\tok[i+2][j+1][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i+1<n && (s[i]=='1' || s[i+1]=='1')){\n\t\t\t\t\tok[i+2][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && j && s[i]=='1'){\n\t\t\t\t\tok[i+1][j-1][k+1]=1;\n                  ok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && j && s[i]=='0'){\n\t\t\t\t\tok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && k && s[i]=='0'){\n\t\t\t\t\tok[i+1][j+1][k-1]=1;\n                  ok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && k && s[i]=='1'){\n\t\t\t\t\tok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n; i++) for(int j=0; j<=n; j++) for(int k=0; k<=n; k++) ok1[i][j][k]=ok[i][j][k];\n\tfor(int i=n; i>=1; i--){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=n; k++){\n\t\t\t\tif(!ok1[i][j][k]) continue;\n\t\t\t\tif(s[i-1]=='0' && j) ok1[i-1][j-1][k]=1;\n\t\t\t\telse if(s[i-1]=='1' && k) ok1[i-1][j][k-1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=1;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; i+j<=n; j++){\n\t\t\tfor(int k=0; i+j+k<=n; k++){\n\t\t\t\t(dp[i+1][j][k]+=dp[i][j][k])%=MOD;\n\t\t\t\tif(i<n && s[n-1-i]=='0'){\n\t\t\t\t\t(dp[i][j][k+1]+=dp[i][j][k])%=MOD;\n\t\t\t\t}else if(i<n){\n\t\t\t\t\t(dp[i][j+1][k]+=dp[i][j][k])%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; i+j<=n; j++){\n\t\t\tfor(int k=0; i+j+k<=n; k++){\n\t\t\t\tif(i+j+k==0) continue;\n\t\t\t\tif(ok1[n-i][j][k]) (ans+=dp[i][j][k])%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 302, p = 998244353;\nvoid add(int &v, int val) {\n\tv += val - p;\n\tv += (v>>31) & p;\n}\nint dp[maxn][maxn][maxn], n, c0, c1, pf1[maxn][maxn<<1][maxn], pf2[maxn][maxn][maxn];\nbool can[maxn][maxn][maxn];\nint pc0[maxn], pc1[maxn], suf1[maxn], suf0[maxn];\nchar w[maxn];\nint res;\nvoid makepf(int x) {\n\tfor (int i = 1;i < n+n;++i)\n\t\tfor (int j = 0;j < n;++j) {\n\t\t\tpf1[x][i][j] = dp[x][i][j];\n\t\t\tadd( pf1[x][i][j], pf1[x][i-1][j+1] );\n\t\t}\n\tfor (int i = 1;i < n;++i)\n\t\tfor (int j = 0;j < n;++j) {\n\t\t\tpf2[x][i][j] = dp[x][i][j];\n\t\t\tadd( pf2[x][i][j], pf2[x][i-1][j] );\n\t\t}\n}\n#define G(V, i, j, k) (min({i,j,k}) < 0 ? 0 : V[i][j][k])\n#define GC(V, i) ((i) < 0 ? 0 : V[i])\nvoid getdp() {\n\tdp[n][0][0] = 1;\n\tfor (int i = n;i >= 0;--i) \n\t\tfor (int j = 0;j <= n;++j)\n\t\t\tfor (int k = 0;k <= n;++k) if (dp[i][j][k]) {\n\t\t\t\tchar W = (i>0? w[i-1] : ';');\n\t\t\t\tif (W != '0')\n\t\t\t\t\tadd(dp[i][j+1][k], dp[i][j][k]);\n\t\t\t\tif (W != '1')\n\t\t\t\t\tadd(dp[i][j][k+1], dp[i][j][k]);\n\t\t\t\tif (i)\n\t\t\t\t\tadd(dp[i-1][ j ][ k ], dp[i][j][k]);\n\t\t\t}\n\tfor (int i = 1;i <= n;++i)\n\t\tfor (int j = 0;j <= n;++j)\n\t\t\tfor (int k = 0;k <= n;++k) {\n\t\t//\t\tif (can[i-1][j][k])\n\t\t//\t\t\tcerr << i-1 << ' ' << j << ' '<< k << \" dp \" << dp[i][j][k] << '\\n';\n\t\t\t\tif (dp[i][j][k] && can[i-1][j][k])\n\t\t\t\t\tadd(res, dp[i][j][k]);\n\t\t\t}\n}\n\nvoid solve() {\n\tfor (int i = n-1;i >= 0;--i) {\n\t\tsuf1[i] = suf1[i+1] + (w[i] == '1');\n\t\tsuf0[i] = suf0[i+1] + (w[i] == '0');\n\t}\n\t{\n\t\tint x = w[0] == '0', y = w[1] == '0';\n\t\tcan[0][0][0] = true;\n\t\tcan[1][x || y][0] = true;\n\t\tcan[1][0][!x || !y] = true;\n\t\tfor (int i = 0;i <= n;++i) \n\t\t\tfor (int j = 0;j <= i+1;++j)\n\t\t\t\tfor (int k = 0;k <= i+1;++k) if (can[i][j][k]) {\n\t\t\t\t\tint x = w[i+1] == '0', y = w[i+2] == '0';\n\t\t\t\t\tint q = w[i+1] == '1', e = w[i+2] == '1';\n\t\t\t\t\tcan[i+2][j + (x || y)][k] = true;\n\t\t\t\t\tcan[i+2][j][k + (q || e)] = true;\n\t\t\t\t\tcan[i+1][j][k] = true;\n\t\t\t\t\tif (j) can[i+1][j-1][k + q] = true;\n\t\t\t\t\tif (k) can[i+1][j + x][k-1] = true;\n\t\t\t\t}\n\t}\n\t\n\tgetdp();\n//\tdp[n][n][0] = 1;\n//\tmakepf(n);\n//\tfor (int i = n-1;i >= 0;--i) {\n//\t\tfor (int j = i;j >= 0;--j) {\n//\t\t\tfor (int k = 0;k <= n;++k) {\n//\t\t\t\tint &A = dp[i][j][k];\n//\t\t\t\tint nc0 = k, nc1 = n - j - k;\n//\t\t\t\tint ec0 = nc0 - suf0[i], ec1 = nc1 - suf1[i];\n//\t\t\t\tif (nc0 > c0 || nc1 > c1 || w[i] == '0' && !k)\n//\t\t\t\t\tcontinue;\n//\t\t\t\tif (w[i] == '1') {\n//\t\t\t\t\tint lx = j+1, ly = k, rx = j+k+1, ry = 0;\n//\t\t\t\t\tfor (int d = 0;d <= k && j+d+1 <= n;++d)\n//\t\t\t\t\t\tadd(A, dp[i+1][j+d+1][k-d]);\n////\t\t\t\t\tadd(A, pf1[i+1][rx][ry]);\n////\t\t\t\t\tadd(A, p - G(pf1, i+1, lx-1, ly+1));\n//\t\t\t\t}\n//\t\t\t\telse {\n//\t\t\t\t\tint lx = j, rx = n;\n//\t\t\t\t\tassert(k);\n//\t\t\t\t\tfor (int d = 0;d + j + 1 <= n;++d)\n//\t\t\t\t\t\tadd(A, dp[i+1][j+d+1][k-1]);\n////\t\t\t\t\tadd(A, pf2[i+1][rx][k-1]);\n////\t\t\t\t\tadd(A, p - G(pf2, i+1, lx-1, k-1));\n//\t\t\t\t}\n//\t\t\t\t//printf(\"dp[%d][%d][%d] : %d len : %d\\n\", i, j, k, dp[i][j][k], nc0 + nc1);\n//\t\t\t}\n//\t\t}\n//\t\t//puts(\"------\");\n//\t\tmakepf(i);\n//\t}\n//\tfor (int i = 0;i <= n;++i)\n//\t\tfor (int j = 0;j <= i;++j)\n//\t\t\tfor (int k = 0;k <= n;++k) if (dp[i][j][k]) {\n//\t\t\t\tint &A = dp[i][j][k];\n//\t\t\t\tint nc0 = k, nc1 = n - j - k;\n//\t\t\t\tint ec0 = nc0 - suf0[i], ec1 = nc1 - suf1[i];\n//\t\t\t\tif (ec0 > GC(pc0, i-1) || ec1 > GC(pc1, i-1)) \n//\t\t\t\t\tcontinue;\n////\t\t\t\tint nc0 = k, nc1 = n - j - k, nowlen = n - j, uplen = n - i, gar = nowlen - uplen, coda = n - nowlen;\n////\t\t\t\tif (coda < gar) continue;\n////\t\t\t\tint ex = min(coda - gar >> 1, i==0?0: w[i-1] == '0' ? c1 - nc1 : c0 - nc0);\n////\t\t\t\t//ex = max(0, ex);\n////\t\t\t\tadd(res, dp[i][j][k] * (ex+1) % p);\n////\t\t\t\tprintf(\"dp[%d][%d][%d] : %d len : %d ex : %d\\n\", i, j, k, dp[i][j][k], nc0 + nc1, ex);\n//\t\t\t}\n//\tadd(res, p-1);\n\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> w;\n\tn = strlen(w);\n\tfor (int i = 0;i < n;++i)\n\t\tc0 += w[i] == '0', c1 += w[i] == '1';\n\tsolve();\n\tcout << res << '\\n'; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res + 1 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int mod=998244353;\nint add(int x,int y){x+=y;return x>=mod?x-mod:x;}\nint sub(int x,int y){x-=y;return x<0?x+mod:x;}\nint mul(int x,int y){return (ll)x*y%mod;}\nvoid ckadd(int&x,int y){x=add(x,y);}\nvoid cksub(int&x,int y){x=sub(x,y);}\nvoid ckmul(int&x,int y){x=mul(x,y);}\nconst int N=305;\nbool ok[N][N][N];\nint dp[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1);\n\tok[0][0][0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=n;~j;j--){\n\t\t\tfor(int k=n;~k;k--){\n\t\t\t\tif(!ok[i][j][k])continue;\n\t\t\t\tif(j+k>=2&&j)ok[i][j-1][k]=1;\n\t\t\t\tif(j+k>=2&&k)ok[i][j][k-1]=1;\n\t\t\t\tif(s[i+1]=='1'||s[i+2]=='1')ok[i+2][j][k+1]=1;\n\t\t\t\tif(s[i+1]=='0'||s[i+2]=='0')ok[i+2][j+1][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&k)ok[i+1][j][k]=1;\n\t\t\t\tif(s[i+1]=='1'&&j)ok[i+1][j-1][k+1]=1;\n\t\t\t\tif(s[i+1]=='0'&&k)ok[i+1][j+1][k-1]=1;\n\t\t\t\tif(s[i+1]=='0'&&j)ok[i+1][j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tdp[n+1][0][0]=1;\n\tfor(int i=n+1;i>=1;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(ok[i-1][j][k]||ok[i][j+(s[i]=='0')][k+(s[i]=='1')])ckadd(ans,dp[i][j][k]);\n\t\t\t\tckadd(dp[i-1][j][k],dp[i][j][k]);\n\t\t\t\tif(s[i-1]=='0')ckadd(dp[i][j][k+1],dp[i][j][k]);\n\t\t\t\telse ckadd(dp[i][j+1][k],dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%i\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// TLE解\n\n#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nint tes(string s, string t) {\n\tvector<int> v;\n\tREP(i, 0, s.size()) v.push_back(0);\n\tREP(j, 0, t.size()) v.push_back(1);\n\n\tset<string> st;\n\tdo {\n\t\tint p = 0;\n\t\tint q = 0;\n\n\t\tstring r;\n\t\tREP(k, 0, v.size()) {\n\t\t\tif (v[k] == 0) {\n\t\t\t\tr += s[p];\n\t\t\t\t++p;\n\t\t\t} else {\n\t\t\t\tr += t[q];\n\t\t\t\t++q;\n\t\t\t}\n\t\t}\n\t\tst.insert(r);\n\t} while (next_permutation(v.begin(), v.end()));\n\treturn st.size();\n}\n\n\nusing M9 = IntMod<998244353>;\n\nstring S;\nbool DP[301][301][301];\nM9 EP[301][301][301];\nM9 EQ[301][301][301];\nvoid pre() {\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\tint N = T.size();\n\n\tEP[0][0][0] = 1;\n\tREP(i, 1, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (T[i - 1] == '0') {\n\t\t\t\t\tREP(dk, 0, k + 1) {\n\t\t\t\t\t\tEP[i][j][k] += EP[i - 1][j][k - dk];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tREP(dj, 0, j + 1) {\n\t\t\t\t\t\tEP[i][j][k] += EP[i - 1][j - dj][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nM9 sub(int i, int j, int k) {\n\tM9 sum = 0;\n\tREP(dj, 0, j + 1) {\n\t\tREP(dk, 0, k + 1) {\n\t\t\tsum += EP[i][j - dj][k - dk] * M9::combi(dj + dk, dj);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin >> S;\n\tpre();\n\n\tint N = S.size();\n\tDP[0][0][0] = true;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (i + 1 < N) {\n\t\t\t\t\tif (S[i] == '0' || S[i + 1] == '0') DP[i + 2][j + 1][k] |= DP[i][j][k];\n\t\t\t\t\tif (S[i] == '1' || S[i + 1] == '1') DP[i + 2][j][k + 1] |= DP[i][j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 0 && S[i] == '1') DP[i + 1][j - 1][k + 1] |= DP[i][j][k];\n\t\t\t\tif (k > 0 && S[i] == '0') DP[i + 1][j + 1][k - 1] |= DP[i][j][k];\n\t\t\t\tif (j + k > 0) DP[i + 1][j][k] |= DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tM9 sum = 0;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (!DP[i][j][k]) continue;\n\t\t\t\tif (S[i] == '0' && DP[i + 1][j + 1][k]) continue;\n\t\t\t\tif (S[i] == '1' && DP[i + 1][j][k + 1]) continue;\n\t\t\t\tsum += sub(N - i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 301, md = 998244353;\n\nchar s[MX];\nint dp[MX][MX][MX], f[MX][MX][MX];\n\nvoid upd(int e0, int e1, int f0, int f1) {\n\tint& val = dp[e0][e1][f0];\n\tval = max(val, f1);\n}\n\nint main() {\n\tignore = scanf(\"%s\", s);\n\t\n\tint n = strlen(s);\n\t\n\tmemset(dp, -1, sizeof dp);\n\t\n\tdp[0][0][0] = 0;\n\tfor (int e0 = 0; e0 < MX; e0++)\n\t\tfor (int e1 = 0; e1 < MX; e1++)\n\t\t\tfor (int f0 = 0; f0 < MX; f0++) {\n\t\t\t\tif (dp[e0][e1][f0] == -1) continue;\n\t\t\t\t\n\t\t\t\tint f1 = dp[e0][e1][f0];\n\t\t\t\t\n\t\t\t\t// both free\n\t\t\t\tif (f0 + f1 >= 2) {\n\t\t\t\t\tif (f0 > 0) upd(e0 + 1, e1, f0 - 1, f1);\n\t\t\t\t\tif (f1 > 0) upd(e0, e1 + 1, f0, f1 - 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// both fixed\n\t\t\t\tif (e0 + e1 + f0 + f1 + 1 < n) {\n\t\t\t\t\tint x = s[e0 + e1 + f0 + f1] - '0';\n\t\t\t\t\tint y = s[e0 + e1 + f0 + f1 + 1] - '0';\n\t\t\t\t\t\n\t\t\t\t\tif (x != y) {\n\t\t\t\t\t\tupd(e0 + 1, e1, f0, f1 + 1);\n\t\t\t\t\t\tupd(e0, e1 + 1, f0 + 1, f1);\n\t\t\t\t\t}\n\t\t\t\t\telse if (x == 0) {\n\t\t\t\t\t\tupd(e0 + 1, e1, f0 + 1, f1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tupd(e0, e1 + 1, f0, f1 + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// one free, one fixed\n\t\t\t\tif (f0 + f1 > 0 && e0 + e1 + f0 + f1 < n) {\n\t\t\t\t\tint x = s[e0 + e1 + f0 + f1] - '0';\n\t\t\t\t\t\n\t\t\t\t\tif (x == 0) {\n\t\t\t\t\t\tupd(e0 + 1, e1, f0, f1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (f1 > 0) upd(e0, e1 + 1, f0 + 1, f1 - 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tupd(e0, e1 + 1, f0, f1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (f0 > 0) upd(e0 + 1, e1, f0 - 1, f1 + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\tint ans = 0;\n\tfor (int e0 = 0; e0 < MX; e0++)\n\t\tfor (int e1 = 0; e1 < MX; e1++) {\n\t\t\tint f0 = -1, f1 = -1;\n\t\t\tfor (int x0 = 0; x0 < MX; x0++) {\n\t\t\t\tint x1 = dp[e0][e1][x0];\n\t\t\t\tif (x1 != -1 && x0 + x1 > f0 + f1) {\n\t\t\t\t\tf0 = x0;\n\t\t\t\t\tf1 = x1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f0 == -1) continue;\n\t\t\t\n\t\t\tint k = e0 + e1 + f0 + f1;\n\t\t\t\n\t\t\tf[k][f0][f1]++;\n\t\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int x = n; x >= 0; x--)\n\t\t\tfor (int y = n; y >= 0; y--) {\n\t\t\t\tf[i + 1][x][y] += f[i][x][y];\n\t\t\t\tf[i + 1][x][y] %= md;\n\t\t\t\t\n\t\t\t\tif (s[i] == '0' && y > 0) {\n\t\t\t\t\tf[i][x][y - 1] += f[i][x][y];\n\t\t\t\t\tf[i][x][y - 1] %= md;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (s[i] == '1' && x > 0) {\n\t\t\t\t\tf[i][x - 1][y] += f[i][x][y];\n\t\t\t\t\tf[i][x - 1][y] %= md;\n\t\t\t\t}\n\t\t\t}\n\t\n\tfor (int x = n; x >= 0; x--)\n\t\tfor (int y = n; y >= 0; y--) {\n\t\t\tif (x > 0) {\n\t\t\t\tf[n][x - 1][y] += f[n][x][y];\n\t\t\t\tf[n][x - 1][y] %= md;\n\t\t\t}\n\t\t\t\n\t\t\tif (y > 0) {\n\t\t\t\tf[n][x][y - 1] += f[n][x][y];\n\t\t\t\tf[n][x][y - 1] %= md;\n\t\t\t}\n\t\t}\n\t\n\tprintf(\"%d\\n\", f[n][0][0]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=305,mod=998244353;\nint n,aa,bb,p[2][N];\nchar s[N];\nint dp[N][N][N];\nbool f[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    for(int i=1;i<=n;i++) p[0][i]=p[0][i-1]+(s[i]=='0'),p[1][i]=p[1][i-1]+(s[i]=='1');\n    f[0][0][0]=true;\n    for(int k=0;k<=n;k++)\n        for(int i=p[1][k];i>=0;i--)\n        for(int j=p[0][k];j>=0;j--)\n    {\n        f[k+1][i][j]|=f[k][i][j];\n        if(i>0) f[k][i-1][j]|=f[k][i][j];\n        if(j>0) f[k][i][j-1]|=f[k][i][j];\n        if(i>0&&k+1<=n&&s[k+1]=='0')\n            f[k+1][i-1][j+1]|=f[k][i][j];\n        if(j>0&&k+1<=n&&s[k+1]=='1')\n            f[k+1][i+1][j-1]|=f[i][j][i];\n        if(k+2<=n)\n        {\n            if(s[k+1]=='1'||s[k+2]=='1')\n                f[k+2][i+1][j]|=f[k][i][j];\n            if(s[k+1]=='0'||s[k+2]=='0')\n                f[k+2][i][j+1]|=f[k][i][j];\n        }\n    }\n    dp[n+1][0][0]=1;\n    ll ans=0;\n    for(int k=n+1;k>=1;k--)\n        for(int i=0;i<=p[1][k-1];i++)\n        for(int j=0;j<=p[0][k-1];j++)\n    {\n        if(f[k-1][i][j])\n            ans=(ans+dp[k][i][j])%mod;\n        if(s[k-1]=='0')\n        {\n            if(f[k-1][i+1][j])\n                dp[k][i+1][j]=(dp[k][i+1][j]+dp[k][i][j])%mod;\n            if(f[k-2][i][j])\n                dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n        }\n        else\n        {\n            if(f[k-1][i][j+1])\n                dp[k][i][j+1]=(dp[k][i][j+1]+dp[k][i][j])%mod;\n            if(f[k-2][i][j])\n                dp[k-1][i][j]=(dp[k-1][i][j]+dp[k][i][j])%mod;\n        }\n    }\n    ans=(ans+mod-1)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nstring S;\nint N;\nconst ll mo=998244353;\n\nll dp[303][303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S;\n\tN=S.size();\n\t\n\tdp[0][0][0]=1;\n\tFOR(i,N) {\n\t\tFOR(x,N) FOR(y,N) if(dp[i][x][y]) {\n\t\t\tif(x) {\n\t\t\t\tdp[i+1][x][y]=1;\n\t\t\t\tif(S[i]=='1') dp[i+1][x-1][y+1]=1;\n\t\t\t}\n\t\t\tif(y) {\n\t\t\t\tdp[i+1][x][y]=1;\n\t\t\t\tif(S[i]=='0') dp[i+1][x+1][y-1]=1;\n\t\t\t}\n\t\t\tif(i+2<=N) {\n\t\t\t\tif(S[i]=='0') dp[i+2][x+1][y]=1;\n\t\t\t\telse dp[i+2][x][y+1]=1;\n\t\t\t\tif(S[i+1]=='0') dp[i+2][x+1][y]=1;\n\t\t\t\telse dp[i+2][x][y+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=N;i>=0;i--) {\n\t\tFOR(x,N) FOR(y,N) if(dp[i][x][y]) {\n\t\t\tint a=x,b=y;\n\t\t\tfor(j=i-1;j>=0;j--) {\n\t\t\t\tif(S[j]=='0') a--;\n\t\t\t\telse b--;\n\t\t\t\tif(a>=0 && b>=0) dp[j][a][b]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFOR(i,N) {\n\t\tif(S[i]=='0') {\n\t\t\tFOR(y,N+1) for(x=N;x>=1;x--) (dp[i][y][x-1]+=dp[i][y][x])%=mo;\n\t\t}\n\t\telse {\n\t\t\tFOR(y,N+1) for(x=N;x>=1;x--) (dp[i][x-1][y]+=dp[i][x][y])%=mo;\n\t\t}\n\t\tFOR(y,N+1) {\n\t\t\tFOR(x,N+1) (dp[i+1][x][y]+=dp[i][x][y])%=mo;\n\t\t}\n\t}\n\tfor(int t=N;t>=0;t--) FOR(x,t+1) {\n\t\ty=t-x;\n\t\tif(x) (dp[N][x-1][y]+=dp[N][x][y])%=mo;\n\t\tif(y) (dp[N][x][y-1]+=dp[N][x][y])%=mo;\n\t\t\n\t}\n\tcout<<dp[N][0][0]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\nusing namespace std;\nconst int N=405,P=998244353;\nvoid upd(int&a,int b){ a=a+b>=P?a+b-P:a+b; }\nchar s[N]; \nint ans,n,f[N][N][N],g[N][N][N]; \nint main(int argc,char *argv[]){\n\tscanf(\"%s\",s+1); \n\tn=strlen(s+1); \n\tf[0][0][0]=1;\n\trep(i,0,n)rep(j,0,i)rep(k,0,i)if(f[i][j][k]){\n\t\tint c0=(s[i+1]=='0')+(s[i+2]=='0'); \n\t\tint c1=(s[i+1]=='1')+(s[i+2]=='1'); \n\t\tif(i+2<=n&&c0)f[i+2][j+1][k]|=f[i][j][k]; \n\t\tif(i+1<=n&&s[i+1]=='1'&&j>=1)f[i+1][j-1][k+1]|=f[i][j][k];\n\t\tif(i+2<=n&&c1)f[i+2][j][k+1]|=f[i][j][k];\n\t\tif(i+1<=n&&s[i+1]=='0'&&k>=1)f[i+1][j+1][k-1]|=f[i][j][k];\n\t\tf[i+1][j][k]|=f[i][j][k];\n\t}\n\tg[n+1][0][0]=1;\n\tdec(i,n+1,1)rep(j,0,n)rep(k,0,n-j){\n\t\tif(s[i-1]=='0'){\n\t\t\tupd(g[i-1][j][k],g[i][j][k]);\n\t\t\tupd(g[i][j][k+1],g[i][j][k]); \n\t\t}else{\n\t\t\tupd(g[i][j+1][k],g[i][j][k]); \n\t\t\tupd(g[i-1][j][k],g[i][j][k]); \n\t\t}\n\t\tif(f[i-1][j][k]&&g[i][j][k])upd(ans,g[i][j][k]);\n\t}\n\tprintf(\"%d\\n\",(ans-1+P)%P); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\nconst int P = 998244353;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nchar s[MAXN]; int n;\nint dp[MAXN][MAXN][MAXN];\nint vis[MAXN][MAXN][MAXN];\nbool res[MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nbool check(int x, int y, int z) {\n\treturn res[x][y][z];\n}\nint main() {\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), dp[n][0][0] = 1;\n\tfor (int i = n; i >= 1; i--)\n\tfor (int j = 0; j + (n - i) <= n - 1; j++)\n\tfor (int k = 0; j + k + (n - i) <= n - 1; k++)\n\t\tif (s[i] == '0') {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j][k + 1], dp[i][j][k]);\n\t\t} else {\n\t\t\tupdate(dp[i - 1][j][k], dp[i][j][k]);\n\t\t\tupdate(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\tmemset(vis, -1, sizeof(vis));\n\tvis[0][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j <= i / 2; j++)\n\tfor (int k = 0; j + k <= i / 2; k++) {\n\t\tif (vis[i][j][k] == -1) continue;\n\t\tint tmp = vis[i][j][k];\n\t\tif (i + 1 <= n && tmp != 0) {\n\t\t\tif (s[i + 1] == '0') chkmax(vis[i + 1][j + 1][k], tmp - 1);\n\t\t\tif (s[i + 1] == '1') chkmax(vis[i + 1][j][k + 1], tmp - 1);\n\t\t}\n\t\tif (i + 2 <= n) {\n\t\t\tif (s[i + 1] == '0' || s[i + 2] == '0') chkmax(vis[i + 2][j + 1][k], tmp);\n\t\t\tif (s[i + 1] == '1' || s[i + 2] == '1') chkmax(vis[i + 2][j][k + 1], tmp);\n\t\t\tchkmax(vis[i + 2][j][k], tmp + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = n; j >= 0; j--)\n\tfor (int k = n; k >= 0; k--) {\n\t\tres[i][j][k] = vis[i][j][k] != -1;\n\t\tif (i != 0) res[i][j][k] |= res[i - 1][j][k];\n\t\tres[i][j][k] |= res[i][j + 1][k];\n\t\tres[i][j][k] |= res[i][j][k + 1];\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = 0; j + (n - i) <= n; j++)\n\tfor (int k = 0; j + k + (n - i) <= n; k++)\n\t\tif (dp[i][j][k] && (n - i) + j + k != 0) {\n\t\t\tif (check(i, j, k)) {\n\t\t\t\tupdate(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=305;\nconst int mod=998244353;\nint n,ans;\nchar s[maxn];\nbool f[maxn][maxn][maxn];\nint g[maxn][maxn][maxn],suf[maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%s\",s);n=strlen(s);\n\tf[0][0][0]=true;\n\tfor(int i=0;i<n;i++)for(int j=n;j>=0;j--)for(int k=n;k>=0;k--)if(f[i][j][k]){\n\t\tif(i+1<n){\n\t\t\tif(s[i]=='0'||s[i+1]=='0')f[i+2][j+1][k]=true;\n\t\t\tif(s[i]=='1'||s[i+1]=='1')f[i+2][j][k+1]=true;\n\t\t}\n\t\tif(j+k>=2){\n\t\t\tif(j)f[i][j-1][k]=true;\n\t\t\tif(k)f[i][j][k-1]=true;\n\t\t}\n\t\tif(j+k>=1){\n\t\t\tf[i+1][j][k]=true;\n\t\t\tif(s[i]=='0'&&k)f[i+1][j+1][k-1]=true;\n\t\t\tif(s[i]=='1'&&j)f[i+1][j-1][k+1]=true;\n\t\t}\n\t}\n\tg[0][0][n]=1;\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++)for(int i=n;i>=0;i--)if(g[j][k][i]){\n\t\tAdd(g[j+1][k][i-(i>0&&s[i-1]=='0')],g[j][k][i]);\n\t\tAdd(g[j][k+1][i-(i>0&&s[i-1]=='1')],g[j][k][i]);\n\t}\n\tsuf[n]=0;\n\tfor(int i=n-1;i>=0;i--)suf[i]=suf[i+1]+(s[i]=='1');\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint cj=j-(n-i-suf[i]),ck=k-suf[i];\n\t\t\tif(cj>=0&&ck>=0&&(f[i][cj][ck]||(i<n&&f[i][cj+1][ck])||(i<n&&f[i][cj][ck+1])||(i==1&&i<n&&cj==0&&ck==0)))\n\t\t\t\tAdd(ans,g[j][k][i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tassert(s.size() >= 10);\n\tint n = s.size();\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\t\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\t/*\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\t\tstd::cerr << \"at \" << i << \" w:\" << j << \" b:\" << k << \" \" << std::endl;\n\t\t\t}\n\t\t}*/\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\t// white\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nnamespace my_std {\nusing namespace std;\n#define reg register\n#define Rint register int\n#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)\n#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)\ntypedef long long i64;\n#define Templ(T) template <typename T>\nTempl(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }\nTempl(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }\nconst int mod = 998244353;\ninline void inc(int &x, const int &y) { x += y; if (x >= mod) x -= mod; }\ninline void dec(int &x, const int &y) { x -= y; if (x < 0) x += mod; }\n} // namespace my_std\nusing namespace my_std;\n\n#define N 350\nchar s[N];\nint n;\nint dp[N][N][N];\nbool tr[N][N][N];\n//[i][c0][c1]: 剩下 i 个字符没有匹配，多了 c0 个 0 和 c1 个 1\n\nint main() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    tr[0][0][0] = 1;\n    FOR(i, 1, n){\n        ROF(c0, n, 0) ROF(c1, n, 0){\n            if(i == n && !c0 && !c1) continue;\n            tr[i][c0][c1] |= tr[i - 1][c0][c1];\n            if(s[i] == 48) tr[i][c0][c1] |= tr[i][c0][c1 + 1];\n            if(s[i] == 49) tr[i][c0][c1] |= tr[i][c0 + 1][c1];\n            //删掉两个把第二个加回原来位置\n            //加回去的可能还是多出来的字符\n        }\n        if(i > 1) FOR(c0, 0, n) FOR(c1, 0, n){\n            if((s[i - 1] == 48 || s[i] == 48) && c0){\n                tr[i][c0][c1] |= tr[i - 2][c0 - 1][c1];\n                //前面两个都不是多余的，把'0'扔到多余的位置\n            }\n            if(s[i - 1] == 48 && s[i] == 48 && c0){\n                tr[i][c0][c1] |= tr[i - 1][c0 - 1][c1 + 1];\n                //前面是\"10\"（'1'是多余的），并把'0'扔到多余的位置\n            }\n            if((s[i - 1] == 49 || s[i] == 49) && c1){\n                tr[i][c0][c1] |= tr[i - 2][c0][c1 - 1];\n                //前面两个都不是多余的，把'1'扔到多余的位置\n            }\n            if(s[i - 1] == 49 && s[i] == 49 && c1){\n                tr[i][c0][c1] |= tr[i - 1][c0 + 1][c1 - 1];\n                //前面是\"01\"（'0'是多余的），并把'1'扔到多余的位置\n            }\n        }\n    }\n    dp[n][0][0] = 1;\n    ROF(i, n, 1){\n        FOR(c0, 0, n) FOR(c1, 0, n){\n            Rint t(dp[i][c0][c1]);\n            inc(dp[i - 1][c0][c1], t);\n            if(s[i] == 48) inc(dp[i][c0][c1 + 1], t);\n            if(s[i] == 49) inc(dp[i][c0 + 1][c1], t);\n        }\n    }\n    Rint ans(0);\n    FOR(i, 0, n){\n        FOR(c0, 0, i) FOR(c1, 0, i){\n            if(tr[i][c0][c1]) inc(ans, dp[i][c0][c1]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n#include <cstring>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nconst int ms = 303;\nconst int MOD = 998244353;\n\nstd::string str;\nint n;\nbool vis[ms][ms][ms];\nint memo[ms][ms][ms];\nint bst[ms][ms];\nint sum[ms][2];\n\nvoid go(int on, int zero, int one, int turn) {\n\tif(vis[on][zero][turn]) return;\n\tvis[on][zero][turn] = true;\n\t//std::cout << \"visiting \" << on << \", \" << zero << \", \" << one << \", \" << turn << \"\\n\";\n\tmemo[on][zero][turn] = one;\n\tif(turn + 1 == (int) str.size()) return;\n\tif(zero >= 2) go(on, zero-1, one, turn+1);\n\tif(one >= 2) go(on, zero, one-1, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero-1, one, turn+1);\n\tif(zero >= 1 && one >= 1) go(on, zero, one-1, turn+1);\n\tif(on < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tif(zero >= 1) go(on+1, zero-1+(1-nxt), one+nxt, turn+1);\n\t\tif(one >= 1) go(on+1, zero+(1-nxt), one+nxt-1, turn+1);\n\t}\n\tif(on+1 < (int) str.size()) {\n\t\tint nxt = str[on] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t\tnxt = str[on+1] - '0';\n\t\tgo(on+2, zero+(1-nxt), one+nxt, turn+1);\n\t}\n}\n\nint dp(int on, int zero, int one) {\n\tif(zero < 0 || one < 0) return 0;\n\tif(on == n && zero == 0 && one == 0) return 1;\n\tint &ans = memo[on][zero][one];\n\tif(ans != -1) return ans;\n\tans = 0;\n\tif(on == n) {\n\t\tans = (dp(on, zero-1, one) + dp(on, zero, one-1)) % MOD;\n\t} else if(str[on] == '0') {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero, one-1)) % MOD;\n\t} else {\n\t\tans = (dp(on+1, zero, one) + dp(on, zero-1, one)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tstd::cin >> str;\n\tn = (int) str.size();\n\tgo(0, 0, 0, 0);\n\tfor(int i = n-1; i >= 0; i--) {\n\t\tsum[i][0] = sum[i+1][0];\n\t\tsum[i][1] = sum[i+1][1];\n\t\tif(str[i] == '0') sum[i][0]++;\n\t\telse sum[i][1]++;\n\t}\n\tmemset(bst, -1, sizeof bst);\n\tfor(int on = 0; on < ms; on++) {\n\t\tfor(int zero = 0; zero < ms; zero++) {\n\t\t\tfor(int turn = 0; turn < ms; turn++) {\n\t\t\t\tif(!vis[on][zero][turn]) continue;\n\t\t\t\tint one = memo[on][zero][turn];\n\t\t\t\tint f[2] = {zero + sum[on][0], one + sum[on][1]};\n\t\t\t\tbst[f[0]][f[1]] = std::max(bst[f[0]][f[1]], on);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo, -1, sizeof memo);\n\tint ans = 0;\n\tfor(int zero = 0; zero < ms; zero++) {\n\t\tfor(int one = 0; one < ms; one++) {\n\t\t\tif(bst[zero][one] < 0) continue;\n\t\t\tint on = bst[zero][one];\n\t\t\t//std::cout << \"best for \" << zero << \", \" << one << \" is \" << on << \", got \" << dp(on, zero - sum[on][0], one - sum[on][1]) << '\\n';\n\t\t\tans = (ans + dp(on, zero - sum[on][0], one - sum[on][1])) % MOD;\n\t\t}\n\t}\n\tstd::cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> V) {\n os << \"[ \"; for(auto v : V) os << v << \" \"; return os << \"]\";}\ntemplate<class L, class R> ostream& operator<<(ostream &os, pair<L,R> P) {\n\treturn os << \"(\" << P.first << \",\" << P.second << \")\";}\n\n#define TRACE\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcout << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...) 1\n#endif\n\n\n#define ll long long\n#define ld long double\n#define vll vector<ll>\n#define pll pair<ll,ll>\n#define vpll vector<pll>\n#define I insert \n#define pb push_back\n#define F first\n#define S second\n#define endl \"\\n\"\n#define vi vector<int>\n#define pii pair<int, int>\n#define vpii vector< pii >\n\n\nconst int mod=998244353;\ninline int mul(int a,int b){return (a*1ll*b)%mod;}\ninline int add(int a,int b){a+=b;if(a>=mod)a-=mod;return a;}\ninline int sub(int a,int b){a-=b;if(a<0)a+=mod;return a;}\ninline int power(int a,int b){int rt=1;while(b>0){if(b&1)rt=mul(rt,a);a=mul(a,a);b>>=1;}return rt;}\ninline int inv(int a){return power(a,mod-2);}\ninline void modadd(int &a,int &b){a+=b;if(a>=mod)a-=mod;} \n\nconst int M = 302;\n\nint dp[M][M][M];\nstring s; \nint n;\n\nint dp1[M][M][M];\nint pos[2][M];\n\n\nvoid pre(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=n;k>=0;k--){\n\t\t\t\tint &cur = dp[i][j][k];\n\t\t\t\tcur = 0 ;\n\t\t\t\tif(k==n && i==0 && j==0){ cur = 1; continue; }\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k+1]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k]);\n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) cur = add(cur, dp[i-1][j][k]);\n\t\t\t\t\tif(j>0) cur = add(cur, dp[i][j-1][k+1]);\n\t\t\t\t}\n\n\t\t\t\t// trace(i, j, k, dp[i][j][k]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tpos[0][n] = pos[1][n] = 0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tpos[0][i] = pos[0][i+1];\n\t\tpos[1][i] = pos[1][i+1];\n\t\tif(s[i]=='0') pos[0][i]++;\n\t\telse pos[1][i]++;\n\t}\n\n\n}\n\nint mc[M][M];\n\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);cout<<setprecision(25);\n\tcin>>s;\n\tn = s.length();\n\tpre();\n\tdp1[0][0][0] = 1;\n\tint ans = 0;\n\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmc[i][j] = -1;\n\t\t}\n\t}\n\n\tfor(int rem=n;rem>=0;rem--){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tint k = rem - (i+j); if(k<0) continue;\n\t\t\t\tk = n - k;\n\t\t\t\tint i1 = i + pos[0][k];\n\t\t\t\tint j1 = j + pos[1][k];\n\t\t\t\tif(dp1[i][j][k]==0) continue;\n\t\t\t\t\n\t\t\t// for(int k=0;k<=n;k++){\n\t\t\t\tmc[i1][j1] = max(mc[i1][j1], k);\n\n\n\t\t\t\tif(k==n){\n\t\t\t\t\tif(i>0) dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0) dp1[i][j-1][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\tif(i+j >= 2){\n\t\t\t\t\tif(i>0)dp1[i-1][j][k] = 1;\n\t\t\t\t\tif(j>0)dp1[i][j-1][k] = 1; \n\t\t\t\t}\n\n\t\t\t\tif(s[k]=='0'){\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(j>0) dp1[i+1][j-1][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(s[k]=='1'){\n\t\t\t\t\tif(i>0) dp1[i-1][j+1][k+1] = 1;\n\t\t\t\t\tif(i>0 || j>0) dp1[i][j][k+1] = 1;\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='1'){\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(k!=n-1 && s[k+1]=='0'){\n\t\t\t\t\t\tdp1[i+1][j][k+2] = 1;\n\t\t\t\t\t\tdp1[i][j+1][k+2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// int ans = 0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n-i;j++){\n\t\t\tif(mc[i][j]>=0 && i<=pos[0][0] && j<=pos[1][0]){\n\t\t\t\tans = add(ans, dp[i][j][mc[i][j]]);\n\t\t\t\t// trace(i, j, mc[i][j], dp[i][j][mc[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tans = sub(ans, 1);\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate <typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate <typename V, typename T> void ndfill(V &x, const T &val) { x = val; }\ntemplate <typename V, typename T> void ndfill(vector<V> &vec, const T &val) { for (auto &v : vec) ndfill(v, val); }\ntemplate <typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate <typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate <typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate <typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate <typename T> vector<T> srtunq(vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T> &vec) { os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec) { os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T> &vec) { os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec) { os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa) { os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp) { os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate <typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp) { os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static std::vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n\n    ModInt doublefac() const {\n        lint k = (this->val + 1) / 2;\n        if (this->val & 1) return ModInt(k * 2).fac() / ModInt(2).power(k) / ModInt(k).fac();\n        else return ModInt(k).fac() * ModInt(2).power(k);\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n\n    ModInt sqrt() const {\n        if (val == 0) return 0;\n        if (mod == 2) return val;\n        if (power((mod - 1) / 2) != 1) return 0;\n        ModInt b = 1;\n        while (b.power((mod - 1) / 2) == 1) b += 1;\n        int e = 0, m = mod - 1;\n        while (m % 2 == 0) m >>= 1, e++;\n        ModInt x = power((m - 1) / 2), y = (*this) * x * x;\n        x *= (*this);\n        ModInt z = b.power(m);\n        while (y != 1) {\n            int j = 0;\n            ModInt t = y;\n            while (t != 1) j++, t *= t;\n            z = z.power(1LL << (e - j - 1));\n            x *= z, z *= z, y *= z;\n            e = j;\n        }\n        return ModInt(std::min(x.val, mod - x.val));\n    }\n};\nconstexpr lint MOD = 998244353;\nusing mint = ModInt<MOD>;\n\nint main()\n{\n    string S;\n    cin >> S;\n    int N = S.length();\n    vector<vector<vector<int>>> dp;\n    ndarray(dp, N + 1, N + 1, N + 1); // dp[i][j][k]: [そのままが残りi文字][自由0個数][自由1個数]\n    dp[N][0][0] = 1;\n    IREP(i, N + 1)\n    {\n        REP(j, N + 1) REP(k, N + 1) if (dp[i][j][k])\n        {\n            if (i > 0)\n            {\n                char c = S[N - i];\n                if (j or k)\n                {\n                    dp[i - 1][j][k] = 1;\n                }\n                if (j) dp[i - 1][j - 1 + (c == '0')][k + (c == '1')] = 1;\n                if (k) dp[i - 1][j + (c == '0')][k - 1 + (c == '1')] = 1;\n\n                if (i > 1)\n                {\n                    char c2 = S[N - i + 1];\n                    dp[i - 2][j + (c == '0')][k + (c == '1')] = 1;\n                    dp[i - 2][j + (c2 == '0')][k + (c2 == '1')] = 1;\n                }\n            }\n        }\n    }\n    constexpr int INF = 1e9;\n    vector<vector<int>> fixlen(N + 1, vector<int>(N + 1, INF));\n\n    vector<int> acc0(N + 1), acc1(N + 1);\n    REP(i, N) acc0[i + 1] = acc0[i] + (S[i] == '0');\n    REP(i, N) acc1[i + 1] = acc1[i] + (S[i] == '1');\n\n    REP(i, dp.size()) REP(j, dp[i].size()) REP(k, dp[i][j].size()) if (dp[i][j][k])\n    {\n        int n0 = acc0[N] - acc0[N - i] + j;\n        int n1 = acc1[N] - acc1[N - i] + k;\n        chmin(fixlen[n0][n1], i);\n    }\n\n    vector<vector<vector<mint>>> dp2; // dp[Sと後ろからちょうどi文字マッチ][0をj回使用][1をk回使用]\n    ndarray(dp2, N + 2, N + 2, N + 2);\n    dp2[0][0][0] = 1;\n    REP(i, N)\n    {\n        REP(j, N + 1) REP(k, N + 1) if (j + k < N)\n        {\n            dp2[i + (S[N - i - 1] == '0')][j + 1][k] += dp2[i][j][k];\n            dp2[i + (S[N - i - 1] == '1')][j][k + 1] += dp2[i][j][k];\n        }\n    }\n\n    IREP(i, N) REP(j, N + 1) REP(k, N + 1) dp2[i][j][k] += dp2[i + 1][j][k];\n\n    mint ret = 0;\n    REP(i, N + 1) REP(j, N + 1) if (fixlen[i][j] < INF)\n    {\n        ret += dp2[fixlen[i][j]][i][j];\n        // if (N <= 4)\n        // {\n        //     dbg((vector<int>{i, j, fixlen[i][j]}));\n        // }\n    }\n    cout << ret << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define mod 998244353\n#define pl(a,b) a=(a+b)%mod;\n#define N 310\n\nstring s;\nll n;\nll f[N][N][N];\nvoid calcf(){\n\trep(i,N)rep(x,N)rep(y,N)f[i][x][y]=0;\n\tf[0][0][0]=1;\n\tfor(ll i=0;i<=n;i++)for(ll x=0;x<=n;x++)for(ll y=0;y<=n;y++){\n\t\tif(i+x+y>n)continue;\n\t\tif(i+1<=n){\n\t\t\tpl(f[i+1][x][y],f[i][x][y]);\n\t\t\tif(s[n-1-i]=='0')pl(f[i][x][y+1],f[i][x][y]);\n\t\t\tif(s[n-1-i]=='1')pl(f[i][x+1][y],f[i][x][y]);\n\t\t}\n\t\telse{\n\t\t\tpl(f[i][x+1][y],f[i][x][y]);\n\t\t\tpl(f[i][x][y+1],f[i][x][y]);\n\t\t}\n\t}\n}\n\nbool dp[N][N][N];\nvoid calcdp(){\n\tll ans=-1;\n\trep(i,N)rep(x,N)rep(y,N)dp[i][x][y]=0;\n\tdp[0][0][0]=1;\n\tfor(ll i=0;i<=n;i++)for(ll x=0;x<=n;x++)for(ll y=0;y<=n;y++){\n\t\tif(n-i+x+y>n)continue;\n\t\tif(dp[i][x][y]==0)continue;\n\t\tpl(ans,f[n-i][x][y]);\n\t\tif(x-1>=0)dp[i][x-1][y]=1;\n\t\tif(y-1>=0)dp[i][x][y-1]=1;\n\t\tif(i+1<=n){\n\t\t\tdp[i+1][x][y]=1;\n\t\t\tif(s[i]=='0'&&y-1>=0)dp[i+1][x+1][y-1]=1;\n\t\t\tif(s[i]=='1'&&x-1>=0)dp[i+1][x-1][y+1]=1;\n\t\t}\n\t\tif(i+2<=n){\n\t\t\trep(r,2){\n\t\t\t\tbool th=0;\n\t\t\t\trep(e,2)if(s[i+e]=='0'+r)th=1;\n\t\t\t\tif(th){\n\t\t\t\t\tif(r==0)dp[i+2][x+1][y]=1;\n\t\t\t\t\tif(r==1)dp[i+2][x][y+1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tcalcf();\n\tcalcdp();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nunordered_set<long long> chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tlong long u = 0;\n\tu *= L + 1; u += i;\n\tu *= L + 1; u += z;\n\tu *= L + 1; u += o;\n\tu *= L + 1; u += f;\n\tif (chk[L - i + z + o + f].count(u)) return;\n\tchk[L - i + z + o + f].insert(u);\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\telse if (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\telse if (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint s[303], e[303];\n\t\tmemset(s, 0x7f, sizeof(s));\n\t\tmemset(e, -1, sizeof(e));\n\t\tfor (auto t : chk[l]){\n\t\t\tint f = t % (L + 1); t /= L + 1;\n\t\t\tint o = t % (L + 1); t /= L + 1;\n\t\t\tint z = t % (L + 1); t /= L + 1;\n\t\t\tint i = t % (L + 1); t /= L + 1;\n\n\t\t\ts[i] = min(s[i], z);\n\t\t\te[i] = max(e[i], z + f);\n\t\t}\n\n\t\tfor (int i = 0; i <= L; i++){\n\t\t\tif (e[i] != -1){\n\t\t\t\tfor (int j = s[i]; j <= e[i]; j++) pin[j + zc[i]] = i;\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\nusing namespace chrono;\n\n#ifdef DEBUG\n\t#define LOCAL_INPUT_FILE\n#else\n\t//~ #define USE_FILE_IO\n#endif\n\n#ifdef USE_FILE_IO\n\t#define INPUT_FILE \"input.txt\"\n\t#define OUTPUT_FILE \"output.txt\"\n\t#define cin ____cin\n\t#define cout ____cout\n\tifstream cin(INPUT_FILE);\n\tofstream cout(OUTPUT_FILE);\n#else\n\t#ifdef LOCAL_INPUT_FILE\n\t\t#define cin ____cin\n\t\tifstream cin(\"input.txt\");\n\t#endif\n#endif\n\nconst int infinity = (int)1e9 + 42;\nconst int64_t llInfinity = (int64_t)1e18 + 256;\nconst int module = (int)1e9 + 7; \nconst long double eps = 1e-8;\n\nmt19937_64 randGen(system_clock().now().time_since_epoch().count());\n\ninline void raiseError(string errorCode) {\n\tcerr << \"Error : \" << errorCode << endl;\n\texit(42);\n}\n\nsigned main() {\n\t#ifndef USE_FILE_IO\n\t\tios_base::sync_with_stdio(false);\n\t#endif\n\t\n\tconst int mod = 998'244'353;\n\t\n\tstring s; cin >> s;\n\tint n = s.size();\n\t\n\tvector<int> c0(n+1);\n\tc0[n] = 0;\n\tfor (int i = n-1; i >= 0; --i) {\n\t\tc0[i] = c0[i+1] + (s[i] == '0');\n\t}\n\t\n\tstatic bool ok[303][303][303];\n\tstatic int mn[303][303];\n\t\n\tok[n][0][0] = true;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tmn[i][j] = INT_MAX;\n\t\t}\n\t}\n\t\n\tfor (int sm = n; sm >= 1; --sm) {\n\t\tfor (int r = 0; r <= sm; ++r) {\n\t\t\tfor (int s0 = 0; r+s0 <= sm; ++s0) {\n\t\t\t\tint s1 = sm - r - s0;\n\t\t\t\tif (!ok[r][s0][s1]) continue;\n\t\t\t\tmn[sm][s0 + c0[n-r]] = min(mn[sm][s0 + c0[n-r]], r);\n\t\t\t\t// remove two usual\n\t\t\t\tif (r >= 2) {\n\t\t\t\t\tok[r-2][s0 + (s[n-r] == '0' || s[n-r+1] == '0')][s1] = true;\n\t\t\t\t\tok[r-2][s0][s1 + (s[n-r] == '1' || s[n-r+1] == '1')] = true;\n\t\t\t\t}\n\t\t\t\t// remove one usual & one floating\n\t\t\t\tif (r >= 1 && s0 > 0) {\n\t\t\t\t\tok[r-1][s0][s1] = true;\n\t\t\t\t\tok[r-1][s0 - 1 + (s[n-r] == '0')][s1] = true;\n\t\t\t\t\tok[r-1][s0 - 1][s1 + (s[n-r] == '1')] = true;\n\t\t\t\t}\n\t\t\t\tif (r >= 1 && s1 > 0) {\n\t\t\t\t\tok[r-1][s0][s1] = true;\n\t\t\t\t\tok[r-1][s0 + (s[n-r] == '0')][s1 - 1] = true;\n\t\t\t\t\tok[r-1][s0][s1 - 1 + (s[n-r] == '1')] = true;\n\t\t\t\t}\n\t\t\t\t// remove two floating\n\t\t\t\tif (s0+s1 >= 2) {\n\t\t\t\t\tif (s0 > 0) {\n\t\t\t\t\t\tok[r][s0-1][s1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (s1 > 0) {\n\t\t\t\t\t\tok[r][s0][s1-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int dp[303][303][303] = {};\n\tdp[n][0][0] = 1;\n\tfor (int i = n; i >= 0; --i) {\n\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\tfor (int k = 0; k <= n; ++k) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tdp[i-1][j][k] += dp[i][j][k];\n\t\t\t\t\tdp[i-1][j][k] %= mod;\n\t\t\t\t}\n\t\t\t\tif (i == 0 || s[i-1] == '0') {\n\t\t\t\t\tdp[i][j][k+1] += dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1] %= mod;\n\t\t\t\t}\n\t\t\t\tif (i == 0 || s[i-1] == '1') {\n\t\t\t\t\tdp[i][j+1][k] += dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int sz = 1; sz <= n; ++sz) {\n\t\tfor (int z = 0; z <= sz; ++z) {\n\t\t\tint r = mn[sz][z];\n\t\t\tif (r == INT_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s0 = z - c0[n-r];\n\t\t\tint s1 = sz - r - s0;\n\t\t\tint p = n-r;\n\t\t\twhile (p >= 0 && s0 >= 0 && s1 >= 0) {\n\t\t\t\tans += dp[p][s0][s1];\n\t\t\t\tans %= mod;\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--p;\n\t\t\t\t--(s[p] == '0' ? s0 : s1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nconst int N = 307;\n\nint dp[N][N][N];\nbool dp2[N][N][N];\n\ninline int sum(int x, int y) {\n\tif (x+y < 0) return x+y+mod;\n\tif (x+y >= mod) return x+y-mod;\n\treturn x+y;\n}\n\ninline int mult(int x, int y) {\n\treturn ((ll) x * y) % mod;\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"H_input.txt\", \"r\", stdin);\n\t//freopen(\"H_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\n\tdp[0][0][0] = 1;\n\tfor (int len = 0; len <= s.size(); ++len) {\n\t\tfor (int zeros = 0; zeros <= s.size(); ++zeros) {\n\t\t\tfor (int ones = 0; ones <= s.size(); ++ones) {\n\n\t\t\t\tif (len == 0) {\n\t\t\t\t\tif (ones) dp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len][ones-1][zeros]);\n\t\t\t\t\tif (zeros) dp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len][ones][zeros - 1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (s[s.size() - len] == '0') {\n\t\t\t\t\t\tif (ones) dp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len][ones-1][zeros]);\n\t\t\t\t\t\tdp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len - 1][ones][zeros]);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (zeros) dp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len][ones][zeros - 1]);\n\t\t\t\t\t\tdp[len][ones][zeros] = sum(dp[len][ones][zeros], dp[len - 1][ones][zeros]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << dp[0][1][0] << endl;\n\n\tdp2[0][0][0] = true;\n\tfor (int i = 0; i + 1 < s.size(); ++i) {\n\t\tfor (int zeros = 0; zeros <= s.size(); ++zeros) {\n\t\t\tfor (int ones = 0; ones <= s.size(); ++ones) {\n\t\t\t\t//cout << i << \" \" << zeros << \" \" << ones << \" \" << dp2[i][zeros][ones] << endl;\n\t\t\t\tif (!dp2[i][zeros][ones]) continue;\n\t\t\t\tint guys = s.size() - i - zeros - ones;\n\n\t\t\t\tif (guys >= 2) {\n\t\t\t\t\tif (s[s.size() - guys] == '0' || s[s.size() - guys + 1] == '0') {\n\t\t\t\t\t\tdp2[i+1][zeros+1][ones] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[s.size() - guys] == '1' || s[s.size() - guys + 1] == '1') {\n\t\t\t\t\t\tdp2[i+1][zeros][ones+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (guys >= 1) {\n\t\t\t\t\tif (s[s.size() - guys] == '0') {\n\t\t\t\t\t\tif (zeros > 0) {\n\t\t\t\t\t\t\tdp2[i+1][zeros][ones] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ones > 0) {\n\t\t\t\t\t\t\tdp2[i+1][zeros][ones] = true;\n\t\t\t\t\t\t\tdp2[i+1][zeros+1][ones-1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (zeros > 0) {\n\t\t\t\t\t\t\tdp2[i+1][zeros][ones] = true;\n\t\t\t\t\t\t\tdp2[i+1][zeros-1][ones+1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ones > 0) {\n\t\t\t\t\t\t\tdp2[i+1][zeros][ones] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (zeros + ones >= 2) {\n\t\t\t\t\tif (zeros > 0) dp2[i+1][zeros-1][ones] = true;\n\t\t\t\t\tif (ones > 0) dp2[i+1][zeros][ones-1] = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> pref_zero(s.size()+1);\n\tpref_zero[0] = 0;\n\n\tfor (int i = 0; i < s.size(); ++i) pref_zero[i+1] = pref_zero[i] + (s[i] == '0');\n\n\tvector<int> pref_one(s.size()+1);\n\tpref_one[0] = 0;\n\n\tfor (int i = 0; i < s.size(); ++i) pref_one[i+1] = pref_one[i] + (s[i] == '1');\n\n\tint ans = 0;\n\n\tfor (int zeros = 0; zeros <= s.size(); ++zeros) {\n\t\tfor (int ones = 0; ones+zeros <= s.size(); ++ ones) {\n\t\t\tint G = -1;\n\n\t\t\tint U, W;\n\n\t\t\tint Q = s.size() - ones - zeros;\n\n\t\t\tfor (int step = 0; step <= s.size(); ++step) {\n\t\t\t\tint z_need = zeros - (pref_zero.back() - pref_zero[step]);\n\t\t\t\tint o_need = ones - (pref_one.back() - pref_one[step]);\n\n\t\t\t\tif (z_need < 0 || o_need < 0) continue;\n\t\t\t\tif (dp2[Q][z_need][o_need]) G = step, U=z_need, W=o_need;\n\t\t\t}\n\n\t\t\t//if (G!=-1) cout << \" === \" << zeros << \" \" << ones << \" \" << G << \" \" << dp[s.size() - G][U][W] << \" \" << U << \" \" << W << endl;\n\n\t\t\tif (G!=-1) ans = sum(ans, dp[s.size() - G][W][U]);\n\t\t}\n\t}\n\n\tcout << ans;\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,ll>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=305,Mod=998244353;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nchar s[MAXN];int n,a[MAXN],f[MAXN][MAXN][MAXN],g[MAXN][MAXN][MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tRep(i,1,n)a[i]=s[i]^48;g[0][0][0]=1;\n\tRep(i,1,n){\n\t\tRed(j,n,0)Red(k,n,0){\n\t\t\tg[i][j][k]|=g[i-1][j][k];\n\t\t\tif(a[i]==0)g[i][j][k]|=g[i][j][k+1];\n\t\t\tif(a[i]==1)g[i][j][k]|=g[i][j+1][k];\n\t\t}\n\t\tRep(j,0,n)Rep(k,0,n)if(i>1){\n\t\t\tif((a[i]==0||a[i-1]==0)&&j)g[i][j][k]|=g[i-2][j-1][k];\n\t\t\tif((a[i]==0&&a[i-1]==0)&&j)g[i][j][k]|=g[i-1][j-1][k+1];\n\t\t\tif((a[i]==1||a[i-1]==1)&&k)g[i][j][k]|=g[i-2][j][k-1];\n\t\t\tif((a[i]==1&&a[i-1]==1)&&k)g[i][j][k]|=g[i-1][j+1][k-1];\n\t\t}\n\t}\n\tf[n+2][0][0]=1,a[0]=-1;\n\tRed(i,n+1,1){\n\t\tRep(j,0,n)Rep(k,0,n)f[i][j][k]=f[i+1][j][k];\n\t\tif(a[i-1]!=1)Rep(j,0,n)Rep(k,1,n)f[i][j][k]=(f[i][j][k]+f[i][j][k-1])%Mod;\n\t\tif(a[i-1]!=0)Rep(j,1,n)Rep(k,0,n)f[i][j][k]=(f[i][j][k]+f[i][j-1][k])%Mod;\n\t}int c0=0,c1=0,ans=0;\n\tRep(i,1,n+1)Rep(j,0,n)Rep(k,0,n)if(g[i-1][j][k])ans=(ans+f[i][j][k])%Mod;\n\tcout<<(ans-1+Mod)%Mod<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 310, mod = 998244353;\nint n,f[N][N][N],C[N][N];\nchar s[N],a[N];\nbool dp[N][N][N],vis[N][N];\n\ninline void upd(int &x,int y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\n\nint main(){\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tFor(i,1,n) a[i]=s[i];\n\tdp[0][0][0]=1;\n\tFOR(i,0,n) For(j,0,i) For(k,0,i) if (dp[i][j][k]){\n\t\tif (a[i+1]==a[i+2]){\n\t\t\tif (a[i+1]=='0') dp[i+2][j+1][k]=1;\n\t\t\t\telse dp[i+2][j][k+1]=1;\n\t\t} else {\n\t\t\tdp[i+2][j+1][k]=dp[i+2][j][k+1]=1;\n\t\t}\n\t\tif (j){\n\t\t\tif (a[i+1]=='0') dp[i+1][j][k]=1;\n\t\t\t\telse dp[i+1][j-1][k+1]=1,dp[i+1][j][k]=1;\n\t\t}\n\t\tif (k){\n\t\t\tif (a[i+1]=='1') dp[i+1][j][k]=1;\n\t\t\t\telse dp[i+1][j][k]=1,dp[i+1][j+1][k-1]=1;\n\t\t}\n\t}\n\tf[n+1][0][0]=f[n+2][0][0]=1;\n\tDow(i,n+1,1) For(j,0,n) For(k,0,n) if (f[i][j][k]){\n\t\tif (a[i-1]=='0'){\n\t\t\tupd(f[i-1][j][k],f[i][j][k]);\n\t\t\tupd(f[i][j][k+1],f[i][j][k]);\n\t\t} else {\n\t\t\tupd(f[i-1][j][k],f[i][j][k]);\n\t\t\tupd(f[i][j+1][k],f[i][j][k]);\n\t\t}\n\t}\n\tC[0][0]=1;\n\tFor(i,1,n){\n\t\tC[i][0]=1;\n\t\tFor(j,1,i) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tint cnt0=0,cnt1=0,ans=0;\n\tDow(i,n,0){\n\t\tFor(j,0,i) For(k,0,i) if (dp[i][j][k]){\n\t\t\tif (vis[cnt0+j][cnt1+k]) continue;\n\t\t\tFor(l,0,j) For(p,0,k){\n\t\t\t\tans=(ans+1ll*f[i+2][j-l][k-p]*C[l+p][l])%mod;\n\t\t\t}\n\t\t\tvis[cnt0+j][cnt1+k]=1;\n\t\t}\n\t\tif (s[i]=='0') ++cnt0;\n\t\t\telse ++cnt1;\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define m_p make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef long long ll;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 rnf(2106);\nconst int N = 303, M = 998244353;\n\nint n;\nchar a[N];\n\nbool can[N][N][N];\n\nint dp[N][N][N];\n\nvoid solv()\n{\n    scanf(\" %s\", (a + 1));\n    for (n = 1; a[n]; ++n){}\n    --n;\n    can[0][0][0] = true;\n    for (int i = 0; i <= n; ++i)\n    {\n        for (int q0 = n; q0 >= 0; --q0)\n        {\n            for (int q1 = n; q1 >= 0; --q1)\n            {\n                if (!can[i][q0][q1])\n                    continue;\n                if (q0 >= 2)\n                    can[i][q0 - 1][q1] = true;\n                if (q1 >= 2)\n                    can[i][q0][q1 - 1] = true;\n                if (q0 >= 1 && q1 >= 1)\n                {\n                    can[i][q0][q1 - 1] = true;\n                    can[i][q0 - 1][q1] = true;\n                }\n                if (i < n)\n                {\n                    if (a[i + 1] == '0')\n                    {\n                        if (q0 >= 1)\n                            can[i + 1][q0][q1] = true;\n                        if (q1 >= 1)\n                            can[i + 1][q0 + 1][q1 - 1] = true;\n                    }\n                    else\n                    {\n                        if (q0 >= 1)\n                            can[i + 1][q0 - 1][q1 + 1] = true;\n                        if (q1 >= 1)\n                            can[i + 1][q0][q1] = true;\n                    }\n                }\n                if (i + 1 < n)\n                {\n                    if (a[i + 1] == a[i + 2])\n                    {\n                        if (a[i + 1] == '0')\n                            can[i + 2][q0 + 1][q1] = true;\n                        else\n                            can[i + 2][q0][q1 + 1] = true;\n                    }\n                    else\n                    {\n                        can[i + 2][q0 + 1][q1] = true;\n                        can[i + 2][q0][q1 + 1] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    dp[n + 1][0][0] = 1;\n    for (int i = n + 1; i >= 1; --i)\n    {\n        for (int q0 = 0; q0 <= n; ++q0)\n        {\n            for (int q1 = 0; q1 <= n; ++q1)\n            {\n                // 0\n                if (a[i] == '0')\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i + 1][q0][q1]) % M;\n                else if (q0 >= 1)\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i][q0 - 1][q1]) % M;\n                // 1\n                if (a[i] == '1')\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i + 1][q0][q1]) % M;\n                else if (q1 >= 1)\n                    dp[i][q0][q1] = (dp[i][q0][q1] + dp[i][q0][q1 - 1]) % M;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int q0 = 0; q0 <= n; ++q0)\n    {\n        for (int q1 = 0; q1 <= n; ++q1)\n        {\n            int yq0 = q0, yq1 = q1;\n            for (int i = n; i >= 0; --i)\n            {\n                if (can[i][yq0][yq1])\n                {\n                    ans = (ans + dp[i + 1][yq0][yq1]) % M;\n                    break;\n                }\n                if (a[i] == '0')\n                    --yq0;\n                else\n                    --yq1;\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n    #ifdef SOMETHING\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #endif // SOMETHING\n    //ios_base::sync_with_stdio(false), cin.tie(0);\n    solv();\n    return 0;\n}\n\n//while ((double)clock() / CLOCKS_PER_SEC <= 0.9){}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) ((void) 42)\n#define dump2D(...) ((void) 42)\n#define dump1D(...) ((void) 42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\n  private:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\n  public:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nconstexpr ll mod = 998244353;\nusing modint = ModuloInteger<mod>;\n\n\nbool canTake[303 + 5][303][303]; // i, 0, 1\nmodint dp[303][303][303]; // 右何文字使って, 使うことが決まった0の数, 1\n\nint n;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> s;\n  n = s.size();\n  // dump(n);\n  canTake[3+(-2)][0][0] = 1;\n  canTake[3+(-1)][0][0] = 1;\n  canTake[3+0][0][0] = 1;\n  for(int i = 0; i <= n; i++) {\n    for(int j = 0; j <= n; j++) {\n      for(int k = 0; k <= n; k++) {\n        bool b = canTake[3+i][j][k];\n        canTake[3+i+1][j][k] |= b;\n        if(i < n) {\n          if(s[i] == '0') {\n            canTake[3+i+2][j+1][k] |= b;\n            if(k-1 >= 0) canTake[3+i+1][j+1][k-1] |= b;\n          } else {\n            canTake[3+i+2][j][k+1] |= b;\n            if(j-1 >= 0) canTake[3+i+1][j-1][k+1] |= b;\n          }\n        }\n        if(i+1 < n) {\n          if(s[i+1] == '0') {\n            canTake[3+i+2][j+1][k] |= b;\n          } else {\n            canTake[3+i+2][j][k+1] |= b;\n          }\n        }\n      }\n    }\n  }\n\n  modint ans = 0;\n  dp[0][0][0] = 1;\n\n  for(int ri = 0; ri <= n; ri++) {\n    for(int j = 0; j <= n; j++) {\n      for(int k = 0; k <= n; k++) {\n        int li = n - ri;\n        // take 0\n        if(li - 1 >= 0 && s[li - 1] == '0') {\n          dp[ri + 1][j][k] += dp[ri][j][k];\n        } else {\n          dp[ri][j + 1][k] += dp[ri][j][k];\n        }\n        // take 1\n        if(li - 1 >= 0 && s[li - 1] == '1') {\n          dp[ri + 1][j][k] += dp[ri][j][k];\n        } else {\n          dp[ri][j][k + 1] += dp[ri][j][k];\n        }\n      }\n    }\n  }\n  for(int ri = 0; ri <= n; ri++) {\n    for(int j = 0; j <= n; j++) {\n      for(int k = 0; k <= n; k++) {\n        int li = n - ri;\n        bool b = canTake[3+li][j][k];\n        if(b) ans += dp[ri][j][k];\n        // if(b) dump(li, j, k, dp[ri][j][k]);\n      }\n    }\n  }\n\n  cout << ans - 1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nconst int N = 310;\n\nint n;\nstring s;\nbool can[2][N][N];\nint best[N][N], suf[N][2], dp[2][N][N];\n\nvoid add(int &x, int y) { \n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nint memo[N][N][N];\nint go(int from, int zeros, int ones) {\n    if (zeros < 0 || ones < 0) return 0;\n    if (zeros + ones == 0) return 1;\n\n    int &res = memo[from][zeros][ones];\n    if (~res) return res;\n\n    res = 0;\n    if (s[from] == '0') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros-1, ones));\n\n    if (s[from] == '1') add(res, go(from+1, zeros, ones));\n    else add(res, go(from, zeros, ones-1));\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    cin >> s;\n    n = si(s);\n    dforsn(i,0,n) {\n        forn(j,2) {\n            suf[i][j] = s[i] == '0'+j;\n            suf[i][j] += suf[i+1][j];\n        }\n    }\n\n    memset(best, -1, sizeof best);\n\n    auto cur = can[0], prv = can[1];\n    cur[0][0] = 1;\n    for (int take = 1; take < n; take++) {\n        swap(cur, prv);\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                cur[a][b] = 0;\n            }\n        }\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) {\n                if (prv[a][b]) {\n                    if (a >= 1 && a+b >= 2) cur[a-1][b] = 1;\n                    if (b >= 1 && a+b >= 2) cur[a][b-1] = 1;\n                    int rest = n - take + 1 - a - b;\n                    int pos = n-rest;\n                    if (s[pos] == '0' && b > 0) cur[a+1][b-1] = 1;\n                    if (s[pos] == '1' && a > 0) cur[a-1][b+1] = 1;\n                    if (pos + 1 < n) {\n                        if (s[pos] == '0' || s[pos+1] == '0') cur[a+1][b] = 1;\n                        if (s[pos] == '1' || s[pos+1] == '1') cur[a][b+1] = 1;\n                    }\n                }\n            }\n        }\n\n        for (int a = 0; a <= n; a++) {\n            for (int b = 0; b <= n-a; b++) if (cur[a][b]) {\n                int rest = n - take - a - b;\n                int pos = n-rest;\n\n                int aa = suf[pos][0] + a;\n                int bb = suf[pos][1] + b;\n                best[aa][bb] = max(best[aa][bb], pos);\n            }\n        }\n    }\n    s += '$';\n    memset(memo, -1, sizeof memo);\n    ll ans = 0;\n    forn(a,n+1) forn(b,n+1) if (best[a][b] != -1) {\n        int pos = best[a][b];\n        int ca = a - suf[pos][0];\n        int cb = b - suf[pos][1];\n        ans += go(pos, ca, cb);\n    }\n    cout << (ans+1) % MOD << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define __iostream_untie__ true\n#include <bits/stdc++.h>\n#include <ext/rope>\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(__iostream_untie__) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n\n#ifndef modint_hpp\n#define modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint() noexcept : val{0} {}\n    constexpr modint(long long x) noexcept : val((x %= mod) < 0 ? mod + x : x) {}\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &other) noexcept { return (val += other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &other) noexcept { return (val += mod - other.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &other) noexcept { return val = (long long)val * other.val % mod, *this; }\n    constexpr modint &operator/=(const modint &other) noexcept { return *this *= inverse(other); }\n    constexpr modint operator+(const modint &other) const noexcept { return modint(*this) += other; }\n    constexpr modint operator-(const modint &other) const noexcept { return modint(*this) -= other; }\n    constexpr modint operator*(const modint &other) const noexcept { return modint(*this) *= other; }\n    constexpr modint operator/(const modint &other) const noexcept { return modint(*this) /= other; }\n    constexpr bool operator==(const modint &other) const noexcept { return val == other.val; }\n    constexpr bool operator!=(const modint &other) const noexcept { return val != other.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long x, modint y) noexcept { return modint(x) + y; }\n    friend constexpr modint operator-(long long x, modint y) noexcept { return modint(x) - y; }\n    friend constexpr modint operator*(long long x, modint y) noexcept { return modint(x) * y; }\n    friend constexpr modint operator/(long long x, modint y) noexcept { return modint(x) / y; }\n    static constexpr modint inverse(const modint &other) noexcept\n    {\n        assert(other != 0);\n        int a{mod}, b{other.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint other, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= other; other *= other, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &other) noexcept { return os << other.val; }\n    friend std::istream &operator>>(std::istream &is, modint &other) noexcept { long long val; other = {(is >> val, val)}; return is; }\n}; // class modint\n\n#endif // modint_hpp\n\n#ifndef binomial_hpp\n#define binomial_hpp\n\nnamespace binomial\n{\n    constexpr int mod = //*\n                        998244353\n                        /*/\n                        1000000007\n                        /**/;\n    constexpr int size = 1 << 20;\n    using mint = modint<mod>;\n    namespace\n    {\n        namespace internal_helper\n        {\n            struct fact_impl\n            {\n                int _fact[size], _inv[size], _invfact[size];\n                fact_impl() : _fact{1}, _inv{0, 1}, _invfact{1}\n                {\n                    for(int i = 1; i < size; ++i) _fact[i] = (long long)_fact[i - 1] * i % mod;\n                    for(int i = 2; i < size; ++i) _inv[i] = mod - (long long)mod / i * _inv[mod % i] % mod;\n                    for(int i = 1; i < size; ++i) _invfact[i] = (long long)_invfact[i - 1] * _inv[i] % mod;\n                }\n            } fact_calced;\n        } // namespace internal_helper\n        mint fact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._fact[x]; }\n        mint invfact(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._invfact[x]; }\n        mint inv(int x) noexcept { assert(x < size); return x < 0 ? 0 : internal_helper::fact_calced._inv[x]; }\n    } // unnamed namespace\n    mint binom(int n, int k) noexcept { return fact(n) * invfact(k) * invfact(n - k); }\n    mint fallfact(int n, int k) noexcept { return fact(n) * invfact(n - k); }\n    mint risefact(int n, int k) noexcept { return fallfact(n + k - 1, k); }\n    // time complexity: O(min(n, k) * log(n))\n    mint stirling_2nd(int n, int k) noexcept\n    {\n        if(n < k) return 0;\n        mint res{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n            if(i & 1) res -= mint::pow(j, n) * invfact(j) * invfact(i);\n            else res += mint::pow(j, n) * invfact(j) * invfact(i);\n        return res;\n    };\n    // time complexity: O(min(n, k) * log(n))\n    mint bell(int n, int k) noexcept\n    {\n        if(n < k) k = n;\n        mint res{}, alt{};\n        for(int i{}, j{k}; j >= 0; ++i, --j)\n        {\n            if(i & 1) alt -= invfact(i);\n            else alt += invfact(i);\n            res += alt * mint::pow(j, n) * invfact(j);\n        }\n        return res;\n    }\n    namespace internal_helper {} // namespace internal_helper\n} // namespace binomial\n\n#endif // binomial_hpp\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n        using namespace binomial;\n\n        string s; cin>>s;\n        int n=s.size();\n\n        bool dp[334][334][334]={};\n        dp[0][0][0]=1;\n\n        for(int i=0; i<n; i++)\n        {\n            if(s[i]=='0' or (i<n-1 and s[i+1]=='0'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j+1][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='1' or (i<n-1 and s[i+1]=='1'))\n            {\n                for(int j=0; j<n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        dp[i+2][j][k+1]|=dp[i][j][k];\n                    }\n                }\n            }\n            if(s[i]=='0')\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        if(k) dp[i+1][j+1][k-1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<n; k++)\n                    {\n                        if(j) dp[i+1][j-1][k+1]|=dp[i][j][k];\n                        dp[i+1][j][k]|=dp[i][j][k];\n                    }\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>0; j--)\n            {\n                for(int k=n; k>=0; k--)\n                {\n                    dp[i][j-1][k]|=dp[i][j][k];\n                }\n            }\n        }\n        for(int i=0; i<=n; i++)\n        {\n            for(int j=n; j>=0; j--)\n            {\n                for(int k=n; k>0; k--)\n                {\n                    dp[i][j][k-1]|=dp[i][j][k];\n                }\n            }\n        }\n\n\n        vector dp2(334, vector(334, vector<mint>(334)));\n        for(int i=0; i<=n; i++)\n        {\n            dp2[n][i][0]=1;\n            dp2[n][0][i]=1;\n        }\n        for(int i=1; i<=n; i++)\n        {\n            for(int j=1; j<=n; j++)\n            {\n                dp2[n][i][j]=dp2[n][i-1][j]+dp2[n][i][j-1];\n            }\n        }\n\n        for(int i=n-1; i>=0; i--)\n        {\n            auto &now=dp2[i];\n            now=dp2[i+1];\n            if(s[i]=='0')\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j][k+1]+=now[j][k];\n                    }\n                }\n            }\n            else\n            {\n                for(int j=0; j<=n; j++)\n                {\n                    for(int k=0; k<=n; k++)\n                    {\n                        now[j+1][k]+=now[j][k];\n                    }\n                }\n            }\n        }\n\n\n        bool calced[666][666]={};\n        mint ans;\n\n        for(int i=n,oc=0,zc=0; i>=0; i--)\n        {\n            if(i<n)\n            {\n                if(s[i]=='0') zc++;\n                else oc++;\n            }\n            for(int j=0; j<=n; j++)\n            {\n                for(int k=0; k<=n; k++)\n                {\n                    if(dp[i][j][k] and !calced[j+zc][k+oc])\n                    {\n                        dump(i,j+zc,k+oc,dp2[i][j][k]);\n                        ans+=dp2[i][j][k];\n                        calced[j+zc][k+oc]=true;\n                    }\n                }\n            }\n        }\n\n        cout << ans-1 << \"\\n\";\n\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=305;\nint n;\nchar s[N];\nint dp[N][N][N],g[N][N][N],f[N][N][N];\nint main(){\n\tcin>>(s+1);\n\tn=strlen(s+1);\n\tdp[0][0][0]=1;\n\tFor(a,0,n)\n\t\tFod(i,n,0)\n\t\t\tFod(j,n,0){\n\t\t\t\tif (dp[a][i][j]){\n//\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",a,i,j);\n\t\t\t\t\tf[a][i][j]=1;\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tf[a+1][i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif (i>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i-1][j]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tdp[a+1][i][j]=1;\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i-1+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+1][i-1][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i][j-1]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tdp[a+1][i][j]=1;\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i+1][j-1]=1;\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tdp[a+1][i][j-1+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tFor(k,a+1,a+2){\n\t\t\t\t\t\t\tif (s[k]=='0')\n\t\t\t\t\t\t\t\tdp[a+2][i+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+2][i][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f[a][i][j]){\n\t\t\t\t\tif (a<n){\n\t\t\t\t\t\tif (i>0)\n\t\t\t\t\t\t\tf[a][i-1][j]=1;\n\t\t\t\t\t\tif (j>0)\n\t\t\t\t\t\t\tf[a][i][j-1]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tg[n+1][0][0]=1;\n\tint ans=1;\n\tFod(b,n,1){\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n)\n\t\t\t\tg[b][i][j]=g[b+1][i][j];\n\t\tif (s[b]=='1'){\n\t\t\tFor(i,1,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i-1][j]);\n\t\t}\n\t\telse {\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i][j-1]);\n\t\t}\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n){\n\t\t\t\tif (i+j>b+1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v=0;\n\t\t\t\tint ii=i,jj=j;\n\t\t\t\tFor(k,b,n){\n\t\t\t\t\tif (f[k][ii][jj]){\n//\t\t\t\t\t\tprintf(\"[%d][%d][%d]\\n\",k,ii,jj);\n\t\t\t\t\t\tv=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[k+1]=='0')\n\t\t\t\t\t\tii++;\n\t\t\t\t\telse\n\t\t\t\t\t\tjj++;\n\t\t\t\t}\n\t\t\t\tif (v) assert(i+j<=b),\n//\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\",b,i,j,g[b][i][j]),\n\t\t\t\t\tAdd(ans,g[b][i][j]);\n\t\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n001\n001 0 1 01 10\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=300,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nchar s[N+9];\nint n;\n\nvoid into(){\n  scanf(\"%s\",s+1);\n  n=strlen(s+1);\n}\n\nint dp[N+9][N+9][N+9];\n\nvoid Get_dp(){\n  dp[n][0][0]=1;\n  for (int i=n;i>=1;--i)\n\tfor (int j=0;j<i;++j)\n\t  for (int k=0;j+k<i;++k){\n\t\tdp[i-1][j][k]=dp[i][j][k];\n\t\ts[i]=='0'?sadd(dp[i][j][k+1],dp[i][j][k]):sadd(dp[i][j+1][k],dp[i][j][k]);\n\t  }\n}\n\nint f[N+9][N+9][N+9];\n\nvoid Get_f(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=n+1;++j)\n\t  for (int k=0;k<=n+1;++k) f[i][j][k]=-1;\n  f[0][0][0]=0;\n  for (int i=0;i<n;++i)\n\tfor (int j=0;j<=i>>1;++j)\n\t  for (int k=0;j+k<=i>>1;++k){\n\t\tif (f[i][j][k]==-1) continue;\n\t\ts[i+1]=='0'?f[i+1][j+1][k]=max(f[i+1][j+1][k],f[i][j][k]-1):f[i+1][j][k+1]=max(f[i+1][j][k+1],f[i][j][k]-1);\n\t\tif (i+2>n) continue;\n\t\tf[i+2][j][k]=max(f[i+2][j][k],f[i][j][k]+1);\n\t\tif (s[i+1]=='0'||s[i+2]=='0') f[i+2][j+1][k]=max(f[i+2][j+1][k],f[i][j][k]);\n\t\tif (s[i+1]=='1'||s[i+2]=='1') f[i+2][j][k+1]=max(f[i+2][j][k+1],f[i][j][k]);\n\t  }\n  for (int i=0;i<=n;++i)\n\tfor (int j=n;j>=0;--j)\n\t  for (int k=n;k>=0;--k){\n\t\tf[i][j][k]=max(f[i][j][k],max(f[i][j][k+1],f[i][j+1][k]));\n\t\tif (i) f[i][j][k]=max(f[i][j][k],f[i-1][j][k]);\n\t  }\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=i;++j)\n\t  for (int k=0;j+k<=i;++k)\n\t\tif (f[i][j][k]>=0) sadd(ans,dp[i][j][k]);\n}\n\nvoid work(){\n  Get_dp();\n  Get_f();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",sub(ans,1));\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void chOut(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing v_bool = vector<bool>;\nusing v_Pii = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    string S; cin >> S;\n    int N = SZ(S);\n\n    vector<mat> dp(N + 1, mat(N + 1, vec(N + 1, -1)));\n    dp[0][0][0] = 0;\n    REP(i, N){\n        REP(j, N + 1) REP(k, N + 1) if(dp[i][j][k] >= 0){\n            if(i + 2 <= N){\n                if(S[i] == '0' || S[i + 1] == '0') chmax(dp[i + 2][j + 1][k], dp[i][j][k]);\n                if(S[i] == '1' || S[i + 1] == '1') chmax(dp[i + 2][j][k + 1], dp[i][j][k]);\n                chmax(dp[i + 2][j][k], dp[i][j][k] + 1);\n            }\n            chmax(dp[i + 1][j][k], dp[i][j][k]);\n            if(dp[i][j][k] >= 1){\n                if(S[i] == '0') chmax(dp[i + 1][j + 1][k], dp[i][j][k] - 1);\n                if(S[i] == '1') chmax(dp[i + 1][j][k + 1], dp[i][j][k] - 1);\n            }\n        }\n    }\n\n    vector<mmat> dq(N + 1, mmat(N + 1, mvec(N + 1, 0)));\n    if(S[N - 1] == '0'){\n        REP(k, N + 1) dq[0][0][k] = 1;\n    }else{\n        REP(j, N + 1) dq[0][j][0] = 1;\n    }\n    REP(i, N){\n        REP(j, N + 1) REP(k, N + 1){\n            dq[i + 1][j][k] += dq[i][j][k];\n        }\n        if(i < N - 1){\n            if(S[N - 2 - i] == '0'){\n                REP(j, N + 1){\n                    mint t = 0;\n                    REP(k, N + 1){\n                        dq[i + 1][j][k] += t;\n                        t += dq[i][j][k];\n                    }\n                }\n            }else{\n                REP(k, N + 1){\n                    mint t = 0;\n                    REP(j, N + 1){\n                        dq[i + 1][j][k] += t;\n                        t += dq[i][j][k];\n                    }\n                }\n            }\n        }\n    }\n\n    mint ans = 0;\n    REP(i, N + 1){\n        REP(j, N + 1) REP(k, N + 1) if(dp[N - i][j][k] >= 0) ans += dq[i][j][k];\n    }\n    Out(ans - 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\n#ifdef AIM\n#include <sys/resource.h>\n#endif\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(__attribute__((unused)) bool);\nvoid precalc();\nclock_t start;\n#define FILENAME \"\"\n\nint main() {\n#ifdef AIM\n  string s = FILENAME;\n//    assert(!s.empty());\n  freopen(\"/home/alexandero/ClionProjects/cryptozoology/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/cryptozoology/output.txt\", \"w\", stdout);\n#else\n//    freopen(FILENAME \".in\", \"r\", stdin);\n//    freopen(FILENAME \".out\", \"w\", stdout);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n\n#ifdef AIM\n  const rlim_t kStackSize = 256 * 1024 * 1024;\n  struct rlimit rl;\n  int result;\n\n  result = getrlimit(RLIMIT_STACK, &rl);\n  if (result == 0)\n  {\n    if (rl.rlim_cur < kStackSize)\n    {\n      rl.rlim_cur = kStackSize;\n      result = setrlimit(RLIMIT_STACK, &rl);\n      if (result != 0)\n      {\n        fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n      }\n    }\n  }\n#endif\n\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n      //cout << \"Case #\" << testNum++ << \": \";\n      solve(true);\n  }\n  cout.flush();\n#ifdef AIM1\n    while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cout.flush();\n  auto end = clock();\n\n  usleep(10000);\n  print_stats(end - start);\n  usleep(10000);\n#endif\n\n    return 0;\n}\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& a) {\n    sort(all(a));\n    a.erase(unique(all(a)), a.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n    cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n    cur = max(cur, val);\n}\n\nvoid precalc() {\n}\n\n#define int li\nconst int mod = 998244353;\n\nvoid add(int& cur, int val) {\n  cur += val;\n  cur %= mod;\n}\n\nconst int C = 310;\nbool reachable[C][C][C];\nint max_pref[C][C];\npair<int, int> in_air[C][C];\n\nint fact[C], rev_fact[C];\nint get_c(int n, int k) {\n  return fact[n] * rev_fact[n - k] % mod * rev_fact[k] % mod;\n}\n\nvoid solve(__attribute__((unused)) bool read) {\n  fact[0] = 1;\n  for (int i = 1; i < C; ++i) {\n    fact[i] = fact[i - 1] * i % mod;\n  }\n  for (int i = 0; i < C; ++i) {\n    rev_fact[i] = binpow(fact[i], mod - 2, mod);\n  }\n  string s;\n  //read = false;\n  if (read) {\n    cin >> s;\n  } else {\n    s = string(300, '0');\n    for (int i = 0; i < s.length(); ++i) {\n      if (rand() & 1) {\n        s[i] = '1';\n      }\n    }\n  }\n  int n = (int)s.length();\n  reachable[0][0][0] = true;\n  for (int pref = 0; pref <= n; ++pref) {\n    for (int a = C - 1; a >= 0; --a) { // 0s\n      for (int b = C - 1; b >= 0; --b) { // 1s\n        if (!reachable[pref][a][b]) {\n          continue;\n        }\n        if (pref + 1 < n) {\n          if (s[pref] == '0' || s[pref + 1] == '0') {\n            reachable[pref + 2][a + 1][b] = true;\n          }\n          if (s[pref] == '1' || s[pref + 1] == '1') {\n            reachable[pref + 2][a][b + 1] = true;\n          }\n        }\n        if (a > 0 || b > 0) {\n          reachable[pref + 1][a][b] = true;\n          if (s[pref] == '0' && b > 0) {\n            reachable[pref + 1][a + 1][b - 1] = true;\n          }\n          if (s[pref] == '1' && a > 0) {\n            reachable[pref + 1][a - 1][b + 1] = true;\n          }\n        }\n        if (a > 1) {\n          reachable[pref][a - 2][b] = true;\n        }\n        if (b > 1) {\n          reachable[pref][a][b - 2] = true;\n        }\n        if (a > 0 && b > 0) {\n          reachable[pref][a - 1][b - 1] = true;\n        }\n      }\n    }\n  }\n  for (int a = 0; a < C; ++a) {\n    for (int b = 0; b < C; ++b) {\n      max_pref[a][b] = -1;\n    }\n  }\n  for (int pref = 0; pref <= n; ++pref) {\n    int cnt[2] = {0, 0};\n    for (int i = pref; i < n; ++i) {\n      ++cnt[s[i] - '0'];\n    }\n    for (int a = 0; a < C; ++a) {\n      for (int b = 0; b < C; ++b) {\n        if (reachable[pref][a][b]) {\n          max_pref[a + cnt[0]][b + cnt[1]] = pref;\n          in_air[a + cnt[0]][b + cnt[1]] = {a, b};\n        }\n      }\n    }\n  }\n\n  int res = 0;\n  for (int a = 0; a < C; ++a) {\n    for (int b = 0; b < C; ++b) {\n      if (max_pref[a][b] == -1) {\n        continue;\n      }\n      if (a + b == 0) {\n        continue;\n      }\n      string cur = s.substr(max_pref[a][b], n - max_pref[a][b]);\n      int cnt[2] = {0, 0};\n      int places[2] = {0, 0};\n      for (char c : cur) {\n        ++cnt[c - '0'];\n      }\n      for (int i = 0; i < 2; ++i) {\n        places[i] = cnt[1 - i];\n      }\n      //cout << a << \" \" << b << \" \" << places[0] << \" \" << places[1] << endl;\n      int A = a - cnt[0], B = b - cnt[1];\n      for (int x = 0; x <= A; ++x) {\n        if (places[0] == 0 && x > 0) {\n          break;\n        }\n        int x_mult = (places[0] == 0 ? 1 : get_c(x + places[0] - 1, x));\n        for (int y = 0; y <= B; ++y) {\n          if (places[1] == 0 && y > 0) {\n            break;\n          }\n          int y_mult = (places[1] == 0 ? 1 : get_c(y + places[1] - 1, y));\n          int cur_res = x_mult * y_mult % mod * get_c(A - x + B - y, A - x) % mod;\n          //cout << \"x: \" << x << \" y: \" << y << \" cur_res: \" << cur_res << endl;\n          add(res, cur_res);\n        }\n      }\n    }\n  }\n  cout << res << \"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 305 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nint n, a;\nchar inp[maxn];\nint dp[maxn][maxn][maxn]; // 长度 还没匹配啥 几个1 \nint fl[maxn][maxn][maxn]; // 从 j 到 n， 提取出 x 个 1 y 个 b \nint mx[maxn][maxn];\nint ed[maxn];\nint main() {\n\tscanf(\"%s\", inp + 1);\n\tint l = strlen(inp + 1);\n\tfor (int i = l; i >= 1; i--) {\n\t\ted[i] = ed[i + 1];\n\t\tif (inp[i] == '1') ed[i]++;\n\t}\n\tdp[0][l][0] = 1;\n\tfor (int i = 0; i <= l; i++)\n\t\tfor (int j = 0; j <= l; j++)\n\t\t\tfor (int k = 0; k <= i; k++)\n\t\t\t\tfor (int s = 0; s < 2; s++) {\n\t\t\t\t\tint ei = i + 1, ej = j, ek = k;\n\t\t\t\t\tif (s == 1) ek++;\n\t\t\t\t\tif (s == inp[j] - '0') ej--;\n\t\t\t\t\tdp[ei][ej][ek] = (dp[ei][ej][ek] + dp[i][j][k]) % mod;\n\t\t\t\t}\n\tfl[1][0][0] = 1;\n\tfor (int i = 1; i <= l + 1; i++)\n\t\tfor (int j = l; j >= 0; j--) // j : 0 k : 1\n\t\t\tfor (int k = l; k >= 0; k--) {\n\t\t\t\tif (!fl[i][j][k]) continue;\n\t\t\t\tmx[l + 1 - i + j + k][k + ed[i]] = i;\n\t\t\t\tif ((j + k) >= 2) {\n\t\t\t\t\tif (j) fl[i][j - 1][k] = 1;\n\t\t\t\t\tif (k) fl[i][j][k - 1] = 1;\n\t\t\t\t\t//填上一项 \n\t\t\t\t}\n\t\t\t\tif (i != l + 1) {\n\t\t\t\t\t//后面选一个\n\t\t\t\t\tint um = inp[i] - '0';\n\t\t\t\t\tif (j) {\n\t\t\t\t\t\tif (um == 1) fl[i + 1][j - 1][k + 1] = 1;\n\t\t\t\t\t\tif (um == 0) fl[i + 1][j][k] = 1;\n\t\t\t\t\t\tfl[i + 1][j][k] = 1;\n\t\t\t\t\t} \n\t\t\t\t\tif (k) {\n\t\t\t\t\t\tif (um == 1) fl[i + 1][j][k] = 1;\n\t\t\t\t\t\tif (um == 0) fl[i + 1][j + 1][k - 1] = 1;\n\t\t\t\t\t\tfl[i + 1][j][k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i <= l - 1) {\n\t\t\t\t\tint um = inp[i] - '0', vm = inp[i + 1] - '0';\n\t\t\t\t\tif (um == 1 || vm == 1) fl[i + 2][j][k + 1] = 1;\n\t\t\t\t\tif (um == 0 || vm == 0) fl[i + 2][j + 1][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= l; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tif (mx[i][j]) {\n\t\t\t\tfor (int u = mx[i][j] - 1; u >= 0; u--)\n\t\t\t\t\tans += dp[i][u][j], \n\t\t\t\t\tans %= mod;\t\n\t\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nconst int MOD = 998244353;\nconst int N = 303;\n\n\nbool state[N][N][N];\nint ways[N][N][N];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    state[n][0][0] = true;\n\n    vector <bool> isZero(n), isOne(n);\n    for (int i = 0; i < n; i++) {\n        isZero[i] = s[i] == '0';\n        isOne[i] = !isZero[i];\n    }\n\n    for (int suffLen = n; suffLen >= 0; suffLen--) {\n        for (int zeros = n; zeros >= 0; zeros--) for (int ones = n; ones >= 0; ones--) {\n            if (state[suffLen][zeros][ones]) {\n                int p1 = n - suffLen;\n                int p2 = p1 + 1;\n\n                if (suffLen >= 2) {\n                    for (int p : {p1, p2}) {\n                        state[suffLen - 2][zeros + isZero[p]][ones + isOne[p]] = true;\n                    }\n                }\n\n                if (suffLen >= 1) {\n                    if (zeros >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros - 1 + isZero[p1]][ones + isOne[p1]] = true;\n                    }\n\n                    if (ones >= 1) {\n                        state[suffLen - 1][zeros][ones] = true;\n                        state[suffLen - 1][zeros + isZero[p1]][ones - 1 + isOne[p1]] = true;\n                    }\n                }\n\n                if (zeros >= 2) state[suffLen][zeros - 2][ones] = true;\n                if (ones >= 2) state[suffLen][zeros][ones - 2] = true;\n                if (zeros >= 1 && ones >= 1) state[suffLen][zeros - 1][ones - 1] = true;\n            }\n        }\n    }\n\n    vector <int> suffZeros(n + 1, 0), suffOnes(n + 1, 0);\n\n    for (int i = 1; i <= n; i++) {\n        suffZeros[i] = suffZeros[i - 1] + isZero[n - i];\n        suffOnes[i] = suffOnes[i - 1] + isOne[n - i];\n    }\n\n    map <pair<int,int>,tuple<int,int,int>> minLenState;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (state[suffLen][zeros][ones]) {\n                int zerosTotal = zeros + suffZeros[suffLen];\n                int onesTotal = ones + suffOnes[suffLen];\n\n                pair <int,int> p = {zerosTotal, onesTotal};\n\n                if (!minLenState.count(p)) {\n                    minLenState[p] = tuple <int,int,int> {suffLen, zeros, ones};\n                }\n            }\n        }\n    }\n\n    ways[0][0][0] = 1;\n\n    for (int suffLen = 0; suffLen <= n; suffLen++) {\n        for (int zeros = 0; zeros <= n; zeros++) for (int ones = 0; ones <= n; ones++) {\n            if (suffLen == 0) {\n                if (zeros >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros - 1][ones];\n                }\n\n                if (ones >= 1) {\n                    ways[suffLen][zeros][ones] += ways[suffLen][zeros][ones - 1];\n                }\n\n                ways[suffLen][zeros][ones] %= MOD;\n            } else {\n                int last = isOne[n - suffLen];\n                ways[suffLen][zeros][ones] = ways[suffLen-1][zeros][ones];\n\n                if (last == 0) {\n                    if (ones >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros][ones-1]) % MOD;\n                    }\n                } else {\n                    if (zeros >= 1) {\n                        ways[suffLen][zeros][ones] = (ways[suffLen][zeros][ones] + ways[suffLen][zeros-1][ones]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (auto &entry : minLenState) {\n        int suffLen, zeros, ones;\n        tie(suffLen, zeros, ones) = entry.second;\n\n        ans = (ans + ways[suffLen][zeros][ones]) % MOD;\n    }\n\n    ans = (ans + MOD - 1) % MOD;\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tfor (auto &i : s) i = i == '0' ? '1' : '0';\n\t\n\tint n = s.size();\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\nset<long long> chk[303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tlong long u = 0;\n\tu *= L + 1; u += i;\n\tu *= L + 1; u += z;\n\tu *= L + 1; u += o;\n\tu *= L + 1; u += f;\n\tif (chk[L - i + z + o + f].count(u)) return;\n\tchk[L - i + z + o + f].insert(u);\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\telse if (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\telse if (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) if (!chk[l].empty()){\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tint s[303], e[303];\n\t\tmemset(s, 0x7f, sizeof(s));\n\t\tmemset(e, -1, sizeof(e));\n\t\tfor (auto t : chk[l]){\n\t\t\tint f = t % (L + 1); t /= L + 1;\n\t\t\tint o = t % (L + 1); t /= L + 1;\n\t\t\tint z = t % (L + 1); t /= L + 1;\n\t\t\tint i = t % (L + 1); t /= L + 1;\n\n\t\t\ts[i] = min(s[i], z);\n\t\t\te[i] = max(e[i], z + f);\n\t\t}\n\n\t\tfor (int i = 0; i <= L; i++){\n\t\t\tif (e[i] != -1){\n\t\t\t\tfor (int j = s[i]; j <= e[i]; j++) pin[j + zc[i]] = i;\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nusing M9 = IntMod<998244353>;\n\n// T = reverse(S) とする\n// 以下、「T 内の文字」と言った場合、先頭から貪欲に T に含まれる文字を確定していくことを示す\n// T = \"100101\" に対して 0 を3つ挿入し、 \"100010010\" を得たなら、\n// [1][0][0] 0 [1][0] 0 [1] となる ([ ] のついた部分が T 内の文字)\n\nstring S;\nbool DP[301][301][301];\t\t// DP[i][j][k] = Sの先頭 i 文字を使って手持ちを「0 が j 個, 1 が k 個」にできるか\nM9 EP[301][301];\t\t\t// EP[i][j] = Tの先頭 i 文字に 0 を j 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 FP[301][301];\t\t\t// FP[i][k] = Tの先頭 i 文字に 1 を k 個挿入してできる文字列で、末尾が T 内の文字であるものの数\nM9 GP[301][301][301];\t\t// GP[i][j][k] = Tの先頭 i 文字に 0 を j 個, 1 を k 個挿入してできる文字列の数\nM9 EQ[301][302];\t\t// 累積和用\nM9 FQ[301][302];\nvoid pre() {\n\tstring T = S;\n\treverse(T.begin(), T.end());\n\tint N = T.size();\n\n\t// EP の計算: 先頭から T を見ていき 0 を挿入する ([1] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tEP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tEP[i][j] = EP[i - 1][j];\n\t\t\t} else {\n\t\t\t\tEP[i][j] = EQ[i - 1][j + 1];\n\t\t\t}\n\t\t}\n\n\t\tREP(j, 0, N + 1) {\n\t\t\tEQ[i][j + 1] = EQ[i][j] + EP[i][j];\n\t\t}\n\t}\n\n\t// FP の計算: 先頭から T を見ていき 1 を挿入する ([0] の前のみに挿入できる)\n\tREP(i, 0, N + 1) {\n\t\tREP(k, 0, N + 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tFP[i][0] = 1;\n\t\t\t} else if (T[i - 1] == '0') {\n\t\t\t\tFP[i][k] = FQ[i - 1][k + 1];\n\t\t\t} else {\n\t\t\t\tFP[i][k] = FP[i - 1][k];\n\t\t\t}\n\t\t}\n\n\t\tREP(k, 0, N + 1) {\n\t\t\tFQ[i][k + 1] = FQ[i][k] + FP[i][k];\n\t\t}\n\t}\n\n\t// GP の計算:\n\t// GP[i][j][k] = sum [p = 0 to j, q = 0 to k] { EP[i][j - p] * FP[i][k - q] * C(p + q, p) } である\n\t// (T 内の文字がどこに現れるかで場合分けするとわかる)\n\t// ここから GP[i][j][k] = GP[i][j - 1][k] + GP[i][j][k - 1] + EP[i][j] * FP[i][k] が得られる\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tGP[i][j][k] += EP[i][j] * FP[i][k];\n\t\t\t\tif (j > 0) GP[i][j][k] += GP[i][j - 1][k];\n\t\t\t\tif (k > 0) GP[i][j][k] += GP[i][j][k - 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> S;\n\tpre();\n\n\tint N = S.size();\n\n\t// DP の計算 (これは素直だと思います)\n\tDP[0][0][0] = true;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (i + 1 < N) {\n\t\t\t\t\tif (S[i] == '0' || S[i + 1] == '0') DP[i + 2][j + 1][k] |= DP[i][j][k];\n\t\t\t\t\tif (S[i] == '1' || S[i + 1] == '1') DP[i + 2][j][k + 1] |= DP[i][j][k];\n\t\t\t\t}\n\t\t\t\tif (j > 0 && S[i] == '1') DP[i + 1][j - 1][k + 1] |= DP[i][j][k];\n\t\t\t\tif (k > 0 && S[i] == '0') DP[i + 1][j + 1][k - 1] |= DP[i][j][k];\n\t\t\t\tif (j + k > 0) DP[i + 1][j][k] |= DP[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tM9 sum = 0;\n\tREP(i, 0, N + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, N + 1) {\n\t\t\t\tif (!DP[i][j][k]) continue;\n\t\t\t\t// 今見ている取り除き方 (i, j, k) を包含するようなうまい取り除き方があれば skip\n\t\t\t\tif (S[i] == '0' && DP[i + 1][j + 1][k]) continue;\n\t\t\t\tif (S[i] == '1' && DP[i + 1][j][k + 1]) continue;\n\t\t\t\tsum += GP[N - i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 310, P = 998244353;\nint dp[N][N], f[N][N][N], n, ans;\nvector <pair<int, int> > mp[N];\nchar s[N];\nvoid join(int x, int y, int i){\n\tif (dp[x][y] != inf) return;\n\tdp[x][y] = i; \n\tmp[i].push_back(mr(x, y));\n}\nint main(){\n\tscanf(\"\\n%s\", s + 1);\n\tn = strlen(s + 1);\n\tmemset(dp, inf, sizeof(dp));\n\tdp[0][0] = 0;\n\tmp[0].push_back(mr(0, 0));\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (unsigned j = 0; j < mp[i - 2].size(); j++){\n\t\t\tint x = mp[i - 2][j].first, y = mp[i - 2][j].second;\n\t\t\tif (s[i - 1] == '0' || s[i] == '0'){\n\t\t\t\tint tx = x + 1, ty = y;\n\t\t\t\tjoin(tx, ty, i);\n\t\t\t}\n\t\t\tif (s[i - 1] == '1' || s[i] == '1'){\n\t\t\t\tint tx = x, ty = y + 1;\n\t\t\t\tjoin(tx, ty, i);\n\t\t\t}\n\t\t}\n\t\tfor (unsigned j = 0; j < mp[i - 1].size(); j++){\n\t\t\tint x = mp[i - 1][j].first, y = mp[i - 1][j].second;\n\t\t\tif (y > 0 && s[i] == '0'){\n\t\t\t\tint tx = x + 1, ty = y - 1;\n\t\t\t\tjoin(tx, ty, i);\n\t\t\t}\n\t\t\tif (x > 0 && s[i] == '1'){\n\t\t\t\tint tx = x - 1, ty = y + 1;\n\t\t\t\tjoin(tx, ty, i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = n; i >= 0; i--)\n\t\tfor (int j = n; j >= 0; j--)\n\t\t\tdp[i][j] = min(dp[i][j], min(dp[i + 1][j], dp[i][j + 1]));\n\t\n\tf[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; k <= i - j; k++){\n\t\t\t\tint t = i - j - k;\n\t\t\t\tif (dp[k][t] > n - j) continue;\n\t\t\t\tif (j > 0){\n\t\t\t\t\tif (s[n - j + 1] == '0'){\n\t\t\t\t\t\tf[j][k][t] = f[j - 1][k][t];\n\t\t\t\t\t\tif (t > 0) f[j][k][t] = (f[j][k][t] + f[j][k][t - 1]) % P;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tf[j][k][t] = f[j - 1][k][t];\n\t\t\t\t\t\tif (k > 0) f[j][k][t] = (f[j][k][t] + f[j][k - 1][t]) % P;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (k > 0) f[j][k][t] = f[j][k - 1][t];\n\t\t\t\t\tif (t > 0) f[j][k][t] = (f[j][k][t] + f[j][k][t - 1]) % P;\n\t\t\t\t}\n\t\t\t\tif (j > 0){\n\t\t\t\t\tif (s[n - j + 1] == '0' && dp[k + 1][t] <= n - (j - 1)) continue;\n\t\t\t\t\tif (s[n - j + 1] == '1' && dp[k][t + 1] <= n - (j - 1)) continue;\n\t\t\t\t}\n\t\t\t\tans = (ans + f[j][k][t]) % P;\n\t\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a< b) { a= b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b< a) { a= b; return true; } return false; }\n\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\nconst int mod= 998244353, MAX= 305, INF= 1<< 30;\nbool dp[MAX][MAX][MAX];\nll dp2[MAX][MAX][MAX];\n\nint main() {\n\n\tstd::ifstream in(\"text.txt\");\n\tstd::cin.rdbuf(in.rdbuf());\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring S; cin>>S;\n\tint N= si(S);\n\tdp[0][0][0]= 1;\n\n\tfor (int i= 0; i< N; i++) {\n\t\tfor (int j= 0; j<= N; j++) {\n\t\t\tfor (int k= 0; k<= N; k++) {\n\t\t\t\tif (dp[i][j][k]== 0) continue;\n\n\t\t\t\tif (i+ 1< N) {\n\t\t\t\t\tif (S[i]== '0') dp[i+ 2][j+ 1][k]= 1;\n\t\t\t\t\telse dp[i+ 2][j][k+ 1]= 1;\n\n\t\t\t\t\tif (S[i+ 1]== '0') dp[i+ 2][j+ 1][k]= 1;\n\t\t\t\t\telse dp[i+ 2][j][k+ 1]= 1;\n\n\t\t\t\t\tdp[i+ 1][j][k]= 1;\n\t\t\t\t}\n\n\t\t\t\tif (j&&S[i]== '1') dp[i+ 1][j- 1][k+ 1]= 1;\n\t\t\t\tif (k&&S[i]== '0') dp[i+ 1][j+ 1][k- 1] =1;\n\t\t\t\tif (j||k) dp[i+ 1][j][k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(all(S));\n\tdp2[0][0][0]= 1;\n\n\tfor (int i= 0; i< N; i++) {\n\t\tfor (int j= 0; j<= N; j++) {\n\t\t\tfor (int k= 0; k<= N; k++) {\n\t\t\t\tif (S[i]== '0') {\n\t\t\t\t\tdp2[i][j][k+ 1] += dp2[i][j][k];\n\t\t\t\t\tdp2[i][j][k+ 1] %= mod;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp2[i][j+ 1][k]+= dp2[i][j][k];\n\t\t\t\t\tdp2[i][j+ 1][k]%= mod;\n\t\t\t\t}\n\t\t\t\tdp2[i+ 1][j][k]+= dp2[i][j][k];\n\t\t\t\tdp2[i+ 1][j][k]%= mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans= 0;\n\n\tfor (int i= 0; i< N; i++) {\n\t\tfor (int j= 0; j<= N; j++) {\n\t\t\tfor (int k= 0; k<= N; k++) {\n\t\t\t\tif (dp[i][j][k]) {\n\t\t\t\t\tans+= dp2[N- i][j][k];\n\t\t\t\t\tans%= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<=int(r);i++)\n#define rep(i,r) for(int i=0;i<int(r);i++)\n#define rrng(i,l,r) for(int i=int(r);i>=int(l);i--)\n#define rrep(i,r) for(int i=int(r)-1;i>=0;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint gcd(int x,int y){\n\tif(x<y)swap(x,y);\n\tif(x%y==0)return y;\n\treturn gcd(y,x%y);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\nstring s;\nbool can[605][605][605];\nint n,sumz[605],sumo[605],mx[605][605];\nMint dp[605][605][605],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>s;\n\tn=si(s);\n\tif(n==1){\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\tcan[0][0][0]=true;\n\tfor(int i=0;i<=n;i++){\n\t\tif(s[i]=='0')sumz[i]++;\n\t\telse sumo[i]++;\n\t\tif(i>0){\n\t\t\tsumz[i]+=sumz[i-1];\n\t\t\tsumo[i]+=sumo[i-1];\n\t\t}\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!can[i][j][k])continue;\n\t\t\t\tif(i+1<si(s)){\n\t\t\t\t\tif(s[i]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t\tif(s[i+1]=='0')can[i+2][j+1][k+1]=true;\n\t\t\t\t\telse can[i+2][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(i>0){\n\t\t\t\t\tif(sumz[i-1]>k)can[i+1][j+1][k+1]=true;\n\t\t\t\t\tif(sumo[i-1]>j-k)can[i+1][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tint x=sumz[i-1]-k,y=sumo[i-1]-(j-k);\n\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<x<<' '<<y<<endl;\n\t\t\t\tif(x>1){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t}\n\t\t\t\tif(x>0&&y>0){\n\t\t\t\t\tcan[i][j+1][k+1]=true;\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t\tif(y>1){\n\t\t\t\t\tcan[i][j+1][k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tmx[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(can[i][j][k]){\n\t\t\t\t\t//cout<<i<<' '<<j<<' '<<k<<endl;\n\t\t\t\t\tchmax(mx[j][k],i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[n][0][0]=1;\n\tfor(int i=n;i>0;i--){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(s[i-1]=='0'){\n\t\t\t\t\tdp[i-1][j+1][k]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j][k+1]+=dp[i][j][k];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i-1][j][k+1]+=dp[i][j][k];\n\t\t\t\t\tdp[i][j+1][k]+=dp[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tdp[i][j][k]+=dp[i-1][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(mx[i][j]==-1)continue;\n\t\t\tint x=sumz[n-1]-j,y=sumo[n-1]-(i-j);\n\t\t\t//cout<<mx[i][j]<<' '<<x<<' '<<y<<' '<<dp[mx[i][j]][x][y]<<endl;\n\t\t\tans+=dp[mx[i][j]][x][y];\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 305;\nconst int MAX_X = 155;\n\nModint dp [MAX_N][MAX_N][MAX_N];\nint arr [MAX_N];\nbitset<MAX_X> pdp [MAX_N][MAX_N][MAX_N];\n// <position, # taken, # 0>\n\nint main () {\n  string s;\n  cin >> s;\n\n  int n = s.size();\n  for (int i = 0; i < n; i++) {\n    arr[i] = s[i] - '0';\n  }\n\n  dp[0][n][0] = Modint(1);\n  for (int i = 0; i < n; i++) {\n    for (int j = n; j >= 1; j--) {\n      for (int k = 0; k < n; k++) {\n        if (arr[j - 1] == 0) {\n          dp[i + 1][j - 1][k] += dp[i][j][k];\n          dp[i + 1][j][k] += dp[i][j][k];\n        } else {\n          dp[i + 1][j - 1][k] += dp[i][j][k];\n          dp[i + 1][j][k + 1] += dp[i][j][k];\n        }\n      }\n    }\n  }\n\n  pdp[0][0][0][0] = 1;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = 0; k < n; k++) {\n        if (pdp[i][j][k].any()) {\n          pdp[i + 1][j][k] |= pdp[i][j][k];\n          pdp[i + 2][j][k] |= pdp[i][j][k] << 1;\n          pdp[i + 2][j + 1][k + (arr[i] == 0)] |= pdp[i][j][k];\n          pdp[i + 2][j + 1][k + (arr[i + 1] == 0)] |= pdp[i][j][k];\n          pdp[i + 1][j + 1][k + (arr[i] == 0)] |= pdp[i][j][k] >> 1;\n        }\n      }\n    }\n  }\n  \n  Modint ans (0);\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= n; j++) {\n      for (int k = 0; k <= n; k++) {\n        if (pdp[i][j][k].any()) {\n          // cerr << \" \" << i << \" \" << k << \" \" << j - k << \" | \" << dp[n - i + j][i][k] << endl;\n          ans += dp[n - i + j][i][k];\n        }\n      }\n    }\n  }\n\n  cout << ans - Modint(1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <functional>\n#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst int N = 300 + 7;\nconst int M = 998244353;\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint sum(int a, int b) {\n  int c = a + b;\n  if (c >= M) c -= M;\n  if (c < 0) c += M;\n  return c;\n}\n\nvoid add(int &a, int b) {\n  a = sum(a ,b);\n}\n\nbool dp[N][N][N];\nint vals[N][N][N];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int n = (int) s.size();\n  dp[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int x = n; x >= 0; x--) {\n      for (int y = n; y >= 0; y--) {\n        if (!dp[i][x][y]) continue;\n        if (x + y >= 2) {\n          if (x)\n            dp[i][x - 1][y] = true;\n          if (y)\n            dp[i][x][y - 1] = true;\n        }\n        if (x && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x][y] = true;\n          } else {\n            dp[i + 1][x - 1][y + 1] = true;\n          }\n        }\n        if (y && i < n) {\n          if (s[i] == '0') {\n            dp[i + 1][x + 1][y - 1] = true;\n          } else {\n            dp[i + 1][x][y] = true;\n          }\n        }\n        if (i + 1 < n) {\n          if (s[i] == s[i + 1]) {\n            if (s[i] == '0') {\n              dp[i + 2][x + 1][y] = true;\n            } else {\n              dp[i + 2][x][y + 1] = true;\n            }\n          } else {\n            dp[i + 2][x + 1][y] = true;\n            dp[i + 2][x][y + 1] = true;\n          }\n        }\n      }\n    }\n  }\n  vals[n][0][0] = 1;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (x + 1 <= n) {\n          if (!i || s[i - 1] != '0')\n            add(vals[i][x + 1][y], vals[i][x][y]);\n          else\n            add(vals[i - 1][x + 1][y], vals[i][x][y]);\n        }\n        if (y + 1 <= n) {\n          if (!i || s[i - 1] != '1')\n            add(vals[i][x][y + 1], vals[i][x][y]);\n          else\n            add(vals[i - 1][x][y + 1], vals[i][x][y]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (i) add(vals[i][x][y], vals[i - 1][x][y]);\n      }\n    }\n  }\n  vector <int> pa(n + 1), pb(n + 1);\n  int a = 0, b = 0;\n  for (int i = n; i >= 0; i--) {\n    if (i < n && s[i] == '0') a++;\n    if (i < n && s[i] == '1') b++;\n    pa[i] = a, pb[i] = b;\n  }\n  auto cost = [&] (int i, int a, int b) {\n    a += pa[i], b += pb[i];\n    int sum = vals[i][a][b];\n    return sum;\n  };\n  int ans = 0;\n  for (int i = n; i >= 0; i--) {\n    for (int x = 0; x <= n; x++) {\n      for (int y = 0; y <= n; y++) {\n        if (dp[i][x][y]) {\n          int cur = 0;\n          add(cur, cost(i, x, y));\n          if (i) {\n            if (s[i - 1] == '0' && x && dp[i - 1][x - 1][y]) {\n              add(cur, -cost(i - 1, x - 1, y));\n            }\n            if (s[i - 1] == '1' && y && dp[i - 1][x][y - 1]) {\n              add(cur, -cost(i - 1, x, y - 1));\n            }\n          }\n          add(ans, cur);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst int kMaxN = 330;\nconst int mod = 998244353;\nstring s;\nint n;\n\ninline void Add(int &a, int b) {\n\ta += b;\n\tif (a >= mod) { a -= mod; }\n}\n\nbool pref_ok[kMaxN][kMaxN][kMaxN];\nint dp[kMaxN][kMaxN][kMaxN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\n\tcin >> s;\n\tn = SZ(s);\n\n\tpref_ok[0][0][0] = true;\n\tfor (int len = 0; len <= n; ++len) {\n\t\tpref_ok[len][0][0] = true;\n\t\tfor (int a = 0; a <= len; ++a) {\n\t\t\tfor (int b = 0; b <= len; ++b) {\n\t\t\t\tif (!pref_ok[len][a][b]) { continue; }\n\t\t\t\tdebug() << imie(len) << imie(a) << imie(b) << \"ok\";\n\t\t\t\tif (len) {\n\t\t\t\t\tpref_ok[len + 1][a][b] = true;\n\t\t\t\t}\n\t\t\t\tif (len < n) {\n\t\t\t\t\tif (a) {\n\t\t\t\t\t\tconst int new_a = a - 1 + (s[len] == '0');\n\t\t\t\t\t\tconst int new_b = b + (s[len] == '1');\n\t\t\t\t\t\tpref_ok[len + 1][new_a][new_b] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tconst int new_a = a + (s[len] == '0');\n\t\t\t\t\t\tconst int new_b = b - 1 + (s[len] == '1');\n\t\t\t\t\t\tpref_ok[len + 1][new_a][new_b] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (len < n - 1) {\n\t\t\t\t\t\tpref_ok[len + 2][a + (s[len] == '0')][b + (s[len] == '1')] = true;\n\t\t\t\t\t\tpref_ok[len + 2][a + (s[len+1] == '0')][b + (s[len+1] == '1')] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpref_ok[n][0][0] = false;\n\n\tint ans = 0;\n\n\tdp[0][0][0] = 1;\n\tfor (int suf = 0; suf <= n; ++suf) {\n\t\tfor (int add0 = 0; suf + add0 <= n; ++add0) {\n\t\t\tfor (int add1 = 0; suf + add0 + add1 <= n; ++add1) {\n\t\t\t\tif (!dp[suf][add0][add1]) { continue; }\n\t\t\t\tdebug() << imie(suf) << imie(add0) << imie(add1) << dp[suf][add0][add1] <<\n\t\t\t\t  \" \" << pref_ok[n - suf][add0][add1];\n\t\t\t\tif (pref_ok[n - suf][add0][add1]) {\n\t\t\t\t\tAdd(ans, dp[suf][add0][add1]);\n\t\t\t\t}\n\n\t\t\t\tchar ch = -1;\n\t\t\t\tif (suf < n) {\n\t\t\t\t\tch = s[n - suf - 1];\n\t\t\t\t}\n\n\t\t\t\t// add 0\n\t\t\t\tif (ch == '0') {\n\t\t\t\t\tAdd(dp[suf + 1][add0][add1], dp[suf][add0][add1]);\n\t\t\t\t} else {\n\t\t\t\t\tAdd(dp[suf][add0 + 1][add1], dp[suf][add0][add1]);\n\t\t\t\t}\n\n\t\t\t\t// add 1\n\t\t\t\tif (ch == '1') {\n\t\t\t\t\tAdd(dp[suf + 1][add0][add1], dp[suf][add0][add1]);\n\t\t\t\t} else {\n\t\t\t\t\tAdd(dp[suf][add0][add1 + 1], dp[suf][add0][add1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    string s;\n    cin >> s;\n\n    int cur = 1;\n    char t = s[0];\n\n    vector <int> a;\n\n    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] != t) {\n            a.app(cur);\n            cur = 1;\n            t = s[i];\n        }   \n        else {\n            ++cur;\n        }   \n    }\n    a.app(cur);\n\n    #ifdef HOME\n    for (auto e : a)\n        cout << e << ' ';\n    cout << endl;                \n    #endif\n\n    int ans = 1;\n    for (auto e : a) {\n        ans = mod(ans * (e + 1));\n    }   \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nchar s[305];\nint n,dp[305][305][305],ans=0,vis[305][305],sum[2][305],add[2][305][305][305];\nint sump[305][305][305];\nint cr[305][305][305];\nconst int mod=998244353;\nint M(int x){return x>=mod?x-mod:x;}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum[0][i]=sum[0][i-1];\n\t\tsum[1][i]=sum[1][i-1];\n\t\tif(s[i]=='0')sum[0][i]++;\n\t\telse sum[1][i]++;\n\t}\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=i;j++)for(int k=0;k<=i-j;k++)cr[i][j][k]=-2;\n\tcr[0][0][0]=0;\n\tvis[sum[0][n]][sum[1][n]]=1;\n\t//w/b\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=i-j;k++)\n\t\t\t{\n\t\t\t\tif(cr[i][j][k]==-2)continue;\n\t\t\t\tif(j+k&&cr[i][j][k]>=0)vis[j+sum[0][n]-sum[0][i]][k+sum[1][n]-sum[1][i]]=i+1;\n\t\t\t\tif(cr[i][j][k]==-1)cr[i+1][j][k]=max(cr[i+1][j][k],0);\n\t\t\t\telse cr[i+1][j][k]=max(cr[i+1][j][k],cr[i][j][k]+1);\n\t\t\t\tif(i<n&&cr[i][j][k]>-1)\n\t\t\t\t{\n\t\t\t\t\tif(s[i+1]=='0')cr[i+1][j+1][k]=max(cr[i+1][j+1][k],max(-1,cr[i][j][k]-1-(cr[i][j][k]%2==0)));\n\t\t\t\t\telse cr[i+1][j][k+1]=max(cr[i+1][j][k+1],max(-1,cr[i][j][k]-1-(cr[i][j][k]%2==0)));\n\t\t\t\t\tif(cr[i][j][k]>0&&cr[i][j][k]%2==0&&i<n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i+1]=='0')cr[i+2][j+1][k]=max(cr[i+2][j+1][k],cr[i][j][k]);\n\t\t\t\t\t\telse cr[i+2][j][k+1]=max(cr[i+2][j][k+1],cr[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(j)add[0][i][j][k]=M(add[0][i][j][k]+add[0][i][j-1][k]);\n\t\t\t\tif(k)add[1][i][j][k]=M(add[1][i][j][k]+add[1][i][j][k-1]);\n\t\t\t\tdp[i][j][k]=M(dp[i][j][k]+M(add[0][i][j][k]+add[1][i][j][k]));\n\t\t\t\tsump[i][j][k]=M(sump[i][j][k]+dp[i][j][k]);\n\t\t\t\tsump[i][j+1][k]=M(sump[i][j+1][k]+sump[i][j][k]);\n\t\t\t\tsump[i][j][k+1]=M(sump[i][j][k+1]+sump[i][j][k]);\n\t\t\t\tif(i==n)continue;\n\t\t\t\tif(s[n-i]=='0')add[1][i+1][j][k]=M(add[1][i+1][j][k]+dp[i][j][k]);\n\t\t\t\telse add[0][i+1][j][k]=M(add[0][i+1][j][k]+dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"@%d\\n\",dp[2][0][0]);\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(i==0&&j==0)continue;\n\t\t\tif(!vis[i][j])continue;\n\t\t\t//printf(\"%d %d %d %d\\n\",i,j,vis[i][j],sump[n-vis[i][j]+1][i-sum[0][n]+sum[0][vis[i][j]-1]][j-sum[1][n]+sum[1][vis[i][j]-1]]);\n\t\t\tans=M(ans+sump[n-vis[i][j]+1][i-sum[0][n]+sum[0][vis[i][j]-1]][j-sum[1][n]+sum[1][vis[i][j]-1]]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt () : x(0) {}\n\tModInt (int64_t x) : x(x >= 0 ? x % mod : (mod - -x % mod) % mod) {}\n\tModInt &operator += (const ModInt &p){\n\t\tif ((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator -= (const ModInt &p) {\n\t\tif ((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator *= (const ModInt &p) {\n\t\tx = (int64_t) x * p.x % mod;\n\t\treturn *this;\n\t}\n\tModInt &operator /= (const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator ^= (int64_t p) {\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator - () const { return ModInt(-x); }\n\tModInt operator + (const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator - (const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator * (const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator / (const ModInt &p) const { return ModInt(*this) /= p; }\n\tModInt operator ^ (int64_t p) const { return ModInt(*this) ^= p; }\n\tbool operator == (const ModInt &p) const { return x == p.x; }\n\tbool operator != (const ModInt &p) const { return x != p.x; }\n\texplicit operator int() const { return x; }\n\tModInt &operator = (const int p) { x = p; return *this;}\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile (b > 0) {\n\t\t\tt = a / b;\n\t\t\ta -= t * b;\n\t\t\tstd::swap(a, b);\n\t\t\tu -= t * v;\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream & operator << (std::ostream &stream, const ModInt<mod> &p) {\n\t\treturn stream << p.x;\n\t}\n\tfriend std::istream & operator >> (std::istream &stream, ModInt<mod> &a) {\n\t\tint64_t x;\n\t\tstream >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn stream;\n\t}\n};\n\ntemplate<int mod> struct MComb {\n\tusing mint = ModInt<mod>;\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (mod - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\ntypedef ModInt<998244353> mint;\n\nint main() {\n\tstd::string s;\n\tstd::cin >> s;\n\tint n = s.size();\n\t\n\tstd::vector<std::vector<int> > ok(n + 1, std::vector<int>(n + 1, -1)); // white, black : max start\n\t{\n\t\tstd::vector<std::vector<std::vector<int> > > dp(n + 1, std::vector<std::vector<int> >(n + 1, std::vector<int>(n + 1, -1)));\n\t\tdp[0][0][0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dp[i][j][k] == -1) continue;\n\t\t\t\t\tauto go = [&] (int i, int j, int k, int val) {\n\t\t\t\t\t\tdp[i][j][k] = std::max(dp[i][j][k], val);\n\t\t\t\t\t};\n\t\t\t\t\tint stock = dp[i][j][k];\n\t\t\t\t\t// normal use\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i] == '0'), k + (s[i] == '1'), stock);\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j + (s[i + 1] == '0'), k + (s[i + 1] == '1'), stock);\n\t\t\t\t\t// use stock\n\t\t\t\t\tif (stock) go(i + 1, j + (s[i] == '0'), k + (s[i] == '1'), stock - 1);\n\t\t\t\t\t// stock\n\t\t\t\t\tif (i + 1 < n) go(i + 2, j, k, stock + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[n][0][0] = -1; // special\n\t\tint sum[n + 1][2];\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = 0; i < n; i++) sum[i + 1][s[i] - '0']++;\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < 2; j++) sum[i + 1][j] += sum[i][j];\n\t\t\n\t\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != -1) {\n\t\t\tint white = j + sum[n][0] - sum[i][0];\n\t\t\tint black = k + sum[n][1] - sum[i][1];\n\t\t\tok[white][black] = std::max(ok[white][black], i);\n\t\t}\n\t}\n\t\n\tstd::reverse(s.begin(), s.end());\n\tmint dp[n + 1][n + 1][n + 1]; // pos, white, black\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) if (dp[i][j][k] != 0) {\n\t\tif (j < n) dp[i + (i < n && s[i] == '0')][j + 1][k] += dp[i][j][k];\n\t\tif (k < n) dp[i + (i < n && s[i] == '1')][j][k + 1] += dp[i][j][k];\n\t}\n\t\n\tmint res = 0;\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) {\n\t\tif (ok[i][j] == -1) continue;\n\t\tint len = n - ok[i][j];\n\t\t// dp[len...][i][j]\n\t\tfor (int k = len; k <= n; k++) res += dp[k][i][j];\n\t}\n\tstd::cout << res - 1 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n// Modular template copied from tourist\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint dp[301][301][301];\nint can[310][310][310];\nint can2[310][310];\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  //dp[i][ones][zeros] = number of strings, using i from end\n  dp[0][0][0] = 1;\n  for (int i = 0; i <= n; i++) {\n    for (int ones = 0; ones <= n; ones++) {\n      for (int zeros = 0; zeros <= n; zeros++) {\n\tif (i) dp[i][ones][zeros] += dp[i-1][ones][zeros];\n\tif (!i || s[n-i] == '0') {\n\t  if (ones) dp[i][ones][zeros] += dp[i][ones-1][zeros];\n\t}\n\tif (!i || s[n-i] == '1') {\n\t  if (zeros) dp[i][ones][zeros] += dp[i][ones][zeros-1];\n\t}\n      }\n    }\n  }\n\n\n  can[0][0][0] = 1;\n  for (int p = 0; p <= n; p++) {\n    for (int ones = n; ones >= 0; ones--) {\n      for (int zeros = n; zeros >= 0; zeros--) {\n\tif (!can[p][ones][zeros]) continue;\n\t//Take 0\n\tif (ones >= 2) can[p][ones-1][zeros] = 1;\n\tif (zeros >= 2) can[p][ones][zeros-1] = 1;\n\tif (ones && zeros) {\n\t  can[p][ones-1][zeros] = 1;\n\t  can[p][ones][zeros-1] = 1;\n\t}\n\n\t//Take 1\n\tif (ones && p < n) can[p+1][ones-1+(s[p]=='1')][zeros+(s[p]=='0')] = 1;\n\tif (zeros && p < n) can[p+1][ones+(s[p]=='1')][zeros-1+(s[p]=='0')] = 1;\n\n\t//Take 2\n\tif (p+2 <= n) {\n\t  can[p+2][ones+(s[p]=='1')][zeros+(s[p]=='0')] = 1;\n\t  can[p+2][ones+(s[p+1]=='1')][zeros+(s[p+1]=='0')] = 1;\n\t}\n\t//cout << p << ' ' <<  ones << ' ' << zeros << endl;\n      }\n    }\n  }\n  vector<array<int,2>> acc(n+1);\n  for (int i = 0; i < n; i++) {\n    acc[i+1] = {acc[i][0]+(s[i] == '0'),\n\t\tacc[i][1]+(s[i] == '1')};\n  }\n  for (int p = 0; p <= n; p++) {\n    for (int ones = 0; ones <= n; ones++) {\n      for (int zeros = 0; zeros <= n; zeros++) {\n\tif (can[p][ones][zeros]) {\n\t  int step = p-ones-zeros;\n\t  int ones_ = acc[p][1]-ones;\n\t  can2[step][ones_] = max(can2[step][ones_], p+1);\n\t}\n      }\n    }\n  }\n  //p-(ones+zeros) = step;\n  Mint ans = 0;\n  for (int step = 0; step < n; step++) {\n    for (int ones_ = 0; ones_ <= n; ones_++) {\n      int p = can2[step][ones_]-1;\n      if (p >= 0) {\n\t//cout << \"OK\" << endl;\n\tint ones = acc[p][1]-ones_;\n\tint zeros = p-step-ones;\n\tassert(ones >= 0 && ones <= n);\n\tassert(zeros >= 0 && zeros <= n);\n\tassert(can[p][ones][zeros]);\n\t//cout << step << ' ' << p << ' ' << ones << ' ' << zeros << ' ' << dp[n-p][ones][zeros] << endl;\n\tans += dp[n-p][ones][zeros];\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\n// const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tRing r = 1;\n\t\tRing x; x.value = value;\n\t\twhile (p) {\n\t\t\tif (p & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tp /= 2;\n\t\t}\n\t\treturn r;\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue -= (value >= MOD) * MOD;\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue += (value < 0) ? MOD : 0;\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nstring s;\n\nvector<string> perform(string s, int steps) {\n\tvector<string> v{s};\t\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = 0; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t}\n\treturn v;\n}\n\nvector<string> perform2(string s, int steps) {\n\tvector<string> v{s};\n\tint adj = steps * 2;\n\tf(i, steps) {\n\t\tvector<string> u;\n\t\tfor (string s : v) {\n\t\t\tchar a = s[0]; char b = s[1];\n\t\t\ts.erase(s.begin());\n\t\t\ts.erase(s.begin());\n\t\t\tfor (char c : {a, b}) {\n\t\t\t\tfor (int i = adj - 1; i <= le(s); i++) {\n\t\t\t\t\tstring t = s;\n\t\t\t\t\tt.insert(t.begin() + i, c);\n\t\t\t\t\tu.pb(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(u.begin(), u.end());\n\t\tu.resize(unique(u.begin(), u.end()) - u.begin());\n\t\tv = u;\n\t\tadj -= 2;\n\t}\n\treturn v;\n}\n\n// vector<string> perform2(string s, int steps) {\n// \tfor (int i = 0; i < steps; i += 2) {\n\n// \t}\n// }\nconst int N = 310;\nint mem[2 * N][2 * N];\nnum binom(int n, int k) {\n\tif (k > n) return 0;\n\tif (n == 0 || k == 0) return 1;\n\tif (mem[n][k] != -1) return mem[n][k];\n\tmem[n][k] = (binom(n - 1, k - 1) + binom(n - 1, k)).value;\n\treturn mem[n][k];\n}\n\nint mem2[N][N][N];\nnum dp(int i, int a, int b) {\n\tif (a < 0 || b < 0) return 0;\n\tif (i >= le(s)) return binom(a + b, b);\n\tif (mem2[i][a][b] != -1) return mem2[i][a][b];\n\tnum rez = 0;\n\t// place 0\n\t{\n\t\tif (s[i] == '0') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else rez += dp(i, a - 1, b);\n\t}\n\t// place 1\n\t{\n\t\tif (s[i] == '1') {\n\t\t\trez += dp(i + 1, a, b);\n\t\t} else {\n\t\t\trez += dp(i, a, b - 1);\n\t\t}\n\t}\n\tmem2[i][a][b] = rez.value;\n\treturn rez;\n}\n\nint mem3[N][N][N];\nbool obt(int i, vector<int> c) {\n\tif (c[0] < 0 || c[1] < 0) return false;\n\tif (i < 0) return c == vector<int>{0, 0};\n\tif (mem3[i][c[0]][c[1]] != -1) return mem3[i][c[0]][c[1]];\n\tif (i - 1 >= 0) {\n\t\t// rem i - 1\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i - 1] - '0']--;\n\t\t\tif (obt(i - 2, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\tf(in, 2) {\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tnc[s[i] - '0']--;\n\t\t\tnc[in]++;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t\t{\n\t\t\tvector<int> nc = c;\n\t\t\tif (obt(i - 1, nc)) return mem3[i][c[0]][c[1]] = true;\n\t\t}\n\t}\n\treturn mem3[i][c[0]][c[1]] = false;\n}\n\n\nsigned main(signed argc, char *argv[]) {\n\tmemset(mem, -1, sizeof mem);\n\tmemset(mem2, -1, sizeof mem2);\n\tmemset(mem3, -1, sizeof mem3);\n\tscan s;\n\tvector<int> t(2);\n\tf(i, le(s)) {\n\t\tt[s[i] - '0']++;\n\t}\n\tnum rez = 0;\n\tfor (int a = 0; a <= t[0]; a++) {\n\t\tfor (int b = 0; b <= t[1]; b++) {\n\t\t\tif (a + b == 0) continue;\n\t\t\tint c = a; int d = b;\n\t\t\tfor (int i = le(s); i >= 0; i--) {\n\t\t\t\tif (i < le(s)) {\n\t\t\t\t\tif (s[i] == '0') c--;\n\t\t\t\t\telse d--;\n\t\t\t\t}\n\t\t\t\tif (obt(i - 1, {c, d})) {\n\t\t\t\t\t// print i, c, d;\n\t\t\t\t\trez += dp(i, c, d);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <assert.h>\n#include <math.h>\n#include <memory.h>\n#include <stdio.h>\n\n#include <algorithm>\n#include <complex>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define left asdgashgrketwjklrej\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-12\n#define M_PI 3.141592653589793\n#define bsize 1024\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 998244353\n\nconst int N = 500031;\n\nint dp[3][331][331];\nint n;\nstring st;\nint len;\nint C0[N],C1[N];\nint can_get0[N],can_get1[N];\nint can1[331][331],can0[331][331];\nint first_dp[5][331][331];\n\nint count_pairs(int x){\n\treturn (x+1)/2;\n}\n\nint DD(int x){\n\treturn count_pairs(x);\n}\n\nset<string> used;\nset<string>::iterator it;\n\nstring gi(string s,int ps,char c){\n\ts.insert(s.begin()+ps,c);\n\treturn s;\n}\n\nvoid dfs(string st){\n\tused.insert(st);\n\tif (st.size()<2)\n\t\treturn;\n\tstring temp=\"\";\n\tfor (int i=2;i<st.size();i++){\n\t\ttemp+=st[i];\n\t}\n\tfor (int i=0;i<=temp.size();i++){\n\t\tstring temp2=gi(temp,i,st[0]);\n\t\tif (used.find(temp2)==used.end())\n\t\t\tdfs(temp2);\n\t\ttemp2=gi(temp,i,st[1]);\n\t\tif (used.find(temp2)==used.end())\n\t\t\tdfs(temp2);\n\t}\n}\n\nbool cmp(string a,string b){\n\tif (a.size()!=b.size())\n\t\treturn a.size()<b.size();\n\treturn a<b;\n}\n\nint CC[N];\nint CC2[N];\n\nvoid generate(string st){\n\tused.clear();\n\tdfs(st);\n\tvector<string> order;\n\tfor (it=used.begin();it!=used.end();it++){\n//\t\tcout<<(*it)<<endl;\n\t\torder.push_back(*it);\n\t}\n\tsort(order.begin(),order.end(),cmp);\n\tfor (int i=0;i<order.size();i++){\n\t\tcout<<order[i]<<endl;\n\t\tCC[order[i].size()]++;\n\t}\n\n\tcout<<\"!!\"<<order.size()<<endl;\n}\n\nint main() {\n  // freopen(\"input.txt\", \"r\", stdin);\n  // freopen(\"output.txt\", \"w\", sttextdout);\n  ios_base::sync_with_stdio(0);\n  // cin.tie(0);\n\n  cin>>st;\n\n  if (st.size()%2==1)\n\t  return 1;\n\n  //generate(st);\n\n  n=st.size();\n\n  for (int i=0;i<st.size();i++){\n\t  C0[i+1]=C0[i];\n\t  C1[i+1]=C1[i];\n\t  if (st[i]=='0')\n\t\t  C0[i+1]++;\n\t  else\n\t\t  C1[i+1]++;\n  }\n\n  first_dp[0][0][0]=1;\n\n  for (int i=0;i<=n;i++){\n\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[(i+3)%4][j][q]=0;\n\t\t  }\n\t  }\n\n\t  for (int have0=0;have0<=i;have0++){\n\t\t  for (int bonus=0;bonus<=i;bonus++){\n\t\t\t  if (first_dp[i%4][have0][bonus]==0)\n\t\t\t\t  continue;\n\t\t\t  can0[i][have0]=1;\n\t\t\t  // use bonus to grab it\n\t\t\t  if (bonus>0&&i<n&&st[i]=='0')\n\t\t\t\t  first_dp[(i+1)%4][have0+1][bonus-1]=1;\n\t\t\t  // take either of the two\n\t\t\t  if (i<n&&st[i]=='0')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  if (i+1<n&&st[i+1]=='0')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  // bonus either of the two\n\t\t\t  if (i<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\t\t\t  if (i+1<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\n\t\t  }\n\t  }\n  }\n\n  for (int i=0;i<4;i++){\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[i][j][q]=0;\n\t\t  }\n\t  }\n  }\n\n  // CP , same for 1\n\n  first_dp[0][0][0]=1;\n\n\n  for (int i=0;i<=n;i++){\n\n\t  for (int j=0;j<=n;j++){\n\t\t  for (int q=0;q<=n;q++){\n\t\t\t  first_dp[(i+3)%4][j][q]=0;\n\t\t  }\n\t  }\n\n\t  for (int have0=0;have0<=i;have0++){\n\t\t  for (int bonus=0;bonus<=i;bonus++){\n\t\t\t  if (first_dp[i%4][have0][bonus]==0)\n\t\t\t\t  continue;\n\t\t\t  can1[i][have0]=1;\n\t\t\t  // use bonus to grab it\n\t\t\t  if (bonus>0&&i<n&&st[i]=='1')\n\t\t\t\t  first_dp[(i+1)%4][have0+1][bonus-1]=1;\n\t\t\t  // take either of the two\n\t\t\t  if (i<n&&st[i]=='1')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  if (i+1<n&&st[i+1]=='1')\n\t\t\t\t  first_dp[(i+2)%4][have0+1][bonus]=1;\n\t\t\t  // bonus either of the two\n\t\t\t  if (i<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\t\t\t  if (i+1<n)\n\t\t\t\t  first_dp[(i+2)%4][have0][bonus+1]=1;\n\n\t\t  }\n\t  }\n  }\n\n  for (int i=0;i<=n;i++){\n\t  for (int j=0;j<=n;j++){\n\t\t  if (can0[i][j])\n\t\t\t  can_get0[i]=j;\n\t\t  if (can1[i][j])\n\t\t\t  can_get1[i]=j;\n\t  }\n  }\n\n  for (int i=1;i<=n;i++){\n\t  can_get0[i]=max(can_get0[i],can_get0[i-1]);\n\t  can_get1[i]=max(can_get1[i],can_get1[i-1]);\n  }\n\n  /*for (int i=0;i<=n;i++){\n\t  cout<<can_get0[i]<<\" \"<<can_get1[i]<<endl;\n  }\n*/\n\n  int ans=0;\n\n  dp[0][0][0]=1;\n  for (int len=0;len<=n;len++){\n\n\t  if (len>0){\n\t\t  for (int cover=0;cover<=len;cover++){\n\t\t\t  for (int count0=0;count0<=len;count0++){\n\t\t\t\t  if (dp[len%2][cover][count0]==0)\n\t\t\t\t\t  continue;\n\t\t\t\t  int added0=count0-(C0[n]-C0[n-cover]);\n\t\t\t\t  int count1=len-count0;\n\t\t\t\t  int added1=count1-(C1[n]-C1[n-cover]);\n\t\t\t\t  if (can_get0[n-cover]>=added0&&can_get1[n-cover]>=added1&&len<=n-DD(n-cover)){\n\t\t\t\t\t//  if (len==5)\n\t\t\t\t\t//\t  cout<<len<<\" \"<<cover<<\" \"<<count0<<\" \"<<added0<<\" \"<<added1<<\" \"<<dp[len%2][cover][count0]<<endl;\n\t\t\t\t\t  ans+=dp[len%2][cover][count0];\n\t\t\t\t\t  CC2[len]+=dp[len%2][cover][count0];\n\t\t\t\t  }\n\t\t\t\t  ans%=bs;\n\t\t\t  }\n\t\t  }\n\t  }\n\n\t  for (int i=0;i<=300;i++){\n\t\t  for (int j=0;j<=300;j++){\n\t\t\t  dp[1-len%2][i][j]=0;\n\t\t  }\n\t  }\n\n\t  for (int cover=0;cover<=len;cover++){\n\t\t  for (int count0=0;count0<=len;count0++){\n\t\t\t  for (int ad=0;ad<=1;ad++){\n\t\t\t\t  int new_cover=cover;\n\t\t\t\t  int new0=count0+1-ad;\n\t\t\t\t  if (cover<n&&st[n-cover-1]==ad+48)\n\t\t\t\t\t  new_cover++;\n\t\t\t\t  dp[1-len%2][new_cover][new0]+=dp[len%2][cover][count0];\n\t\t\t\t  dp[1-len%2][new_cover][new0]%=bs;\n\t\t\t  }\n\t\t  }\n\t  }\n\n  }\n\n  cout<<ans<<endl;\n\n  /*for (int i=0;i<=n;i++){\n\t  cout<<i<<\" \"<<CC[i]<<\"   \"<<CC2[i]<<endl;\n  }*/\n  //cout<<n<<endl;\n\n  cin.get(); cin.get();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD2 1000000007\n#define MOD 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nbool ok[330][330][330]; // pos one two\nInt cnt[330][330][330];\nInt exact[330][330][330];\nstring s;\n\nInt ans;\n\nint main()\n{\n    cin >> s;\n    int n = s.size();\n    for (int i = 0; i <= n; i++) {\n        for (int j = n; j >= 0; j--) {\n            for (int k = n; k >= 0; k--) {\n                if (i == 0 && j == 0 && k == 0)\n                    ok[i][j][k] = true;\n                if (i + 1 < n && (s[i] == '0' || s[i + 1] == '0')) {\n                    ok[i + 2][j + 1][k] |= ok[i][j][k];\n                }\n                if (i + 1 < n && (s[i] == '1' || s[i + 1] == '1')) {\n                    ok[i + 2][j][k + 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '0' && k > 0) {\n                    ok[i + 1][j + 1][k - 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '1' && k > 0) {\n                    ok[i + 1][j - 1][k + 1] |= ok[i][j][k];\n                }\n                if (j)\n                    ok[i][j - 1][k] |= ok[i][j][k];\n\n                if (k)\n                    ok[i][j][k - 1] |= ok[i][j][k];\n            }\n        }\n    }\n\n    exact[n][0][0] = 1;\n\n    for (int one = 0; one <= n; one++) {\n        for (int zero = 0; zero <= n; zero++) {\n            int zero_cnt = 0;\n            int one_cnt = 0;\n            for (int pos = n; pos >= 0; pos--) {\n                cnt[pos][one][zero] = 0;\n                if (one)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one - 1][zero] + exact[pos][one - 1][zero];\n                if (zero)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one][zero - 1] + exact[pos][one][zero - 1];\n                if (pos + 1 <= n) {\n                    exact[pos][one][zero] = exact[pos + 1][one][zero];\n                    if (s[pos] == '0' && one > 0) {\n                        exact[pos][one][zero] += exact[pos][one - 1][zero];\n                    }\n                    if (s[pos] == '1' && zero > 0) {\n                        exact[pos][one][zero] += exact[pos][one][zero - 1];\n                    }\n                }\n                cnt[pos][one][zero] %= MOD;\n                exact[pos][one][zero] %= MOD;\n            }\n            if (one == 0 && zero == 0)\n                continue;\n            if (ok[n][zero][one]) {\n                ans += exact[n][one][zero];\n                ans += cnt[n][one][zero];\n                ans %= MOD;\n                //                cout << zero << \" \" << one << \" \" << ans <<\n                //                endl;\n                continue;\n            }\n\n            for (int pos = n - 1; pos >= 0; pos--) {\n\n                if (s[pos] == '0')\n                    zero_cnt++;\n                else\n                    one_cnt++;\n                int need_one = one - one_cnt;\n                int need_zero = zero - zero_cnt;\n                if (need_one < 0 || need_zero < 0)\n                    break;\n                if (ok[pos][need_zero][need_one]) {\n                    ans += exact[pos][need_one][need_zero];\n                    ans += cnt[pos][need_one][need_zero];\n                    ans %= MOD;\n                    //                    cout << pos << \" \" << need_zero << \" \"\n                    //                    << need_one << \" \"\n                    //                       << ans << endl;\n\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n \ntypedef long long ll;\n\ntypedef long double ld;\n \nusing namespace std;\n \nconst ll maxn = 4e2;\nconst ll mod = 998244353;\n\nll n, m, k, t;\n\nbool dp[maxn][maxn][maxn];\n\nll dp1[maxn][maxn][maxn];\n\nll cnt0[maxn];\n\nll cnt1[maxn];\n\nll ans = 0;\n\nstring s;\n\nvoid count_dp() {\n    dp[0][0][0] = 1;\n    ll q, w, e;\n    for (q = 0; q <= n; q++) {\n        for (w = n; w >= 0; w--) { /// cnt of 0s\n            for (e = n; e >= 0; e--) { /// cnt of 1s\n                if (!dp[q][w][e]) {\n                    continue;\n                }\n                dp[q + 1][w][e] = 1;\n                // both from string\n                if (q + 2 <= n) {\n                    if (s[q] == '0' || s[q + 1] == '0') {\n                        dp[q + 2][w + 1][e] = 1;\n                    }\n                    if (s[q] == '1' || s[q + 1] == '1') {\n                        dp[q + 2][w][e + 1] = 1;\n                    }\n                }\n                // both from pocket\n                if (w + e >= 2 && w >= 1) {\n                    dp[q][w - 1][e] = 1;\n                }\n                if (w + e >= 2 && e >= 1) {\n                    dp[q][w][e - 1] = 1;\n                }\n                // one from string, one from pocket, erase from pocket\n                if (q + 1 <= n) {\n                    if (s[q] == '0') {\n                        if (e >= 1) {\n                            dp[q + 1][w + 1][e - 1] = 1;\n                        }\n                        if (w >= 1) {\n                            dp[q + 1][w][e] = 1;\n                        }\n                    }\n                    if (s[q] == '1') {\n                        if (e >= 1) {\n                            dp[q + 1][w][e] = 1;\n                        }\n                        if (w >= 1) {\n                            dp[q + 1][w - 1][e + 1] = 1;\n                        }\n                    }\n                    // one from string, one from pocket, erase from string\n                    if (w + e >= 1) {\n                        dp[q + 1][w][e] = 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid count_dp1() {\n    reverse(all(s));\n    ll q, w, e;\n    for (q = 1; q <= n; q++) {\n        cnt0[q] = cnt0[q - 1] + (s[q - 1] == '0');\n        cnt1[q] = cnt1[q - 1] + (s[q - 1] == '1');   \n    }\n    dp1[0][0][0] = 1;\n    for (q = 0; q < n; q++) {\n        for (w = 0; w <= n; w++) {\n            for (e = 0; e <= n; e++) {\n                dp1[q][w + (s[q] == '1')][e + (s[q] == '0')] += dp1[q][w][e];\n                dp1[q][w + (s[q] == '1')][e + (s[q] == '0')] %= mod;\n                dp1[q + 1][w][e] += dp1[q][w][e];\n                dp1[q + 1][w][e] %= mod;\n                // assert(cnt0[q] >= 0 && cnt1[q] >= 0);\n                // if (q == 2 && w == 2 && e == 0)cout << \"DP1 DEBUG \" << q << \" \" << w << \" \" << e << \" \" << dp1[q][w][e] << endl;\n                // if (q != 0) {\n                //     if (s[q - 1] == '0') {\n                //         // cout << \"KUU \" << q << \" \" << w << \" \" << e << endl;\n                //         // if (dp1[q][w][e] !=)\n                //         // cout << dp1[q - 1][w + 1][e] << endl; \n                //         dp1[q - 1][w + 1][e] -= dp1[q][w][e];\n                //         dp1[q - 1][w + 1][e] += mod;\n                //         dp1[q - 1][w + 1][e] %= mod;\n                //     }\n                //     else {\n                //         dp1[q - 1][w][e + 1] -= dp1[q][w][e];\n                //         dp1[q - 1][w][e + 1] += mod;\n                //         dp1[q - 1][w][e + 1] %= mod;\n                //     }\n                //     // dp1[q][w][e] = (dp1[q][w][e] + mod) % mod;\n                //     // dp1[q][w][e] -= (dp1[q - 1][w][e]);\n                // }\n            }\n        }\n    }\n}\n\nvoid merge() {\n    ll q, w, e;\n    for (q = 0; q <= n; q++) {\n        for (w = 0; w <= n; w++) {\n            for (e = 0; e <= n; e++) {\n                if (dp[q][w][e]) {\n                    // cout << n - q << \" \" << w << \" \" << e << \" \" << dp1[n - q][w][e] << endl;\n                    ans += dp1[n - q][w][e];\n                    ans %= mod;\n                }\n            }\n            // cout << endl;\n        }\n        // cout << endl;\n    }\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    cin >> s;\n    n = s.length();\n    count_dp();\n    count_dp1();\n    merge();\n    cout << (ans - 1 + mod) % mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nstring s;\nint n;\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nconst int MAX = 301;\nint dp[MAX][MAX][MAX];\n\n#ifdef LOCAL\n\nset<string> odp;\nset<string> wyn;\nvector<string> todo;\nvoid dodaj(string a){\n  if(wyn.insert(a).SE){\n    todo.PB(a);\n  }\n//   if(odp.insert(a).SE){\n//     cout << \"MAM\" << \": \" << a << \"\\n\";\n//   }\n}\nvoid brut() {\n//   R(i,SZ(s)){\n//     s[i]+='0';\n//   }\n  dodaj(s);\n  R(i,SZ(todo)){\n    string x = todo[i];\n    if(SZ(x) == 1)continue;\n    string y = x.substr(2);\n    R(k,2)R(j,SZ(y)+1){\n      dodaj(y.substr(0,j) + x[k] + y.substr(j));\n    }\n  }\n  debug(SZ(wyn));\n}\n\n\nint licz(int dl,int zer,int jed){\n  int x = (n - dl) + zer + jed;\n  int res = 0;\n  R(mb,1<<x){\n    int ak = dl;\n    int i = 0;\n    int j = 0;\n    string xx;\n    R(k,x){\n      int pom = (mb >> k) & 1;\n      xx += pom + '0';\n      if(ak != n && s[ak] == pom){\n        ak++;\n      }else{\n        if(pom){\n          j++;\n        }else{\n          i++;\n        }\n      }\n    }\n    if(i == zer && j == jed){\n      assert(odp.insert(xx).SE);\n      if(wyn.insert(xx).SE){\n        cout << \"!!!!!!!! \" << xx << \"\\n\"; \n      }\n      res++;\n    }\n  }\n  return res;\n}\n#else\nint licz(int dl,int zer,int jed){\n  int &res = dp[dl][zer][jed];\n  if(res != -1) return res;\n  res = 0;\n  if(dl != n && s[dl] == 0){\n    add(res, licz(dl+1,zer,jed));\n  }else{\n    if(zer)add(res, licz(dl,zer-1,jed));\n  }\n  if(dl != n && s[dl] == 1){\n    add(res, licz(dl+1,zer,jed));\n  }else{\n    if(jed)add(res, licz(dl,zer, jed-1));\n  }\n  return res;\n}\n#endif\n\nbool vis[MAX][MAX][MAX];\nvoid dfs(int a,int b,int c){\n  if(vis[a][b][c])return;\n  vis[a][b][c] = 1;\n  if(a < n){\n    if(s[a] == 0)\n      b++;\n    else\n      c++;\n    if(b)dfs(a+1,b-1,c);\n    if(c)dfs(a+1,b,c-1);\n  }\n  if(a < n - 1){\n    if(s[a+1] == 0)\n      b++;\n    else\n      c++;\n    if(s[a] == 0 || s[a+1] == 0)\n      dfs(a + 2, b - 1, c);\n    if(s[a] == 1 || s[a+1] == 1)\n      dfs(a + 2, b, c - 1);\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> s;\n  n = SZ(s);\n#ifdef LOCAL\n  brut();\n#endif\n  int res = 0;\n  int zer = 0;\n  int jed = 0;\n\n  R(i,SZ(s)){\n    s[i] -= '0';\n    if(s[i])jed++;else zer++;\n  }\n  R(i,SZ(s) + 1)R(j,SZ(s) + 1)R(k,SZ(s) + 1)dp[i][j][k] = -1;\n  dp[n][0][0] = 1;\n  dfs(0,0,0);\n  R(i,zer+1)R(j, jed+1){\n    if(i == 0 && j == 0)continue;\n    int mam0 = 0;\n    int mam1 = 0;\n    for(int po = n; i >= mam0 && j >= mam1;){\n      if(vis[po][i - mam0][j - mam1]){\n        add(res, licz(po,i - mam0,j - mam1));\n        break;\n      }\n      if(po == 0)break;\n      po--;\n      if(s[po] == 0)\n        mam0++;\n      else\n        mam1++;\n    }\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": " /*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\n\nusing namespace std;\ntemplate<typename T1, typename T2> inline void chkmin(T1 &a, T2 b) {if (a > b) a = b;}\ntemplate<typename T1, typename T2> inline void chkmax(T1 &a, T2 b) {if (a < b) a = b;}\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define all(c) (c).begin(), (c).end()\n#define sz(c) (int)(c).size()\n#define left left228\n#define right right228\n#define y1 y1228\n#define mp make_pair\n#define pb push_back\n#define y2 y2228\n#define rank rank228\nusing ll = long long;\nusing ld = long double;\nconst string FILENAME = \"input\";\nconst int Mod = 998244353;\nconst int MAXN = 305;\n\n\nint sum(int a, int b) {\n\treturn (a + b >= Mod ? a + b - Mod: a + b);\n}\n\nint mul(int a, int b) {\n\treturn (ll)a * b % Mod;\n}\n\n\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= Mod) {\n\t\ta -= Mod;\n\t}\n}\n\n\nint n;\nint f[MAXN][MAXN][MAXN];\nbool g[MAXN][MAXN][MAXN];\nint ans;\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n \t//read(FILENAME);\n\tstring s;\n\tcin >> s;\n\tn = sz(s);\n\tg[0][0][0]=1;\n\tfor (int i=1;i<=n;i++) for (int p0=0;p0<=i;p0++) for (int p1=0;p1<=i;p1++) {\n\t\tg[i][p0][p1]=g[i-1][p0][p1];\n\t\tif (i>=2) {\n\t\t\tif ((s[i-1]=='0'||s[i-2]=='0')&&p0>0) g[i][p0][p1]|=g[i-2][p0-1][p1];\n\t\t\tif ((s[i-1]=='1'||s[i-2]=='1')&&p1>0) g[i][p0][p1]|=g[i-2][p0][p1-1];\n\t\t}\n\t\tif (s[i-1]=='0'&&p0>0) g[i][p0][p1]|=g[i-1][p0-1][p1+1];\n\t\tif (s[i-1]=='1'&&p1>0) g[i][p0][p1]|=g[i-1][p0+1][p1-1];\n\t}\n\tf[0][0][0]=1;\n\tfor (int d=0;d<=n;d++) {\n\t\tfor (int p0=0;p0<=d;p0++) for (int p1=0;p0+p1<=d;p1++) {\n\t\t\tint mt=d-p0-p1;\n\t\t\tif (g[n-mt][p0][p1]) {\n\t\t\t\tadd(ans,f[d][p0][p1]);\n\t\t\t}\n\t\t\tif (d==n) continue;\n\t\t\tchar t=s[n-1-mt];\n\t\t\tif (t=='0') add(f[d+1][p0][p1],f[d][p0][p1]);\n\t\t\telse add(f[d+1][p0+1][p1],f[d][p0][p1]);\n\t\t\tif (t=='1') add(f[d+1][p0][p1],f[d][p0][p1]);\n\t\t\telse add(f[d+1][p0][p1+1],f[d][p0][p1]);\n\t\t}\n\t}\n\tans = sum(ans, Mod - 1);\n\tcout << ans << '\\n';\n\treturn 0;\t \t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nconst long long mod = 998244353;\nchar S[303]; int L;\n\nvoid add(long long& a, long long b)\n{\n\ta += b;\n\tif (a >= mod)\n\t\ta -= mod;\n}\n\npair<int, int> chk[303][303]; bool seen[303][303];\n\nvoid go(int i, int z, int o, int f)\n{\n\tif (seen[L - i + z + o + f][i]){\n\t\tauto& p = chk[L - i + z + o + f][i];\n\t\tif (p.first <= z && z + f <= p.second) return;\n\t\tp.first = min(p.first, z);\n\t\tp.second = max(p.second, z + f);\n\t}\n\telse{\n\t\tseen[L - i + z + o + f][i] = 1;\n\t\tchk[L - i + z + o + f][i] = { z, z + f };\n\t}\n\tif (i == L) return;\n\n\tif (S[i] == '0' && o) go(i + 1, z, o - 1, f + 1);\n\telse if (S[i] == '0' && (z || f)) go(i + 1, z, o, f);\n\n\tif (S[i] == '1' && z) go(i + 1, z - 1, o, f + 1);\n\telse if (S[i] == '1' && (o || f)) go(i + 1, z, o, f);\n\n\tif (i + 1 < L && S[i] == '0' && S[i + 1] == '0') go(i + 2, z + 1, o, f);\n\tif (i + 1 < L && S[i] == '1' && S[i + 1] == '1') go(i + 2, z, o + 1, f);\n\tif (i + 1 < L && S[i] != S[i + 1]) go(i + 2, z, o, f + 1);\n}\n\nlong long D[303][303][303], R[303][303][303];\nint zc[303], oc[303], pin[303];\n\nint main()\n{\n\tscanf (\"%s\", S);\n\twhile (S[L]) L++;\n\tfor (int i = L-1; i >= 0; i--){\n\t\tzc[i] = zc[i + 1];\n\t\toc[i] = oc[i + 1];\n\t\tif (S[i] == '0') zc[i]++;\n\t\tif (S[i] == '1') oc[i]++;\n\t}\n\n\tgo(0, 0, 0, 0);\n\n\tD[L][0][0] = 1;\n\tfor (int i = L; i >= 0; i--){\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tR[i][j][k] = D[i][j][k];\n\t\t\tif (j) add(R[i][j][k], R[i][j - 1][k]);\n\t\t\tif (k) add(R[i][j][k], R[i][j][k - 1]);\n\t\t}\n\t\tfor (int j = 0; j <= i; j++) for (int k = 0; j + k <= i; k++){\n\t\t\tif (i == 0 || S[i - 1] != '0') add(D[i][j + 1][k], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t\tif (i == 0 || S[i - 1] != '1') add(D[i][j][k + 1], D[i][j][k]);\n\t\t\telse add(D[i - 1][j][k], D[i][j][k]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor (int l = 1; l <= L; l++) {\n\t\tmemset(pin, -1, sizeof(pin));\n\t\tfor (int i = 0; i <= L; i++) if (seen[l][i]){\n\t\t\tfor (int j = chk[l][i].first; j <= chk[l][i].second; j++) pin[j + zc[i]] = i;\n\t\t}\n\n\t\tlong long ret = 0;\n\t\tfor (int j = 0; j <= L; j++) if (pin[j] != -1){\n\t\t\tint p = pin[j];\n\t\t\tint z = j - zc[p];\n\t\t\tint o = l - j - oc[p];\n\t\t\tif (o >= 0){\n\t\t\t\tadd(ans, R[p][z][o]);\n\t\t\t\tadd(ret, R[p][z][o]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf (\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Aa^~ kokoro ga pyonpyon suru n jaa^~\n// ZZZXXkXkkkZ!``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ```?Wfpppbpbbpbbpbbbkbkk\n// ppbbbpbbpVr`` `` ` ` ` ` ```` `` ` ` ``  ` ` ` ` ` ` ` ` `  dppbbkkkkkkkkkkqkqkk\n// HkqqqqqkkWr`` ` ` ``` ``` `?G, ` ` ``.JC!```` ` ` `` `` ````(Wpbkkkkkkkkqkkkkkqk\n// mmmmmqqqqpr` `` `` ```````.+zT=`` `` 7TO-.```````` `` `` ```(yppbkkkkkkkkkkkkkkk\n// ggmgmmqqqH$ ``````````....````` `  ````````.`````` `` ``````.yfpppbbbbkkkkqqqqqH\n// gmmmmmqqqkW<```` `````...`````  .,.`  ````....````` ``````` (Wbqqmgmmgmggggggggg\n// qmmmqqqqkkWk.``````````````````` ;:<`` `````.`````````````-_<-?WHHqmmmmmmgmmgggg\n// @@@@@@@gggHH6- ``````````````` `` _ `` ```````````````` ._~~_.`-?Wkqmmmmmmmggg@g\n// @@@@g@gggHY~.-<_- `````````````````````````````````` ._~~(<-``.`.(WHqqqmmggggmmm\n// @@g@gggHH=.`..._<-___..```````````````````````. .-_~~~_(!``-.``.`` OHHWUWHmqHWXW\n// gggggmqK1.``..~.. _<<+-(____..  ````````  ..__~~_((<<!.`.``` .``.`` j0C1XUHmHIdW\n// ggmmqH0!,_``.>`````` _<<;<v<<<++((((((((((<<<<<<~_. (-.``~``.>..```  jOuWHHqHIdH\n// gmmqkW!`(_ J>`    `` ` _~<`_~~~~<<<<<<<~~__````````` ?1. ._`(__```    zXWHg@HkXH\n// gHHWS{``(lJ<!``.``.```(:+>`._`````.` <..`` - ``. `   _ ?&._.I`_`````` .XyVfppppW\n// HHHSv``.(X:_..... _..(;+<!.(<..-.....-.-_..+_`..<.`.`..`_IJd}  .`..````jqg@@@@@@\n// XHWZ{..<Jk~!.`.. (<.-(+>(_.(1.(_..`.`.`.<_.+<_..<<-..._..-zy>.`_`...```.WH@HHHHH\n// bkWt~.-jCz(_..`.(+<.(;< ._-<=_(<_..-....(_.<1<..(<<.`._..-JUS-._.`...```dHmH9VUH\n// WUUO..(f.(c...__+z<-(+~` _-+<_(><..__.`.(<._.z_.(1;_..__.(C(zT-(..`...``(WHR<+Xk\n// kkkk._(_.->..._(z;:_><.._>_+_<(1>_._<...(v<<.(<.(+z<..-_(Z~_<_j+_..`...`(WHKz1ZW\n// @@gR._+_..~..-<+z<<?<>```_.<_.(+1><_;_..(1_:`.<<??1z--(+Z!..<_.j<....`..(bgHAAQX\n// @@mR.(j:..~.._<z!`.(>~``` ~(_.(+<1><><_.(((_`.<__`.<_.(X>...<_.(<.....`.JUWWWyWW\n// @gmH_(zl..(.._+>```<+_````.~>``(+.<?>>_._(<```(<<``(__<>....<.._<.......dXkkkHHH\n// mmqHl(dk_.(_.-=~`.`.1-..._~-1.``_:`(??<_~(`.--.&_.`.<(;<...._.._<..`..._Xg@@@@@@\n// qHkpk(dX<.(;..j_```.(((JJ&a&-~``````.1<_```-(((e+.-(/`(>...._..(<......(Wmggg@@g\n// HVHbWcz><__+_.(_.(dWWHHH@HHc~````````.+~`` (jHMMMHHHm&.?..._<..(<_..._.(WqqHHmHg\n// 0>vWWkzZwl~<o.__`__~X@@HM@Hb ```.`.``. ```` d@@HHH@@K?76...(<..(<_...(_(ppWWWWHq\n// X0XWHKXXw$<(z<.( `` WHHMHHHH_``````````````.WHHMNMHHH_`(...(<_.(z_..._<(fWVC174W\n// XuXWHHWWz>__+z+.!`..??CZYCOX_`````````````.`~.OvTUZUS_`~.._+?_.(_~_.._zjO=1+~+jy\n// kkkkkkkkX:._<z=1(_`` << ``->``.``.``.``.```` ?<`` (v!`._..(??_.(1._.._=dUOOzzzwX\n// @@@@@@@@H<...1O=v<_...__ -_````````````````.`` `` ~.`` :.~+=?~.(;_(...jdQQQQQkkk\n// H@@@@@@@H~...(==>.~~~~~....`.`````````.`````.`........->.(===~~<<.(...(dg@@@@@@@\n// @@@H@@HHH_.__(=l>~.~~~~~....``.``.``.```..`......~~~~~(<_+=l=~_<.->..~_dqggggg@g\n// @H@@@@MHH_._<(=l>...........```````````````.`...~~~~~~+<(=lz=~((j=z_..~jWqmmgggm\n// @@H@@HHWH_._<(lll-.......```.````.``.`..`````........_z<+llZz~(lOO=<...(VYUUUW9Y\n// @@HMMHWZf>~_=:=llw+.`````````.`.```__~~_``.`````.....(z+llOOz_zllOlz~..~<<1+dW>_\n// MMM#MHHWXl~_=>1ltwOl&.`.``.`````.``````````````.````.(llttwtz(OltwOz<..__zwOwwOz\n// HM#HMHUUI<._1z+ttOZttlt&....``.``.`.````.``...``...(zZtttOktzjttttwlz_._<(Xkkkkk\n// HHHmHSZu:(_~+OztttXtttOZZttO+-..............-(+ztOttwttttd0tOZttttwOl<~.(_dMMHHH\n// rvuuXuuI~~<~(uttttwvOwwwkQQHMMHHHHHHHHHMMMNmgey?OwwwrtttwXOtwttttttXtO-~.((wZyyy\n// HHHHHHK>(~(-(dOrtrrl(QgMHMMMHHHHHHHHHHHHHHHH##HMNkX0rrrrXXrd%`` (Ctwwtz_~.<(Wg@H\n// NNNNNHD(~(zo~zXrrrQdHHMMNMHHHHHHHHHHHHHHHHHHHHHH##HNmyrdKkwZ ` _``-zwrt1~~_<(MNM\n// MMMMM#<<_jwr:(Z4QHHMMHMHHHHHHHHHHHHHHHHHHHHHHHHHHHH###NHSXZ>` ~````.OXtt>~._<?MM\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\nll rand_int(ll l, ll r) //[l, r]\n{\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=305;\nconst int mod=998244353;\nint dp[maxn][maxn][maxn];\nbool ok[maxn][maxn][maxn];\nint C[maxn][maxn];\nvoid init()\n{\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    init();\n    string s;\n    cin>>s;\n    int n=s.length();\n    for(int j=0;j<=n;j++)\n    {\n        for(int k=0;k+j<=n;k++)\n            dp[n][j][k]=C[k+j][k];\n    }\n    for(int i=n-1;i>=0;i--)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;k+j<=i;k++)\n            {\n                dp[i][j][k]=(dp[i][j][k]+dp[i+1][j][k])%mod;\n                if(s[i]=='0'&&k)\n                    dp[i][j][k]=(dp[i][j][k-1]+dp[i][j][k])%mod;\n                if(s[i]=='1'&&j)\n                    dp[i][j][k]=(dp[i][j-1][k]+dp[i][j][k])%mod;\n                // dbg(i,j,k,dp[i][j][k]);\n            }\n        }\n    }\n    // for()\n    int ans=0;\n    ok[0][0][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j>=0;j--)\n        {\n            for(int k=i-j;k>=0;k--)\n            {\n                if(j+k)\n                {\n                    ok[i][j][k]|=(ok[i][j+1][k]|ok[i][j][k+1]);// 自交\n                    ok[i][j][k]|=ok[i-1][j][k];// 删除当前字符\n                }\n                if(s[i-1]=='0'&&j)\n                    ok[i][j][k]|=ok[i-1][j-1][k+1];\n                if(s[i-1]=='1'&&k)\n                    ok[i][j][k]|=ok[i-1][j+1][k-1];\n                // 两个字符移进\n                if(i>=2)\n                {\n                    if(j)\n                    {\n                        if(s[i-1]=='0'||s[i-2]=='0') ok[i][j][k]|=ok[i-2][j-1][k];\n                    }\n                    if(k)\n                    {\n                        if(s[i-1]=='1'||s[i-2]=='1') ok[i][j][k]|=ok[i-2][j][k-1];\n                    }\n                }\n                // dbg(i,j,k,ok[i][j][k]);\n            }\n        }\n    }\n    for(int i=n;i>=0;i--)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;k+j<=i;k++)\n            {\n                if(ok[i][j][k])\n                {\n                    ans=(ans+dp[i][j][k])%mod;\n                    vi cnt(2);\n                    for(int l=i-1;l>=0;l--)// 保证不重复\n                    {\n                        cnt[s[l]=='1']++;\n                        if(cnt[0]>j||cnt[1]>k) break;\n                        ok[l][j-cnt[0]][k-cnt[1]]=false;\n                    }\n                    // dbg(i,j,k,dp[i][j][k]);\n                }\n            }\n        }\n    }\n    print(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=305;\nconst int mod=998244353;\nint n,ans;\nchar s[maxn];\nbool f[maxn][maxn][maxn];\nint g[maxn][maxn][maxn],suf[maxn];\n\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint main(){\n\tscanf(\"%s\",s);n=strlen(s);\n\tf[0][0][0]=true;\n\tfor(int i=0;i<n;i++)for(int j=n;j>=0;j--)for(int k=n;k>=0;k--)if(f[i][j][k]){\n\t\tif(i+1<n){\n\t\t\tif(s[i]=='0'||s[i+1]=='0')f[i+2][j+1][k]=true;\n\t\t\tif(s[i]=='1'||s[i+1]=='1')f[i+2][j][k+1]=true;\n\t\t}\n\t\tif(j+k>=2){\n\t\t\tif(j)f[i][j-1][k]=true;\n\t\t\tif(k)f[i][j][k-1]=true;\n\t\t}\n\t\tif(j+k>=1){\n\t\t\tf[i+1][j][k]=true;\n\t\t\tif(s[i]=='0'&&k)f[i+1][j+1][k-1]=true;\n\t\t\tif(s[i]=='1'&&j)f[i+1][j-1][k+1]=true;\n\t\t}\n\t}\n\tg[0][0][n]=1;\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++)for(int i=n;i>=0;i--)if(g[j][k][i]){\n\t\tAdd(g[j+1][k][i-(i>0&&s[i-1]=='0')],g[j][k][i]);\n\t\tAdd(g[j][k+1][i-(i>0&&s[i-1]=='1')],g[j][k][i]);\n\t}\n\tsuf[n]=0;\n\tfor(int i=n-1;i>=0;i--)suf[i]=suf[i+1]+(s[i]=='1');\n\tfor(int j=0;j<=n;j++)for(int k=0;k<=n;k++){\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint cj=j-(n-i-suf[i]),ck=k-suf[i];\n\t\t\tif(cj>=0&&ck>=0&&(f[i][cj][ck]||(i<n&&f[i][cj+1][ck])||(i<n&&f[i][cj][ck+1])||(i==1&&cj==0&&ck==0)))\n\t\t\t\tAdd(ans,g[j][k][i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nbool ok[303][303][303];\nbool ok1[303][303][303];\nll dp[303][303][303];\nint main()\n{\n\tstring s; cin>>s;\n\tint n=s.size();\n\tok[0][0][0]=1;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=n; j>=0; j--){\n\t\t\tfor(int k=n; k>=0; k--){\n\t\t\t\tif(!ok[i][j][k]) continue;\n\t\t\t\tif(j && j+k>=2) ok[i][j-1][k]=1;\n\t\t\t\tif(k && j+k>=2) ok[i][j][k-1]=1;\n\t\t\t\tif(i+1<n && (s[i]=='0' || s[i+1]=='0')){\n\t\t\t\t\tok[i+2][j+1][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i+1<n && (s[i]=='1' || s[i+1]=='1')){\n\t\t\t\t\tok[i+2][j][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && j && s[i]=='1'){\n\t\t\t\t\tok[i+1][j-1][k+1]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && j && s[i]=='0'){\n\t\t\t\t\tok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && k && s[i]=='0'){\n\t\t\t\t\tok[i+1][j+1][k-1]=1;\n\t\t\t\t}\n\t\t\t\tif(i<n && k && s[i]=='1'){\n\t\t\t\t\tok[i+1][j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n; i++) for(int j=0; j<=n; j++) for(int k=0; k<=n; k++) ok1[i][j][k]=ok[i][j][k];\n\tfor(int i=n; i>=1; i--){\n\t\tfor(int j=0; j<=n; j++){\n\t\t\tfor(int k=0; k<=n; k++){\n\t\t\t\tif(!ok1[i][j][k]) continue;\n\t\t\t\tif(s[i-1]=='0' && j) ok1[i-1][j-1][k]=1;\n\t\t\t\telse if(s[i-1]=='1' && k) ok1[i-1][j][k-1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0]=1;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; i+j<=n; j++){\n\t\t\tfor(int k=0; i+j+k<=n; k++){\n\t\t\t\t(dp[i+1][j][k]+=dp[i][j][k])%=MOD;\n\t\t\t\tif(i<n && s[n-1-i]=='0'){\n\t\t\t\t\t(dp[i][j][k+1]+=dp[i][j][k])%=MOD;\n\t\t\t\t}else if(i<n){\n\t\t\t\t\t(dp[i][j+1][k]+=dp[i][j][k])%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0; i<=n; i++){\n\t\tfor(int j=0; i+j<=n; j++){\n\t\t\tfor(int k=0; i+j+k<=n; k++){\n\t\t\t\tif(i+j+k==0) continue;\n\t\t\t\tif(ok1[n-i][j][k]) (ans+=dp[i][j][k])%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nconst ll mod = 998244353;\nbool p[309][309][309];\nll f[309][309];\nll dp[2][309][309];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tstring s;cin>>s;\n\tp[0][0][0]=1;\n\tint n = sz(s);\n\trepA(i,1,n){\n\t\trep(j,301) rep(k,301) p[i][j][k] = p[i-1][j][k];\n\t\tif(s[i-1]=='0'){\n\t\t\trep(k,301) repA(j,1,300) p[i][j][k]|=p[i-1][j-1][k+1];\n\t\t}\n\t\tif(s[i-1]=='1'){\n\t\t\trep(j,301) repA(k,1,300) p[i][j][k]|=p[i-1][j+1][k-1];\n\t\t}\n\t\tif(i>=2&&(s[i-2]=='0'||s[i-1]=='0')){\n\t\t\trep(j,301) rep(k,301) p[i][j+1][k]|=p[i-2][j][k];\n\t\t}\n\t\tif(i>=2&&(s[i-2]=='1'||s[i-1]=='1')){\n\t\t\trep(j,301) rep(k,301) p[i][j][k+1]|=p[i-2][j][k];\n\t\t}\n\t}\n\tint cnt0=0,cnt1=0;\n\tll fns = 0;\n\tint cur = 0;\n\tdp[0][0][0]=1;\n\trep(j,301) rep(k,301) {\n\t\tif(j) dp[0][j][k]+=dp[0][j-1][k];\n\t\tif(k) dp[0][j][k]+=dp[0][j][k-1];\n\t\tdp[0][j][k]%=mod;\n\t}\n\trepD(i,n,0){\n\t\trepA(j,cnt0,300) repA(k,cnt1,300) if(!f[j][k]&&p[i][j-cnt0][k-cnt1]){\n\t\t\tf[j][k]=1;\n\t\t\tfns+=dp[cur][j][k];\n\t\t}\n\t\tif(i){\n\t\t\tif(s[i-1]=='1'){\n\t\t\t\trep(j,301) dp[1-cur][j][0] = 0;\n\t\t\t\trepA(k,1,300) dp[1-cur][0][k] = dp[cur][0][k-1];\n\t\t\t\trepA(j,1,300) repA(k,1,300) dp[1-cur][j][k]=(dp[1-cur][j-1][k]+dp[cur][j][k-1])%mod;\n\t\t\t\tcnt1++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j,301) dp[1-cur][0][j] = 0;\n\t\t\t\trepA(k,1,300) dp[1-cur][k][0] = dp[cur][k-1][0];\n\t\t\t\trepA(j,1,300) repA(k,1,300) dp[1-cur][j][k]=(dp[cur][j-1][k]+dp[1-cur][j][k-1])%mod;\n\t\t\t\tcnt0++;\t\n\t\t\t}\n\t\t\tcur=1-cur;\n\t\t}\n\t}\n\tcout<<(fns+mod-1)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD2 1000000007\n#define MOD 998244353\n#define PRIM 3\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nbool ok[330][330][330]; // pos one two\nInt cnt[330][330][330];\nInt exact[330][330][330];\nstring s;\n\nInt ans;\n\nint main()\n{\n    cin >> s;\n    int n = s.size();\n    for (int i = 0; i <= n; i++) {\n        for (int j = n; j >= 0; j--) {\n            for (int k = n; k >= 0; k--) {\n                if (i == 0 && j == 0 && k == 0)\n                    ok[i][j][k] = true;\n                if (i + 1 < n && (s[i] == '0' || s[i + 1] == '0')) {\n                    ok[i + 2][j + 1][k] |= ok[i][j][k];\n                }\n                if (i + 1 < n && (s[i] == '1' || s[i + 1] == '1')) {\n                    ok[i + 2][j][k + 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '0' && k > 0) {\n                    ok[i + 1][j + 1][k - 1] |= ok[i][j][k];\n                }\n                if (i < n && s[i] == '1' && j > 0) {\n                    ok[i + 1][j - 1][k + 1] |= ok[i][j][k];\n                }\n                ok[i + 1][j][k] |= ok[i][j][k];\n                if (j)\n                    ok[i][j - 1][k] |= ok[i][j][k];\n\n                if (k)\n                    ok[i][j][k - 1] |= ok[i][j][k];\n            }\n        }\n    }\n\n    exact[n][0][0] = 1;\n\n    for (int one = 0; one <= n; one++) {\n        for (int zero = 0; zero <= n; zero++) {\n            int zero_cnt = 0;\n            int one_cnt = 0;\n            for (int pos = n; pos >= 0; pos--) {\n                cnt[pos][one][zero] = 0;\n                if (one)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one - 1][zero] + exact[pos][one - 1][zero];\n                if (zero)\n                    cnt[pos][one][zero] +=\n                        cnt[pos][one][zero - 1] + exact[pos][one][zero - 1];\n                if (pos + 1 <= n) {\n                    exact[pos][one][zero] = exact[pos + 1][one][zero];\n                    if (s[pos] == '0' && one > 0) {\n                        exact[pos][one][zero] += exact[pos][one - 1][zero];\n                    }\n                    if (s[pos] == '1' && zero > 0) {\n                        exact[pos][one][zero] += exact[pos][one][zero - 1];\n                    }\n                }\n                cnt[pos][one][zero] %= MOD;\n                exact[pos][one][zero] %= MOD;\n            }\n            if (one == 0 && zero == 0)\n                continue;\n            if (ok[n][zero][one]) {\n                ans += exact[n][one][zero];\n                ans += cnt[n][one][zero];\n                ans %= MOD;\n                //                cout << zero << \" \" << one << \" \" << ans <<\n                //                endl;\n                continue;\n            }\n\n            for (int pos = n - 1; pos >= 0; pos--) {\n\n                if (s[pos] == '0')\n                    zero_cnt++;\n                else\n                    one_cnt++;\n                int need_one = one - one_cnt;\n                int need_zero = zero - zero_cnt;\n                if (need_one < 0 || need_zero < 0)\n                    break;\n                if (ok[pos][need_zero][need_one]) {\n                    ans += exact[pos][need_one][need_zero];\n                    ans += cnt[pos][need_one][need_zero];\n                    ans %= MOD;\n                    //                    cout << pos << \" \" << need_zero << \" \"\n                    //                    << need_one << \" \"\n                    //                       << ans << endl;\n\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"Ofast\")\n \n// hloya template v26\n \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n \n#include <bits/stdc++.h>\nusing namespace std;\n \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define sqr(x) ((x) * (x))\n \n#define ull unsigned long long\n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n \nvoid bad(string mes = \"NO\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n \nmt19937_64 mt_rand(\n    chrono::system_clock::now().time_since_epoch().count()\n);\n \ntemplate<typename T1, typename T2> inline bool upmax(T1& a, T2 b) { return (a < b ? (a = b, true) : false); }\ntemplate<typename T1, typename T2> inline bool upmin(T1& a, T2 b) { return (b < a ? (a = b, true) : false); }\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n \ntemplate<typename T>\nT gcd (T a, T b) { while (b) { a %= b; swap (a, b); } return a; }\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-12;\nconst int maxn = (int)3e5 + 3, base = 998244353;\nconst ll llinf = 2e18 + 5;\nconst int mod = 1e9 + 7;\n\nint binpow (int a, int n) {\n    int res = 1;\n    while (n) {\n        if (n & 1)\n            res = 1ll * res * a % mod;\n        a = 1ll * a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint dp[305][305][305];\nint f[305][305][305]; \nint cnt0[305], cnt1[305];\n \nvoid add(int& x, int y) {\n    x = (x + y) % base;\n}\n\nint us[600][600];\n\nint main() {\n    // files1;\n    fast_io;\n\n    string s;\n    cin >> s;\n\n    // precalc number of strings from a zers and b ones with max subseq s[i:...]\n    f[s.size()][0][0] = 1;\n\n    for (int i = s.size(); i >= 0; i--) {\n        for (int a = 0; a < 302; a++) {\n            for (int b = 0; b < 302; b++) {\n                // adding 0 \n                {\n                    int ni = i;\n                    if (i > 0 && s[i - 1] == '0') {\n                        ni--;\n                    }\n                    add(f[ni][a + 1][b], f[i][a][b]);\n                }\n                {\n                    int ni = i;\n                    if (i > 0 && s[i - 1] == '1') {\n                        ni--;\n                    }\n                    add(f[ni][a][b + 1], f[i][a][b]);\n                }\n            }\n        }\n    }\n\n\n    for (int i = 0; i < s.size(); i++) {\n        for (int a = 0; a < 302; a++) {\n            for (int b = 0; b < 302; b++) {\n                add(f[i + 1][a][b], f[i][a][b]);\n            }\n        }\n    }\n\n    for (int i = s.size() - 1; i >= 0; i--) {\n        cnt0[i] = cnt0[i + 1] + (s[i] == '0');\n        cnt1[i] = cnt1[i + 1] + (s[i] == '1');\n    }\n\n\n    dp[0][0][0] = 1;\n    queue<tuple<int, int, int>> q;\n    q.push({0, 0, 0});\n\n    int mxsum = 0;\n\n    int ans = 0;\n    while (!q.empty()) {\n        // dp in queue\n\n\n        auto [i, l0, l1] = q.front();\n        q.pop();\n\n\n        // cout << s.substr(i) << '|' << l0 << ' ' << l1 << ' ' << \"+\" << f[i][rl0][rl1] << endl;\n        \n\n        mxsum = max(mxsum, l0 + l1);\n\n        if (s.size() - i + l0 + l1 >= 2) {\n            for (int k0 = 0; k0 <= min(l0, 2); k0++)\n                for (int k1 = 0; k1 <= min(l1, 2) && k0 + k1 <= 2; k1++) {\n                    int ks = 2 - k0 - k1;\n                    if (i + ks > s.size()) {\n                        continue;\n                    }\n\n                    int rk0 = k0, rk1 = k1;\n                    if (ks >= 1) {\n                        rk0 += s[i] == '0';\n                        rk1 += s[i] == '1';\n                    }                   \n                    if (ks >= 2) {\n                        rk0 += s[i + 1] == '0';\n                        rk1 += s[i + 1] == '1';\n                    }\n\n                    if (rk0 > 0) {\n                        // leave 0\n                        int& to = dp[i + ks][l0 - k0 + 1][l1 - k1];\n                        if (to != 1) {\n                            to = 1;\n                            q.push({i + ks, l0 - k0 + 1, l1 - k1});\n                        }\n                    }\n                    if (rk1 > 0) {\n                        int& to = dp[i + ks][l0 - k0][l1 - k1 + 1];\n                        if (to != 1) {\n                            to = 1;\n                            q.push({i + ks, l0 - k0, l1 - k1 + 1});\n                        }\n                    }\n                }    \n        }\n    }\n\n    for (int i = s.size(); i >= 0; i--) {\n        for (int l0 = 0; l0 < 300; l0++)\n            for (int l1 = 0; l1 < 300; l1++) {\n                int rl0 = l0 + cnt0[i];\n                int rl1 = l1 + cnt1[i];\n                if (!us[rl0][rl1] && dp[i][l0][l1]) {\n                    us[rl0][rl1] = 1;\n                    add(ans, f[i][rl0][rl1]);\n                }\n            }\n    }\n\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 305, djq = 998244353;\n\nint n, f[N][N][N], ans;\nchar s[N];\nbool is[N][N][N], can[N][N][N];\n\nint main()\n{\n\tscanf(\"%s\", s + 1); n = strlen(s + 1);\n\tf[0][0][0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; j + k <= i; k++)\n\t\t\t{\n\t\t\t\tf[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k]) % djq;\n\t\t\t\tf[i + 1][j][k + s[n - j] - '0'] =\n\t\t\t\t\t(f[i + 1][j][k + s[n - j] - '0'] + f[i][j][k]) % djq;\n\t\t\t}\n\tis[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; k <= i; k++)\n\t\t\t{\n\t\t\t\tif (i > 1)\n\t\t\t\t{\n\t\t\t\t\tif (j && (s[i] == '0' || s[i - 1] == '0'))\n\t\t\t\t\t\tis[i][j][k] |= is[i - 2][j - 1][k];\n\t\t\t\t\tif (k && (s[i] == '1' || s[i - 1] == '1'))\n\t\t\t\t\t\tis[i][j][k] |= is[i - 2][j][k - 1];\n\t\t\t\t}\n\t\t\t\tif (s[i] == '0' && j) is[i][j][k] |= is[i - 1][j - 1][k + 1];\n\t\t\t\tif (s[i] == '1' && k) is[i][j][k] |= is[i - 1][j + 1][k - 1];\n\t\t\t\tis[i][j][k] |= is[i - 1][j][k];\n\t\t\t}\n\tfor (int i = 1; i <= n; i++) is[i][0][0] = 0;\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; j + k <= i; k++)\n\t\t\t\tcan[i][j][k] = is[n - j][k][i - j - k] ||\n\t\t\t\t\t(j && can[i][j - 1][k + (s[n - j + 1] == '0')]);\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tfor (int k = 0; j + k <= i; k++)\n\t\t\t\tif (can[i][j][k]) ans = (ans + f[i][j][k]) % djq;\n\treturn std::cout << ans << std::endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef int LL;\nconst LL mod=998244353,maxn=3e2+9;\nLL n;\nLL f[maxn][maxn][maxn],g[maxn][maxn][maxn],is[maxn][maxn][maxn];\nchar s[maxn];\nLL add(LL x,LL y){ return x+=y,x>=mod?x-mod:x; }\nLL mul(LL x,LL y){ return 1ll*x*y%mod; }\nvoid chkmax(LL &x,LL y){ x=std::max(x,y); }\nvoid chkmin(LL &x,LL y){ x=std::min(x,y); }\nint main(){\n\tscanf(\" %s\",s+1);\n\t//f[n][0][0]=1;\n\tn=strlen(s+1);\n\tf[n][0][0]=1;\n\tfor(LL i=n;i>=1;--i){\n\t\tfor(LL j=0;j<=n;++j){\n\t\t\tfor(LL k=0;k<=n;++k){\n\t\t\t\tf[i-1][j][k]=add(f[i-1][j][k],f[i][j][k]);\n\t\t\t\tif(s[i]=='0'){\n\t\t\t\t\tf[i][j][k+1]=add(f[i][j][k+1],f[i][j][k]);\n\t\t\t\t}else{\n\t\t\t\t\tf[i][j+1][k]=add(f[i][j+1][k],f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//if(i==3 && !j && !k) printf(\"%d,%d\\n\",f[n][0][0],f[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(g,-1,sizeof(g));\n\tg[0][0][0]=0;\n\tfor(LL i=0;i<=n;++i){\n\t\tfor(LL j=0;j<=i;++j){\n\t\t\tfor(LL k=0;k<=i;++k){\n\t\t\t\tLL tmp(g[i][j][k]);\n\t\t\t\tif(tmp==-1) continue;\n\t\t\t\tif(i+1<=n && tmp){\n\t\t\t\t\tif(s[i+1]=='0') chkmax(g[i+1][j+1][k],tmp-1);\n\t\t\t\t\tif(s[i+1]=='1') chkmax(g[i+1][j][k+1],tmp-1);\n\t\t\t\t}\n\t\t\t\tif(i+2<=n){\n\t\t\t\t\tif(s[i+1]=='0' || s[i+2]=='0') chkmax(g[i+2][j+1][k],tmp);\n\t\t\t\t\tif(s[i+1]=='1' || s[i+2]=='1') chkmax(g[i+2][j][k+1],tmp);\n\t\t\t\t\tchkmax(g[i+2][j][k],tmp+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL ret(0);\n\tfor(LL i=0;i<=n;++i){\n\t\tfor(LL j=i;j>=0;--j){\n\t\t\tfor(LL k=i;k>=0;--k){\n\t\t\t\tis[i][j][k]=(g[i][j][k]!=-1);\n\t\t\t\tif(i) is[i][j][k]|=is[i-1][j][k];\n\t\t\t\tis[i][j][k]|=is[i][j+1][k];\n\t\t\t\tis[i][j][k]|=is[i][j][k+1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(LL i=0;i<=n;++i){\n\t\tfor(LL j=0;j<=i;++j){\n\t\t\tfor(LL k=0;k<=i;++k){\n\t\t\t\tif(n-i+j+k && is[i][j][k]){\n\t\t\t\t\tret=add(ret,f[i][j][k]);\n\t\t\t\t\t//printf(\"%d,%d,%d\\n\",i,j,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 301;\nconst i64 P = 998244353;\ni64 dp[maxn][maxn][maxn];\nint reach[maxn][maxn][maxn];\ni64 c[2][maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    string s;\n    cin >> s;\n    int n = s.size();\n    forn(i, n) forn(z, 2) c[z][i + 1] = c[z][i] + int(s[i] == (char)('0' + z));\n    dp[0][0][0] = 1;\n    forn(i, n) forn(c0, i + 1) forn(c1, i - c0 + 1) {\n        int p = n - i - 1 + c0 + c1;\n        forn(z, 2) {\n            int nc0 = c0, nc1 = c1;\n            if (s[p] - '0' != z) (z ? nc1 : nc0)++;\n            (dp[i + 1][nc0][nc1] += dp[i][c0][c1]) %= P;\n        }\n    }\n\n    forn(i, maxn) forn(j, maxn) forn(k, maxn) reach[i][j][k] = -1e9;\n    reach[0][0][0] = 0;\n    forn(i, n) forn(c0, i + 1) forn(c1, i - c0 + 1) {\n        if (reach[i][c0][c1] < 0) continue;\n        int nc0 = c0, nc1 = c1;\n        ++(s[i] == '0' ? nc0 : nc1);\n        uax(reach[i + 1][c0][c1], reach[i][c0][c1]);\n        if (reach[i][c0][c1] > 0) uax(reach[i + 1][nc0][nc1], reach[i][c0][c1] - 1);\n        if (i + 2 <= n) {\n            uax(reach[i + 2][c0][c1], reach[i][c0][c1] + 1);\n            uax(reach[i + 2][nc0][nc1], reach[i][c0][c1]);\n            int mc0 = c0, mc1 = c1;\n            ++(s[i + 1] == '0' ? mc0 : mc1);\n            uax(reach[i + 2][mc0][mc1], reach[i][c0][c1]);\n        }\n    }\n\n    i64 ans = 0;\n    for1(i, n) forn(c0, i + 1) forn(c1, i - c0 + 1) {\n        int p = n - i + c0 + c1;\n        if (reach[p][c0][c1] >= 0) {\n//            cerr << i << ' ' << c0 << ' ' << c1 << ' ' << p << ' ' << dp[i][c0][c1] << '\\n';\n            (ans += dp[i][c0][c1]) %= P;\n        }\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=319,mod=998244353;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\nchar s[maxn];int n,f[maxn][maxn][maxn],g[maxn][maxn][maxn];\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);reverse(s+1,s+n+1);\n\tg[0][0][0]=1;s[n+1]='2';\n\tfor(int i=0;i<n;i++) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++) if(g[i][j][k])\n\t{\n\t\tint v=s[i-j-k+1]-'0';\n\t\tAdd(g[i+1][j][k],g[i][j][k]);\n\t\tif(v) Add(g[i+1][j+1][k],g[i][j][k]);\n\t\telse Add(g[i+1][j][k+1],g[i][j][k]);\n\t}\n\tf[n][0][0]=1;\n\tfor(int i=n-1;i;i--) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++)\n\t{\n\t\tint va=s[i-j-k+1]-'0',vb=s[i-j-k+2]-'0',nxt[3];\n\t\tnxt[0]=j+1;nxt[1]=k;nxt[2]=0;\n\t\tif(nxt[va]){nxt[va]--;if(nxt[vb]&&(va==0||vb==0))nxt[vb]--;}\n\t\tf[i][j][k]|=f[i+1][nxt[0]][nxt[1]];\n\t\tnxt[0]=j;nxt[1]=k+1;nxt[2]=0;\n\t\tif(nxt[va]){nxt[va]--;if(nxt[vb]&&(va==1||vb==1))nxt[vb]--;}\n\t\tf[i][j][k]|=f[i+1][nxt[0]][nxt[1]];\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<=i;j++) for(int k=0;j+k<=i;k++)\n\t\tif(f[i][j][k]) Add(ans,g[i][j][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\ninline void _add(int &a,int b)\n{\n    if((a+=b)>=mod)a-=mod;\n}\ninline int add(int a,int b)\n{\n    if((a+=b)>=mod)a-=mod;\n    return a;\n}\ninline int dec(int a,int b)\n{\n    if((a-=b)<0)a+=mod;\n    return a;\n}\ninline int mult(int a,int b)\n{\n    ll t=(ll)a*b;\n    if(t>=mod)t%=mod;\n    return t;\n}\ninline int power(int a,int b)\n{\n    int out=1;\n    while(b)\n    {\n        if(b&1)out=mult(out,a);\n        a=mult(a,a);\n        b>>=1;\n    }\n    return out;\n}\nchar s[310];\nbool f[310][310][310],g[310][310][310];\nint n,ss[310][310][310];\nvoid trans(int i,int j,int k,int c1,int c2)\n{\n    f[i+1][j+(c1==0)][k+(c1==1)]=1;\n    f[i+1][j+(c2==0)][k+(c2==1)]=1;\n}\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    f[0][0][0]=1;\n    for(int i=0;i<n-1;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;j+k<=i;k++)\n            {\n                int pos=i+j+k+1;\n                if(pos>n+1)continue;\n                if(!f[i][j][k])continue;\n                if(pos<=n-1)\n                {\n                    trans(i,j,k,s[pos]-'0',s[pos+1]-'0');\n                }\n                if(pos<=n)\n                {\n                    if(j)\n                    {\n                        trans(i,j-1,k,s[pos]-'0',0);\n                    }\n                    if(k)\n                    {\n                        trans(i,j,k-1,s[pos]-'0',1);\n                    }\n                }\n                if(j>=2)trans(i,j-2,k,0,0);\n                if(j&&k)trans(i,j-1,k-1,0,1);\n                if(k>=2)trans(i,j,k-2,1,1);\n            }\n        }\n    }\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<=i;j++)\n        {\n            for(int k=0;j+k<=i;k++)\n            {\n                int pos=i+j+k+1;\n                if(pos>n+1)continue;\n                g[pos][j][k]=f[i][j][k];\n            }\n        }\n    }\n    for(int i=n+1;i>=2;i--)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            for(int k=0;k<=n;k++)\n            {\n                int c=s[i-1]-'0';\n                if(!c)\n                {\n                    if(j)g[i-1][j-1][k]|=g[i][j][k];\n                }\n                else\n                {\n                    if(k)g[i-1][j][k-1]|=g[i][j][k];\n                }\n            }\n        }\n    }\n    int res=0;\n    ss[n+1][0][0]=1;\n    for(int sum=n+1;sum>=1;sum--)\n    {\n        for(int len=sum;len<=n+1;len++)\n        {\n            int up=len-sum;\n            for(int j=0;j<=up;j++)\n            {\n                int k=up-j;\n                if(s[len-1]=='0')\n                {\n                    _add(ss[len-1][j][k],ss[len][j][k]);\n                    _add(ss[len][j][k+1],ss[len][j][k]);\n                }\n                else\n                {\n                    _add(ss[len][j+1][k],ss[len][j][k]);\n                    _add(ss[len-1][j][k],ss[len][j][k]);\n                }    \n            }\n        }\n    }\n    // for(int i=n+1;i>=1;i--)\n    // {\n    //     for(int j=0;j<=n;j++)\n    //     {\n    //         for(int k=0;k<=n;k++)cerr<<ss[i][j][k]<<' ';\n    //         cerr<<'\\n';\n    //     }\n    //     cerr<<'\\n';\n    // }\n    for(int i=1;i<=n+1;i++)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            for(int k=0;k<=n;k++)\n            {\n                if(g[i][j][k])res=add(res,ss[i][j][k]);\n            }\n        }\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, M;\nvvll g;\n\nvll con;\n\nbool dfs(ll v) {\n\tfor (ll w : g[v]) {\n\t\tif(con[w]!=-1){\n\t\t\tif (con[v] == con[w]) { return false; }\n\t\t}\n\n\t\telse {\n\t\t\tcon[w] = 1 - con[v];\n\t\t\tbool b=dfs(w);\n\t\t\tif (!b) { return false; }\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tstring S;\n\tcin >> S;\n\n\tll N = S.size();\n\tvll a(N + 1, 0);\n\tvll rev(N + 1, 0);\n\trepn(i, N)rev[i] = S[i - 1] - '0';\n\trepn(i, N)a[i] = rev[N + 1 - i];\n\n\tvvvmint dp(N + 1, vvmint(N + 1, vmint(N + 1, 0)));\n\tdp[0][0][0] = 1;\n\n\trep(i, N + 1)rep(j, N + 1)rep(k, N + 1) {\n\t\tif (i > 0)dp[i][j][k] += dp[i - 1][j][k];\n\n\t\tif (i == 0 || a[i] == 0) {\n\t\t\tif (k > 0)dp[i][j][k] += dp[i][j][k - 1];\n\t\t}\n\t\tif (i == 0 || a[i] == 1) {\n\t\t\tif (j > 0)dp[i][j][k] += dp[i][j - 1][k];\n\t\t}\n\n\t\t//cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n\t}\n\n\trep(i, N + 1)rep(j, N + 1)rep(k, N + 1) {\n\t\tif (i < N && a[i + 1] == 0 && j > 0)dp[i][j][k] -= dp[i + 1][j - 1][k];\n\t\tif (i < N && a[i + 1] == 1 && k > 0)dp[i][j][k] -= dp[i + 1][j][k - 1];\n\n\t\t//cout << i << j << k <<\" \"<< dp[i][j][k] << endl;\n\t}\n\n\tvvvll pos(N + 1, vvll(N + 1, vll(N + 1, 0)));\n\tpos[0][0][0] = 1;\n\n\trepn(i,N) {\n\t\tif (i % 2 == 0) {\n\t\t\trep(j, N + 1)rep(k, N + 1) {\n\t\t\t\tif (2 * (j + k) > i) { continue; }\n\n\t\t\t\tpos[i][j][k] |= pos[i - 2][j][k];\n\t\t\t\tif (rev[i] == 0 || rev[i - 1] == 0) {\n\t\t\t\t\tif (j > 0)pos[i][j][k] |= pos[i - 2][j - 1][k];\n\t\t\t\t}\n\t\t\t\tif (rev[i] == 1 || rev[i - 1] == 1) {\n\t\t\t\t\tif (k > 0)pos[i][j][k] |= pos[i - 2][j][k - 1];\n\t\t\t\t}\n\n\t\t\t\tif (2 * (j + k) == i) { continue; }\n\t\t\t\tll t = rev[i - 1] + rev[i];\n\t\t\t\tif (t == 0 && j > 1) {\n\t\t\t\t\tpos[i][j][k] |= pos[i - 2][j - 2][k];\n\t\t\t\t}\n\t\t\t\tif (t == 1 && j > 0 && k > 0) {\n\t\t\t\t\tpos[i][j][k] |= pos[i - 2][j - 1][k - 1];\n\t\t\t\t}\n\t\t\t\tif (t == 2 && k > 1) {\n\t\t\t\t\tpos[i][j][k] |= pos[i - 2][j][k - 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i % 2 == 1) {\n\t\t\trep(j, N + 1)rep(k, N + 1) {\n\t\t\t\tif (2 * (j + k) > i) { continue; }\n\t\t\t\tpos[i][j][k] |= pos[i - 1][j][k];\n\t\t\t\t//if (2 * (j + k) == i - 1) { continue; }\n\t\t\t\tif (rev[i] == 0 && j > 0)pos[i][j][k] |= pos[i - 1][j - 1][k];\n\t\t\t\tif (rev[i] == 1 && k > 0)pos[i][j][k] |= pos[i - 1][j][k - 1];\n\t\t\t}\n\t\t}\n\n\t}\n\n\tmint ans = 0;\n\trep(i, N + 1)rep(j, N + 1)rep(k, N + 1) {\n\t\t//if (pos[N-i][j][k] == 1) { cout << N-i << j << k << \" \" << dp[i][j][k] << endl; }\n\t\tif (pos[N-i][j][k]) { ans += dp[i][j][k]; }\n\t}\n\tans -= 1;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// D.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 330, mod = 998244353;\n\nint n, dp[MAX_N][MAX_N][MAX_N], vis[MAX_N][MAX_N][MAX_N];\nbool verdict[MAX_N][MAX_N][MAX_N];\nchar str[MAX_N];\n\nint main()\n{\n    scanf(\"%s\", str + 1), n = strlen(str + 1);\n    dp[n][0][0] = 1;\n    for (int i = n; i >= 1; i--)\n        for (int j = 0; j + (n - i) <= n - 1; j++)\n            for (int k = 0; j + k + (n - i) <= n - 1; k++)\n                if (str[i] == '0')\n                {\n                    dp[i - 1][j][k] = (0LL + dp[i - 1][j][k] + dp[i][j][k]) % mod;\n                    dp[i][j][k + 1] = (0LL + dp[i][j][k + 1] + dp[i][j][k]) % mod;\n                }\n                else\n                {\n                    dp[i - 1][j][k] = (0LL + dp[i - 1][j][k] + dp[i][j][k]) % mod;\n                    dp[i][j + 1][k] = (0LL + dp[i][j + 1][k] + dp[i][j][k]) % mod;\n                }\n    memset(vis, -1, sizeof(vis)), vis[0][0][0] = 0;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j <= (i >> 1); j++)\n            for (int k = 0; j + k <= (i >> 1); k++)\n                if (vis[i][j][k] != -1)\n                {\n                    int c = vis[i][j][k];\n                    if (i + 1 <= n && c != 0)\n                    {\n                        if (str[i + 1] == '0')\n                            vis[i + 1][j + 1][k] = max(vis[i + 1][j + 1][k], c - 1);\n                        if (str[i + 1] == '1')\n                            vis[i + 1][j][k + 1] = max(vis[i + 1][j][k + 1], c - 1);\n                    }\n                    if (i + 2 <= n)\n                    {\n                        if (str[i + 1] == '0' || str[i + 2] == '0')\n                            vis[i + 2][j + 1][k] = max(vis[i + 2][j + 1][k], c);\n                        if (str[i + 1] == '1' || str[i + 2] == '1')\n                            vis[i + 2][j][k + 1] = max(vis[i + 2][j][k + 1], c);\n                        vis[i + 2][j][k] = max(vis[i + 2][j][k], c + 1);\n                    }\n                }\n    for (int i = 0; i <= n; i++)\n        for (int j = n; j >= 0; j--)\n            for (int k = n; k >= 0; k--)\n            {\n                verdict[i][j][k] = vis[i][j][k] != -1;\n                if (i > 0)\n                    verdict[i][j][k] |= verdict[i - 1][j][k];\n                verdict[i][j][k] |= verdict[i][j + 1][k] || verdict[i][j][k + 1];\n            }\n    int ans = 0;\n    for (int i = 0; i <= n; i++)\n        for (int j = 0; j + (n - i) <= n; j++)\n            for (int k = 0; j + k + (n - i) <= n; k++)\n                if (dp[i][j][k] && (n - i) + j + k != 0 && verdict[i][j][k])\n                    ans = (0LL + ans + dp[i][j][k]) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SZ(x) ((int)(x).size())\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<998244353>;\n\nbool sub[310][310][310];\nMint dp[310][310][310];\nMint comb[310][310];\n\nint main() {\n    rep(i, 310) {\n        comb[i][0] = comb[i][i] = 1;\n        for (int j = 1; j < i; ++j) {\n            comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n        }\n    }\n\n    string S;\n    cin >> S;\n\n    int n = S.size();\n    sub[0][0][0] = 1;\n\n    rep(i, n) {\n        rep(j, i + 1) {\n            rep(k, i + 1 - j) {\n                if (sub[i][j][k]) {\n                    if (S[i] == '0') {\n                        if (k > 0) {\n                            sub[i + 1][j + 1][k - 1] = 1;\n                        }\n                        if (j) {\n                            sub[i + 1][j][k] = 1;\n                        }\n                    } else {\n                        if (j) {\n                            sub[i + 1][j - 1][k + 1] = 1;\n                        }\n                        if (k) {\n                            sub[i + 1][j][k] = 1;\n                        }\n                    }\n\n                    if (i + 2 <= n) {\n                        int p = S[i] - '0', q = S[i + 1] - '0';\n                        if (p > q) swap(p, q);\n                        if (q == 0) {\n                            sub[i + 2][j + 1][k] = 1;\n                        } else if (p == 1) {\n                            sub[i + 2][j][k + 1] = 1;\n                        } else {\n                            sub[i + 2][j + 1][k] = sub[i + 2][j][k + 1] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int j = n; j >= 0; --j) {\n            for (int k = n; k >= 0; --k) {\n                if (sub[i + 1][j][k]) {\n                    if (j > 0 && j + k >= 2) {\n                        sub[i + 1][j - 1][k] = 1;\n                    }\n                    if (k > 0 && j + k >= 2) {\n                        sub[i + 1][j][k - 1] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    rep(i, n + 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1) {\n                if (sub[i][j][k]) {\n                    debug(i, j, k);\n                }\n            }\n        }\n    }\n\n    // use S[i,n)\n    rep(j, n + 1) {\n        rep(k, n + 1 - j) { dp[n][j][k] = comb[j + k][j]; }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        int c = S[i] - '0';\n        rep(j, n + 1) {\n            rep(k, n + 1 - j) {\n                if (c == 0) {\n                    for (int p = 0; p <= k; ++p) {\n                        dp[i][j][k] += dp[i + 1][j][k - p];\n                    }\n                } else {\n                    for (int q = 0; q <= j; ++q) {\n                        dp[i][j][k] += dp[i + 1][j - q][k];\n                    }\n                }\n            }\n        }\n    }\n\n    Mint ans;\n    rep(i, n + 1) {\n        rep(j, n + 1) {\n            rep(k, n + 1 - j) {\n                if (sub[i][j][k]) {\n                    Mint u = dp[i][j][k];\n                    int nj = j, nk = k;\n                    if (i > 0) {\n                        if (S[i - 1] == '0') {\n                            --nj;\n                        } else {\n                            --nk;\n                        }\n\n                        if (nj >= 0 && nk >= 0 && sub[i - 1][nj][nk]) {\n                            u -= dp[i - 1][nj][nk];\n                        }\n                    }\n                    ans += u;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 305;\nconst int mod = 998244353;\n\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint dp[N][N][N];\nint dp2[3][N][N][N];\nint possible[N][N][N];\nint pref[2][N];\nint main(){\n\tstring s; cin >> s;\n\tint n = s.length();\n    // int n = (int) s.size();\n  vector<vector<vector<bool>>> can(n + 1, vector<vector<bool>>(n + 1, vector<bool>(n + 1, false)));\n\t// trace(n);\n  can[0][0][0] = true;\n  for (int i = 0; i <= n; i++) {\n    for (int k0 = n; k0 >= 0; k0--) {\n      for (int k1 = n; k1 >= 0; k1--) {\n        if (!can[i][k0][k1]) {\n          continue;\n        }\n        // both from string\n        if (i + 2 <= n) {\n          if (s[i] == '0' || s[i + 1] == '0') {\n            can[i + 2][k0 + 1][k1] = true;\n          }\n          if (s[i] == '1' || s[i + 1] == '1') {\n            can[i + 2][k0][k1 + 1] = true;\n          }\n        }\n        // both from pocket\n        if (k0 > 0 && k0 + k1 >= 2) {\n          can[i][k0 - 1][k1] = true;\n        }\n        if (k1 > 0 && k0 + k1 >= 2) {\n          can[i][k0][k1 - 1] = true;\n        }\n        // one from string, one from pocket, erase from string\n        if (i + 1 <= n && k0 + k1 >= 1) {\n          can[i + 1][k0][k1] = true;\n        }\n        // one from string, one from pocket, erase from pocket\n        if (i + 1 <= n && k0 > 0) {\n          if (s[i] == '0') {\n            can[i + 1][k0][k1] = true;\n          } else {\n            can[i + 1][k0 - 1][k1 + 1] = true;\n          }\n        }\n        if (i + 1 <= n && k1 > 0) {\n          if (s[i] == '0') {\n            can[i + 1][k0 + 1][k1 - 1] = true;\n          } else {\n            can[i + 1][k0][k1] = true;\n          }\n        }\n      }\n    }\n  }\n\t// trace()s\n\ts = \"$\" + s;\n\tdp2[2][0][0][0] = possible[0][0][0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tpref[0][i] = pref[0][i - 1];\n\t\tpref[1][i] = pref[1][i - 1];\n\t\tint other = s[i] - '0';\n\t\tpref[other][i]++;\n\t\tfor(int n0 = 0; n0 <= i; n0++) for(int n1 = 0; n1 <= i; n1++){\n\t\t\tfor(int old = 0; old < 2; old++) if(dp2[old][i - 1][n0][n1]){\n\t\t\t\tint h[2] = {n0, n1};\n\t\t\t\tdp2[old][i][h[0]][h[1]] = 1; // throw other away\n\t\t\t\tdp2[other][i][h[0]][h[1]] = 1; // throw old away\n\t\t\t\th[other]++;\n\t\t\t\tdp2[2][i][h[0]][h[1]] = 1;// throw old away, other to right\n\t\t\t\th[other]--; h[old]++;\n\t\t\t\tdp2[2][i][h[0]][h[1]] = 1; // throw other away, old to right\n\t\t\t}\n\n\t\t\t// old = 2\n\t\t\tif(dp2[2][i - 1][n0][n1]) dp2[other][i][n0][n1] = 1;\n\t\t}\n\t\tfor(int n0 = 0; n0 <= n; n0++) for(int n1 = 0; n1 <= n; n1++){\n\t\t\tpossible[i][n0][n1] |= dp2[2][i][n0][n1];\n            // if(!(can[i][n0][n1] == possible[i][n0][n1]))\n            // trace(i, n0, n1, can[i][n0][n1]);\n            // assert(can[i][n0][n1] == possible[i][n0][n1]);\n            if(can[i - 1][n0][n1]) can[i][n0][n1] = true;\n\t\t\t// possible[i][n0][n1] |= possible[i - 1][n0][n1];\n\t\t}\n\t\t// \tpossible[i][n0][n1] |= dp2[curr][i][n0][n1];\n\t}\n\n\tdp[0][0][0] = 1;\n\n\tint ans = 0;\n\n\tfor(int n0 = 0; n0 <= n; n0++) for(int n1 = 0; n1 <= n; n1++){\n\t\tfor(int now = 0; now < 2; now++){\n\t\t\tint nn0 = n0, nn1 = n1;\n\t\t\tif(now==0) nn0++;\n\t\t\tif(now==1) nn1++;\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tint num_0 = n0 - (pref[0][n] - pref[0][n - k]);\n\t\t\t\tint num_1 = n1 - (pref[1][n] - pref[1][n - k]);\n\t\t\t\t// maximum suffix that exists as a subsequence ?\n\t\t\t\tint kk = k;\n\t\t\t\tif(s[n - k] - '0'== now){\n\t\t\t\t\tkk++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdp[nn0][nn1][kk] = add(dp[nn0][nn1][kk], dp[n0][n1][k]);\n\t\t\t\t\n\t\t\t\tif(now == 0 && num_0 >= 0&& num_1 >= 0 && n0 + n1 >= 1){\n\t\t\t\t\t\n\t\t\t\t\tif(can[n - k][num_0][num_1]){\n\t\t\t\t\t\tans = add(ans, dp[n0][n1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ld long double\n#define ll long long\n#define st first\n#define nd second\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nconst ll mod = 998244353;\nconst int N = 305;\nint n;\nstring s, t;\nll dp[N][N][N];\nbool p[N][N][N], ign[N][N][N];\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>s;\n\tn = s.size();\n\tif(n==1) {\n\t\tcout<<1;\n\t\treturn 0;\n\t}\n\tt = s;\n\treverse(t.begin(), t.end());\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=n; j>=0; --j) {\n\t\t\tfor(int k=n; k>=0; --k) {\n\t\t\t\tif(i==0) {\n\t\t\t\t\tif(j==0 && k==0) p[i][j][k]=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==1) continue;\n\t\t\t\tif((s[i-2] == '0' || s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j-1][k];\n\t\t\t\t}\n\t\t\t\tif((s[i-2] == '1' || s[i-1] == '1') && k != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-2][j][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j][k];\n\t\t\t\tif((s[i-1] == '0') && j != 0) {\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j-1][k+1];\n\t\t\t\t}\n\t\t\t\tif((s[i-1] == '1') && k != 0){\n\t\t\t\t\tp[i][j][k] = p[i][j][k] | p[i-1][j+1][k-1];\n\t\t\t\t}\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j+1][k];\n\t\t\t\tp[i][j][k] = p[i][j][k] | p[i][j][k+1];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(i==0 && j==0 && k==0) {\n\t\t\t\t\tdp[i][j][k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i==0) {\n\t\t\t\t\tdp[i][j][k] = (((j==0)?0LL:dp[i][j-1][k]) + ((k==0)?0LL:dp[i][j][k-1])) % mod;\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n\t\t\t\tif(t[i-1] == '0' && k != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j][k-1]) % mod;\n\t\t\t\tif(t[i-1] == '1' && j != 0) dp[i][j][k] = (dp[i][j][k] + dp[i][j-1][k]) % mod;\n\t\t\t\tif(t[i-1] == '0' && (p[n-(i-1)][j+1][k] || ign[i-1][j+1][k])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t\tif(t[i-1]=='1' && (p[n-(i-1)][j][k+1] || ign[i-1][j][k+1])) {\n\t\t\t\t\tign[i][j][k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor(int i=0; i<=n; ++i) {\n\t\tfor(int j=0; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) {\n\t\t\t\tif(!ign[i][j][k] && p[n-i][j][k]) ans = (ans + dp[i][j][k]) % mod;\n\t\t\t\t//if(p[n-i][j][k] && !ign[i][j][k]) {\n\t\t\t\t//\tcout<<i<<' '<<j<<' '<<k<<\": \"<<dp[i][j][k]<<'\\n';\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans-1+mod)%mod;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nvoid ckmax(int &x,int y){\n\tif (x<y)\n\t\tx=y;\n}\nvoid ckmin(int &x,int y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int N=305;\nint n;\nchar s[N];\nint dp[N][N][N],g[N][N][N],f[N][N][N];\nint main(){\n\tcin>>(s+1);\n\tn=strlen(s+1);\n\tdp[0][0][0]=1;\n\tFor(a,0,n)\n\t\tFod(i,n,0)\n\t\t\tFod(j,n,0){\n\t\t\t\tif (dp[a][i][j]){\n\t\t\t\t\tf[a][i][j]=1;\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tf[a+1][i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif (i>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i-1][j]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tdp[a+1][i][j]=1;\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i-1+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+1][i-1][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j>0){\n\t\t\t\t\t\tif (i+j>=2)\n\t\t\t\t\t\t\tdp[a][i][j-1]=1;\n\t\t\t\t\t\tif (a<n){\n\t\t\t\t\t\t\tdp[a+1][i][j]=1;\n\t\t\t\t\t\t\tif (s[a+1]=='0')\n\t\t\t\t\t\t\t\tdp[a+1][i+1][j-1]=1;\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tdp[a+1][i][j-1+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (a<=n-2){\n\t\t\t\t\t\tFor(k,a+1,a+2){\n\t\t\t\t\t\t\tif (s[k]=='0')\n\t\t\t\t\t\t\t\tdp[a+2][i+1][j]=1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdp[a+2][i][j+1]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f[a][i][j]){\n\t\t\t\t\tif (a<n){\n\t\t\t\t\t\tif (i>0)\n\t\t\t\t\t\t\tf[a][i-1][j]=1;\n\t\t\t\t\t\tif (j>0)\n\t\t\t\t\t\t\tf[a][i][j-1]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\tg[n+1][0][0]=1;\n\tint ans=1;\n\tFod(b,n,1){\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n)\n\t\t\t\tg[b][i][j]=g[b+1][i][j];\n\t\tif (s[b]=='1'){\n\t\t\tFor(i,1,n)\n\t\t\t\tFor(j,0,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i-1][j]);\n\t\t}\n\t\telse {\n\t\t\tFor(i,0,n)\n\t\t\t\tFor(j,1,n)\n\t\t\t\t\tAdd(g[b][i][j],g[b][i][j-1]);\n\t\t}\n\t\tFor(i,0,n)\n\t\t\tFor(j,0,n){\n\t\t\t\tif (i+j>b+1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (b<n){\n\t\t\t\t\tif (s[b+1]=='0')\n\t\t\t\t\t\tf[b][i][j]|=f[b+1][i+1][j];\n\t\t\t\t\telse\n\t\t\t\t\t\tf[b][i][j]|=f[b+1][i][j+1];\n\t\t\t\t}\n\t\t\t\tif (f[b][i][j])\n\t\t\t\t\tAdd(ans,g[b][i][j]);\n\t\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n001\n001 0 1 01 10\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 305\n#define MOD 998244353\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar S[SIZE];\nint dp[SIZE][SIZE];\nint C[SIZE][SIZE];\nint r0[SIZE],r1[SIZE];\n\nvoid make()\n{\n\tfor(int i=0;i<SIZE;i++)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tC[i][j]=C[i-1][j-1]+C[i-1][j];\n\t\t\tif(C[i][j]>=MOD) C[i][j]-=MOD;\n\t\t}\n\t}\n}\nint main()\n{\n\tmake();\n\tscanf(\"%s\",&S);\n\tint n=strlen(S);\n\t//int n=300;\n\t//for(int i=0;i<n;i++) S[i]='0'+(i%2);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tr0[i]=S[i]=='0';\n\t\tr1[i]=S[i]=='1';\n\t\tif(i>0)\n\t\t{\n\t\t\tr0[i]+=r0[i-1];\n\t\t\tr1[i]+=r1[i-1];\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(dp[i][j]==-1) continue;\n\t\t\tif(dp[i][j]>=n-1) dp[i][j]=dp[i+1][j]=dp[i][j+1]=n;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint v=dp[i][j];\n\t\t\t\tif(S[v]!=S[v+1])\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],v+2);\n\t\t\t\t\tdp[i][j+1]=max(dp[i][j+1],v+2);\n\t\t\t\t}\n\t\t\t\telse if(S[v]=='0')\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],v+2);\n\t\t\t\t\tif(j+1<=r1[v]) dp[i][j+1]=max(dp[i][j+1],v+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j+1]=max(dp[i][j+1],v+2);\n\t\t\t\t\tif(i+1<=r0[v]) dp[i+1][j]=max(dp[i+1][j],v+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ret=MOD-1;\n\tfor(int i=0;i<=r0[n-1];i++)\n\t{\n\t\tfor(int j=0;j<=r1[n-1];j++)\n\t\t{\n\t\t\tif(dp[i][j]==-1) continue;\n\t\t\tint v=dp[i][j];\n\t\t\tint zero,one;\n\t\t\tint a,b;\n\t\t\tif(v==0)\n\t\t\t{\n\t\t\t\tzero=one=0;\n\t\t\t\ta=r0[n-1];\n\t\t\t\tb=r1[n-1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzero=r0[v-1]-i,one=r1[v-1]-j;\n\t\t\t\ta=r0[n-1]-r0[v-1],b=r1[n-1]-r1[v-1];\n\t\t\t}\n\t\t\tint f=zero,s=one;\n\t\t\tif(b==0) f=0;\n\t\t\tif(a==0) s=0;\n\t\t\tfor(int k=0;k<=f;k++)\n\t\t\t{\n\t\t\t\tfor(int l=0;l<=s;l++)\n\t\t\t\t{\n\t\t\t\t\tll w=C[zero+one-k-l][zero-k];\n\t\t\t\t\tif(b>0) w=w*(ll) C[k+b-1][b-1]%MOD;\n\t\t\t\t\tif(a>0) w=w*(ll) C[l+a-1][a-1]%MOD;\n\t\t\t\t\tret+=w;\n\t\t\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 2000000000000000007LL\n#define ULTRABIG 300000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n#include <iostream>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 10], invf[N_MAX * 10];\nvoid f_init (sll n, sll m) {\n\tfrac[0] = 1;\n\tfor (sll i = 1; i <= n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % m;\n\t}\n\n\tinvf[n] = divide(1, frac[n], m);\n\tfor (sll i = n - 1; i >= 0; i--) {\n\t\tinvf[i] = invf[i + 1] * (i + 1) % m;\n\t}\n}\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 4];\nhwllc tup[N_MAX * 4];\n// sll table[3005][3005];\nsll table[2005][2005];\null gin[N_MAX];\n// here we go\n\null parent[501910], size[501910], edges[501910];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull v, ull u) {\n\tv = find(v);\n\tu = find(u);\n\n\n\n\tif (v == u) return false;\n\n\tif (size[v] < size[u]) {\n\t\tull tmp = v;\n\t\tv = u;\n\t\tu = tmp;\n\t}\n\tsize[v] += size[u];\n\tparent[u] = v;\n\treturn true;\n}\n\nsll dp[310][310][310];\n\nsll solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tn = strlen(s);\n\tif (k > n) k = n;\n\n\t// dp[0][0][0] = 1;\n\t// for (i = 0; i < n; i++) {\n\t// \tif (s[i] == '0') {\n\n\t// \t\tfor (j = 0; j < n; j++) {\n\t// \t\t\tfor (ki = 0; ki <= k; ki++) {\n\t// \t\t\t\tdp[i + 1][j + 1][ki] = dp[i][j][ki];\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t} else {\n\n\t// \t\tfor (j = 0; j <= n; j++) {\n\t// \t\t\tfor (ki = 0; ki <= k; ki++) {\n\t// \t\t\t\tdp[i + 1][0][ki] += dp[i][j][ki];\n\t// \t\t\t\tdp[i + 1][j][ki + 1] += dp[i][j][ki];\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tfor (ki = 0; ki <= k; ki++) {\n\t// \t\t\tdp[i + 1][0][ki] %= FOD;\n\n\t// \t\t\tfor (j = n; j >= 1; j--) {\n\t// \t\t\t\tdp[i + 1][j][ki] += dp[i + 1][j + 1][ki];\n\t// \t\t\t\tdp[i + 1][j][ki] %= FOD;\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t}\n\t// }\n\n\t// for (j = 0; j <= n; j++) {\n\t// \tfor (ki = 0; ki <= k; ki++) {\n\t// \t\tresult += dp[n][j][ki];\n\t// \t}\n\t// }\n\t// result %= FOD;\n\n\tif (n == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t} else if (n == 2) {\n\t\tputs((s[0] != s[1]) ? \"3\" : \"2\");\n\t\treturn 0;\n\t}\n\n\thwll cnt = (hwll){0, 0};\n\n\txy[n] = cnt;\n\tfor (i = n - 1; i >= 0; i--) {\n\t\tif (s[i] == '0') {\n\t\t\tcnt.a++;\n\t\t} else {\n\t\t\tcnt.b++;\n\t\t}\n\n\t\txy[i] = cnt;\n\t}\n\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\ttable[i][j] = -1;\n\t\t}\n\t}\n\n\ttable[cnt.a][cnt.b] = 0;\n\tfor (i = n; i >= 2; i--) {\n\t\tsll j0;\n\t\tfor (j0 = 0; j0 <= n; j0++) {\n\t\t\tsll j1 = i - j0;\n\t\t\tif (j1 < 0) break;\n\n\t\t\tsll remin = table[j0][j1];\n\t\t\tif (remin < 0) continue;\n\n\t\t\thwll free = (hwll){j0 - xy[remin].a, j1 - xy[remin].b};\n\n\t\t\tif (remin <= n - 2) {\n\t\t\t\tif (s[remin] == '0' || s[remin + 1] == '0') {\n\t\t\t\t\ttable[j0 - 1][j1] = smax(table[j0 - 1][j1], remin + 2);\n\t\t\t\t}\n\t\t\t\tif (s[remin] == '1' || s[remin + 1] == '1') {\n\t\t\t\t\ttable[j0][j1 - 1] = smax(table[j0][j1 - 1], remin + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remin <= n - 1) {\n\t\t\t\tif (s[remin] == '0' || free.a) {\n\t\t\t\t\ttable[j0 - 1][j1] = smax(table[j0 - 1][j1], remin + 1);\n\t\t\t\t}\n\t\t\t\tif (s[remin] == '1' || free.b) {\n\t\t\t\t\ttable[j0][j1 - 1] = smax(table[j0][j1 - 1], remin + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remin <= n && free.a + free.b >= 2) {\n\t\t\t\tif (free.a) {\n\t\t\t\t\ttable[j0 - 1][j1] = smax(table[j0 - 1][j1], remin);\n\t\t\t\t}\n\t\t\t\tif (free.b) {\n\t\t\t\t\ttable[j0][j1 - 1] = smax(table[j0][j1 - 1], remin);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tif (table[i][j] < 0) continue;\n\n\t\t\tsll v = table[i][j];\n\t\t\tdp[v][i - xy[v].a][j - xy[v].b] += 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = n; j >= 0; j--) {\n\t\t\tfor (ki = n; ki >= 0; ki--) {\n\t\t\t\tdp[i][j][ki] %= FOD;\n\t\t\t\tif (s[i] == '0') {\n\t\t\t\t\tdp[i + 1][j][ki] += dp[i][j][ki];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j - 1][ki] += dp[i][j][ki];\n\t\t\t\t}\n\t\t\t\tif (s[i] == '1') {\n\t\t\t\t\tdp[i + 1][j][ki] += dp[i][j][ki];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j][ki - 1] += dp[i][j][ki];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tresult = dp[n][0][0] % FOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\th = 5;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%lld\", &w);\n\t// scanf(\"%lld%lld\", &h, &w);\n\t// scanf(\"%lld%lld\", &n, &m);\n\t// scanf(\"%lld\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\tscanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// scanf(\"%lld\", &n);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%s\", s[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \tc[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &e[i], &c[i], &d[i]);\n\t// \tc[i]--;\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 998244353\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nlong long combination(int n, int k)\n{\n\tif (k == 0) return 1;\n\t\n\tstatic long long ans[301][301] = {};\n\tif (ans[n][k] != 0) return ans[n][k];\n\t\n\tint i;\n\tlong long x, y;\n\tfor (i = n, x = 1; i >= n - k + 1; i--) x = x * i % Mod;\n\tfor (i = 2, y = 1; i <= k; i++) y = y * i % Mod;\n\tans[n][k] = div_mod(x, y, Mod);\n\treturn ans[n][k];\n}\n\nint main()\n{\n\tchar S[301] = {};\n\tscanf(\"%s\", S);\n\n\tint i, j, k, l, m, count[301][2] = {};\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tcount[i+1][S[i] - '0'] = count[i][S[i] - '0'] + 1;\n\t\tcount[i+1][1 - S[i] + '0'] = count[i][1 - S[i] + '0'];\n\t}\n\tif (i == 1) {\n\t\tprintf(\"1\\n\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tint dis[301][301];\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tfor (j = 0; S[j] != 0; j++) dis[i][j] = -1;\n\t}\n\tif (S[0] != S[1]) {\n\t\tdis[0][1] = 1;\n\t\tdis[1][0] = 1;\n\t} else if (S[0] == '0') dis[1][0] = 1;\n\telse dis[0][1] = 1;\n\tfor (i = 2; S[i] != 0; i++) {\n\t\tfor (j = 0; j <= count[i][0]; j++) {\n\t\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\t\tif ((S[i] == '0' || S[i-1] == '0') && dis[j+1][k] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j+1][k] = dis[j][k] + 2;\n\t\t\t\tif (count[i][0] > j && dis[j+1][k] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j+1][k] = dis[j][k] + 1;\n\t\t\t\tif ((S[i] == '1' || S[i-1] == '1') && dis[j][k+1] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j][k+1] = dis[j][k] + 2;\n\t\t\t\tif (count[i][1] > k && dis[j][k+1] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j][k+1] = dis[j][k] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) {\n\t\t\t\tfor (l = j + 1; l <= count[i][0]; l++) dis[l][k] = i - 1;\n\t\t\t\tfor (l = k + 1; l <= count[i][1]; l++) dis[j][l] = i - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long dp[301][301][301] = {};\n\tfor (j = 0; j <= i; j++) {\n\t\tfor (k = 0; k <= i - j; k++) dp[0][j][k] = combination(j + k, j);\n\t}\n\tfor (l = 1; l <= i; l++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= l - j; k++) {\n\t\t\t\tdp[j][k][l-j-k] = dp[j-1][k][l-j-k];\n\t\t\t\tif (k > 0 && S[i-j] == '1') dp[j][k][l-j-k] += dp[j][k-1][l-j-k];\n\t\t\t\telse if (l - j - k > 0 && S[i-j] == '0') dp[j][k][l-j-k] += dp[j][k][l-j-k-1];\n\t\t\t\tdp[j][k][l-j-k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) ans = (ans + combination(count[i][0] + count[i][1] - j - k, count[i][0] - j)) % Mod;\n\t\t\telse if (dis[j][k] != -1) ans = (ans + dp[i-dis[j][k]-1][count[dis[j][k]+1][0]-j][count[dis[j][k]+1][1]-k]) % Mod;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 998244353\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nlong long combination(int n, int k)\n{\n\tif (k == 0) return 1;\n\t\n\tstatic long long ans[300][300] = {};\n\tif (ans[n][k] != 0) return ans[n][k];\n\t\n\tint i;\n\tlong long x, y;\n\tfor (i = n, x = 1; i >= n - k + 1; i--) x = x * i % Mod;\n\tfor (i = 2, y = 1; i <= k; i++) y = y * i % Mod;\n\tans[n][k] = div_mod(x, y, Mod);\n\treturn ans[n][k];\n}\n\nint main()\n{\n\tchar S[301] = {};\n\tscanf(\"%s\", S);\n\n\tint i, j, k, l, m, count[301][2] = {}, dis[301][301];\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tcount[i+1][S[i] - '0'] = count[i][S[i] - '0'] + 1;\n\t\tcount[i+1][1 - S[i] + '0'] = count[i][1 - S[i] + '0'];\n\t}\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tfor (j = 0; S[j] != 0; j++) dis[i][j] = -1;\n\t}\n\tif (S[0] != S[1]) {\n\t\tdis[0][1] = 1;\n\t\tdis[1][0] = 1;\n\t} else if (S[0] == '0') dis[1][0] = 1;\n\telse dis[0][1] = 1;\n\tfor (i = 2; S[i] != 0; i++) {\n\t\tfor (j = 0; j <= count[i][0]; j++) {\n\t\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\t\tif ((S[i] == '0' || S[i-1] == '0') && dis[j+1][k] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j+1][k] = dis[j][k] + 2;\n\t\t\t\tif (count[i][0] > j && dis[j+1][k] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j+1][k] = dis[j][k] + 1;\n\t\t\t\tif ((S[i] == '1' || S[i-1] == '1') && dis[j][k+1] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j][k+1] = dis[j][k] + 2;\n\t\t\t\tif (count[i][1] > k && dis[j][k+1] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j][k+1] = dis[j][k] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) {\n\t\t\t\tfor (l = j + 1; l <= count[i][0]; l++) dis[l][k] = i - 1;\n\t\t\t\tfor (l = k + 1; l <= count[i][1]; l++) dis[j][l] = i - 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* for (i = 0; S[i] != 0; i++) {\n\t\tfor (j = 0; S[j] != 0; j++) printf(\"%d \", dis[i][j]);\n\t\tprintf(\"\\n\");\n\t} */\n\t\n\tlong long dp[301][301][301] = {};\n\tfor (j = 0; j <= i; j++) {\n\t\tfor (k = 0; k <= i - j; k++) dp[0][j][k] = combination(j + k, j);\n\t}\n\tfor (l = 1; l <= i; l++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= l - j; k++) {\n\t\t\t\tdp[j][k][l-j-k] = dp[j-1][k][l-j-k];\n\t\t\t\tif (k > 0 && S[i-j] == '1') dp[j][k][l-j-k] += dp[j][k-1][l-j-k];\n\t\t\t\telse if (l - j - k > 0 && S[i-j] == '0') dp[j][k][l-j-k] += dp[j][k][l-j-k-1];\n\t\t\t\tdp[j][k][l-j-k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\t/* for (l = 0; l <= i; l++) {\n\t\tfor (j = 0; j <= l; j++) {\n\t\t\tfor (k = 0; k <= l - j; k++) printf(\"dp[%d][%d][%d] = %d\\n\", j, k, l - j - k, dp[j][k][l-j-k]);\n\t\t}\n\t} */\n\t\n\tlong long ans = 0;\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) ans = (ans + combination(count[i][0] + count[i][1] - j - k, count[i][0] - j)) % Mod;\n\t\t\telse if (dis[j][k] != -1) ans = (ans + dp[i-dis[j][k]-1][count[dis[j][k]+1][0]-j][count[dis[j][k]+1][1]-k]) % Mod;\n\t\t\t/* else if (dis[j][k] != -1) {\n\t\t\t\tblock[0] = 0;\n\t\t\t\tblock[1] = 0;\n\t\t\t\tb = S[dis[j][k] + 1] - '0';\n\t\t\t\tblock[b]++;\n\t\t\t\tfor (l = dis[j][k] + 2; S[l] != 0; l++) {\n\t\t\t\t\tif (S[l] != S[l-1]) {\n\t\t\t\t\t\tb = 1 - b;\n\t\t\t\t\t\tblock[b]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (block[0] == 0) ans = (ans + combination(j + count[i][1] - k - 1, j)) % Mod;\n\t\t\t\telse if (block[1] == 0) ans = (ans + combination(k + count[i][0] - j - 1, k)) % Mod;\n\t\t\t\telse {\n\t\t\t\t\tfor (l = 0; l <= j; l++) {\n\t\t\t\t\t\tfor (m = 0; m <= k; m++) {\n\t\t\t\t\t\t\tans = (ans + ((combination(l + block[0] - 1, l) * combination(m + block[1] - 1, m) % Mod) * combination(j - l + count[i][1] - count[dis[j][k]+1][1] - block[1] + m - 1, j - l) % Mod) * combination(k - m + count[i][0] - count[dis[j][k]+1][0] - block[0] + l - 1, k - m)) % Mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} */\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 998244353\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nlong long combination(int n, int k)\n{\n\tif (k == 0 || n == k) return 1;\n\t\n\tstatic long long ans[301][301] = {};\n\tif (ans[n][k] != 0) return ans[n][k];\n\t\n\tint i;\n\tlong long x, y;\n\tfor (i = n, x = 1; i >= n - k + 1; i--) x = x * i % Mod;\n\tfor (i = 2, y = 1; i <= k; i++) y = y * i % Mod;\n\tans[n][k] = div_mod(x, y, Mod);\n\treturn ans[n][k];\n}\n\nint main()\n{\n\tchar S[301] = {};\n\tscanf(\"%s\", S);\n\n\tint i, j, k, l, m, count[301][2] = {};\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tcount[i+1][S[i] - '0'] = count[i][S[i] - '0'] + 1;\n\t\tcount[i+1][1 - S[i] + '0'] = count[i][1 - S[i] + '0'];\n\t}\n\tif (i == 1) {\n\t\tprintf(\"1\\n\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tint dis[301][301];\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tfor (j = 0; S[j] != 0; j++) dis[i][j] = -1;\n\t}\n\tif (S[0] != S[1]) {\n\t\tdis[0][1] = 1;\n\t\tdis[1][0] = 1;\n\t} else if (S[0] == '0') dis[1][0] = 1;\n\telse dis[0][1] = 1;\n\tfor (i = 2; S[i] != 0; i++) {\n\t\tfor (j = 0; j <= count[i][0]; j++) {\n\t\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\t\tif ((S[i] == '0' || S[i-1] == '0') && dis[j+1][k] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j+1][k] = dis[j][k] + 2;\n\t\t\t\tif ((S[i] == '0' || count[i][0] > j) && dis[j+1][k] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j+1][k] = dis[j][k] + 1;\n\t\t\t\tif ((S[i] == '1' || S[i-1] == '1') && dis[j][k+1] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j][k+1] = dis[j][k] + 2;\n\t\t\t\tif ((S[i] == '1' || count[i][1] > k) && dis[j][k+1] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j][k+1] = dis[j][k] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) {\n\t\t\t\tfor (l = j + 1; l <= count[i][0]; l++) dis[l][k] = i - 1;\n\t\t\t\tfor (l = k + 1; l <= count[i][1]; l++) dis[j][l] = i - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long dp[301][301][301] = {};\n\tfor (j = 0; j <= i; j++) {\n\t\tfor (k = 0; k <= i - j; k++) dp[0][j][k] = combination(j + k, j);\n\t}\n\tfor (l = 1; l <= i; l++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= l - j; k++) {\n\t\t\t\tdp[j][k][l-j-k] = dp[j-1][k][l-j-k];\n\t\t\t\tif (k > 0 && S[i-j] == '1') dp[j][k][l-j-k] += dp[j][k-1][l-j-k];\n\t\t\t\telse if (l - j - k > 0 && S[i-j] == '0') dp[j][k][l-j-k] += dp[j][k][l-j-k-1];\n\t\t\t\tdp[j][k][l-j-k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] != -1) ans = (ans + dp[i-dis[j][k]-1][count[dis[j][k]+1][0]-j][count[dis[j][k]+1][1]-k]) % Mod;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define Mod 998244353\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nlong long combination(int n, int k)\n{\n\tif (k == 0 || n == k) return 1;\n\t\n\tstatic long long ans[301][301] = {};\n\tif (ans[n][k] != 0) return ans[n][k];\n\t\n\tint i;\n\tlong long x, y;\n\tfor (i = n, x = 1; i >= n - k + 1; i--) x = x * i % Mod;\n\tfor (i = 2, y = 1; i <= k; i++) y = y * i % Mod;\n\tans[n][k] = div_mod(x, y, Mod);\n\treturn ans[n][k];\n}\n\nint main()\n{\n\tchar S[301] = {};\n\tscanf(\"%s\", S);\n\n\tint i, j, k, l, m, count[301][2] = {};\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tcount[i+1][S[i] - '0'] = count[i][S[i] - '0'] + 1;\n\t\tcount[i+1][1 - S[i] + '0'] = count[i][1 - S[i] + '0'];\n\t}\n\tif (i == 1) {\n\t\tprintf(\"1\\n\");\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tint dis[301][301];\n\tfor (i = 0; S[i] != 0; i++) {\n\t\tfor (j = 0; S[j] != 0; j++) dis[i][j] = -1;\n\t}\n\tif (S[0] != S[1]) {\n\t\tdis[0][1] = 1;\n\t\tdis[1][0] = 1;\n\t} else if (S[0] == '0') dis[1][0] = 1;\n\telse dis[0][1] = 1;\n\tfor (i = 2; S[i] != 0; i++) {\n\t\tfor (j = 0; j <= count[i][0]; j++) {\n\t\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\t\tif ((S[i] == '0' || S[i-1] == '0') && dis[j+1][k] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j+1][k] = dis[j][k] + 2;\n\t\t\t\tif (count[i][0] > j && dis[j+1][k] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j+1][k] = dis[j][k] + 1;\n\t\t\t\tif ((S[i] == '1' || S[i-1] == '1') && dis[j][k+1] < dis[j][k] + 2 && dis[j][k] == i - 2) dis[j][k+1] = dis[j][k] + 2;\n\t\t\t\tif (count[i][1] > k && dis[j][k+1] < dis[j][k] + 1 && dis[j][k] == i - 1) dis[j][k+1] = dis[j][k] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] == i - 1) {\n\t\t\t\tfor (l = j + 1; l <= count[i][0]; l++) dis[l][k] = i - 1;\n\t\t\t\tfor (l = k + 1; l <= count[i][1]; l++) dis[j][l] = i - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long dp[301][301][301] = {};\n\tfor (j = 0; j <= i; j++) {\n\t\tfor (k = 0; k <= i - j; k++) dp[0][j][k] = combination(j + k, j);\n\t}\n\tfor (l = 1; l <= i; l++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= l - j; k++) {\n\t\t\t\tdp[j][k][l-j-k] = dp[j-1][k][l-j-k];\n\t\t\t\tif (k > 0 && S[i-j] == '1') dp[j][k][l-j-k] += dp[j][k-1][l-j-k];\n\t\t\t\telse if (l - j - k > 0 && S[i-j] == '0') dp[j][k][l-j-k] += dp[j][k][l-j-k-1];\n\t\t\t\tdp[j][k][l-j-k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long ans = 0;\n\tfor (j = 0; j <= count[i][0]; j++) {\n\t\tfor (k = 0; k <= count[i][1]; k++) {\n\t\t\tif (dis[j][k] != -1) ans = (ans + dp[i-dis[j][k]-1][count[dis[j][k]+1][0]-j][count[dis[j][k]+1][1]-k]) % Mod;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DSecretPassage solver = new DSecretPassage();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DSecretPassage {\n        Debug debug = new Debug(false);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            char[] s = in.readString().toCharArray();\n            int n = s.length;\n            for (int i = 0; i < n; i++) {\n                s[i] -= '0';\n            }\n\n            Modular mod = new Modular(998244353);\n            Combination comb = new Combination(n, mod);\n\n            int[] cnts = new int[2];\n            for (int i = 0; i < n; i++) {\n                cnts[s[i]]++;\n            }\n            char[] rev = s.clone();\n            SequenceUtils.reverse(rev);\n            IntegerPreSum ps = new IntegerPreSum(i -> rev[i], n);\n            int a = cnts[0];\n            int b = cnts[1];\n            int[][][] dp = new int[a + 1][b + 1][n + 1];\n            dp[0][0][0] = 1;\n            for (int i = 0; i <= a; i++) {\n                for (int j = 0; j <= b; j++) {\n                    for (int k = 0; k <= i + j; k++) {\n                        int plus = dp[i][j][k];\n                        if (plus == 0) {\n                            continue;\n                        }\n                        //add 0\n                        if (i + 1 <= a) {\n                            int next = k;\n                            if (next < n && rev[next] == 0) {\n                                next++;\n                            }\n                            dp[i + 1][j][next] = mod.plus(dp[i + 1][j][next], plus);\n                        }\n                        //add 1\n                        if (j + 1 <= b) {\n                            int next = k;\n                            if (next < n && rev[next] == 1) {\n                                next++;\n                            }\n                            dp[i][j + 1][next] = mod.plus(dp[i][j + 1][next], plus);\n                        }\n                    }\n                }\n            }\n\n            for (int i = 0; i <= a; i++) {\n                for (int j = 0; j <= b; j++) {\n                    for (int k = n - 1; k >= 0; k--) {\n                        dp[i][j][k] = mod.plus(dp[i][j][k], dp[i][j][k + 1]);\n                    }\n                }\n            }\n\n            //debug.debug(\"dp\", dp);\n\n            int ans = 0;\n\n            boolean[][][] maybe = new boolean[n + 1][n + 1][n + 1];\n            maybe[0][0][0] = true;\n            for (int i = 0; i <= n; i++) {\n                for (int j = n; j >= 0; j--) {\n                    for (int k = n; k >= 0; k--) {\n                        if (!maybe[i][j][k]) {\n                            continue;\n                        }\n                        //get first\n                        if (i + 2 <= n) {\n                            int head = s[i];\n                            int next = s[i + 1];\n                            maybe[i + 2][j + 1 - head][k + head] = true;\n                            maybe[i + 2][j + 1 - next][k + next] = true;\n                        }\n                        //pop first\n                        if (j + k > 0 && i + 1 <= n) {\n                            maybe[i + 1][j][k] = true;\n                        }\n                        //pop 0\n                        if (j > 0 && i + 1 <= n) {\n                            int head = s[i];\n                            maybe[i + 1][j - 1 + 1 - head][k + head] = true;\n                        }\n                        //pop 1\n                        if (k > 0 && i + 1 <= n) {\n                            int head = s[i];\n                            maybe[i + 1][j + 1 - head][k - 1 + head] = true;\n                        }\n                        //just pop\n                        if (j + k >= 2) {\n                            if (j > 0) {\n                                maybe[i][j - 1][k] = true;\n                            }\n                            if (k > 0) {\n                                maybe[i][j][k - 1] = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n\n            //debug.debug(\"maybe\", maybe);\n            int[][] min = new int[n + 1][n + 1];\n            SequenceUtils.deepFill(min, n + 1);\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= n; j++) {\n                    for (int k = 0; k <= n; k++) {\n                        if (!maybe[i][j][k]) {\n                            continue;\n                        }\n                        int remain = n - i;\n                        int c0 = remain - ps.prefix(remain - 1);\n                        int c1 = ps.prefix(remain - 1);\n                        c0 += j;\n                        c1 += k;\n                        min[c0][c1] = Math.min(min[c0][c1], remain);\n                    }\n                }\n            }\n\n            for (int j = 0; j <= n; j++) {\n                for (int k = 0; k <= n; k++) {\n                    if (min[j][k] >= n + 1) {\n                        continue;\n                    }\n\n\n                    int remain = min[j][k];\n\n                    debug.debug(\"remain\", remain);\n                    debug.debug(\"j\", j);\n                    debug.debug(\"k\", k);\n                    debug.debug(\"total\", j + k + remain);\n                    int c0 = j;\n                    int c1 = k;\n                    int way = dp[c0][c1][remain];\n                    debug.debug(\"way\", way);\n                    ans = mod.plus(ans, dp[c0][c1][remain]);\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(char[] data, int i, int j) {\n            char tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n        public static void reverse(char[] data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static void reverse(char[] data) {\n            reverse(data, 0, data.length - 1);\n        }\n\n    }\n\n    static class IntegerPreSum {\n        private int[] pre;\n        private int n;\n\n        public IntegerPreSum(int n) {\n            pre = new int[n];\n        }\n\n        public void populate(IntToIntegerFunction a, int n) {\n            this.n = n;\n            if (n == 0) {\n                return;\n            }\n            pre[0] = a.apply(0);\n            for (int i = 1; i < n; i++) {\n                pre[i] = pre[i - 1] + a.apply(i);\n            }\n        }\n\n        public IntegerPreSum(IntToIntegerFunction a, int n) {\n            this(n);\n            populate(a, n);\n        }\n\n        public int prefix(int i) {\n            if (i < 0) {\n                return 0;\n            }\n            return pre[Math.min(i, n - 1)];\n        }\n\n    }\n\n    static interface IntCombination {\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class ModPrimeInverseNumber implements InverseNumber {\n        int[] inv;\n\n        public ModPrimeInverseNumber(int[] inv, int limit, Modular modular) {\n            this.inv = inv;\n            inv[1] = 1;\n            int p = modular.getMod();\n            for (int i = 2; i <= limit; i++) {\n                int k = p / i;\n                int r = p % i;\n                inv[i] = modular.mul(-k, inv[r]);\n            }\n        }\n\n        public ModPrimeInverseNumber(int limit, Modular modular) {\n            this(new int[limit + 1], limit, modular);\n        }\n\n        public int inverse(int x) {\n            return inv[x];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        Modular modular;\n\n        public Modular getModular() {\n            return modular;\n        }\n\n        public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n            this.modular = modular;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            for (int i = 1; i <= limit; i++) {\n                fact[i] = modular.mul(fact[i - 1], i);\n                inv[i] = modular.mul(inv[i - 1], in.inverse(i));\n            }\n        }\n\n        public Factorial(int limit, Modular modular) {\n            this(new int[limit + 1], new int[limit + 1], new ModPrimeInverseNumber(limit, modular), limit, modular);\n        }\n\n    }\n\n    static interface IntToIntegerFunction {\n        int apply(int x);\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static interface InverseNumber {\n        int inverse(int x);\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class Combination implements IntCombination {\n        final Factorial factorial;\n        final Modular modular;\n\n        public Combination(Factorial factorial) {\n            this.factorial = factorial;\n            this.modular = factorial.getModular();\n        }\n\n        public Combination(int limit, Modular modular) {\n            this(new Factorial(limit, modular));\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n  public static void main(String [] args) {\n    Reader in = new Reader();\n    char [] s = in.next().toCharArray();\n    StringProcessor solver = new StringProcessor(s);\n    System.out.println(solver.countWays());\n  }\n}\nclass StringProcessor {\n  char [] s;\n  int n;\n  final int mod = 998244353;\n  boolean [][][] vis;\n  int [][][] mem;\n  int [] cnt;\n  int [][] opt;\n\n  StringProcessor(char [] s) {\n    this.s = s.clone();\n    this.n = this.s.length;\n    vis = new boolean [this.n + 1][this.n + 1][this.n + 1];\n    cnt = new int [this.n + 1];\n    opt = new int [this.n + 1][this.n + 1];\n    mem = new int [this.n + 1][this.n + 1][this.n + 1];\n    cnt[n] = 0;\n    for(int i = n - 1; i >= 0; i--) {\n      cnt[i] = cnt[i + 1];\n      if(s[i] == '1') cnt[i] = cnt[i] + 1;\n    }\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        for(int k = 0; k <= n; k++) {\n          mem[i][j][k] = -1;\n          vis[i][j][k] = false;\n        }\n        opt[i][j] = -1;\n      }\n    }\n  }\n  void dfs(int cur, int cntMove, int cntOne) {\n    if(vis[cur][cntMove][cntOne]) return ;\n    vis[cur][cntMove][cntOne] = true;\n    opt[cntMove][cntOne + cnt[cur]] = Math.max(opt[cntMove][cntOne + cnt[cur]], cur);\n    int cntZero = cur - cntMove - cntOne;\n    if(cntOne >= 2) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n    }\n    if(cntZero >= 2) {\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cntOne >= 1 && cntZero >= 1) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cur + 2 <= n) {\n      if(s[cur] == '0' || s[cur + 1] == '0') {\n        dfs(cur + 2, cntMove + 1, cntOne);\n      }\n      if(s[cur] == '1' || s[cur + 1] == '1') {\n        dfs(cur + 2, cntMove + 1, cntOne + 1);\n      }\n    }\n    if(cur + 1 <= n) {\n      if(s[cur] == '0') {\n        if(cntOne > 0) dfs(cur + 1, cntMove + 1, cntOne - 1);\n        if(cntZero > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      } else {\n        if(cntZero > 0) dfs(cur + 1, cntMove + 1, cntOne + 1);\n        if(cntOne > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      }\n    }\n  }\n  int dp(int cur, int cntOne, int cntZero) {\n    if(cntOne == 0 && cntZero == 0) {\n      return (cur == n) ? 1 : 0;\n    }\n    if(mem[cur][cntOne][cntZero] != -1) {\n      return mem[cur][cntOne][cntZero];\n    }\n    int ans = 0;\n    if(cur < n) {\n      if(s[cur] == '0') {\n        if(cntZero > 0) ans += dp(cur + 1, cntOne, cntZero - 1);\n        if(cntOne > 0) ans += dp(cur, cntOne - 1, cntZero);\n      } else {\n        if(cntOne > 0) ans += dp(cur + 1, cntOne - 1, cntZero);\n        if(cntZero > 0) ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    } else {\n      if(cntOne > 0) {\n        ans += dp(cur, cntOne - 1, cntZero);\n      }\n      if(cntZero > 0) {\n        ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    }\n    return mem[cur][cntOne][cntZero] = ans;\n  } \n  int countWays() {\n    dfs(0, 0, 0);\n    int ans = 1;\n    for(int i = 1; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        int idx = opt[i][j];\n        if(idx < 0) continue;\n        ans += dp(idx, j, n - i - j);\n        ans %= mod;\n      }\n    }\n    return ans;\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 998244353;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tString s = scanString();\n\t\tint n = s.length();\n\t\tboolean dyn1[][][] = new boolean[n + 1][n + 1][n + 1];\n\t\tdyn1[0][0][0] = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dyn1[i][j][k]) {\n\t\t\t\t\t\tdyn1[i + 1][j][k] = true;\n\t\t\t\t\t\tif (j > 0 && s.charAt(i) == '1') {\n\t\t\t\t\t\t\tdyn1[i + 1][j - 1][k + 1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (k > 0 && s.charAt(i) == '0') {\n\t\t\t\t\t\t\tdyn1[i + 1][j + 1][k - 1] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i + 1 < n) {\n\t\t\t\t\t\t\tif (s.charAt(i) == '0' || s.charAt(i + 1) == '0') {\n\t\t\t\t\t\t\t\tdyn1[i + 2][j + 1][k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (s.charAt(i) == '1' || s.charAt(i + 1) == '1') {\n\t\t\t\t\t\t\t\tdyn1[i + 2][j][k + 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dyn2[][][] = new int[n + 1][n + 1][n + 1];\n\t\tdyn2[n][0][0] = 1;\n\t\tint ans = MOD - 1;\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (dyn1[i][j][k]) {\n\t\t\t\t\t\tans = add(ans, dyn2[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && s.charAt(i - 1) == '0') {\n\t\t\t\t\t\tdyn2[i - 1][j][k] = add(dyn2[i - 1][j][k], dyn2[i][j][k]);\n\t\t\t\t\t} else if (j < n) {\n\t\t\t\t\t\tdyn2[i][j + 1][k] = add(dyn2[i][j + 1][k], dyn2[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && s.charAt(i - 1) == '1') {\n\t\t\t\t\t\tdyn2[i - 1][j][k] = add(dyn2[i - 1][j][k], dyn2[i][j][k]);\n\t\t\t\t\t} else if (k < n) {\n\t\t\t\t\t\tdyn2[i][j][k + 1] = add(dyn2[i][j][k + 1], dyn2[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    void solve() {\n        char[] s = in.next().toCharArray();\n        int n = s.length;\n        // used chars; cnt0; cnt1\n        boolean[][][] dp = new boolean[n + 1][n + 1][n + 1];\n        dp[0][0][0] = true;\n        for (int used = 0; used <= n; used++) {\n            for (int cnt0 = n; cnt0 >= 0; cnt0--) {\n                for (int cnt1 = n; cnt1 >= 0; cnt1--) {\n                    if (!dp[used][cnt0][cnt1]) {\n                        continue;\n                    }\n                    if (used + 2 <= n) {\n                        int f1 = s[used] - '0';\n                        int f2 = s[used + 1] - '0';\n                        if (f1 == 0 || f2 == 0) {\n                            dp[used + 2][cnt0 + 1][cnt1] = true;\n                        }\n                        if (f1 == 1 || f2 == 1) {\n                            dp[used + 2][cnt0][cnt1 + 1] = true;\n                        }\n                    }\n                    if (used + 1 <= n) {\n                        int f1 = s[used] - '0';\n\n                        dp[used + 1][cnt0][cnt1] = true;\n                        if (f1 == 0) {\n                            if (cnt0 > 0) {\n                                dp[used + 1][cnt0][cnt1] = true;\n                            }\n                            if (cnt1 > 0) {\n                                dp[used + 1][cnt0 + 1][cnt1 - 1] = true;\n                            }\n                        } else {\n                            if (cnt1 > 0) {\n                                dp[used + 1][cnt0][cnt1] = true;\n                            }\n                            if (cnt0 > 0) {\n                                dp[used + 1][cnt0 - 1][cnt1 + 1] = true;\n                            }\n                        }\n                    }\n                    if (cnt0 > 0) {\n                        dp[used][cnt0 - 1][cnt1] = true;\n                    }\n                    if (cnt1 > 0) {\n                        dp[used][cnt0][cnt1 - 1] = true;\n                    }\n                }\n            }\n        }\n        // {need0, need1}\n        int[][] ways = new int[n + 1][n + 1];\n        ways[0][0] = 1;\n        int res = 0;\n        int[][] nways = new int[n + 1][n + 1];\n        for (int len = 1; len <= n; len++) {\n            for (int i = 0; i < nways.length; i++) {\n                Arrays.fill(nways[i], 0);\n            }\n            for (int need0 = 0; need0 < ways.length; need0++) {\n                for (int need1 = 0; need1 < ways[need0].length; need1++) {\n                    int c = ways[need0][need1];\n                    if (c == 0) {\n                        continue;\n                    }\n                    {\n                        // 0\n                        int sufLen = len - need0 - need1;\n                        int used = n - sufLen;\n                        if (s[used] == '0') {\n                            nways[need0][need1] = add(nways[need0][need1], c);\n                        } else {\n                            nways[need0 + 1][need1] = add(nways[need0 + 1][need1], c);\n                        }\n                    }\n                    {\n                        // 1\n                        int sufLen = len - need0 - need1;\n                        int used = n - sufLen;\n                        if (s[used] == '1') {\n                            nways[need0][need1] = add(nways[need0][need1], c);\n                        } else {\n                            nways[need0][need1 + 1] = add(nways[need0][need1 + 1], c);\n                        }\n                    }\n                }\n            }\n            int[][] tmp = ways;\n            ways = nways;\n            nways = tmp;\n            for (int need0 = 0; need0 < ways.length; need0++) {\n                for (int need1 = 0; need1 < ways[need0].length; need1++) {\n                    if (ways[need0][need1] == 0) {\n                        continue;\n                    }\n                    int sufLen = len - need0 - need1;\n                    int used = n - sufLen;\n                    if (dp[used][need0][need1]) {\n                        res = add(res, ways[need0][need1]);\n//                        System.err.println(\"len = \" + len + \", res = \" + res);\n                    }\n                }\n            }\n        }\n        out.println(res);\n    }\n\n    final int mod = 998244353;\n\n    int mul(int x, int y) {\n        return (int) ((x * 1L * y) % mod);\n    }\n\n    int add(int x, int y) {\n        x += y;\n        return x >= mod ? (x - mod) : x;\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n  public static void main(String [] args) {\n    Reader in = new Reader();\n    char [] s = in.next().toCharArray();\n    StringProcessor solver = new StringProcessor(s);\n    System.out.println(solver.countWays());\n  }\n}\nclass StringProcessor {\n  char [] s;\n  int n;\n  final int mod = 998244353;\n  boolean [][][] vis;\n  int [][][] mem;\n  int [] cnt;\n  int [][] opt;\n\n  StringProcessor(char [] s) {\n    this.s = s.clone();\n    this.n = this.s.length;\n    vis = new boolean [this.n + 1][this.n + 1][this.n + 1];\n    cnt = new int [this.n + 1];\n    opt = new int [this.n + 1][this.n + 1];\n    mem = new int [this.n + 1][this.n + 1][this.n + 1];\n    cnt[n] = 0;\n    for(int i = n - 1; i >= 0; i--) {\n      cnt[i] = cnt[i + 1];\n      if(s[i] == '1') cnt[i] = cnt[i] + 1;\n    }\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        for(int k = 0; k <= n; k++) {\n          mem[i][j][k] = -1;\n          vis[i][j][k] = false;\n        }\n        opt[i][j] = -1;\n      }\n    }\n  }\n  void dfs(int cur, int cntMove, int cntOne) {\n    if(vis[cur][cntMove][cntOne]) return ;\n    vis[cur][cntMove][cntOne] = true;\n    opt[cntMove][cntOne + cnt[cur]] = Math.max(opt[cntMove][cntOne + cnt[cur]], cur);\n    int cntZero = cur - cntMove - cntOne;\n    if(cntOne >= 2) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n    }\n    if(cntZero >= 2) {\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cntOne >= 1 && cntZero >= 1) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cur + 2 <= n) {\n      if(s[cur] == '0' || s[cur + 1] == '0') {\n        dfs(cur + 2, cntMove + 1, cntOne);\n      }\n      if(s[cur] == '1' || s[cur + 1] == '1') {\n        dfs(cur + 2, cntMove + 1, cntOne + 1);\n      }\n    }\n    if(cur + 1 <= n) {\n      if(s[cur] == '0') {\n        if(cntOne > 0) {\n          dfs(cur + 1, cntMove + 1, cntOne - 1);\n          dfs(cur + 1, cntMove + 1, cntOne);\n        }\n        if(cntZero > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      } else {\n        if(cntZero > 0) {\n          dfs(cur + 1, cntMove + 1, cntOne + 1);\n          dfs(cur + 1, cntMove + 1, cntOne);\n        }\n        if(cntOne > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      }\n    }\n  }\n  int dp(int cur, int cntOne, int cntZero) {\n    if(cntOne == 0 && cntZero == 0) {\n      return (cur == n) ? 1 : 0;\n    }\n    if(mem[cur][cntOne][cntZero] != -1) {\n      return mem[cur][cntOne][cntZero];\n    }\n    int ans = 0;\n    if(cur < n) {\n      if(s[cur] == '0') {\n        if(cntZero > 0) ans += dp(cur + 1, cntOne, cntZero - 1);\n        if(cntOne > 0) ans += dp(cur, cntOne - 1, cntZero);\n      } else {\n        if(cntOne > 0) ans += dp(cur + 1, cntOne - 1, cntZero);\n        if(cntZero > 0) ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    } else {\n      if(cntOne > 0) {\n        ans += dp(cur, cntOne - 1, cntZero);\n      }\n      if(cntZero > 0) {\n        ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    }\n    return mem[cur][cntOne][cntZero] = ans;\n  } \n  int countWays() {\n    dfs(0, 0, 0);\n    int ans = 0;\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        int idx = opt[i][j];\n        if(idx < 0) continue;\n        ans += dp(idx, j, n - i - j);\n        ans %= mod;\n      }\n    }\n    return ans;\n  }\n}\n\nclass Reader {\n  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n  StringTokenizer s = new StringTokenizer(\"\");\n  Reader () {}\n  String nextLine() {\n    try {\n      return in.readLine();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return \"Error\";\n    }\n  }\n  String next() {\n    while(!s.hasMoreTokens()) {\n      s = new StringTokenizer(nextLine());\n    }\n    return s.nextToken();\n  }\n  int nextInt() {\n    return Integer.parseInt(next());\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n  public static void main(String [] args) {\n    Reader in = new Reader();\n    char [] s = in.next().toCharArray();\n    StringProcessor solver = new StringProcessor(s);\n    System.out.println(solver.countWays());\n  }\n}\nclass StringProcessor {\n  char [] s;\n  int n;\n  final int mod = 998244353;\n  boolean [][][] vis;\n  int [][][] mem;\n  int [] cnt;\n  int [][] opt;\n\n  StringProcessor(char [] s) {\n    this.s = s.clone();\n    this.n = this.s.length;\n    vis = new boolean [this.n + 1][this.n + 1][this.n + 1];\n    cnt = new int [this.n + 1];\n    opt = new int [this.n + 1][this.n + 1];\n    mem = new int [this.n + 1][this.n + 1][this.n + 1];\n    cnt[n] = 0;\n    for(int i = n - 1; i >= 0; i--) {\n      cnt[i] = cnt[i + 1];\n      if(s[i] == '1') cnt[i] = cnt[i] + 1;\n    }\n    for(int i = 0; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        for(int k = 0; k <= n; k++) {\n          mem[i][j][k] = -1;\n          vis[i][j][k] = false;\n        }\n        opt[i][j] = -1;\n      }\n    }\n  }\n  void dfs(int cur, int cntMove, int cntOne) {\n    if(vis[cur][cntMove][cntOne]) return ;\n    vis[cur][cntMove][cntOne] = true;\n    opt[cntMove][cntOne + cnt[cur]] = Math.max(opt[cntMove][cntOne + cnt[cur]], cur);\n    int cntZero = cur - cntMove - cntOne;\n    if(cntOne >= 2) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n    }\n    if(cntZero >= 2) {\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cntOne >= 1 && cntZero >= 1) {\n      dfs(cur, cntMove + 1, cntOne - 1);\n      dfs(cur, cntMove + 1, cntOne);\n    }\n    if(cur + 2 <= n) {\n      if(s[cur] == '0' || s[cur + 1] == '0') {\n        dfs(cur + 2, cntMove + 1, cntOne);\n      }\n      if(s[cur] == '1' || s[cur + 1] == '1') {\n        dfs(cur + 2, cntMove + 1, cntOne + 1);\n      }\n    }\n    if(cur + 1 <= n) {\n      if(s[cur] == '0') {\n        if(cntOne > 0) dfs(cur + 1, cntMove + 1, cntOne - 1);\n        if(cntZero > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      } else {\n        if(cntZero > 0) dfs(cur + 1, cntMove + 1, cntOne + 1);\n        if(cntOne > 0) dfs(cur + 1, cntMove + 1, cntOne);\n      }\n    }\n  }\n  int dp(int cur, int cntOne, int cntZero) {\n    if(cntOne == 0 && cntZero == 0) {\n      return (cur == n) ? 1 : 0;\n    }\n    if(mem[cur][cntOne][cntZero] != -1) {\n      return mem[cur][cntOne][cntZero];\n    }\n    int ans = 0;\n    if(cur < n) {\n      if(s[cur] == '0') {\n        if(cntZero > 0) ans += dp(cur + 1, cntOne, cntZero - 1);\n        if(cntOne > 0) ans += dp(cur, cntOne - 1, cntZero);\n      } else {\n        if(cntOne > 0) ans += dp(cur + 1, cntOne - 1, cntZero);\n        if(cntZero > 0) ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    } else {\n      if(cntOne > 0) {\n        ans += dp(cur, cntOne - 1, cntZero);\n      }\n      if(cntZero > 0) {\n        ans += dp(cur, cntOne, cntZero - 1);\n      }\n      ans %= mod;\n    }\n    return mem[cur][cntOne][cntZero] = ans;\n  } \n  int countWays() {\n    dfs(0, 0, 0);\n    int ans = 1;\n    for(int i = 1; i <= n; i++) {\n      for(int j = 0; j <= n; j++) {\n        int idx = opt[i][j];\n        if(idx < 0) continue;\n        ans += dp(idx, j, n - i - j);\n        ans %= mod;\n      }\n    }\n    return ans;\n  }\n}\n\nclass Reader {\n  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n  StringTokenizer s = new StringTokenizer(\"\");\n  Reader () {}\n  String nextLine() {\n    try {\n      return in.readLine();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return \"Error\";\n    }\n  }\n  String next() {\n    while(!s.hasMoreTokens()) {\n      s = new StringTokenizer(nextLine());\n    }\n    return s.nextToken();\n  }\n  int nextInt() {\n    return Integer.parseInt(next());\n  }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing System.Collections.Generic;\n\nclass Myon\n\n{\n    public Myon() { }\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n    static Scanner cin;\n    int mod = 998244353;\n\n    void calc()\n    {\n        string S = cin.next();\n        \n        /*\n        string S = \"\";\n        for (int i = 0; i < 150; i++)\n        {\n            S += \"01\";\n        }\n        */\n        \n        int[] ar = new int[S.Length];\n        for (int i = 0; i < S.Length; i++)\n        {\n            ar[i] = (int)(S[i] - '0');\n        }\n        int[] revar = (int[])ar.Clone();\n        Array.Reverse(revar);\n\n        int ans = 0;\n\n        bool[,,] check = new bool[S.Length + 2, S.Length + 2, S.Length + 2];\n        check[0, 0, 0] = true;\n        for (int i = 0; i < S.Length; i++)\n        {\n            for (int j = 0; j <= S.Length; j++)\n            {\n                for (int k = 0; k <= S.Length; k++)\n                {\n                    if (!check[i, j, k]) continue;\n                    int num = i + j + k;\n                    if(num + 2 <= S.Length)\n                    {\n                        if (ar[num] == 0 || ar[num + 1] == 0) check[i + 1, j + 1, k] = true;\n                        if (ar[num] == 1 || ar[num + 1] == 1) check[i + 1, j, k + 1] = true;\n                    }\n                    if(num + 1 <= S.Length)\n                    {\n                        if (j != 0 && ar[num] == 1) check[i + 1, j - 1, k + 1] = true;\n                        if (k != 0 && ar[num] == 0) check[i + 1, j + 1, k - 1] = true;\n                        check[i + 1, j, k] = true;\n                    }\n                    if (j >= 1) check[i + 1, j - 1, k] = true;\n                    if (k >= 1) check[i + 1, j, k - 1] = true;\n                }\n            }\n        }\n\n        int[,,] dp = new int[S.Length + 1, S.Length + 2, S.Length + 2];\n        dp[0, 0, 0] = 1;\n\n        for (int a = 0; a <= S.Length; a++)\n        {\n            for (int b = 0; b <= S.Length - a; b++)\n            {\n                for (int c = 0; c <= S.Length - a - b; c++)\n                {\n                    if (dp[a, b, c] == 0) continue;\n\n                    for (int k = 0; k < 2; k++)\n                    {\n                        if (a != S.Length && revar[a] == k)\n                        {\n                            dp[a + 1, b, c] += dp[a, b, c];\n                            if (dp[a + 1, b, c] >= mod) dp[a + 1, b, c] -= mod;\n                        }\n                        else\n                        {\n                            if (k == 0)\n                            {\n                                dp[a, b + 1, c] += dp[a, b, c];\n                                if (dp[a, b + 1, c] >= mod) dp[a, b + 1, c] -= mod;\n                            }\n                            if (k == 1)\n                            {\n                                dp[a, b, c + 1] += dp[a, b, c];\n                                if (dp[a, b, c + 1] >= mod) dp[a, b, c + 1] -= mod;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\n        for (int a = 0; a <= S.Length; a++)\n        {\n            for (int b = 0; b <= S.Length - a; b++)\n            {\n                for (int c = 0; c <= S.Length - a - b; c++)\n                {\n                    if (check[S.Length - a - b - c, b, c] && dp[a,b,c] >= 1)\n                    {\n                        ans += dp[a, b, c];\n                        if (ans >= mod) ans -= mod;\n                    }\n                }\n                //if (dp[a, b, c] >= 0) Console.WriteLine(a + \" \" + b + \" \" + c + \" \" + dp[a, b, c]);\n            }\n        }\n        ans += mod - 1;\n        ans %= mod;\n        Console.WriteLine(ans);\n\n    }\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        var s = sc.Str;\n        int n = s.Length;\n        var max = new int[n + 1][];\n        var min = new int[n + 1][];\n        var cnt = new int[n + 1][];\n        for (int i = 0; i < n + 1; i++)\n        {\n            max[i] = new int[n + 1];\n            min[i] = new int[n + 1];\n            cnt[i] = new int[n + 1];\n            for (int j = 0; j < n + 1; j++)\n            {\n                max[i][j] = -M;\n                min[i][j] = M;\n            }\n        }\n        max[0][0] = 0;\n        min[0][0] = 0;\n        for (int i = 0; i < n + 1; i++)\n        {\n            for (int j = 0; j < n + 1; j++)\n            {\n                if (i + 2 < n + 1) {\n                    max[i + 2][j] = Math.Max(max[i + 2][j], max[i][j] + (s[i] == '1' || s[i + 1] == '1' ? 1 : 0));\n                    min[i + 2][j] = Math.Min(min[i + 2][j], min[i][j] + (s[i] == '1' && s[i + 1] == '1' ? 1 : 0));\n                    cnt[i + 2][j] = cnt[i][j] + 1;\n                }\n                if (i + 1 < n + 1 && j + 1 < n + 1) {\n                    max[i + 1][j + 1] = Math.Max(max[i + 1][j + 1], max[i][j] + (s[i] == '1' && (cnt[i][j] - max[i][j]) > 0 ? 1 : 0));\n                    min[i + 1][j + 1] = Math.Min(min[i + 1][j + 1], min[i][j] - (s[i] == '0' && min[i][j] > 0 ? 1 : 0));\n                    cnt[i + 1][j + 1] = cnt[i][j];\n                }\n            }\n        }\n        var max2 = new int[n + 1][];\n        var min2 = new int[n + 1][];\n        for (int i = 0; i < n + 1; i++)\n        {\n            max2[i] = new int[n + 1];\n            min2[i] = new int[n + 1];\n            for (int j = 0; j < n + 1; j++)\n            {\n                max2[i][j] = -M;\n                min2[i][j] = M;\n            }\n        }\n        for (int i = 0; i < n + 1; i++)\n        {\n            for (int j = 0; j < n + 1; j++)\n            {\n                if (max[i][j] >= 0) {\n                    max2[i][cnt[i][j]] = Math.Max(max2[i][cnt[i][j]], max[i][j]);\n                    min2[i][cnt[i][j]] = Math.Min(min2[i][cnt[i][j]], min[i][j]);\n                }\n            }\n        }\n\n        var dp = new long[n + 1][][];\n        for (int i = 0; i < n + 1; i++)\n        {\n            dp[i] = new long[n + 1][];\n            for (int j = 0; j < n + 1; j++)\n            {\n                dp[i][j] = new long[n + 1];\n            }\n        }\n        dp[n][0][0] = 1;\n        for (int i = n - 1; i >= 0 ; i--)\n        {\n            for (int j = 0; j < n + 1; j++)\n            {\n                for (int k = 0; k < n + 1; k++)\n                {\n                    if (s[i] == '0') {\n                        if (j + 1 < n + 1 && k + 1 < n + 1) {\n                            dp[i + 1][j + 1][k + 1] = (dp[i + 1][j + 1][k + 1] + dp[i + 1][j][k]) % M;\n                        }\n                    }\n                    else {\n                        if (j + 1 < n + 1) {\n                            dp[i + 1][j + 1][k] = (dp[i + 1][j + 1][k] + dp[i + 1][j][k]) % M;\n                        }\n                    }\n                    dp[i][j][k] = (dp[i][j][k] + dp[i + 1][j][k]) % M;\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < n + 1; i++)\n        {\n            for (int j = 0; j < n + 1; j++)\n            {\n                for (int k = 0; k < n + 1; k++)\n                {\n                    if (min2[i][j] <= k && k <= max2[i][j]) {\n                        ans = (ans + dp[i][j][k]) % M;\n                    }\n                }\n            }\n        }\n        Prt((ans + M - 1) % M);\n\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    // public static readonly int M = 1000000007;\n    public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\n\nlong brute(const(string) S) {\n  bool[string] vis;\n  void dfs(string s) {\n    if (s !in vis) {\n      vis[s] = true;\n      const len = cast(int)(s.length);\n      if (len >= 2) {\n        foreach (i; 2 .. len + 1) {\n          dfs(s[2 .. i] ~ s[0] ~ s[i .. len]);\n          dfs(s[2 .. i] ~ s[1] ~ s[i .. len]);\n        }\n      }\n    }\n  }\n  dfs(S);\n  return vis.length;\n}\n\n\nvoid main() {\n  \n  \n  try {\n    for (; ; ) {\n      const S = readToken();\n      const L = cast(int)(S.length);\n      \n      auto num0s = new int[L + 1];\n      auto num1s = new int[L + 1];\n      foreach (x; 0 .. L) {\n        num0s[x + 1] = num0s[x] + ((S[x] == '0') ? 1 : 0);\n        num1s[x + 1] = num1s[x] + ((S[x] == '1') ? 1 : 0);\n      }\n      \n      // num ops, floating 0s, floating 1s\n      auto can = new bool[][][](L + 1, L + 1, L + 1);\n      can[0][0][0] = true;\n      foreach (i; 0 .. L) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (can[i][a][b]) {\n            const x = i + a + b;\n            // x, x + 1\n            if (x + 2 <= L) {\n              ((S[x] == '0') ? can[i + 1][a + 1][b] : can[i + 1][a][b + 1]) = true;\n              ((S[x + 1] == '0') ? can[i + 1][a + 1][b] : can[i + 1][a][b + 1]) = true;\n            }\n            // x, 0\n            if (x + 1 <= L && a >= 1) {\n              ((S[x] == '0') ? can[i + 1][a - 1 + 1][b] : can[i + 1][a - 1][b + 1]) = true;\n              can[i + 1][a - 1 + 1][b] = true;\n            }\n            // x, 1\n            if (x + 1 <= L && b >= 1) {\n              ((S[x] == '0') ? can[i + 1][a + 1][b - 1] : can[i + 1][a][b - 1 + 1]) = true;\n              can[i + 1][a][b - 1 + 1] = true;\n            }\n            // 0, 0\n            if (a >= 2) {\n              can[i + 1][a - 2 + 1][b] = true;\n            }\n            // 0, 1\n            if (a >= 1 && b >= 1) {\n              can[i + 1][a - 1 + 1][b - 1] = true;\n              can[i + 1][a - 1][b - 1 + 1] = true;\n            }\n            // 1, 1\n            if (b >= 2) {\n              can[i + 1][a][b - 2 + 1] = true;\n            }\n          }\n        }\n      }\n      debug {\n        /*\n        if (L <= 16) {\n          foreach (i; 0 .. L + 1) {\n            writeln(\"i = \", i);\n            foreach (a; 0 .. L + 1) {\n              foreach (b; 0 .. L + 1) {\n                write(can[i][a][b] ? 1 : 0);\n              }\n              writeln;\n            }\n          }\n        }\n        //*/\n      }\n      foreach (i; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) {\n          foreach (b; 0 .. L + 1) {\n            if (can[i][a][b]) {\n              const x = i + a + b;\n              if (x > i + 1) {\n                if (S[x - 1] == '0') {\n                  if (a >= 1) assert(can[i][a - 1][b]);\n                } else {\n                  if (b >= 1) assert(can[i][a][b - 1]);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      auto dp = new Mint[][][](L + 1, L + 1, L + 1);\n      dp[L][0][0] = 1;\n      foreach_reverse (x; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (dp[x][a][b]) {\n            const len = (L - x) + a + b;\n            if (len < L) {\n              dp[x - 1][a][b] += dp[x][a][b];\n              ((S[x - 1] == '0') ? dp[x][a][b + 1] : dp[x][a + 1][b]) += dp[x][a][b];\n            }\n          }\n        }\n      }\n      \n      Mint ans = 1;\n      foreach_reverse (x; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (dp[x][a][b]) {\n            const len = (L - x) + a + b;\n            if (1 <= len && len <= L - 1) {\n              const i = L - len;\n              int aa = a, bb = b;\n              if (x < i + 1) {\n                // muda match\n                aa += num0s[i + 1] - num0s[x];\n                bb += num1s[i + 1] - num1s[x];\n              }\n              if (can[i][aa][bb]) {\n                ans += dp[x][a][b];\n              }\n            }\n          }\n        }\n      }\n      writeln(ans);\n      \n      if (L <= 16) {\n        const brt = brute(S);\n        writeln(\"brt = \", brt);\n        assert(brt == ans.x);\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998244353;\nalias Mint = ModInt!MO;\n\n\nlong brute(const(string) S) {\n  bool[string] vis;\n  void dfs(string s) {\n    if (s !in vis) {\n      vis[s] = true;\n      const len = cast(int)(s.length);\n      if (len >= 2) {\n        foreach (i; 2 .. len + 1) {\n          dfs(s[2 .. i] ~ s[0] ~ s[i .. len]);\n          dfs(s[2 .. i] ~ s[1] ~ s[i .. len]);\n        }\n      }\n    }\n  }\n  dfs(S);\n  return vis.length;\n}\n\n\nvoid main() {\n  \n  \n  try {\n    for (; ; ) {\n      const S = readToken();\n      const L = cast(int)(S.length);\n      \n      auto num0s = new int[L + 1];\n      auto num1s = new int[L + 1];\n      foreach (x; 0 .. L) {\n        num0s[x + 1] = num0s[x] + ((S[x] == '0') ? 1 : 0);\n        num1s[x + 1] = num1s[x] + ((S[x] == '1') ? 1 : 0);\n      }\n      \n      // num ops, floating 0s, floating 1s\n      auto can = new bool[][][](L + 1, L + 1, L + 1);\n      can[0][0][0] = true;\n      foreach (i; 0 .. L) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (can[i][a][b]) {\n            const x = i + a + b;\n            // x, x + 1\n            if (x + 2 <= L) {\n              ((S[x] == '0') ? can[i + 1][a + 1][b] : can[i + 1][a][b + 1]) = true;\n              ((S[x + 1] == '0') ? can[i + 1][a + 1][b] : can[i + 1][a][b + 1]) = true;\n            }\n            // x, 0\n            if (x + 1 <= L && a >= 1) {\n              ((S[x] == '0') ? can[i + 1][a - 1 + 1][b] : can[i + 1][a - 1][b + 1]) = true;\n              can[i + 1][a - 1 + 1][b] = true;\n            }\n            // x, 1\n            if (x + 1 <= L && b >= 1) {\n              ((S[x] == '0') ? can[i + 1][a + 1][b - 1] : can[i + 1][a][b - 1 + 1]) = true;\n              can[i + 1][a][b - 1 + 1] = true;\n            }\n            // 0, 0\n            if (a >= 2) {\n              can[i + 1][a - 2 + 1][b] = true;\n            }\n            // 0, 1\n            if (a >= 1 && b >= 1) {\n              can[i + 1][a - 1 + 1][b - 1] = true;\n              can[i + 1][a - 1][b - 1 + 1] = true;\n            }\n            // 1, 1\n            if (b >= 2) {\n              can[i + 1][a][b - 2 + 1] = true;\n            }\n          }\n        }\n      }\n      debug {\n        /*\n        if (L <= 16) {\n          foreach (i; 0 .. L + 1) {\n            writeln(\"i = \", i);\n            foreach (a; 0 .. L + 1) {\n              foreach (b; 0 .. L + 1) {\n                write(can[i][a][b] ? 1 : 0);\n              }\n              writeln;\n            }\n          }\n        }\n        //*/\n      }\n      foreach (i; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) {\n          foreach (b; 0 .. L + 1) {\n            if (can[i][a][b]) {\n              const x = i + a + b;\n              if (x > i + 1) {\n                if (S[x - 1] == '0') {\n                  if (a >= 1) assert(can[i][a - 1][b]);\n                } else {\n                  if (b >= 1) assert(can[i][a][b - 1]);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      auto dp = new Mint[][][](L + 1, L + 1, L + 1);\n      dp[L][0][0] = 1;\n      foreach_reverse (x; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (dp[x][a][b]) {\n            const len = (L - x) + a + b;\n            if (len < L) {\n              dp[x - 1][a][b] += dp[x][a][b];\n              ((S[x - 1] == '0') ? dp[x][a][b + 1] : dp[x][a + 1][b]) += dp[x][a][b];\n            }\n          }\n        }\n      }\n      \n      Mint ans = 1;\n      foreach_reverse (x; 1 .. L + 1) {\n        foreach (a; 0 .. L + 1) foreach (b; 0 .. L + 1) {\n          if (dp[x][a][b]) {\n            const len = (L - x) + a + b;\n            if (1 <= len && len <= L - 1) {\n              const i = L - len;\n              int aa = a, bb = b;\n              if (x < i + 1) {\n                // muda match\n                aa += num0s[i + 1] - num0s[x];\n                bb += num1s[i + 1] - num1s[x];\n              }\n              if (can[i][aa][bb]) {\n                ans += dp[x][a][b];\n              }\n            }\n          }\n        }\n      }\n      writeln(ans);\n      \n      debug {\n        if (L <= 16) {\n          const brt = brute(S);\n          writeln(\"brt = \", brt);\n          assert(brt == ans.x);\n        }\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport numba as nb\n\n\n@nb.njit('(i1[:],)', cache=True)\ndef solve(s):\n    n = len(s)\n    size = n // 2\n    MOD = 998244353\n    dp_can = np.zeros((n + 1, size + 1, size + 1), dtype=np.int8)\n    dp_cnt = np.zeros((n + 1, size + 1, size + 1), dtype=np.int64)\n\n    dp_cnt[n, 0] = 1\n    for j in range(size):\n        dp_cnt[n, j + 1] = np.cumsum(dp_cnt[n, j]) % MOD\n\n    for i in range(n - 1, -1, -1):\n        if s[i] == 0:\n            for j in range(size + 1):\n                dp_cnt[i, j] = np.cumsum(dp_cnt[i + 1, j]) % MOD\n        else:\n            for k in range(size + 1):\n                dp_cnt[i, :, k] = np.cumsum(dp_cnt[i + 1, :, k]) % MOD\n\n    dp_can[0, 0, 0] = 1\n    for i in range(n):\n        for j in range(size):\n            for k in range(size):\n                if dp_can[i, j, k] == 0:\n                    continue\n                dp_can[i + 1, j, k] = 1\n                if j > 0 and s[i] == 1:\n                    dp_can[i + 1, j - 1, k + 1] = 1\n                if k > 0 and s[i] == 0:\n                    dp_can[i + 1, j + 1, k - 1] = 1\n                if i < n - 1:\n                    if s[i] == 0 or s[i + 1] == 0:\n                        dp_can[i + 2, j + 1, k] = 1\n                    if s[i] == 1 or s[i + 1] == 1:\n                        dp_can[i + 2, j, k + 1] = 1\n    dp_can[1:, 0, 0] = 0\n\n    ans = 0\n\n    for i in range(n, -1, -1):\n        for j in range(size + 1):\n            for k in range(size + 1):\n                if dp_can[i, j, k] == 0:\n                    continue\n\n                ans = (ans + dp_cnt[i, j, k]) % MOD\n\n                a, b = j, k\n                for h in range(i - 1, -1, -1):\n                    if s[h] == 0:\n                        a -= 1\n                    else:\n                        b -= 1\n                    if a < 0 or b < 0:\n                        break\n                    dp_can[h, a, b] = 0\n\n    return ans\n\n\ns = np.array([int(c) for c in input()], dtype=np.int8)\nprint(solve(s))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport numba as nb\n\n\n@nb.njit('(i1[:],)', cache=True)\ndef solve(s):\n    n = len(s)\n    size = n // 2\n    MOD = 998244353\n    dp_can = np.zeros((n + 1, size + 1, size + 1), dtype=np.int8)\n    dp_cnt = np.zeros((n + 1, size + 1, size + 1), dtype=np.int64)\n\n    dp_cnt[n, 0] = 1\n    for j in range(size):\n        dp_cnt[n, j + 1] = np.cumsum(dp_cnt[n, j]) % MOD\n\n    for i in range(n - 1, -1, -1):\n        if s[i] == 0:\n            for j in range(size + 1):\n                dp_cnt[i, j] = np.cumsum(dp_cnt[i + 1, j]) % MOD\n        else:\n            for k in range(size + 1):\n                dp_cnt[i, :, k] = np.cumsum(dp_cnt[i + 1, :, k]) % MOD\n\n    dp_can[0, 0, 0] = 1\n    for i in range(n):\n        dp_can[i + 1] |= dp_can[i]\n        if s[i] == 0:\n            dp_can[i + 1, 1:, :-1] |= dp_can[i, :-1, 1:]\n        else:\n            dp_can[i + 1, :-1, 1:] |= dp_can[i, 1:, :-1]\n        if i < n - 1:\n            if s[i] == 0 or s[i + 1] == 0:\n                dp_can[i + 2, 1:, :] |= dp_can[i, :-1, :]\n            if s[i] == 1 or s[i + 1] == 1:\n                dp_can[i + 2, :, 1:] |= dp_can[i, :, :-1]\n    dp_can[1:, 0, 0] = 0\n\n    ans = 0\n\n    for i in range(n, -1, -1):\n        for j in range(size + 1):\n            for k in range(size + 1):\n                if dp_can[i, j, k] == 0:\n                    continue\n\n                ans = (ans + dp_cnt[i, j, k]) % MOD\n\n                a, b = j, k\n                for h in range(i - 1, -1, -1):\n                    if s[h] == 0:\n                        a -= 1\n                    else:\n                        b -= 1\n                    if a < 0 or b < 0:\n                        break\n                    dp_can[h, a, b] = 0\n\n    return ans\n\n\ns = np.array([int(c) for c in input()], dtype=np.int8)\nprint(solve(s))\n"
  },
  {
    "language": "Python",
    "code": "import math\nX = int(input())\nlcm = 360 * X // math.gcd(360, X)\nprint(lcm // X)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef solve(s):\n    n = len(s)\n    size = n // 2\n    MOD = 998244353\n    dp_can = np.zeros((n + 1, size + 1, size + 1), dtype=np.int8)\n    dp_cnt = np.zeros((n + 1, size + 1, size + 1), dtype=np.int64)\n\n    dp_cnt[n, 0] = 1\n    for j in range(size):\n        dp_cnt[n, j + 1] = np.cumsum(dp_cnt[n, j]) % MOD\n\n    for i in range(n - 1, -1, -1):\n        if s[i] == '0':\n            dp_cnt[i] = np.cumsum(dp_cnt[i + 1], axis=1) % MOD\n        else:\n            dp_cnt[i] = np.cumsum(dp_cnt[i + 1], axis=0) % MOD\n\n    dp_can[0, 0, 0] = 1\n    for i in range(n):\n        dp_can[i + 1] |= dp_can[i]\n        if s[i] == '0':\n            dp_can[i + 1, 1:, :-1] |= dp_can[i, :-1, 1:]\n        else:\n            dp_can[i + 1, :-1, 1:] |= dp_can[i, 1:, :-1]\n        if i < n - 1:\n            if s[i] == '0' or s[i + 1] == '0':\n                dp_can[i + 2, 1:, :] |= dp_can[i, :-1, :]\n            if s[i] == '1' or s[i + 1] == '1':\n                dp_can[i + 2, :, 1:] |= dp_can[i, :, :-1]\n    dp_can[1:, 0, 0] = 0\n\n    ans = 0\n\n    for i in range(n, -1, -1):\n        for j in range(size + 1):\n            for k in range(size + 1):\n                if dp_can[i, j, k] == 0:\n                    continue\n\n                ans = (ans + dp_cnt[i, j, k]) % MOD\n\n                a, b = j, k\n                for h in range(i - 1, -1, -1):\n                    if s[h] == '0':\n                        a -= 1\n                    else:\n                        b -= 1\n                    if a < 0 or b < 0:\n                        break\n                    dp_can[h, a, b] = 0\n\n    return ans\n\n\ns = input()\nans = solve(s)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import math\n\nX=int(input())\nprint(360//math.gcd(360,X))\n    "
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nN = 2*10**3\ng1 = [1]*(N+1) # 元テーブル\ng2 = [1]*(N+1) #逆元テーブル\ninverse = [1]*(N+1) #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\nimport time\nS=input()\nN=len(S)\n#print(N)\nstart=time.time()\nif N==1:\n    exit(print(1))\n\ndp=[[[-10**15 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\ndpf=[[[-10**15 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\n\ndpf[0][0][0]=1\nif S[0]==\"0\":\n    dp[1][1][0]=0\nif S[1]==\"0\":\n    dp[1][1][0]=0\nif S[0]==\"1\":\n    dp[1][0][1]=0\nif S[1]==\"1\":\n    dp[1][0][1]=0\ndpf[1][0][0]=2\nZero=1-int(S[0])+1-int(S[1])\nOne=int(S[0])+int(S[1])\nfor i in range(2,N):\n    Zero+=1-int(S[i])\n    One+=int(S[i])\n    for j in range(Zero+1):\n        for k in range(One+1):\n            a,b=1-int(S[i]),int(S[i])\n            dp[i][j][k]=max(dp[i-1][j-a][k-b]-2,dpf[i-1][j-a][k-b]-1)\n            a,b=1-int(S[i-1]),int(S[i-1])\n            dpf[i][j][k]=max(dpf[i-1][j][k]+1,dp[i-1][j][k]+1-dp[i-1][j][k]%2)\n            dp[i][j][k]=max(dp[i][j][k],2*(dpf[i-2][j-a][k-b]//2),2*(dp[i-2][j-a][k-b]//2))\n            if dp[i][j][k]<0:\n              dp[i][j][k]=-10**5\n            if dpf[i][j][k]<0:\n              dpf[i][j][k]=-10**5\n    dpf[i][0][0]=i+1\n\nmed=time.time()\n#print(med-start)\n\nS=[S[-i-1] for i in range(N)]\nZero=0\nOne=0\nans=1\ncheck=set([])\none,zero=S.count(\"1\"),S.count(\"0\")\nfor i in range(N):\n    Zero+=(S[i]==\"1\")\n    One+=(S[i]==\"0\")\n    for j in range(zero+1):\n        for k in range(one+1):\n            if (dp[N-1-i][j][k]>=0 or dpf[N-1-i][j][k]>=0) and (j,k)!=(0,0):\n                check.add((j,k))\n    ncheck=set([])\n    for j,k in check:\n        A,B=1,1\n        if j!=0:\n            A=cmb(Zero+j-1,j,mod)\n        if k!=0:\n            B=cmb(One+k-1,k,mod)\n        ans+=A*B\n        ans%=mod\n        a,b=1-int(S[i]),int(S[i])\n        if j>=a and k>=b:\n            ncheck.add((j-a,k-b))\n    check=ncheck\n    zero-=1-int(S[i])\n    one-=int(S[i])\n\nprint(ans)\n\ndef check():\n    res=0\n    for i in range(N):\n        for j in range(N+1):\n            for k in range(N+1) :\n                if data[i][j][k]:\n                    print(i,j,k)\n                    res+=1\n    return res\n#print(time.time()-start)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python\nimport math\nfrom copy import copy, deepcopy\nfrom copy import deepcopy as dcp\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2分探索\n#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下\nfrom collections import deque\n#deque(l), pop(), append(x), popleft(), appendleft(x)\n##listでqueの代用をするとO(N)の計算量がかかってしまうので注意\nfrom collections import Counter#文字列を個数カウント辞書に、\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate,combinations,permutations#累積和\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone\n#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする\nfrom functools import lru_cache#pypyでもうごく\n#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率\nfrom decimal import Decimal\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\ndef alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65\ndef num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)\ndef matmat(A,B):\n    K,N,M=len(B),len(A),len(B[0])\n    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]\ndef matvec(M,v):\n    N,size=len(v),len(M)\n    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]\ndef T(M):\n    n,m=len(M),len(M[0])\n    return [[M[j][i] for j in range(n)] for i in range(m)]\ndef main():\n    mod = 998244353\n    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え\n\n    #N = int(input())\n    #N, K = map(int, input().split())\n    #A = tuple(map(int, input().split())) #1行ベクトル\n    #L = tuple(int(input()) for i in range(N)) #改行ベクトル\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列\n    s=input()\n    l1=sum(map(int, s))\n    l=len(s)\n    l0=l-l1\n    dp=[[[0]*(l1+1) for _ in range(l0+1)] for _ in range(l+1)]\n    dp[0][0][0]=1\n    dp[1][0][0]=1\n    def extgcd1(a0,b0):#計算量log(b0),フェルマーの小定理より早い\n        u,v,a,b=1,0,a0,b0\n        while b: t=a//b; a-=t*b; a,b=b,a; u,v=v,u-t*v\n        if a!=1: return -1#互いに素じゃない\n        return u%b0\n    \n    maxn=l\n    fact=[1]*(maxn+1)#NはnCrの最大のn\n    ifact=[1]*(maxn+1)\n    x=1\n    for i in range(2,maxn+1):\n        x=(x*i)%mod\n        fact[i]=x\n        ifact[i]=extgcd1(x,mod)\n    def comb(n,r): \n        if n<0 or r>n:\n            return 0\n        return (fact[n]*ifact[r]%mod)*ifact[n-r]%mod\n\n    for k in range(2,l+1):\n        for i in range(min(l0+1,k+1)):\n            for j in range(min(l1+1,k-i+1)):\n                dp[k][i][j]=dp[k-1][i][j]\n                if s[k-1]==\"0\" and i>0 and j+1<=l1:\n                    dp[k][i][j]|=dp[k-1][i-1][j+1]\n                elif s[k-1]==\"1\" and j>0 and i+1<=l0:\n                    dp[k][i][j]|=dp[k-1][i+1][j-1]\n                if s[k-2]==\"0\" and i>0:\n                    dp[k][i][j]|=dp[k-2][i-1][j]\n                if s[k-2]==\"1\" and j>0:\n                    dp[k][i][j]|=dp[k-2][i][j-1]\n                #print(s[k-1],i,j)\n    ans=0\n    \n    # dp2=[[[0]*(l1+1) for _ in range(l0+1)] for _ in range(l+1)]\n    # dp2[0][0][0]=1\n    pl1=0\n    pl0=0\n    for k in range(l+1):\n        if k==l:\n            ans+=1\n            ans%=mod\n            break\n        if s[-k-1]==\"0\":\n            pl1+=1\n        else:pl0+=1\n        for i in range(l0+1):\n            for j in range(l1+1):\n                if not dp[l-k][i][j]: continue\n                x=0\n                if i+j==0:\n                    x=1\n                elif i==0:\n                    x=comb(pl1+j-1,j)\n                elif j==0:\n                    x=comb(pl0+i-1,i)\n                else:\n                    x=comb(pl0+i-1,i)*comb(pl1+j-1,j)\n\n                #print(k,pl0,pl1,i,j,x)\n                ans+=x\n                ans%=mod\n        #print(ans)\n                \n    ans=(ans-1)%mod\n    print(ans)\n    #print(dp[2])\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nN = 2*10**3\ng1 = [1]*(N+1) # 元テーブル\ng2 = [1]*(N+1) #逆元テーブル\ninverse = [1]*(N+1) #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\n\nS=input()\nN=len(S)\n\ndp=[[[-10**5 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\ndpf=[[[-10**5 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\n\ndpf[0][0][0]=1\nif S[0]==\"0\":\n    dpf[1][1][0]=0\nif S[1]==\"0\":\n    dp[1][1][0]=0\nif S[0]==\"1\":\n    dpf[1][0][1]=0\nif S[1]==\"1\":\n    dp[1][0][1]=0\ndpf[1][0][0]=2\nfor i in range(2,N):\n    for j in range(N+1):\n        for k in range(N+1):\n            a,b=1-int(S[i]),int(S[i])\n            dp[i][j][k]=max(dp[i-1][j-a][k-b]-2,dpf[i-1][j-a][k-b]-1)\n            a,b=1-int(S[i-1]),int(S[i-1])\n            if dp[i-2][j-a][k-b]>=0:\n                dpf[i][j][k]=2*(dp[i-2][j-a][k-b]//2)\n            if dpf[i-2][j-a][k-b]>=0:\n                dpf[i][j][k]=max(2*(dpf[i-2][j-a][k-b]//2),dpf[i][j][k])\n            if dp[i-1][j][k]>=0:\n                dpf[i][j][k]=max(dp[i-1][j][k]+1-dp[i-1][j][k]%2,dpf[i][j][k])\n            dpf[i][j][k]=max(dpf[i][j][k],dpf[i-1][j][k]+1)\n    dpf[i][0][0]=i+1\n\ndata=[[[(dp[i][j][k]>=0 or dpf[i][j][k]>=0)&((j,k)!=(0,0)) for k in range(N+1)] for j in range(N+1)] for i in range(N)]\n\nS=[S[-i-1] for i in range(N)]\nZero=0\nOne=0\nans=1\ncheck=set([])\nfor i in range(N):\n    Zero+=(S[i]==\"1\")\n    One+=(S[i]==\"0\")\n    for j in range(N+1):\n        for k in range(N+1):\n            if data[N-1-i][j][k]:\n                check.add((j,k))\n    ncheck=set([])\n    for j,k in check:\n        A,B=1,1\n        if j!=0:\n            A=cmb(Zero+j-1,j,mod)\n        if k!=0:\n            B=cmb(One+k-1,k,mod)\n        ans+=A*B\n        ans%=mod\n        a,b=1-int(S[i]),int(S[i])\n        if j>=a and k>=b:\n            ncheck.add((j-a,k-b))\n    check=ncheck\n\nprint(ans)\n\ndef check():\n    res=0\n    for i in range(N):\n        for j in range(N+1):\n            for k in range(N+1) :\n                if data[i][j][k]:\n                    print(i,j,k)\n                    res+=1\n    return res\n"
  },
  {
    "language": "Python",
    "code": " "
  },
  {
    "language": "Python",
    "code": "def cmb(n, r, mod):#コンビネーションの高速計算　\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nN = 2*10**3\ng1 = [1]*(N+1) # 元テーブル\ng2 = [1]*(N+1) #逆元テーブル\ninverse = [1]*(N+1) #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1[i]=( ( g1[i-1] * i ) % mod )\n    inverse[i]=( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2[i]=( (g2[i-1] * inverse[i]) % mod )\ninverse[0]=0\n\nimport time\nS=input()\nN=len(S)\n#print(N)\nstart=time.time()\nif N==1:\n    exit(print(1))\n\ndp=[[[-10**5 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\ndpf=[[[-10**5 for i in range(N+2)] for j in range(N+2)] for k in range(N+1)]\n\ndpf[0][0][0]=1\nif S[0]==\"0\":\n    dpf[1][1][0]=0\nif S[1]==\"0\":\n    dp[1][1][0]=0\nif S[0]==\"1\":\n    dpf[1][0][1]=0\nif S[1]==\"1\":\n    dp[1][0][1]=0\ndpf[1][0][0]=2\nZero=1-int(S[0])+1-int(S[1])\nOne=int(S[0])+int(S[1])\nfor i in range(2,N):\n    Zero+=1-int(S[i])\n    One+=int(S[i])\n    for j in range(Zero+1):\n        for k in range(One+1):\n            a,b=1-int(S[i]),int(S[i])\n            dp[i][j][k]=max(dp[i-1][j-a][k-b]-2,dpf[i-1][j-a][k-b]-1)\n            a,b=1-int(S[i-1]),int(S[i-1])\n            if dp[i-2][j-a][k-b]>=0:\n                dpf[i][j][k]=2*(dp[i-2][j-a][k-b]//2)\n            if dpf[i-2][j-a][k-b]>=0:\n                dpf[i][j][k]=max(2*(dpf[i-2][j-a][k-b]//2),dpf[i][j][k])\n            if dp[i-1][j][k]>=0:\n                dpf[i][j][k]=max(dp[i-1][j][k]+1-dp[i-1][j][k]%2,dpf[i][j][k])\n            dpf[i][j][k]=max(dpf[i][j][k],dpf[i-1][j][k]+1)\n    dpf[i][0][0]=i+1\n\ndata=[[[(dp[i][j][k]>=0 or dpf[i][j][k]>=0)&((j,k)!=(0,0)) for k in range(N+1)] for j in range(N+1)] for i in range(N)]\nmed=time.time()\n#print(med-start)\n\nS=[S[-i-1] for i in range(N)]\nZero=0\nOne=0\nans=1\ncheck=set([])\none,zero=S.count(\"1\"),S.count(\"0\")\nfor i in range(N):\n    Zero+=(S[i]==\"1\")\n    One+=(S[i]==\"0\")\n    for j in range(zero+1):\n        for k in range(one+1):\n            if data[N-1-i][j][k]:\n                check.add((j,k))\n    ncheck=set([])\n    for j,k in check:\n        A,B=1,1\n        if j!=0:\n            A=cmb(Zero+j-1,j,mod)\n        if k!=0:\n            B=cmb(One+k-1,k,mod)\n        ans+=A*B\n        ans%=mod\n        a,b=1-int(S[i]),int(S[i])\n        if j>=a and k>=b:\n            ncheck.add((j-a,k-b))\n    check=ncheck\n    zero-=1-int(S[i])\n    one-=int(S[i])\n\nprint(ans)\n\ndef check():\n    res=0\n    for i in range(N):\n        for j in range(N+1):\n            for k in range(N+1) :\n                if data[i][j][k]:\n                    print(i,j,k)\n                    res+=1\n    return res\n#print(time.time()-start)\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nmod modint {\n\n    #[allow(dead_code)]\n    pub struct Mod;\n    impl ConstantModulo for Mod {\n        const MOD: u32 = 998_244_353;\n    }\n\n    #[allow(dead_code)]\n    pub struct StaticMod;\n    static mut STATIC_MOD: u32 = 0;\n    impl Modulo for StaticMod {\n        fn modulo() -> u32 {\n            unsafe { STATIC_MOD }\n        }\n    }\n\n    #[allow(dead_code)]\n    impl StaticMod {\n        pub fn set_modulo(p: u32) {\n            unsafe {\n                STATIC_MOD = p;\n            }\n        }\n    }\n\n    use std::marker::*;\n    use std::ops::*;\n\n    pub trait Modulo {\n        fn modulo() -> u32;\n    }\n\n    pub trait ConstantModulo {\n        const MOD: u32;\n    }\n\n    impl<T> Modulo for T\n    where\n        T: ConstantModulo,\n    {\n        fn modulo() -> u32 {\n            T::MOD\n        }\n    }\n\n    pub struct ModInt<T>(pub u32, PhantomData<T>);\n\n    impl<T> Clone for ModInt<T> {\n        fn clone(&self) -> Self {\n            ModInt::new_unchecked(self.0)\n        }\n    }\n\n    impl<T> Copy for ModInt<T> {}\n\n    impl<T: Modulo> Add for ModInt<T> {\n        type Output = ModInt<T>;\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut d = self.0 + rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> AddAssign for ModInt<T> {\n        fn add_assign(&mut self, rhs: Self) {\n            *self = *self + rhs;\n        }\n    }\n\n    impl<T: Modulo> Sub for ModInt<T> {\n        type Output = ModInt<T>;\n        fn sub(self, rhs: Self) -> Self::Output {\n            let mut d = T::modulo() + self.0 - rhs.0;\n            if d >= T::modulo() {\n                d -= T::modulo();\n            }\n            ModInt::new_unchecked(d)\n        }\n    }\n\n    impl<T: Modulo> SubAssign for ModInt<T> {\n        fn sub_assign(&mut self, rhs: Self) {\n            *self = *self - rhs;\n        }\n    }\n\n    impl<T: Modulo> Mul for ModInt<T> {\n        type Output = ModInt<T>;\n        fn mul(self, rhs: Self) -> Self::Output {\n            let v = self.0 as u64 * rhs.0 as u64 % T::modulo() as u64;\n            ModInt::new_unchecked(v as u32)\n        }\n    }\n\n    impl<T: Modulo> MulAssign for ModInt<T> {\n        fn mul_assign(&mut self, rhs: Self) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T: Modulo> Neg for ModInt<T> {\n        type Output = ModInt<T>;\n        fn neg(self) -> Self::Output {\n            if self.0 == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(T::modulo() - self.0)\n            }\n        }\n    }\n\n    impl<T> std::fmt::Display for ModInt<T> {\n        fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n\n    impl<T: Modulo> std::str::FromStr for ModInt<T> {\n        type Err = std::num::ParseIntError;\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            let val = s.parse::<u32>()?;\n            Ok(ModInt::new(val))\n        }\n    }\n\n    impl<T: Modulo> From<usize> for ModInt<T> {\n        fn from(val: usize) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as usize) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<u64> for ModInt<T> {\n        fn from(val: u64) -> ModInt<T> {\n            ModInt::new_unchecked((val % T::modulo() as u64) as u32)\n        }\n    }\n\n    impl<T: Modulo> From<i64> for ModInt<T> {\n        fn from(val: i64) -> ModInt<T> {\n            let m = T::modulo() as i64;\n            ModInt::new((val % m + m) as u32)\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T> ModInt<T> {\n        pub fn new_unchecked(d: u32) -> Self {\n            ModInt(d, PhantomData)\n        }\n        pub fn zero() -> Self {\n            ModInt::new_unchecked(0)\n        }\n        pub fn one() -> Self {\n            ModInt::new_unchecked(1)\n        }\n        pub fn is_zero(&self) -> bool {\n            self.0 == 0\n        }\n    }\n\n    #[allow(dead_code)]\n    impl<T: Modulo> ModInt<T> {\n        pub fn new(d: u32) -> Self {\n            ModInt::new_unchecked(d % T::modulo())\n        }\n        pub fn pow(&self, mut n: u64) -> Self {\n            let mut t = Self::one();\n            let mut s = *self;\n            while n > 0 {\n                if n & 1 == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n        pub fn inv(&self) -> Self {\n            assert!(self.0 != 0);\n            self.pow(T::modulo() as u64 - 2)\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn mod_pow(r: u64, mut n: u64, m: u64) -> u64 {\n        let mut t = 1 % m;\n        let mut s = r % m;\n        while n > 0 {\n            if n & 1 == 1 {\n                t = t * s % m;\n            }\n            s = s * s % m;\n            n >>= 1;\n        }\n        t\n    }\n}\n// ---------- end ModInt ----------\n\nuse proconio::*;\nuse proconio::marker::*;\n\nuse modint::*;\n\ntype M = ModInt<Mod>;\n\nfn run() {\n    input! {\n        s: Bytes,\n    }\n    let s: Vec<usize> = s.into_iter().map(|c| (c - b'0') as usize).collect();\n    let mut cnt = [0; 2];\n    for c in s.iter() {\n        cnt[*c] += 1;\n    }\n    let (a, b) = (cnt[0], cnt[1]);\n    let len = s.len();\n    let mut dp = vec![vec![vec![M::zero(); b + 1]; a + 1]; len + 1];\n    dp[len][0][0] = M::one();\n    for i in (0..=len).rev() {\n        for j in 0..=a {\n            for k in 0..=b {\n                let v = dp[i][j][k];\n                if v.is_zero() {\n                    continue;\n                }\n                if i > 0 {\n                    dp[i - 1][j][k] += v;\n                }\n                if k + 1 <= b && (i == 0 || s[i - 1] == 0) {\n                    dp[i][j][k + 1] += v;\n                }\n                if j + 1 <= a && (i == 0 || s[i - 1] == 1) {\n                    dp[i][j + 1][k] += v;\n                }\n            }\n        }\n    }\n    let way = dp;\n    let mut ok = vec![vec![vec![false; b + 1]; a + 1]; len + 1];\n    ok[0][0][0] = true;\n    let mut ans = M::zero();\n    for i in 0..=len {\n        for j in (0..=a).rev() {\n            for k in (0..=b).rev() {\n                if !ok[i][j][k] {\n                    continue;\n                }\n                ans += way[i][j][k];\n                if j + k >= 2 {\n                    if j > 0 {\n                        ok[i][j - 1][k] = true;\n                    }\n                    if k > 0 {\n                        ok[i][j][k - 1] = true;\n                    }\n                }\n                if j + k >= 1 && i + 1 <= len {\n                    if j > 0 {\n                        ok[i][j - 1][k] = true;\n                    }\n                    if k > 0 {\n                        ok[i][j][k - 1] = true;\n                    }\n                    let mut cnt = [j, k];\n                    cnt[s[i]] += 1;\n                    if cnt[0] > 0 {\n                        ok[i + 1][cnt[0] - 1][cnt[1]] = true;\n                    }\n                    if cnt[1] > 0 {\n                        ok[i + 1][cnt[0]][cnt[1] - 1] = true;\n                    }\n                }\n                if i + 2 <= len {\n                    ok[i + 1][j][k] = true;\n                    let mut cnt = [j, k];\n                    cnt[s[i]] += 1;\n                    cnt[s[i + 1]] += 1;\n                    if s[i] == 0 || s[i + 1] == 0 {\n                        ok[i + 2][cnt[0] - 1][cnt[1]] = true;\n                    }\n                    if s[i] == 1 || s[i + 1] == 1 {\n                        ok[i + 2][cnt[0]][cnt[1] - 1] = true;\n                    }\n                }\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  }
]