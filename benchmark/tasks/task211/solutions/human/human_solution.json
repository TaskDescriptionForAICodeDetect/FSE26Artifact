[
  {
    "language": "Scala",
    "code": "object Main {\n  def bfs(ar: Array[String], x: Int, y: Int, w: Int, h: Int): Array[String] = {\n    if (x < 0 || x >= w || y < 0 || y >= h)\n      return ar\n    if (ar(y)(x) != '.')\n      return ar\n    // ????????\\?????????????????????????????????????????£???\n    var br = ar\n    br(y) = br(y).patch(x, \"C\", 1)\n    br = bfs(ar, x - 1, y, w, h)\n    br = bfs(br, x + 1, y, w, h)\n    br = bfs(br, x, y + 1, w, h)\n    br = bfs(br, x, y - 1, w, h)\n    return br\n  }\n\n\n  def solve(ar: Array[String], room: Array[Int]): Int = {\n    var x = -1\n    var y = -1\n    for(i <- 0 until ar.length) {\n      val tmp = ar(i).indexOf('@')\n      if (tmp != -1) {\n        x = tmp\n        y = i\n      }\n    }\n    var br = ar\n    br(y) = br(y).patch(x, \".\", 1)\n    br = bfs(br, x, y, room(0), room(1))\n    var cnt = 0\n    for(res <- br)\n      cnt += res.count{_ == 'C'}\n    cnt\n  }\n\n  def main(args: Array[String]) = {\n    var room = io.StdIn.readLine().split(' ').map(_.toInt)\n    while (room(0) != 0) {\n      val ar = new Array[String](room(1))\n      for (i <- 0 until room(1))\n        ar(i) = io.StdIn.readLine()\n      println(solve(ar, room))\n      room = io.StdIn.readLine().split(' ').map(_.toInt)\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n  loop\n  def loop: Unit = {\n    val Array(w, h) = readLine.trim.split(' ').map(_.toInt)\n    if (w == 0) return\n    val state = Array.tabulate(h){_ ⇒ readLine.trim.toCharArray}\n    val start = (0 until h).flatMap(y ⇒ (0 until w).find(x ⇒ state(y)(x) == '@').map(x ⇒ Point(x, y))).head\n    val queue = mutable.Queue[Point](start)\n    var count = 1\n    while(queue.nonEmpty){\n      val p = queue.dequeue()\n      for (n ← p.neighbor if (0 until h).contains(n.y) && (0 until w).contains(n.x) && state(n.y)(n.x) == '.') {\n        state(n.y)(n.x) = '#'\n        queue.enqueue(n)\n        count += 1\n      }\n    }\n    println(count)\n    loop\n  }\n  case class Point(x: Int, y: Int) {\n    def neighbor = Array(Point(x + 1, y), Point(x - 1, y), Point(x, y + 1), Point(x, y - 1))\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  val dir = List((-1, 0), (0, 1), (1, 0), (0, -1))\n\n  def inCheck(w: Int, h: Int, y: Int, x: Int) = {\n    0 <= y && y < h && 0 <= x && x < w\n  }\n\n  def solve(w: Int, h: Int, tiles: List[String]): Int = {\n    var sx, sy = 0\n    tiles.zipWithIndex.foreach(t => \n      for(x <- 0 until w) {\n        if(t._1(x) == '@') {\n          sx = x; sy = t._2\n        }\n      })\n    val used = Array.fill[Boolean](h, w)(false)\n    val queue = new scala.collection.mutable.Queue[List[Int]]\n    queue += List(sy, sx)\n    var count = 1\n    while(queue.size != 0) {\n      val pos = queue.dequeue\n      for(d <- dir) {\n        val my = pos(0) + d._1\n        val mx = pos(1) + d._2\n        if(inCheck(w, h, my, mx) && tiles(my)(mx) == '.' && !used(my)(mx)) {\n          used(my)(mx) = true\n          count += 1\n          queue += List(my, mx)\n        }\n      }\n    }\n    count\n  }\n\n  def main(args:Array[String]) = {\n    val sc = new java.util.Scanner(System.in)\n    var w, h = sc.nextInt\n    while(h != 0 || w != 0) {\n      val tiles = for(_ <- 1 to h) yield sc.next\n      println(solve(w, h, tiles.toList))\n      w = sc.nextInt; h = sc.nextInt\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  def bfs(ar: Array[String], x: Int, y: Int, w: Int, h: Int): Array[String] = {\n    if (x < 0 || x >= w || y < 0 || y >= h)\n      return ar\n    if (ar(y)(x) != '.')\n      return ar\n    // ????????\\?????????????????????????????????????????£???\n    var br = ar\n    br(y) = br(y).patch(x, \"C\", 1)\n    br = bfs(br, x - 1, y, w, h)\n    br = bfs(br, x + 1, y, w, h)\n    br = bfs(br, x, y + 1, w, h)\n    br = bfs(br, x, y - 1, w, h)\n    return br\n  }\n\n\n  def solve(ar: Array[String], room: Array[Int]): Int = {\n    var x = -1\n    var y = -1\n    for(i <- 0 until ar.length) {\n      val tmp = ar(i).indexOf('@')\n      if (tmp != -1) {\n        x = tmp\n        y = i\n      }\n    }\n    var br = ar\n    br(y) = br(y).patch(x, \".\", 1)\n    br = bfs(br, x, y, room(0), room(1))\n    var cnt = 0\n    for(res <- br)\n      cnt += res.count{_ == 'C'}\n    cnt\n  }\n\n  def main(args: Array[String]) = {\n    var room = io.StdIn.readLine().split(' ').map(_.toInt)\n    while (room(0) != 0) {\n      val ar = new Array[String](room(1))\n      for (i <- 0 until room(1))\n        ar(i) = io.StdIn.readLine()\n      println(solve(ar, room))\n      room = io.StdIn.readLine().split(' ').map(_.toInt)\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nint W, H;\nint ans = 0;\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == W || y == H) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\trep(i, H) cin >> field[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (field[i][j] == '@') dfs(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint N = 0;\nint map[21][21] = { 0 }; //map[w][h]\nint w, h;\n\nint check(int cw, int ch){\n//\tcout << cw << \"cheching\" << ch << endl;\n\tif (  (cw >= 1) && (cw <= w) && (1 <= ch) && (ch <= h) ){\n\t\tif (map[cw][ch] == 0){\n\t\t\tmap[cw][ch] = 2;\n\t\t\tN++;\n\t\t\tcheck(cw + 1, ch);\n\t\t\tcheck(cw, ch + 1);\n\t\t\tcheck(cw - 1, ch);\n\t\t\tcheck(cw, ch - 1);\n\t\t}\n\t}\n\treturn(0);\n}\n\n\nint main(void){\n\tint i, j;\n\tint sw, sh;\n\n\tstring input;\n\tcin >> w >> h;\n\n\twhile (w != 0 && h != 0){\n\t\n\t\tfor (i = 0; i < h; i++){\n\t\t\tcin >> input;\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tif (input[j] == '.') map[j + 1][i + 1] = 0;\n\t\t\t\telse{\tif(input[j] == '#') map[j + 1][i + 1] = 1;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmap[j + 1][i + 1] = 2;\n\t\t\t\t\t\t\tsw = j + 1; sh = i + 1;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tmap[sw][sh] = 0;\n\n/*\t\tfor (i = 0; i < h; i++){\n\t\t\tfor (j = 0; j < w; j++){\n\t\t\t\tcout << map[j + 1][i + 1];\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n\t\tN = 0;\n\t\tcheck(sw,sh);\n\n/*\t\tfor (i = 0; i < h; i++){\n\t\tfor (j = 0; j < w; j++){\n\t\tcout << map[j + 1][i + 1];\n\t\t}\n\t\tputchar('\\n');\n\t\t}\n*/\n\t\tcout << N << endl;\n\t\tcin >> w >> h;\n\t}\n\n\n\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nconst dx[] = {-1, 0, 1, 0};\nconst dy[] = {0, -1, 0, 1};\nchar tile[40][40];\nint h, w;\n\nint search(int nx, int ny)\n{\n\tint sum = 0;\n\tif (ny == 0 || nx == 0 || ny == h + 1 || nx == w + 1)return (sum);\n\tif (tile[nx][ny] == '.' || tile[nx][ny] == '@'){\n\t\tsum++;\n\t}\n\t\n\ttile[nx][ny] = '#';\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tif (tile[nx + dx[i]][ny + dy[i]] != '#'){\n\t\t\tsum += search(nx + dx[i], ny + dy[i]);\n\t\t}\n\t}\n\treturn (sum);\n}\n\t\t\nint main()\n{\n\twhile (1){\n\t\t\n\t\tscanf(\"%d %d\", &w, &h);\n\t\t\n\t\tif (h == 0 && w == 0)return (0);\n\t\tint mx, my;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &tile[j][i]);\n\t\t\t\tif (tile[j][i] == '@'){\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search(mx, my));\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <limits>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\n\nconst int INF = 1<<30;\nconst int MOD = (int)1e9 + 7;\nconst int MAX_N = (int)1e5 + 5;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\n#define debug(x) cout << #x << \": \" << x << endl\n\nint W, H;\n\nint solve(int x, int y, const vector<string> &table)\n{\n    queue<pair<int, int>> que;\n    que.push(make_pair(y, x));\n    vector<vector<int>> used(H, vector<int>(W, 0));\n    used[y][x] = 1;\n    int res = 0;\n    while(que.size())\n    {\n        pair<int, int> p = que.front(); que.pop();\n        res++;\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if(nx < 0 or ny < 0 or nx >= W or ny >= H) continue;\n            if(table[ny][nx] == '#' or used[ny][nx]) continue;\n            used[ny][nx] = 1;\n            que.push(make_pair(ny, nx));\n        }\n    }\n    return res;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H, W or H)\n    {\n        vector<string> table(H);\n        int sx, sy;\n        for(int i = 0; i < H; i++)\n        {\n            cin >> table[i];\n            for(int j = 0; j < table[i].size(); j++)\n            {\n                if(table[i][j] == '@') sx = j, sy = i;\n            }\n        }\n        cout << solve(sx, sy, table) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n//ranker\nusing namespace std;\n\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing pis = pair<int, string>;\nusing psi = pair<string, int>;\nusing D = double;\n\nvoid merge (int *first1, int *last1, int *first2, int *last2){\n    int size1 = last1 - first1;\n    int size2 = last2 - first2;\n    int *result = new int[size1+size2];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    while (true){\n        if (i < size1 && (first1[i] <= first2[j] || j >= size2)){\n            result[index] = first1[i];\n            ++i; ++index;\n        }\n        if (j < size2 && (first1[i] > first2[j] || i >= size1)){\n            result[index] = first2[j];\n            ++j; ++index;\n        }\n        if (i==size1 && j==size2){\n            for (i=0; i<size1; ++i) first1[i] = result[i];\n            for (j=0; j<size2; ++j) first2[j] = result[j+size1];\n            delete[] result;\n            return;\n        }\n    }\n}\nvoid MergeSort (int *first, int *last){\n    int size = last - first;\n    if(size <= 1) return;\n    MergeSort(first, first+size/2);\n    MergeSort(first+size/2, last);\n    merge(first, first+size/2, first+size/2, last);\n}\n\n\nint gcd(int a, int b)\n{\n    int c;\n\n    if (a < b) {\n        a+=b; b=a-b; a-=b;\n    }\n\n    while (b != 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nint dx[3]={-1, 0, 1};\nint dy[3]={-1, 0, 1};\nint W, H;\nchar masu[20][20];\nint cnt;\n\nint dfs(int a, int b){\n  masu[a][b] = '#';\n  cnt++;\n  REP(i, 3)REP(j, 3) if(masu[a+dx[i]][b+dy[j]]=='.' && abs(dx[i]+dy[j])==1 && a+dx[i] >= 0 && a+dx[i] < W && b+dx[j] >= 0 && b+dx[j] < H) dfs(a+dx[i], b+dy[j]);\n  return cnt;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    REP(j, H)REP(i, W) cin >> masu[i][j];\n\n    int i0, j0;\n    REP(j, H)REP(i, W) if(masu[i][j] == '@'){\n      i0=i;\n      j0=j;\n      break;\n    }\n\n    cnt = 0;\n    cnt = dfs(i0, j0);\n    cout << cnt << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define FORR(i, m, n) for(int i = m; i >= n; i--)\n#define INF (ll)2e9\n#define MOD ((ll)1e9+7)\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define next asdnext\n#define prev asdprev\n#define bit(n) (1LL<<(n))\n#define cauto const auto&\n#define println(v) cout << v << \"\\n\";\n\ninline vector<vector<vector<ll>>> makeVector(ll i, ll j, ll k) {\n    vector<vector<vector<ll>>> v(i, vector<vector<ll>>(j, vector<ll>(k, 0)));\n    return v;\n}\ninline vector<vector<ll>> makeVector(ll i, ll j) {\n    vector<vector<ll>> v(i, vector<ll>(j, 0));\n    return v;\n}\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate <class InputIterator>\nInputIterator adv(InputIterator x, typename std::iterator_traits<InputIterator>::difference_type n) {\n    advance(x, n);\n    return x;\n}\n\nclass mod {\n    static ll fact[];\npublic:\n\n    template<class... A>\n    static ll mul(A... args) {\n        ll res = 1;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res * i) % MOD;\n        }\n        return res;\n    }\n\n    static ll power(ll base, ll exp) {\n        if (exp == 0) return 1;\n        if (exp & 1) {\n            return mul(base, power(base, exp - 1));\n        } else {\n            ll p = power(base, exp / 2);\n            return mul(p, p);\n        }\n    }\n\n    static ll factorial(int n) {\n        if (fact[n] != 0) return fact[n];\n        if (n == 0) return 1;\n        return fact[n] = mul(n, factorial(n - 1));\n    }\n\n    static ll inverse(int n) {\n        return power(n, MOD - 2);\n    }\n\n    static ll comb(int n, int r) {\n        if (r < 0 || r > n) return 0;\n        return mul(factorial(n), inverse(factorial(n - r)), inverse(factorial(r)));\n    }\n\n    template<class... A>\n    static ll div(ll dividend, A... args) {\n        ll res = dividend;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = mul(res, inverse(i));\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll add(A... args) {\n        ll res = 0;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res + i) % MOD;\n        }\n        return res;\n    }\n\n    template<class... A>\n    static ll sub(ll l, A... args) {\n        ll res = l;\n        for (ll i : std::initializer_list<ll>{args...}) {\n            res = (res - i + MOD) % MOD;\n        }\n        return res;\n    }\n};\nll mod::fact[(int) 1e6 + 1];\n\nint ni() {\n    int i;\n    cin >> i;\n    return i;\n}\nll nll() {\n    ll l;\n    cin >> l;\n    return l;\n}\n\nint main()\n{\n    int dy[] = {-1, 0, 1, 0};\n    int dx[] = {0, 1, 0, -1};\n    while (true) {\n        int W = ni(), H = ni();\n        if (W == 0) break;\n        auto board = makeVector(H, W);\n        int sy, sx;\n        REP (y, H)  {\n            string line;\n            cin >> line;\n            REP (x, W) {\n                board[y][x] = (line[x] == '#');\n                if (line[x] == '@') {\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n\n        auto visited = makeVector(H, W);\n\n        deque<pair<int, int>> Q;\n        Q.push_back(make_pair(sy, sx));\n        visited[sy][sx] = true;\n\n        ll ans = 0;\n        while (!Q.empty()) {\n            ans++;\n            auto p = Q.back();\n            Q.pop_back();\n            REP(i,4) {\n                int ny = p.first + dy[i];\n                int nx = p.second + dx[i];\n                if (ny < 0 || H <= ny) continue;\n                if (nx < 0 || W <= nx) continue;\n                if (board[ny][nx]) continue;\n                if (visited[ny][nx]) continue;\n                Q.push_back(make_pair(ny, nx));\n                visited[ny][nx] = true;\n            }\n        }\n\n        cout << ans <<  endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cctype>\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repi(i,l,n) for(int (i)=(int)(l);(i)<(int)(n);(i)++)\n#define d_arr(arr, h, w) rep(i,(h) ){ cout << \"[\"; rep(j,(w) ) { cout << (arr)[i][j] << \", \"; } cout << \"]\" << endl;}\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x);\n#define fs first\n#define sc second\n\ntypedef pair<int ,int> P;\n\nchar grid[20][20];\nbool arrived[20][20];\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,1,0,-1};\nint w,h;\n\n//i,jから初めて到達可能なタイルの数の最大値(i,j)含む\nvoid rec(int i,int j){\n//    printf(\"i:%d j:%d\\n\",i,j);\n    arrived[i][j] = true;\n    grid[i][j] = '#';\n    int ret = 0;\n    rep(k,4) {\n        int next_j = j+dx[k];\n        int next_i = i+dy[k];\n        if( next_j < w && 0 <= next_j &&\n            next_i < h && 0 <= next_i &&\n            grid[next_i][next_j] == '.')\n        {\n            rec(next_i,next_j);\n        }\n    }\n}\n\nint main()\n{\n    P start;\n    while(1){\n        cin >> w >> h;\n        if( w==0 && h==0 ) {break;}\n        rep(i,20) rep(j,20) arrived[i][j] = false;\n        rep(i,h){\n            rep(j,w){\n                cin >> grid[i][j];\n                if( grid[i][j] == '@' ){ start.first=i;start.second=j; }\n            }\n        }\n        rec(start.first,start.second);\n        int ret=0;\n        rep(i,20){\n            rep(j,20){\n                if(arrived[i][j] == true ){\n                    ret+=1;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\nusing namespace std;\nchar s[100][100];\nint H, W, stx, sty;\nvoid dfs(int x, int y) {\n  if (x < 0 || y < 0 || x >= W || y >= H)\n    return;\n  if (s[y][x] == '.') {\n    s[y][x] = 'x';\n  } else\n    return;\n  dfs(x + 1, y);\n  dfs(x - 1, y);\n  dfs(x, y + 1);\n  dfs(x, y - 1);\n}\nint main() {\n  while (cin >> W >> H) {\n    int ans = 0;\n    if (H == 0 && W == 0)\n      break;\n    rep(i, H) rep(j, W) {\n      cin >> s[i][j];\n      if (s[i][j] == '@') {\n        stx = j;\n        sty = i;\n      }\n    }\n    s[sty][stx] = '.';\n    dfs(stx, sty);\n    rep(i, H) rep(j, W) {\n      if (s[i][j] == 'x')\n        ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h;\nchar tail[21][21];\nint a[]={-1,0,1,0};\nint b[]={0,1,0,-1};\nint cnt=0;\nvoid func(int x,int y);\nmain(){\n  int sx,sy;\n  while(1){\n    cin>> w>> h\n      if(w==0&&h==0) break;\n    cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>> tail[i][j];\n\tif(tail[i][j]=='@'){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    func(sx,sy);\n    cout<< cnt<< endl;\n  }\n}\n\nvoid func(int x,int y){\n  tail[y][x]='#';\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nx=x+a[i];\n    int ny=y+b[i];\n    if(nx>=0 && nx<w && ny>=0 && ny<h && tail[ny][nx]!='#'){\n      func(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\t\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nchar tile[25][25];\n\nint main()\n{\n\tconst int dir[][2] = { {-1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tint w, h;\n\twhile (scanf (\"%d %d\", &w, &h ) && w && h ){\n\t\tP s = P (-1, -1 );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tscanf (\" %c\", tile[i]+j );\n\t\t\t\tif (tile[i][j] == '@' ){\n\t\t\t\t\ts.first = i, s.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tqueue<P> que;\n\t\tque.push (s );\n\t\twhile (!que.empty() ){\n\t\t\tP curr = que.front(); que.pop();\n\t\t\tint row = curr.first;\n\t\t\tint col = curr.second;\n\t\t\trep (k, 4 ){\n\t\t\t\tint nr = row + dir[k][0];\n\t\t\t\tint nc = col + dir[k][1];\n\t\t\t\tif (nr < 0 || nc < 0 || nr >= h || nc >= w || tile[nr][nc] == '#' || tile[nr][nc] == '@' ) continue;\n\t\t\t\tque.push (P (nr, nc ) );\n\t\t\t\ttile[nr][nc] = '@';\n\t\t\t} // end rep\n\t\t} // end while\n\t\tint res = 0;\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tif (tile[i][j] == '@' ) res++;\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tprintf (\"%d\\n\", res );\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans[1000],cnt=0,sx,sy;\nstring m[20];\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tstring t;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tstring t;\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint ch[23][23],cnt;\nvoid dfs(int,int);\nint main(){\n  int w,h,i,j,k,l;\n  string in[21];\n  while(1){\n    cnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> in[i];\n    }\n    for(i=0;i<h+2;i++){\n      for(j=0;j<w+2;j++){\n    ch[i][j]=1;\n      }\n    }\n    for(i=0,k=1;k<h+1;i++,k++){\n      for(j=0,l=1;l<w+1;l++,j++){\n    if(in[i][j]=='.') ch[k][l]=0;\n    else if(in[i][j]=='#') ch[k][l]=1;\n    else ch[k][l]=2;\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n    if(ch[i][j]==2) dfs(i,j);\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid dfs(int i,int j){\n  if(ch[i][j]==1) return ;\n  ch[i][j]=1;\n  cnt++;\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j-1);\n  dfs(i,j+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n\n#define rep(idx, max)\tfor(int idx = 0, idx##Max = max; idx < idx##Max; idx ++)\n#define rrep(idx, min, max)\tfor(int idx = min, idx##Max = max; idx <= idx##Max; idx ++)\n#define MAX_W\t32\n#define MAX_H\t32\n\ntypedef std::vector<int>\tVEC;\n\nint\tg_map[MAX_W * MAX_H];\nint\tg_step;\n\ntypedef struct _POINT\n{\n\tint x, y;\n\t_POINT() {}\n\t_POINT(int _x, int _y) : x(_x), y(_y) {}\n} POINT;\n\nenum\n{\n\tRED_BLOCK = -1,\n\tBLACK_BLOCK = 0,\n};\n\nvoid PrintMap()\n{\n\trep(y, MAX_H)\n\t{\n\t\trep(x, MAX_W)\n\t\t{\n\t\t\t::printf(\"%2d|\", g_map[MAX_W * y + x]);\n\t\t}\n\t\t::putchar('\\n');\n\t}\n\t::putchar('\\n');\n}\n\nvoid Solve(POINT &pt, int step)\n{\n\tstatic int dx[] = { +1, 0, -1, 0};\n\tstatic int dy[] = { 0, +1, 0, -1};\n\n\t//PrintMap();\n\n\tg_map[MAX_W * pt.y + pt.x] = step + 1;\n\tg_step++;\n\n\trep(i, 4)\n\t{\n\t\tPOINT ptn(pt.x + dx[i], pt.y + dy[i]);\n\t\tif (g_map[MAX_W * ptn.y + ptn.x] == BLACK_BLOCK)\n\t\t{\n\t\t\tSolve(ptn, step + 1);\n\t\t}\n\t}\n}\n\nint main(int nArgs, char **lplpszArgs)\n{\n\tint\twidth, height;\n\tint\tmap[MAX_W * MAX_H];\n\n\twhile (std::cin >> width >> height, width)\n\t{\n\t\tPOINT start;\n\n\t\t// Init map info\n\t\trep(y, MAX_H)\n\t\t{\n\t\t\trep(x, MAX_W)\n\t\t\t{\n\t\t\t\tmap[MAX_W * y + x] = RED_BLOCK;\n\t\t\t}\n\t\t}\n\n\t\t// Input map info\n\t\trrep(y, 1, height)\n\t\t{\n\t\t\tchar szLine[0x100];\n\t\t\t::scanf(\"%s\", szLine + 1);\n\t\t\trrep(x, 1, width)\n\t\t\t{\n\t\t\t\tswitch(szLine[x])\n\t\t\t\t{\n\t\t\t\tcase '.':\tmap[MAX_W * y + x] = BLACK_BLOCK;\tbreak;\n\t\t\t\tcase '#':\tmap[MAX_W * y + x] = RED_BLOCK;\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tmap[MAX_W * y + x] = BLACK_BLOCK; \n\t\t\t\t\tstart = POINT(x, y);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//::printf(\"Start: (%d, %d)\\n\", start.x, start.y);\n\t\tg_step = 0;\n\t\t::memcpy(g_map, map, sizeof(map));\n\t\t::Solve(start, 0);\n\t\tstd::cout << g_step << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define RED '#'\n#define BLACK '.'\nusing namespace std;\n\nint w,h;\nchar tiles[20][20];\n\nint rc(int x,int y){\n  if( x<0 || x>=h )\n    return 0;\n  if( y<0 || y>=w )\n    return 0;\n  if( tiles[x][y]==RED )\n    return 0;\n  tiles[x][y]=RED;\n\n  int rtn=1;\n  rtn += rc( x+1,y  );\n  rtn += rc( x-1,y  );\n  rtn += rc( x,y+1  );\n  rtn += rc( x,y-1  );\n\n  return rtn;\n}\nvoid pr(){\n  for( int i=0;i<h;i++){\n    for(int j=0;j<w;j++ )\n      cout << tiles[i][j];\n    cout << endl;\n  }\n}\n\nint main(){\n  int x,y;\n\n  while( true ){\n    cin >> w >> h;\n    if( !w&&!h ) break;\n\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ ){\n\tcin >> tiles[i][j];\n\tif( tiles[i][j]=='@' ){\n\t  tiles[i][j]=BLACK;\n\t  x=i; y=j;\n\t}\n      }\n    //   pr();\n    cout << rc( x,y ) << endl;\n    //pr();\n    //break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-12;\nconst int INF = 10000;\n\nchar mp[22][22];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nbool flag[22][22];\n\nint bfs(int s,int t){\n\tint sum=0;\n\tqueue<PII>pi;\n\tpi.push(MP(s,t));\n\tflag[s][t]=true;\n\twhile(!pi.empty()){\n\t\tPII p=pi.front();pi.pop();\n\t\t\n\t\tsum++;\n\t\tREP(i,4){\n\t\t\tint y=p.first+dy[i],x=p.second+dx[i];\n\t\t\tif(mp[y][x]!='#'&&!flag[y][x]){\n\t\t\t\tflag[y][x]=true;\n\t\t\t\tpi.push(MP(y,x));\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main(){\n\tint W,H;\n\twhile(cin>>W>>H){\n\t\tif(W==0&&H==0)break;\n\t\tREP(i,22)REP(j,22){\n\t\t\tmp[i][j]='#';\n\t\t}\n\t\tCLR(flag);\n\t\tint y,x;\n\t\tREP(i,H)REP(j,W){\n\t\t\tcin>>mp[i+1][j+1];\n\t\t\tif(mp[i+1][j+1]=='@'){\n\t\t\t\tmp[i+1][j+1]='.';\n\t\t\t\ty=i+1;x=j+1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout<<\"!\"<<y<<\" \"<<x<<endl;\n\t\tcout<<bfs(y,x)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nint W, H;\nint ans = 0;\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == W || y == H) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\trep(i, H) cin >> field[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (s[i][j] == '@') solve(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) {\n        ll d = euclid(b, a % b, y, x);\n        return y -= a / b * x, d;\n    }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1)\n            ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1);\n        return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e)\n            return Mod(1);\n        Mod r = *this ^ (e / 2);\n        r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    cin >> skipws;\n    for (;;) {\n        int n, m; cin >> n >> m;\n        swap(n, m);\n\n        if (!n) break;\n\n        int p0, q0;\n\n        vector<vector<char>> mp(n, vector<char>(m, ' '));\n        vector<vi> vis(n, vi(m, 0));\n        \n        rep(i, 0, n) rep(j, 0, m) {\n            cin >> mp[i][j];\n            if (mp[i][j] == '@') p0 = i, q0 = j;\n        }        \n\n        queue<pii> q;\n        q.push({p0, q0});\n        vis[p0][q0] = true;\n        int ans = 1;\n\n        const int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        while (!q.empty()) {\n            int x, y;\n            tie(x, y) = q.front(); q.pop();\n            // cout << x << \"  \" << y << endl;\n            rep(i, 0, 4) {\n                int xx = x + dir[i][0], yy = y + dir[i][1];\n                if (xx >= 0 && xx < n && yy >= 0 && yy < m && mp[xx][yy] == '.' && !vis[xx][yy]) {\n                    vis[xx][yy] = true;\n                    q.push({xx, yy});\n                    ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\nint sx,sy;\n\nvoid solve(){\n    vector<string> t(h);\n    rep(i,h) cin >> t[i];\n\n    rep(i,h) rep(j,w) if(t[i][j]=='@'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    bool visited[32][32];\n    rep(i,32) rep(j,32) visited[i][j]=false;\n    visited[sx][sy]=true;\n    queue<pii> que;\n    que.push(pii(sx,sy));\n    while(!que.empty()){\n        auto p = que.front();\n        que.pop();\n\n        int x = p.fi;\n        int y = p.se;\n\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx<0 or ny<0 or nx>=h or ny>=w) continue;\n            if(t[nx][ny]=='#') continue;\n            if(visited[nx][ny]) continue;\n\n            visited[nx][ny] = true;\n            que.push(pii(nx,ny));\n        }\n    }\n\n    int ans = 0;\n    rep(i,h) rep(j,w) if(visited[i][j]) ans++;\n    cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint sx,sy,h,w;\nstring fld[20];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint bfs() {\n\tbool used[h][w];\n\tREP(i,h) REP(j,w) used[i][j]=false;\n\tint cnt=1;\n\tqueue<P> q;\n\tused[sy][sx]=true;\n\tq.push(P(sx,sy));\n\twhile(!q.empty()) {\n\t\tP p=q.front();q.pop();\n\t\tREP(i,4) {\n\t\t\tint nx=p.fi+dx[i],ny=p.se+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||used[ny][nx]||fld[ny][nx]=='#') continue;\n\t\t\tused[ny][nx]=true;\n\t\t\tcnt++;\n\t\t\tq.push(P(nx,ny));\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\tcin>>w>>h;\n\t\tif(w==0) break;\n\t\tREP(i,h) {\n\t\t\tcin>>fld[i];\n\t\t\tREP(j,w) if(fld[i][j]=='@') sx=j,sy=i;\n\t\t}\n\t\tcout<<bfs()<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n \nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nint d[20][20];\nconst int inf=1e8;\n \nint main(){\n \n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n \n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)d[i][j]=inf;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      d[sy][sx]=0;\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(d[ni][nj]<=d[now.first][now.second]+1) continue;\n            d[ni][nj]=d[now.first][now.second]+1;\n            Q.push(pii(ni, nj));\n         }\n      }\n \n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=(d[i][j]!=inf);\n      }\n \n      cout<< ans<< endl;\n   }\n \n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint h,w;\nchar grid[21][21];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint dfs(int x,int y){\n  if(grid[y][x]=='#')return 0;\n  grid[y][x]='#';\n  int sum=1;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(0<=nx && nx<w && 0<=ny && ny<h)sum+=dfs(nx,ny);\n  }\n  return sum;\n}\n\nint main(void){\n\n  while(cin >> w >> h,w|h){\n    for(int i=0;i<h;i++)cin >> grid[i];\n    \n    for(int y=0;y<h;y++)\n      for(int x=0;x<w;x++)\n\tif(grid[y][x]=='@')cout << dfs(x,y) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <deque>\nusing namespace std;\n\n//x, yðüêé\ntypedef pair<int, int> P;\n\nint w, h;\nchar map[22][22];\n\nint dx[] = { 0, 1, 0, -1};\nint dy[] = {-1, 0, 1,  0};\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\t\t\n\t\tP start;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> map[i];\n\t\t\tchar* at = strchr(map[i], '@');\n\t\t\tif (at != NULL) {\n\t\t\t\tstart.first = at - map[i];\n\t\t\t\tstart.second = i;\n\t\t\t}\n\t\t}\n\t\t//Ç¤\\¦³êéH\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tcout << map[i] << endl;\n\t\t}*/\n\t\t//[³DæTõ\n\t\tdeque<P> deq;\t//deque<P<int, int>>Æ·éÆ>>ZqÆÔá¦Äðß³êé\n\t\tint count = 0;\n\t\tdeq.push_back(start);\n\t\twhile (!deq.empty()) {\n\t\t\tP current = deq.back();\n\t\t\tdeq.pop_back();\n\t\t\tcount++;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nextX = dx[i] + current.first;\n\t\t\t\tint nextY = dy[i] + current.second;\n\t\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h\n\t\t\t\t\t&& map[nextY][nextX] == '.') {\n\t\t\t\t\tdeq.push_back(P(nextX, nextY));\n\t\t\t\t\tmap[nextY][nextX] = '#';//ßçÈ¢æ¤Éßé\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring map[20];\nint count,W,H;\nint walk(int ,int);\n\nint main(){\n\tint i,j;\n\twhile(cin >> W >> H,(W || H)){\n\t\tcount=0;\n\t\tfor(i=0;i<H;i++) cin >> map[i];\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tif(map[i][j]=='@') goto LOOP;\n\t\t\t}\n\t\t}\n\tLOOP:\n\t\twalk(i,j);\n\tcout << count << endl;\n\t}\n\n}\n\nint walk(int a,int b){\n\tmap[a][b] = '#';\n\tcount++;\n\tif(a+1<H && map[a+1][b]  == '.') walk(a+1,b);\n\tif(b+1<W && map[a][b+1]  == '.') walk(a,b+1);\n\tif(a-1>=0 && map[a-1][b]  == '.') walk(a-1,b);\n\tif(b-1>=0 && map[a][b-1]  == '.') walk(a,b-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000000001\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n//int dx[8] = {0,1,1,1,0,-1,-1,-1};\n//int dy[8] = {1,1,0,-1,-1,-1,0,1};\n\nint main(){\n\tint i,j,fx,fy;\n\tint w,h;\n\tchar m[30][30];\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0) break;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tif(m[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=1;\n\t\tqueue<pint> q;\n\t\tq.push(pint(fx,fy));\n\t\twhile(!q.empty()){\n\t\t\tpint c = q.front(); q.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tint nx = c.x + dx[i];\n\t\t\t\tint ny = c.y + dy[i];\n\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && m[nx][ny]=='.'){\n\t\t\t\t\tm[nx][ny] = '@';\n\t\t\t\t\tq.push(pint(nx,ny));\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX_H 22\n#define MAX_W 22\n\nint W, H, X, Y, A;\n\nchar tile[MAX_H][MAX_W];\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '@';\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (0 <= x + dx[i] <= W - 1 && 0 <= y + dy[i] <= H - 1)\n\t\t{\n\t\t\tif (tile[y + dy[i]][x + dx[i]] == '.')\n\t\t\t{\n\t\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> tile[i][j];\n\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tX = j;\n\t\t\t\t\tY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(X, Y);\n\n\t\tA = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tA++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << A << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*??°?????????????????°*/\nint W, H, ans;\nint tile[20][20];\n\n/*??¢??°??????????????????*/\nvoid DPS(int x, int y);\n\nint main() {\n\tint sx = 0, sy = 0;\n\tstring str;\n\n\twhile (cin >> W >> H, W, H) {\n\t\t/*??\\???*/\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> str;\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\ttile[i][j] = (str[j] == '#') ? 0 : 1;\n\t\t\t\t\n\t\t\t\tif (str[j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tDPS(sx, sy);\n\n\t\tcout << ans << endl;\n\t}\n}\n\nvoid DPS(int x, int y) {\n\tif (tile[y][x]) {\n\t\ttile[y][x] = 0;\n\t\tans++;\n\t\t\n\t\tif (x - 1 >= 0)\tDPS(x - 1, y);\n\t\tif (x + 1 < W)\tDPS(x + 1, y);\n\t\tif (y - 1 >= 0)\tDPS(x, y - 1);\n\t\tif (y + 1 < H)\tDPS(x, y + 1);\n\t}\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\nint h, w;\nchar mp[22][22];\n\nconst int nx[] = { 1, 0,-1, 0};\nconst int ny[] = { 0, 1, 0,-1};\n\nint dfs(int y, int x);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n\n  int sx, sy;\n\n  while(true){\n\n    cin >> w >> h;\n\n    if(w == 0 && h == 0){\n      break;\n    }\n\n    for(int i=0;i<h;i++){\n      cin >> mp[i];\n      for(int j=0;j<w;j++){\n        if(mp[i][j] == '@'){\n          sy = i;\n          sx = j; \n        } \n      }\n    }\n\n    cout << dfs(sy, sx) << endl;\n\n  }\n  return 0;\n}\n\nint dfs(int y, int x){\n  if(y >= 0 && x >= 0 && y < h && x < w && mp[y][x] != '#'){\n    mp[y][x] = '#';\n    int t = 0;\n    for(int i=0;i<4;i++){\n      t += dfs(y + ny[i], x + nx[i]);\n    }\n    return t+1;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long INF=1e15;\n\nint n,m;\nchar field[30][30];\n\nvoid dfs(int x,int y){\n    //今いる場所を書き換え\n    field[y][x]='1';\n\n    //移動を8ループ\n    for(int dx=-1;dx<=1;dx++){\n        for(int dy=-1;dy<=1;dy++){\n\n            if(dx*dy!=0)continue;\n\n            int nx=x+dx,ny=y+dy;\n\n            if(0<=nx && nx<n && 0<=ny && ny<m && field[ny][nx]=='.')dfs(nx,ny);\n        }\n    }\n    return ;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while(1){\n        cin>>n>>m;\n        \n        if(n==0&&m==0)break;\n\n        int sx,sy;\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                cin>>field[i][j];\n                if(field[i][j]=='@'){\n                    sx=j;sy=i;\n                }\n            }\n        }\n\n        dfs(sx,sy);\n\n        int res=0;\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(field[i][j]=='1')res++;\n            }\n        }\n\n        cout<<res<<endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for (int i=(n)-1;i>=0;i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define REPS(i,f,n) for (int i=(f)-1;i>=(n);i--)\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n\nchar board[21][21];\nint w, h;\nint x, y;// ?????¨?????????\n\nvoid slove(void){\n\tint cnt = 0;\n\tqueue<pint> q;\n\tq.push(make_pair(y, x));//?????¨????????????queue?????\\??????\n\n\twhile(!q.empty()){\n\t\tpint now = q.front(); q.pop();\n\t\trep(i, 4){\n\t\t\tint nowy = now.fi + dy[i];\n\t\t\tint nowx = now.se + dx[i];\n\t\t\tif (0 <= nowy <= h - 1 && 0 <= nowx && nowx <= w - 1){\n\t\t\t\tif (board[nowy][nowx] == '.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tboard[nowy][nowx] = 0;\n\t\t\t\t\tq.push(make_pair(nowy, nowx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt + 1);//?§?????????´????????\\??????\n\treturn;\n}\n\nvoid scan(int w, int h){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tcin >> board[i][j];\n\t\t\tif (board[i][j] == '@'){\n\t\t\t\ty = i; x = j;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\t/*\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tprintf(\"%c\", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tslove();\n\treturn;\n}\n\nint main(void){\n\trep(i, 1000){\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\t\tscan(w, h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <ctime>\n#include <iterator>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int nb_lignes,nb_colonnes;\n    while(cin>>nb_lignes>>nb_colonnes)\n    {\n        if(nb_lignes == 0)\n            break;\n        int res = 1;\n        vector<string> lab(nb_lignes);\n        vector<vector<bool> > visites(nb_lignes,vector<bool>(nb_colonnes,false));\n        for(int c=0;c<nb_lignes;c++) cin>>lab[c];\n        int xdep,ydep=0;\n        for(xdep=0;xdep<nb_lignes&&lab[xdep][ydep]!='@';xdep++){ for(ydep=0;ydep<nb_colonnes&&lab[xdep][ydep]!='@';ydep++);if(lab[xdep][ydep]=='@')break;}\n        vector<pair<int,int> > parcours;\n        visites[xdep][ydep]=true;\n        parcours.push_back(make_pair(xdep,ydep));\n        while(parcours.size())\n        {\n            int xact = parcours.back().first;\n            int yact = parcours.back().second;\n            parcours.pop_back();\n            int dx[4]={1,-1,0,0};\n            int dy[4]={0,0,1,-1};\n            for(int c=0;c<4;c++)\n            {\n                int x2 = xact + dx[c];\n                int y2 = yact + dy[c];\n                if(x2>=0&&x2<nb_lignes&&y2>=0&&y2<nb_colonnes&&lab[x2][y2]!='#'&&!visites[x2][y2])\n                {\n                    visites[x2][y2]=true;\n                    res++;\n                    parcours.push_back(make_pair(x2,y2));\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#define B(a,x,b) ((a)<=(x)&&(x)<(b))\n\nchar T[999];\nint x,y,cx,cy,i,c;\n\nvoid R(int a,int b){\n\tif(B(0,a,x)&&B(0,b,y)&&T[b*20+a]){\n\t\tT[b*20+a]=0;i++;R(a-1,b);R(a+1,b);R(a,b-1);R(a,b+1);\n\t}\n}\n\nmain(){\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<x*y;i++){\n\t\t\tint _x=i%x, _y=i/x;\n\t\t\tfor(;(c=getchar())!='\\n';);\n\t\t\tswitch(c){\n\t\t\t\tcase '@': cx=_x;cy=_y;\n\t\t\t\tcase '.': T[_y*20+_x]=1; break;\n\t\t\t\tcase '#': T[_y*20+_x]=0; break;\n\t\t\t}\n\t\t}\n\t\ti=0;\n\t\tR(cx,cy);\n\t\tprintf(\"%d\\n\",i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\nint dx[]={0, 0, 1, -1};\nint dy[]={1, -1, 0, 0};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n\nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(int k=0; k<4; k++){\n      int ni=i+dy[k];\n      int nj=j+dx[k];\n      if((0<=ni&&ni<H&&0<=nj&&nj<W)&&fld[ni][nj]=='#'&&used[ni][nj]==0){\n         rec(ni, nj);\n      }\n   }\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<random>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint main(){\n\n  int w, h;\n  while(cin >> w >> h){\n    if( w == 0 && h == 0 ) break;\n\n    vector<string> t(h);\n    for(int i=0; i<h; i++) cin >> t[i];\n    int x, y;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if( t[i][j] == '@' ){\n          x = j;\n          y = i;\n        }\n      }\n    }\n\n    vector< vector<bool> > b(h, vector<bool> (w, false));\n    b[y][x] = true;\n    queue< pair<int, int> > q;\n    q.push( make_pair(x, y) );\n    int dx[4] = {0, 1, 0, -1};\n    int dy[4] = {1, 0, -1, 0};\n    while(true){\n      if( q.empty() ) break;\n\n      pair<int, int> p = q.front();\n      q.pop();\n      int px = p.first;\n      int py = p.second;\n\n      for(int dir=0; dir<4; dir++){\n        int tx = px + dx[dir];\n        int ty = py + dy[dir];\n\n        if( tx < 0 || tx >= w || ty < 0 || ty >= h ) continue;\n        if( b[ty][tx] ) continue;\n        if( t[ty][tx] == '#' ) continue;\n\n        b[ty][tx] = true;\n        q.push( make_pair(tx, ty) );\n      }\n    }\n    int cnt = 0;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if( b[i][j] ) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,h,a[20][20],str1,str2,count=0,m;\n  char in;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>in;\n\tif(in=='#') a[i][j]=0;\n\telse if(in=='@') {\n\t  a[i][j]=2;\n\t}\n\telse a[i][j]=1;\n      }\n    }\n    count=0;\n    while(1){\n      m=0;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(a[i][j]==2){\n\t    m=1;\n\t    count++;\n\t    a[i][j]=3;\n\t    if(i==0){\n\t      if(j==0){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t    }\n\t    else if(j==0){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t    else if(i==h-1){\n\t      if(j==w-1){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t    }\n\t    else if(j==w-1){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t    }\n\t    else {\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(m==0) break;\n    }\n    cout<<count<<endl;\n  }\n    \n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n\nusing namespace std;\n\nint main(){\n  int w, h;\n\n  while(cin >> w >> h, !(w == 0 && h == 0)){\n    char tiles[h+2][w+2];\n    pair<int, int> start;\n\n    for(int i = 0; i < h+2; i++){\n      for(int j = 0; j < w+2; j++){\n        if(i == 0 || j == 0 || i == h+1 || j == w+1){\n          tiles[i][j] = '#';\n        }else{\n          cin >> tiles[i][j];\n          if(tiles[i][j] == '@') start = make_pair(i, j);\n        }\n      }\n    }\n\n    /*for(int i = 0; i < h+2; i++){\n      for(int j = 0; j < w+2; j++){\n\n        cout << tiles[i][j];\n      }\n      cout << endl;\n    }\n    cout << \"start is (\" << start.first << start.second << \")\" << endl;\n*/\n    int dh[4] = {-1,  0, 1, 0};\n    int dw[4] = { 0, -1, 0, 1};\n\n    int cnt = 0;\n    stack< pair<int, int> > s;\n    s.push(start);\n    pair<int, int> cur;\n\n    while(!s.empty()){\n      cur = s.top();\n      s.pop();\n      cnt++;\n\n      for(int i = 0; i < 4; i++){\n        if(tiles[cur.first + dh[i]][cur.second + dw[i]] == '.'){\n          tiles[cur.first + dh[i]][cur.second + dw[i]] = '#';\n          pair<int, int> next = make_pair(cur.first + dh[i], cur.second + dw[i]);\n          s.push(next);\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nchar A[22][22] = {};\nint f[22][22] = {};\nint W, H;\n\nbool isinrange(int i, int j) {\n\treturn 0 <= i&&i < H && 0 <= j&&j < W;\n}\n\nint di[] = { 1,0,-1,0 };\nint dj[] = { 0,1,0,-1 };\nvoid dfs(int i, int j) {\n\tif (isinrange(i, j) == false)return;\n\tif (A[i][j] == '#')return;\n\tif (f[i][j])return;\n\tf[i][j] = true;\n\trep(k, 0, 4) {\n\t\tint ii = i + di[k];\n\t\tint jj = j + dj[k];\n\t\tdfs(ii, jj);\n\t}\n}\n\nsigned main() {\n\tfor (; cin >> W >> H&&W&&H;) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tmemset(A, 0, sizeof(A));\n\t\tint ai, aj;\n\t\trep(i, 0, H) rep(j, 0, W) {\n\t\t\tcin >> A[i][j];\n\t\t\tif (A[i][j] == '@') {\n\t\t\t\tai = i, aj = j;\n\t\t\t}\n\t\t}\n\t\tdfs(ai, aj);\n\t\tint ans = 0;\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tif (f[i][j]) {\n\t\t\t\tans++;\n\t\t\t\tdump(i);\n\t\t\t\tdump(j);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\trep(i, 0, H)dumpc(f[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\n\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int _x, int _y) :x(_x), y(_y){}\n};\n\nchar tile[20][20];\nstack<point> st;\n\nint main()\n{\n\tcin.tie(0); ios::sync_with_stdio(false); \n\t//fstream fs(\"input.txt\");\n\t////////////ここから開始///////////\n\n\t\n\tint x(-1), y(-1);\n\twhile (x != 0 && y != 0){\n\t\tREP(i, 20)REP(j, 20)tile[i][j] = '#';\n\t\tcin >> x >> y;\n\t\t//fs >> x >> y;\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\t//fs >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t\tst.emplace(i, j);\n\t\t\t}\n\t\t}\n\n\t\tint dx[]{0, 1, 0, -1};\n\t\tint dy[]{1, 0, -1, 0};\n\t\tint ans(1);\n\n\t\twhile (!st.empty()){\n\t\t\tpoint now = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tint x1 = now.x + dx[i];\n\t\t\t\tint y1 = now.y + dy[i];\n\t\t\t\tif (x1 > 19 || x1 < 0 || y1 > 19 || y1 < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tile[x1][y1] == '.'){\n\t\t\t\t\tst.emplace(x1, y1);\n\t\t\t\t\ttile[x1][y1] = '#';\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n\nusing namespace std;\n\nchar map[100][100];\nchar smap[100][100];\nint ans;\n\nint serch(int nx,int ny,int maxx,int maxy)\n{\n\tint nextx[4]={1,0,-1,0},nexty[4]={0,1,0,-1};\n\tmap[ny][nx]='0';\n\tfor(int i=0;i<4;i++)\n\t\tif(0<=nx+nextx[i] && nx+nextx[i]<maxx && 0<=ny+nexty[i] && ny+nexty[i]<maxy &&map[ny+nexty[i]][nx+nextx[i]]=='.')\n\t\t\t\tserch(nx+nextx[i],ny+nexty[i],maxx,maxy);\n\treturn ans++;\n}\n\nint main()\n{\n\tint x,y;\n\tint i,j;\n\tint sx,sy;\n\t\n\tfor(;;)\n\t{\n\t\tcin >> x >> y ;\n\t\t\n\t\tif(x==0 && y==0)\n\t\t\tbreak;\n\t\t\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tsmap[i][j]=map[i][j];\n\t\t\t\tif(map[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;\n\t\tserch(sx,sy,x,y);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\nusing namespace std;\n\nint tile[21][21]={0};\nint d[21][21]={0};\nint lapse=0;\nint W,H;\nchar a;\npair<int,int> person;\nint answer=0;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool valid(int x,int y){\n    return (x>=0 && x<H && y>=0 && y<W && tile[x][y]==1);\n}\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid dfs(int x,int y){\n    ++answer;\n    d[x][y]=1;\n    //cout<<\"visited (\"<<x+1<<\",\"<<y+1<<\")\\n\";\n\n    for(int i=0;i<4;++i){\n        if(valid(x+dx[i],y+dy[i]) && d[x+dx[i]][y+dy[i]]==0){\n            dfs(x+dx[i],y+dy[i]);\n        }\n    }\n}\n\nint main(){\n    \n    \n    while(cin>>W>>H && W!=0){\n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                cin>>a;\n                if(a=='.'){\n                    tile[i][j]=1;\n                }\n                else if(a=='@'){\n                    person.first=i;\n                    person.second=j;\n                }\n            }\n        }\n\n        dfs(person.first,person.second);\n\n        cout<<answer<<\"\\n\";\n        answer=0;\n        Fill(tile,0);\n        Fill(d,0);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n\nusing namespace std;\n\nbool input();\nint bfs();\n\nint W, H;\nchar tile[20][20];\t\t//添え字は[縦][横]\nconst int INF = 1000;\ntypedef pair<int, int> P;\nint sw, sh;\nint d[20][20];\t\t//各点への最短距離の配列\nint dw[4] = {1, 0, -1, 0};\nint dh[4] = {0, 1, 0, -1};\t\t//左から順に　→↓←↑　を表す\nint count=0;\t\t//発見した黒いタイルの総数を記憶\n\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tif (!input()) return 0;\n\t\tcount = 0;\n\t\tint ans = bfs();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\n\nint bfs()\n{\n\t// printf(\"bfs()\\n\");\n\tqueue<P> que;\n\tfor (int i=0; i<20; i++)\n\t\tfor (int i2=0; i2<20; i2++)\n\t\t\td[i][i2] = INF;\n\tque.push(P(sh, sw));\n\td[sh][sw] = 0;\n\tcount++;\n\t\n\twhile (que.size())\n\t{\n\t\tP p = que.front();\n\t\tque.pop();\n\t\t\n\t\tfor (int i=0; i<4; i++)\n\t\t{\n\t\t\tint nw = p.second + dw[i];\n\t\t\tint nh = p.first + dh[i];\n\t\t\t\n\t\t\t// printf(\"nw=%d nh=%d\\n\", nw, nh);\n\t\t\t// printf(\"tile[%d][%d]=%c\\n\", nh, nw, tile[nh][nw]);\n\t\t\t// printf(\"d[%d][%d]=%d\\n\", nh, nw, d[nh][nw]);\n\t\t\t\n\t\t\tif (0<=nw && nw < W && 0<=nh && nh<H && tile[nh][nw]!='#' && d[nh][nw]==INF)\n\t\t\t{\n\t\t\t\tque.push(P(nh, nw));\n\t\t\t\td[nh][nw] = d[p.first][p.second] + 1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\n\n\n\n//１つのデータセットに対して１回呼ばれる\nbool input()\n{\n\tscanf(\"%d %d\", &W, &H);\n\t// printf(\"W=%d H=%d\\n\", W, H);\n\tif (W==0) return false;\n\n\tfor (int i=0; i<H; i++)\n\t{\n\t\tscanf(\"%s\", tile[i]);\n\t\tfor (int i2=0; i2<W; i2++)\n\t\t{\n\t\t\tif (tile[i][i2]=='@')\n\t\t\t{\n\t\t\t\tsw = i2;\n\t\t\t\tsh = i;\n\t\t\t}\n\t\t}\n\t\t// printf(\"tile[%d]=%s\\n\", i, tile[i]);\n\t\t// printf(\"%c\\n\",tile[i][5]);\n\t}\n\t\n\treturn true;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint cnt,w,h;\nstring s[21];\nvoid check(int i,int j){\n\tif(s[i][j]=='#')return;\n\tcnt++;\n\ts[i][j]='#';\n\tif(i>0)check(i-1,j);\n\tif(i<h-1)check(i+1,j);\n\tif(j>0)check(i,j-1);\n\tif(j<w-1)check(i,j+1);\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin >>w >>h;\n\t\tif(!(w||h))break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >>s[i];\n\t\t}\n\t\tcnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='@')check(i,j);\n\t\t\t}\n\t\t}\n\tcout << cnt<<endl; \n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\n\nint h, w;\nint sx, sy;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nbool used[21][21];\nint color[21][21];\n\nvoid dfs(int x, int y){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && !used[nx][ny] && color[nx][ny] == 1){\n\t\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\t\tdfs(nx, ny);\n\t\t\t\t}\n\t\t}\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile(true){\n\t\t\tcin >> w >> h;\n\t\t\tif(w == 0)break;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tstring s;\n\t\t\t\t\tcin >> s;\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\t\tif(s[j] == '.' || s[j] == '@')color[i][j] = 1;\n\t\t\t\t\t\t\telse color[i][j] = -1;\n\t\t\t\t\t\t\tif(s[j] == '@'){\n\t\t\t\t\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j] = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx, sy);\n\t\t\tint res = 0;\n\t\t\tused[sx][sy] = true;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\t\tif(used[i][j] == 1)res++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar maze[21][21];\nint maz[21][21];\nint w,h;\nint f(int x,int y){\n\tif(maz[y][x]||maze[y][x]=='#')return 0;\n\tmaz[y][x]=1;\n\ty<h-1&&f(x,y+1);\n\t0<y&&f(x,y-1);\n\tx<w-1&&f(x+1,y);\n\t0<x&&f(x-1,y);\n\treturn 0;\n}\nint main(){\n\tint x,y;\n\tfor(;cin>>w>>h,w;){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>maze[i][j];\n\t\t\t\tmaz[i][j]=0;\n\t\t\t\tif(maze[i][j]=='@'){y=i;x=j;}\n\t\t\t}\n\t\t}\n\t\tf(x,y);\n\t\tint res=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tres+=maz[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cassert>\n#include<ctime>\n#include<algorithm>\n#include<utility>\n#include<map>\n#include<set>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\n#ifdef DEBUG\n#define dprintf      printf\n#define dout(x)      cout<<#x\" = \"<<(x)<<endl\n#define darray(x,n)    {int i;rep(i,n)cout<<#x\"[\"<<i<<\"] = \"<<*((x)+i)<<endl;}\n#define dloop(i,s,g) for((i)=(s);(i)<(g);(i)++)\n#define drep(i,n)    for((i)=0;(i)<(n);(i)++)\n#define dstop()      scanf(\"%*c\")\n#else\n#define dprintf      (1)?0:printf\n#define dout(x)\n#define darray(x,n)\n#define dloop(i,s,g) if(1){}else\n#define drep(i,n)    if(1){}else\n#define dstop()      if(1){}else\n#endif\n\n#define F    first\n#define S    second\n#define pb   push_back\n#define mp   make_pair\n\n#define loop(i,s,g) for((i)=(s);(i)<(g);(i)++)\n#define rep(i,n)    for((i)=0;(i)<(n);(i)++)\n#define all(x)      (x.begin(),x.end())\n#define in(T,...) T __VA_ARGS__; impl(__VA_ARGS__);\n#define array(T,id,n) T id[n]; rep(i,n)cin>>id[i];\n\n//#define int long long;\n#ifndef int\n#define INF (0x7fffffff)\n#else\n#define INF (0x7fffffffffffffff)\n#endif\n\ntypedef  long long           ll;\ntypedef  unsigned            ui;\ntypedef  unsigned long long  ull;\ntypedef  pair<int,int>       i_i;\ntypedef  pair<ll,int>        ll_i;\ntypedef  pair<ll,ll>         ll_ll;\ntypedef  pair<double,int>    d_i;\ntypedef  pair<double,double> d_d;\n\nvoid impl(){};\ntemplate <typename T,typename... TS >\nvoid impl(T &head,TS &... tail)\n{\n  cin>>head;\n  impl(tail ...);\n}\n\nchar a[30][30]={};\nchar n='#';\nchar o='.';\t\t\t\t\t\t       \n\nint dfs(int score,int x,int y)\n{\n  a[y][x]=n;\n  score++;\n  dprintf(\"x,y=%2d,%2d = %d\\n\",x,y,score);\n  if(a[y+1][x]==o)\n    score=dfs(score,x,y+1);\n  if(a[y-1][x]==o)\n    score=dfs(score,x,y-1);\n  if(a[y][x+1]==o)\n    score=dfs(score,x+1,y);\n  if(a[y][x-1]==o)\n    score=dfs(score,x-1,y);\n  \n  return score;\n}\n\nsigned main(void)\n{\n  while(1)\n    {\n      in(int,w,h);\n      if(w==0)\n\tbreak;\n      int i,j;\n      rep(i,30)rep(j,30)a[i][j]=0;\n      int x,y;\n      rep(i,h)\n\trep(j,w)\n\t{\n\t  scanf(\" %c\",&a[i][j]);\n\t  if(a[i][j]=='@')\n\t    x=j,y=i;\n\t}\n      cout<<dfs(0,x,y)<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;  //  ????????§?????????\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)    //  ????????????????¢????????????????????????????????????°???\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nqueue<pair<int,int> > M;\nint W,H;\nint q[20+5][20+5] = {};\t\nchar p[20+5][20+5];\n\nint main() {\n\twhile(cin >> W >> H && W != 0){\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@' ){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tW = M.front().first;\n\t\t\tH = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t{\t\t\n\t\t\t\tif (p[W+dx[k]][H+dy[k]] == '.' && q[W+dx[k]][H+dy[k]] == 0)\n\t\t\t\t{\n\t\t\t\t\tM.push(make_pair(W + dx[k], H + dy[k]));\n\t\t\t\t\tq[W + dx[k]][H + dy[k]] = 1;\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n//#include<windows.h>\n\nint masu[22][22];\nint ans=0;\nint i,j;\n\nvoid saiki(int x,int y){\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\tprintf(\"%d\",ans);\n\tSleep(100);\n\tsystem(\"cls\");\n\t*/\n\tmasu[x][y]=1;\n\tans++;\n\tif(masu[x][y-1]==0)saiki(x,y-1);\n\tif(masu[x+1][y]==0)saiki(x+1,y);\n\tif(masu[x][y+1]==0)saiki(x,y+1);\n\tif(masu[x-1][y]==0)saiki(x-1,y);\n}\n\nint main(){\n\tfor(;;){\n\t\tans = 0;\n\tint W,H;\n\tint x,y;\n\tchar str[22];\n\t\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tmasu[i][j]=1;\n\t\t}\n\t}\n\t\n\tscanf(\"%d%d\", &W, &H);\n\tif(W == 0){\n\t\tbreak;\n\t}\n\tfor(i=0;i<H;i++){\n\t\tscanf(\"%s\",str);\n\t\tfor(j=0;j<W;j++){\n\t\t\tif(str[j]=='.')masu[i+1][j+1]=0;\n\t\t\tif(str[j]=='@'){\n\t\t\t\tx=i+1;\n\t\t\t\ty=j+1;\n\t\t\t\tmasu[i+1][j+1]=0;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\tprintf(\"%d\\n\",ans);\n\tsystem(\"cls\");\n\t*/\n\tsaiki(x,y);\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\t*/\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar map[21][21];\nint count;\nint x, y;\n\nvoid dfs(int nx, int ny){\n  map[ny][nx] = '#';\n  count++;\n  if (nx+1 < x && map[ny][nx+1] == '.'){\n    dfs(nx+1, ny);\n  }\n  if (nx > 0 && map[ny][nx-1] == '.'){\n    dfs(nx-1, ny);\n  }\n  if (ny+1 < y && map[ny+1][nx] == '.'){\n    dfs(nx, ny+1);\n  }\n  if (ny > 0 && map[ny-1][nx] == '.'){\n    dfs(nx, ny-1);\n  }\n  return;\n}\n\nint main(){\n  while (1){\n    cin >> x >> y;\n    if (!(x || y)) break;\n    int ix, iy;\n    count = 0;\n    for (int i = 0; i < y; i++){\n      for (int j = 0; j < x; j++){\n\tcin >> map[i][j];\n\tif (map[i][j] == '@'){ix = j; iy = i;}\n      }\n    }\n    dfs(ix, iy);\n    cout << count << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return (x < h && y < w) || (x >= 0 && y >= 0);\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\n\tmoved = 0;\n\tint initX, initY;\n\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i;\n\t\t    initY = j;\n\t\t}\n\t    }\n\t}\n\t\n\tmove(initX, initY);\n\t\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid solve(int x,int y,int MAP[20][20],int s,int n);\n\nint main()\n{\n    int x,y,num,size;\n    char c;\n    int MAP[20][20];\n\n    while(cin >> size >> num , size && num)\n    {\n        int cnt = 0;\n\n        for(int i=0; i<num; i++){\n            for(int j=0; j<size; j++){\n                cin >> c;\n                if(c == '.'){\n                    MAP[i][j] = 0;\n                }\n                if(c == '#'){\n                    MAP[i][j] = 1;\n                }\n                if(c == '@'){\n                    x = j;\n                    y = i;\n                    MAP[i][j] = 0;\n                }\n            }\n        }\n\n        solve(x,y,MAP,size,num);\n        for(int i=0; i<num; i++){\n            for(int j=0; j<size; j++){\n                if(MAP[i][j] == 2)cnt++;\n            }\n        }\n\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid solve(int x,int y,int MAP[20][20],int s,int n)\n{\n    MAP[y][x] = 2;\n\n    if(x-1 >= 0){\n        if(MAP[y][x-1] == 0){\n            solve(x-1,y,MAP,s,n);\n        }\n    }\n    if(x+1 < s){\n        if(MAP[y][x+1] == 0){\n            solve(x+1,y,MAP,s,n);\n        }\n    }\n    if(y-1 >= 0){\n        if(MAP[y-1][x] == 0){\n            solve(x,y-1,MAP,s,n);\n        }\n    }\n    if(y+1 < n){\n        if(MAP[y+1][x] == 0){\n            solve(x,y+1,MAP,s,n);\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint w,h;\nstring s[22];\nbool vis[22][22];\n\nint d[]={-1,0,1,0,-1};\n\nint dfs(int y,int x){\n\tint res=1;\n\tvis[y][x]=true;\n\trep(i,4){\n\t\tint nx=x+d[i],ny=y+d[i+1];\n\t\tif(nx<0||nx>=w||ny<0||ny>=h||s[ny][nx]=='#')continue;\n\t\tif(!vis[ny][nx])res+=dfs(ny,nx);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\tint sw,sh;\n\t\trep(i,h){\n\t\t\tcin>>s[i];\n\t\t\trep(j,w){\n\t\t\t\tif(s[i][j]=='@'){\n\t\t\t\t\tsw=j; sh=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tcout<<dfs(sh,sw)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  int w, h;\n  \n  int qi[10000], qj[10000];\n  for(;;){\n     char m[30][30];\n     for(int i=0; i<30; i++){\n       for(int j=0; j<30; j++){\n         m[i][j] = '#';\n       }\n     }\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0; i<h; i++){\n      string s;\n      cin >> s;\n      for(int j=0; j<w; j++){\n        m[i+1][j+1] = s[j];\n        if(s[j]=='@'){\n          qi[0] = i+1;\n          qj[0] = j+1;\n          m[i+1][j+1] = '.';\n        }\n      }\n    }\n    int nl=0, nr=1;\n    int count = 0;\n    while(nr-nl>0){\n      int i = qi[nl];\n      int j = qj[nl];\n      if(m[i][j]=='@'){\n        nl++;\n      }else{\n        m[i][j] = '@';\n        count++;\n        if(m[i+1][j]=='.'){\n          qi[nr] = i+1;\n          qj[nr] = j;\n          nr++;\n        }\n        if(m[i-1][j]=='.'){\n          qi[nr] = i-1;\n          qj[nr] = j;\n          nr++;\n        }\n        if(m[i][j+1]=='.'){\n          qi[nr] = i;\n          qj[nr] = j+1;\n          nr++;\n        }\n        if(m[i][j-1]=='.'){\n          qi[nr] = i;\n          qj[nr] = j-1;\n          nr++;\n        }\n        nl++;\n      }\n    }\n    /*\n    for(int i=0; i<h+2; i++){\n      for(int j=0; j<w+2; j++){\n        cout << m[i][j];\n      }\n      cout << endl;\n    }\n  */\n    \n    cout << count << endl;\n  }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\nint mod(ll a){\n    int c=a%1000000007;\n    if(c>=0)return c;\n    else return c+1000000007;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\n#define inf 100000000/*10^8*/\n\n/////////////////////////////////\n\nint w,h;\nint si,sj;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint room[25][25];\nint ans=0;\nint dfs(int x,int y){\n    room[x][y]=2;ans++;\n    for(int i=0;i<=3;i++){\n        int xx=x+dx[i],yy=y+dy[i];\n        if(0<=xx&&xx<=h-1&&0<=yy&&yy<=w-1&&room[xx][yy]==0)dfs(xx,yy);\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0)break;\n        ans=0;\n        for(int i=0;i<=h-1;i++){\n            char s[w+1];cin>>s;\n            for(int j=0;j<=w-1;j++){\n                if(s[j]=='.')room[i][j]=0;\n                else if(s[j]=='#')room[i][j]=1;\n                else if(s[j]=='@')room[i][j]=2,si=i,sj=j;\n            }\n        }\n        cout<<dfs(si,sj)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n螺旋本 p371\n\ncircumcenter:\n    https://ja.wikipedia.org/wiki/%E5%A4%96%E6%8E%A5%E5%86%86#%E5%A4%96%E5%BF%83%E3%81%AE%E4%BD%8D%E7%BD%AE\n    https://mathtrain.jp/goshin\n*/\n#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\nusing namespace std;\n#define INF 1LL << 55\n#define MAX 1LL << 30\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<int,int> P;\n//typedef pair<pair<int,int>,int> p;\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\n#define rad_to_deg(rad) (((rad) / 2 / M_PI) * 360)\ntemplate<class T,class U>bool chmin(T&a,const U&b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>bool chmax(T&a,const U&b){if(a>=b)return false;a=b;return true;}\n//__builtin_popcount(S);\n//C.erase(unique(C.begin(),C.end()),C.end());\n//#define int ll\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\nsigned main(){\n    while(true){\n        int W,H;\n        cin>>W>>H;\n        if(H==0 && W==0) return 0;\n        char C[23][23];\n        int sh,sw;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin>>C[i][j];\n                if(C[i][j]=='@'){\n                    sh=i;sw=j;\n                }\n            }\n        }\n        queue<P> que;\n        int count=1;\n        que.push(P(sh,sw));\n        while(!que.empty()){\n            P x=que.front(); que.pop();\n            for(int i=0;i<4;i++){\n                int nh=x.first+dx[i],nw=x.second+dy[i];\n                if(nh>=1 && nh<=H && nw>=1 && nw<=W && C[nh][nw]=='.'){\n                    count++;\n                    C[nh][nw]='#';\n                    que.push(P(nh,nw));\n                }\n            }\n        }\n        cout<<count<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\ttile[i][0] = '#';\n\t\t\ttile[i][h + 1] = '#';\n\t\t}\n\t\tfor (j = 0; j < 22; j++) {\n\t\t\ttile[0][j] = '#';\n\t\t\ttile[w + 1][j] = '#';\n\t\t}\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0]; used[x][y]=1;\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y-1);\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y+1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint w, h;\nchar a[21][21];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint cnt;\n\nvoid dfs(int x, int y) {\n\ta[x][y] = 0;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&a[nx][ny] == '.') {\n\t\t\tcnt++; dfs(nx, ny);\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tcnt = 1;\n\t\trep(i, h)scanf(\"%s\", a[i]);\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (a[i][j] == '@') {\n\t\t\t\tdfs(i, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nusing LL = long long;\nconst LL LINF = 1e18;\nconst double EPS = 1e-10;\nusing namespace std;\nclass Edge{\npublic:\n    int from,to,value;\n    Edge(LL a,LL b,LL c){\n        from = a;\n        to = b;\n        value = c;\n    }\n    Edge(LL a,LL b){\n        from = a;\n        to = b;\n    }\n};\n\nclass UnionFind {\npublic:\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool connect(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint main(){\n   int h,w;\n   while(cin >> w >> h){\n       if(h == 0 && w == 0)return 0;\n       UnionFind Uni(h*w);\n       vector<string> field;\n       for(int i = 0;i < h;i++){\n           string s;cin >> s;\n           field.push_back(s);\n       }\n       pair<int,int> at;\n       for(int i = 0;i < h;i++){\n           for(int j = 0;j < w;j++){\n      //         cout<<i<<\" \"<<j<<endl;\n               if(field.at(i).at(j) == '#')continue;\n               if(field.at(i).at(j) == '@'){\n                   at = make_pair(i, j);\n                   field.at(i).at(j) = '.';\n               }\n               if(i != 0){\n                   if(field.at(i-1).at(j) == '.')Uni.connect(i*w+j,(i-1)*w+j);\n               }\n               if(j != 0){\n                   if(field.at(i).at(j-1) == '.')Uni.connect(i*w+j,i*w+j-1);\n               }\n           }\n       }\n       cout<<Uni.size(at.first*w+at.second)<<endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define endl \"\\n\"\n#ifdef LOCAL\n#define lout cerr\n#else\nostream devnull(0);\n#define lout devnull\n#endif\n#define AMULET \\\n  cin.tie(0);  \\\n  ios::sync_with_stdio(false);\n// https://github.com/kurokoji/.cpp-Template/blob/master/template/template2.cpp\n#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME\n#define rep(...)                                 \\\n  GET_MACRO(__VA_ARGS__, rep4, rep3, rep2, rep1) \\\n  (__VA_ARGS__)\n#define rep1(n) rep2(_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, n) rep4(i, a, n, 1)\n#define rep4(i, a, n, d) rep5(i, a, n, d, <)\n#define rep5(i, a, n, d, o) for (auto i = decltype(n)(a), _n = (n); i o _n; i += (d))\n\n#define rrep(...)                                    \\\n  GET_MACRO(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1) \\\n  (__VA_ARGS__)\n#define rrep1(a) rrep2(_, a)\n#define rrep2(i, a) rrep3(i, a, 0)\n#define rrep3(i, a, n) rrep4(i, a, n, -1)\n#define rrep4(i, a, n, d) rep5(i, (a)-1, n, d, >=)\n\n#define dump(x) lout << #x << \" = \" << x << endl;\n// alias\ntypedef long long ll;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\n// func\ntemplate <class C>\ninline void vcin(C &c);\ntemplate <class C, class D>\ninline void vcin(C &c, D &d);\ntemplate <class C>\ninline void vcout(const C &c, const string separate = \"\\n\");\ntemplate <class T = int>\ninline T in();\n\nint w, h;\nint cnt;\nchar c[20][20];\n\nvoid dfs(int x, int y);\n\nvoid solve()\n{\n  while (true)\n  {\n    cin >> w >> h;\n    if (w == 0 && h == 0)\n    {\n      break;\n    }\n\n    int sx, sy;\n\n    rep(j, h) rep(i, w)\n    {\n      cin >> c[i][j];\n      lout << i << \",\" << j << \" \";\n      dump(c[i][j]);\n      if (c[i][j] == '@')\n      {\n        sx = i,\n        sy = j;\n      }\n    }\n    dump(sx);\n    dump(sy);\n\n    cnt = 0;\n\n    dfs(sx, sy);\n\n    cout << cnt << endl;\n  }\n}\n\nvoid dfs(int x, int y)\n{\n  if (x < 0 || y < 0 || x >= w || y >= h || c[x][y] == '#')\n    return;\n\n  cnt++;\n  dump(x);\n  dump(y);\n\n  c[x][y] = '#';\n\n  dfs(x - 1, y);\n  dfs(x + 1, y);\n  dfs(x, y - 1);\n  dfs(x, y + 1);\n\n  return;\n}\n\nsigned main()\n{\n  AMULET\n  solve();\n  return 0;\n}\n\ntemplate <class C>\ninline void vcin(C &c)\n{\n  for (auto &a : c)\n  {\n    cin >> a;\n  }\n}\ntemplate <class C, class D>\ninline void vcin(C &c, D &d)\n{\n  for (auto it1 = c.begin(), it2 = d.begin(); it1 != c.end() && it2 != d.end(); it1++, it2++)\n  {\n    cin >> *it1 >> *it2;\n  }\n}\ntemplate <class C>\ninline void vcout(const C &c, const string separate)\n{\n  for (auto it = c.begin(); it != c.end(); it++)\n  {\n    if (it != c.begin())\n      cout << separate;\n    cout << *it;\n  }\n}\ntemplate <class T = int>\ninline T in()\n{\n  T x;\n  cin >> x;\n  return (x);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nint W,H;\nbool visited[20][20];\nchar table[20][21];\n\nstruct Tile{\n\tint row,col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >=0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(int row,int col){\n\tqueue<Tile> Q;\n\tTile tile;\n\ttile.row = row;\n\ttile.col = col;\n\n\tQ.push(tile);\n\n\tTile tmp;\n\twhile(!Q.empty()){\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\n\t\tif(rangeCheck(tmp.row-1,tmp.col) == true && visited[tmp.row-1][tmp.col] == false && table[tmp.row-1][tmp.col] == '.'){\n\t\t\tvisited[tmp.row-1][tmp.col] = true;\n\n\t\t\tTile newTmp;\n\t\t\tnewTmp.row = tmp.row-1;\n\t\t\tnewTmp.col = tmp.col;\n\t\t\tQ.push(newTmp);\n\t\t}\n\t\tif(rangeCheck(tmp.row+1,tmp.col) == true && visited[tmp.row+1][tmp.col] == false && table[tmp.row+1][tmp.col] == '.'){\n\t\t\tvisited[tmp.row+1][tmp.col] = true;\n\t\t\tTile newTmp2;\n\t\t\tnewTmp2.row = tmp.row+1;\n\t\t\tnewTmp2.col = tmp.col;\n\t\t\tQ.push(newTmp2);\n\t\t}\n\t\tif(rangeCheck(tmp.row,tmp.col-1) == true && visited[tmp.row][tmp.col-1] == false && table[tmp.row][tmp.col-1] == '.'){\n\t\t\tvisited[tmp.row][tmp.col-1] = true;\n\t\t\tTile newTmp3;\n\t\t\tnewTmp3.row = tmp.row;\n\t\t\tnewTmp3.col = tmp.col-1;\n\t\t\tQ.push(newTmp3);\n\t\t}\n\t\tif(rangeCheck(tmp.row,tmp.col+1) == true && visited[tmp.row][tmp.col+1] == false && table[tmp.row][tmp.col+1] == '.'){\n\t\t\tvisited[tmp.row][tmp.col+1] = true;\n\t\t\tTile newTmp4;\n\t\t\tnewTmp4.row = tmp.row;\n\t\t\tnewTmp4.col = tmp.col+1;\n\t\t\tQ.push(newTmp4);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint x,y,count;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++)visited[i][k] = false;\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",table[i]);\n\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tif(table[i][k] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvisited[y][x] = true;\n\t\tfunc(y,x);\n\n\t\tcount = 0;\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tif(visited[i][k] == true)count++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",count);\n\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nvoid counts(int h,int w);\nint check[31][31]={0};\nchar s[31][31];\nint dh[4]={-1,0,1,0};\nint dw[4]={0,1,0,-1};\nint ww,hh;\nint counta=0;\nmain(){\n  int sw,sh,countx;\n  while(1){\n    cin>>ww>>hh;\n    if(ww==0&&hh==0) break;\n    for(int i=1;i<=hh;i++){\n      for(int j=1;j<=ww;j++){\n\tcin>>s[i][j];\n\tif(s[i][j]=='@'){\n\t  sh=i;\n\t  sw=j;\n\t}\n      }\n    }\n    counts(sh,sw);\n    cout<<counta<<endl;\n    for(int i=0;i<=30;i++){\n      for(int j=0;j<=30;j++){\n\tcheck[i][j]=0;\n      }\n    }\n    counta=0;\n  }\n}\nvoid counts(int h,int w){\n  check[h][w]=1;\n  counta++;\n  for(int i=0;i<8;i++){\n    int nh=h+dh[i];\n    int nw=w+dw[i];\n    if(nh>=1&&nh<=hh&&nw>=1&&nw<=ww&&s[nh][nw]=='.'&&check[nh][nw]==0){\n      counts(nh,nw);\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst char OK = '.';\nconst char BAD = '#';\nconst char USER = '@';\n\nint W, H;\nint cnt;\nvector<string> ts;\nvector<vector<bool>> done;\n\nvoid dfs(int y, int x) {\n\tif (y < 0 || x < 0 || y >= H || x >= W) return;\n\tif (done[y][x]) return;\n\tif (ts[y][x] == BAD) return;\n\t\n\tdone[y][x] = true;\n\tcnt++;\n\n\tfor (int dx = -1; dx <= 1; dx++) {\n\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\tif (!dy ^ !dx) {\n\t\t\t\tdfs(y + dy, x + dx);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile (cin >> W >> H, W) {\n\t\tts = vector<string>(H);\n\t\tdone = vector<vector<bool>>(H, vector<bool>(W));\n\t\tfor (auto &line : ts) cin >> line;\n\n\t\tcnt = 0;\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (ts[y][x] == USER) {\n\t\t\t\t\tdfs(y, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int H, W;\n        cin >> W >> H;\n        if(H == 0 && W == 0) break;\n        string field[21];\n        i_i start;\n        for(int i = 1; i <= H; i++) {\n            cin >> field[i];\n            field[i] = \"&\" + field[i];\n            for(int w = 1; w <= W; w++) {\n                if(field[i][w] == '@') start = {i, w};\n            }\n        }\n        queue<i_i> que;\n        que.push(start);\n        int ans = 0;\n        while(!que.empty()) {\n            i_i now = que.front();\n            que.pop();\n            int h = now.first;\n            int w = now.second;\n            //cerr << h << \" \" << w << endl;\n            if(field[h][w] == '#') continue;\n            ans++;\n            field[h][w] = '#';\n            for(int k = 0; k < 4; k++) {\n                int newh = h + dh[k];\n                int neww = w + dw[k];\n                if(neww <= 0 || neww > W || newh > H || newh <= 0) continue;\n                if(field[newh][neww] == '#') continue;\n                que.push({newh, neww});\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 21;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  int n = 0;\n  while (q.size()) {\n    n++;\n    P p = q.front();\n    q.pop();\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        f[i][j] = '#';\n        q.push(P(i, j));\n      }\n    }\n  }\n  return n;\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE][MAX_SIZE];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> f[i];\n      for (int j = 0; j < W; ++j) {\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint W, H, x[30][30] = {};\n\t\tchar str[30][30];\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tcin>>str[i][j];\n\t\t\t\tif(str[i][j] == '@') x[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\n\t\tint q = 0;\n\t\twhile(1){\n\t\t\tint z = 0;\n\t\t\tfor(int i = 0; i < W; i++){\n\t\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\t\tif(x[i][j] == 1){\n\t\t\t\t\t\tif(i > 0 && str[i - 1][j] == '.') x[i - 1][j] = 1;\n\t\t\t\t\t\tif(i < W - 1  && str[i + 1][j] == '.') x[i + 1][j] = 1;\n\t\t\t\t\t\tif(j > 0 && str[i][j - 1] == '.') x[i][j - 1] = 1;\n\t\t\t\t\t\tif(j < H - 1&& str[i][j + 1] == '.') x[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < W; i++){\n\t\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\t\tif(x[i][j] == 1) z++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z == q) break;\n\t\t\tq = z;\n\t\t}\n\t\t\n\t\tcout<<q<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<utility>\n#include<set>\n#define ll long long int\n#define ld long double\n#define INF 1000000000\n#define EPS 0.0000000001\n#define rep(i,n) for(i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main()\n{\n  int i,j,k;\n  int h,w;\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  bool used[25][25];\n  char c[25][25];\n\n  while(1){\n\n    cin>>w>>h;\n    if(w==0 && h==0)break;\n\n    int sum=1;\n    rep(i,25)rep(j,25)\n      used[i][j]=false;\n\n    rep(i,h)\n      scanf(\"%s\",c[i]);\n\n    queue<pii> q;\n    rep(i,h)rep(j,w)\n      if(c[i][j]=='@'){\n\tq.push(pii(i,j));//y,x\n\tused[i][j]=true;\n\tbreak;\n      }\n\n    while(q.size()){\n      i=q.front().first;\n      j=q.front().second;\n      q.pop();\n      rep(k,4){\n\tint y=i+dy[k];\n\tint x=j+dx[k];\n\tif(y>=0 && y<h && x>=0 && x<w && used[y][x]==false && c[y][x]=='.'){\n\t    q.push(pii(y,x));\n\t    used[y][x]=true;\n\t    sum++;\n\t  }\n      }\n    }\n\n    cout<<sum<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// \n\n/*\n..#.#..\n..#.#..\n###.###\n...@...\n###.###\n..#.#..\n..#.#..\n */\n\nusing namespace std;\n\nint W,H;\nchar c[100][101]; // c[H][W]\n\nbool visited[100][100]; // <----\n\nint dx[4] = {1,0,-1,0}; // ??? ??? ??? ???\nint dy[4] = {0,1,0,-1};\n\nvoid compute() {\n\n  memset(visited,false,sizeof visited); //memset(???????????????????????????1bit???????????????????????????) ?????????1bit????????§?????????\n\n  queue<int> que;\n  int i,j;\n  for(i=0;i<H;++i) {\n    for(j=0;j<W;++j) {\n      if( c[i][j] == '@' ) {\n\tque.push(j+i*W);\n\tvisited[i][j] = true;\n\t//break;\n\tgoto Skip;\n      }\n    }\n  }\n Skip:;\n\n  int answer = 1; // <---???????????????\n  while( !que.empty() ) { // !0 => 1  !1 => 0\n    int cur = que.front(); que.pop(); // que -> [1,2,3,4], front -> 1, pop -> [2,3,4]\n    int x = cur % W, y = cur / W; //???????????§?¨?\n    \n    for(i=0;i<4;++i) {\n      int nx = x + dx[i], ny = y + dy[i]; //?¬??????§?¨?????¨?????????§?¨?\n\n      if( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue; // 0 && 0 => 0, 1 && 0 => 0, 0 && 1 => 0, 1 && 1 => 1\n      if( c[ny][nx] == '#' || visited[ny][nx] ) continue;         // 0 || 0 => 0, 1 || 0 => 1, 0 || 1 => 1, 1 || 1 => 1\n      \n      que.push(nx+ny*W);\n      visited[ny][nx] = true;\n      ++answer;// <---???????????????\n\n    }\n    \n  }\n\n  cout << answer << endl;// <---???????????????\n\n}\n\nint main() {\n  while( scanf(\"%d %d\",&W,&H), W | H ) {\n    //while( scanf(\"%d %d\",&W,&H), W == 0 && H == 0 ) {\n    int i;\n    for(i=0;i<H;++i) {\n      scanf(\" %s\",&c[i][0]);  // c[y][x]\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nbool hoge(vector<string>& s) {\n\tint H = s.size(), W = s[0].size();\n\tbool flag = false;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (s[y][x] == '.')\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tint _x = x + dx[k], _y = y + dy[k];\n\t\t\t\t\tif (_x >= 0 && _y >= 0 && _x < W && _y < H && s[_y][_x] == '@') {\n\t\t\t\t\t\ts[y][x] = '@';\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\treturn flag;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector<string> s(H);\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\twhile (hoge(s));\n\t\tint cnt = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (s[y][x] == '@') cnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nchar field[30][30];\n\nint dfs(int y, int x) {\n  static int dy[] = {-1, 0, 1, 0};\n  static int dx[] = {0, -1, 0, 1};\n\n  if (field[y][x] == '.') {\n    field[y][x] = '#';\n    int sum = 1;\n    REP(k, 4) { sum += dfs(y + dy[k], x + dx[k]); }\n    return sum;\n  } else {\n    return 0;\n  }\n}\n\nint main() {\n  int W, H;\n  while (scanf(\"%d%d\", &W, &H), W|H) {\n    int sy = -1, sx = -1;\n    memset(field, '#', sizeof(field));\n    FOREQ(y, 1, H) FOREQ(x, 1, W) {\n      scanf(\" %c\", &field[y][x]);\n      if (field[y][x] == '@') {\n        sy = y; sx = x;\n        field[y][x] = '.';\n      }\n    }\n    printf(\"%d\\n\", dfs(sy, sx));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint H, W;\nint table[20][20];\nint cnt;\n\nvoid calc(int current_x, int current_y) {\n\ttable[current_x][current_y] = 3;\n\n\tif(current_x > 0 && table[current_x-1][current_y] == 1)\n\t\tcalc(current_x-1, current_y);\n\tif(current_y > 0 && table[current_x][current_y-1] == 1)\n\t\tcalc(current_x, current_y-1);\n\tif(current_x < W-1 && table[current_x+1][current_y] == 1)\n\t\tcalc(current_x+1, current_y);\n\tif(current_x < H-1 && table[current_x][current_y+1] == 1)\n\t\tcalc(current_x, current_y+1);\n\n\tcnt++;\n}\n\n\nint main() {\n\twhile(1) {\n\t\tcnt = 0;\n\t\tcin >> W >> H;\n\t\tif(H == 0 && W == 0) break;\n\n\t\tchar temp;\n\t\tint current[2];\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tcin >> temp;\n\t\t\t\tif(temp=='.') table[i][j] = 1;\n\t\t\t\telse if(temp=='#') table[i][j] = 2;\n\t\t\t\telse if(temp=='@') {\n\t\t\t\t\ttable[i][j] = 0;\n\t\t\t\t\tcurrent[0] = i;\n\t\t\t\t\tcurrent[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalc(current[0], current[1]);\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 2; k++) {\n            bool flag=true;\n\t\t\tfor (int i = (flag ? 0 : h-1); i >= 0; (flag ? i++ : i--)) {\n\t\t\t\tfor (int j = (flag ? 0 : w-1); j >=0 ; (flag ? j++ : j--)) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n                    if (i==h-1 && j==w-1) {\n                        flag=!flag;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = (flag ? w-1 : 0); j >= 0; flag ? j-- : j++) {\n\t\t\t\tfor (int i = (flag ? h-1 : 0); i >= 0; flag ? i-- : i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n                    if (i==h-1 && j==w-1) {\n                        flag=!flag;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstatic int W, H;\nstatic vector<string> field;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {-1, 0, 1, 0};\n\nint dfs(int x, int y) {\n    if (x < 0 || x >= W || y < 0 || y >= H || field[y][x] == '#')\n        return 0;\n\n    field[y][x] = '#';\n    int sum = 0;\n    for (int k = 0; k < 4; k++) {\n        sum += dfs(x + dx[k], y + dy[k]);\n    }\n\n    return sum + 1;\n}\n\nint main() {\n    for (;;) {\n        cin >> W >> H;\n        if (W == 0) break;\n\n        field.resize(H);\n        int sx, sy;\n        for (int y = 0; y < H; y++) {\n            cin >> field[y];\n            for (int x = 0; x < W; x++) {\n                if (field[y][x] == '@') {\n                    sx = x;\n                    sy = y;\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        cout << dfs(sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint serch(int,int);\nchar tile[20][20];\nint W,H;\n\nint main(){\n\tint posx,posy;\n\n\twhile(1){\n\t\tcin >> W >> H;\n\t\tif(W==0&&H==0) break;\n\n\t\t//^CÇÝÝ\n\t\tfor(int j=0;j<H;j++){\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(tile[i][j]=='@'){\n\t\t\t\t\tposx=i,posy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << serch(posx,posy)+1 << endl;\n\t\tfor(int j=0;j<H;j++){\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\ttile[i][j]='#';\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint serch(int x,int y){\n\t//cout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n\tint cnt=0;\n\tif(x==0&&y==0){\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==y==0\" << endl;\n\t}else if(x==W&&y==0){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==W&&y==0\" << endl;\n\t}else if(x==0&&y==H){\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"x==0&&y==H\" << endl;\n\t}else if(x==W&&y==H){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"x==W&&y==H\" << endl;\n\t}else if(x==0){\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==0\" << endl;\n\t}else if(x==W){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==W\" << endl;\n\t}else if(y==0){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"y==0\" << endl;\n\t}else if(y==H){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"y==H\" << endl;\n\t}else {\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t\t//cout << \"a---------------a\" << endl;\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t\t//cout << \"b---------------b\" << endl;\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t\t//cout << \"c---------------c\" << endl;\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t\t//cout << \"d---------------d\" << endl;\n\t\t}\n\t}\n\t//cout << endl;\n\t//for(int j=0;j<H;j++){\n\t//\tfor(int i=0;i<W;i++){\n\t//\t\tcout << tile[i][j];\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\t//\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define all(c) ((c).begin()),((c).end())\n#define debug(c) cerr<<\"> \"<<#c<<\" = \"<<(c)<<endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,a,b) for(int i=(int)(a);i<=(int)(b);i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint go(int x, int y, char m[21][21], int w, int h) {\n\tint dx[] = {1, -1, 0, 0};\n\tint dy[] = {0, 0, 1, -1};\n\tm[y][x] = '#';\n\tint res = 1;\n\trep (i, 4) {\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif(tx < 0 || tx >= w || ty < 0 || ty >= h) continue;\n\t\tif(m[ty][tx] == '.') res += go(tx, ty, m, w, h);\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor (int w, h; cin >> w >> h, (w | h) != 0; ) {\n\t\tchar m[21][21];\n\t\tint sx, sy;\n\t\trep (i, h) rep (j, w) {\n\t\t\tcin >> m[i][j];\n\t\t\tif (m[i][j] == '@') sx = j, sy = i;\n\t\t}\n\t\tcout << go(sx, sy, m, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <utility>\n#include <cstring>\n\n#define BLACK 1\n#define RED 0\n\nusing namespace std;\n\nint main() {\n  while(true) {\n    int h, w, ans = 0;\n    cin >> w >> h;\n    if(w == 0) break;\n    map<pair<int, int>, bool> visits;\n    map<pair<int, int>, int> table;\n    queue<pair<int, int> > q;\n    char t;\n    pair<int, int> now;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> t;\n\tpair<int, int> index = make_pair(i, j);\n\tif(t == '.') {\n\t  visits[index] = false;\n\t  table[index] = BLACK;\n\t}\n\telse if(t == '#') {\n\t  visits[index] = false;\n\t  table[index] = RED;\n\t}\n\telse {\n\t  visits[index] = true;\n\t  table[index] = BLACK;\n\t  now = index;\n\t}\n      }\n    }\n    q.push(now);\n    ans++;\n    while(!q.empty()){\n      now = q.front();\n      q.pop();\n      pair<int, int> s = now;\n      if(s.first > 0) {\n\ts.first--;\n\tif(table[s] == BLACK && visits[s] == false) {\n\t  ans++;\n\t  q.push(s);\n\t  visits[s] = true;\n\t}\n\ts = now;\n      }\n      if(s.first < h-1) {\n\ts.first++;\n\tif(table[s] == BLACK && visits[s] == false) {\n\t  ans++;\n\t  q.push(s);\n\t  visits[s] = true;\n\t}\n\ts = now;\n      }\n      if(s.second > 0) {\n\ts.second--;\n\tif(table[s] == BLACK && visits[s] == false) {\n\t  ans++;\n\t  q.push(s);\n\t  visits[s] = true;\n\t}\n\ts = now;\n      }\n      if(s.second < w-1) {\n\ts.second++;\n\tif(table[s] == BLACK && visits[s] == false) {\n\t  ans++;\n\t  q.push(s);\n\t  visits[s] = true;\n\t}\n\ts = now;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint w, h;\nbool b[20][20];\nbool ok[20][20];\n\nchar dx[] = {-1, 1, 0, 0};\nchar dy[] = {0, 0, -1, 1};\n\nvoid dfs(int x, int y){\n\tfor(int i=0;i<4;i++){\n\t\tif(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h){\n\t\t\tif(!b[y+dy[i]][x+dx[i]]) continue;\n\t\t\tif(ok[y+dy[i]][x+dx[i]]) continue;\n\t\t\tok[y+dy[i]][x+dx[i]] = true;\n\t\t\tdfs(x+dx[i],y+dy[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(!w) break;\n\t\tint x, y;\n\t\tstring s;\n\t\tmemset(b,false,sizeof(b));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tb[i][j] = (s[j] !='#');\n\t\t\t\tif(s[j]=='@') x = j, y = i;\n\t\t\t}\n\t\t}\n\t\tmemset(ok,false,sizeof(ok));\n\t\tok[y][x] = true;\n\t\tdfs(x,y);\n\t\tint count = 0;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcount += ok[i][j];\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass DoubleArray {\n    int X,Y;\n    int *top;\n    public:\n    DoubleArray(int *p,int x,int y);\n    int *operator[](int i);\n    int getx();\n    int gety();\n};\n\nDoubleArray::DoubleArray(int *p,int x,int y){\n    top = p;\n    X = x;\n    Y = y;\n}\n\nint *DoubleArray::operator[](int i){\n    return top + Y*i;\n}\nint DoubleArray::getx(){\n    return X;\n}\nint DoubleArray::gety(){\n    return Y;\n}\n\nint calc(DoubleArray &map){\n    int i,j,a=0;\n    int x = map.getx();\n    int y = map.gety();\n    queue<int> q;\n    for(i=0;i<x;i++){\n        for(j=0;j<y;j++){\n            if(map[i][j]==2){\n                q.push(i);\n                q.push(j);\n                a=1;\n                map[i][j]=0;\n            }\n        }\n    }\n    while(!q.empty()){\n        i=q.front();\n        q.pop();\n        j=q.front();\n        q.pop();\n        if(i>0) if(map[i-1][j]==1){\n            q.push(i-1);\n            q.push(j);\n            a++;\n            map[i-1][j]=0;\n        }\n        if(j>0) if(map[i][j-1]==1){\n            q.push(i);\n            q.push(j-1);\n            a++;\n            map[i][j-1]=0;\n        }\n        if(i<x-1) if(map[i+1][j]==1){\n            q.push(i+1);\n            q.push(j);\n            a++;\n            map[i+1][j]=0;\n        }\n        if(j<y-1) if(map[i][j+1]==1){\n            q.push(i);\n            q.push(j+1);\n            a++;\n            map[i][j+1]=0;\n        }\n    }\n    return a;\n}\n\nint main(){\n    int i,j,x,y,a[10000],b = 0;\n    string c;\n    while(114514){\n        cin >> x;\n        cin >> y;\n        if(x==0&&y==0) break;\n        if(x>20) x=20;\n        if(y>20) y=20;\n        if(x<1||y<1) continue;\n        int m[x][y];\n        DoubleArray map(&m[0][0],x,y);\n        for(j=0;j<y;j++){\n            for(i=0;i<x;i++){\n                cin >> c;\n                if(c==\"#\") map[i][j]=0;\n                if(c==\".\") map[i][j]=1;\n                if(c==\"@\") map[i][j]=2;\n            }\n        }\n        a[b++] = calc(map);\n    }\n    for(i=0;i<b;i++){\n        cout << a[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\ntypedef  unsigned long long int ull;\ntypedef pair<ll,ll> P;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=998244353;\nconst ll mod=1000000007;\n//ios_base::sync_with_stdio(false);\n//cin.tie(NULL);\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nV<int> dx={0,-1,0,1},dy={-1,0,1,0};\nint main(){\nwhile(1){\n\tint h,w;\n\tcin>>w>>h;\n\tif(w==0)return 0;\n\tV<V<bool>> used(h,V<bool>(w,false));\n\tV<string> s(h);\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tqueue<P> q;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='@'){\n\t\t\t\tq.push(P(i,j));\n\t\t\t\tused[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tP now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=dx[i]+now.fi,ny=dy[i]+now.se;\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)continue;\n\t\t\tif(s[nx][ny]=='#'||used[nx][ny])continue;\n\t\t\tused[nx][ny]=true;\n\t\t\tq.push(P(nx,ny));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(used[i][j])ans++;\n\tcout<<ans<<endl;\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint cnt;\nint w, h;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nchar tile[200][200];\n\nvoid dfs(int x, int y);\n\nint main()\n{\n\tint x, y;\n\n\twhile (true){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif (w == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", tile[i]);\n\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tdfs(x, y);\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\n\treturn (0);\n}\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '#';\n\tcnt++;\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && tile[ny][nx] == '.'){\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans;\nint w,h;\nstring map[50];\nint dx[4] = {1,0,-1,0}, dy[4] = {0,-1,0,1};\nint dfs(P s);\n\nint main(){\n  int i,j;\n  P s;\n  //cout <<x<<y<<endl;\n  while(1){\n    cin >> w >> h;\n    cin.ignore();\n    if(w == 0 && h == 0) break;\n    for(i = 0;i < h;i++) getline(cin,map[i]);\n    while(map[s.second][s.first] != '@'){\n      //cout << map[y][x]<<endl;\n      s.first++;\n      if(s.first > w-1){\n\ts.second++;\n\ts.first = 0;\n      }\n    }\n    dfs(s);\n    cout << ans<<endl;\n    s.first = s.second = ans = 0;\n  }\n  return 0;\n}\n\nint dfs(P s){\n  int i;\n  P tmp;\n  map[s.second][s.first] = '#';\n  ans++;\n  //cout <<\"x = \" << s.first << \" y = \" << s.second << endl;\n  for(i = 0; i<4;i++){\n    if(s.first + dx[i] > -1 && s.first + dx[i] < w && s.second + dy[i] < h && s.second + dy[i] > -1 && map[s.second + dy[i]][s.first + dx[i]] == '.'){\n      tmp.first = s.first + dx[i];\n      tmp.second = s.second + dy[i];\n      dfs(tmp);\n    }\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 50; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0; tile[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0]; used[x][y]=1;\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y-1);\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y+1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[21][21];\nint used[20][20];\nint W, H;\n\nint rec(int i, int j){\n\n   if(fld[i][j]=='#') return 0;\n   if(used[i][j]) return 0;\n   used[i][j]=1;\n   int ret=0;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      ret+=rec(ni, nj);\n   }\n\n   return ret+1;\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n               fld[i][j]='.';\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      cout<< rec(sy, sx)<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//前置き\n#pragma region\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\ntypedef  long long ll;\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define SORT(a) sort(all(a))\n#define REVERSE(a) reverse(all(a))\n\n#define PRINT(str) printf(#str \"\\n\")\n#define yOUT PRINT(Yes)\n#define nOUT PRINT(No)\n#define YOUT PRINT(YES)\n#define NOUT PRINT(NO)\n\n#pragma endregion\n\n//関数定義\n#pragma region \n//偶数 ->　true :: 奇数　-> false\nbool EVEN(ll a){\n    return a%2-1;\n}\n\n//最大公約数\nll gcd(ll a, ll b) {  \n    if (!b)  \n        return a;  \n    return gcd(b, a%b);  \n}  \n\n//最小公倍数\nll lcm(ll a, ll b) {  \n    return a*b/gcd(a,b);  \n} \n\n#pragma endregion\n\n\nint main(){\n    while(1){\n        int w, h, cnt =1;\n        cin >> w >> h;\n        if(w == 0 && h == 0) return 0;\n\n        bool vis[22][22];\n        char gragh[22][22];\n\n        REP(i,22){\n            REP(j,22){\n                vis[i][j] = false;\n                gragh[i][j] = '#';\n            }\n        }\n\n        \n\n\n        int a,b;\n        for(int i=1;i<h+1;i++){\n            for(int j=1;j<w+1;j++){\n                cin >> gragh[i][j];\n\n                if(gragh[i][j] == '@'){\n                    a = i;b = j;\n                }\n            }   \n        }\n\n        \n        stack<int> st;\n        st.push(a); st.push(b);\n        int dx[4] = {0,1,-1,0};\n        int dy[4] = {1,0,0,-1};\n \n\n        while (!st.empty()){\n            int x,y;\n            y = st.top(); st.pop();\n            x = st.top(); st.pop();\n\n            for(int i = 0;i<4;i++){\n                int ix = x + dx[i];\n                int iy = y + dy[i];\n            \n                if(gragh[ix][iy] == '.' && vis[ix][iy] == false){\n                    st.push(ix); st.push(iy);\n                    vis[ix][iy] = true;\n                    cnt ++;\n                }\n            }\n        }\n        cout << cnt <<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <stack>\n\nusing namespace std;\n\ntypedef struct _TAG_POSITION {\n\tint x;\n\tint y;\n} POSITION;\n\nint main(){\n\tint W, H;\n\tstack<POSITION> S;\n\tPOSITION p;\n\twhile(cin >> W >> H, W || H){\n\t\tchar board[H+2][W+2];\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < H+2; i++){\n\t\t\tfor(int j = 0; j < W+2; j++){\n\t\t\t\t(((i == 0) || (i == H + 1)) || ((j == 0) || (j == W + 1))) && (board[i][j] = '#');\n\t\t\t\t(0 < i && i < H + 1) && (0 < j && j < W + 1) && cin >> board[i][j];\n\t\t\t\tif(board[i][j] == '@') { S.push({i,j}); ret++; }\n\t\t\t}\n\t\t}\n\n\t\twhile(!S.empty()){\n\t\t\tp = S.top();\n\t\t\tS.pop();\n\t\t\tif(board[p.x + 1][p.y] == '.') { board[p.x + 1][p.y] = '@'; ret++; S.push({p.x + 1,p.y}); }\n\t\t\tif(board[p.x - 1][p.y] == '.') { board[p.x - 1][p.y] = '@'; ret++; S.push({p.x - 1,p.y}); }\n\t\t\tif(board[p.x][p.y + 1] == '.') { board[p.x][p.y + 1] = '@'; ret++; S.push({p.x,p.y + 1}); }\n\t\t\tif(board[p.x][p.y - 1] == '.') { board[p.x][p.y - 1] = '@'; ret++; S.push({p.x,p.y - 1}); }\n\t\t}\n\t\tcout << ret << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  vector< int > data;\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n  int Size(int x) {\n    return(-data[x]);\n  }\n  int Find(int k) {\n    return(k < 0 ? k : data[k] = Find(data[k]));\n  }\n  void Unite(int a, int b) {\n    a = Find(a), b = Find(b);\n    if(a == b) return;\n    data[a] += data[b];\n    data[b] = a;\n  }\n};\n\nint main() {\n  int W, H;\n  while(cin >> W >> H, W) {\n    string mas[50];\n    for(int i = 0; i < H; i++) cin >> mas[i];\n    UnionFind uf(W * H);\n    for(int i = 0; i < H; i++) {\n      for(int j = 1; j < W; j++) {\n        if(mas[i][j - 1] != '#' && mas[i][j] != '#') uf.Unite(i * W + j - 1, i * W + j);\n      }\n    }\n    for(int i = 1; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(mas[i - 1][j] != '#' && mas[i][j] != '#') uf.Unite(i * W - W + j, i * W + j);\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(mas[i][j] == '@') cout << uf.Size(i * W + j);\n      }\n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint w, h;\nchar tiles[20][21];\n\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n\nbool isRegion(int x, int y){\n    return x >= 0 && x < w && y >= 0 && y < h;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> tiles[i];\n            \n            auto j = find(tiles[i], tiles[i]+w, '@');\n            if(j != tiles[i] + w){\n                sx = j - tiles[i]; sy = i;\n            }\n        }\n        \n        int cnt = 0;\n        queue<pair<int, int> > q;\n        q.push(make_pair(sx, sy));\n        while(!q.empty()){\n            cnt++;\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            \n            for(int i = 0; i < 4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                \n                if(isRegion(nx, ny) && tiles[ny][nx] == '.'){\n                    tiles[ny][nx] = '#';\n                    q.push(make_pair(nx, ny));\n                }\n            }\n        }\n        cout << cnt << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\nint main(){\n  std::ifstream in(\"input.txt\");\n  std::cin.rdbuf(in.rdbuf());\n  int ans[1024] = {0};\n  int dataCounter = 0;\n  int i = 0;\n  while(1){\n    int visited[20][20] = {0};\n    int data[20][20];\n    int x,y;\n    int w = 0;\n    int h = 0;\n    queue<int> xst;\n    queue<int> yst;\n    cin >> w;\n    cin >> h;\n    if(w == 0 && h == 0) break;\n    for(i=0;i<h;i++){\n      int inputCounter = 0;\n      char d;\n      while(cin >> d){\n        if(d == '.')\n          data[i][inputCounter] = 0;\n        else if(d == '#')\n          data[i][inputCounter] = 1;\n        else if(d == '@'){\n          data[i][inputCounter] = 2;\n          x = inputCounter;\n          y = i;\n        }\n        if(inputCounter == w-1)break;\n        inputCounter++;\n      }\n    }\n    int j=0;\n    xst.push(x);\n    yst.push(y);\n    while(!xst.empty()){\n      x = xst.front();\n      y = yst.front();\n      xst.pop();\n      yst.pop();\n      if(x < 0 || w <= x || y < 0 || h <= y)continue;\n      if(visited[y][x]==1 || data[y][x] == 1)continue;\n      visited[y][x] = 1;\n      ans[dataCounter]++;\n      xst.push(x+1);\n      yst.push(y);\n      xst.push(x);\n      yst.push(y+1);\n      xst.push(x-1);\n      yst.push(y);\n      xst.push(x);\n      yst.push(y-1);\n    }\n\n    dataCounter++;\n  }\n  for(i=0;i<dataCounter;i++){\n    cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 900\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; ++i){\n      cin >> line;\n      for(int j=0; j < width ; ++j){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 400; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; ++i){\n    for(int j=0; j < width ; ++j){\n      cout << setw(3)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >  width || y < 0 || y > height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£?????????????´?1??????\npdf??????????????????????????????????????????????????§?????????????????????\n???????????§??????????????§?????????????????°?????????????????£??¨????????§?????????\n??¢?????\\????????????????????????????????£??¨??????????????????\n#endif\n\n#include <iostream>\n#include <queue>\nusing namespace std;\nclass pos\n{\n\tpublic:\n\tint x;\n\tint y;\n\tpos(int,int);\n};\n\npos::pos(int a,int b)\n{\n\tx=a;y=b;\n}\n\nint main()\n{\n\tint w,h;\n\tint g[21][21];\n/*\tfor(int i=0;i<21;i++)\n\t\tfor(int j=0;j<21;j++)\n\t\t\tg[i][j]=-1;\n*/\twhile(1)\n\t{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0) break;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tint psx,psy;\n\t\tbool visited[21][21];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tchar s;\n\t\t\t\tcin>>s;\n\t\t\t\tswitch(s)\n\t\t\t\t{\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tg[i][j]=0;break;\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tg[i][j]=1;break;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tg[i][j]=2;psx=i;psy=j;break;\n\t\t\t\t}\n\t\t\t\tvisited[i][j]=false;\n\t\t\t}\n\n/*\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcout<<g[i][j];\n\t\t\tcout<<endl;\n\t\t}\n*/\n\t\tint num=0;\n\t\tqueue<pos> Q;\n\t\tQ.push(pos(psx,psy));\n\t\tnum++;\n\t\tvisited[psx][psy]=true;\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tpos now=Q.front();\n\t\t\tQ.pop();\n\t\n\t\t\tfor(int i=-1;i<=1;i+=2)\n\t\t\t{\n\t\t\t\tint newx=now.x+i;\n\t\t\t\tint newy=now.y;\n\t\t\t\tif(newx>=0&&newx<h&&newy>=0&&newy<w&&g[newx][newy]==0&&visited[newx][newy]==false)\n\t\t\t\t{\n\t\t\t\t\tQ.push(pos(newx,newy));\t\t\n\t\t\t\t\tnum++;\n\t\t\t\t\tvisited[newx][newy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=-1;i<=1;i+=2)\n\t\t\t{                \n\t\t\t\tint newx=now.x;\n\t\t\t\tint newy=now.y+i;\n\t\t\t\tif(newx>=0&&newx<h&&newy>=0&&newy<w&&g[newx][newy]==0&&visited[newx][newy]==false)\n\t\t\t\t{\n\t\t\t\t\tQ.push(pos(newx,newy));\n\t\t\t\t\tnum++;\n\t\t\t\t\tvisited[newx][newy]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<num<<endl;\n\t\t\t\t\t\t\t\t\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n    int w,h;\n    while(cin >> w >> h && w!=0){\n        int t[w+2][h+2];\n        int matrix[w*h][w*h];\n        int start;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i==0 || j==0 || i==w || j==h)\n                    t[i][j]=0;\n                char tmp; cin >> tmp;\n                if(tmp=='.'){\n                    t[i+1][j+1] = 1;\n                }\n                else if(tmp=='#'){\n                    t[i+1][j+1] = 0;\n                }\n                else{\n                    t[i+1][j+1] = 1;\n                    start = i*w+j;\n                }\n            }\n        }\n        for(int i=0;i<w*h;i++){\n            for(int j=0;j<w*h;j++){\n                matrix[i][j] = 0;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i==0 || j==0 || i==w || j==h)\n                    continue;\n                else{\n                    int id = i*w+h;\n                    if(t[(id-w)/w][(id-w)%w] == 1)\n                        matrix[id][id-w] = 1;\n                    if(t[(id+w)/w][(id+w)/w] == 1)\n                        matrix[id][id+w] = 1;\n                    if(t[(id-1)/w][(id-1)/w] == 1)\n                        matrix[id][id-1] = 1;\n                    if(t[(id+1)/w][(id+1)/w] == 1)\n                        matrix[id][id+1] = 1;\n                }\n            }\n        }\n        int count = 1;\n        queue<int> Q;\n        int came[w*h];\n        for(int i=0;i<w*h;i++){\n            came[i] = 0;\n        }\n        Q.push(start);\n        came[start] = 1;\n        while(Q.size()!=0){\n            int cur = Q.front();\n            for(int i=0;i<w*h;i++){\n                if(matrix[cur][i]==1 && came[i] == 0){\n                    Q.push(i);\n                    came[i] = 1;\n                    count++;\n                }\n            }\n            Q.pop();\n        }\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\nint field[22][22];\nint num;\n\nconst int RED = 0;\nconst int BLACK = 1;\n\nvoid dfs(int x, int y) {\n\t++num;\n\tfield[y][x] = RED;\n\n\n\tif(field[y-1][x] == BLACK) {\n\t\tdfs(x, y-1);\n\t}\n\n\t\n\tif(field[y][x-1] == BLACK) {\n\t\tdfs(x-1, y);\n\t}\n\t\n\tif(field[y][x+1] == BLACK) {\n\t\tdfs(x+1, y);\n\t}\n\t\n\tif(field[y+1][x] == BLACK) {\n\t\tdfs(x, y+1);\n\t}\n}\n\nint main() {\n\tint w, h;\n\n\twhile(cin >> w >> h, w, h) {\n\t\tREP(i, 22) {\n\t\t\tREP(j, 22) {\n\t\t\t\tfield[i][j] = RED;\n\t\t\t}\n\t\t}\n\n\t\tint startx, starty;\n\n\t\tFOR(i, 1, h+1) {\n\t\t\tFOR(j, 1, w+1) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '.') {\n\t\t\t\t\tfield[i][j] = BLACK;\n\t\t\t\t} else if(c == '#') {\n\t\t\t\t\tfield[i][j] = RED;\n\t\t\t\t} else {\n\t\t\t\t\tstartx = j, starty = i;\n\t\t\t\t\tfield[i][j] = BLACK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnum = 0;\n\t\tdfs(startx, starty);\n\n\t\tcout << num << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n\nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if((0<=ni&&ni<H&&0<=nj&&nj<W)&&fld[ni][nj]=='#'&&used[ni][nj]==0){\n         rec(ni, nj);\n      }\n   }\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<utility>\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nusing namespace std;\n\nint main(){\n  int w,h;\n  vector<string> s;\n  queue<pair<int,int>> que;\n  vector<vector<int>> d;\n  int defi,defj;\n  while(cin>>w&&cin>>h){\n    if(!w&&!h)break;\n    s.resize(h);\n    d.resize(h);\n    for(int i=0;i<h;i++)\n      d[i].resize(w,0);\n    for(int i=0;i<h;i++){\n      cin >> s[i];\n      for(int j=0;j<w;j++)\n\tif(s[i][j] == '@'){defi=i;defj=j;}\n    }\n    \n    que.push(make_pair(defi,defj));\n    int ct=1;//???????????????\n    while(que.size()){\n      pair<int,int> defp = que.front();\n      que.pop();\n      pair<int,int> p;\n      for(int i=0;i<4;i++){\n\tp.first = defp.first + dy[i];p.second = defp.second + dx[i];\n\tif(p.first>=0 && p.second>=0 && p.first<h && p.second<w){\n\t  if(d[p.first][p.second])continue;\n\t  else if(s[p.first][p.second] == '.'){\n\t    ct++;\n\t    d[p.first][p.second]++;\n\t    que.push(p);\n\t  }else if(s[p.first][p.second] == '#'){\n\t    d[p.first][p.second]++;\n\t  }\n\t}\n      }\n    }\n    cout << ct << endl;\n    s.clear();\n    d.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, black;\nchar tile[24][24];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y){\n    black++;\n    tile[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n        if( x+dx[i] >= 0 && x+dx[i] < h &&\n            y+dy[i] >= 0 && y+dy[i] < w &&\n            tile[ x+dx[i] ][ y+dy[i] ] == '.' ){\n            dfs( x+dx[i], y+dy[i] );\n        }\n    }\n}\n\nint main(){\n    int i, j;\n    while( cin >> w >> h, w||h ){\n        for(i = 0; i < h; i++){\n            cin >> tile[i];\n        }\n        black = 0;\n        for(i = 0; i < h && !black; i++){\n            for(j = 0; j < w && !black; j++){\n                if( tile[i][j] == '@' ){\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << black << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint i,j,k,w,h,a;\n\t\tchar c[20][20];\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<20;j++){\n\t\t\t\tc[i][j]='\\0';\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tfor(k=0;k<=w*h;k++){\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(c[i][j]=='.'){\n\t\t\t\t\t\tif(c[i][j+1]=='@'||c[i][j-1]=='@'||c[i-1][j]=='@'||c[i+1][j]=='@'){\n\t\t\t\t\t\t\tc[i][j]='@';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\ta=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(c[i][j]=='@')a++;\t\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint dx[8] = {-1, 0, 1, 0, -1, -1, 1, 1};\nint dy[8] = {0, -1, 0, 1, -1, 1, -1, 1};\n\nint w, h, cnt;\nchar field[20][20];\n\nvoid dfs(int x, int y) {\n  if(0 <= x && x < h && 0 <= y && y < w && field[x][y] == '.') { \n    cnt++;\n    field[x][y] = '#';\n    REP(i, 4) {\n      dfs(x+dx[i], y+dy[i]);\n    }\n  }\n}\n\nint main() {\n  while(cin >> w >> h, w+h) {\n    int px, py;\n    REP(i, h) {\n      REP(j, w) {\n\tcin >> field[i][j];\n\tif(field[i][j] == '@') {\n\t  px = i;\n\t  py = j;\n\t  field[i][j] = '.';\n\t}\n      }\n    }\n\n    cnt = 0;\n    dfs(px, py);\n    cout << cnt << endl;\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nchar graph[20][20];\nint cou = 0;\n\nvoid bfs(int a1,int a2){\n  queue<int> Q;\n  int u1,u2;\n  Q.push(a1);\n  Q.push(a2);\n\n  while(!Q.empty()){\n\n    u1 = Q.front();Q.pop();\n    u2 = Q.front();Q.pop();\n\n    if(graph[u1+1][u2] == '.'){\n      graph[u1+1][u2] = 'N';\n      cou++;\n      Q.push(u1+1);Q.push(u2);\n    }\n\n    if(graph[u1][u2+1] == '.'){\n      graph[u1][u2+1] = 'N';\n      cou++;\n      Q.push(u1);Q.push(u2+1);\n    }\n\n    if(graph[u1-1][u2] == '.'){\n      graph[u1-1][u2] = 'N';\n      cou++;\n      Q.push(u1-1);Q.push(u2);\n    }\n\n    if(graph[u1][u2-1] == '.'){\n      graph[u1][u2-1] = 'N';\n      cou++;\n      Q.push(u1);Q.push(u2-1);\n    }\n\n    /* for(int i = 0; i< 9 ;i++){\n       for(int j = 0; j < 6; j++){\n       cout << graph[i][j];\n       }\n       cout << endl;\n       }\n       }*/\n  }\n}\n\nint main(){\n\n  int W,H,a1,a2;\n\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    bfs(a1,a2);\n\n    cout << cou+1 << endl;\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint w, h;\nchar field[21][21];\nbool used[21][21];\n\nint sx, sy;\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nvoid solve(int y,int x){\n\n\tREP(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (ny < h&&ny >= 0 && nx < w&&nx >= 0){\n\t\t\tif (field[ny][nx] == '.'&&used[ny][nx] == 0){\n\t\t\t\tused[ny][nx] = 1;\n\t\t\t\tsolve(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tREP(i, 21)REP(j, 21)used[i][j] = 0;\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '@'){\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve(sy, sx);\n\t\tused[sy][sx] = 1;\n\n\t\tint ans = 0;\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tif (used[i][j])ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h;\nstring field[21]; // 文字を扱うのでstring型の配列を使うと便利です。\n\n// 4近傍(上下左右)のときは次のような配列を用意すると便利\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\n// 現在地(x,y)\nvoid dfs(int x, int y){\n    // 今いるところを'B'に置き換える\n    field[y][x] = 'B';\n\n    // 移動する4方向をループ\n    for(int i=0 ; i < 4 ; i++ ){\n        // x方向にdx[i], y方向にdy[i], 移動した場所を(mx,my)とする\n        int mx = x + dx[i];\n        int my = y + dy[i];\n        // 範囲外に出たときは次の処理へ\n        if( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n        // 黒いタイル'.'だったら再帰呼び出し\n        if( field[my][mx] == '.' ){\n            dfs( mx , my );\n        }\n    }\n}\n\nint main(){\n    while( cin >> w >> h , w || h ){\n        for(int y=0 ; y < h ; y++ ){\n            cin >> field[y];\n        }\n\n        for(int y=0 ; y < h ; y++ ){\n            for(int x=0 ; x < w ; x++ ){\n                if( field[y][x] == '@' ){ // 人'@'だったら再帰関数を呼び出す\n                    dfs( x , y );\n                }\n            }\n        }\n        int ans = 0;\n        // ループで'B'の数を数える(到達可能な黒いタイルの数)\n        for(int y=0 ; y < h ; y++ ){\n            for(int x=0 ; x < w ; x++ ){\n                if( field[y][x] == 'B' )\n                    ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint check(int j){\n\tif (j==2 || j==4 ||j==3)\n\treturn j;\n\telse\n\treturn 3;\n}\nint main(){\n\tint board[22][22];\n\tint w,h;\n\tchar t;\n\twhile(1){\n\t\tcin >>w >>h;\n\t\tif(w==0 && h==0) break;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j = 0;j<=21;j++){\n\t\t\t\tboard[j][i]=4;\n\t\t\t}\n\t\t}//initialization\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> t ;\n\t\t\t\tif(t == '.')board[j][i] = 1;\n\t\t\t\telse if(t=='#')board[j][i]=2;\n\t\t\t\telse board[j][i] = 3;\n\t\t\t}\n\t\t}// input end\n\t\tint cmem = 2000;\n\t\tint c  = 0;\n\t\twhile(cmem-c !=0){\n\t\t\t\tcmem = c;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor (int j= 1;j<=w;j++){\n\t\t\t\t\tif(board[j][i] ==3){\n\t\t\t\t\tboard[j-1][i] =check(board[j-1][i]);\n\t\t\t\t\tboard[j+1][i] =check(board[j+1][i]);\n\t\t\t\t\tboard[j][i-1] =check(board[j][i-1]);\n\t\t\t\t\tboard[j][i+1] =check(board[j][i+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor (int j= 1;j<=w;j++){\n\t\t\t\t\tif (board[j][i] ==3) c+=1;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\t\n\t\n\t\tcout <<c << endl;\t\n\t}//while loop end\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define COUNT(i, n) for(int i = 1; i <= n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define ITER(c) __typeof((c).begin())\n#define each(c, it) for(ITER(c) it = (c).begin(); it != (c).end(); it++)\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int N = 20;\n\nint w, h, cnt;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\nvs m(N);\n\nvoid dfs(pii);\n\nint main(void){\n    for(; cin >> w >> h, w; cout << cnt << endl){\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n        \n        dfs(p);\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if(p.X < 0 || w <= p.X ||\n       p.Y < 0 || h <= p.Y || m[p.Y][p.X] == '#') return;\n\n    cnt++;\n    m[p.Y][p.X] = '#';\n    \n    rep(i, 4) dfs(mp(p.X + dx[i], p.Y + dy[i]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n\nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      if(used[ni][nj]) continue;\n      if(fld[ni][nj]!='.') continue;\n      rec(ni, nj);\n   }\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define range(i,a,b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\n\nusing namespace std;\n\nchar table[30][30];\n\nint dw[4]={1,0,-1,0};\nint dh[4]={0,1,0,-1};\n\nvoid dfs(int w,int h){\n\ttable[h][w]='@';\n\trep(i,4){\n\t\tint nw=w+dw[i];\n\t\tint nh=h+dh[i];\n\t\tif(table[nh][nw]=='.')\n\t\t\tdfs(nw,nh);\n\t}\n}\n\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h,w|h){\n\t\tint sw,sh;\n\t\trep(i,30)rep(j,30) table[i][j]='#';\n\t\trange(i,1,h+1) range(j,1,w+1){\n\t\t\tcin >> table[i][j];\n\t\t\tif(table[i][j]=='@'){\n\t\t\t\tsh=i;\n\t\t\t\tsw=j;\n\t\t\t}\n\t\t}\n\t\tdfs(sw,sh);\n\t\tint ans=0;\n\t\trange(i,1,h+1) range(j,1,w+1) if(table[i][j]=='@') ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n    while(true){\n        int w, h; cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        int sx, sy; //スタート地点の場所\n        vector<vector<char>> mp(h, vector<char>(w)); //入力を受け取る二次元配列\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        vector<vector<int>> ok(h, vector<int>(w)); //到達可能なら1を代入する\n        queue<pair<int, int>> que;\n        que.push({sx, sy});\n        ok[sy][sx] = 1;\n        while(!que.empty()){\n            int x = que.front().first, y = que.front().second; //現在地を取得する\n            que.pop();\n            for(int i = 0; i < 4; i++){\n                if(x + dx[i] < 0 || x + dx[i] >= w || y + dy[i] < 0 || y + dy[i] >= h) continue; //mapの範囲外はcontinue\n                if(mp[y+dy[i]][x+dx[i]] == '#' || ok[y+dy[i]][x+dx[i]] == 1) continue; //障害物で行けないor一度行ったところはスルー\n                //それ以外の場合\n                ok[y+dy[i]][x+dx[i]] = 1; //okに1を代入する\n                que.push({x+dx[i], y+dy[i]}); //現在地からまだ行ってない場所のうち,行ける場所を新たに追加\n            }\n        }\n        int ans = 0; \n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){ //okの要素を全て足すと行ける場所の個数がわかる\n                ans += ok[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <stack>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(void){\n\tint h,w;\n\tqueue<pii> s;\n\tstring m[21];\n\twhile(cin>>w>>h,w||h){\n\t\tfor(int i=0;i<h;i++)cin>>m[i];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='@'){\n\t\t\t\t\ts.push(pii(i,j));\n\t\t\t\t\ti=j=999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c=0;\n\t\twhile(!s.empty()){\n\t\t\tpii a=s.front();s.pop();\n\t\t\tint i=a.first;\n\t\t\tint j=a.second;\n\t\t\tif(!(0<=i&&i<h&&0<=j&&j<w))continue;\n\t\t\tif(m[i][j]=='#')continue;\n\t\t\tc++;\n\t\t\tm[i][j]='#';\n\t\t\ts.push(pii(i+1,j));\n\t\t\ts.push(pii(i-1,j));\n\t\t\ts.push(pii(i,j+1));\n\t\t\ts.push(pii(i,j-1));\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nint box[21][21]={{}};\nint  kazoe(int p,int P,int H,int W){\n  int i,I;\n  a++;\n  box[p][P]=0;\n  if(box[p][P+1]==1) kazoe(p,P+1,H,W);\n  if(box[p][P-1]==1) kazoe(p,P-1,H,W);\n  if(box[p-1][P]==1) kazoe(p-1,P,H,W);\n  if(box[p+1][P]==1) kazoe(p+1,P,H,W);\n  else {\n  return a;\n  }\n}\nint main(){\n  int i,I,H,W,p,P;\n  \n  char v;\n  while(1){\n  cin>>W>>H;\n  if(W==0&&H==0) break;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  cout<<kazoe(p,P,H,W)<<endl;\n  a=0;\n \n  \n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= y*w+x;\n  return s;\n}\n\nint point_x(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint point_y(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  while(w!=0){\n    int a[21][21]={};\n    int sx,sy;\n    for(int j=0;j<h;j++){\n      for(int i=0;i<w;i++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=point_x(cur,w);\n      y=point_y(cur,w);\n      if(x>=1){\n\tif(a[x-1][y]==1&&d[x-1][y]==-1){\n\t  d[x-1][y]=0;\n\t  q.push(point(x-1,y,w,h));\n\t}\n      }\n      if(x<=w-2){\n\tif(a[x+1][y]==1&&d[x+1][y]==-1){\n\t  d[x+1][y]=0;\n\t  q.push(point(x+1,y,w,h));\n\t}\n      }\n      if(y>=1){\n\tif(a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,y-1,w,h));\n\t}\n      }\n      if(y<=h-2){\n\tif(a[x][y+1]==1&&d[x][y+1]==-1){\n\t  d[x][y+1]=0;\n\t  q.push(point(x,y+1,w,h));\n\t}\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout <<t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H,sx,sy;\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nchar F[21][21];\nint visited[21][21] = {};\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        queue<P> Q;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                visited[i][j] = 0;\n                cin >> F[i][j];\n                if(F[i][j]=='@'){\n                    visited[i][j] = 1;\n                    Q.push({i,j});\n                }\n            }\n        }\n        int ans = 0;\n        while(!Q.empty()){\n            ans++;\n            int x = Q.front().first,y = Q.front().second; Q.pop();\n            for(int i=0;i<4;i++){\n                int nx = x+dx[i],ny = y+dy[i];\n                if(in(nx,ny) && F[nx][ny]!='#' && visited[nx][ny]==0){\n                    visited[nx][ny] = 1;\n                    Q.push({nx,ny});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Red and Black.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include \"stdafx.h\"\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tmemo[i][j] = 0;\n\t\t}\n\t}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n\n\n\n\n/*\nvoid solve() {\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tcout << maze[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"@???????????????\" << X << Y << endl;\n}\n*/\n\n\n\n\n\n\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX_H 22\n#define MAX_W 22\n\nint W, H, X, Y, A;\n\nchar tile[MAX_H][MAX_W];\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '@';\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (0 <= x + dx[i] <= W - 1 && 0 <= y + dy[i] <= H - 1)\n\t\t{\n\t\t\tif (tile[y + dy[i]][x + dx[i]] == '#')\n\t\t\t{\n\t\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> tile[i][j];\n\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tX = j;\n\t\t\t\t\tY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(X, Y);\n\n\t\tA = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tA++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << A << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,H;\nchar fld[20][21];\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nbool used[20][20];\nint rec(int y,int x){\n    if(fld[y][x]!='.'||used[y][x])return 0;\n    used[y][x]=true;\n    int ret=0;\n    for(int i=0;i<4;i++){\n        int ty=y+dy[i],tx=x+dx[i];\n        if(ty<0||ty>=H||tx<0||tx>=W)continue;\n        ret+=rec(ty,tx);\n    }\n    return ret+1;\n}\nint main(){\n    while(cin>>W>>H,W||H){\n        fill_n(*used,400,false);\n        for(int i=0;i<H;i++)cin>>fld[i];\n\n        int sy,sx;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(fld[i][j]!='@')continue;\n                sy=i;\n                sx=j;\n                fld[i][j]='.';\n            }\n        }\n\n        cout<<rec(sy,sx)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nint main(){\n  int w,h,count;\n  queue<int> que;\n  int xx[4]={1,0,-1,0};\n  int yy[4]={0,1,0,-1};\n  int pos;\n  string tmap;\n  while(true){\n    cin >> w >> h;\n    if(!w&&!h)\n      break;\n    int mmap[w+2][h+2];\n    for(int x=0;x<w+2;x++){\n      mmap[x][0] = -1;\n      mmap[x][h+1] = -1;\n    }\n    for(int y=0;y<h+2;y++){\n      mmap[0][y] = -1;\n      mmap[w+1][y] = -1;\n    }\n        \n    for(int y=0;y<h;y++){\n      cin >> tmap;\n      for(int x=0;x<w;x++){\n\tswitch(tmap[x]){\n\tcase '.':\n\t  mmap[x+1][y+1] = 0;\n\t  break;\n\tcase '#':\n\t  mmap[x+1][y+1] = -1;\t  \n\t  break;\n\tcase '@':\n\t  mmap[x+1][y+1] = 1;\n\t  que.push(y*w+x);\n\t  break;\n\t}\n      }\n    }\n    count = 1;\n    while(!que.empty()){\n      pos = que.front();\n      for(int dir=0;dir<4;dir++){\n\tif (mmap[pos%w+xx[dir]+1][pos/w+yy[dir]+1]==0){\n\t  que.push(pos+yy[dir]*w+xx[dir]);\n\t  mmap[pos%w+xx[dir]+1][pos/w+yy[dir]+1] = 1;\n\t  count++;\n\t}\n      }\n      que.pop();\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#ifndef M_PI\nconst double M_PI=acos(-1);\n#endif\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool vis[20][20];\nstring in[20];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(vis,0,sizeof(vis));\n    rep(i,h)cin>>in[i];\n    int ans=0;\n    rep(i,h){\n      rep(j,w){\n        if(in[i][j]!='@')continue;\n        queue<PI> q;\n        q.push(mp(i,j));\n        while(!q.empty()){\n          int x=q.front().F,y=q.front().S;q.pop();\n          if(vis[x][y])continue;\n          vis[x][y]=true;\n          ++ans;\n          rep(k,4){\n            int nx=x+dx[k],ny=y+dy[k];\n            if(nx<0 || h<=nx ||\n               ny<0 || w<=ny ||\n               vis[nx][ny] || in[nx][ny]=='#')continue;\n            q.push(mp(nx,ny));\n          }\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ?????¬???????????¬??????\n#pragma region MACRO\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define PED cout << \"\\n\"\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n#define REP(i,x,n) for(int i=x; i<(int)n; ++i)\n#define repi(i,n) for(int i=0; i<=(int)n; ++i)\n#define REPI(i,x,n) for(int i=x; i<=(int)n; ++i)\n#define ILP while(true)\n#define FOR(i,c) for(__typeof((c).begin())!=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#pragma endregion\n\n// ???\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pss;\ntypedef pair<string, int> psi;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long double> vld;\ntypedef vector<long> vl;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\n#pragma endregion\n\n// Effective std\n#pragma region ESTD\ntemplate<typename C, typename T> int count(C& c, T t) { return count(ALL(c), t); }\ntemplate<typename C, typename F> int count_if(C& c, F f) { return count_if(ALL(c), f); }\ntemplate<typename C, typename T> void erase(C& c, T t) { remove(ALL(c), t), c.end(); }\ntemplate<typename C> void remove(vector<C>& c, unsigned int index) { c.erase(c.begin()+index); }\ntemplate<typename C, typename T, typename U> void replace(C& c, T t, U u) { replace(ALL(c), t, u); }\ntemplate<typename C, typename F, typename U> void replace_if(C& c, F f, U u) { (ALL(c), f, u); }\ntemplate<typename C> void reverse(C& c) { reverse(ALL(c)); }\ntemplate<typename C> void sort(C& c) { sort(ALL(c)); }\ntemplate<typename C, typename Pred> void sort(C& c, Pred p) { sort(ALL(c), p); }\n#pragma endregion\n\n// ?????°\n#pragma region CONST_VAL\nconstexpr int PI = (2*acos(0.0));\nconstexpr int EPS = (1e-9);\nconstexpr int MOD = (int)(1e9+7);\nconstexpr int INF = 100000000;\n#pragma endregion\n\nint w, h;\nchar a[21][21];\nint dx[]{1,-1,0,0};\nint dy[]{0,0,1,-1};\nint cnt;\n\nvoid dfs(int x, int y) {\n    a[x][y] = 0;\n    rep(i,4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0<=nx&&nx<h&&0<=ny&&ny<w&&a[nx][ny]=='.') {\n            cnt++;\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main() {\n    while(cin>>w>>h, w) {\n        cnt = 1;\n        rep(i,h) cin >> a[i];\n        rep(i, h) rep(j,w) {\n            if(a[i][j]=='@') {\n                dfs(i,j);\n                break;\n            }\n        }\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nint dxy[]={1,0,-1,0,1};\nint ans=0;\n\nchar tile[21][21];\nint H,W;\n\nvoid dfs(int x, int y){\n\tif(tile[x][y]=='.'){\n\t\tans++;\n\t\ttile[x][y]='#';\n\t}\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = dxy[i] + x, ny = y + dxy[i + 1];\n\t\tif(nx < H && nx >= 0 && ny >= 0 && ny < W){\n\t\t\tif(tile[nx][ny] == '.')dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(std::cin>>W>>H && W+H){\n\t\tans = 0;\n\t\tmemset(tile, '#', sizeof(tile));\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tchar c;\n\t\t\t\tstd::cin>>c;\n\t\t\t\ttile[i][j]=c;\n\t\t\t\tif(tile[i][j] == '@')sx = i, sy = j;\n\t\t\t}\n\t\t}\n\t\ttile[sx][sy] = '.';\n\t\tdfs(sx,sy);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint res,W,H,tile[20][20];\nP start;\n\nint bfs()\n{\n\tint res = 1;\n\tqueue<P> a;\n\ta.push(start);\n\twhile (!a.empty()) {\n\t\tP temp = a.front();\n\t\ta.pop();\n\t\tif (temp.first + 1 < W && tile[temp.first + 1][temp.second]) {\n\t\t\ttile[temp.first + 1][temp.second] = 0;\n\t\t\tres++;\n\t\t\ta.push(P(temp.first + 1, temp.second));\n\t\t}\n\t\tif (temp.first - 1 >= 0 && tile[temp.first - 1][temp.second]) {\n\t\t\ttile[temp.first - 1][temp.second] = 0;\n\t\t\tres++;\n\t\t\ta.push(P(temp.first - 1, temp.second));\n\t\t}\n\t\tif (temp.second + 1 < H && tile[temp.first][temp.second + 1]) {\n\t\t\ttile[temp.first][temp.second + 1] = 0;\n\t\t\tres++;\n\t\t\ta.push(P(temp.first, temp.second + 1));\n\t\t}\n\t\tif (temp.second - 1 >= 0 && tile[temp.first][temp.second - 1]) {\n\t\t\ttile[temp.first][temp.second - 1] = 0;\n\t\t\tres++;\n\t\t\ta.push(P(temp.first, temp.second - 1));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tchar ch;\n\twhile (cin >> W >> H, W || H) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> ch;\n\t\t\t\tif (ch == '.') {\n\t\t\t\t\ttile[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (ch == '#') {\n\t\t\t\t\ttile[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttile[j][i] = 0;\n\t\t\t\t\tstart = P(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint W, H, x[30][30] = {};\n\t\tchar str[30][30];\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tcin>>str[i][j];\n\t\t\t\tif(str[i][j] == '@') x[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\n\t\tint q = 0;\n\t\twhile(1){\n\t\t\tint z = 0;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(x[i][j] == 1){\n\t\t\t\t\t\tif(i > 0 && str[i - 1][j] == '.') x[i - 1][j] = 1;\n\t\t\t\t\t\tif(i < H - 1  && str[i + 1][j] == '.') x[i + 1][j] = 1;\n\t\t\t\t\t\tif(j > 0 && str[i][j - 1] == '.') x[i][j - 1] = 1;\n\t\t\t\t\t\tif(j < W - 1&& str[i][j + 1] == '.') x[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(x[i][j] == 1){\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z == q) break;\n\t\t\tq = z;\n\t\t}\n\n\t\t\n\t\tcout<<q<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid func(int x,int y);\nint h,w;\nchar a[111][111];\nint dx[4]={0,-1,0,1};\nint dy[4]={-1,0,1,0};\nint nx,ny;\nint cnt=0;\nint main(){\n  int fx,fy;\n  while(1){\n    cin >> w >> h;\n    if(h==0 && w==0)break;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin >> a[i][j];\n\tif(a[i][j]=='@'){\n\t  fx=i;\n\t  fy=j;\n\t}\n      }\n    }\n    func(fx,fy);\n    cout << cnt << endl;\n    cnt=0;\n  }\n}\n\n\nvoid func(int x,int y){\n  if(x>h || x<=0 || y>w || y<=0 || a[x][y]=='#' || a[x][y]=='0')return;\n  cnt++;\n  a[x][y]='0';\n  for(int i=0;i<4;i++){\n    nx=dx[i]+x;\n    ny=dy[i]+y;\n    func(nx,ny);\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nchar grid[25][25];\n\nvoid init()\n{\n\tfor (int i = 0; i < 25; i++){\n\t\tfor (int j = 0; j < 25; j++){\n\t\t\tgrid[i][j] = '#';\n\t\t}\n\t}\n}\n\nint search(int ny, int nx)\n{\n\tgrid[ny][nx] = '#';\n\t\n\tint sum = 1;\n\tfor (int i = 0; i < 4; i++){\n\t\tint ty = ny + dy[i];\n\t\tint tx = nx + dx[i];\n\t\tif (grid[ty][tx] == '.'){\n\t\t\tif (grid[ty][tx] == '.'){\n\t\t\t\tsum += search(ty, tx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (sum);\n}\n\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tinit();\n\t\t\n\t\tint sy, sx;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\t\n\t\t\t\tif (grid[i][j] == '@'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", search(sy, sx));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < H && nx >= 0 && nx < W && board[ny][nx] == '.') {\n         ret += dfs(y, x);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nint counta;\nvoid judge(char d[][20], int x, int y, int limitx, int limity) {\n\tif (d[y][x] == '@' || d[y][x] == '.') {\n\t\td[y][x] = '#';\n\t\tcounta++;\n\t\tif (x > 0) judge(d, x - 1, y, limitx, limity);\n\t\tif (x <= limitx - 2)judge(d, x + 1, y, limitx, limity);\n\t\tif (y>0)judge(d, x, y - 1, limitx, limity);\n\t\tif (y <= limity-2)judge(d, x, y + 1, limitx, limity);\n\t}\n}\n\nint main() {\n\tint x, y;\n\tint manx = 0;\n\tint many = 0;\n\tdo {\n\n\t\tcounta = 0;\n\t\tchar a[20][20];\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++)\n\t\t\t\ta[i][j] = '#';\n\t\t}\n\t\tcin >> x >> y;\n\t\tif (x == 0)break;\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == '@') { many = i; manx = j; }\n\t\t\t}\n\t\t}\n\t\tjudge(a, manx, many, x, y);\n\t\tcout << counta << \"\\n\";\n\n\t} while (1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX = 20;\nchar map[MAX][MAX];\nbool book[MAX][MAX];\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x = 0, int y = 0) :x(x), y(y) {}\n}start;\nint sum = 0;\nvoid depthFSearch(int H, int W, Point start)\n{\n\tint next[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\n\tfor (int k = 0; k <= 3; k++)\n\t{\n\t\tint nx = start.x + next[k][0];\n\t\tint ny = start.y + next[k][1];\n\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W||map[nx][ny]=='#')\n\t\t\tcontinue;\n\t\tif (!book[nx][ny] && map[nx][ny] == '.')\n\t\t{\n\t\t\tbook[nx][ny] = true;\n\t\t\tPoint p(nx, ny);\n\t\t\tsum++;\n\t\t\tdepthFSearch(H, W, p);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tint H, W;\n\t\tcin >> W >> H;\n\t\tif (!H && !W)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')\n\t\t\t\t\tstart = Point(i, j);\n\t\t\t}\n\t\tbook[start.x][start.y] = true;\n\t\tsum = 1;\n\t\tdepthFSearch(H, W, start);\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int W, H, i, j, f, d, count;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  char map[32][32];\n  char s[32];\n\n  while (1) {\n    gets(s);\n    sscanf(s, \"%d %d\", &W, &H); if (W == 0 && H == 0) { break; }\n    for (i = 0; i < 30; i++) {\n      strcpy(map[i], \"##############################\");\n    }\n    \n    for (i = 0; i < H; i++) {\n      gets(&map[i+1][1]);\n      map[i+1][W+1] = '#';\n      map[i+1][W+2] = '\\0';\n    }\n\n    count = 1;\n    while (1) {\n      f = 0;\n      for (i = 1; i <= H; i++) {\n        for (j = 1; j <= W; j++) {\n          if (map[i][j] == '@') {\n            for (d = 0; d < 4; d++) {\n              if (map[i+dy[d]][j+dx[d]] == '.') {\n                map[i+dy[d]][j+dx[d]] = '@';\n                count++;\n                f = 1;\n              }\n            }\n          }\n        }\n      }\n      if (!f) {\n        break;\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\nint mod(ll a){\n    int c=a%1000000007;\n    if(c>=0)return c;\n    else return c+1000000007;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\n#define inf 100000000/*10^8*/\n\n/////////////////////////////////\n\nint w,h;\nint si,sj;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint room[25][25];\nint ans=0;\nint dfs(int x,int y){\n    room[x][y]=2;ans++;\n    for(int i=0;i<=3;i++){\n        int xx=x+dx[i],yy=y+dy[i];\n        if(0<=xx&&xx<=h-1&&0<=yy&&yy<=w-1&&room[xx][yy]==0)dfs(xx,yy);\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0)break;\n        ans=0;\n        for(int i=0;i<=h-1;i++){\n            char s[w+1];cin>>s;\n            for(int j=0;j<=w-1;j++){\n                if(s[j]=='.')room[i][j]=0;\n                else if(s[j]=='#')room[i][j]=1;\n                else if(s[j]=='@')room[i][j]=2,si=i,sj=j;\n            }\n        }\n        cout<<dfs(si,sj)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<string>\n#include <deque>\n#include<queue>\n#include<map>\n#include<type_traits>\nusing namespace std;\nchar D[28][28];\nint Y ;\nvoid serch(int X, int Q) {\n\tif (D[X][Q] == '.'||D[X][Q]=='@') {\n\t\tY++;\n\t\tD[X][Q] = '#';\n\t\tserch(X - 1, Q);\n\t\tserch(X + 1, Q);\n\t\tserch(X , Q-1);\n\t\tserch(X , Q+1);\n\t\t\n\n\t}\n\telse return;\n}\n\n\nint main() {\n\tint H, W;\n\tcin >> W >> H;\n\tfor (int i = 0; i <28; i++) {\n\t\tfor (int j = 0; j <28; j++) {\n\t\t\tD[i][j] = '#';\n\t\t}\n\t}\n\tint Sx,Sy;\n\twhile (H) {\n\t\t Y = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> D[j][i];\n\t\t\t\tif (D[j][i] == '@') {\n\t\t\t\t\tSx = j;\n\t\t\t\t\tSy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tserch(Sx, Sy);\n\t\t\n\t\tcout << Y << endl;\n\t\tfor (int i = 0; i <28; i++) {\n\t\t\tfor (int j = 0; j <28; j++) {\n\t\t\t\tD[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nbool debug=true;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar d[21][21];\n\nvoid init(){\n  for(int i=0;i<21;i++)for(int j=0;j<21;j++)d[i][j]='#';\n}\n\nint dfs(int sx,int sy){\n  int cnt=0;\n  queue<int>que;\n  que.push(sx);que.push(sy);\n  while(que.size()){\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    for(int i=0;i<4;i++){\n      if(d[y+dy[i]][x+dx[i]]=='.'){\n\tque.push(x+dx[i]);que.push(y+dy[i]);\n\td[y+dy[i]][x+dx[i]]='#';\n\tcnt++;\n      }\n    }\n  }\n  return cnt+1;\n}\n\nint main(){\n  int w,h;\n  \n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    init();\n    int x,y;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>d[i][j];\n\tif(d[i][j]=='@'){\n\t  x=j;y=i;\n\t}\n      }\n    }\n    cout<<dfs(x,y)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <vector>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nusing std::vector;\n\nint main(){\n\tint w,h;\n\tvector<string> f(30);\n\tvector< vector<int> > g(30,vector<int>(30,0));\n\tint count = 0;\n\tint count2 = 0;\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tcin >> f[i];\n\t\t}\n\n\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tg[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tcount2 = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tif(f[i][j] == '@' && count== 0){\n\t\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t\t\tcount2++;\n\t\t\t\t\t}else if(g[i][j] == 1){\n\t\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\t\tif(f[i-1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i-1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i-1][j] = 1;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tif(f[i+1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i+1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i+1][j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tif(f[i][j-1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j-1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j-1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tif(f[i][j+1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j+1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j+1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(count == count2){\n\t\t\t\tcout << count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount = count2;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint n, m;\nchar field[100][100];\n\nint dfs(int x, int y){\n\tfield[x][y] = '.';\n\n\tfor(int dx = -1; dx <= 1; dx++){\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tint nx = x + dx, ny = y + dy;\n\n\t\t\tif(0 <= nx && nx < n && 0 <= ny && ny < m && field[nx][ny] == 'W') dfs(nx, ny);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%s\", field[i]);\n\t}\n\tint ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(field[i][j] == 'W'){\n\t\t\t\tdfs(i, j);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool is[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (is[nx][ny]) continue;\n      is[nx][ny] = true;\n      dfs(nx, ny); // 次の一から再び4近傍を探索\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W && H) {\n      memset(is, false, sizeof(is));\n      int x, y;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               x = i, y = j;\n            }\n         }\n      }\n\n      is[x][y] = true;\n      dfs(x, y);\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (is[i][j]) cnt++;\n         }\n      }\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint H,W;\nchar S[22][22];\n\nbool used[22][22];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint dfs(int x,int y){\n  used[x][y]=true;\n  int res=1;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx<0||ny<0||nx>=H||ny>=W) continue;\n    if(used[nx][ny]) continue;\n    if(S[nx][ny]!='.') continue;\n    res+=dfs(nx,ny);\n  }\n  return res;\n}\n\nvoid solve(){\n  for(int i=0;i<H;i++) for(int j=0;j<W;j++) cin>>S[i][j];\n  for(int i=0;i<H;i++) for(int j=0;j<W;j++) used[i][j]=false;\n\n  int stx,sty;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(S[i][j]=='@'){\n        stx=i;\n        sty=j;\n      }\n    }\n  }\n\n  cout<<dfs(stx,sty)<<endl;\n\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0) break;\n    solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Shunji Lin 08-144505\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint reachable = 0;\n\nvoid DFS(int grid[20][20], int visited[20][20],  int row_pos, int col_pos, int H, int W);\n\nvoid DFS_aux(int grid[20][20], int visited[20][20], int row_pos, int col_pos, int H, int W) {\n  if (grid[row_pos][col_pos] && !visited[row_pos][col_pos]) {\n    DFS(grid, visited, row_pos, col_pos, H, W);\n  }\n    \n}\n\t \nvoid DFS(int grid[20][20], int visited[20][20], int row_pos, int col_pos, int H, int W) {\n  visited[row_pos][col_pos] = true;\n  reachable += 1;\n  if (!(row_pos == 0)) {\n    DFS_aux(grid, visited, row_pos-1, col_pos, H, W); //up\n  }\n  if (!(col_pos == 0)) {\n    DFS_aux(grid, visited, row_pos, col_pos-1, H, W); //left\n  }\n  if (!(row_pos == H-1)) {\n    DFS_aux(grid, visited, row_pos + 1, col_pos, H, W); //down\n  }\n  if (!(col_pos == W-1)) {\n    DFS_aux(grid, visited, row_pos, col_pos + 1, H , W); //right\n  }\n}\n      \n    \n\n\nint main() {\n  while (true) {\n    int grid[20][20] = {{false}};\n    int visited[20][20] = {{false}};\n    reachable = 0;\n    int man_row = -1, man_col = -1;\n    int W, H;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; i++) {\n      string line;\n      cin >> line;\n      for (int j = 0; j < W; j++) {\n\tif (line[j] == '@') {\n\t  grid[i][j] = true;\n\t  man_row = i;\n\t  man_col = j;\n\t} else if (line[j] == '.') {\n\t  grid[i][j] = true;\n\t}\n      }\n    }\n    /*\n    //print out grid\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n\tif (grid[i][j] == true) {\n\t  cout << 'b';\n\t} else if (grid[i][j] == false) {\n\t  cout << 'r';\n\t} \n      }\n      cout << endl;\n    }\n    */\n    \n    DFS(grid, visited,  man_row, man_col, H, W );\n    cout << reachable << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;  //  ????????§?????????\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)    //  ????????????????¢????????????????????????????????????°???\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    while(true){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0 && m == 0){\n            break;\n        }\n\n        P st;\n        vector<vector<bool>> area(m, vector<bool>(n, false));\n        rep(i, m){\n            rep(j, n){\n                char c;\n                cin >> c;\n\n                if(c == '.'){\n                    area[i][j] = true;\n                }\n                if(c == '@'){\n                    area[i][j] = true;\n                    st = make_pair(i, j);\n                }\n            }\n        }\n\n        vector<int> d = {0, 1, 0, -1};\n\n        vector<vector<bool>> mark(m, vector<bool>(n, false));\n        queue<P> que;\n        que.push(st);\n        int ans = 0;\n        while(not que.empty()){\n            P p = que.front();\n            que.pop();\n\n            int x = p.first;\n            int y = p.second;\n            if(mark[x][y] || not area[x][y]){\n                continue;\n            }\n\n            mark[x][y] = true;\n            ans++;\n            rep(i, 4){\n                int nx = x + d[i];\n                int ny = y + d[i^1];\n                if(0 <= nx && nx < m && 0 <= ny && ny < n){\n                    que.push(make_pair(nx, ny));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (n); i++)\n#define REP(i,s,n) for(long long i = (s); i <= (n); i++)\n#define repr(i,n) for(long long i = (n - 1); i >= 0; i--)\n#define REPR(i,s,n) for(long long i = (s); i >= (n); i--)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define sumvec(v) accumulate(all(v), 0LL)\n#define pb push_back\n#define DOUBLE fixed << setprecision(15)\n#define OK cerr << \"OK\\n\"\n#define OK1 cerr << \"OK1\\n\"\n#define OK2 cerr << \"OK2\\n\"\n#define sz(s) (long long)s.size()\n#define zero(x, n) setw(x) << setfill('0') << n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef vector<vc> vvc;\ntypedef vector<vb> vvb;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vP;\n\ntemplate<class A, class B>\nostream& operator << (ostream& ost, const pair<A, B> &p) {\n    ost << \"{\" << p.first << \", \" << p.second << \"} \";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator << (ostream& ost, const vector<T>&v) {\n    ost << \"{\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        if(i) ost << \" \";\n        ost << v[i];\n    }\n    ost << \"} \\n\";\n    return ost;\n}\n\ntemplate<class A, class B>\nostream& operator << (ostream& ost, const map<A, B>&v) {\n    ost << \"{\";\n    for (auto p : v) {\n        ost << \"{\" << p.first << \", \" << p.second << \"} \";\n    }\n    ost << \"} \";\n    return ost;\n}\n\nvoid debug() { cerr << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid debug(const T &x, const Args &... args) {\n    cerr << x << \" \";\n    debug(args...);\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec) {\n    for(T& e : vec) is >> e;\n    return is;\n}\n\ntemplate<typename A, typename B>\nistream& operator >> (istream& is, pair<A, B>& p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate<typename T>\nstring join(vector<T>& vec, string sep=\" \") {\n    stringstream ss;\n    for(int i = 0; i < (int)vec.size(); i++) {\n        ss << vec[i] << (i + 1 == (int)vec.size() ? \"\\n\" : sep);\n    }\n    return ss.str();\n}\n\ntemplate<class T>\ninline bool chmax(T& a, T b){ if(a < b){ a = b; return true; } return false; }\n\ntemplate<class T>\ninline bool chmin(T& a, T b){ if(a > b){ a = b; return true; } return false; }\n\n#define INT(...) int __VA_ARGS__; IN(__VA_ARGS__)\n#define LL(...) long long __VA_ARGS__; IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__; IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__; IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__; IN(__VA_ARGS__)\n#define LD(...) long double __VA_ARGS__; IN(__VA_ARGS__)\n\nvoid scan(int& a){ cin >> a; }\nvoid scan(long long& a){ cin >> a; }\nvoid scan(char& a){ cin >> a; }\nvoid scan(double& a){ cin >> a; }\nvoid scan(string& a){ cin >> a; }\nvoid scan(long double& a){ cin >> a; }\n\nvoid IN(){}\ntemplate<class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\n\nvoid YES(bool b) { cout << ((b) ? \"YES\\n\" : \"NO\\n\"); }\nvoid Yes(bool b) { cout << ((b) ? \"Yes\\n\" : \"No\\n\"); }\nvoid yes(bool b) { cout << ((b) ? \"yes\\n\" : \"no\\n\"); }\nvoid Yay(bool b) { cout << ((b) ? \"Yay!\\n\" : \":(\\n\"); }\n\nconst long long INF = ((1LL << 62) - (1LL << 31));\nconst long double pi = acos(-1.0);\nconst long long mod=1000000007;\n//const long long mod=998244353;\n\nll powmod(ll a,ll b){ll c=1; while(b>0){ if(b&1){ c=a*c%mod; } a=a*a%mod; b>>=1; } return c;}\nll nCrmod(ll n,ll r){ll x=1,y=1; for(ll i=0;i<r;i++) {x=x*(n-i)%mod; y=y*(i+1)%mod; } return x*powmod(y,mod-2)%mod;}\nll gcd(ll a,ll b){ while(b){ ll c=b; b=a%b; a=c; } return a; }\nll lcm(ll a,ll b){ if(!a || !b) return 0; return a*b/gcd(a,b); }\nvll divisor(ll x){ vll v; for(ll i=1;i*i<=x;i++)if(x%i==0){ v.pb(i);if(i*i!=x)v.pb(x/i); } sort(all(v)); return v; };\nmap<ll,ll> prime_factor(ll n){ map<ll,ll> m; for(ll i=2;i*i<=n;i++){ while(n%i==0){ m[i]++; n/=i; } } if(n!=1) m[n]=1; return m; }\n\nll dy[] = {-1, 0, 0, 1};\nll dx[] = {0, -1, 1, 0};\n\nint main()\n{\n    ll h, w;\n    while(cin >> w >> h, w && h) {\n        vvll a(h, vll(w));\n        ll sy, sx;\n        rep(i, h) {\n            rep(j, w) {\n                CHR(c);\n                if(c == '#') a[i][j] = -1;\n                if(c == '@') sy = i, sx = j;\n            }\n        }\n        queue<P> q;\n        q.push({sy, sx});\n        a[sy][sx] = 1;\n        ll ans = 0;\n        while(!q.empty()) {\n            ans++;\n            ll y = q.front().first;\n            ll x = q.front().second;\n            q.pop();\n            rep(i, 4) {\n                ll ny = y + dy[i];\n                ll nx = x + dx[i];\n                if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n                if(!a[ny][nx]) {\n                    a[ny][nx] = 1;\n                    q.push({ny, nx});\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<string> v;\nint w, h;\n\nint dfs(int i, int j) {\n\tint cnt = 0;\n\tif (i < 0 || j < 0 || i >= h || j >= w) return 0;\n\tif (v[i][j] == '#') return 0;\n\tv[i][j] = '#';\n\tcnt++;\n\tcnt += dfs(i, j - 1) + dfs(i, j + 1) + dfs(i - 1, j) + dfs(i + 1, j);\n\treturn cnt;\n}\n\nint main()\n{\n\tint di, dj;\n\n\twhile (cin >> w >> h, w) {\n\t\tv = vector<string>(h);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> v[i];\n\t\t\tfor (int j = 0; j < w; j++) {\t\n\t\t\t\tif (v[i][j] == '@') {\n\t\t\t\t\tdi = i;\n\t\t\t\t\tdj = j;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tcout << dfs(di, dj) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <climits>\n//#include \"h.h\"\nusing namespace std;\n\n#define ll long long\n#define pint pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mp make_pair\n#define pm(first, second) pb(mp(first, second))\n#define SPACE \" \"\n#define fpf first.first\n#define fps first.second\n#define spf second.first\n#define sps second.second\n\n#define all(X) (X).begin(), (X).end()\n\nint main(){\n\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0)break;\n\t\tvector<string> S(H);\n\t\tqueue<pair<int, int>> Q;\n\t\tfor(int i = 0; i < H; i ++){\n\t\t\tcin >> S[i];\n\t\t\tfor(int j = 0; j < W; j ++){\n\t\t\t\tif(S[i][j] == '@')Q.push(mp(i, j));\n\t\t\t}\n\t\t}\n\t\tpair<int, int> P;\n\t\twhile(!Q.empty()){\n\t\t\tP = Q.front();\n\t\t\tQ.pop();\n\t\t\tS[P.first][P.second] = '@';\n\t\t\tif(P.first > 0 && S[P.first - 1][P.second] == '.')Q.push(mp(P.first - 1, P.second));\n\t\t\tif(P.first < H - 1 && S[P.first + 1][P.second] == '.')Q.push(mp(P.first + 1, P.second));\n\t\t\tif(P.second > 0 && S[P.first][P.second - 1] == '.')Q.push(mp(P.first, P.second - 1));\n\t\t\tif(P.second < W - 1 && S[P.first][P.second + 1] == '.')Q.push(mp(P.first, P.second + 1));\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < H; i ++){\n\t\t\tfor(int j = 0; j < W; j ++){\n\t\t\t\tif(S[i][j] == '@')ans ++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n};\n\nconst Point DIR[4] = {{1,0},{0,1},{-1,0},{0,-1}};\n\nclass Searcher{\nprivate:\n\tint w,h;\n\tchar map[20][20];\n\tPoint init;\n\t\n\tint cnt;\n\tbool visited[20][20];\n\t\npublic:\n\t//面倒なので、中で実装する\n\tSearcher(int w,int h, char map[20][20],Point init){\n\t\tthis->w = w;\n\t\tthis->h = h;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tthis->map[i][j] = map[i][j];\n\t\t\t\tvisited[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tthis->init = init;\n\t\tcnt = 0;\n\t}\n\t\n\tint solve(){\n\t\tdfs(init);\n\t\treturn cnt;\n\t}\n\t\nprivate:\n\tbool inField(Point pos){\n\t\treturn 0<= pos.x && pos.x < w && 0<= pos.y && pos.y < h;\n\t}\n\n\tvoid dfs(Point pos){\n\t\tcnt++;\n\t\tvisited[pos.y][pos.x] = true;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tPoint next = {pos.x + DIR[i].x, pos.y + DIR[i].y};\n\t\t\tif(inField(next)==true){\n\t\t\t\tif(visited[next.y][next.x] == false && map[next.y][next.x] == '.'){\n\t\t\t\t\tdfs(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tchar map[20][20];\n\t\tPoint init;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tinit = (Point){j,i};\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSearcher searcher(w,h,map,init);\n\t\tint result = searcher.solve();\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 21\nint ans,baseX,baseY;\nint w,h;\nchar tile[MAX][MAX];\nvoid seek(int x,int y);\nusing namespace std;\nint main() {\n  while(1){\n    cin >> w;\n    cin >> h;\n    if(w==0&&h==0) return 0;\n    rep(i,h){\n      rep(j,w){\n        cin >> tile[i][j];\n        if(tile[i][j] == '@'){\n          baseX = i;\n          baseY = j;\n        }\n      }\n      tile[i][w] = '#';\n    }\n    rep(i,w) tile[h][i] = '#';\n    ans = 1;\n    seek(baseX,baseY);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nvoid seek(int x,int y){\n  if(tile[x+1][y] == '.'){\n    tile[x+1][y] = '#';\n    ans++;\n    seek(x+1,y);\n  }\n  if(tile[x][y+1] == '.'){\n    tile[x][y+1] = '#';\n    ans++;\n    seek(x,y+1);\n  }\n  if(tile[x-1][y] == '.'){\n    tile[x-1][y] = '#';\n    ans++;\n    seek(x-1,y);\n  }\n  if(tile[x][y-1] == '.'){\n    tile[x][y-1] = '#';\n    ans++;\n    seek(x,y-1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <vector>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nusing std::vector;\n\nint main(){\n\tint w,h;\n\tvector<string> f(30);\n\tvector<vector<int>> g(30,vector<int>(30,0));\n\tint count = 0;\n\tint count2 = 0;\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tcin >> f[i];\n\t\t}\n\n\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tg[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tcount2 = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tif(f[i][j] == '@' && count== 0){\n\t\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t\t\tcount2++;\n\t\t\t\t\t}else if(g[i][j] == 1){\n\t\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\t\tif(f[i-1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i-1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i-1][j] = 1;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tif(f[i+1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i+1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i+1][j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tif(f[i][j-1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j-1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j-1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tif(f[i][j+1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j+1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j+1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(count == count2){\n\t\t\t\tcout << count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount = count2;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define TEMP_T template<typename T>\nTEMP_T void sort(T& v){ sort(v.begin(), v.end()); }\nTEMP_T void revs(T& v){ reverse(v.begin(), v.end()); }\nTEMP_T void uniq(T& v){ sort(v); v.erase(unique(v.begin(), v.end())); }\nTEMP_T T    cums(T& v){ T r; r.push_back(v[0]); for(int i=1; i<v.size(); i++) r.push_back(r[i-1] + v[i]); return r; }\nTEMP_T void show(T& v, char delim=' ', char end='\\n'){ for(int i=0; i<v.size()-1; i++) cout << v[i] << delim; cout << v[v.size()-1] << end; }\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\n\nstruct UF {\n  vector<int> data;\n  UF(int size) : data(size, -1) {}\n  void merge(int x, int y){\n    x = root(x), y = root(y);\n    if (x != y){\n      if (data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n  int root(int x){\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x){\n    return -data[root(x)];\n  }\n};\n\nstruct Solver {\n  int w, h;\n  vector<string> field;\n  Solver(int w, int h) : w(w), h(h) {}\n  int read_input(){\n    for (int i = 0; i < h; i++){\n      string s;\n      cin >> s;\n      field.push_back(s);\n    }\n    return (0);\n  }\n\n  int solve(){\n    UF uf(w * h);\n    int pos;\n    for (int y = 0; y < h; y++){\n      for (int x = 0; x < w; x++){\n        if (field[y][x] == '#') continue;\n        for (int d = 0; d < 4; d++){\n          static const int dx[] = {0, 0, 1, -1};\n          static const int dy[] = {1, -1, 0, 0};\n          int nx = x + dx[d];\n          int ny = y + dy[d];\n          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n          if (field[ny][nx] != '#') uf.merge(y * w + x, ny * w + nx);\n        }\n        if (field[y][x] == '@') pos = y * w + x;\n      }\n    }\n    return uf.size(pos);\n  }\n};\n\nint main()\n{\n  int w, h;\n  while (w = in(), h = in()){\n    Solver s(w, h);\n    s.read_input();\n    printf(\"%d\\n\", s.solve());\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nclass Solver {\npublic:\n\tstatic void solve() {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tvector<int> res;\n\t\twhile (w > 0 && h > 0) {\n\t\t\tvector<vector<bool>> grid(h, vector<bool>(w, true));\n\t\t\ttuple<int, int> start;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tstring s;\n\t\t\t\tcin >> s;\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s[j] == '#')grid[i][j] = false;\n\t\t\t\t\tif (s[j] == '@')start = make_tuple(i, j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueue<tuple<int, int>> que;\n\t\t\tque.push(start);\n\t\t\tint cnt = 0;\n\t\t\t\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto pos = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tint y = get<0>(pos);\n\t\t\t\tint x = get<1>(pos);\n\t\t\t\tif (y < 0 || h <= y || x < 0 || w <= x || !grid[y][x])continue;\n\n\t\t\t\tgrid[y][x] = false;\n\t\t\t\tcnt++;\n\t\t\t\tque.push(make_tuple(y - 1, x));\n\t\t\t\tque.push(make_tuple(y + 1, x));\n\t\t\t\tque.push(make_tuple(y, x - 1));\n\t\t\t\tque.push(make_tuple(y, x + 1));\n\t\t\t}\n\t\t\tres.emplace_back(cnt);\n\n\t\t\tcin >> w >> h;\n\t\t}\n\n\t\tfor (int i = 0; i < res.size(); i++) {\n\t\t\tcout << res[i] << endl;\n\t\t}\n\t}\n};\n\nint main() {\n\tSolver::solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint h,w;\nchar ta[22][22];\nint cheak[22][22]={0};\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint cou=0;\n\nint main(){\n  int a,b;\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    cou=0;\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> ta[i][j];\n\tcheak[i][j]=0;\n\tif(ta[i][j] == '@'){\n\t  a=i,b=j;\n\t}\n      }\n    }\n    //cout << a << \" \" << b << endl;\n    cout << dfs(a,b) << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n      cout << cheak[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n}\n\nint dfs(int x,int y){\n  cheak[x][y]=1;\n  cou++;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx>=0 && nx<h && ny>=0 && ny<w && ta[nx][ny]=='.' && cheak[nx][ny]==0){\n      dfs(nx,ny);\n    }\n  }\n  return cou;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20], check[20][20];\n\nvoid dfs(int x, int y) {\n//    cout << x << \", \" << y << endl;\n    \n    if (room[y][x] == 0) return;\n    \n    num++;\n    \n//    cout << \"num: \" << num << endl;\n    \n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1) dfs(x, y-1);\n    if (y+1 < h) dfs(x, y+1);\n    if (x-1 > -1) dfs(x-1, y);\n    if (x+1 < w) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        \n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iterator>\nusing namespace std;\n\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) (v).rbegin(), (v).rend()\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define rep(i, n) REPS(i, 0, n)\n#define REP1(i,n) for (ll i = 1; i <= (ll)(n); ++i)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {rep(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n\nvs field;\nint w,h;\nint dfs(int y, int x)\n{\n  int cnt=1;\n  field[y][x]='#';\n  rep(i,4)\n  {\n    int nx=x+dx[i], ny=y+dy[i];\n    if(nx<w&&0<=nx&&ny<h&&0<=ny&&field[ny][nx]=='.')\n    {\n      cnt+=dfs(ny,nx);\n    }\n  }\n  return cnt;\n}\n\nsigned main() \n{\n  while(cin>>w>>h, w||h)\n  {\n    field.clear(); //初期化！！\n    string s;\n    rep(i,h) \n    {\n      cin>>s;\n      field.pb(s);\n    }\n    int x,y;\n    rep(i,h) rep(j,w)\n    {\n      if(field[i][j]=='@')\n      {\n        y=i,x=j;\n      }\n    }\n    print(dfs(y,x));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;  //  ????????§?????????\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)    //  ????????????????¢????????????????????????????????????°???\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint h,w,n;\nvector<string> s;\nbool inf(int y,int x){return(y>=0&&y<h&&x>=0&&x<w)?1:0;}\nint bfs(int sy,int sx){\n\tint ret=0;\n\tqueue<P> que;\n\tque.push(P(sy,sx));\n\tvector<vector<int> > d(h,vector<int>(w,INF));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP t=que.front();\n\t\tque.pop();\n\t\tint y=t.first,x=t.second;\n\t\t\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\t\tif(inf(ny,nx)&&d[ny][nx]>d[y][x]+1&&s[ny][nx]!='#'){\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t\td[ny][nx]=d[y][x]+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(d[i][j]!=INF)\n\t\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(cin>>w>>h,h||w||n){\n\t\ts=vector<string>(h);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='@'){\n\t\t\t\t\tcout<<bfs(i,j)<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<=30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <array>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint height, width;\nint sx, sy;\nint ans = 0;\narray<int, 4> dx = {0, 0, 1, -1};\narray<int, 4> dy = {1, -1, 0, 0};\n\n\nvoid bfs()\n{\n    queue<pii> p;\n    p.push({sx, sy});\n    \n    while (!p.empty()) {\n        pii q = p.front(); p.pop();\n        \n        //??????\n        int cx = p.first;\n        int cy = p.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx.at(i);\n            int ny = cy + dy.at(i);\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height \n                    && field.at(ny).at(nx) == '.') {\n\n                ans++;\n                p.push({nx, ny});\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\nint main()\n{\n    while (cin >> height >> width) {\n        if (height == 0 && width == 0) break;\n\n        ans = 0;\n        \n        vector<vector<char>> field(height, vector<char>(width));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                cin >> field.at(y).at(x);\n\n                if (field.at(y).at(x) == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n\n        bfs();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <utility>\n\n#define phb push_back\n#define ppf pop_front\n#define mkp make_pair\n#define r first\n#define c second\nusing namespace std;\n\ntypedef pair< int, int > Pr;\nconst int kDir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nint R, C, SR, SC;\nchar M[25][25];\n\nvoid read();\nvoid solve();\n\nint main() {\n  while (cin >> C >> R, R != 0 && C != 0)\n    read(), solve();\n\n  return 0;\n}\n\nvoid read() {\n  fill(&M[0][0], &M[25][0], '#');\n  for (int i = 1; i <= R; ++i)\n    for (int j = 1; j <= C; ++j) {\n      cin >> M[i][j];\n      if (M[i][j] == '@')\n        SR = i, SC = j;\n    }\n}\n\nvoid solve() {\n  static int vst[25][25], vst_cnt;\n  int res = 0;\n  deque< Pr > que;\n\n  que.phb(mkp(SR, SC)), vst[SR][SC] = ++vst_cnt;\n  while (!que.empty()) {\n    Pr cur = que.front(); que.ppf(), ++res;\n    for (int di = 0; di < 4; ++di) {\n      Pr nxt(cur.r + kDir[di][0], cur.c + kDir[di][1]);\n      if (M[nxt.r][nxt.c] == '.' && vst[nxt.r][nxt.c] != vst_cnt)\n        que.phb(nxt), vst[nxt.r][nxt.c] = vst_cnt;\n    }\n  }\n\n  cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\tint w,h;\n\tint data[30][30];\n\tint flag[30][30];\n\tint dx[4] ={0,1,0,-1};\n\tint dy[4] ={1,0,-1,0};\n\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)break;\n\n\tfor(int i=0;i<30;i++){\n\t\tfor(int j=0;j<30;j++){\n\t\t\tdata[i][j]=-1;\n\t\t\tflag[i][j]=0;\n\t\t}\n\t}\n\n\tchar tmp;\n\tint startX;\n\tint startY;\n\tint cnt=0;\n\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>tmp;\n\t\t\tif(tmp=='.')data[i][j] = 0;\n\t\t\telse if(tmp=='@'){\n\t\t\t\tstartX = j;\n\t\t\t\tstartY = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<int> qX,qY;\n\tqX.push(startX);\n\tqY.push(startY);\n\n\twhile(qX.size()!=0){\n\t\tint topX = qX.front();\n\t\tint topY = qY.front();\n\t\tqX.pop();\n\t\tqY.pop();\n\t\tcnt++;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nowX = topX + dx[i];\n\t\t\tint nowY = topY + dy[i];\n\n\t\t\tif(data[nowY][nowX] ==0 && flag[nowY][nowX] == 0){\n\t\t\t\tqX.push(nowX);\n\t\t\t\tqY.push(nowY);\n\t\t\t\tflag[nowY][nowX]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// PKU 1979\n#include<cstdio>\n#define rep( i, a ) for( int i = 0; i != (a); ++i )\n\nint W, H;\nchar fld[20][20];\nint ans;\n\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nvoid dfs( int x, int y )\n{\n\t++ans;\n\tfld[y][x] = ' ';\n\n\trep( i, 4 )\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H && fld[ny][nx] == '.' )\n\t\t\tdfs( nx, ny );\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &W, &H ), W | H )\n\t{\n\t\tans = 0;\n\t\tint sx, sy;\n\n\t\trep( i, H )\n\t\t{\n\t\t\tgetchar();\n\n\t\t\trep( j, W )\n\t\t\t{\n\t\t\t\tfld[i][j] = getchar();\n\t\t\t\n\t\t\t\tif( fld[i][j] == '@' )\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t}\n\t\t}\n\n\t\tdfs( sx, sy );\n\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<(x);++i)\n\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n\nchar mp[20][22];\nint H, W;\n\nvoid dfs(int y, int x)\n{\n\tif (y < 0 || y >= H || x < 0 || x >= W || mp[y][x] == '#' || mp[y][x] == ' ') return;\n\n\tmp[y][x] = ' ';\n\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &W, &H), H || W) {\n\t\tint sy, sx;\n\n\t\trep(i, H) rep(j, W) {\n\t\t\tscanf(\"\\n%c\", &mp[i][j]);\n\t\t\tif (mp[i][j] == '@') sy = i, sx = j, mp[i][j] = '.';\n\t\t}\n\n\t\tdfs(sy, sx);\n\n\t\tint cnt = 0;\n\n\t\trep(i, H) rep(j, W) if (mp[i][j] == ' ') cnt++;\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool b[21][21];\nint w,h,count=0;\n\nvoid dfs(int x, int y){\n b[y][x]=1;count++;\n int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=dx[i]+x;\n  ny=dy[i]+y;\n  if(0<=nx&&nx<w&&0<=ny&&ny<h)\n   if(b[ny][nx]==0)dfs(nx,ny);\n  }\n }\n\nint main(){\nchar a;\nint sx,sy;\nwhile(1){\ncin>>w>>h;\ncount=0;\nb[21][21]={};\nif(w+h==0)break;\nfor(int i=0;i<h;i++)\nfor(int j=0;j<w;j++){\ncin>>a;\nif(a=='#')b[i][j]=1;\nif(a=='@'){sx=j;sy=i;}\n}\ndfs(sx,sy);\ncout<<count<<endl;\n}\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX = 20;\nchar map[MAX][MAX];\nbool book[MAX][MAX];\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x = 0, int y = 0) :x(x), y(y) {}\n}start;\nint sum = 0;\nvoid depthFSearch(int H, int W, Point start)\n{\n\tint next[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\n\tfor (int k = 0; k <= 3; k++)\n\t{\n\t\tint nx = start.x + next[k][0];\n\t\tint ny = start.y + next[k][1];\n\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W||map[nx][ny]=='#')\n\t\t\tcontinue;\n\t\tif (!book[nx][ny] && map[nx][ny] == '.')\n\t\t{\n\t\t\tbook[nx][ny] = true;\n\t\t\tPoint p(nx, ny);\n\t\t\tsum++;\n\t\t\tdepthFSearch(H, W, p);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tint H, W;\n\t\tcin >> W >> H;\n\t\tif (!H && !W)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tbook[i][j] = false;\n\t\t\t\tif (map[i][j] == '@')\n\t\t\t\t\tstart = Point(i, j);\n\t\t\t}\n\t\tbook[start.x][start.y] = true;\n\t\tsum = 1;\n\t\tdepthFSearch(H, W, start);\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#define rep(i, n) for (int i=0; i<n; ++i)\n#define FOR(i, a, b) for (int i=a; i<b; ++i)\n#define pb(x) push_back(x)\n#define ll long long\n#define ul unsigned long long\n#define dbg(x) cout  << #x << \" : \" << (x) << endl\n#define out(x) cout << (x)\n#define outl(x) cout << (x) << endl\n#define int(n); int n; cin >> n;\n#define long(n); long long n; cin >> n;\n#define dbl(f); double f; cin >> f;\n#define s(s); string s; cin >> s;\n#define into(a, n) for (int i = 0; i < n; ++i) cin >> a[i]\nusing namespace std;\n\nconst int inf =1500000000;\nchar a[20][20];\nint cnt; \nint w,h; \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1}; \nvoid dfs(int x, int y) {\n  a[y][x] = '#';\n  cnt++;\n  rep(i, 4) {\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx<w&&ny<h&&nx>=0&&ny>=0&&a[ny][nx]=='.') dfs(nx, ny);\n  }\n}\n\nint main () {\n  while(true){\n    cnt = 0;\n    cin>>w>>h;\n    if (w==0&& h==0) break;\n    int x0,y0;\n    rep(i, h) {\n      rep(j, w) {\n        cin>>a[i][j];\n        if(a[i][j]=='@' ) {\n          x0=j; y0=i;\n          a[i][j]='.';\n        }\n      } \n    } \n    dfs(x0, y0);\n    outl(cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nint dw[] = {0, 0, 1, -1};\nint dh[] = {1, -1, 0, 0};\n\nint dfs(vector<string>& field, int h, int w){\n    int H = field.size();\n    int W = field[0].size();\n    \n    field[h][w] = 'a';\n    int res = 1;\n    \n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(nh<0 || H<=nh || nw<0 || W<=nw || field[nh][nw] != '.')\n            continue;\n        res += dfs(field, nh, nw);\n    }\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int W, H;\n    while(cin>>W>>H, W|H){\n        vector<string> field(H);\n        for(int i=0; i<H; i++)\n            cin >> field[i];\n        \n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if(field[i][j] == '@'){\n                    cout << dfs(field, i, j) << endl;\n                    break;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n#endif\n\n#include <iostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nstruct pos\n{\n    int x;\n    int y;\n};\nbool state[25][25];\nint result = 1, width, height;\n\nvoid tansaku(pos cur)\n{\n    // 右へ\n    if (cur.x < width - 1 && state[cur.x + 1][cur.y])\n    {\n        state[cur.x + 1][cur.y] = false;\n        result++;\n        tansaku({.x = cur.x + 1, .y = cur.y});\n    }\n    // 左へ\n    if (0 < cur.x && state[cur.x - 1][cur.y])\n    {\n        state[cur.x - 1][cur.y] = false;\n        result++;\n        tansaku({.x = cur.x - 1, .y = cur.y});\n    }\n    // 上へ\n    if (0 < cur.y && state[cur.x][cur.y - 1])\n    {\n        state[cur.x][cur.y - 1] = false;\n        result++;\n        tansaku({.x = cur.x, .y = cur.y - 1});\n    }\n    // 下へ\n    if (cur.y < height - 1 && state[cur.x][cur.y + 1])\n    {\n        state[cur.x][cur.y + 1] = false;\n        result++;\n        tansaku({.x = cur.x, .y = cur.y + 1});\n    }\n}\n\nint main()\n{\n    while (cin >> width >> height && (width != 0 || height != 0))\n    {\n        result = 1;\n        pos cur;\n\n        for (int y = 0; y < height; y++)\n        {\n            string word;\n            cin >> word;\n            for (int x = 0; x < width; x++)\n            {\n                char c = word[x];\n                if ('.' == c)\n                {\n                    state[x][y] = true;\n                }\n                else if ('@' == c)\n                {\n                    state[x][y] = false;\n                    cur.x = x;\n                    cur.y = y;\n                }\n                else if ('#' == c)\n                {\n                    state[x][y] = false;\n                }\n            }\n        }\n        tansaku(cur);\n        cout << result << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb         push_back\n\nconst int INF = 100000000;\n\nint dx[4] = {-1, 0 , 1, 0}, dy[4] = {0 , -1, 0, 1};\nint w, h;\nvector<string> ma;\n\nvoid rec(int y, int x);\n\nint main(void) {\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tma = vector<string>();\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tma.pb(t);\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor(int i=0; i<h; i++){\n\t\t\t//cout << ma[i] << endl;\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(ma[i][j] == '@'){\n\t\t\t\t\tma[i][j] = '.';\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trec(sy, sx);\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(ma[i][j] == 'o'){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\t\n\treturn 0;\n}\n\nvoid rec(int y, int x){\n\t//cout << y << ' ' << x << endl;\n\tif(ma[y][x] == '.') ma[y][x] = 'o';\n\telse return;\n\tint nx, ny;\n\tfor(int i=0; i<4; i++){\n\t\tnx = x + dx[i];\n\t\tny = y + dy[i];\n\n\t\tif(nx >= 0 && nx < w && ny >= 0 && ny < h){\n\t\t\trec(ny, nx);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P,P> PP;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nint main() {\n    int h, w;\n    while(cin >> w >> h, h){\n        string s[25];\n        int si, sj;\n        UnionFindTree g;\n        g.init(h*w);\n        REP(i,h) cin >> s[i];\n        REP(i,h){\n            REP(j,w){\n                if(s[i][j]=='#')continue;\n                if(s[i][j]=='@'){\n                    si = i;\n                    sj = j;\n                }\n                REP(k,4){\n                    int ni = i+di[k], nj = j+dj[k];\n                    if(ni < 0 || ni >= h) continue;\n                    if(nj < 0 || nj >= w) continue;\n                    if(s[ni][nj]=='#') continue;\n                    g.unite(i*w+j,ni*w+nj);\n                }\n            }\n        }\n        cout << g.size(si*w+sj) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\nusing namespace std;\nchar mas[30][30];\nint W,H,sum;\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\nvoid dfs(int x, int y);\nint main(){\n  int sx,sy;\n  while(1){\n    sum = 0;\n    cin >> W >> H;\n    if(W == 0 && H == 0)break;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> mas[i][j];\n\tif(mas[i][j] == '@'){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n    dfs(sx,sy);\n    cout << sum << endl;\n  }\n}\nvoid dfs(int x, int y){\n  sum++;\n  mas[y][x] = '#';\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < W && ny >= 0 && ny < H && mas[ny][nx] != '#'){\n      dfs(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\n\nint w, h;\nstring mp[20];\n\nint dfs(int x, int y) {\n\tint res = 1;\n\tmp[y][x] = '#';\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = { 0,-1, 0, 1};\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0<=nx && nx<w && 0<=ny && ny<h && mp[ny][nx]=='.') {\n\t\t\tres += dfs(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tint sx, sy;\n\t\trep(i, h) {\n\t\t\tcin >> mp[i];\n\t\t\trep(j, w) {\n\t\t\t\tif(mp[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w,h;\nstring field[21]; // ¶ðµ¤ÌÅstring^Ìzñðg¤ÆÖÅ·B\n\n// 4ßT(ãº¶E)ÌÆ«ÍÌæ¤ÈzñðpÓ·éÆÖ\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\n// »Ýn(x,y)\nvoid dfs(int x, int y){\n\t// ¡¢éÆ±ëð'B'Éu«·¦é\n\tfield[y][x] = 'B';\n\n\t// Ú®·é4ûüð[v\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t// xûüÉdx[i], yûüÉdy[i], Ú®µ½êð(mx,my)Æ·é\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\t// ÍÍOÉo½Æ«ÍÌÖ\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t// ¢^C'.'¾Á½çÄAÄÑoµ\n\t\tif( field[my][mx] == '.' ){\n\t\t\tdfs( mx , my );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w||h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> field[y];\n\t\t}\n\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( field[y][x] == '@' ){ // l'@'¾Á½çÄAÖðÄÑo·\n\t\t\t\t\tdfs( x , y );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\t// [vÅ'B'Ìð¦é(BÂ\\È¢^CÌ)\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( field[y][x] == 'B' )\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\nusing namespace std;\nusing Tiles = vector<string>;\n\nstruct Point {\n\tint x;\n\tint y;\n\n\tPoint() :\n\t\tx{0}, y{0}\n\t{}\n\n\tPoint(int _x, int _y) :\n\t\tx{_x}, y{_y}\n\t{}\n\n\tconst Point operator+ (const Point& rhs) const\n\t{\n\t\tPoint temp{x + rhs.x, y + rhs.y};\n\t\treturn temp;\n\t}\n};\n\nconst Point Arround[4] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint dfs(const Tiles& tiles, const Point& start, int W, int H)\n{\n\tint count{0};\n\tqueue<Point> Q;\n\n\t// ????????¨????????????????????????????????????\n\tvector<vector<bool>> done(H, vector<bool>(W, false));\n\n\tQ.push(start);\n\tdone[start.y][start.x] = true;\n\n\twhile(true) {\n\t\tif(Q.empty()) break;\n\n\t\tconst auto& pos = Q.front();\n\t\tQ.pop();\n\n\t\tif(tiles[pos.y][pos.x] == '#') continue;\n\n\t\t++count;\n\n\t\tfor(const auto& a : Arround) {\n\t\t\tconst auto& p = pos + a;\n\n\t\t\tif(p.x < 0 || W <= p.x) continue;\n\t\t\tif(p.y < 0 || H <= p.y) continue;\n\t\t\tif(done[p.y][p.x]) continue;\n\n\t\t\tdone[p.y][p.x] = true;\n\t\t\tQ.push(p);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nint main()\n{\n\tint W, H;\n\n\twhile(true) {\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0) break;\n\n\t\tTiles tiles(H);\n\t\tPoint start;\n\n\t\tfor(int i = 0; i < H; ++i) {\n\t\t\tcin >> tiles[i];\n\n\t\t\tfor(int j = 0; j < tiles[i].size(); ++j) {\n\t\t\t\tif(tiles[i][j] == '@') {\n\t\t\t\t\tstart = Point{j, i};\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(tiles, start, W, H) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define loop(i,a,b) for(ll i=(a);i<ll(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint h,w;\nchar g[30][30];\n\nint rec(int ci, int cj){\n    g[ci][cj] = '#';\n    int ans = 1;\n    int di[] = {0,1,0,-1};\n    int dj[] = {1,0,-1,0};\n    rep(i,4){\n        int ni = ci + di[i];\n        int nj = cj + dj[i];\n        if(ni >= h || nj >= w || ni < 0 || nj < 0 || g[ni][nj] == '#') continue;\n        ans += rec(ni,nj);\n    }\n    return ans;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&w,&h), w != 0){\n        rep(i,h) scanf(\"%s\",g[i]);\n        int ans = 0;\n        rep(i,h)rep(j,w) if(g[i][j]=='@') ans = rec(i,j);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  while(1){\n    int dfs(int x,int y,int count);\n    \n    int w,h;\n    int dx[4]={0,-1,0,1};\n    int dy[4]={-1,0,1,0};\n    int sum=0;\n    char maps[21][21];\n    \n    int main(){\n      int sx,sy;\n      cin >> h >> w;\n      if(h==0 && w==0) break; \n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> maps[i][j];\n\t  if(maps[i][j]=='@'){\n\t    sy=i;\n\t    sx=j;\n\t  }\n\t}\n      }\n      int ans = dfs(sx,sy,0);\n      cout << ans << endl;\n    }\n    \n    int dfs(int x,int y,int count){\n      int nx,ny;\n      for(int i=0;i<4;i++){\n\tnx=x+dx[i];\n\tny=y+dy[i];\n\tmaps[y][x]='#';\n\tif(0<=nx && nx<w && 0<=ny && ny<h && maps[ny][nx]!='#'){\n\t  sum++;\n\t  dfs(nx,ny,count+1);\n\t}\n      }\n      return sum;\n    }\n  }\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n\nusing namespace std;\n\n//マップ探索\nvoid check(int w, int h, int x, int y, int map[20][20], int *ans){\n\n\tif(map[x][y] != 0) *ans = *ans + 1;\n\tif(map[x][y] == 0) return;\n\tmap[x][y] = 0;\n\n\tif(x > 0) check(w, h, x - 1, y, map, ans);\n\tif(x < w - 1) check(w, h, x + 1, y, map, ans);\n\tif(y > 0) check(w, h, x, y - 1, map, ans);\n\tif(y < h - 1) check(w, h, x, y + 1, map, ans);\n\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile(1) {\n\t\t//変数宣言\n\t\tint w, h ;\n\t\tint x, y ;\n\n\t\tint map[20][20];\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 ) break;\t//終了処理\n\n\t\t//マップ初期化\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tchar ch = tmp.at(j);\n\t\t\t\tswitch(ch) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[j][i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tmap[j][i] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tmap[j][i] = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tcheck(w,h,x,y,map,&ans);\n\n\t\tcout << ans << endl;\n\t}\n\n\t\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint w, h;\nchar ch[50][50];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint bfs(int y, int x) {\n    int res = 0;\n    rep(i, 4) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 > ny or 0 > nx or ny >= h or nx >= w) continue;\n        if (ch[ny][nx] == '.') {\n            ch[ny][nx] = 'a';\n            res += bfs(ny, nx) + 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> w >> h and w and h) {\n        int py = 0, px = 0;\n        rep(i, h) rep(j, w) {\n            cin >> ch[i][j];\n            if (ch[i][j] == '@') {\n                py = i, px = j;\n                ch[i][j] = '.';\n            }\n        }\n        cout << bfs(py, px) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nconst int N=25;\nint a[N*N];\nchar c[N][N];\nint root(int x){\n\tint i=x;\n\twhile(1){\n\t\tif(a[x]==x) break;\n\t\tx=a[x];\n\t}\n\tint j=x;\n\twhile(1){\n\t\tif(a[i]==i) break;\n\t\tx=a[i],a[i]=j,i=x;\n\t}\n\treturn j;\n}\nint main(){\n\tint m,n;\n\twhile(scanf(\"%d%d\",&n,&m)){\n\t\tif(m==0&&n==0) break;\n\t\tgetchar();\n\t\tint i,j;\n\t\tfor(i=1;i<=m*n;i++) a[i]=i;\n\t\tfor(i=0;i<m;i++) gets(c[i]);\n\t\tfor(i=0;i<m;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(c[i][j]=='#') continue;\n\t\t\t\tint r=root(i*n+j+1),rr;\n\t\t\t\tif(i&&c[i-1][j]!='#'){\n\t\t\t\t\trr=root((i-1)*n+j+1);\n\t\t\t\t\tif(r!=rr) a[rr]=r;\n\t\t\t\t}\n\t\t\t\tif(i+1<m&&c[i+1][j]!='#'){\n\t\t\t\t\trr=root((i+1)*n+j+1);\n\t\t\t\t\tif(r!=rr) a[rr]=r;\n\t\t\t\t}\n\t\t\t\tif(j&&c[i][j-1]!='#'){\n\t\t\t\t\trr=root(i*n+j-1+1);\n\t\t\t\t\tif(r!=rr) a[rr]=r; \n\t\t\t\t}\n\t\t\t\tif(j+1<n&&c[i][j+1]!='#'){\n\t\t\t\t\trr=root(i*n+j+1+1);\n\t\t\t\t\tif(r!=rr) a[rr]=r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s,ans=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(c[i][j]=='@'){\n\t\t\t\t\ts=root(i*n+j+1);\n\t\t\t\t\tfor(int k=1;k<=m*n;k++){\n\t\t\t\t\t\tif(s==root(k)) ans++;\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j<n) break;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<utility>\n#include<string.h>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define CHMIN(a,b) (a) = min((a),(b))\n#define CHMAX(a,b) (a) = max((a),(b))\n\nint main()\n{\n    std::queue<pair<int,int> > que;\n    int w,h;\n    char ban[25][25]={};\n    int dx[4]={1,0,-1,0};\n    int dy[4]={0,-1,0,1};\n    int ans;\n    while(1==1)\n    {\n        ans=0;\n        scanf(\"%d %d\\n\",&w,&h);\n        if(w==0&&h==0)return 0;\n        REP(i,25)REP(j,25)ban[i][j]='\\0';\n        REP(i,h)\n        {\n            REP(j,w)\n            {\n                scanf(\"%c\",&ban[i][j]);\n                if(ban[i][j]=='@')que.push(pair<int,int>(i,j));\n            }\n            scanf(\"\\n\");\n        }\n        while(!que.empty())\n        {\n            pair<int,int> p=que.front();\n            que.pop();\n            if(ban[p.first][p.second]=='.'||ban[p.first][p.second]=='@')\n            {\n                ban[p.first][p.second]='#';\n                ans++;\n                REP(i,4)\n                {\n                    if(ban[p.first+dy[i]][p.second+dx[i]]=='.')\n                    {\n                        que.push(pair<int,int>(p.first+dy[i],p.second+dx[i]));\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\nvoid move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\tans+=move(x+vec[i][0],y+vec[i][1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\nchar cm[200][200];\nint im[200][200];\n int W,H;\nbool visited[200][200];\nint sy,sx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ntypedef pair<int,int> P;\nint maxx = 1;\nint q = 1;\n\nint dp(int x,int y){\n \n\n  for(int i=0;i<4;i++)\n    {\n      int ny = y+dy[i],nx = x + dx[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && cm[ny][nx] != '#' && !visited[ny][nx]){\n\tq++;\n\tim[ny][nx] = q;\n\tmaxx = max(maxx,q);\n\tvisited[ny][nx] = true;\n\tdp(nx,ny);\n      }\n    }\n}\n\n\nint main(){\n \n\n  while(1)\n    {\n      cin >> W >> H;\n      if(W == 0 && H == 0)break;\n      maxx = 1;\n      memset(im,0,sizeof(im));\n      memset(visited,false,sizeof(visited));\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      cin >> cm[i][j];\n\t      if(cm[i][j] == '#'){\n\t\tim[i][j] = 0;\n\t      }\n\t      else if(cm[i][j] == '@')\n\t\t{\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t}\n\t    }\n\t}\n\n      im[sy][sx]=1;\n      q = 1;\n      visited[sy][sx] = true;\n      dp(sx,sy);\n      cout << maxx  << endl;\n      /*          \n for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++)cout << im[i][j];\n\tcout << endl;\n      }\n      */\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[21][21];\nint used[20][20];\nint W, H;\n \nint rec(int i, int j){\n \n   if(fld[i][j]=='#') return 0;\n   if(used[i][j]) return 0;\n   used[i][j]=1;\n   int ret=0;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      ret+=rec(ni, nj);\n   }\n \n   return ret+1;\n}\n \nint main(){\n \n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n               fld[i][j]='.';\n            }\n         }\n      }\n \n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      cout<< rec(sy, sx)<< endl;\n   }\n \n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> W >> H && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j+1;\n\t\t\t\t}\n\t\t\tf[i+1] = '#'+f[i+1]+'#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tfunction<void(int, int)> dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n\nchar map[30][30];\npair<int,int> s;\nint w,h;\nint cnt;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nclass Node{\npublic:\n  int x,y;\n  int cnt;\n  Node(int _x,int _y,int _cnt):x(_x),y(_y),cnt(_cnt){\n\n  }\n\n};\nint sx,sy;\nvoid show(){\n  for(int i=0;i<h;i++){\n    cout<<map[i]<<endl;\n\n  }\n}\nint bfs(){\n  queue<Node> q;\n  q.push(Node(sx,sy,0));\n  map[sy][sx]='#';\n  int ans=0;\n  while(!q.empty()){\n    Node cur=q.front();q.pop();\n    //    show();\n    ans=max(ans,cur.cnt);\n    for(int i=0;i<4;i++){\n      int nx=cur.x+dx[i];\n      int ny=cur.y+dy[i];\n      if(nx<0||nx>=w||ny<0||ny>=h||map[ny][nx]=='#')continue;\n      map[ny][nx]='#';\n      cnt++;\n      q.push(Node(nx,ny,cur.cnt+1));\n    }\n  }\n  return cnt;\n    \n}void solve(){\n  cnt=0;\n\n  cout<<bfs()+1<<endl;\n}\nint main(){\n  while(cin>>w>>h&&(w||h)){\n    //    for(int i=0;i<h;i++)for(int j=0;j<w;j++)map[i][j]='.';\n    for(int i=0;i<h;i++){\n      cin>>map[i];\n      for(int j=0;j<w;j++){\n\tif(map[i][j]=='@'){\n\t  sx=j;sy=i;\n\t}\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (1){\n\tscanf(\"%d %d\", &w, &h);\n\tif (w == 0 && h == 0) break;\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\tdfs(sx, sy);\n\tprintf(\"%d\\n\", tile);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, m, n) for (int i = m; i < n; ++i)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n  while(1) {\n    int W, H; cin >> W >> H;\n    if(!W) break;\n    vector<string> G(H);\n    rep(i, 0, H) cin >> G[i];\n    vector<vector<int>> visited(H,vector<int>(W));\n    using P = pair<int, int>;\n    queue<P> Q;\n    rep(i, 0, H) rep(j, 0, W) {\n      if(G[i][j] == '@') {\n        Q.push(P(i, j));\n        visited[i][j] = 1;\n      }\n    }\n    int ans = 0;\n    while(!Q.empty()) {\n      ans++;\n      P p = Q.front(); Q.pop();\n      int y = p.first, x = p.second;\n      rep(i, 0, 4) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny < 0 || nx < 0 || ny >= H || nx >= W) continue;\n        if(visited[ny][nx]) continue;\n        if(G[ny][nx] == '.') {\n          visited[ny][nx] = 1;\n          Q.push(P(ny, nx));\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <math.h>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <assert.h>\nusing ll=long long;\n#define int ll\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\nconst int INF = 1e15;\nusing namespace std;\n\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class T>\ninline bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>\ninline bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout<<fixed<<setprecision(20);\n\n    int N,M;\n    while(true){\n        cin >> N >> M;\n        if(N==0 && M==0) break;\n        int x,y;\n        char C[M+2][N+2];\n        rep(i,M+2) rep(j,N+2) C[i][j]='#';\n        rep(i,M){\n            rep(j,N){\n                cin >> C[i+1][j+1];\n                if(C[i+1][j+1]=='@'){\n                    x=i+1; y=j+1;\n                }\n            }\n        }\n        queue<pi> que;\n        que.emplace(x,y);\n        int ans=0;\n        while(!que.empty()){\n            int a=que.front().fi,b=que.front().se;\n            que.pop();\n            if(C[a][b]=='#') continue;\n            ans++;\n            C[a][b]='#';\n            rep(i,4){\n                if(C[a+dx[i]][b+dy[i]]=='.'){\n                    que.emplace(a+dx[i],b+dy[i]);\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w;\nint h;\nint ans;\nvector <vector<char>> maps;\n\nbool check(int x, int y){\nif (0>x || x>=h || 0>y || y>=w){\nreturn false;\n}\nif (maps[x][y]!='.'){\nreturn false;\n}\nreturn true;\n}\n\nvoid bfs(int x, int y){\nvector <vector<int>> move = {{1,0},{-1,0},{0,1},{0,-1}};\nfor (const auto& e: move){\nif (check(x+e[0],y+e[1])){\nans+=1;\nmaps[x+e[0]][y+e[1]]='#';\nbfs(x+e[0],y+e[1]);\n}\n}\n}\n\nint main(){\ncin >> w >> h;\nbool flag = false;\nint pos_x;\nint pos_y;\nwhile (w!=0 || h!=0){\nvector <vector<char>> rawmaps(h,vector<char>(w+1));\nans = 0;\nfor (int i = 0; i < h; i++){\nfor (int j = 0; j < w; j++){\ncin >> rawmaps[i][j];\nif (rawmaps[i][j]=='@'){\npos_x=i;\npos_y=j;\n}\n}\n}\nmaps = rawmaps;\n\nbfs(pos_x,pos_y);\ncout << ans+1 << endl;\ncin >> w >> h;\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nint box[22][22]={{}};\nint  kazoe(int p,int P,int H,int W){\n  int i,I;\n  a++;\n  box[p][P]=0;\n  if(box[p][P+1]==1) kazoe(p,P+1,H,W);\n  if(box[p][P-1]==1) kazoe(p,P-1,H,W);\n  if(box[p-1][P]==1) kazoe(p-1,P,H,W);\n  if(box[p+1][P]==1) kazoe(p+1,P,H,W);\n  else {\n  return a;\n  }\n}\nint main(){\n  int i,I,H,W,p,P;\n  \n  char v;\n  while(1){\n  cin>>W>>H;\n  for(i=0;i<=H+1;i++){\n    for(I=0;I<=W+1;I++){\n      box[i][I]=0;\n    }\n  }\n  if(W==0&&H==0) break;\n  for(i=1;i<=H;i++){\n    for(I=1;I<=W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  cout<<kazoe(p,P,H,W)<<endl;\n  a=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n\nint W, H;\nint sx, sy;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\nint main() {\n\twhile (true) {\n\t\tint ans = 0;\n\t\tchar map[20][20];\n\t\tbool d[20][20];\n\t\tcin >> W >> H;\n\n\t\tif (W == 0)return 0;\n\n\t\trep(i, 0, H)rep(j, 0, W) {\n\t\t\tcin >> map[i][j];\n\t\t\tif (map[i][j] == '@') { sy = i; sx = j; }\n\t\t}\n\n\t\tqueue<P> que;\n\t\trep(i, 0, 20)rep(j, 0, 20)d[i][j] = false;\n\t\tque.push(P(sy, sx));\n\t\td[sy][sx] = true;\n\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\trep(i, 0, 4) {\n\t\t\t\tint ny = p.first + dy[i];\n\t\t\t\tint nx = p.second + dx[i];\n\t\t\t\tif (!(0 <= nx && 0 <= ny && ny < H && nx < W))continue;\n\t\t\t\tif (map[ny][nx] != '#' && d[ny][nx] != true) {\n\t\t\t\t\td[ny][nx] = true;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, 0, 20)rep(j, 0, 20) {\n\t\t\tif (d[i][j] == true)ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n//BFSでやってみる\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nint H, W;\nint table[20][20];\nint cnt;\n\nvoid calc(int current_y, int current_x) {\n\ttable[current_y][current_x] = 3;\n\n\tif(current_y > 0 && table[current_y-1][current_x] == 1)\n\t\tcalc(current_y-1, current_x);\n\tif(current_x > 0 && table[current_y][current_x-1] == 1)\n\t\tcalc(current_y, current_x-1);\n\tif(current_y < H-1 && table[current_y+1][current_x] == 1)\n\t\tcalc(current_y+1, current_x);\n\tif(current_x < W-1 && table[current_y][current_x+1] == 1)\n\t\tcalc(current_y, current_x+1);\n\n\tcnt++;\n}\n\n\nint main() {\n\twhile(1) {\n\t\tcnt = 0;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0) break;\n\n\t\tchar temp;\n\t\tint current[2];\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tcin >> temp;\n\t\t\t\tif(temp=='.') table[i][j] = 1;\n\t\t\t\telse if(temp=='#') table[i][j] = 2;\n\t\t\t\telse if(temp=='@') {\n\t\t\t\t\ttable[i][j] = 0;\n\t\t\t\t\tcurrent[0] = i;\n\t\t\t\t\tcurrent[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalc(current[0], current[1]);\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define MAP_COLUMNS (20+3) // \\r\\n\\0\n\n//#define dprintf(arg1, ... ) printf( arg1, __VA_ARGS__)\n#define dprintf(arg1, ... ) \n\nvoid proc( int width, int height, char map[][MAP_COLUMNS], int x, int y );\n\ninline void docheck( int width, int height, char map[][MAP_COLUMNS], int x, int y ) {\n\tif ( x<0 || x >= width || y<0 || y >= height ) {\n\t\t//invalid\n\t\treturn;\n\t}\n\tdprintf(\"x=%d y=%d  map[y][x]=%c\\n\",x,y,map[y][x]);\n\tif ( map[y][x] != '.' ) { return; }\n\t\n\tmap[y][x] = '@';\n\tproc(width, height, map, x, y);\n}\n\nvoid proc( int width, int height, char map[][MAP_COLUMNS], int x, int y ) {\n\n\t//Left\n\tdocheck(width, height, map, x-1, y);\n\t\n\t//Right\n\tdocheck(width, height, map, x+1, y);\n\t\n\t//Up\n\tdocheck(width, height, map, x, y-1);\n\t\n\t//Down\n\tdocheck(width, height, map, x, y+1);\n}\n\nint main(void) {\n\n\tchar map[20][MAP_COLUMNS];\n\t\n\twhile (1) {\n\t\tint width, height;\n\t\tscanf(\"%d %d\\n\", &width, &height);\n\t\tif ( width==0 && height==0 ) { break; }\n\t\t\n\t\tmemset( map, 0, sizeof(char) * 20 * MAP_COLUMNS );\n\t\t\n\t\tint startx=-1, starty=-1;\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfgets(map[i], MAP_COLUMNS, stdin);\n\t\t\tchar* pos = strchr( map[i], '@' );\n\t\t\tif ( pos != NULL ) {\n\t\t\t\tstartx = pos - map[i];\n\t\t\t\tstarty = i;\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%d %d\\n\",startx,starty);\n\t\tproc(width, height, map, startx, starty);\n\t\t\n\t\tint count=0;\n\t\tfor ( int i=0; i< 20 * MAP_COLUMNS ; i++ ) {\n\t\t\tif( map[0][i] == '@' ) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nvector<string> C;\nvector<vector<bool>> used;\nint MH, MW;\n#define H first\n#define W second\nbool inside(int h, int w) {\n    return 0 <= h && h < MH && 0 <= w && w < MW;\n}\nbool inside(PII p){return inside(p.H, p.W);}\nint dh[] = {-1, 0, 0, 1};\nint dw[] = {0, -1, 1, 0};\nint dfs(PII now) {\n    int res = 1;\n    if (used[now.H][now.W]) return 0;\n    used[now.H][now.W] = true;\n    REP(i, 4) {\n        auto buf = MP(now.H + dh[i], now.W + dw[i]);\n        if (!inside(buf)) continue;\n        if (C[buf.H][buf.W] == '.') res += dfs(buf);\n    }\n    return res;\n}\nvoid solve(int w, int h) {\n    MH = h; MW = w;\n    C.resize(h);\n    used.resize(h, vector<bool>(w, false));\n    PII start;\n    REP(i, h) {\n        cin >> C[i];\n        REP(j, w) {\n            if (C[i][j] == '@') start = MP(i, j);\n        }\n    }\n    //cout << start.H << \" \" << start.W << endl;\n    cout << dfs(start) << endl;\n    used.clear();\n    return;\n}\n\nint main(void) {\n    int n, p, m, w, h;\n    string s;\n    int a, b, c;\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) return 0;\n        solve(w, h);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t\tcompute();\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*W);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%W;\n\t        int y=cur/W;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[i];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny&&ny<H))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*W);\n  visited[ny][nx]=true;\n++answer;\n    }\n   }\n //cout << answer << endl;\n printf(\"%d\\n\",answer);\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <set>\nusing namespace std;\n\nint main() {\n  int h, w;\n  while(cin >> w >> h, w || h) {\n    vector<vector<bool> > qfield(h, vector<bool>(w)); // black: true, red: true\n    int starty, startx;\n    for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) {\n      char c;\n      cin >> c;\n      qfield[y][x] = (c == '#' ? false : true);\n      if(c == '@') {\n        starty = y;\n        startx = x;\n      }\n    }\n    set<pair<int, int> > countedPoses;\n    function<int(int, int)> tileCount = [&](int y, int x) {\n      int rtn = 0;\n      if(y >= 0 && y < h && x >= 0 && x < w && qfield[y][x] && countedPoses.count(make_pair(y, x)) == 0) {\n        countedPoses.insert(make_pair(y, x));\n        int dy[] = {0, 1, 0, -1};\n        int dx[] = {1, 0, -1, 0};\n        for(int i = 0; i < 4; ++i) rtn += tileCount(y + dy[i], x + dx[i]);\n        ++rtn;\n      }\n      return rtn;\n    };\n    cout << tileCount(starty, startx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define all(v) (v).begin(),(v).end()\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint w,h,sx,sy,sum;\nchar mp[21][21];\n\nint dfs(int y,int x){\n  if(0<=y&&y<h&&0<=x&&x<w&&(mp[y][x]=='.'||mp[y][x]=='@')){\n    mp[y][x]='$';\n    sum++;\n    rep(i,4){\n      dfs(y+dy[i],x+dx[i]);\n    }\n  }\n  return sum;\n}\n\nsigned main(){\n \n  while(cin>>w>>h,w){\n    rep(i,h)rep(j,w){\n      cin>>mp[i][j];\n      if(mp[i][j]=='@'){\n        sy=i;sx=j;\n      }\n    }\n    sum=0;\n    cout<<dfs(sy,sx)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nint dfs(int sx ,int sy, vector<vector<bool> > &map){\n\tint t=0;\nif(map[sx][sy]){\n\tmap[sx][sy]=false;\n\tt++;\nfor(int i=0;i<4;i++){\nint x=sx+dx[i];\nint y=sy+dy[i];\nif(map[x][y])\tt+=dfs(x,y,map);\n}\n}\nreturn t;\n}\nint main(void){\nwhile(1){\nint h,w,sx,sy;\ncin>>w>>h;\nif(h==0)break;\nvector<vector<bool> > map(h+2,vector<bool>(w+2,false));\nfor(int i=1;i<=h;i++){\n\tfor(int j=1;j<=w;j++){\n\t\tchar a;\n\t\tcin>>a;\n\t\tif(a=='.')map[i][j]=true;\n\t\tif(a=='@'){\n\t\t\tmap[i][j]=true;\n\t\t\tsx=i;\n\t\t\tsy=j;\n\t\t}\n\t}\n}\n//cout<<sx<<' '<<sy<<endl;\n/*\nfor(int i=1;i<=h;i++){\n\tfor(int j=1;j<=w;j++)if(map[i][j])cout<<1;\n\telse cout<<0;\n\tcout<<endl;\n}*/\ncout<<dfs(sx,sy,map)<<endl;\n}\n\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\nstring a[21];\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\nint cnt, X, Y;\n\nvoid dfs(int y, int x){\n  if( y < 0 || Y <= y || x < 0 || X <= x || a[y][x] == '#') return;\n  a[y][x] = '#';\n  cnt++;\n  for(int i = 0; i < 4; i++)\n    dfs(y + dy[i], x + dx[i]);\n}\n\nint main(){\n  while(cin >> X >> Y, X != 0 || Y != 0) {\n    int sx = 21, sy;\n    for(int i = 0; i < Y; i++){\n      cin >> a[i];\n      if(sx == 21)\n\tfor(int j = 0; j < X; j++)\n\t  if(a[i][j] == '@') sy = i, sx = j;\n    }\n    cnt = 0;\n    dfs(sy, sx);\n    \n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstatic const int margin = 1;\nstatic const int board_size = 32;\n\nchar board[board_size][board_size];\nint W, H;\nint ans_accume;\n\nvoid init() {\n\tfor(int i = 0; i < board_size; i++) {\n\t\tfor(int j = 0; j < board_size; j++) {\n\t\t\tboard[i][j] = '#';\n\t\t}\n\t}\n\tans_accume = 0;\n}\n\nbool input() {\n\tcin >> W >> H;\n\tif(!W && !H)\n\t\treturn false;\n\tfor(int i = margin; i < H + margin; i++) {\n\t\tcin >> board[i] + margin;\n\t}\n\treturn true;\n}\n\n// (p.second, p.first)\nvoid solve(pair<int, int> p) {\n\tif(board[p.first][p.second + 1] == '.') {\n\t\tboard[p.first][p.second + 1] = 'x';\n\t\tans_accume++;\n\t\tsolve(pair<int, int>(p.first, p.second + 1));\n\t}\n\tif(board[p.first][p.second - 1] == '.') {\n\t\tboard[p.first][p.second - 1] = 'x';\n\t\tans_accume++;\n\t\tsolve(pair<int, int>(p.first, p.second - 1));\n\t}\n\tif(board[p.first + 1][p.second] == '.') {\n\t\tboard[p.first + 1][p.second] = 'x';\n\t\tans_accume++;\n\t\tsolve(pair<int, int>(p.first + 1, p.second));\n\t}\n\tif(board[p.first - 1][p.second] == '.') {\n\t\tboard[p.first - 1][p.second] = 'x';\n\t\tans_accume++;\n\t\tsolve(pair<int, int>(p.first - 1, p.second));\n\t}\n}\n\npair<int, int> search_start() {\n\tfor(int i = margin; i < H + margin; i++) {\n\t\tfor(int j = margin; j < W + margin; j++) {\n\t\t\tif(board[i][j] == '@') {\n\t\t\t\tans_accume++;\n\t\t\t\treturn pair<int, int>(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pair<int, int>(-1, -1);\n}\n\nint main(void) {\n\twhile(init(), input()) {\n\t\tsolve(search_start());\n\t\tcout << ans_accume << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> C[i];\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n\tint w, h, sx, sy;\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tvector<string> field = vector<string>(h);\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tauto visited = vector<vector<bool>>(h, vector<bool>(w, false));\n\t\tqueue<int> q = queue<int>();\n\t\tq.push(sy * 100 + sx);\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front() % 100, y = q.front() / 100;\n\t\t\tq.pop();\n\t\t\tif (visited[y][x]) continue;\n\t\t\tans++;\n\t\t\tvisited[y][x] = true;\n\t\t\tint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\t\tif (field[ny][nx] == '.' && !visited[ny][nx])\n\t\t\t\t\tq.push(ny * 100 + nx);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\n\nint x[100][100]={0};\nint count;\n\nvoid foo(int s,int t){\n\tif(x[s][t]==0){\n\t}\n\telse{\n\t\tcount++;\n\t\tx[s][t]=0;\n\t\tif(t-1>=0) foo(s,t-1);\n\t\tfoo(s,t+1);\n\t\tif(s-1>=0) foo(s-1,t);\n\t\tfoo(s+1,t);\n\t}\n}\n\t\nint main(){\n\n\tint w,h;\n\tint i,j;\n\tchar tmp;\n\tint pos1,pos2;\n\t\n\tcin>>w>>h;\n\twhile(!(w==0&&h==0)){\n\t\tmemset(x,0,sizeof(x));\n\t\tcount=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tcin>>tmp;\n\t\t\t//printf(\"%c\\n\",tmp);\n\t\t\tif(tmp=='.'){\n\t\t\t\tx[i][j]=1;\n\t\t\t}\n\t\t\telse if(tmp=='#'){\n\t\t\t\tx[i][j]=0;\n\t\t\t}\n\t\t\telse if(tmp=='@'){\n\t\t\t\tpos1=i;\n\t\t\t\tpos2=j;\n\t\t\t\tx[i][j]=1;\n\t\t\t\t//cout<<\"pos 1 2  \"<<pos1<<\" \"<<pos2<<endl;\n\t\t\t}\n\t\t}\n\t\t//cout<<endl;\n\t}\n\t\t//printf(\"hoge\");\n\t\t\n\t\t/*for(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcout<<x[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t\t*/\n\t\tfoo(pos1,pos2);\n\t\t//cout<<\"hoge\";\n\t\tcout<<count<<endl;\n\t\tcin>>w>>h;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\nint a[30][30];\nint h,w;\n\nvector<string> v;\n\nbool inside(int a, int b){\n\treturn 0<=a&&a<h&&0<=b&&b<w;\n}\n\n\nvoid dfs(pii p){\n\tint dd[]={0,1,0,-1,0};\n\tif(a[p.F][p.S]) return;\n\ta[p.F][p.S]=1;\n\trep(i,4){\n\t\tpii np=p;\n\t\tnp.F+=dd[i];\n\t\tnp.S+=dd[i+1];\n\t\tif(inside(np.F,np.S)){\n\t\t\tif(v[np.F][np.S]=='#') continue;\n\t\t\tdfs(np);\n\t\t}\n\t}\n}\n\nvoid mainmain(){\n\twhile(cin>>w>>h,w||h){\n\t\tv=vector<string>(h);\n\t\trep(i,h) cin>>v[i];\n\t\tpii p;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='@'){\n\t\t\t\t\tp=mkp(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,30) rep(j,30) a[i][j]=0;\n\t\tdfs(p);\n\t\tint ans = 0;\n\t\trep(i,30){\n\t\t\trep(j,30){\n\t\t\t\tans += a[i][j];\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = { 0, 0,-1, 1};\n\nvoid dfs(int x, int y) {\n    num++;\n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    for (int i = 0; i < 4; i++) {\n        int mx = x + dx[i];\n        int my = y + dy[i];\n        \n        if (mx < 0 || w <= mx) continue;\n        if (my < 0 || h <= my) continue;\n        if (room[my][mx] == 0) continue;\n        dfs(mx, my);\n    }\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nclass UF\n{\npublic:\n\tUF()\n\t{\n\t\tcount = 0;\n\t}\n\n\tvoid push(T a)\n\t{\n\t\tM[a] = count;\n\t\tV.push_back(count);\n\t\trank.push_back(0);\n\t\tcount++;\n\t}\n\n\tvoid unite(T a , T b)\n\t{\n\t\tlong long int x = find(M[a]);\n\t\tlong long int y = find(M[b]);\n\t\tif(x == y)return;\n\t\tif(rank[x] < rank[y])\n\t\t{\n\t\t\tV[x] = y;\n\t\t} else\n\t\t{\n\t\t\tV[y] = x;\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\tvoid merge(T a , T b)\n\t{\n\t\tunite(a , b);\n\t}\n\tbool same(T a , T b)\n\t{\n\t\treturn find(M[a]) == find(M[b]);\n\t}\n\tlong long int group()\n\t{\n\t\tset<long long int>S;\n\t\tfor(long long int i = 0; i < V.size(); i++)\n\t\t{\n\t\t\tS.insert(find(V[i]));\n\t\t}\n\t\treturn S.size();\n\t}\n\nprivate:\n\tvector<long long int> V , rank;\n\tmap < T , long long int>M;\n\tlong long int count;\n\n\tlong long int find(long long int x)\n\t{\n\t\tif(V[x] == x)return x;\n\t\telse return V[x] = find(V[x]);\n\t}\n};\n\nint main()\n{\n\tint W , H;\n\twhile(cin >> W >> H , W || H)\n\t{\n\t\tvector<vector<char>>VVC(H , vector<char>(W));\n\t\tUF<pair<int , int>>UFP;\n\t\tpair<int,int>at;\n\t\tfor(size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> VVC[i][j];\n\t\t\t\tUFP.push(make_pair(i , j));\n\t\t\t\tif(VVC[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tat=make_pair(i,j);\n\t\t\t\t}\n\t\t\t\tif(VVC[i][j] != '#')\n\t\t\t\t{\n\t\t\t\t\tif(i != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(VVC[i - 1][j] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUFP.merge(make_pair(i , j) , make_pair(i - 1 , j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(VVC[i][j - 1] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUFP.merge(make_pair(i , j) , make_pair(i , j - 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(size_t i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(size_t j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif(UFP.same(at,make_pair(i,j)))\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass P {\n\tpublic:\n\t\tint x;\n\t\tint y;\n\t\tP(int x, int y) :x(x),y(y) {}\n};\n\nchar map[20][20];\n\nint bfs(int W, int H) {\n\tqueue<P> q;\n\tbool ch[H][W];\n\tfor (int i=0; i<H; i++)\n\tfor (int j=0; j<W; j++)\n\t\tch[i][j] = false;\n\tfor (int i=0; i<H; i++)\n\tfor (int j=0; j<W; j++)\n\t\tif (map[i][j] == '@') {\n\t\t\tq.push(P(j,i));\n\t\t\tch[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\twhile(!q.empty()) {\n\t\tP c = q.front();\n\t\tq.pop();\n\t\tif (c.x+1<W && (!ch[c.y][c.x+1]) && map[c.y][c.x+1]=='.')\n\t\t{ q.push(P(c.x+1, c.y)); ch[c.y][c.x+1]=true; }\n\t\tif (c.y+1<H && (!ch[c.y+1][c.x]) && map[c.y+1][c.x]=='.')\n\t\t{ q.push(P(c.x, c.y+1)); ch[c.y+1][c.x]=true; }\n\t\tif (c.x-1>=0 && (!ch[c.y][c.x-1]) && map[c.y][c.x-1]=='.')\n\t\t{ q.push(P(c.x-1, c.y)); ch[c.y][c.x-1]=true; }\n\t\tif (c.y-1>=0 && (!ch[c.y-1][c.x]) && map[c.y-1][c.x]=='.')\n\t\t{ q.push(P(c.x, c.y-1)); ch[c.y-1][c.x]=true; }\n\t}\n\tint cnt = 0;\n\tfor (int i=0; i<H; i++)\n\tfor (int j=0; j<W; j++)\n\t\tif (ch[i][j]) cnt++;\n\treturn cnt;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, (n||m)) {\n\t\tfor (int i=0; i<m; i++)\n\t\tfor (int j=0; j<n; j++)\n\t\t\tcin >> map[i][j];\n\t\tint res = bfs(n, m);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 250; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2005à\\IB Red and Black\n\n#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main(){\n\tint w, h;\n\tstring b[20];\n\twhile(cin >> w >> h, w){\n\t\tfor(int i=0;i<h;i++) cin >> b[i];\n\t\tint sx, sy;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tif(b[i][j]=='@') sx = i, sy = j;\n\t\tqueue< pair<int, int> > qu; qu.push(make_pair(sx,sy));\n\t\tint res = 0;\n\t\twhile(!qu.empty()){\n\t\t\tpair<int, int> pr = qu.front(); qu.pop();\n\t\t\tint x = pr.first, y = pr.second;\n\t\t\tres++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\tif(nx<0||h<=nx||ny<0||w<=ny||b[nx][ny]!='.') continue;\n\t\t\t\tb[nx][ny] = '#';\n\t\t\t\tqu.push(make_pair(nx,ny));\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint w,h;\nchar tbl[30][30];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool visited[30][30];\nint ans;\n\nvoid dfs(int x,int y){\n  visited[y][x] = 1;\n  ++ans;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx>=w || my>=h || mx<0 || my<0) continue;\n    if(visited[my][mx] || tbl[my][mx]=='#') continue;\n    dfs(mx,my);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w||h){\n    memset(visited,0,sizeof(visited));\n    ans = 0;\n    for(int i=0;i<h;++i) cin >> tbl[i];\n    int sx=-1,sy=-1;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n\tif(tbl[i][j]=='@')\n\t  sy=i,sx=j;\n\n    dfs(sx,sy);\n    cout << ans << endl;\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct tile\n{\n    int row;\n    int col;\n    bool is_visited;\n    bool is_black;\n};\n\ntile start;\ntile map[20][20];\n\nint W, H;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nbool valid(int row, int col)\n{\n    return row >= 0 && row < H && col >= 0 && col < W;\n}\n\nint bfs(tile map[20][20])\n{\n    queue<tile> Q;\n    Q.push(start);\n    int ans = 0;\n\n    while (!Q.empty())\n    {\n        ans += 1;\n        tile src = Q.front();\n        Q.pop();\n\n        for (int i = 0; i < 4; i++)\n        {\n            int row = src.row + dx[i];\n            int col = src.col + dy[i];\n\n            // map の範囲外の場合\n            if (!valid(row, col))\n            {\n                continue;\n            }\n\n            if (map[row][col].is_black && !map[row][col].is_visited)\n            {\n                map[row][col].is_visited = 1;\n                Q.push(map[row][col]);\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main()\n{\n    while (cin >> W >> H && W)\n    {\n        // 入力\n        for (int row = 0; row < H; row++)\n        {\n            for (int col = 0; col < W; col++)\n            {\n                char c;\n                cin >> c;\n\n                if (c == '.')\n                {\n                    map[row][col] = {row, col, 0, 1};\n                }\n                else if (c == '@')\n                {\n                    map[row][col] = {row, col, 1, 1};\n                    start = map[row][col];\n                }\n                else\n                {\n                    map[row][col] = {row, col, 0, 0};\n                }\n            }\n        }\n\n        // BFS\n        cout << bfs(map) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col]!='#' && M[nc.row][nc.col]!='*' && M[nc.row][nc.col]!='@')\n\t{\n\t  M[nc.row][nc.col] = '*';\n\t  S.push(nc);\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm> \n#include<functional> \n#include<cassert>\n#include<numeric> // std::accumulate(vec.begin(),vec.end(),0) sum of element\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<map>\n#include<set>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef std::pair<int, int> P;\ntypedef vector<int> vi;\n\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define all(c) c.begin(),c.end()\n#define show(x) cout << #x << \" = \" << x << endl\n\n#define fi first\n#define se second\n#define pb push_back\n\n\n\n#define DEBUG\n\n\n// void print_vector(const std::vector<int> &t);\n// void unique_vector(std:: vector<int> &t);\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t);\ntemplate <class X>\nvoid unique_vector(std:: vector<X> &t);\n\n\nint w, h;\n\nvector<int> xl={-1, 0, 1, 0};\nvector<int> yl={0, 1, 0, -1};\n\nint main(){\n\n  vi ans;\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    vector<vector<char>> f(h, vector<char>(w));\n    queue<P> ser;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) {\n\tcin >> f[i][j];\n\tif(f[i][j] == '@')\n\t  ser.push(make_pair(i, j));\n      }\n    }\n    int c = 0;\n    while(!ser.empty()){\n      P t = ser.front();\n      ser.pop();\n      int y = t.fi, x = t.se;\n      // show(x); show(y);\n      if(f[y][x] == '@') f[y][x] = '#';\n      for(int i = 0; i < 4; i++) {\n\tint dx = x+xl[i], dy=y+yl[i];\n\t// cout << dx << ' ' << dy << endl;\n\t// show(dx); show(dy);\n\tif(dy < 0 || dy >= h || dx < 0 || dx >= w || f[dy][dx] == '#')\n\t  continue;\n\t\n\tif(f[dy][dx] == '.'){\n\t  c++;\n\t  ser.push(make_pair(dy, dx));\n\t  f[dy][dx] = '#';\n\t}\n      }\t\n      // for(int i = 0; i < h; i++) {\n      // \tfor(int j = 0; j < w; j++) {\n      // \t  cout << f[i][j] << ' ';\n      // \t}\n      // \tcout << endl;\n      // }\n      // cout << endl;\n    }\n    ans.pb(c+1);\n  }\n  for(auto &i : ans) cout << i << endl;\n}\n\ntemplate <class X>\nvoid unique_vector(std::vector<X> &t)\n{\n  std::sort(t.begin(), t.end());\n  t.erase( std::unique(t.begin(), t.end()), t.end() );\n}\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t){\n  for(auto itr=t.begin(); itr != t.end(); itr++){\n    std::cout << *itr;\n    if(itr != t.end()-1) std::cout << ' ';\n  }\n  std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\n\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> void preview(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\n\nconst int INF = 100000000;\nconst double PI = acos(-1.0), EPS = 1e-10;\n\nint main() {\n\tfor(int W, H; cin >> W >> H, W || H;) {\n\t\tvector<string> field(H);\n\t\trep(i,H) cin >> field[i];\n\t\t// First = y, Second = x;\n\t\tP s;\n\t\trep(y,H) rep(x,W) {\n\t\t\tif(field[y][x] == '@') {\n\t\t\t\ts.first = y;\n\t\t\t\ts.second = x;\n\t\t\t}\n\t\t}\n\n\t\tbool reach[20][20];\n\t\tmemset(reach, 0, sizeof reach);\n\n\t\tint ans = 1;\n\t\treach[s.first][s.second] = true;\n\n\t\tint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\n\t\tqueue<P> que;\n\t\tque.push(s);\n\t\twhile(!que.empty()) {\n\t\t\tP here = que.front();\n\t\t\tque.pop();\n\n\t\t\trep(i,4) {\n\t\t\t\tint ny = here.first + dy[i];\n\t\t\t\tint nx = here.second + dx[i];\n\t\t\t\tif(0 <= ny && ny < H && 0 <= nx && nx < W && field[ny][nx] == '.' && reach[ny][nx] == false) {\n\t\t\t\t\treach[ny][nx] = true;\n\t\t\t\t\tans++;\n\t\t\t\t\tque.push(mp(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N+1];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\tmemset(memo.0, sizeof(memo));\n\t//for (int i = 0; i < y; i++) {\n\t\t//for (int j = 0; j < x; j++) {\n\t\t\t//memo[i][j] = 0;\n\t//\t}\n\t//}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nlong long int N, M, K, Q, W, H, L, R;\nlong long int ans;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> W >> H;\n\twhile (H) {\n\t\tans = 0;\n\t\tstring s[30];\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> s[i];\n\t\t\ts[i] = '#' + s[i] + '#';\n\t\t}\n\t\tfor (int i = 0; i <= W + 1; i++) {\n\t\t\ts[0].push_back('#');\n\t\t\ts[H + 1].push_back('#');\n\t\t}\n\t\tint dir[5] = { 1,0,-1,0,1 };\n\t\tqueue<pair<int, int> >Q;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tQ.push({ i,j });\n\t\t\t\t\ts[i][j] = '#';\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\t//cout << \"hi\";\n\t\t\tint cy, cx;\n\t\t\tcy = Q.front().first;\n\t\t\tcx = Q.front().second;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (s[cy + dir[i]][cx + dir[i + 1]] == '.') {\n\t\t\t\t\ts[cy + dir[i]][cx + dir[i + 1]] = '#';\n\t\t\t\t\tans++;\n\t\t\t\t\tQ.push({ cy + dir[i] ,cx + dir[i + 1] });\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n\tint w, h, sx, sy;\n\twhile (cin >> w >> h , w != 0 || h != 0) {\n\t\tvector<string> field = vector<string>(h);\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tauto visited = vector<vector<bool>>(h, vector<bool>(w, false));\n\t\tqueue<int> q = queue<int>();\n\t\tq.push(sy * 100 + sx);\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front() % 100, y = q.front() / 100;\n\t\t\tq.pop();\n\t\t\tif (visited[y][x]) continue;\n\t\t\tans++;\n\t\t\tvisited[y][x] = true;\n\t\t\tint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\t\tif (field[ny][nx] == '.' && !visited[ny][nx])\n\t\t\t\t\tq.push(ny * 100 + nx);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n \n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nchar field[21][21];\nchar visit[21][21];\nint dx[]= {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint W, H;\nvoid dfs(int y, int x) {\n    visit[y][x] = 1;\n    rep(i, 4) {\n        int ny = y+dy[i];\n        int nx = x+dx[i];\n        if(field[ny][nx] == '.' && visit[ny][nx] == 0 &&\n               nx >= 0 && nx < W && ny >= 0 && ny < H) {\n            dfs(ny, nx);\n        }\n    }\n}\nint main(void){\n    while(cin >> W >> H && W) {\n        int y, x;\n        rep(i, H) rep(j, W){\n            cin >> field[i][j];\n            if(field[i][j] == '@') y = i, x = j;\n        }\n        memset(visit, 0, sizeof(visit));\n        dfs(y, x);\n        int ans = 0;\n        rep(i, H) rep(j, W){\n            ans += visit[i][j];\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n//#define int long long\n//#define _DEBUG\n#include <queue>\n#include <vector>\n#include <string>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pos;\nint const infty = -1, none = -9, dx[] = {1,-1,0,0}, dy[]={0,0,1,-1};\nint W, H;\nstring Map[23]; //Map[i][j]:i行j列目\nbool reached[23][23];\npos firstPos;\nqueue<pos> Q;\nint count_reached(){\n    int r = 0;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            if(reached[i][j]) r++;\n        }\n    }\n    return r;\n}\nbool valid(int x, int y){\n    return x>=0 && x<W && y>=0 && y<H && Map[y][x]!='#';\n}\nint solve(){\n    Q.push(firstPos);\n    reached[firstPos.second][firstPos.first] = true;\n    while(true){\n        auto top = Q.front(); Q.pop();\n        int x = top.first, y = top.second;\n        for(int d=0; d<4; d++){\n            if(valid(x+dx[d], y+dy[d]) && !reached[y+dy[d]][x+dx[d]]){\n                Q.push(make_pair(x+dx[d], y+dy[d]));\n                reached[y+dy[d]][x+dx[d]] = true;\n            }\n        }\n        if(Q.empty()) break;\n        //cout << x<<\",\"<<y<<\", \"<< Q.size()<<endl;\n    }\n    return count_reached();\n}\nsigned main(){    \n    while(cin >> W >> H && W > 0){\n        firstPos = make_pair(none, none);\n        for(int i=0; i<H; i++){\n            cin >> Map[i];\n            for(int j=0; j<W; j++){\n                if(Map[i][j] == '@') firstPos = make_pair(j, i);\n                reached[i][j] = false;\n            }\n        }\n        cout << solve() << endl;\n#ifdef _DEBUG\n        cout << firstPos.first<<firstPos.second<< endl;\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++)cout << Map[i][j];\n            cout << endl;\n        }\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                cout<<reached[i][j];\n            }\n            cout << endl;\n        }\n#endif\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    vs v(h);\n    int si, sj;\n    rep(i, h) {\n      cin >> v[i];\n      rep(j, v[i].size()) if (v[i][j] == '@') {\n        si = i;\n        sj = j;\n      }\n    }\n    queue<pii> q;\n    q.emplace(si, sj);\n    int c = 0;\n    while (q.size()) {\n      int i, j;\n      tie(i, j) = q.front();\n      q.pop();\n      if (i < 0 || j < 0 || i >= h || j >= w || v[i][j] == '#') continue;\n      c++;\n      v[i][j] = '#';\n      vi di = {0, 1, 0, -1}, dj = {1, 0, -1, 0};\n      rep(k, 4) q.emplace(i + di[k], j + dj[k]);\n    }\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define N 22\n\nusing namespace std;\n\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n/* ue migi shita hidari */\n\nvoid dfs(int f[N][N], int x, int y, int *count);\n\nint main(void)\n{\n\n\tint w,h;\n\n\tint f[N][N];\n\n\tchar c;\n\tint x,y;\n\n\n\tint count;\n\n\tint i1,i2;\n\n\twhile(1) {\n\n\t\t/* syoki */\n\t\tfor (i1=0;i1<N;i1++) {\n\t\t\tfor (i2=0;i2<N;i2++) {\n\t\t\t\tf[i1][i2] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* nyuryoku */\n\t\tcin >> w;\n\t\tcin >> h;\n\t\tif (w == 0 && h == 0) break;\n\n\t\tfor (i1=1;i1<=h;i1++) {\n\t\t\tfor (i2=1;i2<=w;i2++) {\n\n\t\t\t\tcin >> c;\n\n\t\t\t\tif (c == '.') {\n\t\t\t\t\tf[i1][i2] = 1;\n\t\t\t\t}\n\t\t\t\tif ( c == '@') {\n\t\t\t\t\tf[i1][i2] = 1;\n\t\t\t\t\tx = i2;\n\t\t\t\t\ty = i1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t/* print */\n\t\t/*\n\t\tfor (i1=0;i1<N;i1++) {\n\t\t\tfor (i2=0;i2<N;i2++) {\n\t\t\t\tcout << f[i1][i2] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tcout << x << \" \" << y << endl;\n\t\t*/\n\n\t\tcount = 1;\n\t\tdfs(f,x,y,&count);\n\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}\n\n\nvoid dfs(int f[N][N], int x, int y, int *count)\n{\n\tint i1;\n\n\tint xx,yy;\n\n\tf[y][x] = 0;\n\n\tfor (i1=0;i1<4;i1++) {\n\t\txx = x + dx[i1];\n\t\tyy = y + dy[i1];\n\n\t\tif ( f[yy][xx] == 1) {\n\n\t\t\t(*count)++;\n\t\t\tdfs(f,xx,yy,count);\n\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace\tstd;\nstatic int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nint h,w,r;\nstring s[20];\nvoid dfs(int y,int x){\n  r++;\n  s[y][x]='#';\n  for(int i=0;i<4;i++)\n      if(0<=y+dy[i]&&y+dy[i]<h&&0<=x+dx[i]&&x+dx[i]<w)\n\tif(s[y+dy[i]][x+dx[i]]=='.') dfs(y+dy[i],x+dx[i]);\n}\nint main(){\n\n  int y,x;\n  for(;cin>>w>>h;){\n  r=0;\n  for(int i=0;i<h;i++) cin>>s[i];\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(s[i][j]=='@') y=i,x=j;\n  dfs(y,x);\n  cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//?????????WA????????????\n//????????????????????£??????\n\nint W,H,f[21][21],ans[1000],cnt=0,sx,sy;\nstring s,t;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tif(f[x][y]==0)return;\n\tf[x][y]=0;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tt = s[j];\n\t\t\t\tif(t==\".\")f[j][i]=1;\n\t\t\t\tif(t==\"#\")f[j][i]=0;\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tf[j][i]=1;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\n\nint W,H;\n\nchar r[1000][1000];\n\nint sh,sw;\nint bnum=0;\n\nint c[1000][1000] = {};\n\n\n\n\nint solve(int i,int j){\n    int ans=0;\n\n    if(i <0 || H <= i || j < 0 || W <= j)\n        return 0;\n    if(r[i][j] == '#'){\n        return 0;\n    }\n\n    if(i-1>=0){\n        ans += solve(i-1,j);\n    }\n    \n    if(i+1 <H){\n        ans += solve(i+1,j);\n    }\n    if(j-1>=0){\n        ans += solve(i,j-1);\n    }\n    if(j+1 < W){\n        ans += solve(i,j+1);\n    }\n    return ans;\n}\n\n\nint main(){\n\n    while(1){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0) break;\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> r[i][j];\n                if(r[i][j] == '@'){\n                    sh = i;\n                    sw = j;\n                    r[i][j] = '.';\n                }\n            }\n        }\n        cout << solve(sh,sw) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint W, H;\nchar room[20][20];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint sx, sy;\n\nint dfs(int x, int y)\n{\n  room[y][x] = '#';\n  int cnt = 1;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < W && 0 <= ny && ny < H && room[ny][nx] != '#'){\n      cnt += dfs(nx, ny);\n    }\n  }\n  return cnt;\n}\n\nint main()\n{\n  while(cin >> W >> H, W || H){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> room[i][j];\n\tif(room[i][j] == '@') sx = j, sy = i;\n      }\n    }\n    cout << dfs(sx, sy) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\nint w, h;\nint dxy[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\nchar tiles[21][21];\nchar visited[21][21];\n\nvoid rec(int y, int x)\n{\n    visited[y][x] = 1;\n    \n    for (int i=0; i<4; i++)\n    {\n        int x1, y1;\n        x1 = x + dxy[i][0];\n        y1 = y + dxy[i][1];\n\n        if (tiles[y1][x1] == '.' && visited[y1][x1] ==0 && x1 >= 0 && x1 < w && y1 >= 0 && y1 < h)\n        {\n            \n            rec(y1, x1);\n        }\n    }\n}\n\nint main(void)\n{\n    while (scanf(\"%d %d\", &w, &h) && w && h)\n    {\n        \n\n        int  x0, y0;\n\n        \n\n        for (int i=0; i<h; i++)\n        {\n            for (int j=0; j<w; j++)\n            {\n                cin >> tiles[i][j];\n\n            }\n        }\n        for (int i=0; i<h; i++)\n        {\n            for (int j=0; j<w; j++)\n            {\n                if (tiles[i][j] == '@')\n                {\n                    y0=i;\n                    x0=j;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        rec(y0, x0);\n        //printf(\"%d %d\", x0, y0);\n        int cnt=0;\n        for (int i=0; i<h; i++)\n        {\n            for (int j=0; j<w; j++)\n            {\n                cnt += visited[i][j];\n            }\n        }\n        printf(\"%d\\n\", cnt);\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF=INT_MAX;\nconst int N=30;\n\n\nchar tiles[N][N];\nint W,H;\nint ans=0;\n\n\nvoid solve(int i, int j){\n  \n  tiles[i][j]='x';\n  ans++;\n\n  int di[4]={-1,0,1,0};\n  int dj[4]={0,-1,0,1};\n\n  for(int k=0;k<4;k++){\n    int ni=i+di[k],nj=j+dj[k];\n    if(0<=ni&&ni<H && 0<=nj&&nj<W)\n      if(tiles[ni][nj]=='.'){\n\tsolve(ni,nj);\n      }\n  }   \n  \n}\n\n\n\nint main(){\n\n  P start;\n\n  \n  while(1){\n\n    cin>>W>>H;\n    start = P(INF,INF);\n\n    if(W==0 && H==0) break;\n    ans=0;\n    \n    for(int i=0;i<H;i++){\n      cin>>tiles[i];\n      if(start.first==INF){\n\tfor(int j=0;j<W;j++)\n\t  if(tiles[i][j]=='@') start=P(i,j);\n      }\n    }\n    solve(start.first,start.second);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nint main () {\n    int W, H;\n    while (cin >> H >> W, W + H) {\n        vector<vector<char> > map(W + 2, vector<char>(H + 2, '#'));\n        int sx, sy;\n        REP (i, 1, W + 1) {\n            REP (j, 1, H + 1) {\n                cin >> map[i][j];\n                if (map[i][j] == '@') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        queue<pii> q;\n        q.push(make_pair(sx, sy));\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        vector<vector<bool> > check(W + 2, vector<bool>(H + 2, false));\n        while (q.size()) {\n            pii qq = q.front();\n            q.pop();\n            if (check[qq.second][qq.first]) continue;\n            check[qq.second][qq.first] = true;\n            REP (k, 0, 4) {\n                int xx = qq.first + dx[k];\n                int yy = qq.second + dy[k];\n                if (map[yy][xx] == '#') continue;\n                q.push(make_pair(xx, yy));\n            }\n        }\n        int ans = 0;\n        REP (i, 1, W + 1) REP (j, 1, H + 1) ans += check[i][j];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n */\n\n\n#include <iostream>\n#include <limits>\n\nconstexpr size_t MAX_HEIGHT = 20;\nconst char START_TILE = '@';\nconst char PASSABLE_TILE = '.';\nconst char PROHIBITED_TILE = '#';\nconst char PASSED_TILE = 'P';\n\nbool is_wall(std::string world[MAX_HEIGHT], size_t x, size_t y) {\n\tchar tile = world[y][x];\n\treturn tile == PROHIBITED_TILE || tile == PASSED_TILE;\n}\n\nbool valid(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\treturn x < width && y < height // x and y is unsigned\n\t\t   && !is_wall(world, x, y);\n}\n\nint walk(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\tif (!valid(world, width, height, x, y)) {\n\t\treturn 0; // ????????????????????\\?????????????£?or??¢?´¢??????\n\t}\n\tint total = 1; // ????????????????????\\?????????1?????¨??????????????????\n\tworld[y][x] = PASSED_TILE; // ??????????????¨????????????????????¨?????????????????????????????????\n\t// ?????????????????§??????????????????valid???????????????walk????????§\n\ttotal += walk(world, width, height, x - 1, y);\n\ttotal += walk(world, width, height, x + 1, y);\n\ttotal += walk(world, width, height, x, y - 1);\n\ttotal += walk(world, width, height, x, y + 1);\n\treturn total;\n}\n\nvoid process(size_t width, size_t height) {\n\tstd::string world[MAX_HEIGHT];\n\tsize_t x = std::numeric_limits<size_t>::max(), y = std::numeric_limits<size_t>::max();\n\tfor (size_t i = 0; i < height; ++i) {\n\t\tstd::cin >> world[i];\n\t\tsize_t start_index = world[i].find(START_TILE);\n\t\tif (start_index != std::string::npos) {\n\t\t\tx = start_index;\n\t\t\ty = i;\n\t\t}\n\t}\n\n\tstd::cout << walk(world, width, height, x, y);\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tprocess(width, height);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool b[21][21];\nint w,h,count=0;\n\nvoid dfs(int x, int y){\nb[y][x]=1;count++;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint nx,ny;\nfor(int i=0;i<4;i++){\n nx=dx[i]+x;\n ny=dy[i]+y;\nif(0<=nx&&nx<w&&0<=ny&&ny<h)\nif(b[ny][nx]==0)dfs(nx,ny);\n}\n}\n\nint main(){\nchar a[21][21];\nint sx,sy;\ncin>>w>>h;\n\nfor(int i=0;i<h;i++)\nfor(int j=0;j<w;j++){\ncin>>a[i][j];\nif(a[i][j]=='#')b[i][j]=1;\nif(a[i][j]=='@'){sx=j;sy=i;}\n}\ndfs(sx,sy);\ncout<<count<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nchar field[22][22];\nint cnt=0;\nvoid tansaku(int y,int x){\n\tif(field[y][x+1]=='.'){\n\t\tfield[y][x+1]='#';\n\t\tcnt++;\n\t\ttansaku(y,x+1);\n\t}\n\tif(field[y][x-1]=='.'){\n\t\tfield[y][x-1]='#';\n\t\tcnt++;\n\t\ttansaku(y,x-1);\n\t}\n\tif(field[y+1][x]=='.'){\n\t\tfield[y+1][x]='#';\n\t\tcnt++;\n\t\ttansaku(y+1,x);\n\t}\n\tif(field[y-1][x]=='.'){\n\t\tfield[y-1][x]='#';\n\t\tcnt++;\n\t\ttansaku(y-1,x);\n\t}\n}\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcnt=0;\n\t\tcin >> w >> h;\n\t\tif(!w&&!h)\tbreak;\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tscanf(\"%s\",(field[i]+1));\n\t\tfor(int i=0;i<=w+1;i++){\n\t\t\tfield[0][i]='#';\n\t\t\tfield[h+1][i]='#';\n\t\t}\n\t\tfor(int i=0;i<=h+1;i++){\n\t\t\tfield[i][0]='#';\n\t\t\tfield[i][w+1]='#';\n\t\t}\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tif(field[y][x]=='@'){\n\t\t\t\t\ttansaku(y,x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt+1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint H,W,count=0;\nchar **map;\nbool **isCount;\n\nbool valid(int x,int y)\n{\n    return x<=(W-1)&&x>=0&&y<=(H-1)&&y>=0;\n}\n\nvoid bfs(int x,int y)\n{\n    if(valid(x,y)&&map[y][x]!='#' && !isCount[y][x])\n    {\n        count++;\n        isCount[y][x]=true;\n        for(int i=0;i<4;i++)\n            bfs(x+dx[i],y+dy[i]);\n    }\n  /*int D[100];\n  for(int i=0;i<100;i++)\n    D[i]=-1;\n  queue<int>Q;\n  Q.push(src);\n  D[src]=0;\n  while(!Q.empty())\n    {\n      int cur=Q.front();\n      Q.pop();\n       for(int dst=0;dst<n;dst++)\n\t{\n\t  if(M[cur][dst]==1&&D[dst]==-1)\n\t    {\n\t      D[dst]=D[cur]+1;\n\t      Q.push(dst);\n\t    }\n    }\n    }\n    for(int i=0;i<n;i++)\n        cout<<i+1<<' '<<D[i]<<endl;\n        */\n}\n\n\n\nint main()\n{\n    int x,y;\n    cin>>W>>H;\n    while(W!=0&&H!=0)\n    {\n        isCount=new bool*[H];\n        map=new char*[H];\n        for(int i=0;i<H;i++)\n        {\n            isCount[i]=new bool[W];\n            map[i]=new char[W];\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n                isCount[i][j]=false;\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n            {\n                cin>>map[i][j];\n                if(map[i][j]=='@')\n                {\n                    x=j;\n                    y=i;\n                }\n            }\n        }\n        bfs(x,y);\n        cout << count << endl;\n        delete map;\n        delete isCount;\n        cin>>W>>H;\n        count=0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint w,h;\nstring s[100];\nint ans;\n\nvoid solve(int y,int x){\n  int dx[] = {0,0,1,-1};\n  int dy[] = {1,-1,0,0};\n\n  if(x < 0 || y < 0 || x == w || y == h) return;\n\n  if(s[y][x] == '#') return;\n\n  s[y][x] = '#';\n\n  ans++;\n\n  for(int i=0;i<4;i++) solve(y+dy[i],x+dx[i]);\n\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n    ans = 0;\n\n    for(int i=0;i<h;i++) cin >> s[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(s[i][j] == '@') solve(i,j);\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n\nusing namespace std;\ntypedef pair<int,int> pos;\n\nvoid sub(int x,int y,vector<string> &field,\n\t\tvector<pos> &next,int &count){\n\n\tif(x>=0 && x<field[0].size() &&\n\t\t\ty>=0 && y<field.size()\n\t\t\t&& field[y][x]=='.'){\n\t\t\t\tfield[y][x]='#';\n\t\t\t\tcount++;\n\t\t\t\tnext.push_back(make_pair(x,y));\n\t\t\t}\n}\n\nint solve(int px,int py,vector<string> field){\n\tint count=1;\n\tvector<pos> p;\n\tp.push_back(make_pair(px,py));\n\t\n\tfield[py][px]='#';\n\twhile(!p.empty()){\n\t\tvector<pos> next;\n\t\tfor(int i=0;i<p.size();i++){\n\t\t\tint x = p[i].first;\n\t\t\tint y = p[i].second;\n\t\t\tsub(x-1,y,field,next,count);\n\t\t\tsub(x,y-1,field,next,count);\n\t\t\tsub(x+1,y,field,next,count);\n\t\t\tsub(x,y+1,field,next,count);\n\t\t}\n\t\tp=next;\n\t}\n\treturn count;\n}\n\nint main(){\n\twhile(true){\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tif(sx==0 && sy==0)return 0;\n\t\tvector<string> field;\n\t\tint x,y;\n\t\tfor(int i=0;i<sy;i++){\n\t\t\tstring str;\n\t\t\tfor(int k=0;k<sx;k++){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c!='.' && c!='#' && c!='@'){cout <<\"error\"<<endl;}\n\t\t\t\tstr.push_back(c);\n\t\t\t\tif(c=='@'){\n\t\t\t\t\tx=k;\n\t\t\t\t\ty=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield.push_back(str);\n\t\t}\n\t\tcout << solve(x,y,field) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include <utility>\n#include <functional>\n//#include<>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n//#define int long long;\nsigned main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    int cnt{};\n    vector<string> v(h);\n    for(int i = 0; i < h; ++i){\n      cin >> v[i];\n    }\n    //initialize\n    pair<int, int> p;\n    queue<pair<int, int>> q;\t\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tif(v[i][j] == '@'){\n\t  p = make_pair(i,j);\n\t  q.push(p);\n\t}\n      }\n    }\n    while(!q.empty()){\n      pair<int, int> p;\n      p = q.front();\n      q.pop();\n\n      for(int k = 0; k < 4; ++k){\n\tint x = p.first + dx[k]; int y = p.second + dy[k];\n\tif(0 > x || h <= x || 0 > y || w <= y)continue;\n\tif('.' == v[x][y]){\n\t  v[x][y] = '@';\n\t  ++cnt;\n\t  q.push(make_pair(x, y));\n\t}\n      }\n    }\n    cout << cnt+1 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n/*int f(int x){\n\n  return x * x;\n}\n\nint g(int x){\n  if(x == 0) return 1;\n  return g(x-1) * x;\n}\n*/\n\nint H, W;\n\nvoid  solve(int Y, int X, vector<string> &vec,int &count){\n\n   if(Y<0||Y>=H||X<0||X>=W){\n    return;\n  }\n   else if(vec[Y][X]=='#'){\n    return;\n  }\n  count+=1;\n  vec[Y][X]='#';\n  solve(Y+1,X,vec, count);\n  solve(Y-1,X,vec,count);\n  solve(Y,X-1,vec,count);\n  solve(Y,X+1,vec,count);\n\n}\nint main(){\n  //vector<vector<int>>vec(N,vector<int>(N));\n\n  while(1){\n    // int W,H\n    int count;\n  cin >> W >>H;\n  if(W==0 &&H==0)break;\n  count=0;\n\n  vector<string>vec(H);\n  int x,y;\n\n  for(int i =0;i<H;i++){\n    cin >> vec.at(i);\n    for(int j=0;j<W;j++){\n      if(vec[i][j]=='@'){\n        x = j;\n        y = i;\n        break;\n      }\n           }\n  }\n  solve(y, x,  vec, count);\n  cout << count <<endl;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nchar board[20][20] = {};\nint W, H;\n\nint count(int x, int y) {\n\tif (board[x][y] == '#') return 0;\n\tif (x < 0 || W <= x) return 0;\n\tif (y < 0 || H <= y) return 0;\n\n\tboard[x][y] = '#';\n\n\treturn 1 +\n\t\tcount(x - 1, y) +\n\t\tcount(x + 1, y) +\n\t\tcount(x, y - 1) +\n\t\tcount(x, y + 1);\n}\n\nint main() {\n\twhile (true) {\n\n\t\tscanf(\"%d %d\", &W, &H);\n\n\t\tif (W == 0) break;\n\n\t\tint cx, cy;\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tchar buf[21];\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tboard[x][y] = buf[x];\n\t\t\t\tif (buf[x] == '@') {\n\t\t\t\t\tcx = x; cy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", count(cx, cy));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\ntypedef long long ll;\n\nint W, H;\nchar field[32][32];\nbool used[32][32];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y) {\n    used[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < H && 0 <= ny && ny < W && field[nx][ny] != '#' && used[nx][ny] == false) {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main(void) {\n    while (1) {\n        cin >> W >> H;\n        for (int i = 0; i < 32; i++)\n            for (int j = 0; j < 32; j++)\n                used[i][j] = false;\n        if (W == 0 && H == 0) break;\n        int sx, sy;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> field[i][j];\n                if (field[i][j] == '@') {\n                    sx = i; sy = j;\n                }\n            }\n        }\n        used[sx][sy] = true;\n        dfs(sx, sy);\n        int ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (used[i][j]) ret++;\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\nint W, H;\nstring s[20];\nint num;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nvoid dfs(int x, int y){\n  num++;\n  s[y][x] = '#';\n  for(int i=0; i<4; i++){\n    if(0<=x+dx[i] && x+dx[i]<W && 0<=y+dy[i] && y+dy[i]<H && s[y+dy[i]][x+dx[i]]=='.'){\n      dfs(x+dx[i], y+dy[i]);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W || H){\n    for(int i=0; i<H; i++){\n      cin >> s[i];\n    }\n    int x, y;\n    for(int i=0; i<H; i++){\n      for(int j=0; j<W; j++){\n\tif(s[i][j] == '@'){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n    num = 0;\n    dfs(x, y);\n    cout << num << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\n\nstruct pos{\n\tpos(int X,int Y){\n\t\tx=X,y=Y;\n\t}\n\tint x,y;\n};\n\nint move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tqueue<pos> dfs;\n\tdfs.push(pos(x,y));\n\twhile(!dfs.empty()){\n\t\tpos n=dfs.front();dfs.pop();\n\t\tx=n.x;\n\t\ty=n.y;\n\t\t////\n\t\tans++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\t\tmap[x+vec[i][0]][y+vec[i][1]]='#';\n\t\t\t\t\tdfs.push(pos(x+vec[i][0],y+vec[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/////\n\t}\n\t\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar map[114][514];\nint h, w, ans;\nvoid dfs(int i, int j) {\n\tans++;\n\tmap[i][j] = '#';\n\tif (map[i - 1][j] == '.')dfs(i - 1, j);\n\tif (map[i + 1][j] == '.')dfs(i + 1, j);\n\tif (map[i][j - 1] == '.')dfs(i, j - 1);\n\tif (map[i][j + 1] == '.')dfs(i, j + 1);\n\treturn;\n}\nint main() {\n\twhile (cin >> h >> w, h, w) {\n\t\tans = 0;\n\t\tint x, y;\n\t\tfor (int i = 0; i < 30; i++)for (int j = 0; j < 30; j++)map[i][j] = '#';\n\t\tfor (int i = 1; i <= w; i++)for (int j = 1; j <= h; j++) {\n\t\t\tcin >> map[i][j];\n\t\t\tif (map[i][j] == '@') { x = i; y = j; }\n\t\t}\n\t\tdfs(x, y);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  set<P> s;\n  while (q.size()) {\n    P p = q.front();\n    q.pop();\n    s.insert(p);\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        pair<set<P>::iterator, bool> r = s.insert(P(i, j));\n        if (r.second) q.push(*r.first);\n      }\n    }\n  }\n  return s.size();\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE][MAX_SIZE];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> f[i];\n      for (int j = 0; j < W; ++j) {\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\n\n//pair<int,int>;\n\nint W,H;\nvector<string> s(20);\nint nextX[] = {1,0,-1,0};\nint nextY[] = {0,1,0,-1};\nvector<vector<int>> count_map(20,vector<int>(20,0));\n\nbool range_check(int y,int x){\n  if(y<0||x<0||y>=H||x>=W){\n    return false;\n  }\n  return true;\n}\n\nvoid bfs(int y,int x){\n  if(!range_check(y,x)){\n    return;\n  }\n  //printf(\"%d %d\",y,x);\n  if(s[y][x]=='#'){\n    //printf(\"aaa\\n\");\n    return;\n  }\n  if(count_map[y][x]){\n    return;\n  }\n  count_map[y][x]=1;\n  queue<pair<int,int>> node;\n  for(int i=0;i<4;i++){\n    int ny = y+nextY[i],nx = x + nextX[i];\n    if(!range_check(ny,nx)){\n      continue;\n    }\n    if(s[ny][nx]=='.'){\n      node.emplace(ny,nx);\n    }\n  }\n  while(!node.empty()){\n    pair<int,int> yx = node.front();\n    node.pop();\n    bfs(yx.first,yx.second);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0&&H==0){\n      break;\n    }\n    for(int i=0;i<H;i++){\n      cin>>s[i];\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(s[i][j]=='@'){\n          bfs(i,j);\n        }\n      }\n    }\n    int ans=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        //printf(\"%3d\",count_map[i][j]);\n        if(count_map[i][j]){\n          ans++;\n          count_map[i][j]=0;\n        }\n      }\n      //cout<<endl;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint INF=1e9;\n\nint main(){\n\tint dx[4]={0,1,0,-1};\n    int dy[4]={1,0,-1,0};\n\n\tint w,h;\n\twhile(cin>>w>>h and w>0){\n\t\tqueue<pair<int,int>> q;\n\t    int sy,sx;\n\t\tchar c[h][w]; int d[h][w];\n\t\trep(i,h){\n\t        rep(j,w){\n\t            cin>>c[i][j]; d[i][j]=INF;\n\t\t\t\tif(c[i][j]=='@'){\n\t\t\t\t\tsy=i; sx=j;\n\t\t\t\t}\n\t        }\n\t    }\n\t\td[sy][sx]=0;\n\t    q.push(make_pair(sy,sx));\n\n\t\tint ans=1;\n\t\twhile(q.size()){\n\t        pair<int,int> p=q.front(); //キューの先頭を取り出す\n\t        q.pop(); //取り出したら削除\n\t        int prev=d[p.first][p.second]; //一手前の手数prev\n\t        rep(i,4){ //4方向探索\n\t            int cy=p.first+dy[i];\n\t            int cx=p.second+dx[i];\n\t            if(c[cy][cx]=='.' and d[cy][cx]==INF){ //通行可能かつ未到達\n\t\t\t\t\tif(0<=cy and cy<h){\n\t\t\t\t\t\tif(0<=cx and cx<w){\n\t\t\t\t\t\t\td[cy][cx]=prev+1;\n\t\t\t                q.push(make_pair(cy,cx));\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t            }\n\t        }\n\t    }\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nint dx[]={1,-1,0,0,1,-1,1,-1};\nint dy[]={0,0,1,-1,1,-1,-1,1};\n#define rep(i,a,b) for (int64_t i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define sz(s) (s).size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nint w,h,bx,by,sum=0;\nchar m[21][21];\n\nvoid dfs(int x,int y)\n{\n    if(m[y][x]=='#')return;\n    if(m[y][x]=='.'){sum++;m[y][x]='#';}\n    REP(i,4)\n    {\n        int xx=x+dx[i];\n        int yy=y+dy[i];\n        if(xx>=0&&xx<w&&yy>=0&&yy<h)dfs(xx,yy);\n    }\n}\n\nint main()\n{   \n    while(cin>>w>>h,w){\n    sum=0;\n    REP(i,h)REP(j,w)\n    {\n        cin>>m[i][j];\n        if(m[i][j]=='@'){bx=j;by=i;m[i][j]='.';}\n    }\n    dfs(bx,by);\n    cout<<sum<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n\nint w, h, cnt = 0;\n\nvoid solve( vector<vector<char>>& f, pair<int, int> mp ) {\n\n\tif( mp.F - 1 >= 0 && f[mp.S][mp.F - 1] == '.' ) {\n\t\tcnt++;\n\t\tf[mp.S][mp.F - 1] = '#';\n\t\tsolve( f, make_pair( mp.F - 1, mp.S ) );\n\t}\n\tif( mp.F + 1 < w && f[mp.S][mp.F + 1] == '.' ) {\n\t\tf[mp.S][mp.F + 1] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F + 1, mp.S ) );\n\t}\n\tif( mp.S - 1 >= 0 && f[mp.S - 1][mp.F] == '.' ) {\n\t\tf[mp.S - 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S - 1 ) );\n\t}\n\tif( mp.S + 1 < h && f[mp.S + 1][mp.F] == '.' ) {\n\t\tf[mp.S + 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S + 1 ) );\n\t}\n}\n\nint main() {\n\n\twhile( 1 ) {\n\t\tcin >> w >> h; if( w == 0 && h == 0 ) break;\n\t\t\n\t\tpair<int, int> mp;\n\t\tvector<vector<char>> f;\n\t\tvector<char> tmp( w );\n\t\tREP( i, h ) {\n\t\t\tREP( j, w ) {\n\t\t\t\tcin >> tmp[j];\n\t\t\t\tif( tmp[j] == '@' ) { \n\t\t\t\t\tmp.first = j;\n\t\t\t\t\tmp.second = i; \n\t\t\t\t\ttmp[j] = '#';\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.push_back( tmp );\n\t\t}\n\t\tsolve( f, mp );\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dh[4] = { 1,0,-1,0 };\nint dw[4] = { 0,1,0,-1 };\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\twhile (1) {\n\t\tint H, W; scanf(\"%d %d\", &W, &H);\n\t\tif (H == 0 && W == 0) break;\n\t\tvector<string> vs(H); for (ll i = 0; i < H; i++) cin >> vs[i];\n\t\tint sh, sw;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (vs[i][j] == '@') {\n\t\t\t\t\tsh = i;\n\t\t\t\t\tsw = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>> q;\n\t\tq.emplace(sh, sw);\n\t\tvs[sh][sw] = '#';\n\t\tint res = 1;\n\t\twhile (!q.empty()) {\n\t\t\tint h, w; tie(h, w) = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nh = h + dh[i];\n\t\t\t\tint nw = w + dw[i];\n\t\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\t\tif (vs[nh][nw] == '#') continue;\n\t\t\t\tres++;\n\t\t\t\tvs[nh][nw] = '#';\n\t\t\t\tq.emplace(nh, nw);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint w, h;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint dfs(vector<string>& mp, int x, int y){\n  int cnt = 0;  \n  for(int i=0;i<4;++i){\n\tint tx = x + dx[i];\n\tint ty = y + dy[i];\n\tif(tx < 0 || w <= tx || ty < 0 || h <= ty) continue;\n\tif(mp[ty][tx] == '#') continue;\n\tmp[ty][tx] = '#';\n\tcnt += dfs(mp, tx, ty) + 1;\n  }\n  return cnt;\n}\n\nint main(){\n  while(true){\n\tif(!(cin >> w >> h)) return 0;\n\tif(w == 0 && h == 0) break;\n\tvector<string> vs(h);\n\tfor(int i=0;i<h;++i)\n\t  cin >> vs[i];\n\tint x, y;\n\tfor(int i=0;i<h;++i)\n\t  for(int j=0;j<w;++j)\n\t\tif(vs[i][j] == '@') x=j, y=i;\n\tvs[y][x] = '.';\n\tcout << dfs(vs,x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint tile(int i,int j);\nchar memo[22][22];\nint w,h;\nint ii,jj;\n\nint main(){\n  while(1){\n    cin >> w >> h;\n    if(w==0&&h==0)break;\n    for(int i=0;i<h;i++){\n      cin >> memo[i];\n      for(int j=0;j<w;j++){\n\tif(memo[i][j]=='@'){\n\t  ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    int c=tile(ii,jj);\n    cout << c << endl;\n  }\n}\n\nint tile(int i,int j){\n  if(i>=h||j>=w||i<0||j<0)return 0;\n  if(memo[i][j]=='#') return 0;\n  memo[i][j]='#';\n  int ret=0;\n  ret+=tile(i,j-1);\n  ret+=tile(i,j+1);\n  ret+=tile(i-1,j);\n  ret+=tile(i+1,j);\n  return ret+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint solve(bool visited[20][20],vector<string> v,int x,int y,int w,int h){\n\tif(x<0||y<0||w<=x||h<=y) return 0;\n\tif(visited[y][x]==true||v[y][x]=='#') return 0;\n\tint sum=1;\n\tvisited[y][x]=true;\n\tsum+=solve(visited,v,x+1,y,w,h);\n\tsum+=solve(visited,v,x,y+1,w,h);\n\tsum+=solve(visited,v,x-1,y,w,h);\n\tsum+=solve(visited,v,x,y-1,w,h);\n\treturn sum;\n}\nint main(void){\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\tvector<string> v;\n\t\tbool visited[20][20];\n\t\tfor(int i=0;i<20;++i) for(int j=0;j<20;++j)visited[i][j]=false;\n\t\tint x,y;\n\t\tfor(int i=0;i<h;++i){\n\t\t\tstring s;cin>>s;\n\t\t\tif(s.find(\"@\")!=-1){x=s.find(\"@\");y=i;}\n\t\t\tv.push_back(s);\n\t\t}\n\t\tcout<<solve(visited,v,x,y,w,h)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n ; i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x) // decltypeで型取得、引数があればva_argsのところに入れる\nusing namespace std;\ntypedef long long ll; // long longをllでかけるようにした\nconst int INF = 1e9;\nint n, m, ans = 0;\nchar W[100][100];\n\n// 通れるようなマスがいくつあるか知りたい\nvoid dfs(int y, int x){\n    W[y][x] = '#';\n    for(int dx = -1; dx <= 1; dx++){\n        for(int dy = -1; dy <= 1; dy++){\n            if(dx == dy and dx != 0 and dy != 0) continue;\n            else if(dx == -dy) continue;\n            int nx = dx + x;\n            int ny = dy + y;\n            if(W[ny][nx] == '.' and 0 <= nx and nx < n and 0 <= ny and ny < m){\n                dfs(ny, nx);\n                ans++;\n            }\n        }\n    }\n    return ;\n}\n\nint main(void){\n    while(true){\n        ans = 0; // 新しいデータセットの度に初期化\n        cin >> n >> m;\n        if(n == 0 and m == 0) return 0;\n        REP(i, m){\n            REP(j, n){\n                cin >> W[i][j];\n            }\n        }\n\n        REP(i, m){\n            REP(j, n){\n                if(W[i][j] == '@'){\n                    ans++;\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<cctype>\n\n#define mp make_pair\n#define pb push_back\n#define REP(i,a,n) for(int i = a;i < (n);i++)\n#define rep(i,n) for(int i = 0;i < (n);i++)\n#define all(s) s.begin(), s.end()\n#define rall(s) s.rbegin(), s.rend()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VII;\ntypedef pair<int,int> PII;\n\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\nint W,H;\nvector<string> room;\n\nint dfs(int y,int x){\n\tint res = 0;\n\trep(i,4){\n\t\tif(y + DY[i] < 0 || y + DY[i] >= H || x + DX[i] < 0 || x + DX[i] >= W || room[y + DY[i]][x + DX[i]] == '#') continue;\n\t\troom[y + DY[i]][x + DX[i]] = '#';\n\t\tres++;\n\t\tres += dfs(y + DY[i],x + DX[i]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\n\tint sy,sx,ans;\n\n\twhile(1){\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0) break;\n\t\troom.resize(H);\n\n\t\trep(i,H){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\troom[i] = s;\n\t\t}\n\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(room[i][j] == '@'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = dfs(sy,sx);\n\n\t\tcout << ans + 1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repi(i,a,b) for(int i=int(a);i<(b);i++)\n#define all(x) x.begin(),x.end()\n\nconst ll mod = 1e9+7;\nconst ll INF = 1e9;\n\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nbool valid(int lx,int ux,int ly,int uy,int x,int y){\n\treturn (lx<=x&&x<ux&&ly<=y&&y<uy);\n}\n\nint main()\n{\n\tint w,h;\n\twhile(cin>>w>>h,w!=0&&h!=0){\n\t\tvector<string> s(h);\n\t\trep(i,h)cin>>s[i];\n\n\t\tqueue<P> que;\n\t\trep(i,h)rep(j,w)if(s[i][j]=='@')s[i][j]='x',que.push(P(i,j));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();que.pop();\n\t\t\tint y=p.first,x=p.second;\n\t\t\trep(i,4){\n\t\t\t\tif(valid(0,w,0,h,x+dx[i],y+dy[i])){\n\t\t\t\t\tif(s[y+dy[i]][x+dx[i]]=='.'){\n\t\t\t\t\t\ts[y+dy[i]][x+dx[i]]='x';\n\t\t\t\t\t\tque.push(P(y+dy[i],x+dx[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,h)rep(j,w)if(s[i][j]=='x')ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\nint mapToNum(char c)\n{\n\tswitch (c) {\n\tcase '#':\n\t\t\treturn -1;\n\tcase '.':\n\t\t\treturn 0;\n\tcase '@':\n\t\t\treturn 1;\n\tdefault:\n\t\t\treturn -2;\n\t}\n}\n\nint main()\n{\n\twhile (1) {\n\t\tint w, h;\n\t\t\n\t\tcin >> w >> h;\n\t\t\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tstack< pair<int, int> > stk;\n\t\tvector< vector<int> > tiles(h + 2, vector<int>(w + 2));\n\t\tchar c;\n\t\t\n\t\tfor (int i = 0; i < w + 2; ++i) tiles.at(0).at(i) = tiles.at(h + 1).at(i) = -1;\n\t\t\n\t\tfor (int i = 1; i < h + 1; ++i) {\n\t\t\ttiles.at(i).at(0) = tiles.at(i).at(w + 1) = -1;\n\t\t\tfor (int j = 1; j < w + 1; ++j) {\n\t\t\t\tcin >> c;\n\t\t\t\ttiles.at(i).at(j) = mapToNum(c);\n\t\t\t\tif (c == '@') stk.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint num = 1;\n\t\t\n\t\twhile (!stk.empty()) {\n\t\t\tpair<int, int> p = stk.top();\n\t\t\tstk.pop();\n\t\t\tint x = 1, y = 0, t;\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (tiles.at(p.first + x).at(p.second + y) == 0) {\n\t\t\t\t\ttiles.at(p.first + x).at(p.second + y) = -1;\n\t\t\t\t\tstk.push(make_pair(p.first + x, p.second + y));\n\t\t\t\t\t++num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tt = -y;\n\t\t\t\ty = x;\n\t\t\t\tx = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << num << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nsigned main() {\n    int h, w;\n    while(cin >> w >> h, h || w) {\n        char board[30][30];\n        bool visit[30][30] = {};\n        pii st;\n        rep(i,0,h) rep(j,0,w) {\n            cin >> board[i][j];\n            if(board[i][j] == '@') {\n                st = pii(i, j);\n                visit[i][j] = true;\n            }\n        }\n\n        int ans = 0;\n        queue<pii> q;\n        q.push(st);\n        while(!q.empty()) {\n            pii t = q.front(); q.pop();\n            ans++;\n            rep(i,0,4) {\n                int x = t.fr + dx[i];\n                int y = t.sc + dy[i];\n                if(x < 0 || x >= h || y < 0 || y >= w) continue;\n                if(board[x][y] == '#') continue;\n                if(visit[x][y]) continue;\n                visit[x][y] = true;\n                q.push(pii(x, y));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[4] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> C[i];\n\t\t}\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n\nusing namespace std;\n#define NINF -999999\ntypedef pair<int, int> P;\nint field[21][21];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid solve()\n{\n\tint W, H;\n\twhile(cin >> W >> H)\n\t{\n\t\tif(!W && !H)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tstring tile[21];\n\t\tfor(int i = 0; i < H; ++i)\n\t\t{\n\t\t\tcin >> tile[i];\n\t\t}\n\t\tqueue<P> Que;\n\t\tfor(int i = 0; i < H; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < W; ++j)\n\t\t\t{\n\t\t\t\tif(tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t\tQue.push(p);\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfield[i][j] = NINF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 1;\n\t\tqueue<P> NextQue;\n\t\twhile(!Que.empty())\n\t\t{\n\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tP p;\n\t\t\t\tp.first = Que.front().first + dy[i];\n\t\t\t\tp.second = Que.front().second + dx[i];\n\t\t\t\t\n\t\t\t\tif(p.first < 0 || p.first >= H || p.second < 0 || p.second >= W)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if((tile[p.first][p.second] != '#') && (field[p.first][p.second] == NINF))\n\t\t\t\t{\n\t\t\t\t\tfield[p.first][p.second] = field[Que.front().first][Que.front().second] + 1;\n\t\t\t\t\tNextQue.push(p);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tQue.pop();\n\t\t\tif(Que.empty())\n\t\t\t{\n\t\t\t\twhile(!NextQue.empty())\n\t\t\t\t{\n\t\t\t\t\tQue.push(NextQue.front());\n\t\t\t\t\tNextQue.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n\nint w,h,ans,dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nchar c[22][22];\n\nvoid dfs(int y,int x){\n\tans++;\n\tc[y][x]='#';\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(c[ny][nx]=='-')dfs(ny,nx);\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\tans=0;\n\t\tint y,x;\n\t\trep2(i,1,h+1)rep2(j,1,w+1){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='@')y=i,x=j;\n\t\t}\n\t\tdfs(y,x);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n//#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tscanf(\"%s\", C[i]);\n\t\t}\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(v, a, b) for(int v = (int)(a); v < (int)(b); ++v)\n#define FORE(v, a, b) for(int v = (int)(a); v <= (int)(b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define RS resize\n#define CLR clear\n#define PB push_back\n#define ALL(x) (x).begin(), (x).end()\n#define C complex\n#define CI complex< int >\n#define CD complex< double >\nusing namespace std;\n\nvoid split(string str, char chr, vector< string > *res){\n\tstringstream ss(str);\n\tstring itm;\n\twhile(getline(ss, itm, chr)){\n\t\t(*res).PB(itm);\n\t}\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint w, h, x, y, cnt;\n\tvector< vector< char > > field;\n\tstack< CI > st;\n\t\n\twhile(cin >> w >> h , w){\n\t\tfield.RS(h);\n\t\tREP(i, h){\n\t\t\tfield[i].RS(w);\n\t\t\tREP(j, w){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tst.push(CI(x, y));\n\t\tcnt = 0;\n\t\t\n\t\twhile(!st.empty()){\n\t\t\tcomplex< int > cur = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tif(field[cur.imag()][cur.real()] != '.') continue;\n\t\t\t\n\t\t\tfield[cur.imag()][cur.real()] = '#';\n\t\t\t++cnt;\n\t\t\t\n\t\t\tif(cur.imag() > 0){\n\t\t\t\tif(field[cur.imag() - 1][cur.real()] == '.'){\n\t\t\t\t\tst.push(cur + CI(0, -1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cur.imag() < h - 1){\n\t\t\t\tif(field[cur.imag() + 1][cur.real()] == '.'){\n\t\t\t\t\tst.push(cur + CI(0, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cur.real() > 0){\n\t\t\t\tif(field[cur.imag()][cur.real() - 1] == '.'){\n\t\t\t\t\tst.push(cur + CI(-1, 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cur.real() < w - 1){\n\t\t\t\tif(field[cur.imag()][cur.real() + 1] == '.'){\n\t\t\t\t\tst.push(cur + CI(1, 0));\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tcout << cnt << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  int vx[4]={1,0,-1,0};\n  int vy[4]={0,-1,0,1};\n  while(cin>>w>>h,h+w){\n    string str[h];\n    for(int i=0;i<h;i++)cin>>str[i];\n    bool Map[h][w];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tMap[i][j]=false;\n    queue<pair<int,int> >que;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(str[i][j]=='@'){\n\t  que.push(mp(i,j));\n\t  Map[i][j]=true;\n\t}\n      }\n    }\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      for(int i=0;i<4;i++){\n\tif(now.F+vy[i]>=0&&now.S+vy[i]<w&&now.F+vx[i]>=0&&now.F+vx[i]<h&&(!Map[now.F+vx[i]][now.S+vy[i]])&&str[now.F+vx[i]][now.S+vy[i]]=='.'){\n\t  Map[now.F+vx[i]][now.S+vy[i]]=true;\n\t  que.push(mp(now.F+vx[i],now.S+vy[i]));\n\t}\n      }\n    }\n    ll ans=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(Map[i][j])\n\t  ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define PI 4*atan(1)\n#define INF 1e8\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint W, H;\n\nint ans = 0;\n\nvoid bfs(int x, int y, vector<vector<int>> &M){\n  M[x][y] = INF;\n  ans++;\n\n  for(int i = 0; i < 4; i++){\n    for(int j = 0; j < 4; j++){\n      if(dx[i] == 0 || dy[j] == 0){\n        int nx = x + dx[i], ny = y + dy[j];\n        if(0 <= nx && nx < H && 0 <= ny && ny < W && M[nx][ny] == -1)bfs(nx, ny, M);\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n  while(cin >> W >> H, W||H){\n    ans = 0;\n    vector<string> S(H);\n    vector<vector<int>> M(H, vector<int>(W, -1));\n    for(int i = 0; i < H; i++){\n      cin >> S[i];\n    }\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(S[i][j] == '#')M[i][j] = INF;\n      }\n    }\n\n    pair<int, int> start;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(S[i][j] == '@'){\n          start.first = i; start.second = j;\n        }\n      }\n    }\n    bfs(start.first, start.second, M);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n\n//探索関数\n//引数の座標が移動可能なら1を足し、上下左右を再探索。\n//同じ地点をカウントしないよう、一度カウントした座標はtに置き換える。\nint tansaku(char tile[20][20],int w1,int h1){\n    if(tile[w1][h1]!='.'&&tile[w1][h1]!='@')return 0;\n    tile[w1][h1]='t';\n    return 1+tansaku(tile,w1+1,h1)+tansaku(tile,w1-1,h1)+tansaku(tile,w1,h1+1)+tansaku(tile,w1,h1-1);\n}\n\nint main(){\n    int w,h;\n    int w1,h1; //スタート地点 @ の座標\n   while(1){\n    std::cin >> w;\n    std::cin >> h;\n    if(w==0&&h==0)break;\n    //配列の初期化\n    char tile[20][20]={};\n    // 配列を取得.\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            std::cin >> tile[j][i];\n            if(tile[j][i]=='@'){\n                w1=j; h1=i;\n            }\n        }\n    }\n    std::cout << tansaku(tile,w1,h1) << std::endl;\n   }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <time.h>\n#define all(c) ((c).begin(),(c).end())\n#define rall(c) (c).rbegin(),(c).rend()\n#define sort(v,n) sort(v,v+n)\n#define vsort(v) sort(v.begin(),v.end())\n#define vvsort(v) sort(v.begin(),v.end(),greater<int>())\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\n#define inf 999999999\nusing namespace std;\nconst ll MOD = 1e9 + 7;\nconst double PI = acos(-1.0);\n//---------------------------------------------------------------------------------------------//\nint w, h;\nchar a[21][21];\n\nint bfs(int sh,int sw) {\n\t//cout<<\"--------------------------------------------\"<<endl;\n\tint ans = 1;\n\tqueue<pair<int,int> > q;\n\tq.push(pair<int,int>(sh, sw));\n\twhile (!q.empty())\n\t{\n\t\t//for (int i = 0; i < h; i++) {\n\t\t\t//for (int j = 0; j < w; j++) {\n\t\t\t\t//cout << a[i][j] << \" \";\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t//}\n\n\t\t//cout << ans << endl;\n\t\tint nowx, nowy;\n\t\tnowy = q.front().first;\n\t\tnowx = q.front().second;\n\t\t//cout << nowy << \" \" << nowx << endl;\n\t\tq.pop();\n\t\tif (a[nowy][nowx + 1] == '.' && nowx<w-1) {\n\t\t\tq.push(pair<int,int>(nowy, nowx + 1));\n\t\t\ta[nowy][nowx + 1] = '#';\n\t\t\tans++;\n\t\t}\n\t\tif (a[nowy][nowx - 1]=='.' && nowx>0) {\n\t\t\tq.push(pair<int,int>(nowy, nowx - 1));\n\t\t\ta[nowy][nowx - 1] = '#';\n\t\t\tans++;\n\t\t}\n\t\tif (a[nowy + 1][nowx] == '.' && nowy<h-1) {\n\t\t\tq.push(pair<int,int>(nowy + 1, nowx));\n\t\t\ta[nowy + 1][nowx] = '#';\n\t\t\tans++;\n\t\t}\n\t\tif (a[nowy - 1][nowx] == '.' && nowy>0) {\n\t\t\tq.push(pair<int,int>(nowy - 1, nowx));\n\t\t\ta[nowy - 1][nowx] = '#';\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tint sw, sh;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == '@') {\n\t\t\t\t\tsw = j;\n\t\t\t\t\tsh = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(sh, sw) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<math.h>\n\nusing namespace::std;\n\nchar gMap[21][21];\nbool MapFlg[21][21];\nint gRedCount;\nvoid initMap(void)\n{\n  for(int i = 0; i < 21; i++)\n    {\n      for(int j = 0; j < 21; j++)\n\t{\n\t  gMap[i][j] = '#';\n\t  MapFlg[i][j] = false;\n\t}\n    }\n  gRedCount = 0;\n}\n\nvoid showMap(void)\n{\n  for(int i = 0; i < 21; i++)\n    {\n      for(int j = 0; j < 21; j++)\n\t{\n\t  cout << gMap[i][j];\n\t}\n      cout << endl;\n    } \n}\n\nint countMap(int x , int y)\n{\n  int dx[] = { 0  , 1 , -1 , 0 };\n  int dy[] = { -1 , 0 ,  0 , 1 };\n\n  for(int i = 0; i < 4; i++)\n    {\n      int mx = x + dx[i];\n      int my = y + dy[i];\n\n      if( gMap[my][mx] != '@' && gMap[my][mx] != '#' && MapFlg[my][mx] == false)\n\t{\n\t  gRedCount++;\n\t  MapFlg[my][mx] = true;\n\t  countMap(mx , my);\n\t}\n    }\n\n  return gRedCount;\n\n}\n\nvoid calcAns(int sx, int sy)\n{\n  cout << countMap(sx,sy) + 1 << endl;\n}\n\nint main(void)\n{\n\n  int w,h;\n\n  while( cin >> w >> h  && (w != 0 && h != 0))\n    {\n      int sx,sy;\n      initMap();\n      for(int i = 1; i <= h; i++)\n\t{\n\t  for(int j = 1; j <= w; j++)\n\t    {\n\t      cin >> gMap[i][j];\n\t      if( gMap[i][j] == '@')\n\t\t{\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t}\n\t    }\n\t}\n      calcAns(sx,sy);\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\nint w,h;\nstring matrix[20];\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nbool valid(int x,int y)\n{\n    return (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(matrix[y][x]!='#');\n}\nint main()\n{\n    while(true)\n    {\n        queue<pair<int,int> > q;\n        pair<int,int> man;\n        int amount=1;\n        \n        cin>>w>>h;\n        if(w==0&&h==0)\n            break;\n        for(int i=0;i<h;i++)\n        {\n            cin>>matrix[i];\n            cout<<matrix[i]<<endl;\n        }\n        \n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {\n                if(matrix[i][j]=='@')\n                {\n                    man.first=j;\n                    man.second=i;\n                }\n            }\n        }\n        \n        q.push(man);\n        while(!q.empty())\n        {\n            pair<int,int> current;\n            current=q.front();\n            q.pop();\n            \n            for(int i=0;i<4;i++)\n            {\n\n                if(valid(current.first+dx[i],current.second+dy[i]))\n                {\n                    q.push(make_pair(current.first+dx[i],current.second+dy[i]));\n                    matrix[current.second+dy[i]][current.first+dx[i]]='#';\n                    amount++;\n                    //cout<<current.first+dx[i]<<\",\"<<current.second+dy[i]<<endl;\n                }\n            }\n            \n            matrix[current.second][current.first]='#';\n        }\n        \n        cout<<amount<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint w,h;\nchar fie[21][21];\n\nvoid dfs(int x, int y){\n    for(int i=0; i<4; i++){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(0 <= xx && xx < w && 0 <= yy && yy < h && fie[yy][xx] == '.'){\n            fie[yy][xx] = '@';\n            dfs(xx,yy);\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h , w||h){\n        int sx,sy;\n        for(int i=0; i<h; i++){\n            cin >> fie[i];\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        dfs(sx,sy);\n        int ans = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@') ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// debug\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x)                                         \\\n  cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" \\\n       << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef complex<long double> Complex;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n// constant\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\n//\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n//\n\nint sx, sy;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int w, h;\n\n  while (1) {\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    char tile[22][22];\n    queue<pair<int, int>> que;\n    rep(y, h) {\n      rep(x, w) {\n        cin >> tile[y][x];\n        if (tile[y][x] == '@') {\n          que.push(make_pair(x, y));\n        }\n      }\n    }\n\n    int ans = 0;\n\n    while (!que.empty()) {\n      pair<int, int> p = que.front();\n      que.pop();\n\n      rep(i, 4) {\n        int nx = p.first + dx[i];\n        int ny = p.second + dy[i];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && tile[ny][nx] == '.') {\n          ans++;\n          tile[ny][nx] = '#';\n          que.push(make_pair(nx, ny));\n        }\n      }\n    }\n\n    cout << ans + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\n  if(a[y-1][x]=='.')dfs(y-1,x);\n  if(a[y+1][x]=='.')dfs(y+1,x);\n  if(a[y][x-1]=='.')dfs(y,x-1);\n  if(a[y][x+1]=='.')dfs(y,x+1);\n  return;\n}\nint main(){\n  int w,h,i,j;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%c\",&a[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n//ranker\nusing namespace std;\n\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing pis = pair<int, string>;\nusing psi = pair<string, int>;\nusing D = double;\n\nvoid merge (int *first1, int *last1, int *first2, int *last2){\n    int size1 = last1 - first1;\n    int size2 = last2 - first2;\n    int *result = new int[size1+size2];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    while (true){\n        if (i < size1 && (first1[i] <= first2[j] || j >= size2)){\n            result[index] = first1[i];\n            ++i; ++index;\n        }\n        if (j < size2 && (first1[i] > first2[j] || i >= size1)){\n            result[index] = first2[j];\n            ++j; ++index;\n        }\n        if (i==size1 && j==size2){\n            for (i=0; i<size1; ++i) first1[i] = result[i];\n            for (j=0; j<size2; ++j) first2[j] = result[j+size1];\n            delete[] result;\n            return;\n        }\n    }\n}\nvoid MergeSort (int *first, int *last){\n    int size = last - first;\n    if(size <= 1) return;\n    MergeSort(first, first+size/2);\n    MergeSort(first+size/2, last);\n    merge(first, first+size/2, first+size/2, last);\n}\n\n\nint gcd(int a, int b)\n{\n    int c;\n\n    if (a < b) {\n        a+=b; b=a-b; a-=b;\n    }\n\n    while (b != 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nint dx[3]={-1, 0, 1};\nint dy[3]={-1, 0, 1};\nint W, H;\nchar masu[20][20];\nint cnt;\n\nint dfs(int a, int b){\n  masu[a][b] = '#';\n  cnt++;\n  REP(i, 3)REP(j, 3) if(masu[a+dx[i]][b+dy[j]]=='.' && abs(dx[i]+dy[j])==1 && a+dx[i] >= 0 && a+dx[i] < W && b+dx[j] >= 0 && b+dx[j] < H) dfs(a+dx[i], b+dy[j]);\n  return cnt;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    REP(j, H)REP(i, W) cin >> masu[i][j];\n\n    int i0, j0;\n    REP(j, H)REP(i, W) if(masu[i][j] == '@'){\n      i0=i;\n      j0=j;\n      break;\n    }\n\n    cnt = 0;\n    cnt = dfs(i0, j0);\n    cout << cnt << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cctype>\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repi(i,l,n) for(int (i)=(int)(l);(i)<(int)(n);(i)++)\n#define d_arr(arr, h, w) rep(i,(h) ){ cout << \"[\"; rep(j,(w) ) { cout << (arr)[i][j] << \", \"; } cout << \"]\" << endl;}\n\ntypedef pair<int ,int> P;\n\nclass car\n{\n    int id;\n    int num;\n    public:\n        car(int x, int y){ id=x; num=y; }\n};\n\nint H,W;\nchar grid[20][20];\nint is_visit[20][20];\nint start_h;\nint start_w;\n\n\nvoid rec(int h, int w);\n\n\nint main()\n{\n    //各データセットに対して\n    while( cin >> W >> H )\n    {\n        if ( W == 0 && H == 0 ) break;\n        //入力\n        rep(i, H)\n        {\n            rep(j, W)\n            {\n                char tmp;\n                cin >> tmp;\n                grid[i][j] = tmp;\n                if( tmp == '@') { start_h = i; start_w = j; }\n                is_visit[i][j] = 0;\n            }\n        }\n\n        rec(start_h,start_w);\n\n        int count=0;\n        rep(i,H)\n        {\n            rep(j,W)\n            {\n                count += is_visit[i][j];\n            }\n        }\n\n        cout << count << endl;\n    }\n}\n\nvoid rec(int h, int w)\n{\n    //枠外\n    if( h < 0 || H <= h || w < 0 || W <= w  ) { return ; }\n    //障害物\n    if( grid[h][w] == '#' ) { return ; }\n    //訪れたか\n    if( is_visit[h][w] == 1 ) { return ; }\n    is_visit[h][w] = 1;\n\n    vector<int> v(4);\n    rec(h,w+1);\n    rec(h,w-1);\n    rec(h+1,w);\n    rec(h-1,w);\n\n    //int a = max( v[0] , v[1] );\n    //int b = max( v[2] , v[3] );\n    //return max(a, b) + 1;\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int maxSize = 21;\nint mapData[maxSize][maxSize] = {0};\nint W, H, Ans;\n\nvoid dfs(int hh, int ww) {\n  if(mapData[hh][ww] == 1) {\n    mapData[hh][ww] = 0;\n    Ans++;\n    if(hh+1<H && mapData[hh+1][ww]==1) {\n      dfs(hh+1, ww);\n    }\n    if(ww+1<W && mapData[hh][ww+1]==1) {\n      dfs(hh, ww+1);\n    }\n    if(0<=hh-1 && mapData[hh-1][ww]==1) {\n      dfs(hh-1, ww);\n    }\n    if(0<=ww-1 && mapData[hh][ww-1]==1) {\n      dfs(hh, ww-1);\n    }\n  }\n}\n\nint main() {\n  while(cin>>W>>H && !(W==0 && H==0)) {\n    int startW, startH;\n    Ans = 0;\n    for(int i=0; i<H; i++) {\n      string str;\n      cin>>str;\n      for(int j=0; j<W; j++) {\n\tif(str[j] == '.') {\n\t  mapData[i][j] = 1; // true\n\t}\n\telse if(str[j] == '#') {\n\t  mapData[i][j] = -1; // false;\n\t}\n\telse {\n\t  mapData[i][j] = 1; //true\n\t  startW = i;\n\t  startH = j;\n\t}\n      }\n    }\n    /*\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n\tcout<<mapData[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n    dfs(startW, startH);\n    /*\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n\tcout<<mapData[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n    cout<<Ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint W,H;\nint x[4]={0,0,1,-1};\nint y[4]={1,-1,0,0};\nint i,j;\nint count=0;\nchar room[100][100];\n\nint dfs(int, int);\n\nint main(){\n  while(1){\n    int sy,sx;\n    cin >> W >> H;\n    if(W==0&&H==0)break;\n    for(i = 0 ; i < H ; i++){\n      for(j = 0 ; j < W ; j++){\n\tcin >> room[i][j];\n\tif(room[i][j] == '@'){\n\t  sy = i;\n\t  sx = j; \n\t}\n      }\n    }\n    cout << dfs(sx,sy) << endl;\n  }\n  return 0;\n}\n\nint dfs(int ax,int ay){\n  if(ax<0||ay<0)return 0;\n  if(ax>=W||ay>=H)return 0;\n  if(room[ay][ax]=='#')return 0;\n  room[ay][ax]='#';\n  int cnt=1;\n  int i;\n  for(i=0;i<4;i++){\n    int nx=ax+x[i];\n    int ny=ay+y[i];\n    cnt+=dfs(nx,ny);\n  }\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nchar A[20][20];\nbool V[20][20];\nint count,H,W;\nvoid check(int x,int y){\n    if(0<=x-1){\n        if(A[x-1][y]=='.'&&!V[x-1][y]){\n            count++;\n            V[x-1][y]=true;\n            check(x-1,y);\n        }\n    }\n    if(x+1<H){\n        if(A[x+1][y]=='.'&&!V[x+1][y]){\n            count++;\n            V[x+1][y]=true;\n            check(x+1,y);\n        }\n    }\n   if(0<=y-1){\n        if(A[x][y-1]=='.'&&!V[x][y-1]){\n            count++;\n            V[x][y-1]=true;\n            check(x,y-1);\n        }\n    }   \n    if(y+1<W){\n        if(A[x][y+1]=='.'&&!V[x][y+1]){\n            count++;\n            V[x][y+1]=true;\n            check(x,y+1);\n        }\n    }\n    return;\n    }\nint main(){\n    int x,y;\n    count=1;\n    while(true){\n        cin>>W>>H;\n        if(W==0&&H==0){\n            break;\n        }else{\n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    cin>>A[i][j];\n                    if(A[i][j]=='@'){\n                        x=i;\n                        y=j;\n                    }\n                }\n            }\n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    V[i][j]=false;\n                    }\n                }\n            }\n        check(x,y);\n        cout<<count<<endl;\n        count=1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define MAX 1000000007\n\n\nusing namespace std;\n#define ll long long\n#define dbg if(0)\n#define ISRANGE(val,lo,hi) ((lo<=val)&&(val<hi))\n\n\n\nint main(){\n    ll ans;\n    char t[21][21];//w,h\n    ll dx[4]={-1,1,0,0};\n    ll dy[4]={0,0,-1,1};\n    ll dbg_cnt=0;\n    while(true){\n        ans=0;\n        ll w,h,px,py;\n        cin >>w>>h;\n        if(w==0&&h==0)break;\n        for(int y=0;y<h;y++){\n            for(int x=0;x<w;x++){\n                cin >>t[x][y];\n                if(t[x][y]=='@'){\n                    px=x,py=y;\n                    t[x][y]='.';\n                }\n            }\n        }\n\n        queue< pair<ll,ll> > kouho;//x,y\n        kouho.push(make_pair(px,py));\n        t[px][py]='#';\n        dbg{\n            cout <<\"kokomadeiketa \"<<dbg_cnt<<endl;\n            dbg_cnt++;\n            if(dbg_cnt>5)break;\n        }\n        ans++;\n        while(!kouho.empty()){\n            pair<ll,ll> now=kouho.front();//x,y\n            kouho.pop();\n            if(t[now.first][now.second]=='.'){\n                t[now.first][now.second]='#';\n                ans++;\n            }\n            for(int i=0;i<4;i++){\n                ll qx=now.first+dx[i],qy=now.second+dy[i];\n                if(ISRANGE(qx,0,w) && ISRANGE(qy,0,h)){\n                    if(t[qx][qy]=='.'){\n                        kouho.push(make_pair(qx,qy));\n                    }\n                }\n            }\n            dbg{\n                for(int y=0;y<h;y++){\n                    for(int x=0;x<w;x++){\n                        cout << t[x][y];\n                    }\n                    cout <<endl;\n                }\n            }\n        }\n\n        cout <<ans<<endl;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nint s = 0;\nint x[] = { -1,0,0,1 }; int y[] = { 0,-1,1,0 };\nbool p[20][20]{};\nvoid shima(int a, int b) {\n\ts++;\n\tp[a][b] = false;\n\tfor (int c = 0; c < 4; c++) {\n\t\tint d = a + x[c]; int e = b + y[c];\n\t\tif (d >= 0 && d < 20 && e>=0 && e < 20 && p[d][e])shima(d, e);\n\t}\n}\nint main() {\n\tint a, b;\n\twhile (cin >>b>>a, a | b) {\n\t\ts = 0;\n\t\tfor (int n = 0; n < 20; n++) {\n\t\t\tfor (int m = 0; m < 20; m++) {\n\t\t\t\tp[n][m] = false;\n\t\t\t}\n\t\t}\n\t\tint l = 0, r = 0;\n\t\tfor (int c = 0; c < a; c++) {\n\t\t\tfor (int d = 0; d<b; d++) {\n\t\t\t\tchar e;\n\t\t\t\tcin >> e;\n\t\t\t\tif (e == '.')p[c][d] = true;\n\t\t\t\telse if (e == '@') { l = c; r = d; }\n\t\t\t}\n\t\t}\n\t\tshima(l, r);\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iterator>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring GetStr()\n{\n\tstring str;\n\tgetline(cin,str);\n\treturn str;\n}\n\nvector<int> GetIntVector()\n{\n\tstring str;\n\tgetline(cin,str);\n\tistringstream line( str );\n\n\tistream_iterator<int> iit(line);\n\tistream_iterator<int> iit_eof;\n\n\tvector<int> ret;\n\n\tfor(;iit != iit_eof; iit++){\n\t\tret.push_back(*iit);\n\t}\n\n\treturn ret;\n}\n\nint counter;\n\nvoid GoNext(vector<string>& lines,int hh,int hw)\n{\n\tcounter++;\n\tlines[hh][hw] = '#';\n\n\tif(hw > 0 && lines[hh][hw-1] != '#')\n\t\tGoNext(lines,hh,hw-1);\n\n\tif(hw < (int)lines[hh].size() - 1 && lines[hh][hw+1] != '#')\n\t\tGoNext(lines,hh,hw+1);\n\n\tif(hh > 0 && lines[hh-1][hw] != '#')\n\t\tGoNext(lines,hh-1,hw);\n\n\tif(hh < (int)lines.size() - 1 && lines[hh+1][hw] != '#')\n\t\tGoNext(lines,hh+1,hw);\n}\n\nvoid solve(int w,int h)\n{\n\tvector<string> lines;\n\tfor(int i = 0; i < h; i++){\n\t\tlines.push_back(GetStr());\n\t}\n\n\tint humanw,humanh = -1;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(lines[i][j] == '@'){\n\t\t\t\thumanh = i; humanw = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(humanh != -1) break;\n\t}\n\n\tcounter = 0;\n\n\tGoNext(lines,humanh,humanw);\n\n\tcout << counter <<endl;\n}\n\nvoid solve1130()\n{\n\tvector<int> v = GetIntVector();\n\twhile(v[0] != 0 && v[1] != 0){\n\t\tsolve(v[0],v[1]);\n\t\t v = GetIntVector();\n\t}\n}\n\n\nint main()\n{\n\tsolve1130();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( x < H && y < W && room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '*';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\txy.pop();\n\t\t}\n\t\t/*for( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcout << room[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar mas[25][25];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint w,h,sx,sy,cnt;\nvoid dfs(int,int);\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> mas[i][j];\n                if(mas[i][j] == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        cnt = 0;\n        dfs(sx,sy);\n        cout << cnt << endl;\n    }\n}\n\nvoid dfs(int x,int y){\n    mas[y][x] = '#';\n    cnt++;\n    for(int i=0;i<4;i++){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(nx >= 0 && nx < w && ny >= 0 && ny < h && mas[ny][nx] == '.') {\n            dfs(nx,ny);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            return 0;\n        }\n        vector<vector<char>> v(h, vector<char>(w, '\\0'));\n        pair<int, int> start;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin >> v[i][j];\n                if (v[i][j] == '@') {\n                    start = make_pair(i, j);\n                }\n            }\n        }\n        constexpr char REACHABLE = '$';\n        function<void(int, int)> f = [&v, &f, w, h, REACHABLE](int i, int j) {\n            // ?????¢????¶???????\n            if (i == -1 || j == -1 || i == h || j == w) {\n                return;\n            }\n            // ?§??????§?????????\n            else if (v[i][j] == '#') {\n                return;\n            }\n            // ????????°?????§??????\n            else if (v[i][j] == REACHABLE) {\n                return;\n            }\n            else {\n                v[i][j] = REACHABLE;\n                f(i - 1, j);\n                f(i + 1, j);\n                f(i, j - 1);\n                f(i, j + 1);\n            }\n        };\n        f(start.first, start.second);\n        auto r = accumulate(begin(v), end(v), 0,\n                            [REACHABLE](int z, const vector<char>& vv) {\n                                return z + count(begin(vv), end(vv), REACHABLE);\n                            });\n        cout << r << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar map[32][32];\nint w, h;\n\nint counter;\n\nvoid count(int x, int y) {\n\tmap[x][y] = '#';\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nextX = x + dx[i];\n\t\tint nextY = y + dy[i];\n\t\tif ((0 <= nextX && nextX < w) && (0 <= nextY && nextY < h)) {\n\t\t\tif (map[nextX][nextY] != '#') {\n\t\t\t\tcount(nextX, nextY);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint startX, startY;\n\twhile (cin >> w >> h, w || h) {\n\t\tcounter = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif (map[j][i] == '@') {\n\t\t\t\t\tstartX = j;\n\t\t\t\t\tstartY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount(startX, startY);\n\t\tcout << counter << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\nusing namespace std;\nconst int INF=100000000;\nchar a[20][20];\nint h,w;\nvoid dfs(int x,int y){\n  if(x<0||y<0||x>=w||y>=h)return ;\n  if(a[y][x]=='.'){\n    a[y][x]='$';\n  }else return ;\n  dfs(x+1,y);\n  dfs(x-1,y);\n  dfs(x,y+1);\n  dfs(x,y-1);\n}\nint main(){\n  while(cin>>w>>h,h!=0){\n    int sx,sy;\n    rep(i,h)rep(j,w){\n      cin>>a[i][j];\n      if(a[i][j]=='@')sx=j,sy=i;\n    }\n    int ans=0,k=0;\n    a[sy][sx]='.';\n    dfs(sx,sy);\n    rep(i,h){\n      rep(j,w){\n\tif(a[i][j]=='$')ans++;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\n\n\nint x,y;\nvs box;\nint dx[4]{0,1,0,-1};\nint dy[4]{1,0,-1,0};\nll s=0;\nvoid dfs(int px,int py){\n    REP(i,4){\n        int nx=px+dx[i];\n        int ny=py+dy[i];\n        if(nx>=0&&nx<x&&ny>=0&&ny<y&&box[ny][nx]=='.'){\n            box[ny][nx]='d';\n            s++;\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\n\nint main(){\n    vi ans;\n    while (cin>>x>>y,(x||y))\n    {\n        box.resize(y);\n        int sx=-1,sy;\n        REP(i,y){cin>>box[i];if(sx==-1&&(sx=box[i].find('@'))!=-1){sy=i;}}\n        s=1;\n        dfs(sx,sy);\n        ans.pb(s);\n    }\n    \n    ShowAll(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint W,H,a,b,c;\nint t[20][20];\nchar moji;\nint ty[4] = {0,1,0,-1};\nint tx[4] = {1,0,-1,0};\n\nvoid syokika(){\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      t[i][j]=0;\n    }\n  }\n  c=0;\n}\nvoid visit(int y,int x){\n  c++;\n  t[y][x]=1;\n  int nx,ny;\n  for(int i=0;i<4;i++){\n    ny=y+ty[i];\n    nx=x+tx[i];\n    if(0<=ny&&ny<H&&0<=nx&&nx<W&&t[ny][nx]==0){\n      visit(ny,nx);\n    }\n  }\n}\nint main(){\n  while(true){\n    syokika();\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>moji;\n\tif(moji=='.')t[i][j]=0;\n\tif(moji=='@'){\n\t  a=i;\n\t  b=j;\n\t}\n\tif(moji=='#')t[i][j]=-1;\n      }\n    }\n    visit(a,b);\n    cout<<c<<endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return x < h && y < w;\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\tint initX, initY;\n\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i; initY = j;\n\t\t}\n\t    }\n\t}\n\n\tmove(initX, initY);\n\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint x;\n\tint y;\n} POSITION;\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W + H != 0) {\n\t\tbool board[W][H];\n\t\tvector<POSITION> movable;\n\t\tPOSITION myPosition;\n\t\tint ans = 1;\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\tcase '.': {\n\t\t\t\t\tboard[x][y] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase '@': {\n\t\t\t\t\tboard[x][y] = false;\n\t\t\t\t\tmyPosition.x = x;\n\t\t\t\t\tmyPosition.y = y;\n\t\t\t\t}\t\n\t\t\t\tcase '#': {\n\t\t\t\t\tboard[x][y] = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (myPosition.x - 1 >= 0 && board[myPosition.x - 1][myPosition.y]) {\n\t\t\tmovable.push_back( {myPosition.x - 1, myPosition.y} );\n\t\t\tboard[myPosition.x - 1][myPosition.y] = false;\n\t\t\tans++;\n\t\t}\n\t\tif (myPosition.x + 1 < W && board[myPosition.x + 1][myPosition.y]) {\n\t\t\tmovable.push_back( {myPosition.x + 1, myPosition.y} );\n\t\t\tboard[myPosition.x + 1][myPosition.y] = false;\n\t\t\tans++;\n\t\t}\n\t\tif (myPosition.y - 1 >= 0 && board[myPosition.x][myPosition.y - 1]) {\n\t\t\tmovable.push_back( {myPosition.x, myPosition.y - 1} );\n\t\t\tboard[myPosition.x][myPosition.y - 1] = false;\n\t\t\tans++;\n\t\t}\n\t\tif (myPosition.y + 1 < H && board[myPosition.x][myPosition.y + 1]) {\n\t\t\tmovable.push_back( {myPosition.x, myPosition.y + 1} );\n\t\t\tboard[myPosition.x][myPosition.y + 1] = false;\n\t\t\tans++;\n\t\t}\n\n\t\twhile (movable.size() != 0) {\n\t\t\tPOSITION sp = movable[movable.size() - 1];\n\t\t\tmovable.pop_back();\n\t\t\tif (sp.x - 1 >= 0 && board[sp.x - 1][sp.y]) {\n\t\t\t\tmovable.push_back( {sp.x - 1, sp.y} );\n\t\t\t\tboard[sp.x - 1][sp.y] = false;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (sp.x + 1 < W && board[sp.x + 1][sp.y]) {\n\t\t\t\tmovable.push_back( {sp.x + 1, sp.y} );\n\t\t\t\tboard[sp.x + 1][sp.y] = false;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (sp.y - 1 >= 0 && board[sp.x][sp.y - 1]) {\n\t\t\t\tmovable.push_back( {sp.x, sp.y - 1} );\n\t\t\t\tboard[sp.x][sp.y - 1] = false;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (sp.y + 1 < H && board[sp.x][sp.y + 1]) {\n\t\t\t\tmovable.push_back( {sp.x, sp.y + 1} );\n\t\t\t\tboard[sp.x][sp.y + 1] = false;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint i,j,k,w,h,a;\n\t\tchar c[20][20];\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<20;j++){\n\t\t\t\tc[i][j]='\\0';\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin>>c[i];\n\t\t}\n\t\tfor(k=0;k<=w*h;k++){\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(c[i][j]=='.'){\n\t\t\t\t\t\tif(i!=h-1){\n\t\t\t\t\t\t\tif(c[i+1][j]=='@'){\n\t\t\t\t\t\t\t\tc[i][j]='@';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=w-1){\n\t\t\t\t\t\t\tif(c[i][j+1]=='@'){\n\t\t\t\t\t\t\t\tc[i][j]='@';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i!=0){\n\t\t\t\t\t\t\tif(c[i-1][j]=='@'){\n\t\t\t\t\t\t\t\tc[i][j]='@';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j!=0){\n\t\t\t\t\t\t\tif(c[i][j-1]=='@'){\n\t\t\t\t\t\t\t\tc[i][j]='@';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\ta=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(c[i][j]=='@')a++;\t\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint paint(vector<string> &field, int x, int y) {\n    int cnt = 0;\n\n    for(int i = 0; i < 4; ++i) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx < 0 || field[i].size() <= xx || yy < 0 || field.size() <= yy) continue;\n\n        if(field[yy][xx] == '.') {\n            field[yy][xx] = '#';\n            cnt += paint(field, xx, yy)+1;\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while(true) {\n        int W, H;\n        cin >> W >> H;\n\n        if(!W && !H) break;\n\n        int sx, sy;\n        vector<string> field(H);\n        for(int i = 0; i < H; ++i) {\n            cin >> field[i];\n            for(int x = 0; x < W; ++x) {\n                if(field[i][x] == '@') {\n                    sx = x;\n                    sy = i;\n                }\n            }\n        }\n\n        cout << paint(field, sx, sy)+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\n\nchar r[21][21];\nint w,h,c;\n\nvoid rec(int y,int x){\n\tif(r[y][x]=='.')c++;\n\tr[y][x]='#';\n\trep(d,4){\n\t\tint cy=y+dy[d],cx=x+dx[d];\n\t\tif(ck(cy,h)&&ck(cx,w)&&r[cy][cx]=='.')rec(cy,cx);\n\t}\n}\nint main(){\n\tint sx,sy;\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>r[i][j];\n\t\t\tif(r[i][j]=='@')sx=j,sy=i;\n\t\t}\n\t\tc=1;\n\t\trec(sy,sx);\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int, int);\nint limx,limy,cnt=0,ni,nj;\nchar data[20][21];\n\nint main(){\n  int i,j;\n  while(1){\n    scanf(\"%d%d\",&limx,&limy);\n    if(limx==0 && limy==0)\n      break;\n    for(i=0;i<limy;i++)\n      scanf(\"%s\",data[i]);\n\n    for(i=0;i<limy;i++)\n      for(j=0;j<limx;j++)\n\tif(data[i][j]=='@') ni=i,nj=j;\n    dfs(ni,nj);\n    printf(\"%d\\n\",cnt);\n    cnt=0;\n  }\n  return 0;\n}\n\nvoid dfs(int i, int j){\n  int di[4]={0,-1,0,1};\n  int dj[4]={1,0,-1,0};\n\n  data[i][j]='#';\n  cnt++;\n  for(int r=0;r<4;r++){\n    ni=i+di[r];\n    nj=j+dj[r];\n    if(data[ni][nj]=='.') dfs(ni,nj);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nbool done[21][21];\nint W,H;\nchar s[21][21];\nbool map[21][21];\n\nvoid init(){\n  for(int i=0;i<21;i++){\n    for(int j=0;j<21;j++){\n      done[i][j]=false;\n      map[i][j]=false;\n      s[i][j]=0;\n    }}\n}\n\nvoid solve(int h,int w){\n  if(s[h][w]=='.' || s[h][w]=='@'){\n    map[h][w]=true;\n    done[h][w]=true;\n    if(h-1 >=0 && done[h-1][w]==false) solve(h-1,w);\n    if(h+1 < H && done[h+1][w]==false) solve(h+1,w);\n    if(w-1 >=0 && done[h][w-1]==false) solve(h,w-1);\n    if(w+1 <W && done[h][w+1]==false) solve(h,w+1);\n  }\n  else{\n    map[h][w]=false;\n    done[h][w]=true;\n  }\n\n  return;\n\n}\nint main(){\n  while(1){\n    init();\n    scanf(\"%d%d\",&W,&H);\n    if(W==0 && H==0) break;\n    for(int i=0;i<H;i++)\n      scanf(\"%s\",&s[i]);\n    int sw,sh;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(s[i][j]=='@'){\n          sw=j;\n          sh=i;\n        }}}\n\n    solve(sh,sw);\n\n\n    int ans=0;\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(map[i][j]==true)\n          ans++;\n      }}\n\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 201\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nvoid calc(int h,int w){\n  char mm[SIZE][SIZE];\n  int sy,sx;\n  int ans = 0;\n\n  for(int i=0;i<h;i++){\n    scanf(\"%s\",mm[i]);\n\n    for(int j=0;j<w;j++){\n      if(mm[i][j]=='@'){\n\tsy = i;\n\tsx = j;\n\tmm[i][j]='.';\n      }\n    }\n  }\n\n  queue<pair<int,int> > q;\n\n  q.push({sy,sx});\n\n  while(q.size()){\n    int y = q.front().first;\n    int x = q.front().second;\n    q.pop();\n\n    if(mm[y][x]!='.') continue;\n    mm[y][x]='#';\n    ans++;\n\n    for(int i=0;i<4;i++){\n      if(y+dy[i]<0 || h<=y+dy[i] || x+dx[i]<0 || w<=x+dx[i]) continue;\n\n      if(mm[y+dy[i]][x+dx[i]]=='.'){\n\tq.push({y+dy[i],x+dx[i]});\n      }\n    }\n  }\n  \n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  int h,w;\n  \n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(h==0) break;\n    calc(h,w);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <cfloat>\nusing namespace std;\n\nint solve(vector<string>& tile)\n{\n    int h = tile.size();\n    int w = tile[0].size();\n    int sy, sx;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(tile[i][j] == '@'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n\n    int dy[] = {1, -1, 0, 0};\n    int dx[] = {0, 0, 1, -1};\n\n    vector<vector<bool> > check(h, vector<bool>(w, false));\n    check[sy][sx] = true;\n    queue<pair<int, int> > q;\n    q.push(make_pair(sy, sx));\n\n    int ret = 0;\n    while(!q.empty()){\n        int y = q.front().first;\n        int x = q.front().second;\n        q.pop();\n        ++ ret;\n        for(int i=0; i<4; ++i){\n            int y0 = y + dy[i];\n            int x0 = x + dx[i];\n            if(tile[y0][x0] == '.' && !check[y0][x0]){\n                q.push(make_pair(y0, x0));\n                check[y0][x0] = true;\n            }\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            break;\n\n        vector<string> tile(h+2);\n        tile[0] = tile[h+1] = string(w+2, '#');\n        for(int i=0; i<h; ++i){\n            cin >> tile[i+1];\n            tile[i+1] = '#' + tile[i+1] + '#';\n        }\n\n        cout << solve(tile) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<map>\n#include<utility>\n#include<list>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fori(i,k,n) for(int i=k;i<(int)n;i++)\nusing namespace std;\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nconst int dX[8] = { 0, 1, 1, 1, 0, -1, -1, -1 }, dY[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\nstruct XY\n{\n\tint x;\n\tint y;\n};\n\n\n/*\n(char)'1' - (int)48 = (int)1;\n\n\n*/\nint main()\n{\n\tint h, w;\n\tcin >> w>> h;\n\twhile (w != 0 || h != 0)\n\t{\n\t\tqueue<XY> m;\n\t\tXY fis;\n\t\tint a[200][200] = {};\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int l = 0; l < w; l++)\n\t\t\t{\n\t\t\t\tchar r;\n\t\t\t\tcin >> r;\n\t\t\t\tif (r == '.')\n\t\t\t\t\ta[i + 1][l + 1] = 1;\n\t\t\t\telse if (r == '@')\n\t\t\t\t{\n\t\t\t\t\tfis.x = l + 1;\n\t\t\t\t\tfis.y = i + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\t\tint ans = 1;\n\t\tm.push(fis);\n\t\twhile (!m.empty())\n\t\t{\n\t\t\tXY gg;\n\t\t\tint x, y;\n\t\t\tx = m.front().x;\n\t\t\ty = m.front().y;\n\t\t\tm.pop();\n\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (a[y + dy[i]][x + dx[i]] == 1)\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t\ta[y + dy[i]][x + dx[i]] = 0;\n\t\t\t\t\tgg.x = x + dx[i];\n\t\t\t\t\tgg.y = y + dy[i];\n\t\t\t\t\tm.push(gg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout << ans << endl;\n\t\tcin >> w >> h;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nint ans = 0;\nvoid dfs(vector<string> v, int x,int y,vector< vector<int> > &vv){\n\tint dx[4] = {-1, 1, 0, 0};\n\tint dy[4] = { 0, 0,-1, 1};\n\tif (vv[y][x] == 1) return ;\n\tif (v[y][x] == '#') return ;\t\n\tvv[y][x] = 1;\n\tans++;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (0 <= x + dx[i] and x + dx[i] < v[0].size() and 0 <= y + dy[i] and y + dy[i] < v.size()){\n\t\t\tdfs(v,x + dx[i],y + dy[i],vv);\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\twhile(1){\n\t\tint w,h; cin >> w >> h;\n\t\tans = 0;\n\t\tif (w + h == 0) break;\n\t\tvector<string> tile(h);\n\t\tvector< vector<int> > check(h, vector<int>(w,0));\n\t\tint at_x;\n\t\tint at_y;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> tile[i];\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\tat_x = j;\n\t\t\t\t\tat_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(tile,at_x,at_y,check);\n\t\tcout << ans << endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\nint w,h;\nint sx,sy;\nint a[30][30];\nstring str[30];\nqueue<int> q;\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tcin >> str[i];\n\t\t}\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(str[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push(sy*30+sx);\n\t\ta[sy][sx] = 1;\n\n\t\twhile(!q.empty()){\n\t\t\tint tmp = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tint nx = tmp%30 + dx[i];\n\t\t\t\tint ny = tmp/30 + dy[i];\n\n\t\t\t\tif(ny <0 || nx <0 || ny >= h || nx >= w || str[ny][nx] == '#' || a[ny][nx] == 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tq.push(ny*30+nx);\n\n\t\t\t\ta[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\n\t\tint count=0;\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(a[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n  \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\nchar room[100][100];\nbool fin[100][100];\nint w,h;\n\nint dfs(int i,int j){\n    int sum = 1;\n \n    fin[i][j] = false;\n \n    for(int k = 0;k < 4;k++){\n        int ii = i + dy[k];int jj = j + dx[k];\n        if(ii >= 0 && ii < h && jj >= 0 && jj < w && fin[ii][jj] && room[ii][jj] == '.')\n            sum += dfs(ii,jj);\n    }\n    return sum;\n}\n \nint main(){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n \n        if(w == 0 && h == 0)\n            break;\n \n        for(int i = 0;i < h;i++)\n            scanf(\"%s\",&room[i][0]);\n \n        for(int i = 0;i < h;i++)\n            for(int j = 0;j < w;j++)\n                fin[i][j] = true;\n \n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                if(room[i][j] == '@')\n                    printf(\"%d\\n\",dfs(i,j));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_H = 20;\nconst int MAX_W = 20;\n\n// 入力\nint W, H;\nchar field[MAX_H][MAX_W+1]; // ヌル文字を考慮\nint startx, starty;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y) {\n\tfield[y][x] = '$';\n\tfor (int i = 0; i < 4; i++) {\n\t\tint newX = x + dx[i];\n\t\tint newY = y + dy[i];\n\t\tif (field[newY][newX] == '.') {\n\t\t\tdfs(newX, newY);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif (W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tmemset(field, 0, sizeof(field));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(startx, starty);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (field[i][j] == '$') {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct locate{\n  int x;\n  int y;\n};\n \nchar graph[20][20];\nint cou = 0;\nint H,W;\n\nvoid bfs(locate z){\n  queue<locate> Q;\n  locate u;\n  locate v;\n  Q.push(z);\n \n\n  while(!Q.empty()){\n\n    u = Q.front();Q.pop();\n\n    if(graph[u.y + 1][u.x] == '.' && graph[u.y + 1][u.x] != 'N'){\n      graph[u.y + 1][u.x] = 'N';\n      cou++;\n      v.y = u.y + 1;\n      v.x = u.x;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x + 1] == '.' && graph[u.y][u.x + 1] != 'N'){\n      graph[u.y][u.x + 1] = 'N';\n      cou++;\n      v.x  = u.x + 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n\n    if(graph[u.y - 1][u.x] == '.' && graph[u.y - 1][u.x] != 'N'){\n      graph[u.y - 1][u.x] = 'N';\n      cou++;\n      v.x = u.x;\n      v.y = u.y - 1;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x - 1] == '.' && graph[u.y][u.x - 1] != 'N'){\n      graph[u.y][u.x - 1] = 'N';\n      cou++;\n      v.x = u.x - 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n    \n  }\n  cout << endl;\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcout << graph[i][j];\n      }\n      cout << endl;\n      }\n}\n\nint main(){\n\n  int a1,a2;\n  locate a;\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    a.y = a1;\n    a.x = a2;\n    bfs(a);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 'N';\n      }\n    }\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\n\nint W,H;\n\nchar r[1000][1000];\n\nint sh,sw;\nint bnum=0;\n\nint solve(int i,int j){\n    int ans=0;\n\n    if(i <0 || H <= i || j < 0 || W <= j)\n        return 0;\n    if(r[i][j] == '#'){\n        return 0;\n    }\n    ans = 1;\n    r[i][j] = '#';\n    ans += solve(i-1,j);\n    ans += solve(i+1,j);\n    ans += solve(i,j-1);\n    ans += solve(i,j+1);\n\n    return ans;\n}\n\n\nint main(){\n\n    while(1){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0) break;\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> r[i][j];\n                if(r[i][j] == '@'){\n                    sh = i;\n                    sw = j;\n                    r[i][j] = '.';\n                }\n            }\n        }\n        cout << solve(sh,sw) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ??±???????????¢?´¢(DFS:Depth First Search)\n// ICPC Domestic 2004\n//\n#include <iostream>\nusing namespace std;\n\n#define LIM 20\nint w,h,sx,sy,ans;\nbool field[LIM][LIM];\nchar buff[LIM];\nbool flg=true;\n\nvoid input(void);\nvoid dump(void);\nvoid dfs(int, int);\nvoid solve();\n\n\nint main(void)\n{\n    while(true){\n        input();\n        if(!flg)break; // ????????????????????????????¨??????§????????°??????????????????\n        //dump();\n        dfs(sx,sy);\n        solve();\n    }\n    return 0;\n}\n\nvoid input(void){\n    cin >> w >> h;\n    if(w==0 && h==0){\n        flg=false;\n        return;\n    }\n    for(int i=0;i<h;++i){\n        cin >> buff;\n        for(int j=0;j<w;++j){\n            if(buff[j]=='#')field[i][j]=false; // ????????????\n            else field[i][j]=true; // ?????????\n            if(buff[j]=='@'){\n                sy=i;\n                sx=j;\n            }\n        }\n    }\n    ans=0; //?§£????????????????????????????????¨????????????\n    return;\n}\n\nvoid dump(void){\n    cout << \"sx:\" << sx << \" sy:\" << sy << endl;\n    for(int i=0;i<h;++i){\n        for(int j=0;j<w;++j){\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n}\n\nvoid dfs(int x,int y){\n    if(!field[y][x] || x<0 || y<0 || x>=w || y>=h) //????????¢?????????????????´????????´???\n        return;\n    else{\n        field[y][x]=false;\n        ++ans;\n        dfs(x-1,y); //???\n        dfs(x,y-1); //???\n        dfs(x+1,y); //???\n        dfs(x,y+1); //???\n    }\n    return;\n}\n\nvoid solve(){\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint W, H;\nint start_x = 0, start_y = 0;\nint sum;\n\nvector<vector<char>> makeroom(int w, int h) {\n\tvector<vector<char>> room(h);\n\tfor(int i = 0; i < h; i++) {\n\t\tfor(int j = 0; j < w; j++) {\n\t\t\tchar tmp;\n\t\t\tcin >> tmp;\n\t\t\tif(tmp == '@') {\n\t\t\t\tstart_x = j;\n\t\t\t\tstart_y = i;\n\t\t\t}\n\t\t\troom[i].push_back(tmp);\n\t\t}\n\t}\n\treturn room;\n}\n\nvoid dfs_run(vector<vector<char>>& room, vector<vector<bool>>& checker, int x, int y) {\n\t\n\tif(x != 0) {\n\t\tif(room[y][x - 1] == '.' and checker[y][x - 1]) {\n\t\t\tsum++;\n\t\t\tchecker[y][x - 1] = false;\n\t\t\tdfs_run(room, checker, x - 1, y);\n\t\t}\n\t}\n\tif(x != W - 1) {\n\t\tif(room[y][x + 1] == '.' and checker[y][x + 1]) {\n\t\t\tsum++;\n\t\t\tchecker[y][x + 1] = false;\n\t\t\tdfs_run(room, checker, x + 1, y);\n\t\t}\n\t}\n\tif(y != 0) {\n\t\tif(room[y - 1][x] == '.' and checker[y - 1][x]) {\n\t\t\tsum++;\n\t\t\tchecker[y - 1][x] = false;\n\t\t\tdfs_run(room, checker, x, y - 1);\n\t\t}\n\t}\n\tif(y != H - 1) {\n\t\tif(room[y + 1][x] == '.' and checker[y + 1][x]) {\n\t\t\tsum++;\n\t\t\tchecker[y + 1][x] = false;\n\t\t\tdfs_run(room, checker, x, y + 1);\n\t\t}\n\t}\n}\n\nvoid dfs(vector<vector<char>>& room) {\n\tvector<vector<bool>> checker;\n\tchecker = vector<vector<bool>>(room.size(), vector<bool>(room[0].size(), true));\n\n\tdfs_run(room, checker, start_x, start_y);\n}\n\n\nint main(void) {\n\twhile(1) {\n\t\tcin >> W >> H;\n\t\tif(W == 0 and H ==0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<vector<char>> room = makeroom(W, H);\n\t\tsum = 0;\n\t\tdfs(room);\n\n\t\tcout << sum + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(long long int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nvector<string> c(20);\n\nint dfs(int x, int y,int h,int w) {\n\tint point = 1;\n\tif (c[y][x] == '#') {\n\t\treturn 0;\n\t}\n\tc[y][x] = '#';\n\tif (y + 1 <= h - 1) {\n\t\tpoint+=dfs(x, y + 1, h, w);\n\t}\n\tif (y - 1 >= 0) {\n\t\tpoint+=dfs(x, y - 1, h, w);\n\t}\n\tif (x + 1 <= w - 1) {\n\t\tpoint+=dfs(x + 1, y, h, w);\n\t}\n\tif (x - 1 >= 0) {\n\t\tpoint+=dfs(x - 1, y, h, w);\n\t}\n\treturn point;\n}\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint h, w;\n\t\tint posx = -1, posy = -1;\n\t\tint count = 0;\n\n\t\tcin >> w >> h;\n\t\tif (h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tcin >> c[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(t, 0, w - 1) {\n\t\t\t\tif (c[i][t] == '@') {\n\t\t\t\t\tposx = t;\n\t\t\t\t\tposy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (posx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << dfs(posx, posy, h, w) << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\nint cnt = 0;\n\nvoid dfs(int y, int x) {\n   cnt++;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x+dx[i], ny = y+dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      dfs(ny, nx);\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (W == 0 && H == 0) break;\n      cnt = 0;\n      rep (i, H) {\n         cin >> B[i];\n      }\n      rep (i, H) {\n         rep (j, W) {\n            if (B[i][j] == '@') {\n               dfs(i, j);\n            }\n         }\n      }\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};\nint H,W,ans;\nchar fld[20][20];\n\nvoid dfs(int y,int x){\n    int ny,nx;\n    ans++; fld[y][x] = '#';\n    for(int i=0;i<4;i++){\n        ny = y+dy[i]; nx = x+dx[i];\n        if(0<=ny && ny<H && 0<=nx && nx<W && fld[ny][nx]=='.') dfs(ny,nx);\n    }\n}\n\nint main(){\n    int sy,sx;\n    while(cin>>W>>H,H||W){\n        ans = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>fld[i][j];\n                if(fld[i][j]=='@') sy = i, sx = j;\n            }\n        }\n        dfs(sy,sx);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <map>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b) for(int i = a; i < b; i++)\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> P;\n\nvoid p(vi v){\n\trep(i, v.size()){\n\t\tcout << v[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvoid pp(vector<string> v){\n\trep(i, v.size()){\n\t\tcout << v[i] << endl;\n\t}\n}\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nconst char wall = '#';\n\nint seedfill(vector<string> &v, P start){\n\tqueue<P> q;\n\tq.push(start);\n\tint count = 0;\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tint x = p.first;\n\t\tint y = p.second;\n\n\t\tif(v[y][x] != wall){\n\t\t\tv[y][x] = wall;\n\t\t\tcount++;\n\t\t\trep(i, 4){\n\t\t\t\tq.push(P(x+dx[i], y+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint solve(vector<string> &v){\n\trep(i, v.size()){\n\t\trep(j, v[i].size()){\n\t\t\tif(v[i][j] == '@'){\n\t\t\t\treturn seedfill(v, P(j, i));\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint W, H;\n\twhile(cin >> W >> H){\n\t\tif(!W && !H) break;\n\n\t\tvector<string> field(H+2);\n\t\trep(i, W+2) field[0].push_back(wall);\n\t\tfield[H+1] = field[0];\n\n\t\tFOR(i, 1, H+1){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tfield[i] = wall + tmp + wall;\n\t\t}\n\n\t\tcout << solve(field) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <array>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint height, width;\nint sx, sy;\n\n\nvoid bfs(vector<vector<char>>& field)\n{\n    int ans = 1;\n    array<int, 4> dx = {0, 0, 1, -1};\n    array<int, 4> dy = {1, -1, 0, 0};\n\n    queue<pii> p;\n    p.push({sx, sy});\n    \n    while (!p.empty()) {\n        pii q = p.front(); p.pop();\n        \n        //??????\n        int cx = q.first;\n        int cy = q.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx.at(i);\n            int ny = cy + dy.at(i);\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height \n                    && field.at(ny).at(nx) == '.') {\n\n                ans++;\n                field.at(ny).at(nx) = '#';\n                p.push({nx, ny});\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\nint main()\n{\n    while (cin >> width >> height) {\n        if (height == 0 && width == 0) break;\n\n        vector<vector<char>> field(height, vector<char>(width));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                cin >> field.at(y).at(x);\n\n                if (field.at(y).at(x) == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n\n        bfs(field);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include <utility>\n#include <functional>\n//#include<>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n//#define int long long;\nsigned main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    int cnt{};\n    vector<string> v(h);\n    for(int i = 0; i < h; ++i){\n      cin >> v[i];\n    }\n    //initialize\n    pair<int, int> p;\n    queue<pair<int, int>> q;\t\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tif(v[i][j] == '@'){\n\t  p = make_pair(i,j);\n\t  q.push(p);\n\t}\n      }\n    }\n    while(!q.empty()){\n      pair<int, int> p;\n      p = q.front();\n      q.pop();\n\n      for(int k = 0; k < 4; ++k){\n\tint x = p.first + dx[k]; int y = p.second + dy[k];\n\tif(0 > x || h <= x || 0 > y || w <= y)continue;\n\tif('.' == v[x][y]){\n\t  v[x][y] = '@';\n\t  ++cnt;\n\t  q.push(make_pair(x, y));\n\t}\n      }\n    }\n    cout << cnt+1 << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int (i)=0;(i) < (N); (i)++)\n\nconst int d[4] = {0,0,-1,1};\n\nint dfs(int& H, int& W, vector<vector<char>>& tiles, vector<vector<bool>>& visited, pair<int,int> now){\n    int h = now.first;\n    int w = now.second;\n    int res = 0;\n    if(h < 0 || h >= H || w < 0 || w >= W) return 0;\n    if(tiles[h][w] == '#' || visited[h][w]) return 0;\n\n    visited[h][w] = true;\n    res++;\n\n    for(int i=0;i<4;i++){\n        int nh = h + d[i];\n        int nw = w + d[i^2];\n        res += dfs(H,W,tiles,visited,{nh,nw});\n    }\n\n    return res;\n}\n\nint main(){\n    int H,W;\n    while(cin >> W >> H, H != 0 && W != 0){\n        vector<vector<char>> tiles(H,vector<char>(W));\n        vector<vector<bool>> visited(H,vector<bool>(W,false));\n        pair<int,int> start;\n\n        for(int h=0;h<H;h++){\n            for(int w=0;w<W;w++){\n                cin >> tiles[h][w];\n                if(tiles[h][w] == '@') start = {h,w};\n            }\n        }\n\n        cout << dfs(H, W, tiles, visited, start) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int dm[] = {-1, 0, 1, 0}, dn[] = {0, -1, 0, 1};\nint h, w, count;\nvector< vector<int> > field, finished;\n\nbool valid(int m, int n) {\n    return 0 <= m && m < h && 0 <= n && n < w && field[m][n] == 1;\n}\n\nvoid dfs(int m, int n) {\n    finished[m][n] = 1;\n    count++;\n\n    for(int i = 0; i < 4; i++) {\n        if(valid(m + dm[i], n + dn[i]) && !finished[m + dm[i]][n + dn[i]]) {\n            dfs(m + dm[i], n + dn[i]);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        field.resize(h); finished.resize(h);\n        int m, n;\n        for (int i = 0; i < h; i++) {\n            string input;\n            cin >> input;\n\n            field[i].resize(w); finished[i].resize(w);\n\n            for (int j = 0; j < w; j++) {\n                finished[i][j] = 0;\n\n                if(input[j] == '@') {\n                    m = i;\n                    n = j;\n                }\n                if(input[j] == '#') {\n                    field[i][j] = 0;\n                } else {\n                    field[i][j] = 1;\n                }\n            }\n        }\n\n        count = 0;\n        dfs(m, n);\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int vecx[4] = { -1,0,1,0 };\nconst int vecy[4] = { 0,1,0,-1 };\n\nint h, w;\nchar table[20][20];\nbool iswalked[20][20];\nint si, sj;\nint ans;\n\nvoid dfs(int _i, int _j) {\n\tans++;\n\tiswalked[_i][_j] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (_i + vecx[i] >= h || _i + vecx[i] < 0 || _j + vecy[i] >= w || _j + vecy[i] < 0)continue;\n\t\tif (!iswalked[_i + vecx[i]][_j + vecy[i]] && table[_i + vecx[i]][_j + vecy[i]] == '.') {\n\t\t\tdfs(_i + vecx[i], _j + vecy[i]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, w*h) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif (table[i][j] == '@')si = i, sj = j;\n\t\t\t}\n\t\t}\n\t\tdfs(si, sj);\n\t\tcout << ans << endl;\n\t\tans = 0;\n\t\tfor (int i = 0; i < h; i++)for (int j = 0; j < w; j++)iswalked[i][j] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<vector>\nusing namespace std;\n//上下右左を差すための配列\nint keep_nx[4] = {1 , 0 , -1 , 0};\nint keep_ny[4] = {0 , 1 , 0 , -1};\nvector< vector<bool> > can_Go (20 , vector<bool> (20));   //フィールドで行ける場所\n\n//深さ優先探索\nvoid dfs(int x, int y, int height, int width, int *cnt){\n  can_Go[y][x] = false;   *cnt += 1;\n  for(int i = 0 ; i < 4 ; i++){\n      int nx = x + keep_nx[i], ny = y + keep_ny[i];\n      if(0 <= nx && nx < width && 0 <= ny && ny < height && can_Go[ny][nx] == true)\n        dfs(nx, ny, height, width, cnt);\n  }\n}\n\n\nint main(void){\n\nwhile(true){\n  int width, height, start_x, start_y;    cin >> width >> height;\n  if(width == 0 && height == 0)   break;\n\n  for(int i = 0 ; i < height ; i++){\n    for(int j = 0 ; j < width ; j++){\n      char input;   cin >> input;\n      if(input == '.')  can_Go[i][j] = true;\n      if(input == '#')  can_Go[i][j] = false;\n      if(input == '@'){\n        start_x = j;  start_y = i;\n      }\n    }\n  }\n\n  int ans = 0;\n  dfs(start_x, start_y, height, width, &ans);\n\n  cout << ans << endl;\n}\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nbool in(ll y, ll x, ll h, ll w){\n\treturn 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint main(){\n\twhile(1){\n\t\tll w,h; cin >> w >> h;\n\t\tif(!w && !h) break;\n\t\tvector<vc> a(h,vc(w));\n\t\tll sy,sx;\n\t\trep(i,h) rep(j,w) cin >> a[i][j];\n\t\trep(i,h) rep(j,w) if(a[i][j]=='@') sy = i, sx = j;\n\t\tvvl d(h,vl(w,-1));\n\t\td[sy][sx] = 1;\n\t\tqueue<P> q;\n\t\tq.emplace(sy,sx);\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front(); q.pop();\n\t\t\trep(i,4){\n\t\t\t\tll ny = p.first + dy[i];\n\t\t\t\tll nx = p.second + dx[i];\n\t\t\t\tif(!in(ny,nx,h,w) || d[ny][nx] > -1) continue;\n\t\t\t\td[ny][nx] = a[ny][nx]=='.' ? 1 : 0;\n\t\t\t\tif(d[ny][nx]) q.emplace(ny,nx);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\trep(i,h) rep(j,w) if(d[i][j]!=-1) ans += d[i][j];\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N_PRIME 1000000007\n#define ll int64_t\n\nvoid calc(){\n    int w,h;\n    int board[32][32];\n    bool moved[32][32];\n    int px,py;\n    \n    cin >> w >> h;\n    if( w == 0 && h == 0)exit(0);\n    for(int j = 0 ; j < h ;j++ ){\n        string s;\n        cin >> s;\n        for(int i = 0 ; i < w ; i++ ){\n            moved[i][j] = false;\n            \n            if( s[i] == '.' ){\n                board[i][j] = 1;\n            }else if(s[i] == '#' ){\n                board[i][j] = 2;\n            }else if(s[i] == '@' ){\n                px = i;\n                py = j;\n                board[i][j] = 1;\n            }\n        }\n    }\n    \n    int count = 0;\n    queue<int> xs;\n    queue<int> ys;\n    xs.push(px);\n    ys.push(py);\n    \n    while(xs.size()>0){\n        px = xs.front();\n        py = ys.front();\n        xs.pop();\n        ys.pop();\n        \n        if( px < 0 || w <= px || py < 0 || h <= py )\n            continue;\n        \n        if( moved[px][py] )\n            continue;\n        moved[px][py] = true;\n        \n        if( board[px][py] == 2 )\n            continue;\n\n        xs.push(px + 1 );\n        ys.push(py + 0 );\n        \n        \n        xs.push(px + 0 );\n        ys.push(py + 1 );\n        \n        \n        xs.push(px - 1 );\n        ys.push(py + 0 );\n        \n        \n        xs.push(px + 0 );\n        ys.push(py - 1 );\n        count++;\n    }\n    \n    cout << count << endl;\n}\n\nint main(void){\n    while(true)calc();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define line() cerr << \"---------------\" << endl;\n\nint W, H;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W || H) {\n      memset(visited, false, sizeof(visited));\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      visited[sx][sy] = true;\n      dfs(sx, sy);\n      \n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\n\n//dpは行ったかどうか、vは行けるかどうか\nvoid depth_search(int x,int y,vector< vector<int> >& dp,vector< vector<int> >& v,int w,int h){\n  if(x>0){if(v[x-1][y]==1 and dp[x-1][y]!=1){dp[x-1][y]=1;depth_search(x-1,y,dp,v,w,h);}}\n  if(x<h-1){if(v[x+1][y]==1 and dp[x+1][y]!=1){dp[x+1][y]=1;depth_search(x+1,y,dp,v,w,h);}}\n  if(y>0){if(v[x][y-1]==1 and dp[x][y-1]!=1){dp[x][y-1]=1;depth_search(x,y-1,dp,v,w,h);}}\n  if(y<w-1){if(v[x][y+1]==1 and dp[x][y+1]!=1){dp[x][y+1]=1;depth_search(x,y+1,dp,v,w,h);}}\n}\n\n\nvoid solve(int w,int h){\n  vector< vector<int> > dp(h,vector<int>(w,0));\n  vector< vector<int> > v(h,vector<int>(w,0));\n  int x,y;\n  for(int i=0;i<h;i++){\n    string s;cin >>s;\n    for(int j=0;j<w;j++){\n      if(s[j]!='#') v[i][j]=1;\n      if(s[j]=='@'){dp[i][j]=1;x=i;y=j;}\n    }\n  }\n  depth_search(x,y,dp,v,w,h);\n  int c=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(dp[i][j]==1)c+=1;\n    }\n  }\n  cout << c << endl;\n}\n\n\nint main(){\n  int w,h;\n  while(cin >> w >> h and w!=0){\n    solve(w,h);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(1)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W==0 && H==0) break;\t\n      printf(\"%d\\n\", solve(W,H));\t\n    }\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col]!='#' && M[nc.row][nc.col]!='*' && M[nc.row][nc.col]!='@')\n\t{\n\t  M[nc.row][nc.col] = '*';\n\t  S.push(nc);\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <array>\n\nconst int kSize = 20 + 2;\n\nstd::array<int, 4> ways = {-1, -kSize, +1, +kSize};\n\ninline int xy2pos(const int x, const int y){\n    return x + y * kSize;\n}\n\nstd::array<bool, kSize*kSize> Bfs(const std::array<bool, kSize*kSize> &tiles, int pos){\n    std::array<bool, kSize*kSize> arrived;\n    std::queue<int> q;\n    q.push(pos);\n    std::fill(arrived.begin(), arrived.end(), false);\n    while(!q.empty()){\n        pos = q.front();\n        q.pop();\n        arrived[pos] = true;\n        for(int way : ways)\n            if(tiles.at(pos + way) && !arrived.at(pos + way))\n                q.push(pos + way);\n    }\n    return arrived;\n}\n\nint main(){\n    int w,h;\n    std::array<bool,kSize*kSize> tiles; ///< true if black\n    while((std::cin >> w >> h) && w != 0){\n        std::fill(tiles.begin(), tiles.end(), false);\n        int pos;\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                char c;\n                std::cin >> c;\n                tiles[xy2pos(x,y)] = (c == '.');\n                if(c == '@'){\n                    pos = xy2pos(x,y);\n                    tiles[pos] = true;\n                }\n            }\n        }\n        auto arrived = Bfs(tiles, pos);\n        int sum = 0;\n        for(bool v : arrived)\n            sum += (v) ? 1 : 0;\n        std::cout << sum << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define MOD 1000000007\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<string>\n#include<set>\n#include<map>\nusing namespace std;\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\n#define FOR(i,m,n) for(int i=(m);(i)<(n);(i)++)\ntypedef long long ll;\n\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={1,0,-1,0};\n\nint W,H,res;\nvoid dfs(int x,int y,vector<vector<char> >& m){\n    if(m[y][x]=='#')return;\n    res++;\n    m[y][x]='#';\n    rep(i,4){\n        int nx=x+dx[i],ny=y+dy[i];\n        if(nx>=0&&nx<W&&ny>=0&&ny<H){\n            dfs(nx,ny,m);\n        }\n    }\n}\n\nint main(){\n    while(cin >> W >> H,W|H){\n        vector<vector<char> > m(H,vector<char>(W));\n        rep(i,H)rep(j,W)cin >> m[i][j];\n        res=0;\n        rep(i,H)rep(j,W){\n            if(m[i][j]=='@')dfs(j,i,m);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[22][22];\nint w, h;\nint yy[4] = {-1, 0, 0, 1}, xx[4] = {0, 1, -1, 0};\nint solve(int y, int x){\n\tif(a[y][x] == '#')return 0;\n\ta[y][x] = '#';\n\tint ans = 0;\n\tfor(int i = 0;i < 4;i++){\n\t\tans += solve(y+yy[i], x+xx[i]);\n\t}\n\treturn ans+1;\n}\n\nint main(){\n\tint y, x;\n\twhile(cin >> w >> h){\n\t\tfill((char*)a, (char*)(a+22), '#');\n\t\tfor(int i = 1;i <= h;i++)\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == '@'){y = i;x = j;}\n\t\t}\n\t\tcout << solve(y, x) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%H;\n\t        int y=cur/H;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[i];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny&&ny<H))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*H);\n  visited[ny][nx]=true;\n++answer;\n    }\n   }\n //cout << answer << endl;\n printf(\"%d\\n\",answer);\n }\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, ans;\nint d[4][2] = { { 1, 0 }, { -1, 0 }, {0, 1}, {0, -1} };\nchar map[20][20];\n\nvoid search_dfs(int x, int y){\n\tif( x < 0 || x >= w || y < 0 || y >= h ) return;\n\tif( map[y][x] != '.' ) return;\n\tans ++;\n\tmap[y][x] = '*';\n\tfor(int i = 0; i < 4; i++)\n\t\tsearch_dfs( x + d[i][0], y + d[i][1] );\n}\n\nint main(void){\n\n\twhile( 1 ) {\n\t\tcin >> w >> h;\n\t\tif( w == 0 && h == 0 ) break;\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tcin >> map[i];\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t\tif( map[i][j] == '@' ) {\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsearch_dfs(j, i);\n\t\t\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nsigned main() {\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0) break;\n\n\t\tint sx, sy;\n\n\t\tvector<string> board;\n\t\trep(y, H) {\n\t\t\tboard.push_back(nextString());\n\t\t\trep(x, board[y].size()) {\n\t\t\t\tif (board[y][x] == '@') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tauto visit = vector< vector<bool> >(H, vector<bool>(W, false));\n\t\tvisit[sy][sx] = true;\n\n\t\tint cnt = 0;\n\t\tqueue<int> q;\n\t\tq.push(sy * 100 + sx);\n\t\twhile (!q.empty()) {\n\t\t\tint n = q.front();\n\t\t\tq.pop();\n\n\t\t\tint x = n % 100;\n\t\t\tint y = n / 100;\n\n\t\t\tcnt++;\n\n\t\t\trep(dir, 4) {\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\t\t\tif (visit[ny][nx]) continue;\n\t\t\t\tif (board[ny][nx] != '.') continue;\n\n\t\t\t\tq.push(ny * 100 + nx);\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define INF 1e9\n\nint W,H;\nint t_situ[20][20];\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nint x_start, y_start, Count;\n\nvoid move(int x_standard, int y_standard){\n  if(t_situ[y_standard][x_standard] == 2 && x_standard >=0 && x_standard < W\n      && y_standard >=0 && y_standard < H){\n    t_situ[y_standard][x_standard] = 1;\n    Count++;\n    REP(k,4) move(x_standard+dx[k], y_standard+dy[k]);\n  }/*else if(t_situ[y_standard][x_standard] == 1 )\n      REP(k,4) move(x_standard+dx[k]+dy[k], y_standard+dx[k]+dy[k]);*/\n}\n\nvoid solve(int X, int Y){\n  Count = 0;\n  char t_type[Y][X];\n  REP(i,20) REP(j,20) t_situ[i][j] = 0;\n  //0:red, 1:black&gone, 2:black&not_gone\n\n  REP(i,Y){\n    REP(j,X){\n      cin>>t_type[i][j];\n      switch (t_type[i][j]) {\n        case '@':\n            t_situ[i][j] = 2;\n            x_start = j;\n            y_start = i;\n            break;\n        case '.':\n            t_situ[i][j] = 2;\n            break;\n        case '#':\n            t_situ[i][j] = 0;\n      }\n    }\n  }\n\n  move(x_start, y_start);\n\n  cout<<Count<<endl;\n  /*REP(i,20){\n    REP(j,20){\n      cout<<t_situ[i][j];\n    }\n    cout<<endl;\n  }*/\n}\n\nint main(){\n\n  while(1) {\n    cin>>W>>H;\n    if(W == 0 && H == 0) break;\n    solve(W,H);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint tile[22][22] = {};\nint w, h;\nint cnt;\n\nvoid fill(int x, int y) {\n\ttile[x][y] = 0;\n\tcnt++;\n\tif (tile[x - 1][y] == 1) fill(x - 1, y);\n\tif (tile[x][y - 1] == 1) fill(x, y - 1);\n\tif (tile[x][y + 1] == 1) fill(x, y + 1);\n\tif (tile[x + 1][y] == 1) fill(x + 1, y);\n}\n\nint main() {\n\tint x = 0, y = 0;\n\twhile (cin >> w >> h && (w || h)) {\n\t\tcnt = 0;\n\t\tfor (int i = 1; i <= h; ++i){\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif (tmp == '.') tile[i][j] = 1;\n\t\t\t\telse if (tmp == '#') tile[i][j] = 0;\n\t\t\t\telse x = i, y = j, tile[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfill(x, y);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\nvector<int> ans;\nint cf[20][20];\nbool field[20][20];\nint w,h;\nvoid dfs(int i,int j,int count);\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w + h == 0) break;\n\t\tfor(int i = 0;i < 20;i++){\n\t\t\tfor(int j = 0;j < 20;j++){\n\t\t\t\tcf[i][j] = -1;\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint px,py;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tchar t;\n\t\t\t\tcin >> t;\n\t\t\t\tif(t == '.') field[i][j] = true;\n\t\t\t\telse if(t == '@'){ px = j; py = i;field[i][j] = true;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint counta = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] && cf[i][j] == -1){\n\t\t\t\t\tdfs(i,j,counta);\n\t\t\t\t\tcounta++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pn = cf[py][px];\n\t\tint count = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(cf[i][j] == pn) count++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans.push_back(count);\n\t}\n\tfor(int i = 0;i < ans.size();i++) cout << ans[i] << endl;\n\treturn 0;\n}\n\nvoid dfs(int i,int j,int count){\n\tcf[i][j] = count;\n\tif(i != 0 && field[i-1][j] && cf[i-1][j] == -1) dfs(i-1,j,count);\n\tif(i != h-1 && field[i+1][j] && cf[i+1][j] == -1) dfs(i+1,j,count);\n\tif(j != 0 && field[i][j-1] && cf[i][j-1] == -1) dfs(i,j-1,count);\n\tif(j != w-1 && field[i][j+1] && cf[i][j+1] == -1) dfs(i,j+1,count);\n}"
  },
  {
    "language": "C++",
    "code": "// Red and Black\n// 問題URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n// 中央*右\n// \n// 所用時間: 1h\n// BFSで解きました、キューの使い方について理解が深まりました。\n\n#include <iostream>\n#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint W, H,stX, stY, curX, curY, buffX, buffY;\nstring buff, FD[25];\nqueue<int> Qx, Qy;\n\nbool isRed(int x, int y){ //(x,y)が赤か?\n    return FD[y][x] == '#';\n}\n\nbool inField(int x, int y){ //(x,y)がフィールド内か?\n    return 0 <= x && x <= (W-1) && 0 <= y && y <= (H-1);\n}\n\nvoid solve(){\n    int cnt = 0;\n    bool Checked[25][25]={};\n    Qx.push(stX);\n    Qy.push(stY);\n    cnt++;\n    Checked[stY][stX] = true;\n\n    while(!Qx.empty()){ //キューが空になるまで\n        curX = Qx.front(); curY = Qy.front();\n        Qx.pop(); Qy.pop();\n        // printf(\"(curX, curY) = (%d, %d)\\n\", curX, curY);\n\n        for(int i = 0; i < 4; i++){//現在地の周囲4マスについて\n            buffX = curX + dx[i]; buffY = curY + dy[i];\n            if(inField(buffX, buffY) && !isRed(buffX, buffY) && !Checked[buffY][buffX]){ //未調査で移動可能であれば\n                Qx.push(buffX); Qy.push(buffY);\n                Checked[buffY][buffX] = true;\n                cnt++;\n            }\n        }\n    }\n    cout << cnt << endl;\n}\n\nint main(){\n    while(cin >> W >> H && W){\n        for(int i = 0; i < H; i++){\n            cin >> buff;\n            FD[i] = buff;\n            for(int j = 0; j < buff.size(); j++){\n                    if(buff[j]=='@'){ //スタート地点を見つけたら記録する\n                        stX = j;\n                        stY = i;\n                        // printf(\"(stX, stY) = (%d, %d)\\n\", stX, stY);\n                    }\n                }\n            }\n    solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nstruct P {\n    using T = int;\n    T y, x;\n\n    P(T _y = 0, T _x = 0) :y(_y), x(_x) {}\n\n    inline bool operator == (P p) const { return y == p.y && x == p.x; }\n    inline bool operator < (P p) const { return y == p.y ? x < p.x : y < p.y; }\n    inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n    inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n    inline P operator+=(P p) { y += p.y; x += p.x; return *this; }\n    inline P operator-=(P p) { y -= p.y; x -= p.x; return *this; }\n};\n\n\n\ntemplate<typename T>\n// using T = int;\nstruct F {\n    int height, width;\n    vector<T> data;\n\n    F(int h = 1, int w = 1) :height(h), width(w), data(h*w) {}\n\n    inline T& operator()(int y, int x) { return data[x + y * width]; }\n    inline T& operator()(P p) { return data[p.x + p.y * width]; }\n    inline T operator()(int y, int x) const { return data[x + y * width]; }\n    inline T operator()(P p) const { return data[p.x + p.y * width]; }\n\n    inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n    inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n    inline void fill(T e) { std::fill(ALL(data), e); }\n    inline void resize(int h, int w) { height = h; width = w; data.resize(h*w); }\n\n    void print(ostream& os, int setw_arg = 4) {\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x)\n                os << setw(setw_arg) << operator()(y, x) << ' ';\n            os << '\\n';\n        }\n    }\n};\n\n\nint moving[][2] = { {0,1},{1,0},{-1,0},{0,-1} };\n\n\nint solve() {\n    int H, W;\n    scanner >> W >> H;\n\n    if (H == 0 && W == 0) return 1;\n\n    F<int> field(H, W);\n    P start;\n\n    repeat(y, H) {\n        string str;\n        scanner >> str;\n        repeat(x, W) {\n            field(y, x) = !(str[x] == '#');\n            if (str[x] == '@') start = P(y, x);\n        }\n    }\n\n    queue<P> q;\n    q.push(start);\n    field(start) = 0;\n\n    ll ans = 1;\n\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        for (auto mv : moving) {\n            int vy = mv[0], vx = mv[1];\n            if (field.safe(p + P(vy, vx)) && field(p + P(vy, vx))) {\n                q.push(p + P(vy, vx));\n                ans += 1;\n                field(p + P(vy, vx)) = 0;\n            }\n        }\n    }\n\n    printer << ans << '\\n';\n    return 0;\n}\n\n\nint main() {\n\n    while (!solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\nusing P = pair<int, int>;\n\nint map[22][22];\n\nP dirs[] = {P(1, 0), P(-1, 0), P(0, 1), P(0, -1)};\n\nint dfs(int h, int w) {\n    if (!map[h][w]) return 0;\n    map[h][w] = 0;\n    int ans = 0;\n    for (P dir : dirs) {\n        ans += dfs(h + dir.first, w + dir.second);\n    }\n    return ans + 1;\n}\n\nint main() {\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) break;\n\n        for (int i = 0; i < 22; ++i)\n            for (int j = 0; j < 22; ++j)\n                map[i][j] = 0;\n        \n        int pw, ph;\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 1; j <= w; ++j) {\n                char c;\n                cin >> c;\n                if (c == '.') map[i][j] = 1;\n                if (c == '@') { \n                    map[i][j] = 1;\n                    ph = i;\n                    pw = j;\n                }\n            }\n        }\n        cout << dfs(ph, pw) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 2000000000\n#define MOD 1000000007\n#define EPS (1e-10)\n\nusing namespace std;\n\n\nvector<int>  dx = {1,-1,0,0};\nvector<int>  dy = {0,0,1,-1};\n\nint ans = 0;\nint W,H;\n\nbool in_range(int x,int y) {\n\tif (0 <= x and x < W and 0 <= y and y < H) {\n\t\treturn true;\n\t}else {\n\t\treturn false;\n\t}\n}\nint dfs(vector<string> &tab,int x, int y) {\n\tint ret = 0;\n\tif (tab[y][x] == '#' or tab[y][x] == '/') return  0;\n\tif (tab[y][x] == '.') {\n\t\tret += 1;\n\t\ttab[y][x] = '/';\n\t}\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (in_range(nx,ny)) {\n\t\t\tret += dfs(tab,nx,ny);\t\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid printv(vector<string> v){\n\tfor(int i = 0; i < v.size(); i++){\n\t\tcout << v[i] << endl;\n\t}\n}\n\nint main() {\n\t\n\twhile(1) {\n\t\tcin >> W >> H;\n\t\tif (W + H == 0) break;\n\t\tint x,y;\n\t\tvector<string> tab;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tstring s; cin >> s;\n\t\t\ttab.push_back(s);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (tab[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printv(tab);\n\t\tcout << dfs(tab,x,y) + 1 << endl;\n\t\t//printv(tab);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nsigned main()\n{\n    int h, w;\n    while(cin>>w>>h, w) {\n        char field[h+1][w+1];\n        int sx, sy;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                char c;\n                cin >> c;\n                if(c=='@') {\n                    sx = i;\n                    sy = j;\n                }\n                field[i][j] = c;\n            }\n        }\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(sx, sy));\n        int ans = 0;\n        while(!q.empty()) {\n            ans++;\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first;\n            int y = p.second;\n            for(int i=0; i<4; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(nx>=0&&nx<h&&ny>=0&&ny<w&&field[nx][ny]=='.') {\n                    q.push(make_pair(nx, ny));\n                    field[nx][ny] = '#';\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint ans,w,h,f;\nstring m[25];\nvoid solve(int x,int y){\n  if(x<0 || y<0 || x>=h || y>=w) return;\n  if(m[x][y]=='#') return;\n  m[x][y]='#';\n  ans++;\n  solve(x+1,y);\n  solve(x-1,y);\n  solve(x,y+1);\n  solve(x,y-1);\n}\nint main(void){\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h) break;\n    for(int i=0;i<h;i++) cin >> m[i];\n    ans=0;\n    f=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(m[i][j]=='@'){\n\t  solve(i,j);\n\t  f=1;\n\t  break;  \n\t}\n      }\n      if(f) break;\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nbool check[22][22];\nchar c[22][22];\nint w,h;\n\nint recursion(pair<int,int> pos){\n  if(c[pos.first][pos.second]=='#'){return 0;}\n  if(check[pos.first][pos.second]){return 0;}\n  check[pos.first][pos.second]=true;\n  int count=1;\n  if(pos.first>0){\n    count+=recursion(make_pair(pos.first-1,pos.second));\n  }\n  if(pos.second>0){\n    count+=recursion(make_pair(pos.first,pos.second-1));\n  }\n  if(pos.first<w-1){\n    count+=recursion(make_pair(pos.first+1,pos.second));\n  }\n  if(pos.second<h-1){\n    count+=recursion(make_pair(pos.first,pos.second+1));\n  }\n  return count;\n}\n\nint main(){ _;\n  pair<int,int> pos;\n  while(cin>>w>>h,!(w==0&&h==0)){\n    REP(y,h)REP(x,w){\n      cin>>c[x][y];\n      check[x][y]=false;\n      if(c[x][y]=='@')\n\tpos=make_pair(x,y);\n    }\n    cout<<recursion(pos)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nchar a[21][21];\nint dfs(int i,int j){\n    if(i==h||j==w||i<0||j<0)return 0;\n    if(a[i][j]=='#')return 0;\n    int s=1;\n    a[i][j]='#';\n    s+=dfs(i+1,j);\n    s+=dfs(i-1,j);\n    s+=dfs(i,j+1);\n    s+=dfs(i,j-1);\n    return s;\n}\nint main(){\n    int i,j;\n    while(cin>>w>>h,w!=0&&h!=0){\n    for(i=0;i<h;i++)cin>>a[i];\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='@')cout<<dfs(i,j)<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint main(){\n  int W, H;\n  while(cin >> W >> H && W>0 && H>0){\n    int map[20][20];\n    for(int i=0;i<20;i++)\n      for(int j=0;j<20;j++)\n        map[i][j]=0;\n    int at[2];\n\n    for(int i=0;i<H;i++){\n      string s;\n      cin >> s;\n      for(int j=0;j<W;j++){\n        map[i][j]=(s[j]=='.'?1:(s[j]=='@'?2:0));\n        if(s[j]=='@'){\n          at[0]=i; at[1]=j;\n        }\n      }\n    }\n\n    vector<int> list[400];  //??£??\\?????????????????????????????????20*i+j?????????\n    for(int i=0;i<400;i++){\n      if(i>=20) //???\n        if(map[i/20-1][i%20]>0) list[i].push_back(i-20);\n      if(i%20>0) //???\n        if(map[i/20][(i-1)%20]>0) list[i].push_back(i-1);\n      if(i%20<19) //???\n        if(map[i/20][(i+1)%20]>0) list[i].push_back(i+1);\n      if(i<180) //???\n        if(map[i/20+1][i%20]>0) list[i].push_back(i+20);\n    }\n\n    bool d[400];\n    for(int i=0;i<400;i++) d[i]=false;\n\n    stack<int> cur;\n    cur.push(at[0]*20+at[1]);\n    d[at[0]*20+at[1]]=true;\n\n    while(!cur.empty()){\n      bool flg=false;\n      for(vector<int>::iterator it=list[cur.top()].begin();it!=list[cur.top()].end();it++){\n        if(!d[*it]){\n          flg=true;\n          cur.push(*it);\n          d[*it]=true;\n          break;\n        }\n      }\n      if(flg) continue;\n      cur.pop();\n    }\n\n    int cnt=0;\n    for(int i=0;i<400;i++)\n      if(d[i]) cnt++;\n\n    cout << cnt << endl;\n  }\n\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <math.h>\n\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\ntemplate<class T> using hset = unordered_set<T>;\ntemplate<class Key, class T> using hmap = unordered_map<Key, T>;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nbool isOutOfBounds(int y, int x, int h, int w) {\n    return y < 0 || y >= h || x < 0 || x >= w;\n}\n\nint main() {\n    int W, H;\n    vs room;\n\n    int sy, sx;\n    while (cin >> W >> H) {\n        if (W == 0) break;\n\n        room.resize(H);\n        REP(y, H) {\n            cin >> room[y];\n            REP(x, W) {\n                if (room[y][x] == '@') { sy = y; sx = x; room[y][x] = '#'; }\n            }\n        }\n\n        queue<int> que;\n        que.push(sy);\n        que.push(sx);\n        int y, x, cnt=1;\n        while (!que.empty()) {\n            y = que.front(); que.pop();\n            x = que.front(); que.pop();\n\n            for (int i=0; i<4; i++) {\n                if (isOutOfBounds(y+dy[i], x+dx[i], H, W)) continue;\n                if (room[y+dy[i]][x+dx[i]] == '#') continue;\n\n                cnt++;\n                room[y+dy[i]][x+dx[i]] = '#';\n                que.push(y+dy[i]);\n                que.push(x+dx[i]);\n            }\n        }\n\n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\nusing namespace std;\nchar field[21][21];\nchar visit[21][21];\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nint W,H;\nvoid dfs(int y, int x){\n  visit[y][x] = 1;\n  rep(i,4){\n    int ny = y+dy[i];\n    int nx = x+dx[i];\n    if(field[ny][nx] == '.'\n       && visit[ny][nx] == 0\n       && nx >= 0\n       && nx < W\n       && ny >= 0\n       && ny < H){\n          dfs(ny,nx);\n        }\n  }\n}\nint main(){\n  while(cin >> W >> H && W){\n    int y,x;\n    rep(i,H){\n      rep(j,W){\n        cin >> field[i][j];\n        if(field[i][j] == '@') y=i,x=j;\n      }\n    }\n    memset(visit,0,sizeof(visit));\n    dfs(y,x);\n    int ans = 0;\n    rep(i,H){\n      rep(j,W){\n        ans += visit[i][j];\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\n\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\nint W, H;\nstring mem[20];\nbool res[20][20];\n\nint dfs(int sx, int sy)\n{\n  for(int i = 0; i < 20; i++)\n    for(int j = 0; j < 20; j++)\n      res[i][j] = 0;\n  queue<int> q;\n  q.push(sx);\n  q.push(sy);\n  while(!q.empty())\n  {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n    res[y][x] = true;\n    for(int i = 0; i < 4; i++)\n    {\n      \n      int tx = x + dx[i];\n      int ty = y + dy[i];\n      if(tx >= 0 && ty >= 0 && tx < W && ty < H && mem[ty][tx] == '.' && !res[ty][tx])\n      {\n        q.push(tx);\n        q.push(ty);\n      }\n    }\n  }\n  int ans = 0;\n  for(int y = 0; y < H; y++)\n    for(int x = 0; x < W; x++)\n      ans += res[y][x];\n  return ans;\n}\n\nint main()\n{\nloop:\n  for(int i = 0; i < 20; i++)\n    mem[i] = \"\";\n  int sx = -1, sy;\n  cin >> W >> H;\n  if(!(W || H))\n    return 0;\n  for(int i = 0; i < H; i++)\n  {\n    cin >> mem[i];\n    if(sx != -1)\n      continue;\n    for(int j = 0; j < W; j++)\n    {\n      if(mem[i][j] == '@')\n      {\n        sx = j;\n        sy = i;\n        break;\n      }\n    }\n  }\n  cout << dfs(sx, sy) << endl;\n  goto loop;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint w,h;\nstring data[50];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nint ans;\n\nvoid solve(int y, int x){\n\n  if(y < 0 || x < 0 || y == h || x == w) return;\n  if(data[y][x] == '#') return;\n\n  data[y][x] = '#';\n  ans++;\n\n  for(int i=0;i<4;i++) solve(y+dy[i], x+dx[i]);\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++) cin >> data[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(data[i][j] == '@') ans = 0, solve(i, j); //y,x\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define endll '\\n'\n#define ll long long\n\nconst int crow = 25;\nbool visited [crow][crow];\nstring tiles[crow];\nint row, col, cnt;\n\nvoid dfs (int posx, int posy) {\n    if (posx < 0 || posy < 0 || posx >= col || posy >= row || visited [posy][posx] || tiles[posy][posx] == '#')\n        return;\n    visited [posy][posx] = true;\n    cnt++;\n    dfs (posx-1, posy);\n    dfs (posx+1, posy);\n    dfs (posx, posy-1);\n    dfs (posx, posy+1);\n}\n\n\nint main () {\n\n    cin  >> col >> row;\n    while (row && col) {\n        int posx = 0, posy = 0;\n        for (int j = 0; j < row; j++) {\n            cin >> tiles[j];\n            for (int i = 0; i < col; i++) {\n                visited [j][i] = false;\n                if (tiles[j][i] == '@') {\n                    posx = i;\n                    posy = j;\n                    //visited [j][i] = true;\n                }\n            }\n        }\n        cnt = 0;\n        dfs (posx, posy);\n        cout << cnt << endll;\n        cin  >> col >> row;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[20][20] = {} ;\nint cnt,w, h, p[20][20] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 400; i++) {\n\t\t\tc[i / 20][i % 20] = p[i / 20][i % 20] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j][i] = 0;\n\t\t\t\t\tp[j][i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j][i] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1 || p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\tf = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j][i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h][i%h] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 10007;\nstatic const int INF = 1 << 25;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { 1, -1, 0, 0 };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint W, H, a, b, ans;\nVS mp;\nstring str;\n\nint gcd( int m, int n ) {\n\tif ( n == 0 ) return m;\n\treturn gcd( n, m % n );\n}\n\n\nint main() {\n\twhile ( ~scanf(\"%d %d\", &W, &H) && W && H ) {\n\t\tfor ( int i = 0; i < W + 2; i++ ) {\n\t\t\tstr += \"#\";\n\t\t}\n\t\tans = 0;\n\t\tmp.resize( H + 2 );\n\t\tmp[ 0 ] = str;\n\t\tmp[ H + 1 ] = str;\n\t\tfor ( int i = 1; i < H + 1; i++ ) {\n\t\t\tcin >> str;\n\t\t\tstr = \"#\" + str + \"#\";\n\t\t\tmp[ i ] = str;\n\t\t\tfor ( int j = 1; j < W + 2; j++ ) {\n\t\t\t\tif ( mp[ i ][ j ] == '@' ) {\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<PII> q;\n\t\tq.push( PII( a, b ) );\n\t\twhile ( q.size() ) {\n\t\t\tint y = q.front().first;\n\t\t\tint x = q.front().second;\n\t\t\tif ( mp[ y ][ x ] == '#' ) {\n\t\t\t\tq.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmp[ y ][ x ] = '#';\n\t\t\tans++;\n\t\t\tq.pop();\n\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\tif ( mp[ y + dy[ i ] ][ x + dx[ i ] ] != '#' ) {\n\t\t\t\t\tq.push( PII( y + dy[ i ], x + dx[ i ] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t\tstr.clear();\n\t\tmp.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nbool used[25][25];\nint s;\nint n,m;\n\nvoid check(int x,int y){\n\tif(x<0 || n<=x || y<0 || m<=y)return;\n\tif(used[x][y])return;\n\tused[x][y]=true,s++;\n\tcheck(x+1,y);\n\tcheck(x-1,y);\n\tcheck(x,y+1);\n\tcheck(x,y-1);\n}\n\nint main(){\n\tint i,j,k;\n\tint a,b,c;\n\tint x,y;\n\tchar ca[26];\n\twhile(cin>>m>>n){\n\t\tif(!n)break;\n\t\tmemset(used,false,sizeof(used));\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>ca;\n\t\t\tfor(j=0;j<m;j++){\n\t\t\t\tif(ca[j]=='#')used[i][j]=true;\n\t\t\t\tif(ca[j]=='@')x=i,y=j;\n\t\t\t}\n\t\t}\n\t\ts=0;\n\t\tcheck(x,y);\n\t\tcout<<s<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst ll infll = (1LL << 61) - 1;\n#define fast() ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define digit(N) cout << fixed << setprecision((N))\n\nint H, W;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main()\n{\n    while (cin >> H >> W)\n    {\n        if (H == 0 && W == 0)\n            return 0;\n        vector<string> grid(W);\n\n        pair<int, int> s;\n        for (int i = 0; i < W; i++)\n        {\n            cin >> grid[i];\n            for (int j = 0; j < H; j++)\n            {\n                if (grid[i][j] == '@')\n                    s = {i, j};\n            }\n        }\n\n        queue<pair<int, int>> que;\n        que.push(s);\n\n        vector<vector<int>> visited(W, vector<int>(H));\n\n        visited[s.first][s.second] = 1;\n\n        while (!que.empty())\n        {\n            auto p = que.front();\n            que.pop();\n\n            visited[p.first][p.second] = 1;\n            for (int i = 0; i < 4; i++)\n            {\n                int nx = p.first + dx[i], ny = p.second + dy[i];\n                if (nx < 0 || nx >= W)\n                    continue;\n                if (ny < 0 || ny >= H)\n                    continue;\n                if (visited[nx][ny])\n                    continue;\n                if (grid[nx][ny] == '.')\n                    que.push({nx, ny});\n            }\n        }\n\n        int ans = 0;\n\n        for (int i = 0; i < W; i++)\n        {\n            for (int j = 0; j < H; j++)\n            {\n                ans += visited[i][j];\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass DoubleArray {\n    int X,Y;\n    int *top;\n    public:\n    DoubleArray(int *p,int x,int y);\n    int *operator[](int i);\n    int getx();\n    int gety();\n};\n\nDoubleArray::DoubleArray(int *p,int x,int y){\n    top = p;\n    X = x;\n    Y = y;\n}\n\nint *DoubleArray::operator[](int i){\n    return top + Y*i;\n}\nint DoubleArray::getx(){\n    return X;\n}\nint DoubleArray::gety(){\n    return Y;\n}\n\nint calc(DoubleArray &map){\n    int i,j,a=0;\n    int x = map.getx();\n    int y = map.gety();\n    queue<int> q;\n    for(i=0;i<x;i++){\n        for(j=0;j<y;j++){\n            if(map[i][j]==2){\n                q.push(i);\n                q.push(j);\n                a=1;\n                map[i][j]=0;\n            }\n        }\n    }\n    while(!q.empty()){\n        i=q.front();\n        q.pop();\n        j=q.front();\n        q.pop();\n        if(i>0) if(map[i-1][j]==1){\n            q.push(i-1);\n            q.push(j);\n            a++;\n            map[i-1][j]=0;\n        }\n        if(j>0) if(map[i][j-1]==1){\n            q.push(i);\n            q.push(j-1);\n            a++;\n            map[i][j-1]=0;\n        }\n        if(i<x-1) if(map[i+1][j]==1){\n            q.push(i+1);\n            q.push(j);\n            a++;\n            map[i+1][j]=0;\n        }\n        if(j<y-1) if(map[i][j+1]==1){\n            q.push(i);\n            q.push(j+1);\n            a++;\n            map[i][j+1]=0;\n        }\n    }\n    return a;\n}\n\nint main(){\n    int i,j,x,y,a[10000],b = 0;\n    string c;\n    for(b=0; b<10000; b++){\n        cin >> x;\n        cin >> y;\n        if(x==0&&y==0) break;\n        if(x>20) x=20;\n        if(y>20) y=20;\n        if(x<1||y<1) continue;\n        int m[x][y];\n        DoubleArray map(&m[0][0],x,y);\n        for(j=0;j<y;j++){\n            for(i=0;i<x;i++){\n                cin >> c;\n                if(c==\"#\") map[i][j]=0;\n                if(c==\".\") map[i][j]=1;\n                if(c==\"@\") map[i][j]=2;\n            }\n        }\n        a[b] = calc(map);\n    }\n    for(i=0;i<b;i++){\n        cout << a[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 金子先生へ\n// ITC-LMSの「第9回提出物」の提出期間が6/23までで、期間後の提出が不可になっています。\n// しかし月曜までに今回の課題全部は解き終わらないので、いつもの様に7月末までにしてくださると幸いです。\n// 多分、今回の課題は全部解けそうです。\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility> // pair<int,int> xxxx;  make_pair(first,second);\nusing namespace std;\n\nint W,H;\nint X,Y; // 自分の位置\nchar s[20+10];\nchar c;\nbool tile[20+10][20+10]; // タイルの状態。trueは黒、falseは赤(または壁)。\nbool visited[20+10][20+10];\nint answer;\n\n// 右、上、左、下\nconst int dx[4] = { 1, 0, -1, 0 }; \nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool valid (int x, int y) {\n  return 0 <= x && x < H && 0 <= y && y < W && tile[x][y] ;\n}\n\nvoid init() { // 初期化\n  fill(&tile[0][0], &tile[0][0]+20*20, 0);\n  fill(&visited[0][0], &visited[0][0]+20*20, 0);\n  answer = 0;\n}\n\nvoid make_tile() { // タイル読み込み\n  for (int i=0; i<H; i++) {\n    scanf(\"%s\", s);\n    for (int j=0; j<W; j++) {\n      c = s[j];\n      if (c == '.') {\n\ttile[i][j] = true;\n      } else if (c == '#') {\n\ttile[i][j] = false;\n      } else if (c == '@') {\n\ttile[i][j] = true;\n\tX = i;\n\tY = j;\n      }\n    }\n  }\n}\n\nvoid count_tile() {\n  queue<pair<int,int>> Q; // 幅優先探索を使う。特に理由はないが、周辺から徐々に探査する感じになるのでイメージしやすい。\n  pair<int,int> cur = make_pair(X,Y);\n  Q.push(cur);\n  while (!Q.empty()) {\n    cur = Q.front();\n    Q.pop();\n    if (visited[cur.first][cur.second]) {\n      continue;\n    }\n    visited[cur.first][cur.second] = true;\n    answer++;\n    for (int i=0; i<4; i++) {\n      int a = cur.first+dx[i];\n      int b = cur.second+dy[i];\n      if (valid(a, b) && !visited[a][b]) {\n\tQ.push(make_pair(a, b));\n      }\n    }\n  }\n  printf(\"%d\\n\", answer);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &W, &H) && W && H) {\n    init();\n    make_tile();\n    count_tile();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\nvoid search(int h, int w, int tairu[22][22], int check[22][22]){\n    if(check[h][w]==1)return;\n    if(tairu[h][w]==0)return;\n    \n    check[h][w]=1;\n    search(h+1,w,tairu,check);\n    search(h-1,w,tairu,check);\n    search(h,w+1,tairu,check);\n    search(h,w-1,tairu,check);\n}\n\n\n\n\n\n\nint main()\n{\n\n    int H,W;\n    while(cin>>W>>H){\n        if(W==0&&H==0)break;\n        int tairu[22][22]={0};\n        int start_w, start_h;\n        for(int i=1; i<=H; i++){\n            for(int j=1; j<=W; j++){\n                char input;\n                cin>>input;\n                if(input=='.')tairu[i][j]=1;\n                if(input=='@'){\n                    tairu[i][j]=1;\n                    start_w=j;\n                    start_h=i;\n                }\n            }\n        }\n        //\n        \n        int check[22][22]={0};\n        search(start_h, start_w, tairu, check);\n        int ans=0;\n        for(int i=1; i<=H; i++){\n            for(int j=1; j<=W; j++){\n                ans+=check[i][j];\n            }\n        }\n        cout<<ans<<endl;\n        \n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define inRange(x, y, w, h) (0 <= x && x < w && 0 <= y && y < h)\n\nusing namespace std;\n\nint h, w;\nint dx[] = { 0, 0, -1, 1 }; \nint dy[] = { -1, 1, 0, 0 };\n\nvoid search( int x, int y, char map[20][20] )\n{\n\tmap[y][x] = '@';\n\tfor(int i=0; i < 4; ++i) {\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif(inRange(mx, my, w, h) && map[my][mx] == '.') {\n\t\t\tsearch(mx, my, map);\n\t\t}\n\t}\n}\n\nint main( void )\n{\n\tchar map[20][20];\n\n\twhile(cin >> w >> h, w | h) {\n\t\tint sx, sy;\n\t\tfor(int y=0; y < h; ++y)\n\t\t\tfor(int x=0; x < w; ++x) {\n\t\t\t\tcin >> map[y][x];\n\t\t\t\tif(map[y][x] == '@') {\n\t\t\t\t\tsx = x;\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\tsearch(sx, sy, map);\n\t\tint count = 0;\n\t\tfor(int y=0; y < h; ++y)\n\t\t\tfor(int x=0; x < w; ++x) {\n\t\t\t\tif(map[y][x] == '@') ++count;\n\t\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX (256)\nusing namespace std;\n\nint N, M;\nchar field[MAX][MAX];\nint sx, sy;\nint ans = 0;\n\nint dx[4]= {1, 0, -1 ,0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs (int x, int y){\n\tif(0 <= x && x < N && 0 <= y && y < M && field[x][y] == '.'){\n\t\tfield[x][y] = '#';\n\t\tans++;\n\t\t\n\t\tfor(int i =0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tdfs(nx, ny);\n\t\t\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(1){\n\tans = 0;\n\tcin >> M >> N;\n\t\n\tif(M == 0 && N == 0) break;\n\t\n\tfor(int i =0; i < N; i++){\n\t\tfor(int j =0; j < M; j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i =0; i < N; i++){\n\t\tfor(int j =0; j < M; j++){\n\t\t\tif(field[i][j] == '@'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t\tfield[sx][sy] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tdfs(sx, sy);\n\t\n\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nusing namespace std;\n\nint d4x[] = {0, 1, 0, -1};\nint d4y[] = {-1, 0, 1, 0};\n\nint W, H;\nint reachable(vector<string>& map, int x, int y){\n  //cout << x << \",\" << y << endl;\n  int res = 0;\n  rep(i, 4){\n    int sx = d4x[i] + x, sy = d4y[i] + y;\n    if(0 <= sx && sx < W && 0 <= sy && sy < H){\n      if(map[sy][sx] != '#'){\n        map[sy][sx] = '#';\n        res += reachable(map, sx, sy) + 1;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> W >> H, W != 0){\n    vector<string> map(H);\n    rep(i, H) cin >> map[i];\n    int gy, gx;\n    rep(y, H) {\n      rep(x, W) {\n        if (map[y][x] == '@'){\n          gy = y; gx = x;\n          break;\n        }\n      }\n    }\n    //cout << \"OK\" << endl;\n    cout << reachable(map, gx, gy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool b[21][21];\nint w,h,count=0;\n\nvoid dfs(int x, int y){\n b[y][x]=1;count++;\n int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=dx[i]+x;\n  ny=dy[i]+y;\n  if(0<=nx&&nx<w&&0<=ny&&ny<h)\n   if(b[ny][nx]==0)dfs(nx,ny);\n  }\n }\n\nint main(){\nchar a;\nint sx,sy;\nwhile(1){\ncin>>w>>h;\ncount=0;\nb[21][21]={};\nfor(int i=0;i<h;i++)\nfor(int j=0;j<w;j++){\ncin>>a;\nif(a=='#')b[i][j]=1;\nif(a=='@'){sx=j;sy=i;}\n}\ndfs(sx,sy);\ncout<<count<<endl;\n}\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nツ個ゥツづ按づェツつスツ姪「ツ妥ィツづ?つキツづ?\n'@'ツづ個湘ェツ渉環つゥツづァ, ツ深ツつウツ優ツ静ヲツ探ツ催オツづ?嘉ーツつォツづ慊つオツづ・ツつ、.\n */\n#include <iostream>\nusing namespace std;\n\nint w, h;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nchar t[22][22];\n\nint solve(int x, int y){\n  int res = 1;\n\n  t[y][x] = '#';\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && t[ny][nx] != '#'){\n      res += solve(nx, ny);\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    int sx, sy;\n\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == '@'){\n          sy = i;\n          sx = j;\n          t[i][j] = '.';\n        }\n      }\n    }\n\n    cout << solve(sx, sy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint W,H;\nvoid solve(int,int);\nchar dfs[20][20];\nint d_x[]={1,0,-1,0},d_y[]={0,1,0,-1};\n\nint main(){\n\t\n\twhile(1){\n\t\tint ans=0;\n\t\tcin>>W>>H;\n\t\tif(W==0&&H==0)\tbreak;\n\n\t\tint dx,dy;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>dfs[j][i];\n\t\t\t\tif(dfs[j][i]=='@'){\n\t\t\t\t\tdx=j;\n\t\t\t\t\tdy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(dx,dy);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(dfs[j][i]=='T')\n\t\t\t\t\tans++;\n\t\tcout<<ans<<endl;\n\t\tmemset(dfs,0,sizeof(dfs));\n\t}\n}\n\nvoid solve(int x,int y){\n\tdfs[x][y]='T';\n\t\n\tfor(int j=0;j<4;j++){\n\t\tint mx=x+d_x[j],my=y+d_y[j];\n\t\tif(mx<0||my<0||mx>W||my>H)\tcontinue;\n\t\tif(dfs[mx][my]=='.')\n\t\t\tsolve(mx,my);\n\t}\n\treturn ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n//ranker\nusing namespace std;\n\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing pis = pair<int, string>;\nusing psi = pair<string, int>;\nusing D = double;\n\nvoid merge (int *first1, int *last1, int *first2, int *last2){\n    int size1 = last1 - first1;\n    int size2 = last2 - first2;\n    int *result = new int[size1+size2];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    while (true){\n        if (i < size1 && (first1[i] <= first2[j] || j >= size2)){\n            result[index] = first1[i];\n            ++i; ++index;\n        }\n        if (j < size2 && (first1[i] > first2[j] || i >= size1)){\n            result[index] = first2[j];\n            ++j; ++index;\n        }\n        if (i==size1 && j==size2){\n            for (i=0; i<size1; ++i) first1[i] = result[i];\n            for (j=0; j<size2; ++j) first2[j] = result[j+size1];\n            delete[] result;\n            return;\n        }\n    }\n}\nvoid MergeSort (int *first, int *last){\n    int size = last - first;\n    if(size <= 1) return;\n    MergeSort(first, first+size/2);\n    MergeSort(first+size/2, last);\n    merge(first, first+size/2, first+size/2, last);\n}\n\n\nint gcd(int a, int b)\n{\n    int c;\n\n    if (a < b) {\n        a+=b; b=a-b; a-=b;\n    }\n\n    while (b != 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nint dx[3]={-1, 0, 1};\nint dy[3]={-1, 0, 1};\nint W, H;\nchar masu[20][20];\nint cnt;\n\nint dfs(int a, int b){\n  masu[a][b] = '#';\n  cnt++;\n  REP(i, 3)REP(j, 3) if(masu[a+dx[i]][b+dy[j]]=='.' && abs(dx[i]+dy[j])==1) dfs(a+dx[i], b+dy[j]);\n  return cnt;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    REP(j, H)REP(i, W) cin >> masu[i][j];\n\n    int i0, j0;\n    REP(j, H)REP(i, W) if(masu[i][j] == '@'){\n      i0=i;\n      j0=j;\n      break;\n    }\n\n    cnt = 0;\n    cnt = dfs(i0, j0);\n    cout << cnt << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w){\n\t\tvector<string> cell(h);\n\t\tint sx=-1, sy;\n\t\tREP(i, h){\n\t\t\tcin >> cell[i];\n\t\t\tif (sx==-1)\n\t\t\tREP(j, w){\n\t\t\t\tif (cell[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tcell[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>> Q;\n\t\tQ.push(pair<int, int>(sx, sy));\n\t\tint ans = 0;\n\t\twhile (!Q.empty()){\n\t\t\tans++;\n\t\t\tpair<int, int> p = Q.front(); Q.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tif (0 <= p.first + dx[i] && p.first + dx[i] < w && 0 <= p.second + dy[i] && p.second + dy[i] < h&&cell[p.second + dy[i]][p.first + dx[i]] == '.'){\n\t\t\t\t\tcell[p.second + dy[i]][p.first + dx[i]] = '#';\n\t\t\t\t\tQ.push(pair<int, int>(p.first + dx[i], p.second + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef vector <string> VS;\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int, LL> PIL;\ntypedef vector <PIL> VPIL;\n\n\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define sort(c) sort((c).begin(),(c).end())\n\n#define range(i,a,b) for(int i=(a); i < (b); i++)\n#define rep(i,n) range(i,0,n)\n\n#define MAX_INT 2147483647\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint result; \nstring field[20];\nvoid dfs(int hx, int hy, int Lx, int Ly, int Ux, int Uy){\n\tint nx, ny;\n\tif(field[hy][hx] != '#'){\n\t\tresult++;\n\t\tfield[hy][hx] = '#';\n\t\trep(i,4){\n\t\t\tnx = hx + dx[i]; ny = hy + dy[i];\n\t\t\tif (Lx <= nx && nx < Ux && Ly <= ny && ny < Uy) \n\t\t\t\tdfs(nx, ny, Lx, Ly, Ux, Uy);\n\t\t}\n\t}\n}\nint main(){\n\tint W, H;\n\twhile (1){\n\t\tcin >> W >> H;\n\t\tif (!(W and H)) break;\n\t\tresult = 0;\n\t\trep(i,H) cin >> field[i];\n\t\trep(i,H) rep(j,W) if (field[i][j] == '@') dfs(j,i,0,0,W,H);\n\t\t\t\tcout << result << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint h, w, ans;\nchar field[25][25];\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y) {\n  if(field[y][x] == '.' && 0 <= x && x < w && 0 <= y && y < h) {\n    field[y][x] = '#';\n    ans++;\n    for(int i = 0; i < 4; i++) {\n      int nx = x+dx[i], ny = y+dy[i];\n      dfs(nx, ny);\n    }\n  }\n}\n\nint main() {\n  int sx, sy;\n  while(cin >> w >> h, w+h) {\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> field[i][j];\n\tif(field[i][j] == '@') {\n\t  sx = j;\n\t  sy = i;\n\t  field[i][j] = '.';\n\t}\n      }\n    }\n\n    ans = 0;\n    dfs(sx, sy);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint used[23][23];\nint answer;\nint h,w;\nstring s[23];\n\nvoid dfs(int y,int x){\n  answer++;\n  used[y][x] = 1;\n  \n  if( y-1 >= 0 && used[y-1][x]==0 && s[y-1][x]!='#') dfs( y-1,x );\n  \n  if( y+1 <  h && used[y+1][x]==0 && s[y+1][x]!='#') dfs( y+1,x );\n  \n  if( x-1 >= 0 && used[y][x-1]==0 && s[y][x-1]!='#') dfs( y,x-1 );\n  \n  if( x+1 <  w && used[y][x+1]==0 && s[y][x+1]!='#') dfs( y,x+1 );\n}\n\nint main(){\n  \n  while( cin>>w>>h,w){\n    \n    int y,x;\n\n    answer = 0;\n    \n    memset( used,0,sizeof(used) );\n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='@'){\n\t  y = i;\n\t  x = j;\n\t}\n      }\n    }    \n    dfs(y,x);\n    cout<< answer <<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <queue>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w; cin >> w >> h, w | h;){\n\t\tVVI table(h, VI(w));\n\t\tPII goal;\n\t\tREP(i, h){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tREP(j, w){\n\t\t\t\tchar letter = line[j];\n\t\t\t\tint value = 0;\n\t\t\t\tif(letter == '@'){\n\t\t\t\t\tgoal = MP(i, j);\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}else if(letter == '#'){\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}\n\t\t\t\ttable[i][j] = value;\n\t\t\t}\n\t\t}\n\t\tqueue<PII> q;\n\t\tq.push(goal);\n\t\tint total = 1;\n\t\twhile(!q.empty()){\n\t\t\tPII p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.second, y = p.first;\n\t\t\tint cv = table[y][x];\n\t\t\tREP(i, 4){\n\t\t\t\tint dx = x + DX[i];\n\t\t\t\tint dy = y + DY[i];\n\t\t\t\tif(0 <= dx && dx < w &&\n\t\t\t\t\t0 <= dy && dy < h &&\n\t\t\t\t\ttable[dy][dx] == 0){\n\t\t\t\t\ttotal++;\n\t\t\t\t\ttable[dy][dx] = 1;\n\t\t\t\t\tq.push(MP(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar mas[111][111];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint sx,sy;\nint w,h,cou;\n\nint dfs(int x,int y);\nint main(){\n  while(1){\n    cou=0;\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mas[i][j];\n\tif(mas[i][j]=='@'){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    dfs(sx,sy);\n    cout<<cou<<endl;\n  }\n}\nint dfs(int x,int y){\n  mas[y][x]='#';\n  cou++;\n  for(int i=0;i<4;i++){\n    int nextx=x+dx[i];\n    int nexty=y+dy[i];\n    if(0<=nextx && nextx<w && 0<=nexty && nexty<h && mas[nexty][nextx]=='.'){\n      dfs(nextx,nexty);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<numeric>\n#include<stdio.h>\n\nusing std::cout;\nusing std::cout;\nusing std::cin;\nusing std::setw;\nusing std::setfill;\nusing std::string;\nusing std::pair;\nusing std::make_pair;\nusing std::vector;\nusing std::queue;\nusing std::deque;\nusing std::priority_queue;\nusing std::next_permutation;\nusing std::iota;\nusing std::sort;\nusing std::greater;\nusing std::max;\nusing std::min;\n\n#define INF 999999999;\n#define MOD 1000000007\n\nusing ulli = unsigned long long int;\n\n#define EVEL 1\n\n#ifndef EVEL\n#define dbug(X) std::cout << #X << \":\" <<X<<\" \" ;\n#define dbugf(s) std::cout << s << \" \";\n#define dbugln std::cout<<\"\\n\";\n#else\n#define dbug(X) {}\n#define dbugf(s) {}\n#define dbugln {}\n#endif\n\nint W, H;\nint M[21][21];\nint xd[] = {0, 1, 0, -1};\nint yd[] = {-1, 0, 1, 0};\nbool Mf[21][21];\nqueue<int> Q;\n\nint main(){\n\tcin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n    \n    while(1){\n        cin >> W >> H;\n        if(W == 0 && H == 0) break;\n        for(int i = 0; i  < W; i++){\n            for(int j = 0; j < H; j++){\n                M[i][j] = 1;\n                Mf[i][j] = false;\n            }\n        }\n        char c;\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> c;\n                if(c == '.') M[j][i] = 0;\n                else if(c == '#') M[j][i] = 1;\n                else if(c == '@'){\n                    M[j][i]=0;\n                    Q.push(i*W+j);\n                    Mf[j][i] = true;\n                }\n            }\n        }\n\n        int ans = 0;\n        while(!Q.empty()){\n            const int r = Q.front();Q.pop();\n            ans++;\n            int x, y;\n            for(int i = 0; i < 4; i++){\n                x = (r%W) + xd[i];\n                y = (r/W) + yd[i];\n                if(x < 0 || x >= W || y < 0 || y >= H)continue;\n                if(Mf[x][y] || M[x][y]!=0)continue;\n                Q.push(x + y*W);\n                Mf[x][y] = true;     \n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n/*\n6 9\n....#.\n.....#\n......\n......\n......\n......\n......\n#@...#\n.#..#.\n11 9\n.#.........\n.#.#######.\n.#.#.....#.\n.#.#.###.#.\n.#.#..@#.#.\n.#.#####.#.\n.#.......#.\n.#########.\n...........\n11 6\n..#..#..#..\n..#..#..#..\n..#..#..###\n..#..#..#@.\n..#..#..#..\n..#..#..#..\n7 7\n..#.#..\n..#.#..\n###.###\n...@...\n###.###\n..#.#..\n..#.#..\n0 0\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nstruct MapHeader {\n\tint w;\n\tint h;\n};\n\nMapHeader read_header() {\n\tstd::string line;\n\tstd::getline(std::cin, line);\n\tstd::istringstream line_stream(line);\n\tMapHeader result;\n\tline_stream >> result.w >> result.h;\n\treturn result;\n}\n\nstruct SearchContext {\n\tMapHeader header;\n\tstd::vector<bool> map;\n\tsize_t count;\n\n\tSearchContext(MapHeader header)\n\t\t: header(header),\n\t\tcount(0)\n\t{\n\t\tmap.reserve(header.w * header.h);\n\t}\n\n\tsize_t index(int x, int y) {\n\t\treturn (size_t)header.w * y + x;\n\t}\n};\n\nvoid search(SearchContext& context, int x, int y) {\n\tif (x < 0 || x >= context.header.w || y < 0 || y >= context.header.h) return;\n\n\tsize_t index = context.index(x, y);\n\tif (context.map[index]) return;\n\n\tcontext.map[index] = true;\n\tcontext.count++;\n\t\n\tsearch(context, x + 1, y);\n\tsearch(context, x - 1, y);\n\tsearch(context, x, y + 1);\n\tsearch(context, x, y - 1);\n}\n\nint main()\n{\n\twhile (true) {\n\t\tMapHeader header = read_header();\n\t\tif (header.w == 0 && header.h == 0) break;\n\n\t\tSearchContext context(header);\n\t\tint start_x, start_y;\n\n\t\tstd::string line;\n\t\tline.reserve(header.w + 2);\n\n\t\tfor (int y = 0; y < header.h; y++) {\n\t\t\tline.clear();\n\t\t\tstd::getline(std::cin, line);\n\n\t\t\tfor (int x = 0; x < header.w; x++) {\n\t\t\t\tswitch (line[x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tcontext.map.push_back(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tcontext.map.push_back(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tstart_x = x;\n\t\t\t\t\tstart_y = y;\n\t\t\t\t\tcontext.map.push_back(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsearch(context, start_x, start_y);\n\t\tstd::cout << context.count << std::endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w, h;\nchar tile[20][20];\nint cnt = 0;\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nvoid f(int x, int y){\n\ttile[x][y] = '#';\n\tcnt++;\n\tfor (int i = 0; i < 4; i++){\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (tile[X][Y] != '#' && 0 <= X && X < w && 0 <= Y && Y < h){\n\t\t\tf(X, Y);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile (cin >> w >> h, w + h != 0){\n\t\tcnt = 0;\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tcin >> tile[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (tile[x][y] == '@') f(x, y);\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <array>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint height, width;\nint sx, sy;\n\n\nvoid bfs(vector<vector<char>>& field)\n{\n    int ans = 1;\n    array<int, 4> dx = {0, 0, 1, -1};\n    array<int, 4> dy = {1, -1, 0, 0};\n\n    queue<pii> p;\n    p.push({sx, sy});\n    \n    while (!p.empty()) {\n        pii q = p.front(); p.pop();\n        \n        //??????\n        int cx = q.first;\n        int cy = q.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx.at(i);\n            int ny = cy + dy.at(i);\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height \n                    && field.at(ny).at(nx) == '.') {\n\n                ans++;\n                field.at(ny).at(nx) = '#';\n                p.push({nx, ny});\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\nint main()\n{\n    while (cin >> width >> height) {\n        if (height == 0 && width == 0) break;\n\n        vector<vector<char>> field(height, vector<char>(width));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                cin >> field.at(y).at(x);\n\n                if (field.at(y).at(x) == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n\n        bfs(field);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for (int i=(n)-1;i>=0;i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define REPS(i,f,n) for (int i=(f)-1;i>=(n);i--)\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n\nchar board[21][21];\nint w, h;\nint x, y;// ?????¨?????????\n\nvoid slove(void){\n\tint cnt = 0;\n\tqueue<pint> q;\n\tq.push(make_pair(y, x));//?????¨????????????queue?????\\??????\n\n\twhile(!q.empty()){\n\t\tpint now = q.front(); q.pop();\n\t\trep(i, 4){\n\t\t\tint nowy = now.fi + dy[i];\n\t\t\tint nowx = now.se + dx[i];\n\t\t\tif (0 <= nowy <= h - 1 && 0 <= nowx && nowx <= w - 1){\n\t\t\t\tif (board[nowy][nowx] == '.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tboard[nowy][nowx] = 0;\n\t\t\t\t\tq.push(make_pair(nowy, nowx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt + 1);//?§?????????´????????\\??????\n\treturn;\n}\n\nvoid scan(int w, int h){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tcin >> board[i][j];\n\t\t\tif (board[i][j] == '@'){\n\t\t\t\ty = i; x = j;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\t\n\tslove();\n\treturn;\n}\n\nint main(void){\n\trep(i, 1000){\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\t\tscan(w, h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      char fld[H][W];\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      bool visited[H][W];\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)visited[i][j]=0;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         visited[now.first][now.second]=1;\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(visited[ni][nj]) continue;\n            Q.push(pii(ni, nj));\n         }\n      }\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=visited[i][j];\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nbool f[21][21];\nchar tile[21][21];\nint w,h;\n\nint dfs(int x,int y)\n{\n\tif(x < 0 || y < 0 || x >= h || y >= w || f[x][y] || tile[x][y] == '#')return 0;\n\t\n\tf[x][y] = true;\n\n\tint sum = 0;\n\n\tsum += dfs(x-1,y);\n\tsum += dfs(x+1,y);\n\tsum += dfs(x,y-1);\n\tsum += dfs(x,y+1);\n\n\treturn sum + 1;\n}\n\n\n\nint main()\n{\n\n\t\n\twhile(cin >> w >> h && w && h)\n\t{\n\t\t\n\t\tmemset(tile,0,21*21*sizeof(char));\n\t\tmemset(f,0,21*21*sizeof(bool));\n\n\t\tint sx,sy;\n\n\t\tfor(int i = 0;i < h;i++)\n\t\t{\n\t\t\tfor(int j = 0;j < w;j++)\n\t\t\t{\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif(tile[i][j] == '@'){sx = i;sy = j;}\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(sx,sy) << endl;\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nint r[20][20],ans,w,h;\nchar C[20][20];\nint search(int x,int y){\n    if(x<0||x>=w||y<0||y>=h||C[y][x]=='#'||r[y][x]) return 0;\n    r[y][x]=1;\n    ans++;\n    search(x+1,y);search(x-1,y);search(x,y+1);search(x,y-1);\n}\nint main(){\n    while(true){\n        cin>>w>>h;\n        if(w==0) break;\n        int sx,sy;\n        rep(i,h)rep(j,w){\n            cin>>C[i][j];\n            if(C[i][j]=='@') sx=j,sy=i;\n        }\n        rep(i,h)rep(j,w) r[i][j]=0;\n        ans=0;\n        search(sx,sy);\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\n\nstruct pos{\n\tpos(int X,int Y){\n\t\tx=X,y=Y;\n\t}\n\tint x,y;\n};\n\nint move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tstack<pos> bfs;\n\tbfs.push(pos(x,y));\n\twhile(!bfs.empty()){\n\t\tpos n=bfs.top();bfs.pop();\n\t\tx=n.x;\n\t\ty=n.y;\n\t\tans++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\t\tmap[x+vec[i][0]][y+vec[i][1]]='#';\n\t\t\t\t\tbfs.push(pos(x+vec[i][0],y+vec[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n​\nint W, H;\nchar visit[21][21];\nint dfs(int h, int w){\n  int sum=1;\n  if(0>w || w==W || 0>h || h==H) return 0;\n  if(visit[h][w]=='#')  return 0;\n  if(visit[h][w]=='!')   return 0;\n    visit[h][w] = '!';\n    sum += dfs(h, w+1);\n    sum += dfs(h, w-1);\n    sum += dfs(h+1, w);\n    sum += dfs(h-1, w);\n  \n  return sum;\n}\n​\nint main(void){\n  int w1, h1;\n  string str;\n  while(cin >> W >> H){\n    if(W == 0 && H == 0)  break;\n    for(int i=0; i<H; i++){\n      cin >> str;\n      for(int j=0; j<W; j++){\n        visit[i][j] = str[j];\n        if(visit[i][j] == '@'){\n          visit[i][j] = '.';\n          w1 = j; h1 = i;  \n        }\n      }\n    }\n    cout << dfs(h1, w1) <<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nvector<int> x;\nvector<int> y;\nvector<int> nextx;\nvector<int> nexty;\nint w,h;\nint count;\nbool check(int a,int b){\n  for (int i=0;i<nextx.size();i++){\n    if (nextx[i]==a&&nexty[i]==b)\n      return false;\n  }\n  return true;\n}\nint search(int **field){\n  x.clear();\n  y.clear();\n  for (int i=0;i<nextx.size();i++){\n    x.push_back(nextx[i]);\n    y.push_back(nexty[i]);\n  }\n  nextx.clear();\n  nexty.clear();\n  for (int i=0;i<x.size();i++){\n    field[x[i]][y[i]]=0;\n    count++;\n  }\n  for (int i=0;i<x.size();i++){\n    if (field[x[i]-1][y[i]]==1&&x[i]-1>=0&&check(x[i]-1,y[i])){\n      nextx.push_back(x[i]-1);\n      nexty.push_back(y[i]);\n    }\n    if (x[i]+1<h&&field[x[i]+1][y[i]]==1&&check(x[i]+1,y[i])){\n      nextx.push_back(x[i]+1);\n      nexty.push_back(y[i]);\n    }\n    if (field[x[i]][y[i]-1]==1&&y[i]-1>=0&&check(x[i],y[i]-1)){\n      nextx.push_back(x[i]);\n      nexty.push_back(y[i]-1);\n    }\n    if (field[x[i]][y[i]+1]==1&&y[i]+1<w&&check(x[i],y[i]+1)){\n      nextx.push_back(x[i]);\n      nexty.push_back(y[i]+1);\n    }\n  }\n  if (nextx.empty()){\n    return -1;\n  }\n  int *f[h];\n  for (int i=0;i<h;i++)\n    f[i]=field[i];\n  return search(f);\n}\nint main(){\n  string temp;\n  while (cin>>w>>h,w|h!=0){\n    count=0;\n    int field[h][w];\n    for (int i=0;i<h;i++){\n      cin>>temp;\n      for (int j=0;j<w;j++){\n\tif (temp[j]=='.')\n\t  field[i][j]=1;\n\tif (temp[j]=='#')\n\t  field[i][j]=0;\n\tif (temp[j]=='@'){\n\t  field[i][j]=1;\n\t  nextx.push_back(i);\n\t  nexty.push_back(j);\n\t}\n      }\n    }\n    int *f[h];\n    for (int i=0;i<h;i++)\n      f[i]=field[i];\n    search(f);\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint x,y,p,q,i,w,h,r=1;\nint j,k[101][101];\nchar s[101][101];\nint a[]={1,-1,0,0}, b[]={0,0,1,-1};\nvoid func(int x, int y){\n    for(i=0;i<4;i++){\n        if (x+a[i]<=h&&x+a[i]>0&&y+b[i]<=w&&y+b[i]>0){\n            if(s[x+a[i]][y+b[i]]=='.'){\n                r++;\n                k[x+a[i]][y+b[i]]=1;\n                func(x+a[i],y+b[i]);\n            }\n            \n        }\n    }\n}\n\nint main(){\n        while(1){\n        scanf(\"%d %d\",&w,&h);\n        if (w==0&&h==0) break;\n        for (i=1;i<=h;i++){\n            for (j=1;j<=w;j++){\n                scanf(\"%c\",&s[i][j]);\n                if (s[i][j]=='@') k[i][j]=1;\n                else k[i][j]=0;\n                if (s[i][j]=='@') {\n                    p=i; q=j;\n                }\n            }\n        }\n        func(p,q);\n        printf(\"%d\\n\",r);\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <utility>\n\n#define phb push_back\n#define ppf pop_front\n#define mkp make_pair\n#define r first\n#define c second\nusing namespace std;\n\ntypedef pair< int, int > Pr;\nconst int kDir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nint R, C, SR, SC;\nchar M[25][25];\n\nvoid read();\nvoid solve();\n\nint main() {\n  while (cin >> C >> R, R != 0 && C != 0)\n    read(), solve();\n\n  return 0;\n}\n\nvoid read() {\n  fill(&M[0][0], &M[25][0], '#');\n  for (int i = 1; i <= R; ++i)\n    for (int j = 1; j <= C; ++j) {\n      cin >> M[i][j];\n      if (M[i][j] == '@')\n        M[i][j] = '.', SR = i, SC = j;\n    }\n}\n\nvoid solve() {\n  static int vst[25][25], vst_cnt;\n  int res = 0;\n  deque< Pr > que;\n\n  que.phb(mkp(SR, SC)), vst[SR][SC] = ++vst_cnt;\n  while (!que.empty()) {\n    Pr cur = que.front(); que.ppf(), ++res;\n    for (int di = 0; di < 4; ++di) {\n      Pr nxt(cur.r + kDir[di][0], cur.c + kDir[di][1]);\n      if (M[nxt.r][nxt.c] == '.' && vst[nxt.r][nxt.c] != vst_cnt)\n        que.phb(nxt), vst[nxt.r][nxt.c] = vst_cnt;\n    }\n  }\n\n  cout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nchar map[20][21];\nint w, h;\nint ans;\nint x, y;\nint xx, yy;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nvoid Move(int X, int Y) {\n\tans++;\n\tmap[Y][X] = '#';\n\tfor(int i = 0; i < 4; i++) {\n\t\txx = X + dx[i];\n\t\tyy = Y + dy[i];\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h && map[yy][xx] == '.') {\n\t\t\tMove(xx, yy);\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(1) {\n\t\tans = 0;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif(!w && !h) break;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", map[i]);\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(map[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMove(x, y);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      char fld[H][W];\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      int visited[H][W];\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)visited[i][j]=0;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         visited[now.first][now.second]=1;\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(visited[ni][nj]) continue;\n            Q.push(pii(ni, nj));\n         }\n      }\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=visited[i][j];\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<=30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;(i)>=0;(i)--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n\ntypedef long long ll;\n\nvector<string> M;\n\nint main(){\n\n    \n    while(true){\n    int w,h;\n    cin>>w>>h;\n        \n        if(w==0&&h==0)break;\n        \n    M.clear();\n        \n    REP(i,h){\n        string s; cin>>s;\n        M.push_back(s);\n    }\n    \n    int x,y = 0;\n    for(x=0;x<w;x++){\n        for(y=0;y<h;y++){\n            if(M[y][x]=='@')goto nexts;\n        }\n    }\n    \nnexts:;\n    \n    int ans=0;\n    stack<pair<int,int>> sta;\n    sta.push(make_pair(x,y));\n    while(sta.size()!=0){\n        int xt=sta.top().first,yt=sta.top().second;\n        sta.pop();\n        \n        if(M[yt][xt]=='.'){\n            M[yt][xt]= '#';\n            ans++;\n        }\n        \n        if(xt<w-1)if(M[yt][xt+1]=='.')sta.push(make_pair(xt+1,yt));\n        if(xt>0)if(M[yt][xt-1]=='.')sta.push(make_pair(xt-1,yt));\n        if(yt<h-1)if(M[yt+1][xt]=='.')sta.push(make_pair(xt,yt+1));\n        if(yt>0)if(M[yt-1][xt]=='.')sta.push(make_pair(xt,yt-1));\n        \n    }\n    \n    cout<<ans+1<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint w, h;\nchar ch[50][50];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint bfs(int y, int x) {\n    int res = 0;\n    rep(i, 4) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 > ny or 0 > nx or ny >= h or nx >= w) continue;\n        if (ch[ny][nx] == '.') {\n            ch[ny][nx] = 'a';\n            res += bfs(ny, nx) + 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> w >> h and (w or h)) {\n        int py = 0, px = 0;\n        rep(i, h) rep(j, w) {\n            cin >> ch[i][j];\n            if (ch[i][j] == '@') {\n                py = i, px = j;\n                ch[i][j] = '.';\n            }\n        }\n        cout << bfs(py, px) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#define rep(i, n) for (int i = 0; i < n; ++i)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MAX_W = 20, MAX_H = 20;\nint tiles[MAX_H][MAX_W];\nint d[4][2] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\n\nvoid dfs(ll x, ll y, ll w, ll h) {\n  tiles[y][x] = 0;\n\n  rep(i, 4) {\n      int dx = d[i][0];\n      int dy = d[i][1];\n      if (x + dx < 0 || x + dx >= w) continue;\n      if (y + dy < 0 || y + dy >= h) continue;\n\n      if (tiles[y + dy][x + dx] == -1) {\n        dfs(x + dx, y + dy, w, h);\n      }\n  }\n}\n\n\nint main() {\n  while(true) {\n    ll w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n\n    string line;\n    int startX;\n    int startY;\n    rep(i, h) {\n      cin >> line;\n      rep(j, w) {\n        if (line[j] == '.') {\n          tiles[i][j] = -1;\n        } else if (line[j] == '#') {\n          tiles[i][j] = 1;\n        } else {\n          tiles[i][j] = -1;\n          startX = j;\n          startY = i;\n        }\n      }\n    }\n\n    dfs(startX, startY, w, h);\n    ll cnt = 0;\n    rep(i, h) {\n      rep(j, w) {\n        if (tiles[i][j] == 0) ++cnt;\n      }\n    }\n    cout << cnt << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long int64;\ntypedef int int32;\ntypedef char int8;\ntypedef int32 int__;\ntypedef pair<int,int> pii;\n#define rep(i,j) for(int__ i=0;i<j;i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);i++)\n#define repeat_eq(i,j,k) for(int__ i=(j);i<=(k);i++)\n#define all(v) (v).begin(),(v).end()\n\nconst int INF=1<<30;//=10E10\n\nint main()\n{\n  int w,h;\n  while(cin>>w>>h && w && h){\n    char tile[20][20];\n    int fx,fy;\n    rep(i,h)rep(j,w){\n      cin>>tile[i][j];\n      if(tile[i][j]=='@'){\n\tfx=j;fy=i;\n      }\n    }\n    \n    bool visited[20][20]={};\n    stack<pii> p;\n    int ans=0;\n    p.push(pii(fy,fx));\n    while(!p.empty()){\n      pii now=p.top();p.pop();\n      int nx=now.second,ny=now.first;\n      if(!visited[ny][nx]){\n\tvisited[ny][nx]=true;\n\tans++;\n\tif(ny>0 && tile[ny-1][nx]=='.')p.push(pii(ny-1,nx));\n\tif(ny+1<h && tile[ny+1][nx]=='.')p.push(pii(ny+1,nx));\n\tif(nx>0 && tile[ny][nx-1]=='.')p.push(pii(ny,nx-1));\n\tif(nx+1<w && tile[ny][nx+1]=='.')p.push(pii(ny,nx+1));\n      }\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int W, int H) {\n    vector<vector<char>> field(H + 2, vector<char>(W + 2, '#'));\n    vector<vector<int>> cost(H + 2, vector<int>(W + 2));\n    queue<pair<int, int>> que;\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == '@') {\n                que.push(make_pair(i, j));\n                cost[i][j] = 1;\n            }\n        }\n    }\n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 1, 0, -1};\n    while (!que.empty()) {\n        pair<int, int> p = que.front();\n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            int nx = p.second + dx[i];\n            int ny = p.first + dy[i];\n            if (field[ny][nx] == '#') continue;\n            if (cost[ny][nx]) continue;\n            cost[ny][nx] = 1;\n            que.push(make_pair(ny, nx));\n        }\n    }\n    int ret = 0;\n    for (int i = 0; i < cost.size(); i++) {\n        for (int j = 0; j < cost[i].size(); j++) {\n            if (cost[i][j]) ret++;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int W, H;\n    while (1) {\n        cin >> W >> H;\n        if (!W & !H) break;\n        cout << solve(W, H) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1, 0, 1, 0};\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst int MAX_N = 20;\nint W, H, ans = 1;\nvector<string> field;\n\nint dfs(int x, int y){\n\t\trep(i, 4){\n\t\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\t\tif(0 <= ty && 0 <= tx && ty < H && tx < W && field[ty][tx] == '.' ){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tfield[ty][tx] = '#';\n\t\t\t\t\t\tdfs(tx, ty);\n\t\t\t\t}\n\t\t}\n\t\treturn ans;\n}\n\nint main(){\n\t\twhile(1){\n\t\t\t\tcin >> W >> H;\n\t\t\t\tif(W == 0 && H == 0) break;\n\n\t\t\t\tfield.resize(H);\n\t\t\t\trep(i,H) cin >> field[i];\n\t\t\t\tint sx, sy;\n\n\t\t\t\t//rep(i,H) cout << field[i] << endl;\n\n\t\t\t\trep(y,H)rep(x,W)if(field[y][x] == '@'){ sx = x; sy = y; }\n\n\t\t\t\t//cout << sx << \" \" <<sy <<endl;\n\t\t\t\tdfs(sx, sy);\n\t\t\t\t//rep(i,H) cin >> field[i];\n\t\t\t\tcout << ans <<endl;\n\t\t\t\tans = 1;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(a,b) for(int (a)=0;(a)<(b);(a)++)\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0 && h==0)break;\n        int sx,sy;\n        int sum=0;\n        int dy[]={-1,0,1,0};\n        int dx[]={0,-1,0,1};\n    \n    \n        string data[30]={};\n    \n        for(int i=0;i<h;i++){\n            cin>>data[i];\n        }\n    \n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(data[i][j]=='@'){\n                    sx=j;sy=i;\n                    break;\n                }\n            }\n        }\n    \n        bool visited[30][30]={};\n    \n        queue<pair<int,int> > que;\n    \n        que.push( pair<int,int>(sy,sx) );\n        visited[sy][sx]=true;\n    \n        while(que.size()){\n            int qff=que.front().first,qfs=que.front().second;\n            sum++;\n            rep(i,4){\n                if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs+dx[i]>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false && data[ qff+dy[i] ][ qfs+dx[i] ]!='#' ){\n                    que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                    visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n                }\n            }\n            \n            que.pop();\n        }\n        cout<<sum<<endl;\n        \n//        rep(i,h){rep(j,w)cout<<(visited[i][j]?'*':'_');cout<<endl;}\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w,h,ans;\nchar c[25][25];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nvoid dfs(int y,int x)\n{\n\tif(c[y][x]=='#') return;\n\tc[y][x]='#';\n\t++ans;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w) dfs(ny,nx);\n\t}\n\treturn;\n}\n\nint main(int argc, char const *argv[])\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t\tans=0;\n\t\tint x,y;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tcin>>c[i][j];\n\t\t\t\tif(c[i][j]=='@') y=i,x=j,c[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tdfs(y,x);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint ans;\nbool check[20][20];\nchar maze[20][20];\n\nvoid init()\n{\n\tfor (int i = 0; i < 20; ++i) {\n\t\tfor (int j = 0; j < 20; ++j) {\n\t\t\tcheck[i][j] = false;\n\t\t\tmaze[i][j] = '\\0';\n\t\t}\n\t}\n}\n\nvoid search(int y, int x, int h, int w)\n{\n\tif (y >= h || x >= w || y < 0 || x < 0 || check[y][x] || maze[y][x] == '#') {\n\t\treturn;\n\t}\n\n\tcheck[y][x] = true;\n\t++ans;\n\tsearch(y + 1, x, h, w);\n\tsearch(y - 1, x, h, w);\n\tsearch(y, x + 1, h, w);\n\tsearch(y, x - 1, h, w);\n}\n\nint main(void)\n{\n\tint w, h;\n\twhile (cin >> w >> h && w != 0) {\n\t\tans = 0;\n\t\tinit();\n\t\tint sx, sy;\n\t\tfor (int y = 0; y < h; ++y) {\n\t\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t\tcin >> maze[y][x];\n\t\t\t\tif (maze[y][x] == '@') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsearch(sy, sx, h, w);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar tile[20][21];\nbool vis[20][20];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint W,H;\nint dfs(int x,int y) {\n    int sum=1;\n    vis[y][x]=1;\n    for(int i=0;i<4;i++) {\n        int nx=x+dx[i],ny=y+dy[i];\n        if(0>nx||nx>=W||0>ny||ny>=H||tile[ny][nx]=='#'||vis[ny][nx]) continue;\n        sum+=dfs(nx,ny);\n    }\n    return sum;\n}\nint main() {\n    while(scanf(\"%d %d\",&W,&H),W) {\n        for(int i=0;i<H;i++) scanf(\"%s\",tile[i]);\n        int sx,sy;\n        for(int i=0;i<H;i++) {\n            for(int j=0;j<W;j++) if(tile[i][j]=='@') {sx=j;sy=i;tile[i][j]='.';}\n        }\n        memset(vis,0,sizeof(vis));\n        printf(\"%d\\n\",dfs(sx,sy));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(1000);\n    nexty.reserve(1000);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    kaisuu++;\n    cout << sum <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nchar tile[21][21];\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = { 0,-1, 1, 0};\n\nint dfs(int x, int y){\n\tif(x<0 || w<=x || y<0 || h<=y) return 0;\n\tif(tile[y][x] == '#') return 0;\n\n\ttile[y][x] = '#';\n\tint count = 1;\n\tfor(int i=0; i<4; i++){\n\t\tcount += dfs(x+dx[i], y+dy[i]);\n\t}\n\treturn count;\n}\n\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w && !h) break;\n\n\t\tint x=0, y=0; //pos\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif(tile[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(x, y) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint solve(int w,int h){\n    int res = 0;\n    vector<vector<char>> masu(h+2,vector<char>(w+2,'#'));\n    pii S;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            cin >> masu[i][j];\n            if(masu[i][j] == '@'){\n                masu[i][j] = '.';\n                S = {i,j};\n            }\n        }\n    }\n    vector<vector<int>> flag(h+2,vector<int>(w+2,0));\n    queue<pii> q; q.push(S);\n    int dxy[5] = {1,0,-1,0,1};\n    while(q.size()){\n        int x,y; tie(x,y) = q.front(); q.pop();\n        if(masu[x][y] == '#') continue;\n        if(flag[x][y] == 1) continue;\n        flag[x][y] = 1;\n        for(int k = 0; k < 4;k++){\n            int nx = x + dxy[k],ny = y + dxy[k+1];\n            q.push({nx,ny});\n        }\n    }\n    for(auto& vec:flag) res += accumulate(vec.begin(),vec.end(),0);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int w,h;\n    while(cin >> w >> h, w|h){\n        cout << solve(w,h) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid move(const vector<vector<char>> &board, vector<vector<bool>> &reached, int x, int y, int w, int h) {\n    if (x < 0 || w <= x || y < 0 || h <= y) {\n        return;\n    } else if (board[x][y] == '#') {\n        return;\n    } else if (reached[x][y]) {\n        return;\n    }\n    reached[x][y] = true;\n    int dxAry[] = {0, 1, 0, -1};\n    int dyAry[] = {-1, 0, 1, 0};\n    for (int i = 0; i < 4; ++i) {\n        move(board, reached, x + dxAry[i], y + dyAry[i], w, h);\n    }\n}\nint main(void){\n    int w, h;\n    while (cin >> w >> h && w && h) {\n        vector<vector<char>> board(w, vector<char>(h));\n        int sx, sy;\n        for (int i = 0; i < h; ++i) {\n            string row;\n            cin >> row;\n            for (int j = 0; j < row.length(); ++j) {\n                board[j][i] = row[j];\n                if (row[j] == '@') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        vector<vector<bool>> reached(w, vector<bool>(h, false));\n        move(board, reached, sx, sy, w, h);\n        int count = 0;\n        for (int y = 0; y < h; ++y)\n            for (int x = 0; x < w; ++x)\n                count += reached[x][y];\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nchar tile[21][21];\nint W, H;\nint ans;\n\nvoid dfs( int x, int y ) {\n\tREP( i, 4 ) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H && tile[nx][ny] == '.' ) {\n\t\t\ttile[nx][ny] = '#';\n\t\t\tans++;\n\t\t\tdfs( nx, ny );\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile( cin >> W >> H, W, H ) {\n\t\t\n\t\tint sx, sy;\n\t\tREP( i, H ) {\n\t\t\tREP( j, W ) {\n\t\t\t\tcin >> tile[j][i];\n\t\t\t\tif( tile[j][i] == '@' ) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ttile[j][i] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tans = 1;\n\t\tdfs( sx, sy );\n\t\tcout << ans << endl;\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n\n#define ll (long long)\n#define REP(i,n) for(int i = 0;i<(int)n;i++)\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (a);i>(b);i--)\n#define COUNTER int i= 0,j = 0,k = 0,l = 0,m = 0, n= 0;\n#define RETURN cout << endl;\n/*vector<vector<int>>ArrayName = vector<vector<int>>(sizeofx, vector<int>(sizeofy, 0));*/\nusing namespace std;\n\n\n\nint dfs (int x,int y,vector<vector<char>>&v);\n\nint lim_x,lim_y;\nint mx[] = {-1,1,0,0};\nint my[] = {0,0,-1,1,};\n\nint main (void){\n    \n    int x,y;\n    int sh_x = 0,sh_y = 0;\n    \n    while(cin >> lim_x >> lim_y,lim_x+lim_y)\n        {\n            vector<vector<char>>v = vector<vector<char>>(lim_y, vector<char>(lim_x, 0));\n            REP(i,lim_y)\n            REP(j,lim_x)\n            {\n                cin >> v[i][j];\n                if(v[i][j] == '@')\n                    {\n                        sh_y = i;\n                        sh_x = j;\n                    }\n            }\n            //cout << lim_x << \" \" << lim_y << endl;\n            //cout << sh_x  <<\" \"<< sh_y << endl;\n            cout << dfs(sh_x,sh_y,v) << endl;\n            /*v is array name(pointer)*/\n      \n        }\n    return 0;\n}\n\nint dfs(int x,int y, vector<vector<char>>&v)\n{\n    int counter = 1;\n    for(int i = 0; i<4;i++){\n            int tx = x+mx[i],ty = y+my[i];\n            if((tx >= 0 && tx<lim_x) && (ty >= 0 && ty <lim_y) && (v[ty][tx] == '.'))\n            {\n                v[ty][tx] = '#';\n                //cout << v[ty][tx] << endl;\n                counter += dfs(tx, ty, v);\n                //cout << \"come on !\" << endl;\n            }\n                \n        }\n            \n    return counter;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint sx,sy,h,w;\nstring fld[20];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint bfs() {\n\tbool used[h][w]={};\n\tint cnt=1;\n\tqueue<P> q;\n\tused[sy][sx]=true;\n\tq.push(P(sx,sy));\n\twhile(!q.empty()) {\n\t\tP p=q.front();q.pop();\n\t\tREP(i,4) {\n\t\t\tint nx=p.fi+dx[i],ny=p.se+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||used[ny][nx]||fld[ny][nx]=='#') continue;\n\t\t\tused[ny][nx]=true;\n\t\t\tcnt++;\n\t\t\tq.push(P(nx,ny));\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\tcin>>w>>h;\n\t\tREP(i,h) {\n\t\t\tcin>>fld[i];\n\t\t\tREP(j,w) if(fld[i][j]=='@') sx=j,sy=i;\n\t\t}\n\t\tcout<<bfs()<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= y*w+x;\n  return s;\n}\n\nint point_x(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint point_y(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  while(w!=0){\n    int a[21][21]={};\n    int sx,sy;\n    for(int j=0;j<h;j++){\n      for(int i=0;i<w;i++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=point_x(cur,w);\n      y=point_y(cur,w);\n      if(x>=1){\n\tif(a[x-1][y]==1&&d[x-1][y]==-1){\n\t  d[x-1][y]=0;\n\t  q.push(point(x-1,y,w,h));\n\t}\n      }\n      if(x<=w-2){\n\tif(a[x+1][y]==1&&d[x+1][y]==-1){\n\t  d[x+1][y]=0;\n\t  q.push(point(x+1,y,w,h));\n\t}\n      }\n      if(y>=1){\n\tif(a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,y-1,w,h));\n\t}\n      }\n      if(y<=h-2){\n\tif(a[x][y+1]==1&&d[x][y+1]==-1){\n\t  d[x][y+1]=0;\n\t  q.push(point(x,y+1,w,h));\n\t}\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout <<t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nint main(){\n  char c;\n  int x, y, atx, aty, ind, count = 1;\n  std::vector<int> real;\n  std::queue<int> q;\n\n  std::cin >> x;\n  std::cin >> y;\n\n  while(x != 0 || y != 0){\n\n    real.resize(x*y);\n\n    for(int i = 0; i < y; i++){         //地図の読み込みと＠の座標の格納\n      for(int j = 0; j < x; j++){\n        std::cin >> c;\n        if(c == '.'){\n\n          real[i*x + j] = 1;\n\n        }else if(c == '#'){\n\n          real[i*x + j] = 0;\n\n        }else if(c == '@'){\n\n          real[i*x + j] = -1;\n          atx = j;//atx と aty は＠の座標を意味している\n          aty = i;\n\n        }else{\n\n          std::cout << \"unexpected char input!\" << std::endl;\n          return 0;\n\n        }\n      }\n    }\n\n    //＠を起点にして探索を開始する。\n\n    q.push(atx + aty * x);\n\n    while( !q.empty() ){\n\n      ind = q.front();\n      q.pop();\n\n\n      if( ind%x != 0){//左をチェック 左端でなければ\n        if(real[ ind-1 ] == 1 ){\n\n          real[ ind-1 ] = -1;\n          q.push( ind-1 );\n          count++;\n        }\n      }\n\n      if( ind%x != x-1 ){//右をチェック 右端でなければ\n        if(real[ ind+1 ] == 1){\n\n          real[ ind+1 ] = -1;\n          q.push( ind+1 );\n          count++;\n        }\n      }\n\n      if( ind-x > 0 ){//上をチェック 上端でなければ\n        if(real[ ind-x ] == 1){\n\n          real[ ind-x ] = -1;\n          q.push( ind-x );\n          count++;\n        }\n      }\n\n      if( ind+x < x * y){//下をチェック 下端でなければ\n        if(real[ ind+x ] == 1){\n\n          real[ ind+x ] = -1;\n          q.push( ind+x );\n          count++;\n        }\n      }\n\n    }\n\n    std::cout << count << std::endl;\n    std::cout << std::endl;\n\n/*\n    for(int i = 0; i < y;i++){\n      for(int j = 0; j < x; j++){\n        std::cout << real[i*x + j];\n      }\n      std::cout << std::endl;\n    }\n//*/\n    std::cin >> x;\n    std::cin >> y;\n    count = 1;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\nint move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\tans+=move(x+vec[i][0],y+vec[i][1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint answer,w,h;\nchar c[21][21];\n\nvoid move(int x,int y){\n    if(c[x][y]!='#'){\n        answer++;\n        c[x][y]='#';\n        if(x-1>=0) move(x-1,y);\n        if(x+1<h) move(x+1,y);\n        if(y-1>=0) move(x,y-1);\n        if(y+1<w) move(x,y+1);\n    }\n}\n\nint main(){\n    while(1){\n        int x,y;\n        answer=0;\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0) return 0;\n        getchar();\n        for(int i=0;i<h;i++){\n            for(int j=0;j<=w;j++){\n                scanf(\"%c\",&c[i][j]);\n                if(c[i][j]=='@'){\n                    x=i;\n                    y=j;\n                }\n            }\n        }\n        move(x,y);\n        printf(\"%d\\n\",answer);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <array>\n\nusing namespace std;\n\n\ntypedef std::array<uint32_t, 2> Idx;\n\nuint32_t checkAndSetIdx(vector<string>& mp, vector<Idx>& stack, uint32_t i, uint32_t j)\n{\n    if(i > mp.size()-1 || j > mp.at(0).size()-1)\n        return 0;\n\n    if(mp[i][j] == '.'){\n        mp[i][j] = 'x';\n        Idx e = {i, j};\n        stack.push_back(e);\n        return 1;\n    }\n\n    return 0;\n}\n\n\nint main()\n{\n    while(1)\n    {\n        uint32_t h, w;\n        cin >> w >> h;\n\n        if(w == 0 && h == 0)\n            break;\n\n\n        Idx iniPos;\n\n        vector<string> mp;\n        for(uint32_t i = 0; i < h; ++i){\n            mp.push_back([](){string str; cin >> str; return str;}());\n\n            for(uint32_t j = 0; j < w; ++j){\n                if(mp[i][j] == '@'){\n                    Idx e = {i, j};\n                    iniPos = e;\n                    mp[i][j] = 'x';\n                }\n            }\n        }\n\n\n        vector<Idx> stack;\n        stack.push_back(iniPos);\n        uint32_t cnt = 1;\n\n\n        while(stack.size() != 0){\n            auto nowPos = stack.at(stack.size() - 1);\n            stack.pop_back();\n            const auto i = nowPos[0],\n                       j = nowPos[1];\n\n            cnt += checkAndSetIdx(mp, stack, i+1, j);\n            cnt += checkAndSetIdx(mp, stack, i-1, j);\n            cnt += checkAndSetIdx(mp, stack, i, j+1);\n            cnt += checkAndSetIdx(mp, stack, i, j-1);\n        }\n\n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint used[23][23]; // 0=まだ訪れていない　。　１＝すでに訪れた\nint answer;\nint h,w;   // フィールドの縦幅＝h、横幅＝w；　\nstring s[23];\n\n// 「 再帰 」でググると分かります。\n\nvoid dfs(int y,int x){  //　今いる座標が（y,x）\n\n\tanswer++; //座標 (y,x) に到達できたので答えに１を足す\n\tused[y][x] = 1;   //座標 (y,x) に到達した。（　この座標は二度と使わない　）\n\n\t/* 4方向に移動するのを実際にシミュレーション  */\n\n    // 1つ上に動けるか？　座標(y-1,x)がフィールドの外に出ていなくて、座標( y-1,x )にまだ訪れていなければ　移動します。　（　座標(y-1,x)が#じゃなければ移動　）\n\tif( y-1 >= 0 && used[y-1][x]==0 && s[y-1][x]!='#') dfs( y-1,x );  \n\n\t// 1つ下に動けるか？　座標(y+1,x)がフィールドの外に出ていなくて、座標( y-1,x )にまだ訪れていなければ　移動します。　（　座標(y+1,x)が#じゃなければ移動　）\n\tif( y+1 <  h && used[y+1][x]==0 && s[y+1][x]!='#') dfs( y+1,x );  \n\n\t// 1つ右に動けるか？　座標(y,x-1)がフィールドの外に出ていなくて、座標( y-1,x )にまだ訪れていなければ　移動します。　（　座標(y,x-1)が#じゃなければ移動　）\n\tif( x-1 >= 0 && used[y][x-1]==0 && s[y][x-1]!='#') dfs( y,x-1 );  \n\n\t// 1つ左に動けるか？　座標(y,x+1)がフィールドの外に出ていなくて、座標( y-1,x )にまだ訪れていなければ　移動します。　（　座標(y,x+1)が#じゃなければ移動　）\n\tif( x+1 <  w && used[y][x+1]==0 && s[y][x+1]!='#') dfs( y,x+1 );   \n}\n\nint main(){\n\n\twhile( cin>>w>>h,w){\n\n\t\tint y,x;\n\n\t\tanswer = 0;\n\n\t\tmemset( used,0,sizeof(used) ); // 配列usedの中身を全て０にする　（ memsetでは　0 と -1 以外の値を使うとバグります ）\n\n\t\tfor(int i=0;i<h;i++) cin>>s[i]; //フィールドを文字列で読み込む\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='@'){  //  スタート地点を探す。\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(y,x);\n\n\t\tcout<< answer <<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * red_and_black.cpp\n *\n *  Created on: 2017/02/10\n *      Author: Nishio\n */\n\n#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define mp(a,b) make_pair(a,b)\nusing namespace std;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\nint main(){\n\tint H,W;\n\n\twhile(cin>>W>>H&&W){\n\t\tqueue<pair<int,int>> q;\n\t\tbool dp[21][21]={false};\n\t\tint nowx,nowy,nextx,nexty,count=1;\n\t\tchar c[21][21];\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tcin>>c[i][j];\n\t\t\t\tif(c[i][j]=='@'){\n\t\t\t\t\tdp[i][j]=true;\n\n\t\t\t\t\tq.push(mp(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tnowy=q.front().first;\n\t\t\tnowx=q.front().second;\n\t\t\tq.pop();\n\t\t\tREP(i,0,4){\n\t\t\t\tnextx=nowx+dx[i];\n\t\t\t\tnexty=nowy+dy[i];\n\t\t\t\tif(0<=nextx && nextx<W && 0<=nexty &&nexty<H){\n\t\t\t\t\tif(!dp[nexty][nextx]&&c[nexty][nextx]=='.'){\n\t\t\t\t\t\tdp[nexty][nextx]=true;\n\t\t\t\t\t\tq.push(mp(nexty,nextx));\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\nstruct Point{\n  int x;int y;\n};\n\nint main(){\n  int w,h,i,j,k,c=0;\n  string str;\n  Point p,b;\n  cin >> w >> h;\n  while(w!=0&&h!=0){\n    c=1;\n    int dp[21][21]={{}};\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tif(str[j]=='.') dp[j][i]= 1;\n\tif(str[j]=='#') dp[j][i]= 2;\n\tif(str[j]=='@') {\n\t  dp[j][i]= 3;\n\t  p.x=j;p.y=i;\n\t}\n      }\n    }\n    \n    queue <Point> q;\n    q.push(p);\n    while(!q.empty()){\n      p = q.front();\n      q.pop();\n      if((p.x+1)<w&&dp[p.x+1][p.y]==1){\n\tc++;\n\tb.x=p.x+1;b.y=p.y;\n\tdp[p.x+1][p.y]=-1;\n\tq.push(b);\n      }\n      if((p.x-1)>=0&&dp[p.x-1][p.y]==1){\n\tc++;\n\tb.x=p.x-1;b.y=p.y;\n\tdp[p.x-1][p.y]=-1;\n\tq.push(b);\n      }\n      if((p.y+1)<h&&dp[p.x][p.y+1]==1){\n\tc++;\n\tb.x=p.x;b.y=p.y+1;\n\tdp[p.x][p.y+1]=-1;\n\tq.push(b);\n      }\n      if((p.y-1)>=0&&dp[p.x][p.y-1]==1){\n\tc++;\n\tb.x=p.x;b.y=p.y-1;\n\tdp[p.x][p.y-1]=-1;\n\tq.push(b);\n      }\n    }\n    cout << c << endl;\n    cin >> w >> h;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\nint num;\nint X,Y;\nvector<vector<char>> vec;\nvector<vector<bool>> reg(Y,vector<bool>(X,0));\nvoid search(int y,int x){\n  //  cout<<\"search\"<<x <<\" \"<<y<<endl;\n    bool h=0;\n //   reg[x][y]=0;\n    if(x+1<X){\n        if(reg[y][x+1]==1){\n            num++;\n          //  cout<<\"count\"<<endl;\n            reg[y][x+1]=0;\n            search(y,x+1);\n            h=1;\n        }\n    }\n    if(x-1>=0){\n        if(reg[y][x-1]==1){\n            num++;\n         //   cout<<\"count\"<<endl;\n            reg[y][x-1]=0;\n            search(y,x-1);\n            h=1;\n            \n        }\n    }\n    if(y+1<Y){\n        if(reg[y+1][x]==1){\n            num++;\n          //  cout<<\"count\"<<endl;\n            reg[y+1][x]=0;\n            search(y+1,x);\n            h=1;\n            \n        }\n    }\n    if(y-1>=0){\n        if(reg[y-1][x]==1){\n            num++;\n          //  cout<<\"count\"<<endl;\n            reg[y-1][x]=0;\n            search(y-1,x);\n            h=1;\n            \n        }\n    }\n    if(h==0){\n     //   cout<<\"OUT\"<<endl;\n    }\n}\nint main(){\n    while(1){\n        \n        cin >> X >> Y;\n        if(X==0 || Y==0){\n            break;\n        }\n        num=0;\n        vec.assign(Y,vector<char>(X,'0'));\n        reg.assign(Y,vector<bool>(X,0));\n        int start_x=0;\n        int start_y=0;\n      //  int c=0;\n        for(int i=0;i<Y;i++){\n            string s;\n            cin >> s;\n            for(int j=0;j<X;j++){\n                vec[i][j]=s[j];\n                if(s[j]=='@'){\n                    start_x=j;\n                    start_y=i;\n                }\n                else if(s[j]=='.'){\n                    reg[i][j]=1;\n                }else{\n                 //   c++;\n                }\n            }\n        }\n         //   cout<<c<<endl;\n       // cout<<start_x<<\",\"<<start_y<<endl;\n       search(start_y,start_x);\n       cout<<num+1<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nint visited[20][20];\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)visited[i][j]=0;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      int cnt=0;\n      visited[sy][sx]=1;\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         //visited[now.first][now.second]=1;\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(visited[ni][nj]) continue;\n            visited[ni][nj]=1;\n            Q.push(pii(ni, nj));\n         }\n      }\n\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=visited[i][j];\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nint w,h;\nint ans=1;\nchar tile[21][21];\n\nvoid saiki(int x,int y){\n\ttile[x][y]='#';\n\tif(tile[x-1][y]=='.')ans++,saiki(x-1,y);\n\tif(tile[x+1][y]=='.')ans++,saiki(x+1,y);\n\tif(tile[x][y-1]=='.')ans++,saiki(x,y-1);\n\tif(tile[x][y+1]=='.')ans++,saiki(x,y+1);\n}\n\nint main(void){\n\tint a,b; \n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tans=1;\n\t\tfor(a=0;a<h;a++){\n\t\t\tscanf(\"%s\",tile[a]);\n\t\t}\n\t\tfor(a=0;a<h;a++){\n\t\t\tfor(b=0;b<w;b++){\n\t\t\t\tif(tile[a][b]=='@')saiki(a,b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n\n\nint main(){\n    std::vector<int> tiles;\n    std::queue<int> unvisited_tile_q;\n    int width, height, counter, pos;\n    std::string line;\n\n    while(true){\n        std::cin >> width >> height;\n        if( width == 0 && height == 0 ) break;\n        tiles.resize(width*height);\n        pos = 0;\n        for( int h = 0; h < height; h++ ){\n            std::cin >> line;\n            for(std::string::iterator it = line.begin(); it != line.end(); ++it) {\n                switch(*it){\n                    case '#':\n                        tiles[pos] = 0;\n                        break;\n                    case '@':\n                        unvisited_tile_q.push(pos);\n                    case '.':\n                        tiles[pos] = 1;\n                }\n                pos++;\n            }\n        }\n\n        counter = 0;\n        while( !unvisited_tile_q.empty() ){\n            pos = unvisited_tile_q.front();\n            unvisited_tile_q.pop();\n            if( tiles[pos] == 1 ){\n                counter++;\n                tiles[pos] = -1;\n            } else continue;\n            //left\n            if ( pos - 1 >= 0 && pos % width > 0 && tiles[pos-1] == 1 ) unvisited_tile_q.push(pos-1); \n             //right\n            if ( pos + 1 <= tiles.size() && pos % width < width - 1 && tiles[pos+1] == 1 ) unvisited_tile_q.push(pos+1);\n            //up\n            if ( pos - width >= 0 && tiles[pos-width] == 1 ) unvisited_tile_q.push(pos-width);\n            //down\n            if ( pos + width < tiles.size() && tiles[pos+width] == 1 ) unvisited_tile_q.push(pos+width);\n        }\n\t    //output result\n\t    std::cout << counter << std::endl;\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n */\n\n\n#include <iostream>\n#include <limits>\n\nconstexpr size_t MAX_HEIGHT = 20;\nconst char START_TILE = '@';\nconst char PASSABLE_TILE = '.';\nconst char PROHIBITED_TILE = '#';\nconst char PASSED_TILE = 'P';\n\nbool is_wall(std::string world[MAX_HEIGHT], size_t x, size_t y) {\n\tchar tile = world[y][x];\n\treturn tile == PROHIBITED_TILE || tile == PASSED_TILE;\n}\n\nbool valid(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\treturn x < width && y < height // x and y is unsigned\n\t\t   && !is_wall(world, x, y);\n}\n\nint walk(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\tif (!valid(world, width, height, x, y)) {\n\t\treturn 0; // ????????????????????\\?????????????£?or??¢?´¢??????\n\t}\n\tint total = 1; // ????????????????????\\?????????1?????¨??????????????????\n\tworld[y][x] = PASSED_TILE; // ??????????????¨????????????????????¨?????????????????????????????????\n\t// ?????????????????§??????????????????valid???????????????walk????????§\n\ttotal += walk(world, width, height, x - 1, y);\n\ttotal += walk(world, width, height, x + 1, y);\n\ttotal += walk(world, width, height, x, y - 1);\n\ttotal += walk(world, width, height, x, y + 1);\n\treturn total;\n}\n\nvoid process(size_t width, size_t height) {\n\tstd::string world[MAX_HEIGHT];\n\tsize_t x = std::numeric_limits<size_t>::max(), y = std::numeric_limits<size_t>::max();\n\tfor (size_t i = 0; i < height; ++i) {\n\t\tstd::cin >> world[i];\n\t\tsize_t start_index = world[i].find(START_TILE);\n\t\tif (start_index != std::string::npos) {\n\t\t\tx = start_index;\n\t\t\ty = i;\n\t\t}\n\t}\n\n\tstd::cout << walk(world, width, height, x, y);\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tprocess(width, height);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm> \n#include <cstdlib> \n#include <ctime> \n#include <cstdio> \n#include <functional> \n#include <set> \n#include <sstream> \n#include <cctype>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <map>\n \nusing namespace std;\n\nbool vis[30][30];\nint cnt;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint w,h;\n\nvoid dfs(vector<string> &vs,int y,int x){\n\n\tif(vis[y][x]) return;\n\tvis[y][x]=true;\n\tcnt++;\n\n\tfor(int i=0;i<4;i++){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif( 0<=ny && ny<h && 0<=nx && nx<w && vs[ny][nx]=='.') dfs(vs,ny,nx);\n\t}\n\n}\n\nint main(){\n\n\twhile(cin>>w>>h,w||h){\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++) vis[i][j]=false;\n\t\t}\n\t\tcnt=0;\n\n\t\tvector<string> vs(h);\n\t\tint x,y;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>vs[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(vs[i][j]=='@') y=i,x=j;\n\t\t\t}\n\t\t}\n\n\t\tdfs(vs,y,x);\n\t\tcout<<cnt<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct locate{\n  int x;\n  int y;\n};\n \nchar graph[20][20];\nint cou = 0;\nint H,W;\n\nvoid bfs(locate z){\n  queue<locate> Q;\n  locate u;\n  locate v;\n  Q.push(z);\n \n\n  while(!Q.empty()){\n\n    u = Q.front();Q.pop();\n\n    if(graph[u.y + 1][u.x] == '.' && graph[u.y + 1][u.x] != 'N'){\n      graph[u.y + 1][u.x] = 'N';\n      cou++;\n      v.y = u.y + 1;\n      v.x = u.x;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x + 1] == '.' && graph[u.y][u.x + 1] != 'N'){\n      graph[u.y][u.x + 1] = 'N';\n      cou++;\n      v.x  = u.x + 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n\n    if(graph[u.y - 1][u.x] == '.' && graph[u.y - 1][u.x] != 'N'){\n      graph[u.y - 1][u.x] = 'N';\n      cou++;\n      v.x = u.x;\n      v.y = u.y - 1;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x - 1] == '.' && graph[u.y][u.x - 1] != 'N'){\n      graph[u.y][u.x - 1] = 'N';\n      cou++;\n      v.x = u.x - 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n    \n  }\n  cout << endl;\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcout << graph[i][j];\n      }\n      cout << endl;\n      }\n}\n\nint main(){\n\n  int a1,a2;\n  locate a;\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    a.y = a1;\n    a.x = a2;\n    bfs(a);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 'N';\n      }\n    }\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<set>\n#include<map>\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef long long LL;\nint h,w,step;\nchar mp[25][25];\nconst int ox[]={1,-1,0,0};\nconst int oy[]={0,0,1,-1};\n\nbool dfs(int X,int Y){\n\tfor(int i=0;i<4;i++){\n\t\tint x=X+ox[i];\n\t\tint y=Y+oy[i];\n\t\tif(0<=x&&x<h&&0<=y&&y<w&&mp[x][y]=='.'){\n\t\t\tmp[x][y]='@';\n\t\t\tstep++;\n\t\t\tdfs(x,y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&w,&h)!=EOF&&(w+h)){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tscanf(\"%s\",&mp[i]);\n\t\tstep=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mp[i][j]=='@'){\n\t\t\t\t\tstep=1;\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\ti=w=25;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",step);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint w, h; \n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tchar map[21][21];\n\t\tbool b[21][21];\n\t\tqueue<pair<int, int>>bfs;\n\t\tfor (int i = 0; i < h; i++)for (int j = 0; j < w; j++) {\n\t\t\tcin >> map[i][j];\n\t\t\tb[i][j] = false;\n\t\t\tif (map[i][j] == '@') {\n\t\t\t\tbfs.push(make_pair(i, j));\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\twhile (bfs.size() > 0) {\n\t\t\tpair<int, int>p = bfs.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tmap[x][y] = '#';\n\t\t\tif (x > 0){\n\t\t\t\tif (map[x - 1][y] == '.' && !b[x - 1][y]) {\n\t\t\t\t\tbfs.push(make_pair(x - 1, y));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x - 1][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < h) {\n\t\t\t\tif (map[x + 1][y] == '.' && !b[x + 1][y]) {\n\t\t\t\t\tbfs.push(make_pair(x + 1, y));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x + 1][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y > 0) {\n\t\t\t\tif (map[x][y - 1] == '.'&& !b[x][y - 1]) {\n\t\t\t\t\tbfs.push(make_pair(x, y - 1));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x][y - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < w) {\n\t\t\t\tif (map[x][y + 1] == '.' && !b[x][y + 1]) {\n\t\t\t\t\tbfs.push(make_pair(x, y + 1));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x][y + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs.pop();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nchar map[21][21];\nint tx[4] = {-1,0,1,0};\nint ty[4] = {0,1,0,-1};\nint w,h,c;\n\nint search(int y,int x){\n  int i,nx,ny;\n  c++;\n  for(i=0;i<4;i++){\n    nx=x+tx[i];\n    ny=y+ty[i];\n    if(0<=nx && nx<w && 0<=ny && ny<h && map[ny][nx]!='#'){\n      map[ny][nx]='#';\n      search(ny,nx);\n    }\n  }\n  \n  return c;\n  \n}\n\nint main(){\n\n  int i,j,nx,ny;\n  int a;\n\n  while(1){\n    c=0;\n    cin>>w>>h;\n  \n    if(w==0&&h==0){\n      break;\n    }\t    \n \n    \n    for(i=0; i<h ; i++){\n      for(j=0; j<w ; j++){\n\tcin>>map[i][j];\n\tif(map[i][j]=='@'){\n\t  nx = j;\n\t  ny = i;\n\t}\n      } \n    }\n    \n    map[ny][nx]='#';\n    a=search(ny,nx);\n    cout<<c<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar map[21][21];\nint count;\nint x, y;\n\nvoid dfs(int nx, int ny){\n  map[ny][nx] = '#';\n  count++;\n  if (nx < x && map[ny][nx+1] == '.'){\n    dfs(nx+1, ny);\n  }\n  if (nx > 0 && map[ny][nx-1] == '.'){\n    dfs(nx-1, ny);\n  }\n  if (ny < y && map[ny+1][nx] == '.'){\n    dfs(nx, ny+1);\n  }\n  if (ny > 0 && map[ny-1][nx] == '.'){\n    dfs(nx, ny-1);\n  }\n  return;\n}\n\nint main(){\n  while (1){\n    cin >> x >> y;\n    if (!(x || y)) break;\n    int ix, iy;\n    count = 0;\n    for (int i = 0; i < y; i++){\n      for (int j = 0; j < x; j++){\n\tcin >> map[i][j];\n\tif (map[i][j] == '@'){ix = j; iy = i;}\n      }\n    }\n    dfs(ix, iy);\n    cout << count << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nint H,W;\nchar map[21][21];\nint dist[21][21];\nusing namespace std;\n\nvoid solve(){\n  int nx,ny,sx,sy;\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,1,0,-1};\n  for(int height = 0; height < H; height++){\n    for(int width = 0; width < W ; width++){\n      dist[height][width] = 0;\n      if(map[height][width] == '@'){\n        sx = width;\n        sy = height;\n      }\n    }\n  }\n\n  dist[sy][sx] = 1;\n  for(int d = 1; d < H * W; d++){\n    for(int height = 0; height < H; height++){\n      for(int width = 0; width < W ; width++){\n        if(d == dist[height][width]){\n          for(int dir = 0 ; dir < 4; dir++){\n            nx = width + dx[dir];\n            ny = height + dy[dir];\n            if(nx >= 0 && nx < W && ny >= 0 && ny < H &&\n               map[ny][nx] != '#' && dist[ny][nx] == 0){\n\n              dist[ny][nx] = dist[height][width] + 1;\n\n            }\n          }\n        }\n      }\n    }\n  }\n  int res = 0;\n  for(int height = 0; height < H; height++){\n    for(int width = 0; width < W ; width++){\n      //cout << dist[height][width] ;\n      if(dist[height][width] != 0) res++;\n    }\n    //cout << endl;\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(true){\n    cin >> W >> H ;\n    if(W + H == 0) break;\n    for(int height = 0; height < H; height++){\n      for(int width = 0; width < W ; width++){\n        cin >> map[height][width];\n      }\n    }\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 21\n\nstring str[MAX];\nint n,m,cnt,dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\nvoid dfs(int x,int y){\n  str[x][y] = '#';\n\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i] , ny = y + dy[i];\n    if(nx < 0 || nx > m || ny < 0 || ny > n) return; \n    if(str[nx][ny] == '.'){\n      cnt++;\n      dfs(nx,ny);\n    }\n  }\n\n  return;\n}\n\nint main(){\n  while(cin >> n >> m , n + m){\n    for(int i = 0 ; i < m ; i++)\n      cin >> str[i];\n    \n    int x,y;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < m ; j++){\n\tif(str[j][i] == '@'){\n\t  x = j;\n\t  y = i;\n\t  break;\n\t}\n      }\n    }\n    cnt = 1;\n    dfs(x,y);\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_INT  100005\nusing namespace std;\n\n//??\\???????????§???\n#define MAX_X  22\n#define MAX_Y  22\n\n//?????°\nchar field[MAX_X][MAX_Y];\nint X, Y;\nint px, py;                     // players position\n\n\n//?§????4?????????????????????\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1,  0, -1};\n\n\nvoid print_field() {\n  for (int y = 0; y < Y; y++ ) {\n    for (int x = 0; x < X; x++ ) {\n      cout << field[x][y];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nvoid dfs(int x, int y) {\n\n  field[x][y] = '$';            // ?¨????????????¨?????°\n\n  for (int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(field[nx][ny] == '.') {\n      dfs(nx, ny);\n    }\n  }\n\n}\n\n\nint main() {\n\n  while(true) {\n\n    cin >> X >> Y;\n\n    if(X == 0 && Y == 0) break;\n\n    for(int y = 0; y < Y; y++ ){\n      for(int x = 0; x < X; x++ ){\n        cin >> field[x][y];\n        if( field[x][y] == '@' ) { px = x; py = y; }\n      }\n    }\n\n    dfs(px, py);\n\n    // ?¨?????????´????????°??????\n    int res = 0;\n    for(int y = 0; y < Y; y++ ){\n      for(int x = 0; x < X; x++ ){\n        if ( field[x][y] == '$' ) { res++; }\n      }\n    }\n\n    cout << res << endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#define INF 999999\n#define fst first\n#define snd second\n#define MAX 32\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long ll;\n\nint w,h,d[MAX][MAX],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},sx,sy;\nchar maze[MAX][MAX];\n\t\nvoid bfs(){\n\tint i,j;\n\tqueue<P> que;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)d[i][j]=0;\n\tque.push(P(sx,sy));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tif(maze[p.fst][p.snd]=='#'||d[p.fst][p.snd])continue;\n\t\td[p.fst][p.snd]=1;\n\t\tfor(i=0;i<4;i++){\n\t\t\tint nx=p.fst+dx[i],ny=p.snd+dy[i];\n\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w){\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\t\nint main(){\n\tint i,j,t;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tgetchar();\n\t\tif(w==0&&h==0)break;\n\t\tt=0;\n\t\tfor(i=0;i<MAX;i++)for(j=0;j<MAX;j++)maze[i][j]='\\0';\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&maze[i][j]);\n\t\t\t\tif(maze[i][j]=='@'){\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tbfs();\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++)t+=d[i][j];\n\t\tprintf(\"%d\\n\",t);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nint main(){\n  char c;\n  int x, y, atx, aty, ind, count = 1;\n  std::vector<int> real;\n  std::queue<int> q;\n\n  std::cin >> x;\n  std::cin >> y;\n\n  while(x != 0 || y != 0){\n\n    real.resize(x*y);\n\n    for(int i = 0; i < y; i++){         //地図の読み込みと＠の座標の格納\n      for(int j = 0; j < x; j++){\n        std::cin >> c;\n        if(c == '.'){\n\n          real[i*x + j] = 1;\n\n        }else if(c == '#'){\n\n          real[i*x + j] = 0;\n\n        }else if(c == '@'){\n\n          real[i*x + j] = -1;\n          atx = j;//atx と aty は＠の座標を意味している\n          aty = i;\n\n        }else{\n\n          std::cout << \"unexpected char input!\" << std::endl;\n          return 0;\n\n        }\n      }\n    }\n\n    //＠を起点にして探索を開始する。\n\n    q.push(atx + aty * x);\n\n    while( !q.empty() ){\n\n      ind = q.front();\n      q.pop();\n\n\n      if( ind%x != 0){//左をチェック 左端でなければ\n        if(real[ ind-1 ] == 1 ){\n\n          real[ ind-1 ] = -1;\n          q.push( ind-1 );\n          count++;\n        }\n      }\n\n      if( ind%x != x-1 ){//右をチェック 右端でなければ\n        if(real[ ind+1 ] == 1){\n\n          real[ ind+1 ] = -1;\n          q.push( ind+1 );\n          count++;\n        }\n      }\n\n      if( ind-x > -1 ){//上をチェック 上端でなければ\n        if(real[ ind-x ] == 1){\n\n          real[ ind-x ] = -1;\n          q.push( ind-x );\n          count++;\n        }\n      }\n\n      if( ind+x < x * y){//下をチェック 下端でなければ\n        if(real[ ind+x ] == 1){\n\n          real[ ind+x ] = -1;\n          q.push( ind+x );\n          count++;\n        }\n      }\n\n    }\n\n    std::cout << count << std::endl;\n\n/*\n    for(int i = 0; i < y;i++){\n      for(int j = 0; j < x; j++){\n        std::cout << real[i*x + j];\n      }\n      std::cout << std::endl;\n    }\n//*/\n    std::cin >> x;\n    std::cin >> y;\n    count = 1;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1},\n              dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n    for (;;) {\n        int w, h; cin >> w >> h;\n        if (w == 0) break;\n\n        vector<string> s(h);\n        int si, sj;\n        REP(i, h) {\n            cin >> s[i];\n            REP(j, w) {\n                if (s[i][j] == '@') {\n                    si = i, sj = j;\n                    s[i][j] = '.';\n                }\n            }\n        }\n\n        int ans = 0;\n        vvi vis(h, vi(w));\n        function<void(int,int)> dfs = [&](int i, int j) {\n            vis[i][j] = 1;\n            ++ans;\n            REP(k, 4) {\n                int y = i + dy[k], x = j + dx[k];\n                if (y < 0 or x < 0 or y >= h or x >= w) continue;\n                if (s[y][x] == '#') continue;\n                if (vis[y][x]) continue;\n                dfs(y, x);\n            }\n        };\n\n        dfs(si, sj);\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n\nchar mp[20][22];\nint H, W;\n\nvoid dfs(int y, int x)\n{\n    if (y < 0 || y >= H || x < 0 || x >= W || mp[y][x] == '#' || mp[y][x] == ' ') return;\n\n    mp[y][x] = ' ';\n\n    rep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main()\n{\n    while (scanf(\"%d %d\", &W, &H), H || W) {\n        int sy, sx;\n\n        rep(i, H) rep(j, W) {\n            scanf(\"\\n%c\", &mp[i][j]);\n            if (mp[i][j] == '@') sy = i, sx = j, mp[i][j] = '.';\n        }\n\n        dfs(sy, sx);\n\n        int cnt = 0;\n\n        rep(i, H) rep(j, W) if (mp[i][j] == ' ') cnt++;\n\n        printf(\"%d\\n\", cnt);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint count; \nint dx[4]={1,0,-1,0};int dy[4]={0,1,0,-1};\nchar board[100][100];\nvoid dfs(int x,int y){\n       count++;\n       board[y][x]='#';\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i];int ny=y+dy[i];\n      if(nx>=0&&nx<w&&ny>=0&&ny<h&&board[ny][nx]=='.'){\n          dfs(nx,ny);\n      }\n    }\n}\nint main(){\n\twhile(1){\n  cin>>w>>h;\n  if(w==0&&h==0) break;\n  count=0;\n  for(int k=0;k<h;k++){\n    cin>>board[k];\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(board[i][j]=='@'){\n         dfs(j,i);\n      }\n    }\n  }\n  cout<<count<<endl;\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n    int x, y;\n};\n\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nchar room[25][25];\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w != 0){\n        for(int i=0;i<=h+1;++i){\n            for(int j=0;j<=w+1;++j){\n                if(i == 0 || j == 0 || i == h+1 || j == w+1)\n                    room[i][j] = '#';\n                else\n                    room[i][j] = '.';\n            }\n        }\n        int sx = 0, sy = 0;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                scanf(\" %c\",&room[i+1][j+1]);\n                if(room[i+1][j+1] == '@'){\n                    sx = j+1;\n                    sy = i+1;\n                }\n            }\n        }\n        queue<Node> que;\n        que.push((Node){sx, sy});\n        while(!que.empty()){\n            Node curr = que.front(); que.pop();\n            for(int i=0;i<4;++i){\n                int nx = curr.x + dx[i], ny = curr.y + dy[i];\n                if(room[ny][nx] == '.'){\n                    room[ny][nx] = '@';\n                    que.push((Node){nx, ny});\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=1;i<=h;++i)\n            for(int j=1;j<=w;++j)\n                if(room[i][j] == '@')ans++;\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\n#define INF 999999999\n\nchar map[20][21];\nbool ch[20][20];\nint ans;\n\nvoid dfs(int w, int h, char map[20][21], bool c[20][20], int x, int y){\n\t//cout << x << \" \" << y << \" \" << ans << endl;\n\tans++;\n\tc[x][y] = 1;\n\tif(x>0 && map[x-1][y]=='.' && c[x-1][y]==0){\n\t\tdfs(w,h,map,c,x-1,y);\n\t}\n\tif(x<h-1 && map[x+1][y]=='.' && c[x+1][y]==0){\n\t\tdfs(w,h,map,c,x+1,y);\n\t}\n\tif(y>0 && map[x][y-1]=='.' && c[x][y-1]==0){\n\t\tdfs(w,h,map,c,x,y-1);\n\t}\n\tif(y<w-1 && map[x][y+1]=='.' && c[x][y+1]==0){\n\t\tdfs(w,h,map,c,x,y+1);\n\t}\n}\n\nint main(){\n\tint i, j, w, h, x, y;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\tfor(i=0;i<h;i++){\n\t\t\tcin >> map[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tch[i][j] = 0;\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs(w,h,map,ch,x,y);\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n//#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\n#include <queue>\n#include <set>\nusing namespace std;\n\nbool check[30][30] = { false };\nint movex[] = { 0, 1, 0, -1 };\nint movey[] = { 1, 0, -1, 0 };\n\nint move(int num, int x, int y){\n\tint retnum = num;\n\tif (check[x][y]){\n\t\tretnum++;\n\t\tcheck[x][y] = false;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tretnum = move(retnum, x + movex[i], y + movey[i]);\n\t\t}\n\t}\n\n\treturn retnum;\n}\n\nint main(void){\n\n\tint W ,H;\n\t// char ;\n\n\twhile (scanf(\"%d %d\", &W, &H) != EOF){\n\t\tif (W == 0 && H == 0) break;\n\t\tint ax, ay;\n\n\t\tfor (int i = 0; i<29; i++){\n\t\t\tfor (int j = 0; j<29; j++){\n\t\t\t\tcheck[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i<=H; i++){\n\t\t\t\tchar buff[20];\n\t\t\t\tscanf(\"%s\", buff);\n\t\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tif (buff[j- 1] == '.') check[i][j] = true;\n\t\t\t\telse if (buff[j - 1] == '@'){\n\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\tax = i;\n\t\t\t\t\tay = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << move(0, ax, ay) << endl;\n\n\t}\n\n\treturn 0;\n}\n\n/*\nfor(i=0;i<N;i++){\ncin >> X[i];\n}\n\n\nfor(i=0;i<N;i++){\nfor(j=0;j<N;j++){\ncin >> X[i][j];\n}\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n};\n\nconst Point dir[4] = {{1,0},{0,1},{-1,0},{0,-1}};\n\nint w,h;\nchar map[20][20];\nbool visited[20][20];//訪問済みならtrue\nint cnt;//黒いタイルを数えるカウンタ\n\nbool inField(Point p){\n\treturn 0<=p.x && p.x < w && 0<=p.y && p.y < h;\n}\n\n//幅優先探索\nvoid dfs(Point pos){\n\tcnt++;\n\tvisited[pos.y][pos.x] = true;\n\tfor(int i=0;i<4;i++){\n\t\tPoint next = {pos.x+dir[i].x, pos.y+dir[i].y};\n\t\tif(inField(next)==true){\n\t\t\tif(visited[next.y][next.x] == false && map[next.y][next.x] == '.'){\n\t\t\t\tdfs(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tPoint init;//初期位置\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tvisited[i][j] = false;\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\t//初期代入以外はキャストする必要がある。\n\t\t\t\t\tinit = (Point){j,i};\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tdfs(init);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[22][22] = {} ;\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint W, H, ans;\nstring maze[20];\n\nbool check(int x, int y){\n\treturn x >= 0 && x < W && y >= 0 && y < H && maze[y][x] == '.';\n}\n\nvoid dfs(int x, int y){\n\t\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(check(nx, ny)){\n\t\t\tmaze[ny][nx] = '#';\n\t\t\tans++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> W >> H && (W || H)){\n\t\tfor(int i = 0; i < H; ++i)\n\t\t\t\tcin >> maze[i];\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(maze[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint H, W;\nint map[20][20];\nint c;\nusing namespace std;\n\nvoid printArray();\nvoid check(int, int);\n\nint main() {\n  cin  >> W >> H;\n  int sy, sx;\n  for (int i = 0; i < H; i++) {\n    string line;\n    cin >> line;\n    for (int j = 0; j < W; j++) {\n      if (line[j] == '@') {\n        sy = i;\n        sx = j;\n        map[i][j] = 0;\n      } else if (line[j] == '.') {\n        map[i][j] = 0;\n      } else if (line[j] == '#') {\n        map[i][j] = 1;\n      }\n    }\n  }\n  // printArray();\n  c = 0;\n  check(sy, sx);\n  // printArray();\n  cout << c << endl;\n  return 0;\n}\n\nvoid check(int y, int x) {\n  if (y < 0 || x < 0 || y >= H || x >= W || map[y][x] == 1) {\n    return;\n  }\n  map[y][x] = 1;\n  c++;\n  check(y + 1, x);\n  check(y - 1, x);\n  check(y, x + 1);\n  check(y, x - 1);\n}\n\nvoid printArray() {\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cout << map[i][j];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <queue>\n//ranker\nusing namespace std;\n\n#define REPS(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (int i = (a); i >= n; --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing pis = pair<int, string>;\nusing psi = pair<string, int>;\nusing D = double;\n\nvoid merge (int *first1, int *last1, int *first2, int *last2){\n    int size1 = last1 - first1;\n    int size2 = last2 - first2;\n    int *result = new int[size1+size2];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    while (true){\n        if (i < size1 && (first1[i] <= first2[j] || j >= size2)){\n            result[index] = first1[i];\n            ++i; ++index;\n        }\n        if (j < size2 && (first1[i] > first2[j] || i >= size1)){\n            result[index] = first2[j];\n            ++j; ++index;\n        }\n        if (i==size1 && j==size2){\n            for (i=0; i<size1; ++i) first1[i] = result[i];\n            for (j=0; j<size2; ++j) first2[j] = result[j+size1];\n            delete[] result;\n            return;\n        }\n    }\n}\nvoid MergeSort (int *first, int *last){\n    int size = last - first;\n    if(size <= 1) return;\n    MergeSort(first, first+size/2);\n    MergeSort(first+size/2, last);\n    merge(first, first+size/2, first+size/2, last);\n}\n\n\nint gcd(int a, int b)\n{\n    int c;\n\n    if (a < b) {\n        a+=b; b=a-b; a-=b;\n    }\n\n    while (b != 0) {\n        c = a % b;\n        a = b;\n        b = c;\n    }\n\n    return a;\n}\n\nint dx[3]={-1, 0, 1};\nint dy[3]={-1, 0, 1};\nint W, H;\nchar masu[20][20];\nint cnt;\n\nint dfs(int a, int b){\n  masu[a][b] = '#';\n  cnt++;\n  REP(i, 3)REP(j, 3) if(masu[a+dx[i]][b+dy[j]]=='.' && abs(dx[i]+dy[j])==1 && a+dx[i] >= 0 && a+dx[i] < W && b+dx[j] >= 0 && b+dx[j] < H) dfs(a+dx[i], b+dy[j]);\n  return cnt;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    REP(j, H)REP(i, W) cin >> masu[i][j];\n\n    int i0, j0;\n    REP(j, H)REP(i, W) if(masu[i][j] == '@'){\n      i0=i;\n      j0=j;\n      break;\n    }\n\n    cnt = 0;\n    cnt = dfs(i0, j0);\n    cout << cnt << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n#define MAX 21\nint w,h;\nchar map[MAX][MAX];\nint dx[]={ 0, 1, 0,-1};\nint dy[]={ 1, 0,-1, 0};\nint count;\nvoid search(int y,int x){\n\t//cout<<\"now:(\"<<x<<\",\"<<y<<\")\"<<endl;\n\tmap[y][x]='#';\n\tfor(int i=0;i<4;i++){\n\t\tint nextX=x+dx[i];\n\t\tint nextY=y+dy[i];\n\t\t//cout<<\"next:(\"<<nextX<<\",\"<<nextY<<\")\"<<endl;\n\t\tif(nextY<0||nextX<0||nextY>=h||nextX>=w || map[nextY][nextX]=='#')continue;\n\t\t++count;\n\t\tsearch(nextY,nextX);\n\t}\n\treturn;\n}\nint main(){\n\twhile(cin>>w>>h && (w||h)){\n\t\tint st_w,st_h;\n\t\tmemset(map,' ',sizeof(map));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tst_w=j;st_h=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=1;\n\t\tsearch(st_h,st_w);\n\t\tcout<<count<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\nint main() {\n  int W, H, x, y, ans, c;\n  string s;\n  while (cin >> W >> H, W) {\n    vector<string> M;\n    ans = 0;\n    M.push_back(string(W+2, '#'));\n    for (int i = 0; i < H; ++i) {\n      cin >> s;\n      for (int j = 0; j < W; ++j) {\n\tif (s[j] == '@') {\n\t  x = i+1;\n\t  y = j+1;\n\t  s[j] = '!';\n\t  break;\n\t}\n      }\n      s = '#' + s + '#';\n      M.push_back(s);\n    }\n    M.push_back(string(W+2, '#'));\n    queue<vector<int>> que;\n    que.push({x, y});\n    while (!que.empty()) {\n      ++ans;\n      x = que.front()[0];\n      y = que.front()[1];\n      que.pop();\n      if (M[x-1][y] == '.') {\n\tM[x-1][y] = '!';\n\tque.push({x-1,y});\n      }\n      if (M[x][y-1] == '.') {\n\tM[x][y-1] = '!';\n\tque.push({x,y-1});\n      }\n      if (M[x+1][y] == '.') {\n\tM[x+1][y] = '!';\n\tque.push({x+1,y});\n      }\n      if (M[x][y+1] == '.') {\n\tM[x][y+1] = '!';\n\tque.push({x,y+1});\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\nint move(int x,int y){\n\tint ans=1;\n\tmap[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\tans+=move(x+vec[i][0],y+vec[i][1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint dfs(int x, int y, vector<vector<bool> >& canGo){\n  if(!canGo[x][y]){ return 0; }\n\n  int ans = 1;\n  canGo[x][y] = false;\n  for(int i = 0; i < 4; i++)\n    ans += dfs(x + dx[i], y + dy[i], canGo);\n  \n  return ans;\n}\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    char input;\n    int sx, sy;\n    vector<vector<bool> > canGo(h + 2, vector<bool>(w + 2, false));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n        cin >> input;\n        if(input == '.' || input == '@'){ canGo[i][j] = true; }\n        if(input == '@'){\n          sx = i;\n          sy = j;\n        }\n      }\n    }\n    \n    int ans = dfs(sx, sy, canGo);\n    cout << ans << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nint w, h;\nchar B[20][21];\n\nint dfs(int i, int j) {\n   B[i][j] = '#';\n   int res = 1;\n   for (int k = 0; k < 4; k++) {\n      int y = i + dy[k], x = j + dx[k];\n      if (y >= 0 && y < h && x >= 0 && x < w && B[y][x] == '.') res += dfs(y, x);\n   }\n   return res;\n}\n\nint main() {\n   for (; scanf(\"%d%d\", &w, &h), w;) {\n      for (int i = 0; i < h; i++) {\n         scanf(\"%s\", B[i]);\n      }\n      for (int i = 0; i < h; i++) {\n         for (int j = 0; j < w; j++) {\n            if (B[i][j] == '@') printf(\"%d\\n\", dfs(i, j));\n         }\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nint done[20][20];\nchar tile[20][20];\nint mw,mh;\nstring temp;\nint loopchk(int h,int w,int v);\nint check(int h,int w);\nint check(int h,int w){\n\tint posw=114514;\n\tint posh=114514;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(tile[i][j] == '@'){\n\t\t\t\tposh = i;\n\t\t\t\tposw = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(posw!=114514){break;}\n\t}\n\treturn 1+loopchk(posh,posw,0);\n}\nint loopchk(int h,int w,int v){\n\tint value=v;\n\tif(done[h][w] == 1){\n\t\treturn value-1;\n\t}else{\n\t\tdone[h][w] = 1;\n\t}\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif(w + j < 0 || w + j > mw - 1){continue;}\n\t\t\tif(h + i < 0 || h + i > mh - 1){continue;}\n\t\t\tif(i == 0 && j == 0){continue;}\n\t\t\tif(i == -1 && j == -1 || i == -1 && j == 1 || i == 1 && j == -1 || i == 1 && j == 1){continue;} \n\t\t\tif(tile[h+i][w+j] == '.'){\n\t\t\t\tvalue = 1 + loopchk(h + i, w + j,value);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h, w != 0 || h != 0){\n\t\tmw = w;\n\t\tmh = h;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t\ttile[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> temp;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\ttile[i][j] = temp[j];\n\t\t\t}\n\t\t}\n\t\tcout << check(h,w) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Point{\n\tint x,y;\n};\n\nconst Point DIR[4] = {{1,0},{0,1},{-1,0},{0,-1}};\n\nbool inField(int w,int h, int x,int y){\n\treturn 0<= x && x < w && 0<= y && y<h;\n}\n\nint main(){\n\twhile(true){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w == 0){\n\t\t\tbreak;\n\t\t}\n\t\tchar map[20][20];\n\t\tbool visited[20][20];\n\t\tPoint init;//初期位置\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tvisited[i][j] = false;\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tinit = (Point){j,i};\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//入力終わり。探索開始\n\n\t\tint cnt=1;//初期位置の分を含める\n\t\tvisited[init.y][init.x] = true;//初期位置の処理\n\t\t\n\t\tqueue<Point> open;\n\t\topen.push(init);\n\t\twhile(open.empty()==false){\n\t\t\tPoint now = open.front();//先頭の要素をget\n\t\t\topen.pop();//front()とセットで使う。先頭の要素をremove\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tPoint next = {now.x + DIR[i].x, now.y + DIR[i].y};\n\t\t\t\tif(inField(w,h,next.x,next.y)==true){\n\t\t\t\t\tif(visited[next.y][next.x] == false && map[next.y][next.x] == '.'){\n\t\t\t\t\t\tvisited[next.y][next.x] = true;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\topen.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n}\n//(特にboolの)代入時にcheck == trueなんてしないように注意"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector> \nusing namespace std;\n\nint x,y;\nchar ti[30][30];\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint sum=0;\n\nbool valid(int i,int j)\n{\n\treturn(i>=0&&i<y&&j>=0&&j<x);\n}\n\nvoid dfs(int m,int n)\n{\n\tsum++;\n\tti[m][n]='#';\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint x,y;\n\t\tx=m+dx[i];\n\t\ty=n+dy[i];\n\t\tif(valid(x,y) && ti[x][y]=='.')\n\t\t  dfs(x,y);\n\t}\n}\n\nint main()\n{\n\tint m,n;\n\twhile(cin >> x >> y)\n\t{\n\t\tsum=0;\n\t\tif(!x&&!y)\n\t\t  break;\n\t\tfor(int i=0;i<y;i++)\n\t\t   for(int j=0;j<x;j++)\n\t\t   {\n\t\t   \t    cin >> ti[i][j];\n\t\t   \t    if(ti[i][j]=='@')\n\t\t   \t    {\n\t\t   \t    \tm=i;\n\t\t   \t    \tn=j;\n\t\t\t\t}\n\t\t   }\n\t\tdfs(m,n);\n\t    cout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n\nint w, h, cnt = 0;\n\nint solve( vector<vector<char>>& f, pair<int, int>& mp ) {\n\n\tif( mp.F - 1 >= 0 && f[mp.S][mp.F - 1] == '.' ) {\n\t\tcnt++;\n\t\tf[mp.S][mp.F - 1] = '#';\n\t\tsolve( f, make_pair( mp.F - 1, mp.S ) );\n\t}\n\tif( mp.F + 1 < w && f[mp.S][mp.F + 1] == '.' ) {\n\t\tf[mp.S][mp.F + 1] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F + 1, mp.S ) );\n\t}\n\tif( mp.S - 1 >= 0 && f[mp.S - 1][mp.F] == '.' ) {\n\t\tf[mp.S - 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S - 1 ) );\n\t}\n\tif( mp.S + 1 < h && f[mp.S + 1][mp.F] == '.' ) {\n\t\tf[mp.S + 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S + 1 ) );\n\t}\n\treturn cnt;\n}\n\nint main() {\n\n\twhile( 1 ) {\n\t\tcin >> w >> h; if( w == 0 && h == 0 ) break;\n\t\t\n\t\tpair<int, int> mp;\n\t\tvector<vector<char>> f;\n\t\tvector<char> tmp( w );\n\t\tREP( i, h ) {\n\t\t\tREP( j, w ) {\n\t\t\t\tcin >> tmp[j];\n\t\t\t\tif( tmp[j] == '@' ) { \n\t\t\t\t\tmp.first = j;\n\t\t\t\t\tmp.second = i; \n\t\t\t\t\ttmp[j] = '#';\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.push_back( tmp );\n\t\t}\n\n\t\tcout << solve( f, mp ) << endl;\n\t\tcnt = 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col]!='#' && M[nc.row][nc.col]!='*' && M[nc.row][nc.col]!='@')\n\t{\n\t  M[nc.row][nc.col] = '*';\n\t  S.push(nc);\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tscanf(\"%s\", C[i]);\n\t\t}\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nvector<string> field;\nint w,h;\n\nint bfs(int sx,int sy){\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++)\n\t\tfill(passed[i],passed[i]+21,false);\n\n\tqueue<pair<int,int> > *prv = new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt = new queue<pair<int,int> >();\n\n\tint dy[] = {-1,0,0,1};\n\tint dx[] = {0,-1,1,0};\n\n\tprv->push(make_pair(sy,sx));\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second] = true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np = cp;\n\t\t\t\tnp.first += dy[i];\n\t\t\t\tnp.second += dx[i];\n\t\t\t\t// ツ各ツ陛サツ古シツづ鳴暗堋督ョ\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(passed[np.first][np.second] || field[np.first][np.second] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tnxt->push(np);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n\n\tint cnt = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(passed[i][j])\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\nint main(){\n\n\twhile(cin >> w >> h && !(w == 0 && h == 0)){\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfield.push_back(str);\n\t\t\tfor(int k = 0; k < str.size(); k++){\n\t\t\t\tif(str[k] == '@'){\n\t\t\t\t\tsx = k;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(sx,sy) << endl;\n\n\t\tfield.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint w;\nint h;\nstring map[20];\nbool come[20][20];\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint dfs(int x, int y)\n{\n    if(x < 0 || y < 0 || w <= x || h <= y)return 0;\n    if(come[y][x])return 0;\n    if(map[y][x] == '#')return 0;\n\n    come[y][x] = true;\n\n    int ret = 1;\n    for(int i = 0; i < 4;i++)\n    {\n        ret += dfs(x + dx[i], y + dy[i]);\n    }\n    return ret;\n}\n\nint main()\n{\n    while( cin >> w >> h, (w | h) )\n    {\n        \n        string gomi;\n        getline(cin, gomi);//??°?????????\n\n        int px, py;\n\n        //input\n        for (int i = 0; i < h; i++)\n        {\n            getline(cin, map[i]);\n            for(int j = 0; j < w; j++)\n            {\n                come[i][j] = false;\n                if(map[i][j] == '@')\n                {\n                    px = j;\n                    py = i;\n                }\n            }\n        }\n        cout << dfs(px, py) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ck(i, j) ((i) >= 0 && (i) < (j))\nusing namespace std;\nchar tile[21][21];\nint  w, h, dy[] = {-1,0,1,0}, dx[] = {0,-1,0,1};\n\nint dfs(int y, int x){\n  tile[y][x] = '#';\n  int res = 1;\n  rep(i, 4){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ck(ny, h) && ck(nx, w) && tile[ny][nx] == '.')\n      res += dfs(ny, nx);\n  }\n\n  return res; \n}\n\nint main(){\n  while(scanf(\"%d%d\", &w, &h) && w && h){\n    rep(i, h)  scanf(\"%s\", tile[i]);\n    rep(i, h) rep(j, w)\n      if(tile[i][j] == '@') printf(\"%d\\n\", dfs(i, j));\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MH 20\n#define MW 20\nusing namespace std;\nchar f[MH][MW];\nbool v[MH][MW];\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nint w, h;\nint c = 0;\n\nvoid search(int x, int y) {\n\t++c;\n\tv[y][x] = true;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == false && f[ny][nx] != '#') {\n\t\t\tsearch(nx, ny);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint sx, sy;\n\n\twhile (cin >> w >> h, !(w == 0 && h == 0)) {\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif (f[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tfill(v[0], v[MH], false);\n\t\tsearch(sx, sy);\n\t\tcout << c << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar map[114][514];\nint w, h, ans;\nvoid dfs(int x, int y) {\n\tmap[x][y] = '#';\n\tans++;\n\tif (map[x - 1][y] == '.')dfs(x - 1, y);\n\tif (map[x + 1][y] == '.')dfs(x + 1, y);\n\tif (map[x][y - 1] == '.')dfs(x, y - 1);\n\tif (map[x][y + 1] == '.')dfs(x, y + 1);\n\treturn;\n}\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tint x, y;\n\t\tans = 0;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n\nbool done[22][22];\nint w, h;\nbool field[22][22];\nint ofs[4][2] = {\n  {0,1},\n  {1,0},\n  {-1,0},\n  {0,-1}\n};\nint dfs(int x, int y) {\n  if( !field[y][x] ) return 0;\n  if( done[y][x] ) return 0;\n  done[y][x] = true;\n  int cnt = 1;\n  rep(i, 4) {\n    int nx = x + ofs[i][0];\n    int ny = y + ofs[i][1];\n    cnt += dfs(nx, ny);\n  }\n  return cnt;\n}\n\nint main()\n{\n  while(cin >> w >> h, (w|h)) {\n    rep(i, 21) rep(j, 21) {\n      field[i][j] = done[i][j] = false;\n    }\n    int sx, sy;\n    rep(y, h) {\n      rep(x, w) {\n        char c;\n        cin >> c;\n        field[y + 1][x + 1] = c != '#';\n        if( c == '@' ) {\n          sx = x + 1;\n          sy = y + 1;\n        }\n      }\n    }\n\n    cout << dfs(sx, sy) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\t\n#include<functional>\n\nusing namespace std;\n\nnamespace MyLib {\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n}\n\nusing namespace MyLib;\n\nint dfs(int i, int j);\nint t[20][20];\nint b[20][20];\nint w, h;\n\n\nint main() {\n\n\tint x, y;\n\tstring buf;\n\twhile (cin >> w >> h, w) {\n\t\tREP(i, 20)\n\t\t\tfill(b[i],b[i]+20, 0);\n\t\tREP(i, h) {\n\t\t\tcin >> buf;\n\t\t\tREP(j, w) {\n\t\t\t\tif (buf[j] == '#')\n\t\t\t\t\tt[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tt[i][j] = 1;\n\t\t\t\tif (buf[j] == '@')\n\t\t\t\t\ty = i, x = j;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(y, x)-1 << endl;\n\n\n\n\t}\n\t\n}\n\nint dfs(int i, int j) {\n\tint a, x, c, d;\n\ta = x = c = d = 0;\n\tif (0 <= i - 1 && b[i - 1][j] == 0 && t[i - 1][j] == t[i][j]) {\n\t\tb[i - 1][j] = 1;\n\t\ta = dfs(i - 1, j);\n\t}\n\tif (h > i + 1 && b[i + 1][j] == 0 && t[i + 1][j] == t[i][j]) {\n\t\tb[i + 1][j] = 1;\n\t\tx = dfs(i +1, j);\n\t}\n\tif (0<= j- 1 && b[i][j-1] == 0 && t[i][j-1] == t[i][j]) {\n\t\tb[i][j-1] = 1;\n\t\tc = dfs(i , j-1);\n\t}\n\tif (w > j + 1 && b[i ][j+1] == 0 && t[i ][j+1] == t[i][j]) {\n\t\tb[i ][j+1] = 1;\n\t\td = dfs(i , j+1);\n\t}\n\treturn a + x + c + d + 1;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <cmath>\nusing namespace std;\n\nint main(){\n\n    int c[21][21],w,h;\n    memset(c,0,sizeof(c));\n    char t;\n    while(1){\n    cin>>w>>h;if(w==0&&h==0)return 0;\n    for(int i=0;i<w*h;i++){cin>>t;c[i%w][i/w]=t;}\n    for(int i=0;i<w*h;i++){\n      for(int j=0;j<w*h;j++)\n        if(c[j%w][j/w]==64){\n\t  if(c[j%w-1][j/w]==46)c[j%w-1][j/w]=64;\n          if(c[j%w+1][j/w]==46)c[j%w+1][j/w]=64;\n          if(c[j%w][j/w-1]==46)c[j%w][j/w-1]=64;\n          if(c[j%w][j/w+1]==46)c[j%w][j/w+1]=64;\n        }\n    }\n    int cou=0;\n    for(int i=0;i<w*h;i++)if(c[i%w][i/w]==64)cou++;\n    cout<<cou<<endl;\n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint main(){\n\n    while(true){\n\tint h,w;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tvector< vector<char> > board(h+2,vector<char>(w+2,'#'));\n\tint sx,sy;\n\tint ans = 0;\n\tREP(i,h)REP(j,w){\n\t    cin >> board[i+1][j+1];\n\t    if(board[i+1][j+1] == '@'){\n\t\tsx = j+1;\n\t\tsy = i+1;\n\t\tboard[sy][sx] = '#';\n\t\tans++;\n\t    }\n\t}\n\tqueue<int> qx;\n\tqueue<int> qy;\n\tqx.push(sx);\n\tqy.push(sy);\n\twhile(!qx.empty()){\n\t    int x = qx.front();\n\t    int y = qy.front();\n\t    qx.pop();\n\t    qy.pop();\n\t    REP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(board[ny][nx] == '.'){\n\t\t    board[ny][nx] = '#';\n\t\t    qx.push(nx);\n\t\t    qy.push(ny);\n\t\t    ans++;\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint w,h;\nstd::string f[20];\nint cnt;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nvoid rec(int x, int y){\n\tint mx, my;\n\n\tf[y][x] = '#';\n\tcnt++;\n\n\trep(i,4){\n\t\tmx = x + dx[i];\n\t\tmy = y + dy[i];\n\n\t\tif(mx < 0 || mx >= w)continue;\n\t\tif(my < 0 || my >= h)continue;\n\t\tif(f[my][mx] != '.')continue;\n\t\trec(mx, my);\n\t}\n}\n\n\n\n\nint main(){\n\twhile(std::cin >> w >> h, (w||h)){\n\t\trep(i,h){\n\t\t\tstd::cin >> f[i];\n\t\t}\n\t\tcnt = 0;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(f[i][j] == '@')rec(j,i);\n\t\t\t}\n\t\t}\n\t\tstd::cout << cnt << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint w,h;\nchar m[21][21];\n\nint dfs(int y,int x){\n  if(x < 0 || x >= w)return 0;\n  if(y < 0 || y >= h)return 0;\n  if(m[y][x] == '#') return 0;\n  int ret = 1;\n  m[y][x] = '#';\n  ret += dfs(y+1,x);\n  ret += dfs(y-1,x);\n  ret += dfs(y,x+1);\n  ret += dfs(y,x-1);\n  return ret;\n}\n\nint main(){\n  int sx,sy;\n  while(true){\n  scanf(\"%d %d\",&w,&h);\n  if(w == 0 && h == 0)break;\n  for(int i = 0;i < h;i++){\n    scanf(\"%s\",m[i]);\n    for(int j = 0;j < w;j++){\n      if(m[i][j] == '@'){\n        sx=j;sy=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",dfs(sy,sx));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint w,h;\nint sx,sy;\nchar room[20][21];\nint res;\n\nint dfs(int y,int x){\n  room[y][x]='#';\n  \n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(0<=nx && nx<w && 0<=ny && ny<h && room[ny][nx]=='.'){\n      res++;\n      dfs(ny,nx);\n    }\n  }\n}\n\nint main(){\n  while(cin>> w>> h,w){\n    res=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>> room[i][j];\n\tif(room[i][j]=='@'){\n\t  sy=i; sx=j;\n\t}\n      }\n    }\n    dfs(sy,sx);\n    cout<< res+1<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n//#include<windows.h>\n\nint masu[22][22];\nint ans=0;\nint i,j;\n\nvoid saiki(int x,int y){\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\tprintf(\"%d\",ans);\n\tSleep(100);\n\tsystem(\"cls\");\n\t*/\n\tmasu[x][y]=1;\n\tans++;\n\tif(masu[x][y-1]==0)saiki(x,y-1);\n\tif(masu[x+1][y]==0)saiki(x+1,y);\n\tif(masu[x][y+1]==0)saiki(x,y+1);\n\tif(masu[x-1][y]==0)saiki(x-1,y);\n}\n\nint main(){\n\tfor(;;){\n\tint W,H;\n\tint x,y;\n\tchar str[22];\n\t\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tmasu[i][j]=1;\n\t\t}\n\t}\n\t\n\tscanf(\"%d%d\", &W, &H);\n\tif(W == 0){\n\t\tbreak;\n\t}\n\tfor(i=0;i<H;i++){\n\t\tscanf(\"%s\",str);\n\t\tfor(j=0;j<W;j++){\n\t\t\tif(str[j]=='.')masu[i+1][j+1]=0;\n\t\t\tif(str[j]=='@'){\n\t\t\t\tx=i+1;\n\t\t\t\ty=j+1;\n\t\t\t\tmasu[i+1][j+1]=0;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\tprintf(\"%d\\n\",ans);\n\tsystem(\"cls\");\n\t*/\n\tsaiki(x,y);\n\t/*\n\tfor(i=0;i<22;i++){\n\t\tfor(j=0;j<22;j++){\n\t\t\tif(masu[i][j]==0)printf(\" \");\n\t\t\tif(masu[i][j]==1)printf(\"¡\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\t*/\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nbool b[21][21];\nint w,h,count=0;\n\nvoid dfs(int x, int y){\n b[y][x]=1;count++;\n int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=dx[i]+x;\n  ny=dy[i]+y;\n  if(0<=nx&&nx<w&&0<=ny&&ny<h)\n   if(b[ny][nx]==0)dfs(nx,ny);\n  }\n }\n\nint main(){\nchar a;\nint sx,sy;\nwhile(1){\ncin>>w>>h;\ncount=0;\nif(w+h==0)break;\nfor(int i=0;i<h;i++)\nfor(int j=0;j<w;j++){\ncin>>a;\nb[i][j]=0;\nif(a=='#')b[i][j]=1;\nif(a=='@'){sx=j;sy=i;}\n}\ndfs(sx,sy);\ncout<<count<<endl;\n}\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//red and black\n#if 0\n\n#endif // 0\n#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MAX 1000\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint matri[MAX][MAX],s[MAX][MAX];\nint w,h;\nbool valid(int x,int y)\n{\n    return x>=0&&x<w&&y>=0&&y<h&&matri[x][y];\n}\nint main()\n{\n    while(cin>>w>>h&&w&&h)\n    {\n        pair<int,int> p;\n        for(int j=0;j<h;j++)\n            for(int i=0;i<w;i++)\n            {\n                s[i][j]=1;\n                char c;\n                cin>>c;\n                if(c=='.')\n                    matri[i][j]=1;\n                else if(c=='#')\n                {\n                    matri[i][j]=0;\n                    s[i][j]=0;\n                }\n                else if(c=='@'){\n                    matri[i][j]=1;\n                    p.first=i;\n                    p.second=j;\n                }\n            }\n        stack<pair<int,int> > q;\n        int sum=0;\n        q.push(p);\n        s[p.first][p.second]=0;\n        while(!q.empty())\n        {\n            p=q.top();\n            int i;\n            for(i=0;i<4;i++)\n            {\n                int x=p.first+dx[i];\n                int y=p.second+dy[i];\n                if(valid(x,y)&&s[x][y])\n                {\n                    p.first=x;\n                    p.second=y;\n                    q.push(p);\n                    s[x][y]=0;\n                    break;\n                }\n            }\n            if(i>=4)\n            {\n                sum++;\n                q.pop();\n            }\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[22][22] = {} ;\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n/*\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct point {\n  int x, y;\n} POINT;\n\nint W, H;\nchar str[20][21];\nqueue<POINT> que;\n\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &W, &H);\n  if (!W && !H) return false;\n\n  for (i = 0; i < H; i++) {\n    scanf(\"%s\", str[i]);\n  }\n\n  return true;\n}\n\nint main() {\n  int i, j, cnt;\n  POINT p, q;\n\n  while (input()) {\n\n    while (!que.empty()) que.pop();\n    for (i = 0; i < H; i++) {\n      for (j = 0; j < W; j++) {\n        if (str[i][j] == '@') {\n          p.x = j;\n          p.y = i;\n          que.push(p);\n          i = H;\n          j = W;\n        }\n      }\n    }\n\n    cnt = 0;\n    while (!que.empty()) {\n      p = que.front();\n      que.pop();\n      if (p.x < 0 || W <= p.x || p.y < 0 || H <= p.y) continue;\n      if (str[p.y][p.x] == '#') continue;\n      cnt++;\n      str[p.y][p.x] = '#';\n      q.x = p.x;\n      q.y = p.y+1;\n      que.push(q);\n      q.x = p.x+1;\n      q.y = p.y;\n      que.push(q);\n      q.x = p.x-1;\n      q.y = p.y;\n      que.push(q);\n      q.x = p.x;\n      q.y = p.y-1;\n      que.push(q);\n    }\n\n    printf(\"%d\\n\", cnt);\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_N 50\n#define MAX_R 50\n\n#define MAX_W 20\n#define MAX_H 20\n\nint W, H;\nint ans[100000];\nint C = 0;\nchar maze[MAX_W][MAX_H];\n\nvoid dfs(int sx, int sy){\n\t\n\tmaze[sy][sx] = '#';\n\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H && maze[ny][nx] != '#'){\n\t\t\tans[C]++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile (true){\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint sx;\n\t\tint sy;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans[C] = 1;\n\t\tdfs(sx,sy);\n\t\tC++;\n\n\t}\n\n\tfor (int i = 0; i < C; i++){\n\t\tcout << ans[i] << endl;\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nint ans;\nvector<string> f;\n\nvoid solve(int x, int y)\n{\n  if (x < 0 || x >= f[0].size())\n    return;\n  if (y < 0 || y >= f.size())\n    return;\n  if (f[y][x] == '#')\n    return;\n  \n  ++ans;\n  f[y][x] = '#';\n\n  for (int i = 0; i < 4; ++i)\n    solve(x+dx[i], y+dy[i]);\n}\n\nint main()\n{\n  int W, H, x, y;\n  for ( ; ; ) {\n    cin >> W >> H;\n    if (W == 0 && H == 0)\n      break;\n\n    f.clear();\n    for (int i = 0; i < H; ++i) {\n      string tmp;\n      cin >> tmp;\n      int a = tmp.find_first_of(\"@\", 0);\n      if (a != string::npos) {\n\tx = a;\n\ty = i;\n      }\n      f.push_back(tmp);\n    }\n    ans = 0;\n    solve(x, y);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e17;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\n\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nsigned main()\n{\n\tIOS();\n\tint H,W;\n\tvector<int>ans;\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(H==0&&W==0)break;\n\t\tstring s[H];\n\t\trep(i,0,H)cin>>s[i];\n\t\tqueue<pair<int,int>>que;\n\t\trep(i,0,H){\n\t\t\trep(j,0,W){\n\t\t\t\tif(s[i][j]=='@')que.push({i,j});\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>visit(H,vector<int>(W,0));\n\t\twhile(!que.empty()){\n\t\t\tint i = que.front().fi;\n\t\t\tint j = que.front().se;\n\t\t\tque.pop();\n\t\t\tif(visit[i][j])continue;\n\t\t\tvisit[i][j] = true;\n\t\t\trep(k,0,4){\n\t\t\t\tint ni = i + dx[k];\n\t\t\t\tint nj = j + dy[k];\n\t\t\t\tif(ni<0||nj<0||H<=ni||W<=nj)continue;\n\t\t\t\tif(s[ni][nj]=='#')continue;\n\t\t\t\tif(visit[ni][nj])continue;\n\t\t\t\tque.push({ni,nj});\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\trep(i,0,H)rep(j,0,W)if(visit[i][j])res++;\n\t\tans.push_back(res);\n\t}\n\tfor(auto e:ans){\n\t\tcout<<e<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y);\n\twhile(!q.empty()){\n\t\tp=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(p.first+dx[i],p.second+dy[i]))\n\t\t\t\ttot+=1;\n\t\t\t\tP[p.first+dx[i]][p.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t\tp.first+=dx[i]; p.second+=dy[i];\n\t\t\t\tq.push(p);\n\t\t}\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[j][i];\n\t\t\t\tif(P[j][i]=='@')\n\t\t\t\t\tx1=j; y1=i; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t\tcout << tot << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nchar c[1000][1000];\nbool went[1000][1000];\nint ans,n,m;\nvoid go(int x,int y){\n    if(x>=n||y>=m||x<0||y<0)return ;\n    if(c[x][y]=='#')return;\n    if(went[x][y])return;\n    went[x][y]=true;\n    go(x+1,y);\n    go(x,y+1);\n    go(x-1,y);\n    go(x,y-1);\n    ans++;\n    return ;\n}\nint main(){\n    bool f;\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(n==0&&m==0)return 0;\n        f=true;\n        ans=0;\n        for(int i=0;i<n;i++)scanf(\"%s\",c[i]);\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++)went[i][j]=false;\n        for(int i=0;i<n&&f;i++)for(int j=0;j<m&&f;j++)if(c[i][j]=='@'){\n            go(i,j);\n            f=false;\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nvoid RB(int x,int y){\n    int W,H;\n    long count = 0;\n    char area[22][22]={};\n    char temp;\n    using P = pair <int,int>;\n    queue <P> que;\n    const int direction[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; \n\n    W = x;\n    H = y;\n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n            cin >> temp;\n            switch (temp){\n                case '.':\n                    area[i][j] = 1;\n                    break;\n                case '#':\n                    break;\n                case '@':\n                    area[i][j] = 0;\n                    que.push(P(i,j));\n                    break;\n            }\n        }\n    }\n\n    while(!que.empty()){\n        P temppair = que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int tempx = temppair.first + direction[i][0];\n            int tempy = temppair.second + direction[i][1];\n            if(area[tempx][tempy]==1){\n                que.push(P(tempx,tempy));\n                area[tempx][tempy] = 0;\n            }\n        }\n        count++;\n    }\n\n    cout << count << endl;\n\n}\n\nint main(){\n    int x,y;\n    while(1){\n        cin >> x >> y;\n        if(x == 0 && y == 0) break;\n        RB(x,y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nstring fie[30]={};\nint w,h;\nint c;\nbool visited[30][30];\n\nvoid dfs(int y,int x){\n    visited[y][x]=true;\n    c++;\n    int dx[]={1,0,-1,0};\n    int dy[]={0,1,0,-1};\n    rep(i,4){\n        if(0<=x+dx[i] && x+dx[i]<w  &&  0<=y+dy[i] && y+dy[i]<h  &&  fie[y+dy[i]][x+dx[i]]=='.'  &&  visited[y+dy[i]][x+dx[i]]==false){\n            dfs(y+dy[i],x+dx[i]);\n        }\n    }\n}\n\n\nint main(){\n    while(cin>>w>>h){\n        c=0;\n        if(w==0 && h==0)break;\n        rep(i,30)rep(j,30)visited[i][j]=false;\n        int sy,sx;\n        rep(i,h){\n            cin>>fie[i];\n        }\n        rep(i,h)rep(j,w){\n            if(fie[i][j]=='@') sy=i,sx=j;\n        }\n        \n        dfs(sy,sx);\n             \n        cout<<c<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nchar tile[30][30];\nint W, H;\nint ix, iy;\nint cnt;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid dfs(int x, int y){\n\ttile[y][x] = '#';\n\tcnt++;\n\tfor (int i = 0; i < 4; i++){\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (0<=X && X<W && 0<=Y && Y<H && tile[Y][X]!='#'){\n\t\t\tdfs(X, Y);//関数の再起\n\t\t}\n\t}\n}\n\n\n\n\n\nint main(){\n\n\twhile (cin >> W >> H, W + H != 0){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tfor (int x = 0; x < W; x++){\n\t\t\t\tcin >> tile[y][x];\n\t\t\t\tif (tile[y][x] == '@'){\n\t\t\t\t\tix = x;\n\t\t\t\t\tiy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(ix, iy);\n\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\nusing namespace std;\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\n\nint main() {\nint yoko,tate,px,py;\nwhile(cin>>yoko>>tate &&yoko){\n\n\tint m[25][25];\n\nstring st;\ncin>>yoko>>tate;\nfor(int i=1;i<tate+1;i++){\ncin>>st;\nfor(int j=1;j<yoko+1;j++){\nif(st[j-1]=='#') m[i][j]=-1;\nelse if(st[j-1]=='.') m[i][j]=0;\nelse if(st[j-1]=='@'){\n m[i][j]=1;\npx=i;\npy=j;\n}\n}\n}\nint ans=1;\nstack<pair<int,int> > s;\ns.push(make_pair(px,py));\n//cout<<\"pxpy \"<<px<<\" \"<<py<<endl;\nwhile(s.empty()==false){\npx=s.top().first;\npy=s.top().second;\ns.pop();\n\nfor(int i=0;i<4;i++){\n//cout<<px+dx[i]<<\" \"<<py+dy[i]<<endl;\n\tif(0<px+dx[i] && px+dx[i]<tate+1 && py+dy[i]>0 && py+dy[i]<yoko+1){\n\t\n\t\tif(m[px+dx[i]][py+dy[i]]==0){\n\t\t\tm[px+dx[i]][py+dy[i]]=1;\n\t\t\ts.push(make_pair(px+dx[i],py+dy[i]));\n\t\t\tans++;\n//cout<<px+dx[i]<<\" \"<<py+dy[i]<<\" \"<<ans<<endl;\n\t\t}\n\n\t}}\n}\n\ncout<<ans<<endl;\n\n}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <fstream>\n\nusing namespace std;\n#define SZ(x) (int)(x).size()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REPR(i,n) for(int i=(n)-1;i>=0;i--)\n#define ALL(s) (s).begin(), (s).end()\n#define so(V) sort(ALL(V))\n#define rev(V) reverse(ALL(V))\n#define uni(v) v.erase( unique(ALL(v)) , v.end());\n\ntypedef long long unsigned int llu;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\nconst double EPS = 1e-9;\nconst int MOD = 1e9 + 7;\nconst int INF = (1 << 29);\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\ntemplate<typename T>vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\ntemplate<typename T, typename U, typename... V>\ntypename enable_if<is_same<T, U>::value != 0>::type\nfill_v(U & u, const V... v) { u = U(v...); }\ntemplate<typename T, typename U, typename... V>\ntypename enable_if<is_same<T, U>::value == 0>::type\nfill_v(U & u, const V... v) { for (auto& e : u) fill_v<T>(e, v...); }\ntemplate<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return 1; } return 0; }\n\nint W, H;\nbool check(int y, int x) {\n\tif (y < 0 || y >= H)return false;\n\tif (x < 0 || x >= W)return false;\n\treturn true;\n}\n\nconst int BLACK = 1;\nconst int RED = -1;\nvector<vb> Ans;\nvvi Map;\nint dx[] = { -1,0,0,1 };\nint dy[] = { 0,-1,1,0 };\n\nvoid dfs(int x,int y){\n\tREP(i, 4) {\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (check(Y, X)) {\n\t\t\tif (Map[Y][X] == BLACK && (!Ans[Y][X])) {\n\t\t\t\tAns[Y][X] = true;\n\t\t\t\tdfs(X,Y);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> W >> H;\n\twhile (W != 0) {\n\t\tAns = vector<vb>(H, vb(W, false));\n\t\tMap = vvi(H, vi(W, 0));\n\t\tint x = 0, y = 0;\n\t\tREP(i, H) {\n\t\t\tstring S;\n\t\t\tcin >> S;\n\t\t\tREP(j, W) {\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tMap[i][j] = BLACK;\n\t\t\t\t}\n\t\t\t\telse if (S[j] == '#') {\n\t\t\t\t\tMap[i][j] = RED;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tMap[i][j] = BLACK;\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tAns[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\t\tint ans = 0;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif (Ans[i][j])ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint H, W;\nchar mas[21][21];\n\nint dfs(int x, int y) {\n    static int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n    int ret = 1;\n    mas[y][x] = '#';\n    for(int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && mas[ny][nx] == '.') {\n            ret += dfs(nx, ny);\n        }\n    }\n    return ret;\n}\n\nint main() {\n\n    while(cin >> W >> H, W) {\n\n        int sx, sy;\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == '@') sx = j, sy = i;\n            }\n        }\n        cout << dfs(sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define all(i) i.begin(), i.end()\n#define ll long long\n#define bl bool\n#define nn printf(\"\\n\");\n#define mod 1000000007\n\nusing namespace std;\n\nint w, h, cnt;\nvoid srch(int x, int y, vector<vector<char>> &inp, vector < vector <bool>> &hit)\n{\n\tif (x < 0 || w <= x || y < 0 || h <= y || inp[x][y] == '#') { return; }\n\tif (hit[x][y]) return;\n\thit[x][y] = true;\n\tcnt += 1;\n\tsrch(x + 1, y, inp, hit);\n\tsrch(x - 1, y, inp, hit);\n\tsrch(x, y + 1, inp, hit);\n\tsrch(x, y - 1, inp, hit);\n}\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) { break; }\n\t\tcnt = 0;\n\t\tvector<vector<char>> inp(w, vector<char>(h, 0));\n\t\tvector<vector<bool>> hit(w, vector<bool>(h, false));\n\t\tint x = 0, y = 0;\n\t\trep(i, h)\n\t\t{\n\t\t\trep(j, w)\n\t\t\t{\n\t\t\t\tcin >> inp[j][i];\n\t\t\t\tif (inp[j][i] == '@'){ x = j; y = i; }\n\t\t\t}\n\t\t}\n\t\tsrch(x, y, inp, hit);\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint W, H;\nint sx, sy;\nint ans;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvector<vector<char>>  field;\n\nbool is_out_of_range(int x, int y) {\n    return x < 0 || x >= W || y < 0 || y >= H;\n}\n\nvoid dfs(int x, int y) {\n    if (is_out_of_range(x, y)) return;\n    if (field[y][x] == '#') return;\n\n    field[y][x] = '#';\n    ans++;\n\n    for (int i = 0; i < 4; ++i) {\n        dfs(x + dx[i], y + dy[i]);\n    }\n    return;\n}\n\nint main() {\n\twhile(cin >> W >> H, W) {\n        ans = 0;\n        field.assign(H, vector<char>(W));\n        for (int y = 0; y < H; ++y) {\n            for (int x = 0; x < W; ++x) {\n                cin >> field[y][x];\n                if (field[y][x] == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n    \n        dfs(sx, sy);\n        cout << ans << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include <utility>\n#include <functional>\n//#include<>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n//#define int long long;\nsigned main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    int cnt{};\n    vector<string> v(h);\n    for(int i = 0; i < h; ++i){\n      cin >> v[i];\n    }\n    //initialize\n    pair<int, int> p;\n    queue<pair<int, int>> q;\t\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tif(v[i][j] == '@'){\n\t  p = make_pair(i,j);\n\t  q.push(p);\n\t}\n      }\n    }\n    while(!q.empty()){\n      pair<int, int> p;\n      p = q.front();\n      q.pop();\n\n      for(int k = 0; k < 4; ++k){\n\tint x = p.first + dx[k]; int y = p.second + dy[k];\n\tif(0 > x || h <= x || 0 > y || w <= y)continue;\n\tif('.' == v[x][y]){\n\t  v[x][y] = '@';\n\t  ++cn\n\t  q.push(make_pair(x, y));\n\t}\n      }\n    }\n    cout << cnt+1 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntypedef pair<int,int> P ;\n\nint main(){\n\n\tint dx[4]={0,0,-1,1};\n\tint dy[4]={-1,1,0,0};\n\n\t\n\twhile(1){\n\t\tint cnt=1;\n\t\tint w,h;\n\t\tint sx,sy;\n\t\tchar c[21][21];\n\n\t\tcin >> w >> h ;\n\t\tif( h==0 && w==0) return 0;\n\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tscanf(\"%s\", c[y]);\n\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\tif( c[y][x] == '@' ){\n\t\t\t\t\tsx = x; \n\t\t\t\t\tsy = y;\n\t\t\t\t }\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tq.push(P(sx,sy));\n\t\tc[sy][sx] = '#';\n\n\t\twhile(!q.empty()) {\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint mx = x+dx[i] , my = y+dy[i];\n\t\t\t\tif( mx<0 || my<0 || w<=mx || h<=my || c[my][mx] == '#'||c[my][mx] =='@') continue;\n\t\t\t\tq.push(P(mx,my));\t\n\t\t\t\tc[my][mx] = '#';\t\n\t\t\t\tcnt++;\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <array>\n\nconst int kSize = 20 + 2;\n\nstd::array<int, 4> ways = {-1, -kSize, +1, +kSize};\n\ninline int xy2pos(const int x, const int y){\n    return x + y * kSize;\n}\n\nstd::array<bool, kSize*kSize> Bfs(const std::array<bool, kSize*kSize> &tiles, int pos){\n    std::array<bool, kSize*kSize> arrived;\n    std::queue<int> q;\n    q.push(pos);\n    std::fill(arrived.begin(), arrived.end(), false);\n    while(!q.empty()){\n        pos = q.front();\n        q.pop();\n        arrived[pos] = true;\n        for(int way : ways)\n            if(tiles.at(pos + way) && !arrived.at(pos + way))\n                q.push(pos + way);\n    }\n    return arrived;\n}\n\nint main(){\n    int w,h;\n    std::array<bool,kSize*kSize> tiles; ///< true if black\n    while((std::cin >> w >> h) && w != 0){\n        std::fill(tiles.begin(), tiles.end(), false);\n        int pos;\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                char c;\n                std::cin >> c;\n                tiles[xy2pos(x,y)] = (c == '.');\n                if(c == '@'){\n                    pos = xy2pos(x,y);\n                    tiles[pos] = true;\n                }\n            }\n        }\n        auto arrived = Bfs(tiles, pos);\n        int sum = 0;\n        for(bool v : arrived)\n            sum += (v) ? 1 : 0;\n        std::cout << sum << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){ xy.push(pair<int, int>(i, j)); }\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '#';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\txy.pop();\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//00\n#include<iostream>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nint main(){\n  for(int W,H;cin>>W>>H,W|H;){\n    bool g[20][20];\n    queue<pair<int,int> > que;\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tchar c;\n\tcin>>c;\n\tg[y][x]=c=='.';\n\tif(c=='@'){\n\t  que.push(make_pair(y,x));\n\t}\n      }\n    }\n    int ans=0;\n    while(!que.empty()){\n      ans++;\n      int y=que.front().first;\n      int x=que.front().second;\n      que.pop();\n      int dy[]={0,1,0,-1};\n      int dx[]={1,0,-1,0};\n      for(int i=0;i<4;i++){\n\tint ny=y+dy[i];\n\tint nx=x+dx[i];\n\tif(0<=ny&&ny<H&&0<=nx&&nx<W&&g[ny][nx]){\n\t  que.push(make_pair(ny,nx));\n\t  g[ny][nx]=false;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1000000007;\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint ans;\nchar c[40][40];\nint a,b;\n\n\nvoid bfs(int sx, int sy) {\n\tqueue< pair<int,int> > q;\n\tqueue< PII > qp;\n\tq.push(MP(sx,sy));\n\tc[sx][sy] = 'x';\n\tfor (int i = 1; i < 1000; i++) {\n\t\twhile (!q.empty()) {\n\t\t\tPII v = q.front(); //get value\n\t\t\tq.pop();\n\t\t\tint x = v.first, y = v.second;\n\t\t\tif (c[x+1][y] == '.'){ qp.push(MP(x+1,y)); c[x+1][y] = 'x'; ans++; }\n\t\t\tif (c[x-1][y] == '.'){ qp.push(MP(x-1,y)); c[x-1][y] = 'x'; ans++; }\n\t\t\tif (c[x][y+1] == '.'){ qp.push(MP(x,y+1)); c[x][y+1] = 'x'; ans++; }\n\t\t\tif (c[x][y-1] == '.'){ qp.push(MP(x,y-1)); c[x][y-1] = 'x'; ans++; }\n\n\t\t}\n\t\twhile (!qp.empty()) {\n\t\t\tq.push(qp.front());\n\t\t\tqp.pop();\n\t\t}\n\t\t//\t\tfor (int h = 0; h < b+2; h++) {\n\t\t//\t\t\tfor (int w = 0; w < a+2; w++) {\n\t\t//\t\t\t\tcout << c[w][h];\n\t\t//\t\t\t}\n\t\t//\t\t\tcout << endl;\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\n\t}\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (true) {\n\t\tint sx,sy;\n\t\tcin >> a >> b;\n\t\tif (a == 0 && b == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int h = 0; h < b+2; h++) {\n\t\t\tfor (int w = 0; w < a+2; w++) {\n\t\t\t\tif (h == 0 || w == 0 || h == b+1 || w == a+1) {\n\t\t\t\t\tc[w][h] = '#';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> c[w][h];\n\t\t\t\t\tif (c[w][h] == '@') {\n\t\t\t\t\t\tsx = w;\n\t\t\t\t\t\tsy = h;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tbfs(sx,sy);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar tile[21][21];\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\n\nint sum=0;\n\nvoid check(int x,int y)\n{\n  if(tile[x][y]=='#')\n    return;\n  sum++;\n  tile[x][y]='#';\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>=0 &&x+dx[i]<21 &&y+dy[i]>=0 &&y+dy[i]<21)\n\t{\n\t  check(x+dx[i],y+dy[i]);\n\t}\n    }\n}\n\nint main()\n{\n  int w,h;\n  for(;cin>>w>>h,w||h;)\n    {\n      for(int i=0;i<21;i++)\n\t  for(int j=0;j<21;j++)\n\t      tile[i][j]='#';\n      \n      int x,y;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>tile[j][i];\n\t    if(tile[j][i]=='@')\n\t      {\n\t\tx=j,y=i;\n\t      }\n\t  }\n      sum=0;\n      check(x,y);\n      cout<<sum<<endl;\n      /*\n      for(int i=0;i<h;i++,cout<<endl)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cout<<tile[j][i];\n\t  }\n      */\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar m[21][21];\nint cnt=1,w,h;\nvoid dfs(int x,int y){\n  int i,j;\n  m[y][x]='#';\n  for(i=-1;i<=1;++i){\n    if(y+i<0) continue;\n    if(m[y+i][x]=='.'){\n      cnt++;\n      dfs(x,y+i);\n    }\n  }\n  for(j=-1;j<=1;++j){\n    if(x+j<0) continue;\n    if(m[y][x+j]=='.'){\n      cnt++;\n      dfs(x+j,y);\n    }\n  }\n}\nint main(){\n  int i,j,x,y;\n  while(cin>>w>>h){\n    if(w==0&&h==0) break;\n    for(i=0;i<21;++i)\n      for(j=0;j<21;++j)\n\tm[i][j]=0;\n    for(i=0;i<h;++i){\n      for(j=0;j<w;++j){\n\tcin>>m[i][j];\n\tif(m[i][j]=='@'){\n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n    cnt=1;\n    dfs(x,y);\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nchar tile[21][21];\nint W, H;\nint ans;\n\nvoid dfs( int x, int y ) {\n\tREP( i, 4 ) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H && tile[nx][ny] == '.' ) {\n\t\t\ttile[nx][ny] = '#';\n\t\t\tans++;\n\t\t\tdfs( nx, ny );\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile( cin >> W >> H, W, H ) {\n\t\t\n\t\tint sx, sy;\n\t\tREP( i, H ) {\n\t\t\tREP( j, W ) {\n\t\t\t\tcin >> tile[j][i];\n\t\t\t\tif( tile[j][i] == '@' ) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ttile[j][i] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tans = 0;\n\t\tdfs( sx, sy );\n\t\tcout << ans << endl;\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nconst int dx[4] = {0, 1, -1, 0}, dy[4] = {1, 0, 0, -1};\nint W, H;\nint solve(vector<string>& fld, int sx, int sy){\n    queue<pint> que;\n    int res = 0;\n    que.push(pint(sx, sy));\n    while(!que.empty()){\n        pint now = que.front(); que.pop();\n        if(fld[now.second][now.first] == '.'){\n            res++;\n            fld[now.second][now.first] = '#';\n        }else\n          continue;\n        rep(i, 4){\n            int nx = now.first + dx[i], ny = now.second + dy[i];\n            if(nx < 0 || ny < 0 || W <= nx || H <= ny)\n              continue;\n            que.push(pint(nx, ny));\n        }\n    }\n    return res;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> W >> H && W){\n        vector<string> fld(H);\n        rep(i, H) cin >> fld[i];\n        int sx, sy;\n        rep(i, H) rep(j, W)\n          if(fld[i][j] == '@'){\n              sx = j;\n              sy = i;\n              fld[i][j] = '.';\n              break;\n          }\n        cout << solve(fld, sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#define pi 3.14159\nusing namespace std;\n\nint a;\nchar map[20][20];\nint w, h;\nvoid dfs(int y, int x);\n\nint main() {\n\twhile(1) {\n\t\ta = 1;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tint x, y;\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif(map[i][j] == '@') {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\tmap[y][x] = 0;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == '.') { map[i][j] = -1;}\n\t\t\t}\n\t\t}\n\t\tdfs(y+1, x);\n\t\tdfs(y, x-1);\n\t\tdfs(y, x+1);\n\t\tdfs(y-1, x);\n\t\tcout << a <<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs(int y, int x) {\n\tif(y == -1 || x == -1 || y >= h || x >= w) {return ;}\n\tif(map[y][x] == '#') {return ;}\n\tif(map[y][x] == 0) {return ;}\n\tmap[y][x] = 0;\n\ta++;\n\tdfs(y-1, x);\n\tdfs(y, x-1);\n\tdfs(y, x+1);\n\tdfs(y+1, x);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W || H) {\n      memset(visited, false, sizeof(visited));\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      visited[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nstd::string field[20];\nint dx[4] = {0,-1,0,1};\t//右、上、左、下\nint dy[4] = {1,0,-1,0};\nint h,w;\nint cnt;\nvoid rec(int y,int x){\n\tfield[y][x] = '#';\n\tcnt++;\n\tint xi, yi;\n\trep(i,4){\n\t\txi = x, yi = y;\n\t\txi += dx[i];\n\t\tyi += dy[i];\n\n\t\tif(xi < 0 || xi >= w)continue;\n\t\tif(yi < 0 || yi >= h)continue;\n\t\tif(field[yi][xi] != '.')continue;\n\t\trec(yi,xi);\n\t}\n}\n\nint main(){\n\n\twhile(std::cin >> w >> h, (h||w)){\n\n\t\tcnt = 0;\n\n\t\trep(i,h){\n\t\t\tstd::cin >> field[i];\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\trec(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << cnt << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\nusing namespace std;\n\nstruct state { int y, x, step; };\nstatic const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n        int w, h;\n        while (scanf(\"%d%d\", &w, &h), w) {\n                vector<string> s(h);\n                for (int i = 0; i < h; i ++) cin >> s[i];\n                int sy, sx;\n                for (int i = 0; i < h; i ++) {\n                        for (int j = 0; j < w; j ++) {\n                                if (s[i][j] == '@') {\n                                        sy = i, sx = j;\n                                }\n                        }\n                }\n                vector<vector<bool>> used(h, vector<bool>(w, false));\n                queue<state> q;\n                q.push({sy, sx, 0});\n                used[sy][sx] = true;\n                while (!q.empty()) {\n                        state p = q.front(); q.pop();\n                        for (int d = 0; d < 4; d ++) {\n                                int xx = p.x + dx[d], yy = p.y + dy[d];\n                                if (xx < 0 || xx >= w || yy < 0 || yy >= h) continue;\n                                if (used[yy][xx] || s[yy][xx] == '#') continue;\n                                used[yy][xx] = true;\n                                q.push({yy, xx, p.step + 1});\n                        }\n                }\n                int ans = 0;\n                for (int i = 0; i < h; i ++) {\n                        for (int j = 0; j < w; j ++) {\n                                ans += used[i][j];\n                        }\n                }\n                printf(\"%d\\n\", ans);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n\nint frip(vector<vector<char>>& map, int h, int w, int H, int W)\n{\n    int cnt = (map[h][w] == '.') ? 1 : 0;\n    map[h][w] = 'x';\n    if(w != 0 && map[h][w-1] == '.'){\n        //++cnt;\n//        map[h-1][w-1] = 'x';\n        cnt += frip(map, h, w-1, H, W);\n    }\n    if(w != W-1 && map[h][w+1] == '.'){\n        //++cnt;\n//        map[h-1][w+1] = 'x';\n        cnt += frip(map, h, w+1, H, W);\n    }\n    if(h != H-1 && map[h+1][w] == '.'){\n        //++cnt;\n//        map[h+1][w-1] = 'x';\n        cnt += frip(map, h+1, w, H, W);\n    }\n    if(h != 0 && map[h-1][w] == '.'){\n        //++cnt;\n//        map[h+1][w+1] = 'x';\n        cnt += frip(map, h-1, w, H, W);\n    }\n    \n    return cnt;\n}\n\n\nint solve(vector<vector<char>>& map, int H, int W)\n{\n    int ci, cj;\n    for(int i=0;i<H;++i) for(int j=0;j<W;++j) if(map[i][j] == '@') { ci = i; cj = j; }\n    \n    return frip(map, ci, cj, H, W) + 1;\n}\n\n\nint main()\n{\n    int H, W;\n    while(cin >> W >> H, H){\n        vector<vector<char>> map(H);\n        for(int i=0;i<H;++i){\n            string str{};\n            cin >> str;\n            map[i] = vector<char>(str.begin(), str.end());\n        }\n        \n        cout << solve(map, H, W) << endl;\n//        for(int i=0;i<H;++i){\n//            for(int j=0;j<W;++j) cout << map[i][j];\n//            cout << endl;\n//        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};\n\nchar mp[20][22];\nint H, W;\n\nvoid dfs(int y, int x)\n{\n\tif (y < 0 || y >= H || x < 0 || x >= W || mp[y][x] == '#' || mp[y][x] == ' ') return;\n\n\tmp[y][x] = ' ';\n\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &W, &H), H || W) {\n\t\tint sy, sx;\n\n\t\trep(i, H) rep(j, W) {\n\t\t\tscanf(\"\\n%c\", &mp[i][j]);\n\t\t\tif (mp[i][j] == '@') sy = i, sx = j, mp[i][j] = '.';\n\t\t}\n\n\t\tdfs(sy, sx);\n\n\t\tint cnt = 0;\n\n\t\trep(i, H) rep(j, W) if (mp[i][j] == ' ') cnt++;\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\nchar cm[200][200];\nint im[200][200];\n int W,H;\nbool visited[200][200];\nint sy,sx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ntypedef pair<int,int> P;\n\nint bfs();\n\nint main(){\n \n\n  while(1)\n    {\n      cin >> W >> H;\n      if(W == 0 && H == 0)break;\n      memset(im,0,sizeof(im));\n      memset(visited,false,sizeof(visited));\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      cin >> cm[i][j];\n\t      if(cm[i][j] == '#'){\n\t\tim[i][j] = 8;\n\t      }\n\t      else if(cm[i][j] == '@')\n\t\t{\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t}\n\t    }\n\t}\n\n      cout << bfs() << endl;\n      /*     \n for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++)cout << im[i][j];\n\tcout << endl;\n      }\n      */\n\n    }\n}\n\nint bfs()\n{\n  int maxx = 0;\n  queue<P> que;\n  que.push(P(sx,sy)); \n  im[sy][sx] = 1;\n  int cou=1;\n  visited[sy][sx] = true;\n\n  while(que.size())\n    {\n      P p = que.front();\n      que.pop();\n\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.first + dx[i],ny = p.second + dy[i];\n\n\t  if(0 <= nx && nx < W && 0 <= ny && ny < H && cm[ny][nx] != '#' && !visited[ny][nx])\n\t    {\n\t      visited[ny][nx] = true;\n\t      cou++;\n\t      im[ny][nx]=cou;\n\t      maxx = max(maxx,im[ny][nx]);\n\t      que.push(P(nx,ny));\n\t    }\n\t}\n      \n    }\nreturn maxx;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint H,W,count=0;\nchar **map;\nbool **isCount;\n\nbool valid(int x,int y)\n{\n    return x<=(W-1)&&x>=0&&y<=(H-1)&&y>=0;\n}\n\nvoid bfs(int x,int y)\n{\n    if(valid(x,y)&&map[y][x]!='#' && !isCount[y][x])\n    {\n        count++;\n        isCount[y][x]=true;\n        for(int i=0;i<4;i++)\n            bfs(x+dx[i],y+dy[i]);\n    }\n  /*int D[100];\n  for(int i=0;i<100;i++)\n    D[i]=-1;\n  queue<int>Q;\n  Q.push(src);\n  D[src]=0;\n  while(!Q.empty())\n    {\n      int cur=Q.front();\n      Q.pop();\n       for(int dst=0;dst<n;dst++)\n\t{\n\t  if(M[cur][dst]==1&&D[dst]==-1)\n\t    {\n\t      D[dst]=D[cur]+1;\n\t      Q.push(dst);\n\t    }\n    }\n    }\n    for(int i=0;i<n;i++)\n        cout<<i+1<<' '<<D[i]<<endl;\n        */\n}\n\n\n\nint main()\n{\n    int x,y;\n    cin>>W>>H;\n    while(W!=0&&H!=0)\n    {\n        isCount=new bool*[H];\n        map=new char*[H];\n        for(int i=0;i<H;i++)\n        {\n            isCount[i]=new bool[W];\n            map[i]=new char[W];\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n                isCount[i][j]=false;\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n            {\n                cin>>map[i][j];\n                if(map[i][j]=='@')\n                {\n                    x=j;\n                    y=i;\n                }\n            }\n        }\n        bfs(x,y);\n        cout << count << endl;\n        delete map;\n        delete isCount;\n        cin>>W>>H;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\nchar heya[22][22];\nchar vis[22][22];\nint H,W;\n\nint solve(int x,int y){\n  if(y<0||y>=W) return 0;\n  if(x<0||x>=H) return 0;\n  if(heya[x][y]!='.') return 0;\n  if(vis[x][y]==1) return 0;\n  vis[x][y]=1;\n  int res=1;\n  res+=solve(x+1,y);\n  res+=solve(x-1,y);\n  res+=solve(x,y+1);\n  res+=solve(x,y-1);\n  return res;\n}\n\nint main(void){\n  int i,j;\n  int sx,sy;\n  while(cin>>W>>H,W||H){\n    sx=sy=0;\n    for(i=0;i<H;i++){\n      for(j=0;j<W;j++){\n        cin>>heya[i][j];\n        vis[i][j]=0;\n        if(heya[i][j]=='@'){\n          sx=i;sy=j;\n          heya[i][j]='.';\n        }\n      }\n    }\n    cout<<solve(sx,sy)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass P\n{\npublic:\n\tint x,y;\n\tP(int X,int Y)\n\t{\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\n\nint main()\n{\n\tstack<P>st;\n\tint n,m;\n\tint numX[4]={0,1,0,-1};\n\tint numY[4]={1,0,-1,0};\n\n\twhile(cin>>n>>m && n)\n\t{\n\t\tint flag[500][500]={};\n\t\tint count=0;\n\t\tstring in;\n\t\tchar set[500][500]={};\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tcin >> set[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(set[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tst.push(P(j,i));\n\t\t\t\t\tflag[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint xx,yy;\n\n\t\twhile(!st.empty())\n\t\t{\n\t\t\tcount++;\n\t\t\txx=st.top().x;\n\t\t\tyy=st.top().y;\n\t\t\tst.pop();\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tif(set[numY[i]+yy][numX[i]+xx]=='.' && flag[numY[i]+yy][numX[i]+xx]==0)\n\t\t\t\t{\n\t\t\t\t\tst.push(P(numX[i]+xx,numY[i]+yy));\n\t\t\t\t\tflag[numY[i]+yy][numX[i]+xx]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << count << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<cstdlib>\n#define cinf(n,x,y) for(int i=0;i<(n);i++) cin >> x[i] >> y[i];\ntypedef long long int ll;\nusing namespace std;\n\nint w,h;\nstring f[20];\nint cnt;\n\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\n\nvoid dfs(int x,int y){\n\tf[y][x]='#';\n\tcnt++;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\n\t\tif(nx<0||nx>=w)continue;\n\t\tif(ny<0||ny>=h)continue;\n\t\tif(f[ny][nx]!='.')continue;\n\n\t\tdfs(nx,ny);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> f[i];\n\t\t}\n\t\tcnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(f[i][j]=='@')dfs(j,i);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define nrep(i,n) for(int i=1;i<=(n);i++)\n#define FST first\n#define SEC second\nusing namespace std;\n\ntypedef pair <int,int> pxy;\n#define WMAX 20\n#define HMAX 20\nint dd[5]={0,1,0,-1,0};\nint W,H;\n\nvoid print(char map[HMAX][WMAX]){\n  putchar('\\n');\n  rep(i,H){\n    rep(j,W){\n      cout << map[i][j];\n    }\n    putchar('\\n');\n  }\n}\n\nint dfs(char map[HMAX][WMAX]){\n  stack <pxy> s;\n  int n=0;\n  rep(i,H){\n    if(n) break;\n    rep(j,W){\n      if(map[i][j]=='@'){\n\ts.push(pxy(j,i));\n\tn=1;\n\tbreak;\n      }\n    }\n  }\n\n  while(!s.empty()){\n    int cx=s.top().FST, cy=s.top().SEC;\n    s.pop();\n    if(map[cy][cx]=='.')\n      n++;\n    map[cy][cx]='#';\n    rep(r,4){\n      int nx=cx+dd[r], ny=cy+dd[r+1];\n      if(nx<0||W<=nx||ny<0||H<=ny||map[ny][nx]=='#')\n\tcontinue;\n      s.push(pxy(nx,ny));\n    }\n  }\n  return n;\n}\n\n\nint main(){\n  for(;;){\n    scanf(\"%d %d\",&W,&H);\n    if(!(W+H)) break;\n    \n    char map[HMAX][WMAX];\n    rep(i,H){\n      string s;\n      cin >> s;\n      strcpy(map[i],s.c_str());\n    }\n    printf(\"%d\\n\",dfs(map));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int W = 20, H = 20;\nchar board[H][W];\n\nint bfs(int x, int y, int w, int h){\n\tint dx[] = {0, -1, 1, 0}, dy[] = {-1, 0, 0, 1}, c = 0;\n\tqueue<P> q;\n\tq.push(make_pair(x, y));\n\tboard[y][x] = '#';\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\t\t++c;\n\t\tfor(int i = 0;i < 4;++i){\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && board[ny][nx] == '.'){\n\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\tboard[ny][nx] = '#';\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main(){\n\tint w, h, x, y;\n\twhile(cin >> w >> h, w){\n\t\tfor(int i = 0;i < h;++i){\n\t\t\tfor(int j = 0;j < w;++j){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(x, y, w, h) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n#define loop(i,a,b) for(int i = a ; i < b ; i++)\n#define rep(i,a) for(int i = 0 ; i < a ; i++) \n\nchar maze[21][21];\nint dx[4] = { 0, 0,-1, 1};\nint dy[4] = {-1, 1, 0, 0};\nint H,W;\nbool inmaze(int x,int y){\n  return (0<=x && x<H) && (0<=y && y<W);\n}\n\nint dfs(int x,int y){\n  if(!inmaze(x,y))return 0;\n  maze[x][y] = '#';\n  int res = 1;\n  rep(i,4){\n    if(maze[x+dx[i]][y+dy[i]] == '.'){\n      res += dfs(x+dx[i],y+dy[i]);\n    }\n  }\n  return res;\n}\nint main(void){\n  while(cin>>W>>H,H+W){\n    int sx,sy;\n    rep(i,H){\n      string s;\n      cin>>s;\n      rep(j,W){\n\tmaze[i][j] = s[j];\n\tif(s[j] == '@'){\n\t  sx = i;sy = j;\n\t}\n      }\n    }\n    maze[sx][sy] = '.';\n    cout<<dfs(sx,sy)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (cin >> w >> h, w || h){\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\n\tdfs(sx, sy);\n\n\tcout << tile << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint W, H;\nint x[4] = {1,0,-1,0};\nint y[4] = {0,-1,0,1};\n\nbool in_map(int h, int w) {\n  return (1 <= h && h <= H && 1 <= w && w <= W);\n}\n\nchar M[25][25];\nint cnt;\nvoid dfs(int h, int w) {\n  cnt += 1;\n  M[h][w] = '#';\n  for (int i = 0; i < 4; i++) {\n    int nh = h+y[i]; int nw = w+x[i];\n    if (in_map(nh, nw) && M[nh][nw] != '#') {\n      dfs(nh, nw);\n    }\n  }\n}\n\nint main() {\n  int sh,sw;\n  while(cin >> W >> H && W > 0) {\n    cnt = 0;\n    for (int h = 1; h <= H; h++) {\n      for (int w = 1; w <= W; w++) {\n        cin >> M[h][w];\n        if (M[h][w] == '@') {\n          sh = h; sw = w;\n        }\n      }\n    }\n    dfs(sh, sw);\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp Red and Black\n//???????????????????£?10?????????????????°20???\n#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nint tile[21][21]={0};\nint d[21][21]={0};\nint W,H;\nchar a;\npair<int,int> person;\nint answer=0;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nbool valid(int x,int y){\n    return (x>=0 && x<H && y>=0 && y<W && tile[x][y]==1);\n}\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nvoid bfs(int x,int y){\n    queue<pair<int,int>> Q;\n    pair<int,int> place = make_pair(x,y);\n    Q.push(place);\n    ++answer;\n    d[x][y]=1;\n    //cout<<\"visited (\"<<x+1<<\",\"<<y+1<<\")\\n\";\n\n    while(!Q.empty()){\n        place=Q.front();\n        Q.pop();\n        for(int i=0;i<4;++i){\n            pair<int,int> next=make_pair(place.first+dx[i],place.second+dy[i]);\n            if(tile[next.first][next.second]!=0 && d[next.first][next.second]==0 && valid(next.first,next.second)){\n                Q.push(next);\n                d[next.first][next.second]=1;\n                //cout<<\"visited (\"<<next.first+1<<\",\"<<next.second+1<<\")\\n\";\n                ++answer;\n            }\n        }\n    }\n}\n\nint main(){\n    \n    \n    while(cin>>W>>H && W!=0){\n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                cin>>a;\n                if(a=='.'){\n                    tile[i][j]=1;\n                }\n                else if(a=='@'){\n                    person.first=i;\n                    person.second=j;\n                }\n            }\n        }\n\n        bfs(person.first,person.second);\n\n        cout<<answer<<\"\\n\";\n        answer=0;\n        Fill(tile,0);\n        Fill(d,0);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nchar s[32][32];\nint cnt;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nvoid dfs(int y, int x)\n{\n\tcnt++;\n\ts[y][x]=0;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint ny=y+dy[i];\n\t\tint nx=x+dx[i];\n\t\tif(s[ny][nx]=='.')\n\t\t\tdfs(ny,nx);\n\t}\n}\n\nint main()\n{\n\tint w,h;\n\twhile(cin >> w >> h, w||h)\n\t{\n\t\tcnt = 0;\n\t\tmemset(s,0,sizeof(s));\n\t\tfor(int i=1; i<=h; i++)\n\t\t{\n\t\t\tcin >> s[i]+1;\n\t\t}\n\n\t\tfor(int i=1; i<=h; i++)\n\t\tfor(int j=1; j<=w; j++)\n\t\tif(s[i][j]=='@')\n\t\t{\n\t\t\tdfs(i,j);\n\t\t\tbreak;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nint main( void )\n{\n\tconst int dx[4] = { 1, 0, -1, 0 };\n\tconst int dy[4] = { 0, -1, 0, 1 };\n\n\tint w, h;\n\twhile ( cin>>w>>h && ( w != 0 && h != 0 ) )\n\t{\n\t\tvector < vector <char> > V( h, vector <char>(w, false) );\n\t\tqueue < pair<int,int> > Q;\n\n\t\tfor ( int i = 0; i < h; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < w; j++ )\n\t\t\t{\n\t\t\t\tcin >> V[i][j];\n\t\t\t\tif ( V[i][j] == '@' )\n\t\t\t\t\tQ.push( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\n\t\twhile ( !Q.empty() )\n\t\t{\n\t\t\tpair <int,int> now = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tV[now.first][now.second] = 'v';\n\n\t\t\tfor ( int i = 0; i < 4; i++ )\n\t\t\t{\n\t\t\t\tint nx = now.second + dx[i];\n\t\t\t\tint ny = now.first + dy[i];\n\n\t\t\t\tif ( ( nx < 0 || nx >= w ) || ( ny < 0 || ny >= h ) )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( V[ny][nx] != '.' )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tQ.push( make_pair( ny, nx ) );\n\n\t\t\t}\n\t\t}\n\n\t\tint kotae = 0;\n\t\tfor ( int i = 0; i < h; i++ )\n\t\t{\n\t\t\tfor ( int j = 0; j < w; j++ )\n\t\t\t{\n\t\t\t\tif ( V[i][j] == 'v' )\n\t\t\t\t\tkotae++;\n\t\t\t}\n\t\t}\n\n\t\tcout << kotae << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint W,H;\nvoid solve(int,int);\nchar dfs[20][20];\nint d_x[]={1,0,-1,0},d_y[]={0,1,0,-1};\nint main(){\n\t\n\twhile(1){\n\t\tint ans=0;\n\t\tcin>>W>>H;\n\t\tif(W==0&&H==0)\tbreak;\n\n\t\tint dx,dy;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>dfs[j][i];\n\t\t\t\tif(dfs[j][i]=='@'){\n\t\t\t\t\tdx=j;\n\t\t\t\t\tdy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(dx,dy);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(dfs[j][i]=='T')\n\t\t\t\t\tans++;\n\t\tcout<<ans<<endl;\n\t\tmemset(dfs,0,sizeof(dfs));\n\t}\n}\n\nvoid solve(int x,int y){\n\tdfs[x][y]='T';\n\t\n\tfor(int j=0;j<4;j++){\n\t\tint mx=x+d_x[j],my=y+d_y[j];\n\t\tif(mx<0||my<0||mx>W||my>H)\tcontinue;\n\t\tif(dfs[mx][my]=='.')\n\t\t\tsolve(mx,my);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define USE_CPP11\n// #define USE_PRINTF\n\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <numeric>\n#include <complex>\n#include <memory>\n#include <sstream>\n\n#ifdef USE_CPP11\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#endif\n\n#define PRINT(obj) cout << obj << endl\n#define REP(i, n) for(int (i) = 0; (i) < (n); i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nnamespace Scanner {\n#ifdef USE_PRINTF\n  int    nextInt()    { int    d; scanf(\"%d\" , &d); return d; }\n  float  nextFloat()  { float  f; scanf(\"%f\" , &f); return f; }\n  double nextDouble() { double f; scanf(\"%lf\", &f); return f; }  \n  string nextString() { string s; scanf(\"%s\" , &s); return s; }\n  ll     nextll()     { ll     l; scanf(\"%ll\", &l); return l; }\n#else\n  int    nextInt()    { int    d; cin >> d; return d; }\n  float  nextFloat()  { float  f; cin >> f; return f; }\n  double nextDouble() { double f; cin >> f; return f; }  \n  string nextString() { string s; cin >> s; return s; }\n  ll     nextll()     { ll     l; cin >> l; return l; }\n#endif\n\n  string getLine() { \n    string input;\n    getline(cin, input);\n    return input;\n  }\n};\n\nnamespace myLibrary {\n  vector<string> split(const string& str, char delim) {\n    vector<string> ret;\n    size_t current = 0, found;\n    while ((found = str.find_first_of(delim, current)) != string::npos) {\n      ret.push_back(string(str, current, found - current));\n      current = found + 1;\n    }\n    ret.push_back(string(str, current, str.size() - current));\n    return ret;\n  }\n  \n#ifdef USE_CPP11\n  ///\n  /// higher-order functional\n  /// This is like map in haskell, python, etc.\n  /// Sample usage:\n  ///   vector<int> a = {1, 2, 3, 4, 5};\n  ///   vector<int> b = myLibrary::_Map<int, int>(a, [](int n){\n  ///     return n * n;\n  ///   });\n  /// Result:\n  ///   b = 1, 4, 9, 16, 25\n  ///\n  template<typename T_IN, typename T_OUT, class Functor>\n  vector<T_OUT> _Map(vector<T_IN> src, Functor func) {\n    vector<T_OUT> ret;\n    for (int i = 0; i < src.size(); i++) {\n      ret.push_back(func(src[i]));\n    }\n    return ret;\n  }\n#endif\n};\n\nstruct State {\npublic:\n  bool onGrand;\n  bool isLeftUp;\n  bool isRightUp;\n  \n  State(): onGrand(true), isLeftUp(false), isRightUp(false) { }\n};\n\nenum Square {\n  BLACK, RED\n};\n\nstruct Position {\npublic:\n  int x, y;\n  Position() { };\n  Position(int x, int y): x(x), y(y) { };\n};\n\nint main() {\n  while (true) {\n    int W = Scanner::nextInt();\n    int H = Scanner::nextInt();\n    if (W + H == 0) break;\n    \n    Square field[21][21];\n    memset(field, RED, sizeof(field));\n    \n    Position startPos;    \n    REP(i, H) {\n      string input = Scanner::nextString();\n      REP(j, W) {\n        switch (input[j]) {\n          case '.': { field[i][j] = BLACK;  break; }\n          case '#': { field[i][j] = RED;    break; }\n          case '@': { \n            startPos.x = i;\n            startPos.y = j;\n            field[i][j] = RED; \n            break; \n          }\n        }\n      }  \n    }\n    \n    int count = 1;\n    \n    queue<Position> q;\n    q.push(startPos);\n     \n    int dx[4] = { 0, -1, 1, 0 };\n    int dy[4] = { -1, 0, 0, 1 };\n    \n    while (!q.empty()) {\n      Position p = q.front(); q.pop();\n      REP(i, 4) {\n        int nx = p.x + dx[i];\n        int ny = p.y + dy[i];\n        if (nx < 0) continue;\n        if (ny < 0) continue;\n        \n        if (field[nx][ny] == BLACK) {\n          q.push(Position(nx, ny));\n          field[nx][ny] = RED;\n          count++;\n        } \n      }  \n    } \n    PRINT(count);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col] != '*' && M[nc.row][nc.col] != '#' && M[nc.row][nc.col] != '@')\n\t{\n\t  S.push(nc);\n\t  M[nc.row][nc.col] = '*';\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint h,w;\nstring str[30];\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint dfs(int y,int x){\n    str[y][x] = '#';\n    int res = 0;\n    for(int i=0;i<4;i++){\n        if(y+dy[i]<0 || y+dy[i]>=h || x+dx[i]<0 || x+dx[i]>=w || str[y+dy[i]][x+dx[i]]!='.') continue;\n        res += dfs(y+dy[i],x+dx[i])+1;\n    }\n    return res;\n}\n\nint main()\n{\n    \n    while(cin >> w >> h,w!=0&&h!=0){\n        for(int i=0;i<h;i++) cin >> str[i];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(str[i][j] == '@'){\n                    cout << dfs(i,j)+1 << endl;\n                }\n            }\n        }\n    }\n\n    return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nvector<string> Tiles;\nvoid counts(int NW,int NH,int W,int H){\n\tif(NW!=0){\n\t\tif(Tiles[NH][NW-1]=='.'){\n\t\t\tans++;\n\t\t\tTiles[NH][NW-1] = 'D';\n\t\t\tcounts(NW-1,NH,W,H);\n\t\t}\n\t}\n\tif(NH!=0){\n\t\tif(Tiles[NH-1][NW]=='.'){\n\t\t\tans++;\n\t\t\tTiles[NH-1][NW] = 'D';\n\t\t\tcounts(NW,NH-1,W,H);\n\t\t}\n\t}\n\tif(NW<W-1){\n\t\tif(Tiles[NH][NW+1]=='.'){\n\t\t\tans++;\n\t\t\tTiles[NH][NW+1] = 'D';\n\t\t\tcounts(NW+1,NH,W,H);\n\t\t}\n\t}\n\tif(NH<H-1){\n\t\tif(Tiles[NH+1][NW]=='.'){\n\t\t\tans++;\n\t\t\tTiles[NH+1][NW] = 'D';\n\t\t\tcounts(NW,NH+1,W,H);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tint W,H;\n\tint FW,FH;\n\tcin >> W >> H;\n\tint loop,loop2;\n\twhile(W){\n\t\tvector<string> (H).swap(Tiles);\n\t\tfor(loop=0;loop<H;loop++){\n\t\t\tcin >> Tiles[loop];\n\t\t}\n\t\tfor(loop=0;loop<H;loop++){\n\t\t\tfor(loop2=0;loop2<W;loop2++){\n\t\t\t\tif(Tiles[loop][loop2]=='@'){\n\t\t\t\t\tFW = loop2;\n\t\t\t\t\tFH = loop;\n\t\t\t\t\tloop = H;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1;\n\t\tcounts(FW,FH,W,H);\n\t\tcout << ans << endl;\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n\nusing namespace std;\n\nvector<string> map;\nint w,h,area;\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nvoid f(int x,int y){\n\tmap[y][x]='#';\n\tfor(int i=0;i<4;i++)\n\t\tif(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h)\n\t\t\tif(map[y+dy[i]][x+dx[i]]=='.'){\n\t\t\t\tarea++;\n\t\t\t\tf(x+dx[i],y+dy[i]);\n\t\t\t}\n}\n\nint main(){\n\tostringstream out;\n\n\tstring line;\n\n\twhile(cin >> w >> h, w|h){\n\t\tmap.clear();\n\t\tint x=-1,y;\n\t\tarea=1;\n\t\tfor(int iy=0;iy<h;iy++){\n\t\t\tcin >> line;\n\t\t\tmap.push_back(line);\n\t\t\tif(x==-1)\n\t\t\t\tfor(int ix=0;ix<line.length();ix++)\n\t\t\t\t\tif(line[ix]=='@'){\n\t\t\t\t\t\tx=ix;\n\t\t\t\t\t\ty=iy;\n\t\t\t\t\t}\n\t\t}\n\n\t\tf(x,y);\n\n\t\tout << area << endl;\n\t}\n\n\n\tcout << out.str();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;  //  ????????§?????????\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)    //  ????????????????¢????????????????????????????????????°???\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n  while(1){\n    int w,h,s,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},an=1;\n    string mp[20];\n    queue<int> t;\n    cin>>w>>h;\n    if(w==0)break;\n    for(int i=0;i<h;i++){\n      cin>>mp[i];\n      for(int j=0;j<w;j++)if(mp[i][j]=='@')s=w*i+j;\n    }\n    t.push(s);\n    while(!t.empty()){\n      s=t.front();\n      int x=s%w,y=s/w;\n      t.pop();\n      for(int i=0;i<4;i++){\n\tint x1=x+dx[i],y1=y+dy[i];\n\tif(0<=x1&&x1<w&&0<=y1&&y1<h){\n\t  if(mp[y1][x1]=='.'){\n\t    t.push(w*y1+x1);\n\t    mp[y1][x1]='#';\n\t    an++;\n\t  }\n\t}\n      }\n    }\n    cout<<an<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint W, H, x[30][30] = {};\n\t\tchar str[30][30];\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tcin>>str[i][j];\n\t\t\t\tif(str[i][j] == '@') x[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\n\t\tint q = 0;\n\t\twhile(1){\n\t\t\tint z = 0;\n\t\t\tfor(int i = 0; i < W; i++){\n\t\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\t\tif(x[i][j] == 1){\n\t\t\t\t\t\tif(i > 0 && str[i - 1][j] == '.') x[i - 1][j] = 1;\n\t\t\t\t\t\tif(i < H - 1  && str[i + 1][j] == '.') x[i + 1][j] = 1;\n\t\t\t\t\t\tif(j > 0 && str[i][j - 1] == '.') x[i][j - 1] = 1;\n\t\t\t\t\t\tif(j < W - 1&& str[i][j + 1] == '.') x[i][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < W; i++){\n\t\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\t\tif(x[i][j] == 1) z++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(z == q) break;\n\t\t\tq = z;\n\t\t}\n\t\t\n\t\tcout<<q<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\nchar cm[200][200];\nint im[200][200];\n int W,H;\nbool visited[200][200];\nint sy,sx;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\ntypedef pair<int,int> P;\n\nint bfs();\n\nint main(){\n \n\n  while(1)\n    {\n      cin >> W >> H;\n      if(W == 0 && H == 0)break;\n      memset(im,0,sizeof(im));\n      memset(visited,false,sizeof(visited));\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      cin >> cm[i][j];\n\t      if(cm[i][j] == '#'){\n\t\tim[i][j] = 8;\n\t      }\n\t      else if(cm[i][j] == '@')\n\t\t{\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t  im[i][j] = 1;\n\t\t}\n\t    }\n\t}\n\n      cout << bfs() << endl;\n      /*     \n for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++)cout << im[i][j];\n\tcout << endl;\n      }\n      */\n\n    }\n}\n\nint bfs()\n{\n  int maxx = 0;\n  queue<P> que;\n  que.push(P(sx,sy)); \n  im[sy][sx] = 1;\n  int cou=1;\n  visited[sy][sx] = true;\n\n  while(que.size())\n    {\n      P p = que.front();\n      que.pop();\n\n      for(int i=0;i<4;i++)\n\t{\n\t  int nx = p.first + dx[i],ny = p.second + dy[i];\n\n\t  if(0 <= nx && nx < W && 0 <= ny && ny < H && cm[ny][nx] != '#' && !visited[ny][nx])\n\t    {\n\t      visited[ny][nx] = true;\n\t      cou++;\n\t      im[ny][nx]=cou;\n\t      maxx = max(maxx,im[ny][nx]);\n\t      que.push(P(nx,ny));\n\t    }\n\t}\n      \n    }\nreturn cou;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint main(void){\n  int W,H;\n  char room[20][20];\n  int i,j,k;\n  int count;\n  scanf(\"%d %d\",&W,&H);\n  while(!(W==0&&H==0)){\n    for(i=0;i<H;i++){\n      scanf(\"%s\",room[i]);\n    }\n    for(i=0;i<W*H;i++){\n      for(j=1;j<H;j++){\n\tfor(k=0;k<W;k++){\n\t  if(room[j][k]!='#' && room[j-1][k]=='@'){\n\t    room[j][k]='@';\n\t  }\n\t}\n            }\n      for(j=0;j<H;j++){\n\tfor(k=1;k<W;k++){\n\t  if(room[j][k]!='#' && room[j][k-1]=='@'){\n\t    room[j][k]='@';\n\t  }\n\t}\n      }\n      for(j=0;j<H-1;j++){\n\tfor(k=0;k<W;k++){\n\t  if(room[j][k]!='#' && room[j+1][k]=='@'){\n\t    room[j][k]='@';\n\t  }\n\t}\n      }\n      for(j=0;j<H;j++){\n\tfor(k=0;k<W-1;k++){\n\t  if(room[j][k]!='#' && room[j][k+1]=='@'){\n\t    room[j][k]='@';\n\t  }\n\t}\n      }\n    }\n    count=0;\n    for(i=0;i<H;i++){\n      for(j=0;j<W;j++){\n\tif(room[i][j]=='@'){\n\t  count++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n    scanf(\"%d %d\", &W,&H);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\nint x,y,p,q,i,w,h,r=1;\nint j,k[101][101];\nchar s[101][101];\nint a[]={1,-1,0,0}, b[]={0,0,1,-1};\nvoid func(int x, int y){\n    for(i=0;i<4;i++){\n        if (x+a[i]<=h&&x+a[i]>0&&y+b[i]<=w&&y+b[i]>0){\n            if(k[x+a[i]][y+b[i]]==1);\n            else if(s[x+a[i]][y+b[i]]=='.'){\n                r++;\n                k[x+a[i]][y+b[i]]=1;\n                func(x+a[i],y+b[i]);\n            }\n            \n        }\n    }\n}\n\nint main(){\n        while(1){\n        scanf(\"%d %d\",&w,&h);\n        if (w==0&&h==0) break;\n        for (i=1;i<=h;i++){\n            for (j=1;j<=w;j++){\n                scanf(\"%c\",&s[i][j]);\n                if (s[i][j]=='@') k[i][j]=1;\n                else k[i][j]=0;\n                if (s[i][j]=='@') {\n                    p=i; q=j;\n                }\n            }\n        }\n        func(p,q);\n        printf(\"%d\\n\",r);\n        \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int make_mask(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a, n, m) if (opt_debug) { FOR(__i, 0, (n)){ darr_range( (a)[__i], 0, (m) ); } }\n#define dvec2(v) if (opt_debug) { FOR(__i, 0, v.size()){ dvec( (v)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define dumpv(x) if (opt_debug) { cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nint g_height, g_width;\nbool in_field(P p) {\n\treturn (0 <= p.Y && p.Y < g_height) && (0 <= p.X && p.X < g_width);\n}\n// }}}\n// }}}\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\tint W, H;\n\twhile (cin >> W >> H, W || H) {\n\t\tg_height = H;\n\t\tg_width = W;\n\t\tqueue<P> q;\n\t\tVVC field = VVC(H, VC(W));\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\tq.push(P(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.front(); q.pop();\n\t\t\tans++;\n\t\t\tFOR (d, 0, 4) {\n\t\t\t\tP np = p + dydx4[d];\n\t\t\t\tif (in_field(np) && field[np.Y][np.X] == '.') {\n\t\t\t\t\tq.push(np);\n\t\t\t\t\tfield[np.Y][np.X] = '!';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nint a,b,ans;\nint q[20+5][20+5];\nchar p[20+5][20+5];\n\nusing namespace std;\nint main() {\n\tqueue<pair<int,int> > M;\n\tpair<int,int> X;\n\twhile(cin >> a >> b){\n\t\tfor (int i=1; i<=21; i++){\n\t\t\tfor (int j=1; j<=21; j++){\n\t\t\t\tq[i][j] = 0;\n\t\t\t\tp[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tif (a==0) return 0;\n\t\tans = 0;\n\t\tfor (int i=1; i<=b; i++){\n\t\t\tfor (int j=1; j<=a; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@'){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tans = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\n\t\twhile(!M.empty()){\n\t\t\ta = M.front().first;\n\t\t\tb = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int i=0; i<=3; i++){\t\t\n\t\t\t\tif (p[a+dx[i]][b+dy[i]]=='.' && q[a+dx[i]][b+dy[i]]==0){\n\t\t\t\t\tM.push(make_pair(a+dx[i],b+dy[i]));\n\t\t\t\t\tq[a+dx[i]][b+dy[i]] = 1;\n\t\t\t\t\tans+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <queue>\n#include <cstdio>\nusing namespace std;\nint W, H;\nchar c[100][101];\nbool visited[100][100];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid computer(){\n    memset(visited,false,sizeof visited);\n    queue<int> que;\n    int i, j;\n    for(i=0;i<H;i++){\n        for(j=0;j<W;j++){\n            if(c[i][j]=='@'){\n                que.push(j+i*W);\n                visited[i][j] = true;\n                goto Skip;\n            }\n        }\n    }\nSkip:;\n    \n    int answer = 1;\n    while( !que.empty()){\n        int cur = que.front(); que.pop();\n        int x = cur % W, y = cur / W;\n        \n        for(i=0;i<4;++i){\n            int nx = x + dx[i],ny = y + dy[i];\n            if(!(0<=nx && nx < W && 0<=ny && ny<H))continue;\n            if(c[ny][nx]=='#' || visited[ny][nx])continue;\n            que.push(nx+ny*W);\n            visited[ny][nx]=true;\n            ++answer;\n        }\n        \n        \n        \n    }\n    \n    cout << answer << endl;\n    \n    \n}\n\n// abcdd\n// efgeg\n\nint main(){\n    while(cin >> W >> H, W==0&&H==0){\n        int i;\n        for(i=0;i<H;++i){\n            //cin >> c[i][0];\n            scanf(\" %s\",&c[i][0]);\n        }\n        computer();\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\nusing namespace std;\nint H, W;\n\nint main () {\n  const int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; \n  while(cin >> W >> H && W != 0 && H != 0) {\n    int srcy, srcx;\n    int G[W][H];\n    int D[W][H];\n    for (int i = 0; i < H; i++) {\n      for (int k = 0; k < W; k++) {\n        D[k][i] = -1;\n        char input;\n        cin >> input;\n        if (input == '.') {\n          G[k][i] = 0;\n        } else if (input == '#') {\n          G[k][i] = 1;\n        } else {\n          G[k][i] = 0;\n          srcx = k;\n          srcy = i;\n        }\n      }\n    }\n    // for (int i = 0; i < H; i++) {\n    //   for (int k = 0; k < W; k++) {\n    //     cout << G[k][i] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    // for (int i = 0; i < H; i++) {\n    //   for (int k = 0; k < W; k++) {\n    //     cout << D[k][i] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    \n    queue<pair<int, int> > Q; // 整数を管理するキューの定義\n    pair<int, int> src = make_pair(srcx, srcy);\n    Q.push(src);\n    D[srcx][srcy] = 0; // 出発点\n    // cerr << \"src \" << srcx << \", \" << srcy  << endl;\n    while (! Q.empty()) {\n      pair<int, int> cur = Q.front(); // 先頭要素を取り出す\n      Q.pop();\n      int x = cur.first;\n      int y = cur.second;\n      // cerr << \"src \" << x << \", \" << y  << endl;\n      for (int i = 0; i < 4; i++) {\n        int dstx = x+dx[i];\n        int dsty = y+dy[i];\n        // cerr << \"visiting \" << dstx << \", \" << dsty << \", \" << G[dstx][dsty] << \", \" <<  D[dstx][dsty]  << endl;\n        if (\n          (dstx >= 0 && dstx <= W - 1)\n          && (dsty >= 0 && dsty <= H - 1)\n          && G[dstx][dsty] == 0\n          && D[dstx][dsty] == -1\n        ) { // cur から dst に辺があり，dst が未訪問なら\n          D[dstx][dsty] = D[x][y]+1; //\n          Q.push(make_pair(dstx, dsty));\n        }\n      }\n    }\n    // for (int i = 0; i < H; i++) {\n    //   for (int k = 0; k < W; k++) {\n    //     cout << D[k][i] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int r = 0;\n    for (int i = 0; i < W; i++) {\n      for (int k = 0; k < H; k++) {\n        if (D[i][k] != -1) {\n          r++;\n        }\n      }\n    }\n    cout << r << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W,H;\n\nvoid dfs(string *m, int x, int y){\n\tif(y-1 >= 0 && m[y-1][x] == '.'){\n\t\tm[y-1][x] = '@';\n\t\tdfs(m, x, y-1);\n\t}\n\tif(y+1 < H && m[y+1][x] == '.'){\n\t\tm[y+1][x] = '@';\n\t\tdfs(m, x, y+1);\n\t}\n\tif(x-1 >= 0 && m[y][x-1] == '.'){\n\t\tm[y][x-1] = '@';\n\t\tdfs(m, x-1, y);\n\t}\n\tif(x+1 < W && m[y][x+1] == '.'){\n\t\tm[y][x+1] = '@';\n\t\treturn dfs(m, x+1, y);\n\t}\n}\nint main(){\n\tcin >> W >> H;\n\twhile(W!=0 || H!=0){\n\t\tstring m[H];\n\t\tint x,y;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tm[i] = tmp;\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(tmp[j] == '@'){\n\t\t\t\t\tx = j, y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(m,x,y);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(m[i][j] == '@'){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> W >> H;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint w, h;\nstring s[20];\nint sy, sx;\n\nvoid dfs(int y, int x) {\n    s[y][x] = '@';\n    REP (i, 4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w && s[ny][nx] == '.') {\n            dfs(ny, nx);\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n        REP (i, h) {\n            cin >> s[i];\n            REP (j, w) {\n                if (s[i][j] == '@') sy = i, sx = j;\n            }\n        }\n        dfs(sy, sx);\n        int ans = 0;\n        REP (i, h) REP (j, w) ans += (s[i][j] == '@');\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W && H) {\n      memset(visited, false, sizeof(visited));\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      board[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\nusing namespace std;\nint w,h;\nint dx[4] = {0,1,0,-1},dy[4] = {1,0,-1,0};\nint main(void) {\n\twhile (1) {\n\t\tint ans = 0;\n\t\tcin >> w >> h;\n\t\tvector<vector<int> > d(h,vector<int>(w,-1));\n\t\tvector<string> s(h);\n\t\tqueue<pair<int,int> > q;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor(int i = 0;i < h;i++){\n\t\t    cin >> s[i];\n\t\t    for(int j = 0;j < w;j++){\n\t\t        if(s[i][j] == '@'){\n\t\t            d[i][j] = 0;\n\t\t            q.push(pair<int,int>(i,j));\n\t\t        }\n\t\t    }\n\t\t}\n\t\t\n\t\twhile(!q.empty()){\n\t\t    pair<int,int> cur = q.front();\n\t\t    q.pop();\n\t\t    for(int k = 0;k < 4;k++){\n\t\t        int x = cur.first+dx[k];\n\t\t        int y = cur.second+dy[k];\n\t\t        if(x < 0 || x >= h || y < 0 || y >= w) continue;\n\t\t        if(s[x][y] == '#') continue;\n\t\t        if(d[x][y] == -1){\n\t\t            d[x][y] = d[cur.first][cur.second]+1;\n\t\t            ans++;\n\t\t            q.push(pair<int,int>(x,y));\n\t\t        }\n\t\t    }\n\t\t}\n\t\tcout << ans+1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nchar m[22][22],*p;\nint F(int x,int y)\n{\n\tif(m[y][x]=='#')return 0;\n\tm[y][x]='#';\n\treturn 1+F(x+1,y)+F(x-1,y)+F(x,y+1)+F(x,y-1);\n}\nint main()\n{\n\tint w,h,i,x,y;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tfor(i=1;i<=h;++i)\n\t\t{\n\t\t\tscanf(\"%s\",m[i]+1);\n\t\t\tif(p=strchr(m[i]+1,'@'))x=p-m[y=i];\n\t\t}\n\t\tfor(i=0;i<h+2;++i)m[i][0]=m[i][w+1]='#';\n\t\tfor(i=0;i<w+2;++i)m[0][i]=m[h+1][i]='#';\n\t\tprintf(\"%d\\n\",F(x,y));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 横型探索\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint w, h;\nint mx[] = {0, 0, -1, 1};\nint my[] = {-1, 1, 0, 0};\n\nint main() {\n    while ( true ) {\n        int x, y, cnt = 0;\n        cin >> w >> h;\n        if ( w == 0 && h == 0 ) break;\n\n        vector<string> v(h);\n        queue<int> s;\n\n        for ( int i = 0; i < h; i++ ) {\n            cin >> v[i];\n\n            // @の座標を記録\n            for ( int j = 0; j < v[i].size(); j++ ) {\n                if ( v[i][j] == '@' ) {\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n\n        // キューにスタート地点を追加\n        s.push(x);\n        s.push(y);\n\n        while(!s.empty()) {\n            x = s.front(); s.pop();\n            y = s.front(); s.pop();\n\n            for ( int i = 0; i < 4; i++ ) {\n                int nx = x + mx[i], ny = y + my[i];\n                if ( 0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == '.' ) {\n                    v[ny][nx] = '#';\n                    s.push(nx);\n                    s.push(ny);\n                }\n            }\n            cnt++;\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\n#define int ll\n\nvi dx = {1, 0, -1, 0, 1, -1, -1, 1}, dy = {0, 1, 0, -1, 1, 1, -1, -1};\n\nmain()\n{\n  while(1){\n    int w,h; cin >> w >> h;\n    if(w == 0) break;\n\n    vs maze(h); rep(i,h) cin >> maze[i];\n    vvi look(h,vi(w));\n    int sx, sy;\n    rep(i,h) rep(j,w) if(maze[i][j] == '@'){\n      sx = i; sy = j;\n    }\n    \n    queue<pii> q;\n\n    q.push(pii(sx,sy));\n    int ans = 1;\n    look[sx][sy] = 1;\n\n    while(not q.empty()){\n      pii p = q.front();\n      q.pop();\n\n      //if(p.fst == gx and p.snd == gy) break;\n\n      rep(i, 4){\n\tint nx = p.fst + dx[i], ny = p.snd + dy[i];\n\tif(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != '#' and look[nx][ny] == 0){\n\t  q.push(pii(nx, ny));\n\t  look[nx][ny] = 1;\n\t  ans++;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, black;\nchar tile[24][24];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y){\n    black++;\n    tile[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n        if( x+dx[i] >= 0 && x+dx[i] < h &&\n           y+dy[i] >= 0 && y+dy[i] < w &&\n           tile[ x+dx[i] ][ y+dy[i] ] == '.' ){\n            dfs( x+dx[i], y+dy[i] );\n        }\n    }\n}\n\nint main(){\n    int i, j;\n    while( cin >> w >> h){\n        if(w==0&&h==0)\n            break;\n        for(j=0;j<w;j++){\n            for(i = 0; i < h; i++){\n                cin >> tile[i][j];\n            }\n        }\n        black = 0;\n        for(j = 0; j < w && !black; j++){\n            for(i = 0; i < h && !black; i++){\n                if( tile[i][j] == '@' ){\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << black << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define B(a,x,b) ((a)<=(x)&&(x)<(b))\n\nchar T[999];\nint x,y,cx,cy,i,c;\n\nvoid R(a,b){\n\tif(B(0,a,x)&&B(0,b,y)&&T[b*20+a]){\n\t\tT[b*20+a]=0;i++;R(a-1,b);R(a+1,b);R(a,b-1);R(a,b+1);\n\t}\n}\n\nmain(){\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<x*y;i++){\n\t\t\tint _x=i%x, _y=i/x;\n\t\t\tfor(;(c=getchar())!='\\n';);\n\t\t\tswitch(c){\n\t\t\t\tcase '@': cx=_x;cy=_y;\n\t\t\t\tcase '.': T[_y*20+_x]=1; break;\n\t\t\t\tcase '#': T[_y*20+_x]=0; break;\n\t\t\t}\n\t\t}\n\t\ti=0;\n\t\tR(cx,cy);\n\t\tprintf(\"%d\\n\",i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w+h!=0){\n\t\tstring ban[100];\n\t\tint sx=0,sy=0;\n\t\tqueue< pair<int,int> >bfs;\n\t\tbool table[100][100];\n\t\tfor(int i=0;i<100;i++)for(int j=0;j<100;j++)table[i][j]=false;\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>ban[i];\n\t\t\tfor(int j=0;j<ban[i].size();j++){\n\t\t\tif(ban[i][j]=='@')sy=i,sx=j;\n\t\t\t}\n\t\t}\n\t\tpair<int,int> s(sx,sy);\n\t\tbfs.push(s);\n\t\ttable[sy][sx]=true;\n\t\tint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\t\twhile(bfs.empty()==false){\n\t\t\tpair<int,int>now=bfs.front();\n\t\t\tbfs.pop();\n\t\t\tint nx=now.first,ny=now.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(nx+dx[i]>=0&&nx+dx[i]<w&&ny+dy[i]>=0&&ny+dy[i]<h){\n\t\t\t\t\tif(table[ny+dy[i]][nx+dx[i]]==false&&ban[ny+dy[i]][nx+dx[i]]=='.'){\n\t\t\t\t\tpair<int,int>tmp(nx+dx[i],ny+dy[i]);\n\t\t\t\t\tbfs.push(tmp);\n\t\t\t\t\ttable[tmp.second][tmp.first]=true;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(table[i][j])cnt++;\n\t\tcout<<cnt<<endl;\n\t\tfor(int i=0;i<100;i++)ban[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w, h;\nchar data[99][99]; //y, x\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint solve(int x, int y){\n\n  if(x < 0 || y < 0 || x == w || y == h) return 0;\n  if(data[y][x] == '#') return 0;\n\n  data[y][x] = '#';\n\n  int ret = 0;\n  for(int i=0;i<4;i++) ret += solve(x+dx[i], y+dy[i])+1;\n\n  return ret;\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    int sx, sy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> data[i][j];\n\tif(data[i][j] == '@') sx = j, sy = i;\n      }\n    }\n\n    cout << solve(sx, sy)/4 << endl; //for()で４回+1しているため\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 500; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint ans,w,h;\nstring g[30];\nbool visit[30][30];\n\nint rec(int y,int x){\n  int res = 1;\n  int dx[] = {0,1,0,-1}, dy[] = {-1,0,1,0};\n  visit[y][x] = true;\n\n  for(int k=0;k<4;k++){\n    int sy = y+dy[k] ,sx = x+dx[k];\n    if(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n    if(visit[sy][sx] || g[sy][sx] == '#')continue;\n    res += rec(sy,sx);\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> w >> h && (w||h)){\n\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++)visit[i][j] = false;\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    ans = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == '@')cout << rec(i,j) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\n\nint main(){\n    std::vector<int> row;\n    int prev_col, width, height, max = 0, last = 0;\n    bool connect_prev_row;\n    \n    std::cin >> width >> height;\n    row.resize(width+1);\n    for( int i = 0; i <= width; i++ ) row[i] = 0;\n\n    std::string line;\n    while( true ){\n        std::cin >> line;\n        if( line == \"00\" ) {\n            std::cout << max;\n            break;\n        }\n        connect_prev_row = false;\n        for(std::string::size_type i = 0; i < line.size(); i++ ){\n            if( line[i] == '.' ){\n                if( connect_prev_row ){\n                    if( row[i] > 0 ) row[i+1] = row[i] + 1;\n                    else row[i+1] = row[i] - 1;\n                } else {\n                    connect_prev_row = true;\n                    if( row[i] <= 0 && row[i+1] <= 0 ) row[i+1] = row[i+1] + row[i] - 1;\n                    else row[i+1] = std::abs(row[i+1]) + std::abs(row[i]) + 1;\n                }\n            } else if( line[i] == '@' ) {\n                if ( connect_prev_row ) row[i+1] = - row[i] + 1;\n                else {\n                    connect_prev_row = true;\n                    row[i+1] = - row[i+1] - row[i] + 1;\n                }\n            } else {\n                row[i+1] = 0;\n                connect_prev_row = false;\n            }\n            max = max > row[i+1] ? max : row[i+1];\n        }\n        last = 0;\n        for( int i = line.size(); i > 0; i-- ) {\n            if( row[i] == 0 ) last = 0;\n            else if( row[i] > 0 ){\n                if(  last == 0 ) last = row[i];\n                else row[i] = last;\n            } else {\n                if(  last == 0 ) last = row[i];\n                else row[i] = last;\n            } \n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\nint w,h;\nchar board[25][25];\nint sx,sy;\nint nx,ny;\nint ans;\nvoid dfs(int x,int y){\n  board[y][x] ='#';\n  for(int j = 0;j <4;j++){\n    nx =x +dx[j];\n    ny =y +dy[j];\n    if(nx <1 ||nx >w||ny <1 ||ny >h)\n      continue;\n    if(board[ny][nx] =='.'){\n      ans++;\n      dfs(nx,ny);\n    }\n  }\n}\n\nint main()\n{\n  while(cin>>w>>h,w||h){\n    ans = 1;\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tcin>>board[i][j];\n      }\n    }\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tif(board[i][j] =='@'){\n\t  sx = j;\n\t  sy = i;\n\t  dfs(j,i);\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\ttile[i][0] = '#';\n\t\t\ttile[i][h + 1] = '#';\n\t\t}\n\t\tfor (j = 0; j < 22; j++) {\n\t\t\ttile[0][j] = '#';\n\t\t\ttile[w + 1][j] = '#';\n\t\t}\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0]; used[x][y]=1;\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y-1);\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y+1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=55,INF=1<<30;\nint H,W;\nint cnt;\nint state[MAX][MAX];\nvector<int> dx={1,0,-1,0},dy={0,-1,0,1};\n\nvoid DFS(int us,int ut){\n    for(int i=0;i<4;i++){\n        if(0<=us+dx[i]&&us+dx[i]<H&&0<=ut+dy[i]&&ut+dy[i]<W){\n            if(state[us+dx[i]][ut+dy[i]]==0){\n                cnt++;\n                state[us+dx[i]][ut+dy[i]]=1;\n                DFS(us+dx[i],ut+dy[i]);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>W>>H;\n        if(H==0&&W==0) break;\n        \n        int s,t;\n        cnt=1;\n        memset(state,0,sizeof(state));\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                char c;cin>>c;\n                if(c=='@'){\n                    s=i;\n                    t=j;\n                    state[i][j]=1;\n                }else if(c=='#'){\n                    state[i][j]=1;\n                }\n            }\n        }\n        \n        DFS(s,t);\n        \n        cout<<cnt<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nchar map[20][20];\nint W,H;\nint cnt;\n\nvoid fac(int y,int x){\n  map[y][x]='#';\n  cnt++;\n  \n  if(map[y+1][x]=='.' && y < H-1)\n    fac(y+1,x);\n  if(map[y-1][x]=='.' && y > 0)\n    fac(y-1,x);\n  if(map[y][x+1]=='.' && x < W-1)\n    fac(y,x+1);\n  if(map[y][x-1]=='.' && x > 0)\n    fac(y,x-1);  \n}\n\nint main(){\n  int i,j;\n  int x,y;\n\n  while(1){\n    cin >> W >> H;\n\n    if(W+H==0)\n      break;\n    \n    for(i=0;i<H;i++){\n      for(j=0;j<W;j++){\n\tcin >> map[i][j];\n\tif(map[i][j]=='@'){\n\t  x=j; y=i; \n\t} //@position      \n      }\n    }\n    \n    cnt=0;\n    fac(y,x); //release cnt\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint w, h;\n\t\tchar field[30][30];\n\t\tint visit[30][30]={0};\n\t\tint ans=0;\n\t\tint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\t\tpoint start;\n\t\t\n\t\tscanf(\" %d %d\", &w, &h);\n\t\tif(w==0) break;\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tscanf(\" %c\", &field[j][i]);\t\t\n\t\t\t\tif(field[j][i] == '@'){\n\t\t\t\t\tstart.x=j;\n\t\t\t\t\tstart.y=i;\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tqueue<point> que;\n\t\tvisit[start.x][start.y]=1;\n\t\tque.push(start);\n\t\t++ans;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tpoint now=que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tint nx=now.x+dx[i], ny=now.y+dy[i];\n\t\t\t\t\n\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && field[nx][ny]=='.' && visit[nx][ny]==0){\n\t\t\t\t\tvisit[nx][ny]=1;\n\t\t\t\t\t++ans;\n\t\t\t\t\t\n\t\t\t\t\tpoint pp;\n\t\t\t\t\tpp.x=nx; pp.y=ny;\n\t\t\t\t\tque.push(\tpp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\nvoid search(int h, int w, int tairu[22][22], int check[22][22]){\n    if(check[h][w]==1)return;\n    if(tairu[h][w]==0)return;\n    \n    check[h][w]=1;\n    search(h+1,w,tairu,check);\n    search(h-1,w,tairu,check);\n    search(h,w+1,tairu,check);\n    search(h,w-1,tairu,check);\n}\n\n\n\n\n\n\nint main()\n{\n\n    int H,W;\n    while(cin>>W>>H){\n        int tairu[22][22]={0};\n        int start_w, start_h;\n        for(int i=1; i<=H; i++){\n            for(int j=1; j<=W; j++){\n                char input;\n                cin>>input;\n                if(input=='.')tairu[i][j]=1;\n                if(input=='@'){\n                    tairu[i][j]=1;\n                    start_w=j;\n                    start_h=i;\n                }\n            }\n        }\n        //\n        \n        int check[22][22]={0};\n        search(start_h, start_w, tairu, check);\n        int ans=0;\n        for(int i=1; i<=H; i++){\n            for(int j=1; j<=W; j++){\n                ans+=check[i][j];\n            }\n        }\n        cout<<ans<<endl;\n        \n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#define INF 100000\nusing namespace std;\n\nchar G[20][20];\nint used[20][20];\nint ans;\n\nvoid dfs(int x, int y, int H, int W){\n    if (x<0 || x>= W || y<0 || y>= H || G[y][x]== '#') {\n        return;\n    }\n    if (G[y][x]=='.') {\n        ans++;\n    }\n    used[y][x]=0;\n    if (used[y-1][x]) dfs(x, y-1, H, W);\n    if (used[y+1][x]) dfs(x, y+1, H, W);\n    if (used[y][x-1]) dfs(x-1, y, H, W);\n    if (used[y][x+1]) dfs(x+1, y, H, W);\n    \n    return;\n}\n\n\nint main(){\n    for (; ;) {\n        int H, W;\n        cin >> W>> H;\n        if (H==0 && W==0) return 0;\n        for (int i=0; i<H; i++) {\n            for (int j=0; j<W; j++) {\n                used[i][j]=1;\n                G[i][j]= '#';\n            }\n        }\n        ans = 0;\n        int sx=0,sy=0;\n        for (int i=0; i<H; i++) {\n            for(int j=0; j<W; j++){\n                char p;\n                cin >> p;\n                G[i][j] = p;\n                if (p=='@') {\n                    sx = j;\n                    sy = i;\n                    G[i][j]= '.';\n                }\n            }\n        }\n        dfs(sx, sy, H, W);\n       /* for (int i=0; i<H; i++) {\n            for (int j=0; j<W; j++) {\n                cout << used[i][j]<<\"|\";\n            }\n            cout << endl;\n        }\n        for (int i=0; i<H; i++) {\n            for (int j=0; j<W; j++) {\n                cout << G[i][j]<<\"|\";\n            }\n            cout << endl;\n        }*/\n        cout << ans<< endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define MAX_WH 20\n\ntypedef std::pair<int, int> P;\n\nconst int dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nint W, H, sx, sy;\nchar field[MAX_WH][MAX_WH];\nint solve();\n\nint bfs();\n\nint main(){\n\twhile(true){\n\t\tstd::cin >> W >> H;\n\t\tif(W == 0 && H == 0)\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tchar in;\n\t\t\t\tstd::cin >> in;\n\n\t\t\t\tif(in == '@')\n\t\t\t\t\tsx = j, sy = i;\n\n\t\t\t\tfield[j][i] = in;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << solve() << std::endl;\n\t}\n\treturn 0;\n}\n\nint solve(){\n\treturn bfs();\n}\n\nint bfs(){\n\tstd::queue<P> que;\n\tint ans = 0;\n\tbool flag[MAX_WH][MAX_WH];\n\n\tfor(int i = 0; i < MAX_WH; ++i){\n\t\tfor(int j = 0; j < MAX_WH; ++j)\n\t\t\tflag[i][j] = true;\n\t}\n\n\tque.push(P(sx, sy));\n\tflag[sx][sy] = false;\n\n\twhile(!que.empty()){\n\t\t++ans;\n\t\tP p = que.front(); que.pop();\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\n\t\t\tif(nx >= 0 && ny >= 0 && nx < W && ny < H && field[nx][ny] != '#' && flag[nx][ny]){\n\t\t\t\tflag[nx][ny] = false;\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid init(int data[22][22],int w,int h){\n\tfor(int i = 0;i < w+2;i++){\n\t\tdata[0][i] = 1;\n\t\tdata[h+1][i] = 1;\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tdata[i+1][0] = 1;\n\t\tdata[i+1][w+1] = 1;\n\t}\n}\n\nvoid show(int data[22][22],int w,int h){\n\tfor(int i = 0;i < h+2;i++){\n\t\tfor(int j = 0;j < w+2;j++){\n\t\t\tprintf(\"%d\",data[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint ans;\nint dx[4] = {1,0,-1,0},dy[4] = {0,-1,0,1};\n\nvoid count(int data[22][22],int sx,int sy){\n\tfor(int i = 0;i < 4;i++){\n\t\tif(data[sy+dy[i]][sx+dx[i]] == 0){\n\t\t\tans++;\n\t\t\tdata[sy+dy[i]][sx+dx[i]] = 2;\n\t\t\tcount(data,sx+dx[i],sy+dy[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint W,H,sx,sy;\n\tint data[22][22];\n\tchar str[21];\n\n\twhile(1){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tinit(data,W,H);\n\t\tfor(int i = 0;i < H;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tfor(int j = 0;j < W;j++){\n\t\t\t\tif(str[j] == '.'){\n\t\t\t\t\tdata[i+1][j+1] = 0;\n\t\t\t\t}else if(str[j] == '#'){\n\t\t\t\t\tdata[i+1][j+1] = 1;\n\t\t\t\t}else if(str[j] == '@'){\n\t\t\t\t\tdata[i+1][j+1] = 2;\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//show(data,W,H);\n\n\t\tans = 1;\n\t\tcount(data,sx,sy);\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n\nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      if(used[ni][nj]) continue;\n      if(fld[ni][nj]!='.') continue;\n      rec(ni, nj);\n   }\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\n#define lf double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\nll w, h;\nchar field[100][100];\nbool use[100][100];\nll ans=0;\n\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\nvoid dfs(int x, int y)\n{\n\tuse[y][x] = true;\n\tans++;\n\trep(i, 4){\n\t\tll tx = x+dx[i];\n\t\tll ty = y+dy[i];\n\t\tif (!(0<=tx && tx<=w-1 && 0<=ty && ty<=h-1)) continue;\n\t\tif (use[ty][tx] || field[ty][tx]=='#') continue;\n\t\tdfs(tx, ty);\n\t}\n\treturn;\n}\n\nint main(void)\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(cin>>w>>h, w!=0){\n\t\tll sx, sy;\n\t\tans = 0;\n\t\tmemset(use, 0, sizeof(use));\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j]=='@'){\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx, sy);\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  while (1){\n    int W, H;\n    cin >> W >> H;\n    if (W == 0 && H == 0){\n      break;\n    }\n    vector<vector<char>> c(H + 2, vector<char>(W + 2, '#'));\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        cin >> c[i][j];\n      }\n    }\n    int sy, sx;\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        if (c[i][j] == '@'){\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    c[sy][sx] = '.';\n    int ans = 0;\n    vector<vector<bool>> used(H + 2, vector<bool>(W + 2, false));\n    used[sy][sx] = true;\n    queue<pair<int, int>> Q;\n    Q.push(make_pair(sy, sx));\n    while (!Q.empty()){\n      int y = Q.front().first;\n      int x = Q.front().second;\n      Q.pop();\n      ans++;\n      for (int i = 0; i < 4; i++){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if (!used[y2][x2] && c[y2][x2] == '.'){\n          used[y2][x2] = true;\n          Q.push(make_pair(y2, x2));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> C[i][j];\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i]))\n\t\t\t\ttot+=1;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tcur.first+=dx[i]; cur.second+=dy[i];\n\t\t\t\tq.push(cur);\n\t\t}\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[j][i];\n\t\t\t\tif(P[j][i]=='@')\n\t\t\t\t\tx1=j; y1=i; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t\tcout << tot << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#define _USE_MATH_DEFINES\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\n\nstruct edge {\n    int to, cost;\n};\n\nint H, W;\nbool marked[100][100];\nint sum;\n\nvoid BFS(pii st) {\n    queue<pii> que;\n    que.push(st);\n    sum++;\n    marked[st.first][st.second] = false;\n    while (que.size() > 0) {\n        pii base = que.front();\n        que.pop();\n        pii mv[4] = {pii(-1, 0), pii(1, 0), pii(0, -1), pii(0, 1)};\n        int basex = base.first;\n        int basey = base.second;\n        for (int i = 0; i < 4; i++) {\n            int x = basex + mv[i].first;\n            int y = basey + mv[i].second;\n            if (x >= 0 && x < H && y >= 0 && y < W) {\n                if (marked[x][y]) {\n                    que.push(pii(x, y));\n                    sum++;\n                    marked[x][y] = false;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (true) {\n        cin >> W >> H;\n        if (W == 0) {\n            break;\n        }\n        for (int i = 0; i < H; i++) {\n            fill(marked[i], marked[i] + W, true);\n        }\n        pii st;\n        for (int i = 0; i < H; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < W; j++) {\n                if (s[j] == '#') {\n                    marked[i][j] = false;\n                } else if (s[j] == '@') {\n                    st = pii(i, j);\n                }\n            }\n        }\n        sum = 0;\n        BFS(st);\n        cout << sum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<queue>\nusing namespace std;\nint W,H;\nchar c[101][101];\nbool visited [100][100];\n\nint dx[4]={1,0,-1,0};\nint dy [4]={0,1,0,-1} ;\n\nvoid compute(){\n  memset(visited,false,sizeof visited);\n\n\n  queue<int> que;\nint i,j;\n for(i=0;i<H;++i){\n   for(j=0;j<W;++j){\n     if(c[i][j]=='@'){\n       que.push(j+i*W);\n       visited[i][j]=true;\n       break;}\n       \n\t }\n\n\n   }\n int answer=1;\n \n while(!que.empty()){\n   int cur = que.front();\n   que.pop();\n   int x = cur % W,y=cur/W;\n\n   for(i=0;i<4;i++)\n     {int nx = x + dx[i],ny= y+dy[i];\n       if(!(0<=nx && nx< W && 0<=ny && ny < H))continue;\n       if(c[ny][nx]=='#'||visited[ny][nx])continue;\n       \n       que.push(nx+ny*W);\n       visited[ny][nx]=true;\n       ++answer;\n       \n     }\n }\n cout<<answer<<endl;\n \n}\n\n\n\n\n\nint main(){\n  while(cin>>W>>H,W|H) {\n    for(int i=0;i<H;++i) {\n      cin>>c[i];\t    \n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\nvector<int> ans;\ntypedef pair <int, int> P;\n\nint  main(){\n  int W,H;\n  cin >> W >> H;\n  int tate[4] = {0,1,0,-1};\n  int yoko[4] = {1,0,-1,0};\n  while(W){\n    int count = 0;\n    queue < P > zahyou;\n    vector< vector<int> > room(H, vector<int>(W));\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        char a;\n        cin >> a;\n        if(a == '.')room[i][j] = 1;\n        else if(a == '@'){\n          zahyou.push( P (i,j) );\n          room[i][j] = 1;\n        }\n        else room[i][j] = 0;\n      }\n    }\n    while(zahyou.size()){\n      pair<int, int> now = zahyou.front();\n      zahyou.pop();\n      if(room[now.first][now.second] == 1){\n        count++;\n        room[now.first][now.second] = 0;\n        for(int i = 0; i < 4 ; i++){\n          zahyou.push( P (now.first+tate[i], now.second+yoko[i]));\n        }\n      }\n    }\n    ans.push_back(count);\n    cin >> W >> H;\n  }\n  for(int i = 0 ; i < ans.size(); i++)\n    cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int W = 20, H = 20;\n\nint w, h;\nchar board[H + 2][W + 2];\n\nint search(int x, int y){\n\tint c = 0, nx, ny;\n\tint dx[] = {0, -1, 1, 0}, dy[] = {-1, 0, 0, 1};\n\tqueue<P> q;\n\tmap<P, bool> v;\n\tq.push(make_pair(x, y));\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tv[p] = true;\n\t\tboard[p.second][p.first] = '#';\n\t\t++c;\n\t\tfor(int i = 0;i < 4;++i){\n\t\t\tnx = p.first + dx[i];\n\t\t\tny = p.second + dy[i];\n\t\t\tif(board[ny][nx] == '.' and !v[make_pair(nx, ny)]){\n\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t\tv[make_pair(nx, ny)] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\nint main(){\n\tint sx, sy;\n\twhile(cin >> w >> h, w){\n\t\tfor(int i = 0;i < h + 1;++i){\n\t\t\tfill(board[i], board[i] + W + 2, 0);\n\t\t}\n\t\tfor(int i = 0;i < h;++i){\n\t\t\tfor(int j = 0;j < w;++j){\n\t\t\t\tcin >> board[i + 1][j + 1];\n\t\t\t\tif(board[i + 1][j + 1] == '@'){\n\t\t\t\t\tsx = j + 1;\n\t\t\t\t\tsy = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << search(sx, sy) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n\n#define ll (long long)\n#define REP(i,n) for(int i = 0;i<(int)n;i++)\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (a);i>(b);i--)\n#define COUNTER int i= 0,j = 0,k = 0,l = 0,m = 0, n= 0;\n#define RETURN cout << endl;\n/*vector<vector<int>>ArrayName = vector<vector<int>>(sizeofx, vector<int>(sizeofy, 0));*/\nusing namespace std;\n\n\n\nint dfs (int x,int y,vector<vector<char>>&v);\n\nint lim_x,lim_y;\nint mx[] = {-1,1,0,0};\nint my[] = {0,0,-1,1,};\n\nint main (void){\n    \n    int x,y;\n    int sh_x = 0,sh_y = 0;\n    \n    while(cin >> lim_x >> lim_y,lim_x+lim_y)\n        {\n            vector<vector<char>>v = vector<vector<char>>(lim_y, vector<char>(lim_x, 0));\n            REP(i,lim_y)\n            REP(j,lim_x)\n            {\n                cin >> v[i][j];\n                if(v[i][j] == '@')\n                    {\n                        sh_y = i;\n                        sh_x = j;\n                    }\n            }\n            //cout << lim_x << \" \" << lim_y << endl;\n            //cout << sh_x  <<\" \"<< sh_y << endl;\n            cout << dfs(sh_x,sh_y,v) << endl;\n            /*v is array name(pointer)*/\n      \n        }\n    return 0;\n}\n\nint dfs(int x,int y, vector<vector<char>>&v)\n{\n    int counter = 1;\n    for(int i = 0; i<4;i++){\n            int tx = x+mx[i],ty = y+my[i];\n            if((tx >= 0 && tx<lim_x) && (ty >= 0 && ty <lim_y) && (v[ty][tx] == '.'))\n            {\n                v[ty][tx] = '#';\n                //cout << v[ty][tx] << endl;\n                counter += dfs(tx, ty, v);\n                //cout << \"come on !\" << endl;\n            }\n                \n        }\n            \n    return counter;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid func(vvl &S, vector<string> &F, ll &w, ll &h, ll y, ll x) {\n  if (y < 0 || y >= h || x < 0 || x >= w || S[y][x] != 0) {\n    return;\n  } else if (F[y][x] == '#') {\n    S[y][x] = -1;\n    return;\n  } else {\n    S[y][x] = 1;\n    func(S, F, w, h, y, x + 1);\n    func(S, F, w, h, y, x - 1);\n    func(S, F, w, h, y + 1, x);\n    func(S, F, w, h, y - 1, x);\n    return;\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl all_ans;\n  while (true) {\n    ll h, w;\n    cin >> w >> h;\n    if (h == 0 || w == 0)\n      break;\n    vvl S = VVL(h, w, 0);\n    vector<string> F(h);\n    REP(i, h) cin >> F[i];\n    ll x = 0, y = 0;\n    REP(i, h) REP(j, w) {\n      if (F[i][j] == '@') {\n        x = j;\n        y = i;\n      }\n    }\n    func(S, F, w, h, y, x);\n    ll ans = 0;\n    REP(i, h) REP(j, w) {\n      if (S[i][j] == 1)\n        ans++;\n    }\n    all_ans.push_back(ans);\n  }\n  AUTO(ans, all_ans) cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring room[20];\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nint dfs(int x, int y){\n    int cnt = 1;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        \n        if(room[ny][nx] == '.'){\n            room[ny][nx] = '#';\n            cnt += dfs(nx, ny);\n        }\n    }\n    return cnt;\n}\n\nint main(int argc, const char * argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int w,h; cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> room[i];\n            if(room[i].find('@') != -1){\n                sx = room[i].find('@');\n                sy = i;\n            }\n        }\n        \n        cout << dfs(sx, sy) << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nvoid solve(int W,int H){\n    vector<string> S(H);\n    for (int i=0;i<H;++i) cin >> S[i];\n    vector<vector<bool>> seen(H,vector<bool>(W,false));\n    int ans=0;\n    auto dfs=[&](auto self,int x,int y)->void{\n        seen[x][y]=true; ++ans;\n        for (int i=0;i<4;++i){\n            int nx=x+dx[i],ny=y+dy[i];\n            if (nx<0||H<=nx||ny<0||W<=ny) continue;\n            if (S[nx][ny]=='#') continue;\n            if (seen[nx][ny]) continue;\n            self(self,nx,ny);\n        }\n    };\n    for (int i=0;i<H;++i){\n        for (int j=0;j<W;++j){\n            if (S[i][j]=='@'){\n                dfs(dfs,i,j);\n            }\n        }\n    }\n    cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W,H;\n    while(cin >> W >> H,W){\n        solve(W,H);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\ntypedef long long ll;\nint H, W;\nbool visited[20][20];\nint calc(vector<string> &vs, int y, int x) {\n  if(y < 0 || y >= H || x < 0 || x >= W) return 0;\n  if(visited[y][x] || vs[y][x] == '#') return 0;\n  visited[y][x] = true;\n  int ret = 1;\n  ret += calc(vs, y+1,x);\n  ret += calc(vs, y-1,x);\n  ret += calc(vs, y,x+1);\n  ret += calc(vs, y,x-1);\n  return ret;\n}\n\nint main()\n{\n  while(cin >> W >> H) {\n    if(W == 0) return 0;\n    vector<string> vs(H);\n    FOR(i,0,H) cin >> vs[i];\n    int sx, sy;\n    FOR(y,0,H) {\n      FOR(x,0,W) {\n        if(vs[y][x] == '@') {\n          sx = x;\n          sy = y;\n        }\n      }\n    }\n    FOR(i,0,H) FOR(j,0,W) visited[i][j] = false;\n    cout << calc(vs, sy, sx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nclass Main{\n\tpublic:\n\n\tint N;\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tint W,H;cin >> W >> H;if(W==0 && H ==0)break;\n\t\t\tvector<string> board(H);\n\t\t\tREP(y,H)cin >> board[y];\n\n\t\t\tvector<vector<bool>> passed(H,vector<bool>(W));\n\t\t\tqueue<pair<int,int>> que;\n\t\t\tREP(y,H)REP(x,W){\n\t\t\t\tif(board[y][x]=='@'){\n\t\t\t\t\tque.push(make_pair(y,x));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res=0;\n\t\t\twhile(!que.empty()){\n\t\t\t\tpair<int,int> pos=que.front();que.pop();\n\t\t\t\tif(passed[pos.first][pos.second])continue;\n\t\t\t\tpassed[pos.first][pos.second]=true;\n\t\t\t\tres++;\n\n\t\t\t\tREP(d,4){\n\t\t\t\t\tint ny=pos.first+dy[d],nx=pos.second+dx[d];\n\t\t\t\t\tif(IN(0,ny,H) && IN(0,nx,W)){\n\t\t\t\t\t\tif(board[ny][nx]=='.'){\n\t\t\t\t\t\t\tque.push(make_pair(ny,nx));\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << res <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar map[20][20];\n\nint W, H, start_x, start_y, ans = 0;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y)\n{\n  ans++;\n  if(map[x][y] != '#'){\n    map[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n      int next_x = x + dx[i], next_y = y + dy[i];\n      if(next_x < W && next_x >= 0 && next_y < H && next_y >= 0){\n\tif(map[next_x][next_y] == '#')\n\t  continue;\n\tdfs(next_x, next_y);\n      }else{\n\tcontinue;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0){\n      break;\n    }else{\n      for(int i = 0; i < H; i++){\n\tfor(int j = 0; j < W; j++){\n\t  cin >> map[j][i];\n\t  if(map[j][i] == '@'){\n\t    start_x = j;\n\t    start_y = i;\n\t  }\n\t}\n      }\n      dfs(start_x, start_y);\n      cout << ans << endl;\n      ans = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\nchar stage[22][22];\nbool vis[22][22];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nclass Data{\n\tpublic:\n\tint x;\n\tint y;\n\tint cnt;\n\tData(){}\n\tData(int x,int y,int cnt):x(x),y(y),cnt(cnt){}\n};\nint main(){\n\tint w,h;\n\twhile(scanf(\"%d%d\",&w,&h),(w|h)){\n\t\tmemset(stage,0,sizeof(stage));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\",stage[i]);\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(stage[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue < Data > Q;\n\t\tint ans = 0;\n\t\tQ.push(Data(sx,sy,1));\n\t\t\n\t\twhile( !Q.empty() ){\n\t\t\tData d = Q.front();Q.pop();\n\t\t\tif(vis[d.y][d.x]++)continue;\n\t\t\tans += d.cnt;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tif(dx[i]+d.x < 0 || dx[i]+d.x >= w || dy[i]+d.y < 0 || dy[i]+d.y >= h || stage[dy[i]+d.y][dx[i]+d.x] == '#')continue;\n\t\t\t\tQ.push(Data(dx[i]+d.x,dy[i]+d.y,d.cnt));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[22][22];\nint w, h;\nint yy[4] = {-1, 0, 0, 1}, xx[4] = {0, 1, -1, 0};\nint solve(int y, int x){\n\tif(a[y][x] == '#')return 0;\n\ta[y][x] = '#';\n\tint ans = 0;\n\tfor(int i = 0;i < 4;i++){\n\t\tans += solve(y+yy[i], x+xx[i]);\n\t}\n\treturn ans+1;\n}\n\nint main(){\n\tint y, x;\n\twhile(cin >> w >> h, w){\n\t\tfill((char*)a, (char*)(a+22), '#');\n\t\tfor(int i = 1;i <= h;i++)\n\t\tfor(int j = 1;j <= w;j++){\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == '@'){y = i;x = j;}\n\t\t}\n\t\tcout << solve(y, x) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint ans=0;\nvector<vector<int>> search(int x,int y,vector<vector<int>> umi){\n    umi[y][x]=-1;\n    ans++;\n    \n    if(umi[y+1][x]!=-1){\n        umi=search(x,y+1,umi);\n    }\n    if(umi[y][x-1]!=-1){\n        umi=search(x-1,y,umi);\n    }\n    if(umi[y][x+1]!=-1){\n        umi=search(x+1,y,umi);\n    }\n    if(umi[y-1][x]!=-1){\n        umi=search(x,y-1,umi);\n    }\n    return umi;\n}\n\n\nint main(void){\n    int h,w;\n    char c;\n    int x;\n    int y;\n    vector<vector<int>> umi;\n    while(cin>>w>>h,h){\n        vector<vector<int>> umi;\n        vector<int> nul;\n        for(int j=0;j<w+2;j++){\n            nul.push_back(-1);\n        }\n        umi.push_back(nul);\n        for(int i=0;i<h;i++){\n            vector<int> tmp;\n            tmp.push_back(-1);\n            for(int j=0;j<w;j++){\n                if(cin>>c,c=='@'){\n                    tmp.push_back(1);\n                    x=j+1;\n                    y=i+1;\n                }\n                else if(c=='.'){\n                    tmp.push_back(0);\n                }\n                else{\n                    tmp.push_back(-1);\n                }\n            }\n            tmp.push_back(-1);\n            umi.push_back(tmp);\n            getchar();\n        }\n        umi.push_back(nul);\n        for(int i=0;i<h+2;i++){\n            for(int j=0;j<w+2;j++){\n                //cout<<umi[i][j]+1;\n            }\n            //cout<<endl;\n        }\n        search(x,y,umi);\n\n        \n        cout<<ans<<endl;\n        ans=0;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef queue<P> Q;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\n#define mp make_pair\n\nint w,h;\nchar fie[21][21];\n\nvoid bfs(int x, int y){\n    Q q;\n    q.push(mp(x,y));\n    while(!q.empty()){\n        for(int i=0; i<4; i++){\n            int xx = q.front().first + dx[i];\n            int yy = q.front().second + dy[i];\n            if(0 <= xx && xx <= w && 0 <= yy && yy <= h && fie[yy][xx] == '.'){\n                fie[yy][xx] = '@';\n                q.push(mp(xx,yy));\n            }\n        }\n        q.pop();\n    }\n}\n\nint main(){\n    while(cin >> w >> h , w||h){\n        int sx,sy;\n        for(int i=0; i<h; i++){\n            cin >> fie[i];\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        bfs(sx,sy);\n        int ans = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@') ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n    }\n    \n}\n\nint main(){\n    int x,y;\n    while(cin>>x>>y,x|y){\n        int startx,starty;\n        vector<vector<bool> > map;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n     \nconst int INF=100000000;\n     \nchar maze[20][20];\nint w, h;\nint sx, sy;\nint cnt;\n     \nint d[20][20];\n     \nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\n     \n     \nint bfs(){\n  queue< pair<int, int> > que;\n     \n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) d[i][j]=INF;\n     \n  que.push(pair<int, int>(sy, sx));\n  d[sy][sx]=0;\n     \n  while(que.size()){\n    pair<int, int> p=que.front();\n    que.pop();\n     \n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i], nx=p.second+dx[i];\n     \n      if(0<=ny&&ny<h&&0<=nx&&nx<w&&maze[ny][nx]!='#'&&d[ny][nx]==INF){\n\tque.push(pair<int, int>(ny, nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n\tcnt++;\n      }\n    }\n  }\n  return cnt+1;\n}\n     \nint main(){\n     \n  while(cin>>w>>h, w){\n  \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>maze[i][j];\n\tif(maze[i][j]=='@'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    cnt=0;\n    int res=bfs();\n     \n    cout<<res<<endl;\n\n  }\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nchar ban[21][21];\nint cont = 0;\n\n\tint w, h;\n\t\n\tint MAX = 0;\n\nvoid saiki(int y, int x)\n{\n\tcont++;\n\tban[y][x] = '_';\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcout << ban[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << w << h << endl;\n\t\n\tgetchar();\n\t\n\tcout << cont << endl;;\n\t*/\n\t\n\tif(ban[y+1][x] == '.'){\n\t\tsaiki(y+1,x);\n\t\tban[y+1][x] == '.';\n\t}\n\tif(ban[y-1][x] == '.'){\n\t\tsaiki(y-1,x);\n\t\tban[y-1][x] == '.';\n\t} \n\tif(ban[y][x-1] == '.'){\n\t\tsaiki(y,x-1);\n\t\tban[y][x-1] == '.';\n\t}\n\tif(ban[y][x+1] == '.'){\n\t\tsaiki(y,x+1);\n\t\tban[y][x+1] == '.';\n\t}\n\t\n\tif(cont > MAX){\n\t\tMAX = cont;\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint st_x, st_y;\n\t\tMAX = cont = 0;\n\t\t\n\t\tcin >> w >> h;\n\t\t\n\t\tif( w == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> ban[i][j];\n\t\t\t\tif(ban[i][j] == '@'){\n\t\t\t\t\tst_x = j;\n\t\t\t\t\tst_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tsaiki(st_y,st_x);\n\t\t\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nclass pos\n{\n\tpublic:\n\tint x;\n\tint y;\n\tpos(int,int);\n};\n\npos::pos(int a,int b)\n{\n\tx=a;y=b;\n}\n\nint main()\n{\n\tint w,h;\n\tint g[21][21];\n/*\tfor(int i=0;i<21;i++)\n\t\tfor(int j=0;j<21;j++)\n\t\t\tg[i][j]=-1;\n*/\twhile(1)\n\t{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0) break;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tg[i][j]=-1;\n\t\tint psx,psy;\n\t\tbool visited[21][21];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tchar s;\n\t\t\t\tcin>>s;\n\t\t\t\tswitch(s)\n\t\t\t\t{\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tg[i][j]=0;break;\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tg[i][j]=1;break;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tg[i][j]=2;psx=i;psy=j;break;\n\t\t\t\t}\n\t\t\t\tvisited[i][j]=false;\n\t\t\t}\n\n/*\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcout<<g[i][j];\n\t\t\tcout<<endl;\n\t\t}\n*/\n\t\tint num=0;\n\t\tqueue<pos> Q;\n\t\tQ.push(pos(psx,psy));\n\t\tnum++;\n\t\tvisited[psx][psy]=true;\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tpos now=Q.front();\n\t\t\tQ.pop();\n\t\n\t\t\tfor(int i=-1;i<=1;i+=2)\n\t\t\t{\n\t\t\t\tint newx=now.x+i;\n\t\t\t\tint newy=now.y;\n\t\t\t\tif(newx>=0&&newx<h&&newy>=0&&newy<w&&g[newx][newy]==0&&visited[newx][newy]==false)\n\t\t\t\t{\n\t\t\t\t\tQ.push(pos(newx,newy));\t\t\n\t\t\t\t\tnum++;\n\t\t\t\t\tvisited[newx][newy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=-1;i<=1;i+=2)\n\t\t\t{                \n\t\t\t\tint newx=now.x;\n\t\t\t\tint newy=now.y+i;\n\t\t\t\tif(newx>=0&&newx<h&&newy>=0&&newy<w&&g[newx][newy]==0&&visited[newx][newy]==false)\n\t\t\t\t{\n\t\t\t\t\tQ.push(pos(newx,newy));\n\t\t\t\t\tnum++;\n\t\t\t\t\tvisited[newx][newy]=true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout<<num<<endl;\n\t\t\t\t\t\t\t\t\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n    int w,h;\n    while(cin >> w >> h && w!=0){\n        // int t[100][100];\n        int t[h+2][w+2];\n        for(int i=0;i<h+2;i++){\n            for(int j=0;j<w+2;j++){\n                t[i][j] = 0;\n            }\n        }\n\n        int start;\n        for(int i=0;i<h+2;i++){\n            for(int j=0;j<w+2;j++){\n                if(i==0 || j==0 || i==h+1 || j==w+1)\n                    t[i][j]=0;\n                else{\n                    char tmp; cin >> tmp;\n                    if(tmp=='.'){\n                        t[i][j] = 1;\n                    }\n                    else if(tmp=='#'){\n                        t[i][j] = 0;\n                    }\n                    else{\n                        t[i][j] = 1;\n                        start = i*w+j;\n                    }\n                }\n            }\n        }\n\n        //test\n        // for(int i=0;i<h+2;i++){\n        //     for(int j = 0;j<w+2;j++){\n        //         if(j==0)\n        //             cout << t[i][j];\n        //         else\n        //             cout << \" \" << t[i][j];\n        //     }\n        //     cout << endl;\n        // }\n\n        int ** matrix = new int*[(w+2)*(h+2)];\n        for( int i=0; i<(w+2)*(h+2); i++ ) {\n            matrix[i] = new int[(w+2)*(h+2)];\n        }\n        for(int i=0;i<w*h;i++){\n            for(int j=0;j<w*h;j++){\n                matrix[i][j] = 0;\n            }\n        }\n        for(int i=0;i<h+2;i++){\n            for(int j=0;j<w+2;j++){\n                int id = i*(w+2)+j;\n                if(i==0 || j==0 || i == h+1 || j == w+1 || t[i][j]==0)\n                    continue;\n                else{\n                    if(t[(id-w-2)/(w+2)][(id-w-2)%(w+2)] == 1){\n                        matrix[id][id-w-2] = 1;\n                    }\n                    if(t[(id+w+2)/(w+2)][(id+w+2)/(w+2)] == 1){\n                        matrix[id][id+w+2] = 1;\n                    }\n                    if(t[(id-1)/(w+2)][(id-1)/(w+2)] == 1){\n                        matrix[id][id-1] = 1;\n                    }\n                    if(t[(id+1)/(w+2)][(id+1)/(w+2)] == 1){\n                        matrix[id][id+1] = 1;\n                    }\n                }\n            }\n        }\n\n        // test\n        // for(int i=0;i<(h+2)*(w+2);i++){\n        //     for(int j = 0;j<(h+2)*(w+2);j++){\n        //         if(j==0)\n        //             cout << matrix[i][j];\n        //         else\n        //             cout << \" \" << matrix[i][j];\n        //     }\n        //     cout << endl;\n        // }\n\n\n        int count = 1;\n        queue<int> Q;\n        int came[(w+2)*(h+2)];\n        for(int i=0;i<(w+2)*(h+2);i++){\n            came[i] = 0;\n        }\n        Q.push(start);\n        came[start] = 1;\n        while(Q.size()!=0){\n            int cur = Q.front();\n            for(int i=0;i<(w+2)*(h+2);i++){\n                if(matrix[cur][i]==1 && came[i] == 0){\n                    Q.push(i);\n                    came[i] = 1;\n                    count++;\n                }\n            }\n            Q.pop();\n        }\n        cout << count << endl;\n        for( int i=0; i<(w+2)*(h+2); i++ ) {\n            delete[] matrix[i];\n        }\n        delete[] matrix;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct UF {\n  vector<int> p;\n  UF(int N):p(N,-1) {}\n  int rt(int x){return p[x]<0?x:p[x]=rt(p[x]);}\n  int s(int x){return -p[rt(x)];}\n  void cat(int x,int y) {\n    if((x=rt(x))==(y=rt(y))) return;\n    if(p[x]<p[y])swap(x,y);\n    p[y]+=p[x];\n    p[x]=y;\n  }\n};\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    int W, H; scanf(\"%d%d\", &W, &H);\n    if(W==0) break;\n    static char tbl[30][30];\n    for(int y = 0; y < H; y++) scanf(\" %s\", tbl[y]);\n    UF uf(W*H);\n    int k = 0;\n    for(int y = 0; y < H; y++) {\n      for(int x = 0; x < W; x++) {\n        if(tbl[y][x]=='#') continue;\n        if(y>0 && tbl[y-1][x]!='#') uf.cat(y*W+x,(y-1)*W+x);\n        if(x>0 && tbl[y][x-1]!='#') uf.cat(y*W+x,y*W+(x-1));\n        if(tbl[y][x]=='@')k=y*W+x;\n      }\n    }\n    printf(\"%d\\n\", uf.s(k));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <numeric>\n#include <queue>\nusing namespace std;\n\nint main(){\n    bool end = false ;\n    int w,h ;\n    cin >> w >> h ;\n    if (w == 0 && h == 0)\n    {\n        end = true ;\n    }\n    \n    //外側が全て壁になるように、元の迷路より2マス大きく取る（エラー回避）\n    \n    while (end == 0)\n    {\n    vector<vector<int> > a(h+2,vector<int>(w+2,-2)) ;\n    pair<int,int> start ;\n        for (size_t i = 1; i < h+1; i++)\n        {\n            for (size_t j = 1; j < w+1; j++)\n            {\n                char status ;\n                cin >> status ;\n                if (status == '.')\n                {\n                    a.at(i).at(j) = -1 ;\n                }else if (status == '@')\n                {\n                    a.at(i).at(j) = 0 ;\n                    start.first = i ;\n                    start.second = j ;\n                }else if (status == '#')\n                {\n                    a.at(i).at(j) = -2 ;\n                }\n                \n                \n                \n            }\n            \n        }\n        \n        queue<pair<int,int> > wait ;\n        int del[4][2] = {\n            {1,0},\n            {0,1},\n            {-1,0},\n            {0,-1}\n        };\n        wait.push(start) ;\n        pair<int,int> now ;\n        int ans = 0 ;\n        while (wait.empty() == 0)\n        {\n            now = wait.front() ;\n            wait.pop() ;\n            ans ++;\n            for (size_t i = 0; i < 4; i++)\n            {\n                int look1 = now.first + del[i][0] ;\n                int look2 = now.second + del[i][1] ;\n                pair <int,int> look = make_pair(look1,look2) ;\n                if (a.at(look.first).at(look.second) == -1)\n                {\n                    a.at(look.first).at(look.second) = 0 ;\n                    wait.push(look) ;\n\n                }\n                \n            }\n            \n        }\n        \n        cout << ans << endl ;\n\n        cin >> w >> h ;\n        if (w == 0 && h == 0)\n        {\n            end = true ;\n        }\n        \n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint n, m;\nchar field[100][100];\n\nint dfs(int x, int y){\n\tfield[x][y] = '.';\n\n\tfor(int dx = -1; dx <= 1; dx++){\n\t\tfor(int dy = -1; dy <= 1; dy++){\n\t\t\tint nx = x + dx, ny = y + dy;\n\n\t\t\tif(0 <= nx && nx < n && 0 <= ny && ny < m && field[nx][ny] == 'W') dfs(nx, ny);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i=0; i<100; i++){\n\t\t\tfor(int j=0; j<100; j++){\n\t\t\t\tfield[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%s\", field[i]);\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tif(field[i][j] == 'W'){\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define  INF 1100000000\n#define\t MOD 1000000007\nusing namespace std;\n\nint vis[22][22];\nchar mp[22][22];\n\nint dfs(int sh, int sw, int ans){\n\tif(mp[sh+1][sw] == '.' && vis[sh+1][sw] == 0){\n\t\tvis[sh+1][sw] = 1;\n\t\tans++;\n\t\tans = dfs(sh+1, sw, ans);\n\t}\n\tif(mp[sh-1][sw] == '.' && vis[sh-1][sw] == 0){\n\t\tvis[sh-1][sw] = 1;\n\t\tans++;\n\t\tans = dfs(sh-1, sw, ans);\n\t}\n\tif(mp[sh][sw-1] == '.' && vis[sh][sw-1] == 0){\n\t\tvis[sh][sw-1] = 1;\n\t\tans++;\n\t\tans = dfs(sh, sw-1, ans);\n\t}\n\tif(mp[sh][sw+1] == '.' && vis[sh][sw+1] == 0){\n\t\tvis[sh][sw+1] = 1;\n\t\tans++;\n\t\tans = dfs(sh, sw+1, ans);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint W, H, ans, sw, sh;\n\t\n\twhile(1){\n\t\tans = 0;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0) break;\n\t\tfor(int i=0;i<22;i++){\n\t\t\tfor(int j=0;j<22;j++){\n\t\t\t\tvis[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin >> mp[i][j];\n\t\t\t\tif(mp[i][j] == '@'){\n\t\t\t\t\tsh = i;\n\t\t\t\t\tsw = j;\n\t\t\t\t\tvis[i][j] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tvis[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = dfs(sh, sw, ans);\n\t\tans++;\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstatic const int WHITE = 0;\nstatic const int ABLE  = 1;\nstatic const int N = 20;\n\nchar a[N][N];\nint judge[N][N];\n\nvoid search(int x, int y, int w, int h) {\n\tqueue<int> qx, qy;\n\tqx.push(x);\n\tqy.push(y);\n\tjudge[y][x] = ABLE;\n\t\n\tint tx, ty;\n\twhile (!qx.empty() && !qy.empty()) {\n\t\ttx = qx.front();\n\t\tqx.pop();\n\t\tty = qy.front();\n\t\tqy.pop();\n\t\t\n\t\tif (ty + 1 < h && a[ty+1][tx] != '#' && judge[ty+1][tx] == WHITE) {\n\t\t\tjudge[ty+1][tx] = ABLE;\n\t\t\tqx.push(tx);\n\t\t\tqy.push(ty+1);\n\t\t}\n\t\tif (ty - 1 >= 0 && a[ty-1][tx] != '#' && judge[ty-1][tx] == WHITE) {\n\t\t\tjudge[ty-1][tx] = ABLE;\n\t\t\tqx.push(tx);\n\t\t\tqy.push(ty-1);\n\t\t}\n\t\tif (tx + 1 < w && a[ty][tx+1] != '#' && judge[ty][tx+1] == WHITE) {\n\t\t\tjudge[ty][tx+1] = ABLE;\n\t\t\tqx.push(tx+1);\n\t\t\tqy.push(ty);\n\t\t}\n\t\tif (tx - 1 >= 0 && a[ty][tx-1] != '#' && judge[ty][tx-1] == WHITE) {\n\t\t\tjudge[ty][tx-1] = ABLE;\n\t\t\tqx.push(tx-1);\n\t\t\tqy.push(ty);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (h == 0) break;\n\t\t\n\t\tint startx, starty;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tcin >> a[i][j];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] == '.' || a[i][j] == '#') judge[i][j] = WHITE;\n\t\t\t\telse {\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t\tjudge[i][j] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsearch(startx, starty, w, h);\n\t\t\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tif (judge[i][j] == ABLE) count++;\n\t\t\t\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nchar room[21][21];\nint count,W,H;\n\nvoid root(int W_n,int H_n){\n\tif((H_n+1)<H&&room[H_n+1][W_n]=='.'){\n\t\troom[H_n+1][W_n]='#';\n\t\tcount++;\n\t\troot(W_n,H_n+1);\n\t}\n\tif(W_n>0&&room[H_n][W_n-1]=='.'){\n\t\troom[H_n][W_n-1]='#';\n\t\tcount++;\n\t\troot(W_n-1,H_n);\n\t}\n\tif(H_n>0&&room[H_n-1][W_n]=='.'){\n\t\troom[H_n-1][W_n]='#';\n\t\tcount++;\n\t\troot(W_n,H_n-1);\n\t}\n\tif((W_n+1)<W&&room[H_n][W_n+1]=='.'){\n\t\troom[H_n][W_n+1]='#';\n\t\tcount++;\n\t\troot(W_n+1,H_n);\n\t}\n\n}\n\n\nint main(void){\n\t\n\tscanf(\"%d%d\",&W,&H);\n\twhile(W!=0&&H!=0){\n\t\tcount=1;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tscanf(\"%s\",room[i]);\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(room[i][j]=='@'){\n\t\t\t\t\troot(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t\tscanf(\"%d%d\",&W,&H);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n//container util\n//------------------------------------------\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define iter(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n//repetition\n//------------------------------------------\n#define loop(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  loop(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\n// output vector\n// ------------------------------------------\nnamespace std {\n    template<typename T> ostream & operator<<(ostream& os, vector<T> const& v){\n        for(auto it=v.begin(); it!=v.end(); ++it){\n            os << *it << (it+1==v.end() ? \"\" : \",\");\n        }\n        return os;\n    }\n}\n\n//clear memory\n#define clr(a) memset((a), 0 ,sizeof(a))\n\nint lcm(int a,int b){\n   return a*b/__gcd(a,b);\n}\n \nvb pn((int)1e4+10); \nvoid prime_number(int n){\n   fill(all(pn),true);\n   pn[0]=false;pn[1]=false;\n   loop(i,2,n/2+1){\n      if(!pn[i]) continue;\n      for(int j=2;i*j<=n;j++){\n         pn[i*j]=false;\n      }\n   }\n}\n\nchar m[21][21];\nint ans;\n\nvoid tansaku(int a, int b, int x, int y){\n   if(a-1>=0)if(m[a-1][b]=='.'){\n      m[a-1][b]='*';\n      ans++;\n      tansaku(a-1,b,x,y);\n   }\n   if(b-1>=0)if(m[a][b-1]=='.'){\n      m[a][b-1]='*';\n      ans++;\n      tansaku(a,b-1,x,y);\n   }\n   if(a+1<x)if(m[a+1][b]=='.'){\n      m[a+1][b]='*';\n      ans++;\n      tansaku(a+1,b,x,y);\n   }\n   if(b+1<y)if(m[a][b+1]=='.'){\n      m[a][b+1]='*';\n      ans++;\n      tansaku(a,b+1,x,y);\n   }\n}\n\nint main(){\n   int x,y,a,b;\n   string tmp;\n   while(cin >> x >> y){\n      if(x+y==0) break;\n      ans=1;\n      rep(j,y){\n         rep(i,x){\n            cin>>m[i][j];\n            if(m[i][j]=='@'){\n               a=i;b=j;\n            }\n         }\n      }\n      tansaku(a,b,x,y);\n      cout <<  ans << endl;\n\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0,  -1};\n\nint sx, sy;\nint ans;\nint w, h;\nvector<string> ma;\n\nvoid BFS(){\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\tans++;\n\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint ny = p.first + dy[i];\n\t\t\tint nx = p.second + dx[i];\n\n\t\t\tif(ny >= 0 && ny < h && nx >= 0 && nx < w && ma[ny][nx] == '.'){\n\t\t\t\tans++;\n\t\t\t\tma[ny][nx] = '#';\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\nint main(void){\n\twhile(1){\n\t\tma.clear();\n\t\tans = 0;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\n\t\t\tma.push_back(tmp);\n\t\t}\n\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(ma[i][j] == '@' ){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tBFS();\n\n\t\tcout << ans << endl;\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint w,h;\nchar fie[23][23];\nint check[23][23];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint solve(int x,int y){\n  int ret=1;\n  check[x][y]=1;\n  for(int i=0;i<4;i++){\n    if(x+dx[i] < 0 || x+dx[i] >= w || y+dy[i] <0 || y+dy[i] >=h) continue;\n    if(fie[x+dx[i]][y+dy[i]]=='.' && check[x+dx[i]][y+dy[i]]==0){\n      ret+=solve(x+dx[i],y+dy[i]);\n    }\n  }\n  return ret;\n}\n\nmain(){\n  while(1){\n    int x,y;\n    cin >> w>>h;\n    if(!w || !h) break;\n    memset(check,0,sizeof(check));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> fie[j][i];\n\tif(fie[j][i]=='@'){ x=j;y=i;}\n      }\n    }\n    cout << solve(x,y) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\nchar **data;\nint w,h;\n\nint r(int,int);\n\nint main(){\n\tint i,j;\n\tint num;\n\tint x,y;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\tdata=new char*[h];\n\t\tfor(i=0;i<h;i++){\n\t\t\tdata[i]=new char[w+1];\n\t\t\tcin>>data[i];\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(data[i][j]=='@'){\n\t\t\t\t\tdata[i][j]='.';\n\t\t\t\t\tx=j;\n\t\t\t\t\ty=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnum=r(x,y);\n\t\tcout<<num<<endl;\n\t}\n\treturn 0;\n}\n\nint r(int x,int y){\n\tint count=0;\n\tif(x>=w || x<0) return 0;\n\tif(y>=h || y<0) return 0;\n\n\tif(data[y][x]=='.'){\n\t\tdata[y][x]='@';\n\t\tcount++;\n\t}\n\telse return 0;\n\tcount+=r(x+1,y);\n\tcount+=r(x-1,y);\n\tcount+=r(x,y+1);\n\tcount+=r(x,y-1);\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int w,h;\n    while(1){\n        cin>>w>>h;  if(w==0)break;\n        char tile[h][w];    //タテｘヨコ\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++)cin>>tile[i][j];\n        }\n//        for(int i=0;i<h;i++){\n//            for(int j=0;j<w;j++)cout<<tile[i][j]<<\" \";\n//            cout<<endl;\n//        }\n\n        int ans=1;\n\n        for(int a=0;a<w*h;a++){\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n\n                    if(tile[i][j]=='@'){\n                        tile[i][j]='#';\n\n                        if(j<w-1 && tile[i][j+1]=='.'){\n                            ans++;\n                            tile[i][j+1]='@';\n                        }\n                        if(j>0 && tile[i][j-1]=='.'){\n                            ans++;\n                            tile[i][j-1]='@';\n                        }\n                        if(i<h-1 && tile[i+1][j]=='.'){\n                            ans++;\n                            tile[i+1][j]='@';\n                        }\n                        if(i>0 && tile[i-1][j]=='.'){\n                            ans++;\n                            tile[i-1][j]='@';\n                        }\n\n//                        for(int b=0;b<h;b++){\n//                            for(int c=0;c<w;c++)cout<<tile[b][c];\n//                            cout<<endl;\n//                        }\n//                        cout<<endl;\n                        break;\n\n                    }\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint count;\nint W = 0, H = 0;\nchar tyle[22][22];\n\n\nvoid check(int x, int y);\n\n\nint main(){\n\n\tint i, j;\n\tint startH, startW;\n\n\n\twhile(1){\n\n\t\tcount = 0;\n\n\t\tcin >> W >> H;\n\n\t\tif(W != 0 && H != 0){\n\n\t\t\tfor(i = 0; i <= W; i++){\n\t\t\t\ttyle[i][0] = '#';\n\t\t\t\ttyle[i][H+1] = '#';\n\t\t\t}\n\n\t\t\tfor(i = 0; i <= H; i++){\n\t\t\t\ttyle[0][i] = '#';\n\t\t\t\ttyle[W+1][i] = '#';\n\t\t\t}\n\n\t\t\tfor(i = 1; i <= H; i++){\n\t\t\t\tfor(j = 1; j <= W; j++){\n\t\t\t\t\tcin >> tyle[j][i];\n\t\t\t\t\tif(tyle[j][i] == '@'){\n\t\t\t\t\t\tstartH = i;\n\t\t\t\t\t\tstartW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tcheck(startW, startH);\n\n\t\t\tcout << count << endl;\n\n\t\t}\n\n\t\telse{break;}\n\n\t}\n\n\treturn 0;\n}\n\n\n\n\nvoid check(int x, int y){\n\n\tcount++;\n\n\ttyle[x][y] = '#';\n\n\tif(tyle[x][y-1] == '.'){\n\t\tcheck(x, y-1);\n\t}\n\tif(tyle[x-1][y] == '.'){\n\t\tcheck(x-1, y);\n\t}\n\tif(tyle[x][y+1] == '.'){\n\t\tcheck(x, y+1);\n\t}\n\tif(tyle[x+1][y] == '.'){\n\t\tcheck(x+1, y);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstatic const int MAX= 20;\nchar map[MAX][MAX];\n\nint main() {\n    int W, H, sx, sy, nx, ny, sum;\n    int dx[4] = {0, 0, -1, 1};\n    int dy[4] = {-1, 1, 0, 0};\n    for (; ;) {\n        std::cin >> W >> H;\n        if (H == 0 && W == 0) break;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                std::cin >> map[i][j];\n                if (map[i][j] == '@') sx = i, sy =j;\n            }\n        }\n        std::queue<std::pair<int, int> > q;\n        q.push({sx, sy});\n        map[sx][sy] = '*';\n        while ( !q.empty() ) {\n            std::pair<int, int> p = q.front(); q.pop();\n            for (int i = 0; i < 4; i++) {\n                nx = p.first + dx[i], ny = p.second + dy[i];\n                if (0 <= nx && nx < H && 0 <= ny && ny < W && map[nx][ny] == '.') {\n                    map[nx][ny] = '*';\n                    q.push({nx, ny});\n                }\n            }\n        }\n        sum = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) if (map[i][j] == '*') sum++;\n        }\n        std::cout << sum << std::endl;\n    }\n\n\n    return  0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nint main(){\n  char c;\n  int x, y, atx, aty, ind, count = 1;\n  std::vector<int> real;\n  std::queue<int> q;\n\n  std::cin >> x;\n  std::cin >> y;\n\n  while(x != 0 || y != 0){\n\n    real.resize(x*y);\n\n    for(int i = 0; i < y; i++){         //地図の読み込みと＠の座標の格納\n      for(int j = 0; j < x; j++){\n        std::cin >> c;\n        if(c == '.'){\n\n          real[i*x + j] = 1;\n\n        }else if(c == '#'){\n\n          real[i*x + j] = 0;\n\n        }else if(c == '@'){\n\n          real[i*x + j] = -1;\n          atx = j;//atx と aty は＠の座標を意味している\n          aty = i;\n\n        }else{\n\n          std::cout << \"unexpected char input!\" << std::endl;\n          return 0;\n\n        }\n      }\n    }\n\n    //＠を起点にして探索を開始する。\n\n    q.push(atx + aty * x);\n\n    while( !q.empty() ){\n      \n      ind = q.front();\n      q.pop();\n\n\n      if( ind%x != 0){//左をチェック 左端でなければ\n        if(real[ ind-1 ] == 1 ){\n\n          real[ ind-1 ] = -1;\n          q.push( ind-1 );\n          count++;\n        }\n      }\n\n      if( ind%x != x-1 ){//右をチェック 右端でなければ\n        if(real[ ind+1 ] == 1){\n\n          real[ ind+1 ] = -1;\n          q.push( ind+1 );\n          count++;\n        }\n      }\n\n      if( ind-x > 0 ){//上をチェック 上端でなければ\n        if(real[ ind-x ] == 1){\n\n          real[ ind-x ] = -1;\n          q.push( ind-x );\n          count++;\n        }\n      }\n\n      if( ind+x < x * y){//下をチェック 下端でなければ\n        if(real[ ind+x ] == 1){\n\n          real[ ind+x ] = -1;\n          q.push( ind+x );\n          count++;\n        }\n      }\n\n    }\n\n    std::cout << count << std::endl;\n    std::cout << std::endl;\n\n///*\n    for(int i = 0; i < y;i++){\n      for(int j = 0; j < x; j++){\n        std::cout << real[i*x + j];\n      }\n      std::cout << std::endl;\n    }\n//*/\n    std::cin >> x;\n    std::cin >> y;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define REP(i,s,n) for(int i=s ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\n\nint W,H;\nchar field[20][20];\nint cnt;\n\nvoid dfs(int x,int y){\n\n  field[y][x]='#';\n  \n  cnt++;\n  \n  if( x+1 < W && field[y][x+1] == '.'){\n    dfs(x+1,y);\n  }\n  if(x-1 >= 0 && field[y][x-1] == '.'){\n    dfs(x-1,y);\n  }\n  if(y+1 < H && field[y+1][x] == '.'){\n    dfs(x,y+1);\n  }\n  if(y-1 >=0 && field[y-1][x] == '.'){\n    dfs(x,y-1);\n  }\n  \n}\nint main(){\n  \n  int x,y;\n  \n  while(1){\n    cin >>W>>H;\n    if(W==0 && H==0)break;\n    \n    rep(i,H){\n      rep(j,W){\n\tcin >>field[i][j];\n\tif(field[i][j] == '@'){\n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n    cnt=0;\n    dfs(x,y);\n    cout <<cnt<<endl; \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid dfs(int x,int y);\nint h,w;\nchar ta[22][22];\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint cou=0;\n\nint main(){\n  int a,b;\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    cou=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> ta[i][j];\n\tif(ta[i][j]=='@'){\n\t  a=i,b=j;\n\t}\n      }\n    }\n    dfs(a,b);\n    cout << cou << endl;\n  }\n}\n\nvoid dfs(int x,int y){\n  ta[x][y]='#';\n  cou++;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx>=0 && nx<h && ny>=0 && ny<w && ta[nx][ny]=='.'){\n      dfs(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pq priority_queue\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define line() cerr << \"---------------\" << endl;\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\nint H, W;\nchar b[30][30];\nint ans;\n\nvoid dfs(int y, int x) {\n   ans++;\n   b[y][x] = '*';   \n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny>=0 && ny<H && nx>=0 && nx<W && b[ny][nx] == '.') {\n         dfs(ny, nx);\n      }\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> b[i];\n      }\n\n      ans = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (b[i][j] == '@') {\n               dfs(i, j);\n            }\n         }\n      }\n      cout << ans << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\nusing P = pair<int, int>;\n\nint h, w;\n\nvoid dfs(int x, int y, vector<string> &g, vector<vector<bool>> &seen) {\n    if(seen[y][x] || g[y][x] == '#') {\n        return;\n    }\n    seen[y][x] = true;\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && g[ny][nx] == '.' &&\n           !seen[ny][nx]) {\n            dfs(nx, ny, g, seen);\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        cin >> w >> h;\n        if(h == 0 && w == 0) {\n            break;\n        }\n        vector<string> g(h);\n        for(int i = 0; i < h; i++) {\n            cin >> g[i];\n        }\n        vector<vector<bool>> seen(h, vector<bool>(w, false));\n        int sx, sy;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(g[i][j] == '@') {\n                    sy = i, sx = j;\n                }\n            }\n        }\n        dfs(sx, sy, g, seen);\n        int ans = 0;\n        for(int i = 0; i < h; i++) {\n            ans += count(ALL(seen[i]), true);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint w,h,res;\nchar field[20][20];\n\nvoid dfs(int x,int y){\n\tres++;\n\tfield[x][y] = '#';\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] == '.'){\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\tint x,y;\n\twhile(cin >> w >> h,w){\n\t\tres = 0;\n\t\tgetchar();\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++) {\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tdfs(x,y);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint dy[]={0,0,-1,1},dx[]={-1,1,0,0};\nclass data{\npublic:\n    int y,x;\n    data(int _y,int _x){\n        y=_y;x=_x;\n    }\n    data(){}\n};\nint main(){\n    int w,h;\n    while(cin>>w>>h,h||w){\n        char field[20][21];\n        bool f[20][20]={{0}};\n        for(int i=0;i<h;i++)cin>>field[i];\n        int sy,sx;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(field[i][j]=='@'){\n                    sy=i;\n                    sx=j;\n                }\n            }\n        }\n        queue<data>Q;\n        Q.push(data(sy,sx));\n        int cnt=0;\n        while(Q.size()){\n            data a=Q.front();Q.pop();\n            int y=a.y,x=a.x;\n            if(y<0||y>=h||x<0||x>=w)continue;\n            if(f[y][x])continue;\n            if(field[y][x]=='#')continue;\n            f[y][x]=true;\n            cnt++;\n            for(int i=0;i<4;i++){\n                Q.push(data(y+dy[i],x+dx[i]));\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint W, H;\nchar map[20][20];\nint cnt;\nint angle[][2] = {\n\t{-1, 0}, {0, -1}, {1, 0}, {0, 1}\n};\n\nvoid dfs(int x, int y)\n{\n\tif (map[x][y] == '#' || x < 0 || y < 0 || x >= W || y >= H){\n\t\treturn;\n\t}\n\tcnt++;\n\tmap[x][y] = '#';\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tdfs(x + angle[i][0], y + angle[i][1]);\n\t}\n}\n\nint main()\n{\n\tint num;\n\t\n\twhile (scanf(\"%d %d\", &W, &H), W + H){\n\t\tint x;\n\t\tint y;\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tscanf(\" %c\", &map[j][i]);\n\t\t\t\tif (map[j][i] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tmap[j][i] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tdfs(x, y);\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\n\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tint tot=1; //?????£????????????(?????????????????????)\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y);\n\twhile(!q.empty()){\n\t\tp=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(p.first+dx[i],p.second+dy[i]))\n\t\t\t\ttot+=1;\n\t\t\t\tp.first+=dx[i]; p.second+=dy[i];\n\t\t\t\tq.push(p);\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[j][i];\n\t\t\t\tif(P[j][i]=='@')\n\t\t\t\t\tx1=j; y1=i; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint main(){\n\tint w,h;\n\tchar cfield[20][21];\n\tint ifield[20][20];\n\tint already[20][20];\n\tchar point;\n\n\twhile(std::cin >> w >> h && (w || h)){\n\t\trep(i,20){\n\t\t\tmemset(cfield[i],'#',20);\n\t\t\trep(j,20){\n\t\t\t\tifield[i][j] = 0;\n\t\t\t\talready[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint x=-1,y=-1;\n\t\tint count = 1;\n\t\tint sum;\n\t\trep(i,h){\n\t\t\tstd::cin >> cfield[i];\n\t\t}\n\t\trep(i,20){\n\t\t\trep(j,20){\n\t\t\t\tif(cfield[i][j] == '@'){\n\t\t\t\t\tx=i,y=j;\n\t\t\t\t\talready[x][y] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfield[x][y] == '@') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\trep(i,3) {\n\t\t\t\tpoint = cfield[x - 1 + i][y];\n\t\t\t\tif (point == '@' || point == '.' || point == '#') {\n\t\t\t\t\tif (point == '@') {\n\t\t\t\t\t\talready[x - 1 + i][y] = 1;\n\t\t\t\t\t\tifield[x - 1 + i][y] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (point == '.') {\n\t\t\t\t\t\tif (already[x - 1 + i][y] != 1) {\n\t\t\t\t\t\t\tifield[x - 1 + i][y] = 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tifield[x - 1 + i][y] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(point == '#'){\n\t\t\t\t\t\tifield[x - 1 + i][y] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,3) {\n\t\t\t\tpoint = cfield[x][y - 1 + j];\n\t\t\t\tif (point == '@' || point == '.' || point == '#') {\n\t\t\t\t\tif (point == '@') {\n\t\t\t\t\t\talready[x][y - 1 + j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (point == '.') {\n\t\t\t\t\t\tif (already[x][y - 1 + j] != 1) {\n\t\t\t\t\t\t\tifield[x][y - 1 + j] = 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tifield[x][y - 1 + j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (point == '#') {\n\t\t\t\t\t\tifield[x][y - 1 + j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsum = 0;\n\t\t\trep(i,20){\n\t\t\t\trep(j,20){\n\t\t\t\t\tsum += ifield[i][j];\n\t\t\t\t\tif(ifield[i][j] == 1){\n\t\t\t\t\t\tcfield[i][j] = '@';\n\t\t\t\t\t\tcfield[x][y] = '.';\n\t\t\t\t\t\tx=i,y=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum == 0)break;\n\t\t\tcount++;\n\t\t}\n\t\tstd::cout << count << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define INF 1e18\nusing namespace std;\n// x[H][W]\n// 1: accessible\n// INF: not arrived\n// -1: can't access\nint a[20][20];\nint H, W;\n\nvoid dfs(int x, int y) {\n  int moveX[4] = { 1, 0, -1, 0 };\n  int moveY[4] = { 0, 1, 0, -1 };\n  a[y][x] = 1;\n  for (int i = 0; i < 4; i++) {\n    int nx = moveX[i]+x;\n    int ny = moveY[i]+y;\n    if (a[ny][nx] == INF && nx >= 0 && nx < W && ny >= 0 && ny < H) {\n      dfs(nx, ny);\n    }\n  }\n}\n\nsigned main() {\n  while (cin>>W>>H, W+H!=0) {\n    int startX, startY;\n    for (int i = 0LL; i < H; i++) {\n      for (int j = 0LL; j < W; j++) {\n        char c; cin >> c;\n        if (c == '.') {\n          a[i][j] = INF;\n        } else if (c == '#') {\n          a[i][j] = -1;\n        } else {\n          a[i][j] = INF;\n          startX = j;\n          startY = i;\n        }\n      }\n    }\n    dfs(startX, startY);\n    \n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        if (a[i][j] == 1) ans++;\n      }\n    }\n\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h;\nstring s[20];\n\nint getCount(int sy, int sx) {\n\tconst int dy[4] = {-1, 0, 1, 0};\n\tconst int dx[4] = {0, 1, 0, -1};\n\tqueue<P> que;\n\tbool used[20][20] = {false};\n\t\n\tque.push(P(sy, sx));\n\tused[sy][sx] = true;\n\t\n\twhile (!que.empty()) {\n\t\tP now = que.front(); que.pop();\n\t\tint y = now.first;\n\t\tint x = now.second;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || used[ny][nx]) continue;\n\t\t\tused[ny][nx] = true;\n\t\t\tque.push(P(ny, nx));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tans += used[i][j];\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '@') {\n\t\t\t\tcout << getCount(i, j) << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (!w) break;\n\t\tfor (int i = 0; i < h; i++) cin >> s[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint h, w = 0;\nint ct = 0;\nvector<string> map;\n\nvoid count(int y,int x){\n\tmap[y][x] = 'X';\n\tif (y != 0){\n\t\tif (map[y-1][x] == '.'){\n\t\t\t\tcount(y-1,x);\n\t\t}\n\t}\n\tif (y != h-1){\n\t\tif (map[y+1][x] == '.'){\n\t\t\t\tcount(y+1,x);\n\t\t}\n\t}\n\tif (x != 0){\n\t\tif (map[y][x-1] == '.'){\n\t\t\t\tcount(y,x-1);\n\t\t}\n\t}\n\tif (x != w-1){\n\t\tif (map[y][x+1] == '.'){\n\t\t\t\tcount(y,x+1);\n\t\t}\n\t}\n\tct++;\n}\n\nint main(){\n\tint stx, sty;\n\twhile (1){\n\t\tcin >> w >> h;\n\t\tif (h == 0 && w == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tmap.push_back(tmp);\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == '@'){\n\t\t\t\t\tsty = i;\n\t\t\t\t\tstx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount(sty,stx);\n\t\tcout << ct << endl;\n\t\tct = 0;\n\t\tmap.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct dsu {\n  const int n;\n  vector<int> p, sz;\n  dsu(int _n) : n(_n), p(n, -1), sz(n, 1) {}\n  int root(int v) { return p[v] == -1 ? v : v = root(p[v]); }\n  void unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n  }\n  int size(int v) { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int h, w;\n  while (cin >> w >> h, w) {\n    vector<string> s(h);\n    for (auto&& e : s) {\n      cin >> e;\n    }\n    dsu d(h * w);\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (s[i][j] != '#') {\n          if (i + 1 < h and s[i + 1][j] != '#') {\n            d.unite(i * w + j, (i + 1) * w + j);\n          }\n          if (j + 1 < w and s[i][j + 1] != '#') {\n            d.unite(i * w + j, i * w + (j + 1));\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        if (s[i][j] == '@') {\n          cout << d.size(i * w + j) << '\\n';\n        }\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint tx[4] = {0,-1,0,1};\nint ty[4] = {-1,0,1,0};\nchar map[21][21];\n\nint slv(int x,int y){\n    map[y][x]='#';\n    int ans=0;\n    for(int i=0;i<4;++i)\n        if( x+tx[i]!=-1 && y+ty[i]!=-1 && x+tx[i]!=w && y+ty[i]!=h)\n            if( map[y+ty[i]][x+tx[i]] == '.' )\n                ans+=slv( x+tx[i], y+ty[i] ) + 1 ;\n    return ans;\n}\n\nint main()\n{\n    int ix,iy;\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        for(int i=0;i<h;++i)\n            for(int j=0;j<w;++j){\n                cin >> map[i][j];\n                if(map[i][j]=='@'){ix=j;iy=i;}\n            }\n        cout << slv( ix , iy ) + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX = 20;\nchar map[MAX][MAX];\nbool book[MAX][MAX];\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x = 0, int y = 0) :x(x), y(y) {}\n}start;\nint sum = 0;\nvoid depthFSearch(int H, int W, Point start)\n{\n\tint next[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\n\tfor (int k = 0; k <= 3; k++)\n\t{\n\t\tint nx = start.x + next[k][0];\n\t\tint ny = start.y + next[k][1];\n\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W)\n\t\t\tcontinue;\n\t\tif (!book[nx][ny] && map[nx][ny] == '.')\n\t\t{\n\t\t\tbook[nx][ny] = true;\n\t\t\tPoint p(nx, ny);\n\t\t\tsum++;\n\t\t\tdepthFSearch(H, W, p);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tif (!H && !W)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')\n\t\t\t\t\tstart = Point(i, j);\n\t\t\t}\n\t\tbook[start.x][start.y] = true;\n\t\tsum = 1;\n\t\tdepthFSearch(H, W, start);\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nvoid Ans(bool f){\n  if(f) cout << \"YES\"<<endl;\n  else cout << \"NO\"<<endl;\n}\n\nll w,h,ans;\nvector<vector<char>> t;\nvoid dfs(ll x, ll y){\n  if(value(x,y,w,h)){\n    if( t[x][y] != '.' ) return ;\n    ++ans;\n    t[x][y] = '0';\n    rep(i,4){\n      dfs(x+dx[i],y+dy[i]);\n    }\n  }\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> w >> h && w && h){\n    ll x,y;\n    t = vector<vector<char>>(20,vector<char>(20,' '));\n    ans = 0;\n    rep(i,h){\n      rep(j,w){\n        cin >> t[j][i];\n        if(t[j][i] == '@'){\n          x = j;\n          y = i;\n        }\n      }\n    }\n    t[x][y] = '.';\n    dfs(x,y);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main()\n{\n\tchar map[32][32];\n\tqueue< P > que;\n\twhile (true)\n\t{\n\t\tint w, h, x, y;\n\t\tcin >> w >> h;\n\t\tif (!(w || h)) break;\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> map[i];\n\t\t\tchar* x0 = index(map[i], '@');\n\t\t\tif (x0 != NULL)\n\t\t\t{\n\t\t\t\tx = x0 - map[i];\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tque.push(P(x, y));\n\t\tmap[y][x] = '#';\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP current = que.front();\n\t\t\tque.pop();\n\t\t\tcount++;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint nx = current.first + dx[i];\n\t\t\t\tint ny = current.second + dy[i];\n\t\t\t\tif ((0 <= nx && nx < w && 0 <= ny && ny < h) && (map[ny][nx] == '.'))\n\t\t\t\t{\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tmap[ny][nx] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint cnt;\nint w,h;\nchar map[24][24];\nvoid func(int y,int x)\n{\n    cnt++;\n    map[y][x]='#';\n    int ny,nx;\n    int dx[]={0,0,1,-1};\n    int dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++)\n    {\n        ny=y+dy[i];\n        nx=x+dx[i];\n        if(map[ny][nx]=='.'&&0<=ny&&0<=nx&&ny<h&&nx<w)func(ny,nx);\n    }\n    return;\n}\nint main()\n{\n    while(cin>>w>>h,w)\n    {\n        cnt=0;\n        int x,y;\n        for(int i=0;i<24;i++)\n        {\n            for(int j=0;j<24;j++)\n            {\n                map[i][j]='#';\n            }\n        }\n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {\n                cin>>map[i][j];\n                if(map[i][j]=='@')\n                {\n                    y=i;\n                    x=j;\n                }\n            }\n        }\n        func(y,x);\n        cout<<cnt<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nint func(int x, int y, vector<vector<int>> &map){\n\n    if(map[y][x] == -1)\n        return 0;\n\n    if(map[y][x] == 1)\n        return 0;\n\n    map[y][x] = 1;\n\n    int ret = 0;\n\n    for(int i = 0; i < 4; i++){\n        ret += func(x + dx[i], y + dy[i], map);\n    }\n\n    return ret + 1;\n\n}\n\nint main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while( true ){\n\n        int w, h;\n        cin >> w >> h;\n        \n        if(w == 0 && h == 0)\n            break;\n\n        int x,y;\n        vector<vector<int>> map(h + 2, vector<int>(w + 2, -1));\n        for(int i = 0; i < h; i++){\n            string s;\n            cin >> s;\n            for(int j = 0; j < w ; j++){\n                if(s[j] == '.')\n                    map[i + 1][j + 1] = 0;\n                else if(s[j] == '#')\n                    map[i + 1][j + 1] = -1;\n                else {\n                    map[i + 1][j + 1] = 0;\n                    x = j + 1;\n                    y = i + 1;\n                }\n            }\n        }\n\n        cout << func(x, y, map) << endl;\n        /*\n        for(auto &x:map){\n            for(auto &y: x)\n                cout << y << ' ';\n            cout << endl;\n        }\n        */\n\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nint box[20][20];\nint  kazoe(int p,int P,int H,int W){\n  int i,I;\n  a++;\n  box[p][P]=0;\n  if(box[p][P+1]==1) kazoe(p,P+1,H,W);\n  if(box[p][P-1]==1) kazoe(p,P-1,H,W);\n  if(box[p-1][P]==1) kazoe(p-1,P,H,W);\n  if(box[p+1][P]==1) kazoe(p+1,P,H,W);\n  else {\n  return a;\n  }\n}\nint main(){\n  int i,I,H,W,p,P;\n  \n  char v;\n  while(1){\n  cin>>W>>H;\n  if(W==0&&H==0) break;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  cout<<kazoe(p,P,H,W)<<endl;\n  a=0;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      box[i][I]=0;\n    }\n  }\n  \n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\nconst int dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\nint main(void){\n\tqueue<int> qx, qy;\n\tint x, y, i, j, w, h, flag[20][20], count;\n\tchar field[20][21];\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tmemset(flag,0,sizeof(flag));\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = getchar();\n\t\t\t\tif(field[i][j] == '@')\n\t\t\t\t\ty = i, x = j;\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tqx.push(x);\n\t\tqy.push(y);\n\t\twhile(qx.size()){\n\t\t\tx = qx.front();\n\t\t\ty = qy.front();\n\t\t\tqx.pop();\n\t\t\tqy.pop();\n\t\t\tflag[y][x] = 1;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0 && y + dy[i] < h && !flag[y + dy[i]][x + dx[i]] && field[y + dy[i]][x + dx[i]] == '.')\n\t\t\t\t\tqx.push(x + dx[i]), qy.push(y + dy[i]);\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++)\n\t\t\t\tif(flag[i][j]) count++;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\ntypedef struct{\n  int col;\n  int row;\n}RL;\n\n\nint main(){\n\n  int col, row;\n  while(cin >> row >> col){\n    if(col == 0 && row == 0)break;\n    int sum = 1;\n    char data[col][row];\n    RL myposi;\n\n    for(int i = 0; i < col; i++){\n      for(int j = 0; j < row; j++){\n\tcin >> data[i][j];\n\tif(data[i][j] == '@'){\n\t  myposi.col = i;\n\t  myposi.row = j;\n\t}\n      }\n    }\n\n    queue<RL> Q;\n    Q.push(myposi);\n\n    while(!Q.empty()){\n      RL front;\n      front = Q.front();\n      Q.pop();\n      \n      if(front.col-1 >= 0 && data[front.col-1][front.row] == '.'){\n\tsum++;\n\tdata[front.col-1][front.row] = '#';\n\tRL a;\n\ta.col = front.col-1;\n\ta.row = front.row;\n\tQ.push(a);\n      }\n      if(front.col+1 < col && data[front.col+1][front.row] == '.'){\n\tsum++;\n\tdata[front.col+1][front.row] = '#';\n\tRL a;\n\ta.col = front.col+1;\n\ta.row = front.row;\n\tQ.push(a);\n      }\n      if(front.row-1 >= 0 && data[front.col][front.row-1] == '.'){\n\tsum++;\n\tdata[front.col][front.row-1] = '#';\n\tRL a;\n\ta.col = front.col;\n\ta.row = front.row-1;\n\tQ.push(a);\n      }\n       if(front.row+1 < row && data[front.col][front.row+1] == '.'){\n\tsum++;\n\tdata[front.col][front.row+1] = '#';\n\tRL a;\n\ta.col = front.col;\n\ta.row = front.row+1;\n\tQ.push(a);\n      }\n\n    }\n    cout << sum << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n        \n    }\n    \n}\n\nint main(){\n    while(1){\n        int x,y,startx,starty;\n        vector<vector<bool> > map;\n        cin>>x>>y;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nint w,h;\nchar f[32][32];\n\nint fill(int x, int y){\n\tif( x<0 || y<0 || x>=w || y>=h || f[y][x]=='#' )return 0;\n\tf[y][x] = '#';\n\treturn 1 + fill(x-1,y) + fill(x+1,y) + fill(x,y+1) + fill(x,y-1);\n}\n\nint main(){\n\tint x,y;\n\twhile(cin>>w>>h,w|h){\n\t\trep(i,h)cin>>f[i];\n\t\trep(i,h)rep(j,w)if( f[i][j]=='@' ){\n\t\t\tx=j; y=i;\n\t\t}\n\t\tprintf(\"%d\\n\",fill(x,y));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <string>\n#include <vector>\n#define INF 10000000\n#define PI 3.14159265358979323846\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef vector<int> v;\ntypedef vector<int, int> v2;\ntypedef vector< pair<int, int> > vp;\nint dx[4] = {  0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nint w, h;\nchar c[21][21];\n\nint bfs(int y, int x){\n\tint sum = 1;\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && c[ny][nx] == '.'){\n\t\t\tc[ny][nx] = '#';\n\t\t\tsum += bfs(ny, nx);\n\t\t}\n\t}\n\t\n\treturn sum;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\twhile (1){\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\n\t\tint sx,sy;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif (c[i][j] == '@'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\t\t\n\n\t\tcout << bfs(sy, sx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nvoid bfs(std::vector<std::vector<char> > &map, std::pair<int, int> start) {\n    int w = map.size();\n    int h = map[0].size();\n    int dy[4] = {0, 0, 1, -1};\n    int dx[4] = {1, -1, 0, 0};\n    std::queue<std::pair<int, int> > que; // coord\n    int cost = 0;\n    std::pair<int, int> coord = start;\n    cost++;\n    que.push(std::make_pair(coord.first, coord.second));\n    map[coord.first][coord.second] = '#';\n\n    while(! que.empty()) {\n        coord = que.front(); \n        que.pop();\n        for (int i = 0; i < 4; i++) {\n            if (map[coord.first + dy[i]][coord.second + dx[i]] == '.') {\n                cost++;\n                que.push(std::make_pair(coord.first + dy[i], coord.second + dx[i]));\n                map[coord.first + dy[i]][coord.second + dx[i]] = '#';\n            }\n        }\n    }\n    std::cout << cost << std::endl;\n    return;\n}\n\nint main(void) {\n    int w;\n    int h;\n    std::pair<int, int> start;\n\n    while (1) {\n        std::cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        std::vector<std::vector<char> > map(h + 2, std::vector<char>(w + 2, '#'));\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                std::cin >> map[i][j];\n                if (map[i][j] == '@') {\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n        bfs(map, start);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\ttot++;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint W, H;\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {-1, 0, 1, 0};\nchar field[22][22];     // 1-origin\n\nint dfs(int y, int x)\n{\n  if (field[y][x] == '#') {\n    return 0;\n  }\n  \n  field[y][x] = '#';\n  int res = 1;\n  for (int k = 0; k < 4; k++) {\n    res += dfs(y + dy[k], x + dx[k]);\n  }\n\n  return res;\n}\n\nint main()\n{\n\n  while (cin >> W >> H && (W && H)) {\n\n    // pre exec\n    for (int i = 0; i <= 22; i++)\n      for (int j = 0; j < 22; j++) \n        field[i][j] = '#';\n\n    // read\n    int sx = 1, sy = 1;\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == '@') {\n          sx = j; sy = i;\n          field[i][j] = '*';\n        }\n      }\n    }\n\n    // depth first search\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dfs(char tebl[][20],int y,int x,int h,int w,int ans){\n\ttebl[y][x]='$';\n\tif(y>0&&tebl[y-1][x]=='.'){//up\n\t\tans=max(ans,dfs(tebl,y-1,x,h,w,ans+1));\n\t}\n\tif(y<h&&tebl[y+1][x]=='.'){//down\n\t\tans=max(ans,dfs(tebl,y+1,x,h,w,ans+1));\n\t}\n\tif(x>0&&tebl[y][x-1]=='.'){//left\n\t\tans=max(ans,dfs(tebl,y,x-1,h,w,ans+1));\n\t}\n\tif(x<w&&tebl[y][x+1]=='.'){//right\n\t\tans=max(ans,dfs(tebl,y,x+1,h,w,ans+1));\n\t}\n\treturn ans;\n}\n\t\n\n\n\n\nint main(){\n\twhile(true){\n\t\tchar tebl[20][20]={};\n\t\tint w,h,sy,sx;\n\t\tcin>>w>>h;\n\t\tif(w==0||h==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int n=0;n<h;n++){\n\t\t\tfor(int m=0;m<w;m++){\n\t\t\t\tcin>>tebl[n][m];\n\t\t\t\tif(tebl[n][m]=='@'){\n\t\t\t\t\tsy=n;\n\t\t\t\t\tsx=m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(tebl,sy,sx,h-1,w-1,1)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint w, h;\nchar ch[50][50];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nint bfs(int y, int x) {\n    int res = 0;\n    rep(i, 4) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 > ny or 0 > nx or ny >= h or nx >= w) continue;\n        if (ch[ny][nx] == '.') {\n            ch[ny][nx] = 'a';\n            res += bfs(ny, nx) + 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> w >> h and (w or h)) {\n        int py = 0, px = 0;\n        rep(i, h) rep(j, w) {\n            cin >> ch[i][j];\n            if (ch[i][j] == '@') {\n                py = i, px = j;\n                ch[i][j] = 'a';\n            }\n        }\n        cout << bfs(py, px) + 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstruct P {\n  int x, y;\n  P(int x, int y) : x(x), y(y) { }\n};\n\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nint main() {\n  for(int W, H; cin >> W >> H && W; ) {\n    vector<string> M;\n    queue<P> que;\n\n    for(int y = 0; y < H; y++) {\n      string line;\n      cin >> line;\n\n      M.push_back(line);\n\n      for(int x = 0; x < W; x++) {\n        if(M[y][x] == '@') {\n          que.push(P(x, y));\n        }\n      }\n    }\n\n    int answer = 0;\n    for(; !que.empty(); que.pop()) {\n      P p = que.front();\n      answer++;\n\n      for(int i = 0; i < 4; i++) {\n        int nx = p.x + dx[i], ny = p.y + dy[i];\n\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && M[ny][nx] == '.') {\n          M[ny][nx] = '#';\n          que.push(P(nx, ny));\n        }\n      }\n    }\n\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define MOD 1000000007\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nchar map[20][20]={0};\nint number=1;\nint h,w;\n\nvoid debug(void) {\n\tfor(int i=0;i<h;i++) { for(int j=0;j<w;j++) putchar(map[i][j]); putchar('\\n'); }\n}\n\nvoid trace(int x,int y) {\n\tif(x-1 >= 0 && map[y][x-1]=='.') {\n\t\tmap[y][x-1] = '@';\n\t\ttrace(x-1,y);\n\n\t\tnumber++;\n\t}\n\n\tif(x+1 < w && map[y][x+1]=='.') {\n\t\tmap[y][x+1] = '@';\n\t\ttrace(x+1,y);\n\t\tnumber++;\n\t}\n\tif(y-1 >= 0 && map[y-1][x]=='.') {\n\t\tmap[y-1][x] = '@';\n\t\ttrace(x,y-1);\n\t\tnumber++;\n\t}\n\n\tif(y+1 < h && map[y+1][x]=='.') {\n\t\tmap[y+1][x] = '@';\n\t\ttrace(x,y+1);\n\t\tnumber++;\n\t}\n}\n\nint main(void) {\n\tchar buf[21];\n\n\tint x,y;\n\n\n\tfor(;;) {\n\n\t\tnumber=1;\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\n\t\tif(w==0 || h==0) break;\n\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfgets(buf,1024,stdin);\n\n\t\t\tmemcpy(&map[i],buf,w);\n\t\t}\n\n\n\t\tfor(int j=0;j<h;j++) {\n\t\t\tfor(int i=0;i<w;i++) {\n\t\t\t\tif(map[j][i] == '@'){\n\t\t\t\t\tx=i;y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\ttrace(x,y);\n\n\t\tprintf(\"%d\\n\",number);\n\n\t}\n\n\t//debug();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[22][22] = {} ;\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n/*\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n*/\t\t\tprintf(\"\\n\");\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nusing namespace std;\n\nint w, h;\nstring f[20];\nint cnt;\n\nint dx[] = {-1,  1,  0 , 0};\nint dy[] = { 0,  0, -1,  1};\n\nvoid rec(int x, int y) {\n  f[y][x] = '#';\n  cnt++;\n\n  for (int i=0; i<4; i++) {\n    int mx = x + dx[i];\n    int my = y + dy[i];\n\n    if (mx < 0 || w <= mx) { continue; }\n    if (my < 0 || h <= my) { continue; }\n    if (f[my][mx] != '.') { continue; }\n\n    rec(mx, my);\n  }\n}\n\nint main() {\n  while (cin >> w >> h, (w||h)) {\n    for (int i=0; i<h; i++) {\n      cin >> f[i];\n    }\n\n    cnt = 0;\n    for (int y=0; y<h; y++) {\n      for (int x=0; x<w; x++) {\n        if (f[y][x] == '@') { rec(x, y); }\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nint w,h;\nint ans=1;\nchar tile[21][21];\n\nvoid saiki(int x,int y){\n\tif(x<0 | x>h | y<0 | y>w)return;\n\ttile[x][y]='#';\n\tif(tile[x-1][y]=='.')ans++,saiki(x-1,y);\n\tif(tile[x+1][y]=='.')ans++,saiki(x+1,y);\n\tif(tile[x][y-1]=='.')ans++,saiki(x,y-1);\n\tif(tile[x][y+1]=='.')ans++,saiki(x,y+1);\n}\n\nint main(void){\n\tint a,b; \n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tans=1;\n\t\tfor(a=0;a<h;a++){\n\t\t\tscanf(\"%s\",tile[a]);\n\t\t}\n\t\tfor(a=0;a<h;a++){\n\t\t\tfor(b=0;b<w;b++){\n\t\t\t\tif(tile[a][b]=='@')saiki(a,b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h,ret;\nchar mp[20][20];\n\nvoid rec(int y,int x){\n\tif(mp[y][x]=='#')return;\n\tret++;\n\tmp[y][x]='#';\n\tif(x+1<w)rec(y,x+1);\n\tif(y+1<h)rec(y+1,x);\n\tif(x-1>=0)rec(y,x-1);\n\tif(y-1>=0)rec(y-1,x);\n}\n\nint main(){\n\tint x,y;\n\twhile(cin >> w >> h && w && h){\n\t\tret = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> mp[i][j];\n\t\t\t\tif(mp[i][j]=='@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trec(y,x);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nstruct aa {\n\tint y;\n\tint x;\n\tbool black;\n};\n\nint main() {\n\twhile (1) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (!w)break;\n\t\tvector<vector<int>>field(h + 2, vector<int>(w + 2, 0));\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i + 1][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsx = j + 1;\n\t\t\t\t\t\tsy = i + 1;\n\t\t\t\t\t\tfield[i + 1][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<aa>que;\n\t\tque.push_back(aa{ sy, sx, true });\n\t\tint ans = 1;\n\t\tvector<vector<bool>>used(h + 2, vector<bool>(w + 2, false));\n\t\tused[sy][sx] = true;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.back());\n\t\t\tque.pop_back();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tif (atop.black) {\n\t\t\t\t\tif (field[ny][nx] == 1) {\n\t\t\t\t\t\tif (!used[ny][nx]) {\n\t\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\tque.push_back(aa{ ny,nx,!atop.black });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[ny][nx] == 1) {\n\t\t\t\t\t\tif (!used[ny][nx]) {\n\t\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\tque.push_back(aa{ ny,nx,!atop.black });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\nvoid solve()\n{\n\tint W, H;\n\twhile(cin >> W >> H, W || H)\n\t{\n\t\tvector< vector<char> > field(H);\n\t\tfor(int i = 0; i < field.size(); ++i)\n\t\t{\n\t\t\tfield[i].resize(W);\n\t\t}\n\t\tqueue<P> Que;\n\t\tfor(int i = 0; i < field.size(); ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < field[i].size(); ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = j;\n\t\t\t\t\tp.second = i;\n\t\t\t\t\tQue.push(p);\n\t\t\t\t\tfield[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 1;\n\t\twhile(!Que.empty())\n\t\t{\n\t\t\tP p = Que.front();\n\t\t\tQue.pop();\n\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tP np;\n\t\t\t\tnp.first = p.first + dx[i];\n\t\t\t\tnp.second = p.second + dy[i];\n\t\t\t\tif((0 <= np.first && np.first < W) && (0 <= np.second && np.second < H) && field[np.second][np.first] == '.')\n\t\t\t\t{\n\t\t\t\t\tQue.push(np);\n\t\t\t\t\tfield[np.second][np.first] = '#';\n\t\t\t\t\t++count;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include <string>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\n\n\nvoid dfs(int y,int x){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif(t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(y+dy[k],x+dx[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\n\tint w,h,sx,sy,cnt;\n\trep(i,20)rep(j,21){\nt[i][j]=='#';\t\n\t}\n\nwhile(true){\nscanf(\"%d %d\",&w,&h);\nif(!w&&!h) return 0;\nfor(int i=1;i<=h;i++)\n{\ncin >> t[i];\n}\t\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\ndfs(sy,sx);\ncnt =0;\n\nrep(i,h){\n\tcout << t[i]<<endl;\n\trep(j,w)if(t[i][j]=='@') cnt++;\t\n}\n\ncout <<cnt<< endl;;\n\n\n}\n\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h;\nstring inp[21];\n\nconst int MAX=23;\nint room[MAX][MAX];\nint cnt;\n\nvoid init(){\n    int i, j;\n    for(i=0; i<MAX; i++){\n        for(j=0; j<MAX; j++){\n            room[i][j]=0;\n        }\n    }\n    cnt = 0;\n}\n\nvoid dfs(int x, int y){\n    cnt++;\n    room[x][y]=0;\n    if(room[x+1][y]){\n        dfs(x+1,y);\n    }\n    if(room[x-1][y]){\n        dfs(x-1,y);\n    }\n    if(room[x][y+1]){\n        dfs(x,y+1);\n    }\n    if(room[x][y-1]){\n        dfs(x,y-1);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    \n    while(1){\n        cin >> w >> h;\n        \n        if(w==0 && h==0)\n            break;\n        \n        int i, j;\n        int x=0, y=0;\n        for(i=1; i<=h; i++){\n            cin >> inp[i];\n            for(j=0; j<w; j++){\n                switch(inp[i][j]){\n                    case '.':\n                        room[j+1][i]=1;\n                        break;\n                    case '#':\n                        room[j+1][i]=0;\n                        break;\n                    case '@':\n                        room[j+1][i]=1;\n                        x=j+1;\n                        y=i;\n                        break;\n                }\n            }\n        }\n        \n        dfs(x, y);\n        cout << cnt << endl;\n        \n        init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint W, H;\nchar visit[21][21];\nint sum;\nint  dfs(int w, int h){\n    int sum = 0;\n    if(0<=w && w<W && 0<=h && h<H){\n    if(visit[w][h]=='.'){\n        visit[w][h] = '!';\n        return 1;\n    }\n    sum += dfs(w+1, h);\n    sum +=dfs(w-1, h);\n    sum +=dfs(w, h+1);\n    sum +=dfs(w, h-1);\n    return sum;\n    }\n    return sum;\n}\n\nint main(void){\n    string str;\n    while(cin >> W >> H){\n        if(W == 0 && H == 0)    break;\n        for(int i=0; i<H; i++){\n            cin >> str;\n            for(int j=0; j<W; j++){\n                visit[i][j] = str[j];\n                if(visit[i][j] == '@')\n                    dfs(i, j);\n            }\n        }\n        cout << sum <<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nstring s[22];\nint cnt;\nvoid dfs(int x, int y){\n\tcnt++;\n\ts[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif(s[ x+dx[i] ][ y+dy[i] ]!='#') dfs(x+dx[i],y+dy[i]);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint w,h,sx,sy;\n\t\tcnt=0;\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tcin >> s[i];\n\t\t\ts[i]=\"#\"+s[i]+\"#\";\n\t\t}\n\t\ts[0]=\"\";\n\t\ts[h+1]=\"\";\n\t\ts[0].append(w+2,'#');\n\t\ts[h+1].append(w+2,'#');\n\t\tfor(int i=1;i<h+1;i++){\n\t\t\tfor(int j=1;j<w+1;j++){\n\t\t\t\tif(s[i][j]=='@'){sx=i;sy=j;}\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0 ,-1};\n\ntypedef pair<int,int> P;\n\nint bfs(int, int, int, int, char **);\n\nint main()\n{\n\tint w, h, sx, sy;\n\tchar **map;\n\n\twhile( cin >> w >> h && w > 0)\n\t{\n\t\tfflush(stdin);\n\n\t\tmap = new char *[h];\n\t\tfor(int f1 = 0; f1 < h; f1++)\n\t\t{\n\t\t\tmap[f1] = new char [w+1];\n\t\t\tscanf(\"%s\",map[f1]);\n\t\t\tfor(int f2 = 0; f2 < w; f2++)\n\t\t\t{\n\t\t\t\tif(map[f1][f2] == '@')\n\t\t\t\t{\n\t\t\t\t\tsx = f2;\n\t\t\t\t\tsy = f1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(w, h, sx, sy, map) << endl;\n\t}\n\n\treturn 0;\n}\n\nint bfs(int w, int h, int sx, int sy, char **map)\n{\n\tint px, py, cnt = 1;\n\n\tqueue<P> que;\n\tque.push(P(sy,sx));\n\twhile(!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\tfor(int f1 = 0; f1 < 4; f1++)\n\t\t{\n\t\t\tpy = p.first + dy[f1];\n\t\t\tpx = p.second + dx[f1];\n\t\t\tif(px >= 0 && px < w && py >= 0 && py < h && map[py][px] == '.')\n\t\t\t{\n\t\t\t\tque.push(P(py,px));\n\t\t\t\tmap[py][px] = '#';\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\n\nint main(){\n    std::vector<int> row;\n    int prev_col, width, height, max = 0, last = 0;\n    bool connect_prev_row;\n    \n    while(true){\n        std::cin >> width >> height;\n        if( width == 0 && height == 0 ) break;\n        row.resize(width+1);\n        for( int i = 0; i <= width; i++ ) row[i] = 0;\n\n        std::string line;\n        for( int h = 0; h < height; h++ ){\n            std::cin >> line;\n            connect_prev_row = false;\n            for(std::string::size_type i = 0; i < line.size(); i++ ){\n                if( line[i] == '.' ){\n                    if( connect_prev_row ){\n                        if( row[i] > 0 ) row[i+1] = row[i] + 1;\n                        else row[i+1] = row[i] - 1;\n                    } else {\n                        connect_prev_row = true;\n                        if( row[i] <= 0 && row[i+1] <= 0 ) row[i+1] = row[i+1] + row[i] - 1;\n                        else row[i+1] = std::abs(row[i+1]) + std::abs(row[i]) + 1;\n                    }\n                } else if( line[i] == '@' ) {\n                    if ( connect_prev_row ) row[i+1] = - row[i] + 1;\n                    else {\n                        connect_prev_row = true;\n                        row[i+1] = - row[i+1] - row[i] + 1;\n                    }\n                } else {\n                    row[i+1] = 0;\n                    connect_prev_row = false;\n                }\n                max = max > row[i+1] ? max : row[i+1];\n            }\n            last = 0;\n            for( int i = line.size(); i > 0; i-- ) {\n                if( row[i] == 0 ) last = 0;\n                else if( row[i] > 0 ){\n                    if(  last == 0 ) last = row[i];\n                    else row[i] = last;\n                } else {\n                    if(  last == 0 ) last = row[i];\n                    else row[i] = last;\n                } \n            }\n        }\n            \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint width, depth;\nint s_w, s_d;\nbool is_visit[20 + 2][20 + 2];\nchar field[20 + 2][20 + 2];\nint t_x[4] = {1, 0, -1, 0};\nint t_y[4] = {0, -1, 0, 1};\n\n\nint search(int w, int d)\n{\n  //  printf(\"(%d, %d)\\n\", w, d);\n  if (is_visit[d][w]) return 0;\n  if (field[d][w] == '#') return 0;\n  is_visit[d][w] = true;\n  int sum = 0;\n  for (int i = 0; i < 4; i++) {\n    sum += search(w + t_x[i], d + t_y[i]);\n  }\n  return sum + 1;\n}\n\nint main()\n{\n  while (scanf(\"%d %d \", &width, &depth) == 2) {\n    if (width == 0 && depth == 0) {\n      break;\n    }\n    for (int i = 0; i < 22; i++) {\n      fill(is_visit[i], &is_visit[i][22], false);\n      fill(field[i], &field[i][22], '#');\n    }\n    for (int i = 1; i <= depth; i++) {\n      for (int j = 1; j <= width; j++) {\n\tscanf(\"%c \", &field[i][j]);\n\tif (field[i][j] == '@') {\n\t  s_w = j, s_d = i;\n\t}\n\t//\tprintf(\"%c\", field[i][j]);\n      }\n      //      printf(\"\\n\");\n    }\n    \n    printf(\"%d\\n\", search(s_w, s_d));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_N 50\n#define MAX_R 50\n\n#define MAX_W 20\n#define MAX_H 20\n\nint W, H;\nint ans;\nchar maze[MAX_W][MAX_H];\n\nvoid dfs(int sx, int sy){\n\t\n\tmaze[sy][sx] = '#';\n\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H && maze[ny][nx] != '#'){\n\t\t\tans++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile (true){\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint sx;\n\t\tint sy;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tdfs(sx,sy);\n\t\tcout << ans << endl;\n\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//bool c[22][22] = {};\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n/*\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n*/\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n//\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n//\t\t\t\tcase '.':\n//\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t//if (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t\t/*if (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\tprintf(\"a\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h, ans;\nchar map[20][20];\n\nvoid ex(int x, int y) {\n  if(x < 0 || y < 0 || x >= w || y >= h) return;\n  if(map[x][y] == '#') return;\n\n  if(map[x][y] == '@' || map[x][y] == '.') {\n    map[x][y] = ':';\n    ans ++;\n  }\n  else {\n    return;\n  }\n  \n  ex(x-1, y);\n  ex(x+1, y);\n  ex(x, y-1);\n  ex(x, y+1);\n  \n  return;\n}\n\nint main() {\n  while(cin >> w >> h) {\n    if(w == 0 && h == 0) break;\n    char tmp;\n    int s[2];\n    for(int j = 0; j < h; j ++) {\n      for(int i = 0; i < w; i ++) {\n\tcin >> tmp;\n\tmap[i][j] = tmp;\n\tif(tmp == '@') {\n\t  s[0] = i;\n\t  s[1] = j;\n\t}\n      }\n    }\n    \n    ans = 0;\n    //cout << s[0] << s[1] << endl;\n    ex(s[0], s[1]);\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 1130: Red and Black */\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define MAX_W 20\n#define MAX_H 20\n\nusing namespace std;\n\n/* 隣接タイルへの移動用配列 */\nint move[4][2] = {{1,0},{0,-1},{-1,0},{0,1}};\nchar tiles[MAX_H][MAX_W]; /* タイルの並びを入れる配列 */\nint w,h; /* 床の幅、高さ */\nint sum; /* 移動可能なタイル数 */\n\nint i,j,k,l,m,n;\n\nint dfs(int y, int x) {\n\n//  rep(i,h){ rep(j,w) cout << tiles[i][j]; cout << endl; } cout << endl;\n\tfor(int i=0; i<4; i++) {\n\t\tint nx = x+move[i][0], ny = y+move[i][1];\n\t\t\n\t\tif(\n\t\t\t/* 床の範囲内で */\n\t\t\t0<=nx&&nx<w &&\n\t\t\t0<=ny&&ny<h &&\n\t\t\t/* 黒いタイルだったら */\n\t\t\ttiles[ny][nx] == '.'\n\t\t) {\n\t\t\t/* 二重カウントしないよう予め書き換え */\n\t\t\ttiles[ny][nx] = '#';\n\t\t\tsum++;\n\t\t\tdfs(ny,nx);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\t\n\tint yy,xx;\n\t\n\twhile(1) {\n\t\t\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tfor(int i=0; i<h; i++) {\n\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\tcin >> tiles[i][j];\n\t\t\t}\n\t\t}\n\n//    rep(i,h){ rep(j,w) cout << tiles[i][j]; cout << endl; } cout << endl;\n//    cout << \"before xx \" << xx << endl;\n//    cout << \"before yy \" << yy << endl;\n\t\t\n\t\t/* @の位置を探す */\n\t\tfor(yy=0; yy<h; yy++) {\n//      cout << 'a' << endl;\n\t\t\tfor(xx=0; xx<w; xx++) {\n//        cout << 'b' << endl;\n\t\t\t\tif(tiles[yy][xx] == '@') break;\n\t\t\t}\n//      cout << \"yy \" << yy << \"xx \" << xx << \"tile \" << tiles[yy][xx] << endl;\n\t\t\tif(0 <= yy && yy < h && 0 <= xx && xx < w && tiles[yy][xx] == '@') break;\n\t\t}\n\n//    cout << \"xx \" << xx << endl;\n//    cout << \"yy \" << yy << endl;\n\t\t\n\t\tsum = 1;\n\t\tdfs(yy,xx);\n\t\t\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nvoid dfs(int, int);\nint limx,limy,cnt=0,ni,nj;\nchar data[21][21];\n\nint main(){\n  int i,j;\n  while(1){\n    scanf(\"%d%d\",&limx,&limy);\n    if(limx==0 && limy==0)\n      break;\n    for(i=0;i<limy;i++)\n      scanf(\"%s\",data[i]);\n\n    for(i=0;i<limy;i++)\n      for(j=0;j<limx;j++)\n\tif(data[i][j]=='@') ni=i,nj=j;\n    dfs(ni,nj);\n    printf(\"%d\\n\",cnt);\n    cnt=0;\n  }\n  return 0;\n}\n\nvoid dfs(int i, int j){\n  int di[4]={0,-1,0,1};\n  int dj[4]={1,0,-1,0};\n\n  data[i][j]='#';\n  cnt++;\n  for(int r=0;r<4;r++){\n    ni=i+di[r];\n    nj=j+dj[r];\n    if(data[ni][nj]=='.' && ni >= 0 && ni < limy && nj >= 0 && nj < limx) \n      dfs(ni,nj);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main {\n\tstatic int w,h,sx,sy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};\n\tstatic String[] field;\n\tstatic boolean[][] visited;\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0 && h == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfield = new String[h];\n\t\t\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfield[i] = sc.next();\n\t\t\tint tmp = field[i].indexOf('@');\n\t\t\tif(tmp != -1) {\n\t\t\t\tsy = i; sx = tmp;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tvisited = new boolean[h][w];\n\t\tQueue<Point> que = new LinkedList<Point>();\n\t\tPoint s = new Point(sx, sy);\n\t\t\n\t\tque.add(s);\n\t\tvisited[sy][sx] = true;\n\t\tint ans = 1;\n\t\twhile(!que.isEmpty()) {\n\t\t\tPoint p = que.poll();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tPoint next = new Point(p.x + dx[i], p.y + dy[i]);\n\t\t\t\tif(!inField(next) || field[next.y].charAt(next.x) == '#' || visited[next.y][next.x] == true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tque.add(next);\n\t\t\t\t\tvisited[next.y][next.x] = true;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic boolean inField(Point p) {\n\t\tif(p.x >= 0 && p.x < w && p.y >= 0 && p.y < h) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint w, h;\nchar tiles[20][21];\n\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n\nbool isRegion(int x, int y){\n    return x >= 0 && x < w && y >= 0 && y < h;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> tiles[i];\n            \n            auto j = find(tiles[i], tiles[i]+w, '@');\n            if(j != tiles[i] + w){\n                sx = j - tiles[i]; sy = i;\n            }\n        }\n        \n        int cnt = 0;\n        queue<pair<int, int> > q;\n        q.push(make_pair(sx, sy));\n        while(!q.empty()){\n            cnt++;\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            \n            for(int i = 0; i < 4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                \n                if(isRegion(nx, ny) && tiles[ny][nx] == '.'){\n                    tiles[ny][nx] = '#';\n                    q.push(make_pair(nx, ny));\n                }\n            }\n        }\n        cout << cnt << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 180; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 500\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; i++){\n      cin >> line;\n      for(int j=0; j < width ; j++){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 300; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width; j++){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width;j++){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; i++){\n    for(int j=0; j < width ; j++){\n      cout << setw(3)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    //cout << isValidPoint(x+dx,y+dy) << \" \" << x+dx << y+dy << endl;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      //cout << isValidPoint(x+dx,y+dy) << \" \" << x+dx << y+dy << endl;\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >=  width || y < 0 || y >= height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint tile[22][22];\nint sum;\n\nvoid search(int w,int h)\n{\n  if(tile[w][h]){\n    tile[w][h]=0; sum++;\n    search(w,h-1);\n    search(w-1,h);\n    search(w+1,h);\n    search(w,h+1);\n  }\n}\n\nint main()\n{\n  int w,h,i,j,sx,sy;\n  char c;\n  \n  for(;;){\n    cin>>w>>h;\n    if(!(w|h)) break;\n\n    sum=0;\n    for(i=0;i<22;i++)\n      for(j=0;j<22;j++)\n\ttile[i][j]=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>c;\n\tif(c=='#') tile[j][i]=0;\n\telse if(c=='.') tile[j][i]=1;\n\telse if(c=='@'){\n\t  tile[j][i]=1; sx=j; sy=i;\n\t}\n      }\n    }\n    search(sx,sy);\n    cout<<sum<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nchar graph[20][20];\nint cou = 0;\nint W,H;\n\nvoid bfs(int a1,int a2){\n  queue<int> Q;\n  int u1,u2;\n  Q.push(a1);\n  Q.push(a2);\n\n  while(!Q.empty()){\n\n    u1 = Q.front();Q.pop();\n    u2 = Q.front();Q.pop();\n\n    if(graph[u1+1][u2] == '.'){\n      graph[u1+1][u2] = 'N';\n      cou++;\n      Q.push(u1+1);Q.push(u2);\n    }\n\n    if(graph[u1][u2+1] == '.'){\n      graph[u1][u2+1] = 'N';\n      cou++;\n      Q.push(u1);Q.push(u2+1);\n    }\n\n    if(graph[u1-1][u2] == '.'){\n      graph[u1-1][u2] = 'N';\n      cou++;\n      Q.push(u1-1);Q.push(u2);\n    }\n\n    if(graph[u1][u2-1] == '.'){\n      graph[u1][u2-1] = 'N';\n      cou++;\n      Q.push(u1);Q.push(u2-1);\n    }\n    /*\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcout << graph[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n}\n\n\nint main(){\n\n  int a1,a2;\n\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    bfs(a1,a2);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 0;\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = { 0, 0,-1, 0};\n\nvoid dfs(int x, int y) {\n    num++;\n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    for (int i = 0; i < 4; i++) {\n        int mx = x + dx[i];\n        int my = y + dy[i];\n        \n        if (mx < 0 || w <= mx) continue;\n        if (my < 0 || h <= my) continue;\n        if (room[my][mx] == 0) continue;\n        dfs(mx, my);\n    }\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\n\nint h, w;\nint sx, sy;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nbool used[21][21];\nint color[21][21];\n\nvoid dfs(int x, int y){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && !used[nx][ny] && color[nx][ny] == 1){\n\t\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\t\tdfs(nx, ny);\n\t\t\t\t}\n\t\t}\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile(true){\n\t\t\tcin >> w >> h;\n\t\t\tif(w == 0)break;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tstring s;\n\t\t\t\t\tcin >> s;\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\t\tif(s[j] == '.' || s[j] == '@')color[i][j] = 1;\n\t\t\t\t\t\t\telse color[i][j] = -1;\n\t\t\t\t\t\t\tif(s[j] == '@'){\n\t\t\t\t\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused[i][j] = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx, sy);\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\t\tif(used[i][j] == 1)res++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct locate{\n  int x;\n  int y;\n};\n \nchar graph[20][20];\nint cou = 0;\nint H,W;\n\nvoid bfs(locate z){\n  queue<locate> Q;\n  locate u;\n  locate v;\n  Q.push(z);\n \n\n  while(!Q.empty()){\n\n    u = Q.front();Q.pop();\n    if(u.y < H - 1){\n      if(graph[u.y + 1][u.x] == '.' && graph[u.y + 1][u.x] != 'N'){\n\tgraph[u.y + 1][u.x] = 'N';\n\tcou++;\n\tv.y = u.y + 1;\n\tv.x = u.x;\n\tQ.push(v);\n      }\n    }\n    if(u.x < W - 1){\n      if(graph[u.y][u.x + 1] == '.' && graph[u.y][u.x + 1] != 'N'){\n\tgraph[u.y][u.x + 1] = 'N';\n\tcou++;\n\tv.x  = u.x + 1;\n\tv.y = u.y;\n\tQ.push(v);\n      }\n    }\n    if(u.y > 0){\n      if(graph[u.y - 1][u.x] == '.' && graph[u.y - 1][u.x] != 'N'){\n\tgraph[u.y - 1][u.x] = 'N';\n\tcou++;\n\tv.x = u.x;\n\tv.y = u.y - 1;\n\tQ.push(v);\n      }\n    }\n    if(u.x > 0){\n      if(graph[u.y][u.x - 1] == '.' && graph[u.y][u.x - 1] != 'N'){\n\tgraph[u.y][u.x - 1] = 'N';\n\tcou++;\n\tv.x = u.x - 1;\n\tv.y = u.y;\n\tQ.push(v);\n      }\n    }\n\n    /* cout << endl;\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcout << graph[i][j];\n      }\n      cout << endl;*/\n    }\n  }\n  \n}\n\nint main(){\n\n  int a1,a2;\n  locate a;\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    a.y = a1;\n    a.x = a2;\n    bfs(a);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 'N';\n      }\n    }\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring place[20];\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nint serch(int n,int m,int y,int x)\n{\n\tint ans=0;\n\tplace[y][x]='#';\n\tfor(int i=0,ax,ay;i<4;i++)if((ay=dy[i]+y)<m&&(ax=dx[i]+x)<n&&ay>=0&&ax>=0&&place[ay][ax]=='.')ans+=serch(n,m,ay,ax)+1;\n\treturn ans;\n}\nint main() {\n\tint n,m;\n\twhile(cin>>n>>m,n,m){\n\t\tfor(int i=0;i<m;i++)cin>>place[i];\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++)if(place[i][j]=='@')cout<<serch(n,m,i,j)+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <queue>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w; cin >> w >> h, w | h;){\n\t\tVVI table(h, VI(w));\n\t\tPII goal;\n\t\tREP(i, h){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tREP(j, w){\n\t\t\t\tchar letter = line[j];\n\t\t\t\tint value = 0;\n\t\t\t\tif(letter == '@'){\n\t\t\t\t\tgoal = MP(i, j);\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}else if(letter == '#'){\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}\n\t\t\t\ttable[i][j] = value;\n\t\t\t}\n\t\t}\n\t\tqueue<PII> q;\n\t\tq.push(goal);\n\t\tint total = 1;\n\t\twhile(!q.empty()){\n\t\t\tPII p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.second, y = p.first;\n\t\t\tint cv = table[y][x];\n\t\t\tREP(i, 4){\n\t\t\t\tint dx = x + DX[i];\n\t\t\t\tint dy = y + DY[i];\n\t\t\t\tif(0 <= dx && dx < w &&\n\t\t\t\t\t0 <= dy && dy < h &&\n\t\t\t\t\ttable[dy][dx] == 0){\n\t\t\t\t\ttotal++;\n\t\t\t\t\ttable[dy][dx] = 1;\n\t\t\t\t\tq.push(MP(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int> pos;\nchar map[20][20];\nconst int next[4][2] = {\n  {-1,0},{1,0},{0,-1},{0,1},\n};\nint main()\n{\n  for(;;){\n    int w,h;\n    scanf(\"%d %d\",&w,&h);\n    if(w == 0 || h == 0) break;\n    string dummy;\n    getline(cin,dummy);\n    memset(map,'.',sizeof(map));\n    pos p;\n    for(int i=0; i<h; i++){\n      string s;\n      getline(cin,s);\n      for(int j=0; j<w; j++){\n        if(s[j] == '@'){\n          p = make_pair(i,j);\n        }\n        map[i][j] = s[j];\n      }\n    }\n    set<pos> memo;\n    memo.insert(p);\n    queue<pos> q;\n    q.push(p);\n    for(;;){\n      if(q.empty()) break;\n      p = q.front(); q.pop();\n      for(int i=0; i<4; i++){\n        pos pn = make_pair(p.first+next[i][0], p.second+next[i][1]);\n        if(pn.first < 0 || pn.first >= h || pn.second < 0 || pn.second >= w ||\n           map[pn.first][pn.second] == '#'){\n          continue;\n        }\n        if(memo.insert(pn).second){\n          q.push(pn);\n        }\n      }\n    }\n    printf(\"%d\\n\", memo.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#define N 20\nusing namespace std;\n\nint main(){\n\tint w, h;\n\twhile(cin >>w >>h){\n\t\tif(w == 0 && h == 0) break;\n\t\tint cnt = 1, dxh[4] = {-1, 0, 1, 0}, dxw[4] = {0, 1, 0, -1};\n\t\tstring home[N];\n\t\tqueue<int> quh, quw;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >>home[i];\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(home[i][j] == '@'){\n\t\t\t\t\t quh.push(i);\n\t\t\t\t\t quw.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(quh.empty() != 1){\n\t\t\tint nowh = quh.front(), noww = quw.front();\n\t\t\tquh.pop();\n\t\t\tquw.pop();\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tif(nowh + dxh[i] >= h || noww + dxw[i] >= w || nowh + dxh[i] < 0 || noww + dxw[i] < 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(home[nowh + dxh[i]][noww + dxw[i]] == '.'){\n\t\t\t\t\tquh.push(nowh + dxh[i]);\n\t\t\t\t\tquw.push(noww + dxw[i]);\n\t\t\t\t\tcnt++;\n\t\t\t\t\thome[nowh + dxh[i]][noww + dxw[i]] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<cnt <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h, w_index, h_index;\n    int ans = 1;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(h);\n        for (int i = 0; i < h; i++) {\n            vec[i].resize(w);\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        for (auto it = vec.begin(); it != vec.end(); it++ ) {\n            auto iter = find(it->begin(), it->end(), '@');\n\n            if(iter!=it->end()){\n                h_index = distance( vec.begin(), it );\n                w_index = distance( it->begin(), iter );\n            }\n        }\n\n        dfs( w, h, w_index, h_index, vec, ans );\n\n        std::cout << ans << std::endl;\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[h_index][w_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[ny][nx] != '#' ){\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n\nusing namespace std;\n\nint w,h;\nchar m[22][22];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint dfs(int y , int x){\n  int rtn = 0;\n  if(y < 0 || h <= y || x < 0 || w <= x || m[y][x] =='#')\n    return rtn;\n  m[y][x] = '#';\n  rtn++;\n  rep(i,0,4){\n    rtn += dfs(y + dy[i] , x + dx[i]);\n  }\n  return rtn;\n}\n\nint main(){\n  while(cin >> w >> h , w + h){\n    int sx,sy;\n    rep(i,0,h){\n      rep(j,0,w){\n        cin >> m[i][j];\n        if(m[i][j] == '@'){\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    cout << dfs(sy , sx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n\nint w, h;\n\nint dfs(int y, int x, vector<string> &v){\n  int my[] = {0, 0, 1, -1};\n  int mx[] = {1, -1, 0, 0};\n  int ret = 1;\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < h && nx < w && v[ny][nx] == '.'){\n      v[ny][nx] = '#';\n      ret += dfs(ny, nx, v);\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >>w >>h && w){\n    vector<string> v(h);\n    REP(i, h) cin >>v[i];\n    REP(i, h) REP(j, w) if(v[i][j] == '@') cout <<dfs(i, j, v) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nint cnt, w, h;\nchar m[20][20];\n\nvoid dfs(pii);\n\nint main(void){\n    while(cin >> w >> h, w){\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n\n        dfs(p);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if((p.X < 0 || w <= p.X) ||\n       (p.Y < 0 || h <= p.Y)) return;\n\n    if(m[p.Y][p.X] == '.') cnt ++;\n    else return;\n    m[p.Y][p.X] = '#';\n\n    rep(i, 4){\n        pii next = mp(p.X + dx[i], p.Y + dy[i]);\n        dfs(next);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define MAX 30\n#define rep(i,p) for(int i=0;i<p;i++)\nusing namespace std;\nint W,H,count,yoko,tate;\nint person_now_x,person_now_y;\nchar input;\nbool masu[MAX][MAX];\nbool visit[MAX][MAX];\n// ?§???? {?????????????????????}\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nvoid dfs (int x, int y) {\n  // start : (x y)\n  visit[x][y] = true;\n  count++;\n  rep(i,4) {\n    yoko = x+dx[i];\n    tate = y+dy[i];\n    if ( masu[yoko][tate] and !visit[yoko][tate] ) dfs(yoko,tate);\n  }\n}\nint main(){\n  while(1) {\n    // W ?¨?\n    // H ???\n    cin >> W >> H;\n    if (W==0 and H==0) break;\n    // ?????????\n    count = 0;\n    rep(i,MAX) rep(j,MAX) masu[i][j] = false;\n    rep(i,MAX) rep(j,MAX) visit[i][j] = false;\n    // . true  black\n    // # false red\n    // @ true  person on black\n    // ????????????????????????????????????????????´????????????????????¨????????±???\n    for (int i=1; i<=H; i++)\n      for (int j=1; j<=W; j++) {\n        cin >> input;\n        if (input == '.') masu[i][j] = true;\n        else if (input == '#') masu[i][j] = false;\n        else {\n          person_now_x = i;\n          person_now_y = j;\n          masu[i][j] = true;\n        }\n      }\n    dfs(person_now_x,person_now_y);\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\nvector <vector<int> > randb (vector <vector<char> >tile,vector <vector<int> > canmove,int si,int sj,int w,int h);\nint main(){\n  int w,h;\n  cin >> w >> h;\n  while(w != 0 || h != 0){\n    vector <vector<char> > tile(h,vector<char>(w));\n    vector <vector<int> > canmove(h,vector<int>(w,0));\n    int si,sj;\n    int cnt = 0;\n    for(int i = 0 ; i < h ; i++){\n      for(int j = 0 ; j < w ; j++){\n        cin >> tile[i][j];\n        if(tile[i][j] == '@'){\n          canmove[i][j] = 1;\n          si = i;\n          sj = j;\n        }\n      }\n    }\n    canmove = randb(tile,canmove,si,sj,w,h);\n    for(int i = 0 ; i < h ; i++){\n      for(int j = 0 ; j < w ; j++){\n          cnt += canmove[i][j];\n        }\n      }\n      cout << cnt << endl;\n    cin >> w >> h;\n  }\n  return 0;\n}\n\n vector <vector<int> > randb (vector <vector<char> >tile,vector <vector<int> > canmove,int si,int sj,int w,int h){\n   if( si+1 < h && tile[si+1][sj] == '.'  && canmove[si+1][sj] == 0){\n     canmove[si+1][sj] = 1;\n     canmove = randb(tile,canmove,si+1,sj,w,h);\n   }\n   if( si-1 >= 0 && tile[si-1][sj] == '.'  && canmove[si-1][sj] == 0){\n     canmove[si-1][sj] = 1;\n     canmove = randb(tile,canmove,si-1,sj,w,h);\n   }\n   if( sj+1 < w && tile[si][sj+1] == '.'  && canmove[si][sj+1] == 0){\n     canmove[si][sj+1] = 1;\n     canmove = randb(tile,canmove,si,sj+1,w,h);\n   }\n   if( sj-1 >= 0 && tile[si][sj-1] == '.'  && canmove[si][sj-1] == 0){\n     canmove[si][sj-1] = 1;\n     canmove = randb(tile,canmove,si,sj-1,w,h);\n   }\n\n   return canmove;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define rrep(i,n) for(int i = n - 1; i >= 0; i--)\n#define REP(i,k,n) for(int i = k; i < n; i++)\n\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\n\nint dfs(int x,int y);\nint dx[] = {0,-1,0,1,0};\n\nint w,h;\nstring g[21];\n\nint main(){\n    while(cin >> w >> h,w) {\n        rep(i,h){\n            cin >> g[i];\n        }\n        rep(y,h) {\n            rep(x,w){\n                if(g[y][x] == '@') {\n                    int cnt = dfs(x,y);\n                    cout << cnt << endl;\n                }\n            }\n        }\n    }\n    return 0;\n\n}\n\nint dfs(int x,int y){\n    g[y][x] = '#';\n    int cnt = 1;\n    rep(i,4){\n        int nx = x + dx[i], ny = y + dx[i + 1];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && g[ny][nx] == '.') {\n            cnt += dfs(nx,ny);\n        }\n    }\n    return cnt;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\nusing namespace std;\nvoid dfs(int x, int y);\n\nint cnt = 0;\nstring data[20];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint w, h;\n\nint main()\n{\n    while(true){\n      cin >> w >> h;\n      if(w == 0 && h == 0) break;\n      \n      int sx, sy;\n      for(int i = 0 ; i < h ; i++){\n\tcin >> data[i];\n\tfor(int j = 0 ; j < w ; j++){\n\t  if(data[i][j] == '@'){\n\t    sx = j;\n\t    sy = i;\n\t  }\n\t}\n      }\n      dfs(sx, sy);\n      cout << cnt << '\\n';\n      cnt = 0;\n  }\n}\n\nvoid dfs(int x, int y)\n{\n  data[y][x] = '#';\n  cnt++;\n\n  rep(i, 4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && data[ny][nx] == '.'){\n      dfs(nx, ny);\n    }\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nvoid bfs(vector< vector<char> > &plane, int x, int y, int &ans){  \n  plane[x][y] = '#';\n  ans++;\n  for(int i=0; i<4; i++){\n    if(0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h)\n      if(plane[x + dx[i]][y + dy[i]] != '#')\n        bfs(plane, x + dx[i], y + dy[i], ans);\n  }\n  \n  return;\n}\n\nint main(){\n  while(true){\n    cin >> w >> h;\n    if(w == 0)\n      break;\n\n    int sx, sy;\n    vector< vector<char> > plane(w, vector<char>(h));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        cin >> plane[j][i];\n        if(plane[j][i] == '@'){\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n\n    int ans = 0;\n    bfs(plane, sx, sy, ans);\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long int lint;\ntypedef unsigned long long int ulint;\n\n//#define DEBUG\n\n#ifdef DEBUG\n#\tdefine dump(i) cout << \"[*] \" #i \" : \" << i << endl;\n#\tdefine debug(i) i\n#else\n#\tdefine dump(i)\n#\tdefine debug(i)\n#endif\n#define rep(i, MAX) for (int i = 0; i < (MAX); ++i)\n\nstruct UnionFind\n{\n\tvector<int> par;\n\n\tUnionFind(int n): par(n) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t}\n};\n\ninline void solve() {\n\tint w, h;\n\tconstexpr int MAX = 20;\n\tchar tile[MAX][MAX];\n\tdump(MAX);\n\n\twhile (true) {\n\t\tpair<int, int> at;\n\t\tcin >> w >> h;\n\t\tif (!w && !h) return;\n\t\tint table[MAX] = {};\n\t\tUnionFind uf = UnionFind(200);\n\n\t\tconst int asdf = MAX * MAX;\n\t\tdump(asdf);\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@') {\n\t\t\t\t\tat.first = i;\n\t\t\t\t\tat.second = j;\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint csi = 1;\n\t\tif (tile[0][0] == '.') {\n\t\t\ttile[0][0] = csi++;\n\t\t} else {\n\t\t\ttile[0][0] = 0;\n\t\t}\n\t\ttable[tile[0][0]]++;\n\t\tfor (int i = 1; i < w; ++i) {\n\t\t\tif (tile[0][i] == '.') {\n\t\t\t\ttile[0][i] = tile[0][i-1] != 0 ? tile[0][i-1] : csi++;\n\t\t\t} else {\n\t\t\t\ttile[0][i] = 0;\n\t\t\t}\n\t\t\ttable[tile[0][i]]++;\n\t\t}\n\t\trep(i, h) {\n\t\t\tif (i == 0) continue;\n\t\t\trep(j, w) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\ttile[i][j] = tile[i-1][j] != 0 ? tile[i-1][j] : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\tint tmp = tile[i-1][j];\n\t\t\t\t\t\tif (tmp == 0) {\n\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t} else if (tile[i][j-1] != 0) {\n\t\t\t\t\t\t\tuf.unite(tmp, tile[i][j-1]);\n\t\t\t\t\t\t\tif (tmp > tile[i][j-1]) {\n\t\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttile[i][j] = tmp != 0 ? tmp : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttable[tile[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint iv = tile[at.first][at.second];\n\t\trep(i, csi) {\n\t\t\tif (uf.same(iv, i)) {\n\t\t\t\tans += table[i];\n\t\t\t}\n\t\t}\n\t\tdump(\"tile\");\n\t\tdump(\"table\");\n\t\tdump(\"ans\");\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\t//*\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\t// */\n#ifdef DEBUG\n\tconst auto start = chrono::high_resolution_clock::now();\n#endif\n\tsolve();\n#ifdef DEBUG\n\tconst auto stop = chrono::high_resolution_clock::now();\n\tcerr << \"[*] time: \" << chrono::duration_cast<chrono::milliseconds>(stop-start).count()\n\t\t<< \" [ms]\" << endl;\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int mp[21][21];\n  int w,h;\n  int x[4]={1,-1,0,0};\n  int y[4]={0,0,1,-1};\n  int m;\n  bool b;\n  char s;\n  int ans;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    ans=0;\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\tmp[i][j]=0;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>s;\n\tif(s=='#') mp[i][j]=1;\n\telse if(s=='@') mp[i][j]=2;\n      }\n    }\n    b=true;\n    while(b){\n      b=false;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(mp[i][j]==2){\n\t    /*for(int k=0;k<4;k++){*/\n\t      if(mp[i+1][j]==0){\n\t\tmp[i+1][j]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i-1][j]==0){\n\t\tmp[i-1][j]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i][j+1]==0){\n\t\tmp[i][j+1]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i][j-1]==0){\n\t\tmp[i][j-1]=2;\n\t\tb=true;\n\t      }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\t/*cout<<mp[i][j]<<\" \";*/\n\tif(mp[i][j]==2) ans++;\n      }\n      /* cout<<endl;*/\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n  \n    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint w, h;\nstruct xydata {\n    int x, y;\n};\n\nint main() {\n    while(1) {\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        int sx, sy;\n        vector< vector<char> > tile(h, vector<char>(w, '.'));\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                cin >> tile[i][j];\n                if(tile[i][j] == '@') {\n                    sx = j; sy = i;\n                }\n            }\n        }\n        vector< vector<char> > ntile = tile;\n        queue<xydata> que;\n        xydata first; first.x = sx; first.y = sy;\n        que.push(first);\n        ntile[sy][sx] = '#';\n        while(!que.empty()) {\n            xydata now = que.front();\n            que.pop();\n            for(int i = 0; i < 4; ++i) {\n                int nx = now.x+dx[i], ny = now.y+dy[i];\n                if(nx >= 0 && nx < w && ny >= 0 && ny < h) {\n                    if(ntile[ny][nx] == '.') {\n                        xydata next;\n                        next.x = nx, next.y = ny;\n                        que.push(next);\n                        ntile[ny][nx] = '#';\n                    }\n                }\n            }\n        }\n\n        int cnt = 0;\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                if(tile[i][j] == '.' || tile[i][j] == '@') {\n                    if(ntile[i][j] == '#') cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nchar ma[30][30];\nint b[30][30];\nint cnt;\nint dfs(int sy,int sx){\n    for(int i=0;i<4;i++){\n        int ny=sy+dy[i],nx=sx+dx[i];\n        if(ny < 0 || ny > h - 1 || nx < 0 || nx > w - 1 || b[ny][nx]==1 || ma[ny][nx]=='#'){continue;}\n        b[ny][nx]=1;\n        cnt++;\n        dfs(ny,nx);\n    }\n    return cnt;\n}\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0 && h==0){\n            break;\n        }\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>ma[i][j];\n                if(ma[i][j]=='@'){\n                    sy=i;\n                    sx=j;\n                }\n            }\n        }\n        cnt=1;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                b[i][j]=0;\n            }\n        }\n        b[sy][sx]=1;\n        cout<<dfs(sy,sx)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint xs[] = {0, 1, 0, -1}, ys[] = {1, 0, -1, 0};\nchar c[108][108];\nint w, h;\nbool come[108][108];\nint dfs(int x, int y){\n\tif(x < 0 || y < 0 || x >= h || y >= w)return 0;\n\tif(c[x][y] == '#')return 0;\n\tif(come[x][y])return 0;\n\tcome[x][y] = true;\n\tint res = 1;\n\tfor(int i = 0;i < 4;i++){\n\t\tres += dfs(x + xs[i], y + ys[i]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint si, sj;\n\twhile(cin >> w >> h, w | h){\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == '@'){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}\n\t\t\t\tcome[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(si, sj) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nchar t[20][20];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ans,h,w;\nqueue<P> q;\n\nint bfs(int x, int y){\n\n  q.push( P(x, y) );\n  \n  while( !q.empty() ){\n    P now = q.front();\n    q.pop();\n    for( int i = 0 ; i < 4 ; i++ ){\n      int nx = now.first + dx[i];\n      int ny = now.second + dy[i];\n      if( 0 <= nx && nx < w && 0 <= ny && ny <= h \n\t  && t[ny][nx] == '.' ){\n\tt[ny][nx] = '#';\n\tq.push( P(nx, ny) );\n\tans++;\n      }\n    }\n  }\n  return ans;\n}\n\nint main(void){\n\n  int x,y;\n  while( cin >> w >> h, h + w ){\n\n    memset( t, 0, sizeof(t) );\n    ans = 1;\n\n    for( int i = 0 ; i < h ; i++ ){\n      for( int j = 0 ; j < w ; j++ ){\n\tcin >> t[i][j];\n\tif( t[i][j] == '@' ){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n    cout << bfs(x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntemplate<typename A,typename B> inline void chmin(A &a,B b){if(a>b) a=b;}\ntemplate<typename A,typename B> inline void chmax(A &a,B b){if(a<b) a=b;}\n\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n//-----------------------------------------------------------------------\n\nint w,h;\nchar M[25][25];\nint cnt;\n\nvoid dfs(int y,int x)\n{\n    M[y][x]='#';\n    cnt++;\n    REP(i,4){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(0<=ny && ny<h && 0<=nx && nx<w && M[ny][nx]=='.') dfs(ny,nx);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>w>>h,w|h)\n    {\n        REP(i,h) cin>>M[i];\n        REP(i,h) REP(j,w){\n            if(M[i][j]=='@'){\n                cnt=0; dfs(i,j);\n                cout<<cnt<<endl;\n                i=h,j=w;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nchar ban[21][21];\nint cont = 0;\n\n\tint w, h;\n\t\n\tint MAX = 0;\n\nvoid saiki(int y, int x)\n{\n\tcont++;\n\tban[y][x] = '_';\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcout << ban[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << w << h << endl;\n\t\n\tgetchar();\n\t\n\tcout << cont << endl;;\n\t*/\n\t\n\tif(ban[y+1][x] == '.' && y+1 < h){\n\t\tsaiki(y+1,x);\n\t}\n\tif(ban[y-1][x] == '.' && y-1 > -1){\n\t\tsaiki(y-1,x);\n\t} \n\tif(ban[y][x-1] == '.' && x-1 > -1){\n\t\tsaiki(y,x-1);\n\t}\n\tif(ban[y][x+1] == '.' && x+1 < w){\n\t\tsaiki(y,x+1);\n\t}\n\t\n\tif(cont > MAX){\n\t\tMAX = cont;\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint st_x, st_y;\n\t\tMAX = cont = 0;\n\t\t\n\t\tcin >> w >> h;\n\t\t\n\t\tif( w == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tban[i][j] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> ban[i][j];\n\t\t\t\tif(ban[i][j] == '@'){\n\t\t\t\t\tst_x = j;\n\t\t\t\t\tst_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tsaiki(st_y,st_x);\n\t\t\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w, h;\nchar tile[20][20];\nint cnt = 0;\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nvoid f(int x, int y){\n\ttile[x][y] = '#';\n\tcnt++;\n\tfor (int i = 0; i < 4; i++){\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (tile[X][Y] == '.' && 0 <= x && x < w && 0 <= y && y < h){\n\t\t\tf(X, Y);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile (cin >> w >> h, w + h != 0){\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tcin >> tile[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (tile[x][y] == '@') f(x, y);\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int W, int H) {\n    vector<vector<char>> field(H + 2, vector<char>(W + 2, '#'));\n    vector<vector<int>> cnt(H + 2, vector<int>(W + 2, 0));\n    pair<int, int> p;\n    queue<pair<int, int>> Q;\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == '@') {\n                Q.push(make_pair(i, j));\n                cnt[i][j] = 1;\n            }\n        }\n    }\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0, 1, -1};\n    while (!Q.empty()) {\n        p = Q.front();\n        Q.pop();\n        for (int i = 0; i < 4; i++) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            if (field[ny][nx] == '#') continue;\n            if (cnt[ny][nx] == 1) continue;\n            Q.push(make_pair(ny, nx));\n            cnt[ny][nx] = 1;\n        }\n    }\n    int ret = 0;\n    for (int i = 0; i < cnt.size(); i++) {\n        for (int j = 0; j < cnt[i].size(); j++) {\n            if (cnt[i][j] == 1) ret++;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    int W, H;\n    vector<int> ans;\n    while (1) {\n        cin >> W >> H;\n        if (!W && !H) break;\n        ans.push_back(solve(W, H));\n    }\n\n    for (int r : ans) cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar c[21][21];\nint w, h;\nint sy, sx;\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[21][21];\nint ans = 0;\n\nvoid dfs(int y, int x){\n    f[y][x] = true;\n    ans++;\n    for(int i = 0; i < 4; i++){\n        int newy = y + dy[i];\n        int newx = x + dx[i];\n        if(0 <= newy && newy < h && 0 <= newx && newx < w && f[newy][newx] == false && c[newy][newx] != '#'){\n            dfs(newy, newx);\n        }\n    }\n    return;\n}\n\nint main(){\n    while(cin >> w >> h, w, h){\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> c[i][j];\n                if(c[i][j] == '@'){\n                    sy = i;\n                    sx = j;\n                }\n                f[i][j] = false;\n            }\n        }\n        ans = 0;\n        dfs(sy, sx);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <stdio.h>\nusing namespace std;\n#define ll long long\ntypedef pair<int, int> P;\nchar maze[30][30];\nint  w, h;\nint sx, sy;\nint ans = 0;\n\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\n\nvoid bfs() {\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()) {\n\t\tP p = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.second + dx[i], ny = p.first + dy[i];\n\n\n\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && maze[ny][nx] != '#') {\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t\tmaze[ny][nx] = '#';\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tans = 0;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tmaze[i][j] = '#';\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, sy, sx, dy[] = {-1, 0, 1, 0}, dx[] = {0, 1, 0, -1};\nchar data[20][20];\nbool vis[20][20];\n\nbool check(int y, int x){\n  if(y<0 || y>=h) return false;\n  if(x<0 || x>=w) return false;\n  return true;\n}\n\nint dfs(int y, int x){\n  int res = 1;\n  vis[y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(!check(ny, nx)) continue;\n    if(vis[ny][nx]) continue;\n    if(data[ny][nx] == '.') res += dfs(ny, nx);\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    fill(vis[0], vis[20], false);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        if(data[i][j] == '@'){\n          sy = i;\n          sx = j;\n          data[i][j] = '.';\n        }\n      }\n    }\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 9000\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; i++){\n      cin >> line;\n      for(int j=0; j < width ; j++){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 400; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width; j++){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width;j++){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; i++){\n    for(int j=0; j < width ; j++){\n      cout << setw(3)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    //cout << isValidPoint(x+dx,y+dy) << \" \" << x+dx << y+dy << endl;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      //cout << isValidPoint(x+dx,y+dy) << \" \" << x+dx << y+dy << endl;\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >=  width || y < 0 || y >= height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nchar table[20][20];\n\tint W,H;\n\nvoid dfs(int x,int y){\n\tif(table[x][y]!= '#')\n\t\ttable[x][y]='#';\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\trep(i,4)\n\t\tif(0<=x+dx[i]&&x+dx[i]<W&&0<=y+dy[i]&&y+dy[i]<H&&table[x+dx[i]][y+dy[i]]!='#')\n\t\t\tdfs(x+dx[i],y+dy[i]);\n\treturn ;\n}\n\n\nint main(void){\n\twhile(cin >> W >> H,W|H){\n\t\tint pre=0,sx,sy;\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\tcin >> table[x][y];\n\t\t\t\tif(table[x][y]=='#')\n\t\t\t\t\tpre++;\n\t\t\t\tif(table[x][y]=='@')\n\t\t\t\t\tsx=x,sy=y;\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy);\n\t\tint post=0;\n\t\trep(y,H)\n\t\t\trep(x,W)\n\t\t\t\tif(table[x][y]=='#')\n\t\t\t\t\tpost++;\n\t\tcout << post-pre << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint main()\n{\n  int W, H, i, j, f, d, count;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  char map[32][32];\n  char s[32];\n\n  while (1) {\n    gets(s);\n    sscanf(s, \"%d %d\", &W, &H); if (W == 0 && H == 0) { break; }\n    for (i = 0; i < 30; i++) {\n      strcpy(map[i], \"##############################\");\n    }\n    \n    for (i = 0; i < H; i++) {\n      gets(&map[i+1][1]);\n      map[i+1][W+1] = '#';\n      map[i+1][W+2] = '\\0';\n    }\n\n    count = 1;\n    while (1) {\n      f = 0;\n      for (i = 1; i <= H; i++) {\n        for (j = 1; j <= W; j++) {\n          if (map[i][j] == '@') {\n            for (d = 0; d < 4; d++) {\n              if (map[i+dy[d]][j+dx[d]] == '.') {\n                map[i+dy[d]][j+dx[d]] = '@';\n                count++;\n                f = 1;\n              }\n            }\n          }\n        }\n      }\n      if (!f) {\n        break;\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint COUNT=0;\n\nvoid dfs(vector<string> map,int state[20][20],int x,int y,int W,int H){\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  if(x<0 || x==H || y<0 || y==W)return; //????????????\n  if(state[x][y]!=0 || map[x][y]=='#')return; //?????§????????£??????????????????????????????\n  ++COUNT;\n  state[x][y]=1;\n  for(int i=0;i<4;++i)dfs(map,state,x+dx[i],y+dy[i],W,H); //??????????????¨??¢?´¢\n}\n\nint main(){\n  int W,H,x,y;\n  vector<string> map;\n  string a;\n  while(true){\n    COUNT=0;\n    cin >> W >>H;\n  if(!W && !H)break;\n  int state[20][20]={0}; //?????§????????£???????????????\n  for(int i=0;i<H;++i){ //???????????\\???\n    cin >> a;\n    map.push_back(a);\n  }\n  for(int i=0;i<H;++i){//????????????????????¢?´¢\n    if(0<map[i].find('@') && map[i].find('@')<W){\n      y=map[i].find('@');\n      x=i;\n      break;\n    }\n  }\n    dfs(map,state,x,y,W,H);\n    cout << COUNT << endl;\n    map.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\n  if(y!=0)\n    if(a[y-1][x]=='.')\n      dfs(y-1,x);\n  if(y!=20)\n    if(a[y+1][x]=='.')\n      dfs(y+1,x);\n  if(x!=0)\n    if(a[y][x-1]=='.')\n      dfs(y,x-1);\n  if(x!=20)\n    if(a[y][x+1]=='.')\n      dfs(y,x+1);\n}\nint main(){\n  int w,h,i,j;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%c\",&a[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0; tile[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j); used[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0];\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y); used[x - 1][y] = 1;\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y); used[x + 1][y] = 1;\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y - 1); used[x][y - 1] = 1;\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y + 1); used[x][y + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define min(a, b) ((a)<(b)? (a):(b))\n#define max(a, b) ((a)>(b)? (a):(b))\n#define rep(i, n) REP(i, 0, (n))\n#define REP(i, a, n) for(typeof(n) i=(a); i<(n); i++)\n\nint H, W;\nchar t[30][30];\nbool visited[30][30];\n\nint dfs(int i, int j, int cnt) {\n    if(i < 0 || j < 0 || i >= H || j >= W) return 0;\n    if(visited[i][j]) return 0;\n    if(t[i][j] == '#') return 0;\n    \n    visited[i][j] = true;\n    \n    return 1 + dfs(i+1, j, cnt) + dfs(i-1, j, cnt) + dfs(i, j+1, cnt) + dfs(i, j-1, cnt);\n}\n\nint main() {\n\twhile(true) {\n        cin >> W >> H;\n        if(W == 0 && H == 0) break;\n        \n        int p, q;\n        rep(i, H) {\n            rep(j, W) {\n                cin >> t[i][j];\n                visited[i][j] = false;\n                if(t[i][j] == '@') {p = i; q = j;}\n            }\n        }\n        cout << dfs(p, q, 0) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n\nchar ma[30][30];\n\nint W,H;\nint dfs(int nx,int ny){\n\tif(ma[ny][nx]=='#')return 0;\n\tma[ny][nx]='#';\n\tint re=1;\n\tfor(int i=0;i<4;i++){\n\t\tint nex=nx+dx[i],ney=ny+dy[i];\n\t\tif(nex>=0 && ney>=0 && nex<W && ney<H)re+=dfs(nex,ney);\n\t}\n\treturn re;\n}\n\n\nint main(){\n\tint sx,sy;\n\twhile(cin>>W>>H && W+H){\n\t\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++){\n\t\t\tcin>>ma[i][j];\n\t\t\tif(ma[i][j]=='@'){sx=j,sy=i;}\n\t\t}\n\t\tcout<<dfs(sx,sy)<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 90000\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; ++i){\n      cin >> line;\n      for(int j=0; j < width ; ++j){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 400; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; ++i){\n    for(int j=0; j < width ; ++j){\n      cout << setw(3)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >  width || y < 0 || y > height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint m,n,ans;\nchar ice[22][22];\n\nvoid saiki(int w,int h){\n\tice[w][h]='*';\n\t\n\tif(ice[w+1][h]=='.')saiki(w+1,h);\n\tif(ice[w][h+1]=='.')saiki(w,h+1);\n\tif(w!=0)if(ice[w-1][h]=='.')saiki(w-1,h);\n\tif(h!=0)if(ice[w][h-1]=='.')saiki(w,h-1);\n}\n\nint main(void){\n\n\tfor(;;){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(!m||!n)break;\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",&ice[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i][j]=='@')saiki(i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i][j]=='*')ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint main()\n{\n\tint W, H;\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\twhile (cin >> W >> H && W != 0 && H != 0)\n\t{\n\t\tbool path[20 + 1][20 + 1];\n\t\tfor (int i = 1; i <= H; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= W; j++)\n\t\t\t{\n\t\t\t\tpath[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tchar field[20 + 1][20 + 1];\n\t\tint startx, starty;\n\t\tfor (int i = 1; i <= H; i++)\n\t\t{\n\t\t\tchar buf[21];\n\t\t\tcin >> buf;\n\t\t\tstring str = buf;\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = str.at(j);\n\t\t\t\tif (str.at(j) == '@')\n\t\t\t\t{\n\t\t\t\t\tstartx = j + 1;\n\t\t\t\t\tstarty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint tiles = 0;\n\t\tqueue< pair<int,int> > q;\n\t\tq.push(make_pair(startx, starty));\n\t\tpath[starty][startx] = true;\n\t\twhile(q.size() > 0)\n\t\t{\n\t\t\tpair<int,int> p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\ttiles++;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (nx > W || ny > H || nx < 1 || ny < 1)continue;\n\t\t\t\tif (path[ny][nx])continue;\n\t\t\t\tif (field[ny][nx] == '#')continue;\n\t\t\t\tpath[ny][nx] = true;\n\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t}\n\t\t}\n\t\tcout << tiles << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <iostream>\n#include <locale>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint solve(int w, int h) {\n    vector<string> s(h);\n    queue<int> queX;\n    queue<int> queY;\n    for (int i = 0; i < h; i++) {\n        cin >> s[i];\n    }\n    int x, y;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (s[i][j] == '@') {\n                queX.push(i);\n                queY.push(j);\n                s[i][j] = '#';\n                break;\n            }\n        }\n    }\n    int xmove[4] = {0, 0, -1, 1};\n    int ymove[4] = {1, -1, 0, 0};\n    int ans      = 0;\n    while (!queX.empty() && !queY.empty()) {\n        x = queX.front();\n        y = queY.front();\n        queX.pop();\n        queY.pop();\n        ans++;\n\n        for (int i = 0; i < 4; i++) {\n            if (x + xmove[i] >= 0 && x + xmove[i] < h && y + ymove[i] >= 0 && y + ymove[i] < w) {\n                if (s[x + xmove[i]][y + ymove[i]] == '.') {\n                    queX.push(x + xmove[i]);\n                    queY.push(y + ymove[i]);\n                    s[x + xmove[i]][y + ymove[i]] = '#';\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int w, h;\n    vector<int> ans;\n    while (1) {\n        cin >> w >> h;\n        if (!w && !h)\n            break;\n        ans.push_back(solve(w, h));\n    }\n    for (int a : ans) cout << a << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w, h;\nchar tile[20][20];\nint ans = 0;\nint dx[4] = { 0, 0, 1, -1 };\nint dy[4] = { 1, -1, 0, 0 };\n\nvoid solve(int x, int y)\n{\n\tans++;\n\ttile[y][x] = '#';\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (tile[Y][X] == '.' && 0 <= X && X < w && 0 <= Y && Y < h)\n\t\t{\n\t\t\tsolve(X, Y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\n\twhile (cin >> w >> h, w + h != 0){\n\t\t\n\t\tans = 0;\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (tile[i][j] == '@') solve(j, i);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**********************************************\n\n1.red and black\n2.炭田高輝\n3.sumita.takaki@gmail.com\n\nlast updated: 2013-10-15@20:19\n\n **********************************************/\n#include<iostream>\n#include<algorithm>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n\n\nvoid rec(int y, int x);\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\nbool visit[21][21];\nstring tiles[21];\nint h=0, w=0;\n\n\n\nint main(void){\n        \n\n\n        while(cin >> w >> h, h){\n                \n                \n                for(int i=0; i<h; i++){\n\n                        cin >> tiles[i];\n                        \n                        for(int j=0; j<w; j++)visit[i][j] = false;\n                }\n\n\n                for(int i=0; i<h; i++){\n\n                        for(int j=0; j<w; j++){\n                                \n                                if(tiles[i][j] == '@')rec(i,j);\n\n                        }\n                }\n                                \n                int ans = 0;\n\n                for(int i=0; i<h; i++){\n\n                        for(int j=0; j<w; j++){\n                                if(visit[i][j])ans++;\n                        }\n\n                }\n\n                cout << ans << endl;\n\n        }\n\n\n\n}\n\nvoid rec(int y, int x){\n\n        \n        if(visit[y][x])return;\n        visit[y][x] = true;\n\n        for(int i=0; i<4; i++){\n                int ny = y + dy[i], nx = x + dx[i];\n\n                if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n                if(tiles[ny][nx] == '#')continue;\n                rec(ny,nx);\n        }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  vector< int > data;\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n  int Size(int x) {\n    return(-data[Find(x)]);\n  }\n  int Find(int k) {\n    return(data[k] < 0 ? k : data[k] = Find(data[k]));\n  }\n  void Unite(int a, int b) {\n    a = Find(a), b = Find(b);\n    if(a == b) return;\n    data[a] += data[b];\n    data[b] = a;\n  }\n};\n\nint main() {\n  int W, H;\n  while(cin >> W >> H, W) {\n    string mas[50];\n    for(int i = 0; i < H; i++) cin >> mas[i];\n    UnionFind uf(W * H);\n    for(int i = 0; i < H; i++) {\n      for(int j = 1; j < W; j++) {\n        if(mas[i][j - 1] != '#' && mas[i][j] != '#') uf.Unite(i * W + j - 1, i * W + j);\n      }\n    }\n    for(int i = 1; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(mas[i - 1][j] != '#' && mas[i][j] != '#') uf.Unite(i * W - W + j, i * W + j);\n      }\n    }\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        if(mas[i][j] == '@') cout << uf.Size(i * W + j) << endl;\n      }\n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint tile[22][22];\nint w, h;\nint cnt;\n\nvoid fill(int x, int y) {\n\ttile[x][y] = 0;\n\tcnt++;\n\tif (tile[x - 1][y] == 1) fill(x - 1, y);\n\tif (tile[x][y - 1] == 1) fill(x, y - 1);\n\tif (tile[x][y + 1] == 1) fill(x, y + 1);\n\tif (tile[x + 1][y] == 1) fill(x + 1, y);\n}\n\nint main() {\n\tint x = 0, y = 0;\n\twhile (cin >> w >> h && (w || h)) {\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < 22; ++i) for (int j = 0; j < 22; ++j) tile[i][j] = 0;\n\t\tfor (int i = 1; i <= h; ++i){\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif (tmp == '.') tile[i][j] = 1;\n\t\t\t\telse if (tmp == '#') tile[i][j] = 0;\n\t\t\t\telse x = i, y = j, tile[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfill(x, y);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\nbool B[25][25]; int N, M;\nvoid dfs(int ty, int tx, vs S)\n{\n\tfor (int r = 0; r < 4; r++)\n\t{\n\t\tint y = ty + dd[r];\n\t\tint x = tx + dd[r + 1];\n\t\tif (y < 0 || y >= N || x < 0 || x >= M)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (S[y][x] == '.' && B[y][x] == false)\n\t\t{\n\t\t\tB[y][x] = true;\n\t\t\tdfs(y, x, S);\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tcin >> M >> N;\n\t\tif (N == 0 && M == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvs S(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> S[i];\n\t\t}\n\t\tint sy = -1, sx = -1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (S[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tdfs(sy, sx, S);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (B[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans+1) << endl;\n\t}\n\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll h,w,H,W,t[20][20],vx[4]={0,0,1,-1},vy[4]={1,-1,0,0},cnt,X,Y;\nstring s[20];\nqueue<P> que;\nint main(void){\n    while(1){\n        cin>>w>>h;\n        if(h==0&&w==0){\n            return 0;\n        }\n        cnt=0;\n        for(int i=0;i<h;i++){\n            cin>>s[i];\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                t[i][j]=0;\n                if(s[i][j]=='@'){\n                    H=i,W=j;\n                    //cout<<H<<W<<s[H][W]<<endl;\n                }\n            }\n        }\n        \n        que.push({H,W});\n        t[H][W]=1;\n        while(que.size()){\n            P p=que.front();\n            que.pop();\n            for(int i=0;i<4;i++){\n                X=p.first+vx[i];Y=p.second+vy[i];\n                if(0<=X&&X<=h-1&&0<=Y<=Y<=w-1&&t[X][Y]==0&&s[X][Y]=='.'){\n                    que.push({X,Y});\n                    t[X][Y]=1;\n                    cnt++;\n                }\n            }\n        }\n        cout<<cnt+1<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint h, w;\nchar grid[30][30];\nint ans;\n\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, -1, 1, 0};\n\nvoid dfs(int x, int y) {\n  grid[y][x] = '#';\n  ans++;\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (nx < 0 || ny < 0 || nx >= w || ny >= h ) {\n      continue;\n    }\n    if ( grid[ny][nx] == '#' ) {\n      continue;\n    }\n    dfs(nx, ny);\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(20) << fixed;\n\n  int sx, sy;\n\n  while ( true ) {\n    cin >> w >> h;\n\n    if (w == 0 && h == 0) { break; }\n\n    rep(y, h) {\n      cin >> grid[y];\n    }\n\n    rep(y, h) {\n      rep(x, w) {\n        if (grid[y][x] == '@') {\n          sx = x; sy = y;\n        }\n      }\n    }\n    ans = 0;\n    dfs(sx, sy);\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w, h, cnt;\nint vx[] = {0, 1, 0, -1};\nint vy[] = {1, 0, -1, 0};\nchar field[20][20];\nvoid solve(int x, int y){\n    ++cnt;\n    field[y][x] = '#';\n    for(int i = 0; i < 4; ++i){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        if(nx >= 0 && nx < w && ny >= 0 && ny < h && field[ny][nx] == '.')\n            solve(nx, ny);\n    }\n}\nint main(){\n    int sx, sy;\n    while(cin >> w >> h){\n\n        if(!(w || h)) break;\n        for(int i = 0; i < h; ++i){\n            for(int j = 0; j < w; ++j){\n                cin >> field[i][j];\n                if(field[i][j] == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        cnt = 0;\n\n        solve(sx, sy);\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nint box[20][20];\nint  kazoe(int p,int P,int H,int W){\n  int i,I;\n  a++;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cout<<box[i][I];\n    }\n    cout<<endl;\n  }\n  box[p][P]=0;\n  if(box[p][P+1]==1) kazoe(p,P+1,H,W);\n  if(box[p][P-1]==1) kazoe(p,P-1,H,W);\n  if(box[p-1][P]==1) kazoe(p-1,P,H,W);\n  if(box[p+1][P]==1) kazoe(p+1,P,H,W);\n  else {\n  return a;\n  }\n}\nint main(){\n  int i,I,H,W,p,P;\n  \n  char v;\n  while(1){\n  cin>>W>>H;\n  if(W==0&&H==0) break;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  cout<<kazoe(p,P,H,W)<<endl;\n  a=0;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      box[i][I]=0;\n    }\n  }\n  \n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint solve( int w, int h, vector< vector<char> > &v );\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(w);\n        for (int i = 0; i < w; i++) {\n            vec[i].resize(h);\n        }\n\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < h; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        sums.push_back( solve( w, h, vec ) );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nint solve( int w, int h, vector< vector<char> > &v ){\n    int w_index, h_index, total;\n    int ans = 1;\n\n    for (auto it = v.begin(); it != v.end(); it++ ) {\n        auto iter = find(it->begin(), it->end(), '@');\n\n        if(iter!=it->end()){\n            w_index = distance( v.begin(), it );\n            h_index = distance( it->begin(), iter );\n        }\n    }\n\n    dfs( w, h, w_index, h_index, v, ans );\n\n    return ans;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[w_index][h_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[nx][ny] == '.' ){\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n\nint tansaku(char tile[20][20],int w1,int h1){\n    if(tile[w1][h1]!='.'&&tile[w1][h1]!='@')return 0;\n    tile[w1][h1]='t';\n    return 1+tansaku(tile,w1+1,h1)+tansaku(tile,w1-1,h1)+tansaku(tile,w1,h1+1)+tansaku(tile,w1,h1-1);\n}\n\nint main(){\n    int w,h;\n    int w1,h1; //スタート地点\n   // 標準入力\n   while(1){\n    std::cin >> w;\n    std::cin >> h;\n    if(w==0&&h==0)break;\n    //配列の初期化\n    char tile[20][20]={};\n    // 配列を取得.\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            std::cin >> tile[j][i];\n            if(tile[j][i]=='@'){\n                w1=j; h1=i;\n            }\n        }\n    }\n    std::cout << tansaku(tile,w1,h1) << std::endl;\n   }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> C[i][j];\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(make_pair(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(make_pair(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <math.h>\n#include <utility>\nusing namespace std;\n\ntypedef long long int ll; \ntypedef pair<int,int> Pii;\n\nint W,H,tmpAns;\nvector <vector <int> > cels;\nvector<int> ans;\nvector<Pii> candidate;//未探索候補\n\n// タイルの種類　黒＝1，赤＝2，探索済み＝3\n\nbool isCan(int h,int w){\n    // 範囲チェック\n    if(h<0||h>H-1)return false;\n    if(w<0||w>W-1)return false;\n\n    // チェック\n    if(cels[h][w]==1)return true;\n    return false;\n}\n\nvoid searchCel(int h,int w){\nPii tmpPair;\n\ntmpAns++;\ncels[h][w]=3;\nif(isCan(h,w+1)==true){\n    tmpPair.first = h;tmpPair.second = w+1;\n    candidate.push_back(tmpPair);\n}\nif(isCan(h,w-1)==true){\n    tmpPair.first = h;tmpPair.second = w-1;\n    candidate.push_back(tmpPair);\n}\nif(isCan(h+1,w)==true){\n    tmpPair.first = h+1;tmpPair.second = w;\n    candidate.push_back(tmpPair);\n}\nif(isCan(h-1,w)==true){\n    tmpPair.first = h-1;tmpPair.second = w;\n    candidate.push_back(tmpPair);\n}\n\nwhile(1){\n    if(candidate.empty())return;\n    pair<int,int> tmpPair=candidate.back();\n    candidate.pop_back();\n    if(cels[tmpPair.first][tmpPair.second]==1){\n        searchCel(tmpPair.first,tmpPair.second);\n        break;\n    }\n}\n\nreturn;\n}\n\nint main(){\n    char tmp;\n    int now_w,now_h;\n    while(1){\n        cin>>W>>H;\n        if(W==0&&H==0)break;\n        cels.clear();\n        cels.assign(H,vector<int>(W,0));\n        tmpAns=0; \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin>>tmp;\n                switch (tmp){\n                case '.':\n                    cels[i][j]=1;\n                    break;\n                case '#':\n                    cels[i][j]=2;\n                    break;\n                case '@':\n                    cels[i][j]=3;\n                    now_h=i;now_w=j;\n                    break;\n                default:\n                    return -1;\n                }\n            }\n        }\n        searchCel(now_h,now_w);\n        ans.push_back(tmpAns);\n        \n    }\n\n    for(int i=0;i<ans.size();i++){\n        cout<<ans[i]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nconst int vx[4] = { 0, 1, 0, -1 }, vy[4] = { 1, 0, -1, 0 };\n\nint W, H;\nstd::string s[21];\nbool is_searched[21][21];\n\nint solve() {\n  int sx, sy;\n\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      if (s[i][j] == '@') {\n        sx = i, sy = j;\n        goto L;\n      }\n    }\n  }\nL:\n\n  std::memset(is_searched, false, sizeof is_searched);\n\n  int ans = 1;\n\n  std::queue<std::pair<int, int> > que;\n  que.push({ sx, sy });\n  is_searched[sx][sy] = true;\n\n  while (!que.empty()) {\n    std::pair<int, int> p = que.front();\n    que.pop();\n\n    for (int i = 0; i < 4; ++i) {\n      int nx = p.first + vx[i], ny = p.second + vy[i];\n\n      if (0 <= nx && nx < H && 0 <= ny && ny < W && !is_searched[nx][ny] && s[nx][ny] == '.') {\n        ans++;\n        is_searched[nx][ny] = true;\n        que.push({ nx, ny });\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n  while (cin >> W >> H, H | W) {\n    for (int i = 0; i < H; ++i) {\n      cin >> s[i];\n    }\n\n    int ans = solve();\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<functional>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nusing namespace std;\n\ntypedef pair<int ,int > P;\n\nint ans;\nint w,h;\nchar maze[27][27];\n\nvoid dfs(int x,int y)\n{\n\t//printf(\"[debug]:%d,%d\\n\",x,y);\n\tmaze[x][y]='#';\n\trep(i,4)\n\t{\n\t\tint nx=dx[i]+x;\n\t\tint ny=dy[i]+y;\n\t\tif(maze[nx][ny]=='.')\n\t\t{\n\t\t\tans++;\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n\n}\n\nvoid solve()\n{\n\t/*\n\trep(i,25)\n\t{\n\t\trep(j,25)\n\t\t{\n\t\t\tcout<<maze[i][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\trep(i,h) rep(j,w)\n\t{\n\t\tif(maze[i][j]=='@')\n\t\t{\n\t\t\tdfs(i,j);\n\t\t\tcout<<ans+1<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\n}\n\nint main()\n{\n\trep(i,25) rep(j,25) maze[i][j]='#';\n\t\n\twhile(cin>>w>>h)\n\t{\n\t\tif(w==0&&h==0) return 0;\n\t\trep(i,h) rep(j,w) \n\t\t{\n\t\t\tcin>>maze[i][j];\n\t\t}\n\t\tsolve();\n\t\tans=0;\n\t\trep(i,25) rep(j,25) maze[i][j]='#';\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nchar m[22][22];\nint main() {\n\tint w, h;\n\tpii pos;\n\twhile (cin>>w>>h,w) {\n\t\tfill((char*)m, (char*)m + 22 * 22,'#');\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tif (m[i][j] == '@')pos = pii(i, j);\n\t\t\t}\n\t\t}\n\t\tint sum = 1;\n\t\tqueue<pair<int, int>> que;\n\t\tque.push(pos);\n\t\twhile (!que.empty()) {\n\t\t\tint dx[] = { 1,0,-1,0 }, dy[] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = que.front().second+dx[i], y = que.front().first+dy[i];\n\t\t\t\tif (m[y][x] == '.') {\n\t\t\t\t\tm[y][x] = '@';\n\t\t\t\t\tsum++;\n\t\t\t\t\tque.push(pii(y, x));\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\nusing namespace std;\n\n\n\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\n\n\nint main(){\n\n\n\n\tint W,H,sx,sy;\n\n\tstring s[25];\n\n\tbool flag[25][25];\n\n\n\n\twhile(1){\n\n\t\tcin>>W>>H;\n\n\t\tif(W==0&&H==0) break;\n\n\t\tfor(int i=0; i<H; i++){\n\n\t\t\tcin>>s[i];\n\n\t\t\tfor(int j=0; j<W; j++){\n\n\t\t\t\tif(s[i][j] == '@'){\n\n\t\t\t\t\tsx = j;\n\n\t\t\t\t\tsy = i;\n\n\t\t\t\t}\n\n\t\t\t\tflag[i][j] = false;\n\n\t\t\t}\n\n\t\t}\n\n\n\n\n\n\t\tqueue<int> qx;\n\n\t\tqueue<int> qy;\n\n\t\tqx.push(sx);\n\n\t\tqy.push(sy);\n\n\n\n\t\tflag[sy][sx] = true;\n\n\n\n\t\tint x, y, cnt = 1;\n\n\t\twhile(!qx.empty()){\n\n\n\n\t\t\tx = qx.front();\n\n\t\t\ty = qy.front();\n\n\t\t\tqx.pop();\n\n\t\t\tqy.pop();\n\n\n\n\t\t\tfor(int k=0; k<4; k++){\n\n\t\t\t\tint nx = x+dx[k], ny = y+dy[k];\n\n\t\t\t\tif(0<=nx && nx<W && 0<=ny && ny<H){\n\n\t\t\t\t\tif(s[ny][nx] == '.' && !flag[ny][nx]){\n\n\t\t\t\t\t\tqx.push(nx);\n\n\t\t\t\t\t\tqy.push(ny);\n\n\t\t\t\t\t\tflag[ny][nx] = true;\n\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\n\n\n\t}\t\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<iomanip>\n#include<stack>\n#include<cmath>\n#define ll long long\nusing namespace std;\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h && w&&h) {\n\t\tint move[4][2] = { {1,0},{0,1},{-1,0},{0,-1} },cnt=0;\n\t\tchar room[20][20];\n\t\tbool flag[20][20] = {};\n\t\tqueue<pair<int, int>>que;\n\t\tpair<int, int>cur;\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') que.push(make_pair(j, i));\n\t\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tcur = que.front();\n\t\t\tque.pop();\n\t\t\tflag[cur.second][cur.first] = true;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (cur.first + move[i][0] >= 0 && cur.first + move[i][0] < w&&cur.second + move[i][1] >= 0 && cur.second + move[i][1] < h)\n\t\t\t\t\tif (!flag[cur.second + move[i][1]][cur.first + move[i][0]]&& room[cur.second + move[i][1]][cur.first + move[i][0]]=='.') {\n\t\t\t\t\t\tque.push(make_pair(cur.first + move[i][0], cur.second + move[i][1]));\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\tflag[cur.second + move[i][1]][cur.first + move[i][0]] = true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\n#define W_MAX 20\n#define H_MAX 20\n\n#define B '.'\n#define R '#'\n#define M '@'\n\nchar map[W_MAX][H_MAX];\n\nint main(){\n\n  while(true){\n    int W,H;\n    cin >> W >> H;\n\n    if(W==0 && H==0) break;\n\n    pii s; //start\n\n    for(int i=0; i<H; i++){\n      getchar();\n      for(int j=0; j<W; j++){\n\tscanf(\"%c\", &map[i][j]);\n\tif(map[i][j]==M){\n\t  s = make_pair(i,j);\n\t  map[i][j] = R;\n\t}\n      }\n    }\n\n    stack<pii> st;\n    st.push(s);\n    int dx[] = {-1,0,0,1}; int dy[] = {0,1,-1,0};\n    int ans=0;\n    while(!st.empty()){\n      pii p = st.top(); st.pop();\n      int x = p.first; int y = p.second;\n      ans++;\n      for(int i=0; i<4; i++){\n\tint nx = x+dx[i]; int ny = y+dy[i];\n\tif(nx>=0 && nx<H &&\n\t   ny>=0 && ny<W &&\n\t   map[nx][ny]==B){\n\t  st.push(make_pair(nx,ny));\n\t  map[nx][ny] = R;\n\t}\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\n  if(y!=0)\n    if(a[y-1][x]=='.')\n      dfs(y-1,x);\n  if(y!=20)\n    if(a[y+1][x]=='.')\n      dfs(y+1,x);\n  if(x!=0)\n    if(a[y][x-1]=='.')\n      dfs(y,x-1);\n  if(x!=20)\n    if(a[y][x+1]=='.')\n      dfs(y,x+1);\n}\nint main(){\n  int w,h,i,j;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%c\",&a[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid checkboard(void);\nvoid startmove(void);\nint checked(int i,int j);\n\nchar board[20][20];\nint H,W,now[2];\n\nint main(void){\n\twhile(1){\n\t\tcin >> H >> W ;\n\t\tif (!H && !W) break;\n\t\t// count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j]=='@'){\n\t\t\t\t\tnow[0]=i;\n\t\t\t\t\tnow[1]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstartmove();\n\t\tcheckboard();\n\t}\n\n}\n\n\nvoid startmove(void){\n\tint n;\n\tdo{\n\t\tn=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@')\n\t\t\t\t\tn+=checked(i,j);\n\t\t\t}\n\t\t}\n\n\t}while(n);\n}\n\nint checked(int i,int j){\n\tint a=0;\n\tif(i>=0 && board[i-1][j]=='.'){\n\t\tboard[i-1][j]='@';\n\t\ta=1;\n\t}\n\tif(i<W && board[i+1][j]=='.'){\n\t\tboard[i+1][j]='@';\n\t\ta=1;\n\t}\n\tif(j>=0 && board[i][j-1]=='.'){\n\t\tboard[i][j-1]='@';\n\t\ta=1;\n\t}\n\tif(j<H && board[i][j+1]=='.'){\n\t\tboard[i][j+1]='@';\n\t\ta=1;\n\t}\n\t// checkboard();\n\treturn a;\n}\nvoid checkboard(void){\n\t\tint count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@') count++; \n\t\t\t\t// cout << board[i][j];\n\t\t\t}\n\t\t}\n\t\t\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar table[21][21];\nbool reachable;\nint cnt;\nint w, h;\n\nvoid dfs(int x, int y) {\n    if (table[y][x] == '@')\n        reachable = true;\n    table[y][x] = '#';\n    for (int dy = -1; dy <= 1; dy++) {\n        for (int dx = -1; dx <= 1; dx++) {\n            if (dx*dy != 0 || x+dx < 0 || x+dx >= w || y+dy < 0 || y+dy >= h)\n                continue;\n            if (table[y+dy][x+dx] != '#') {\n                cnt++;\n                dfs(x+dx, y+dy);\n            }\n        }\n    }\n}\n\nint main()\n{\n    start:\n    while (cin >> w >> h, w|h) {\n        // input\n        for (int i = 0; i < h; i++) {\n            cin >> table[i];\n        }\n        // dfs\n        for (int j = 0; j < h; j++) {\n            for (int i = 0; i < w; i++) {\n                if (table[j][i] != '#') {\n                    reachable = false;\n                    cnt = 1;\n                    dfs(i, j);\n                    if (reachable) {\n                        cout << cnt << endl;\n                        goto start;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  int n = 0;\n  while (q.size()) {\n    n++;\n    P p = q.front();\n    q.pop();\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        f[i][j] = '#';\n        q.push(P(i, j));\n      }\n    }\n  }\n  return n;\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE][MAX_SIZE];\n  char c[MAX_SIZE + 1];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> c;\n      for (int j = 0; j < W; ++j) {\n        f[i][j] = c[j];\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nint cnt, w, h;\nchar m[20][20];\n\nvoid dfs(pii);\n\nint main(void){\n    while(cin >> w >> h, w){\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n\n        dfs(p);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if(p.X < 0 || w <= p.X ||\n            p.Y < 0 || h <= p.Y) return;\n\n    if(m[p.Y][p.X] == '.') cnt ++;\n    else return;\n    m[p.Y][p.X] = '#';\n\n    rep(i, 4){\n        pii next = mp(p.X + dx[i], p.Y + dy[i]);\n        dfs(next);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid search(int x, int y);\n\nint w, h;\nchar maze[22][22]; //行（y)　列（x）\nbool reached[22][22];\nint ans;\n\nint main() {\n  while(cin >> w >> h) {\n    if(w == 0 && h == 0) return 0;\n\n    // 初期化\n    for(int k = 0; k < h; k++) {\n      for(int l = 0; l < w; l++) {\n        maze[k][l] = '#';\n        reached[k][l] = false;\n      }\n    }\n    ans = 0;\n\n    //fill(reached, false);\n    // スタート座標\n    int a, b;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        cin >> maze[i][j];\n        if(maze[i][j] == '@') {\n          a = i;\n          b = j;\n          // cout << a << \" \" << b << endl;\n        }\n      }\n    }\n\n    search(a, b);\n    cout << ans << endl;\n\n    // for(int i = 0; i < h; i++) {\n    //   for(int j = 0; j < w; j++) cout << maze[i][j];\n    //   cout << endl;\n    // }\n  }\n}\n\nvoid search(int y, int x) {\n  // 迷路の外側か壁の場合は何もしない\n  if(x < 0 || w <= x || y < 0 || h <= y || maze[y][x] == '#') return;\n  // 以前に到達していたら何もしない\n  if(reached[y][x]) return;\n  ans++;\n  reached[y][x] = true;  //　到達したよ\n\n  // ４方向を試す\n  search(y, x + 1); //右\n  search(y, x - 1); //左\n  search(y + 1, x); //下\n  search(y - 1, x); //上\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(void) {\n\tint x, y, ans;\n\tbool bit;\n\t\n\twhile(1) {\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0) { break; }\n\t\tchar map[y][x];\n\t\t\n\t\tfor(int i=0; i<y; i++) { cin >> map[i]; }\n\t\tdo {\n\t\t\tbit = false;\n\t\t\tfor(int i=0; i<y; i++) {\n\t\t\t\tfor(int j=0; j<x; j++) {\n\t\t\t\t\tif(map[i][j] == '@') {\n\t\t\t\t\t\tif(j>0 && map[i][j-1] != '#' && map[i][j-1] != '@') { map[i][j-1] = '@'; bit = true; }\n\t\t\t\t\t\tif(i>0 && map[i-1][j] != '#' && map[i-1][j] != '@') { map[i-1][j] = '@'; bit = true; }\n\t\t\t\t\t\tif(j<x-1 && map[i][j+1] != '#' && map[i][j+1] != '@') { map[i][j+1] = '@'; bit = true; }\n\t\t\t\t\t\tif(i<y-1 && map[i+1][j] != '#' && map[i+1][j] != '@') { map[i+1][j] = '@'; bit = true; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while(bit);\n\t\tans = 0;\n\t\tfor(int i=0; i<y; i++) {\n\t\t\tfor(int j=0; j<x; j++) {\n\t\t\t\tif(map[i][j] == '@') { ans++; }\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct locate{\n  int x;\n  int y;\n};\n \nchar graph[20][20];\nint cou = 0;\nint H,W;\n\nvoid bfs(locate z){\n  queue<locate> Q;\n  locate u;\n  locate v;\n  Q.push(z);\n \n\n  while(!Q.empty()){\n\n    u = Q.front();Q.pop();\n    if(u.y < H - 1){\n      if(graph[u.y + 1][u.x] == '.' && graph[u.y + 1][u.x] != 'N'){\n\tgraph[u.y + 1][u.x] = 'N';\n\tcou++;\n\tv.y = u.y + 1;\n\tv.x = u.x;\n\tQ.push(v);\n      }\n    }\n    if(u.x < W - 1){\n      if(graph[u.y][u.x + 1] == '.' && graph[u.y][u.x + 1] != 'N'){\n\tgraph[u.y][u.x + 1] = 'N';\n\tcou++;\n\tv.x  = u.x + 1;\n\tv.y = u.y;\n\tQ.push(v);\n      }\n    }\n    if(u.y > 0){\n      if(graph[u.y - 1][u.x] == '.' && graph[u.y - 1][u.x] != 'N'){\n\tgraph[u.y - 1][u.x] = 'N';\n\tcou++;\n\tv.x = u.x;\n\tv.y = u.y - 1;\n\tQ.push(v);\n      }\n    }\n    if(u.x > 0){\n      if(graph[u.y][u.x - 1] == '.' && graph[u.y][u.x - 1] != 'N'){\n\tgraph[u.y][u.x - 1] = 'N';\n\tcou++;\n\tv.x = u.x - 1;\n\tv.y = u.y;\n\tQ.push(v);\n      }\n    }\n\n    /* cout << endl;\n       for(int i = 0; i< H ;i++){\n       for(int j = 0; j < W; j++){\n       cout << graph[i][j];\n       }\n       cout << endl;*/\n  }\n}\n  \n\n\nint main(){\n\n  int a1,a2;\n  locate a;\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    a.y = a1;\n    a.x = a2;\n    bfs(a);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 'N';\n      }\n    }\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define BLACK '.'\n#define RED '#'\n#define PEOPLE '@'\n#define N 25\n\nchar room[N][N];\nint h,w;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint count(int x, int y){\n  if( x<1 || x>w || y<1 || y>h )\n    return 0;\n\n  if( room[y][x] == RED )\n    return 0;\n  room[y][x] = RED;\n\n  int r=1;\n  for( int i=0;i<4;i++ )\n    r += count(x+dx[i], y+dy[i]);\n  return r;\n}\n\n\nint main(){\n  int st_x, st_y;\n  while( cin >> w >> h,(w|h) ){\n    for( int i=1;i<=h;i++ ){\n      for( int j=1;j<=w;j++ ){\n\tcin >> room[i][j];\n\tif( room[i][j] == PEOPLE ){\n\t  st_x=j;st_y=i;\n\t  room[i][j] = BLACK;\n\t}\n      }\n    }\n    cout << count(st_x, st_y) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring room[20];\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nint dfs(int x, int y){\n    int cnt = 1;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        \n        if(room[ny][nx] == '.'){\n            room[ny][nx] = '#';\n            cnt += dfs(nx, ny);\n        }\n    }\n    return cnt;\n}\n\nint main(int argc, const char * argv[]) {\n    while(1){\n        int w,h; cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> room[i];\n            if(room[i].find('@') != -1){\n                sx = room[i].find('@');\n                sy = i;\n            }\n        }\n        \n        cout << dfs(sx, sy) << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define BLACK '.'\n#define RED '#'\n#define ST '@'\n\nint w,h, ans=0;\nchar t[100][100];\n\nint rec(int x, int y){\n  if( x<0 || x>=h ) return 0;\n  if( y<0 || y>=w ) return 0;\n\n  if( t[x][y] == RED ) return 0;\n  t[x][y] = RED;\n\n  int dx[4] = {0,0,1,-1};\n  int dy[4] = {1,-1,0,0};\n  int r=1;\n  for( int d=0;d<4;d++ )\n     r+= rec(x+dx[d], y+dy[d]);\n  return r;\n}\nint main(){\n  while( cin>>w >> h, w){\n    int si, sj;\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++) {\n\tcin >> t[i][j];\n\tif( t[i][j] == ST ){\n\t  si=i; sj=j;\n\t}\n      }\n    cout << rec(si,sj) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\nvector<int> dx = {0,0,1,-1};\nvector<int> dy = {1,-1,0,0};\nint h,w;\nchar maze[23][23];\nbool seen[23][23];\n\nint id(int i,int j){\n    return i + j * h;\n}\n\nvoid dfs(int now){\n    int i = now % h;\n    int j = now / h;\n    if(seen[i][j]) return;\n    seen[i][j] = true;\n\n    rep(k,4){\n        int next_i = i + dx[k];\n        int next_j = j + dy[k];\n        if(0 <= next_i && next_i < h && 0 <= next_j && next_j < w){\n            if(seen[next_i][next_j]) continue;\n            if(maze[next_i][next_j] == '#') continue;\n            dfs(id(next_i,next_j));\n        }\n    }\n\n    return;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0 && h==0) break;\n        rep(i,h)rep(j,w) seen[i][j] = false;\n        rep(i,h)rep(j,w) cin >> maze[i][j];\n        int si, sj;\n        rep(i,h)rep(j,w){\n            if(maze[i][j]=='@') si = i,sj = j;\n        }\n        dfs(id(si,sj));\n        int ans = 0;\n        rep(i,h)rep(j,w){\n            ans += seen[i][j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <numeric>\n#include <queue>\n\nint main(){\n    for(;;){\n        int w,h;\n        std::cin >> w >> h;\n        if ( ( w == 0 ) && ( h == 0 ) ){return 0;}\n        std::vector<char> map(w*h);\n        std::vector<int> sw(w*h); for( auto v : sw ){ v=0; }\n        std::queue<int> queue;\n        int person;\n        for( int i=0; i<static_cast<int>(map.size()); ++i ){ std::cin >> map[i]; if (map[i]=='@'){person=i;} }\n        queue.push(person);\n        while( !queue.empty() ){\n            int t = queue.front(); queue.pop();\n            if ( map[t] == '#' ){continue;}\n            if (sw[t]){\n                continue;\n            } else {\n                sw[t] = 1;\n            }\n            if ( ( (t+1)%w ) && ( t+1 < w*h ) ){ queue.push(t+1); }\n            if ( t+w < w*h ){ queue.push(t+w); }\n            if ( (t%w) && ( 0 <= t-1 ) ){ queue.push(t-1); }\n            if ( 0 <= t-w ){ queue.push(t-w); }\n        }\n        std::cout << std::accumulate(sw.begin(),sw.end(),0) << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nint h,w;\nvector<string> s;\nbool inf(int y,int x){\n\treturn (y>=0&&y<h&&x>=0&&x<w)?true:false;\n}\nint bfs(int sy,int sx){\n\tint ret=0;\n\tqueue<P> que;\n\tque.push(P(sy,sx));\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\twhile(!que.empty()){\n\t\tP t=que.front();\n\t\tque.pop();\n\t\tint y=t.first,x=t.second;\n\t\tif(used[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tused[y][x]=true;\n\t\tret++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\t\tif(inf(ny,nx)&&!used[ny][nx]&&s[ny][nx]!='#'){\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\t\n\t\n\twhile(cin>>w>>h,h||w){\n\t\ts=vector<string>(h);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='@'){\n\t\t\t\t\tans=bfs(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint W, H, sx, sy, cnt;\nvector<int> dxy;\nstring field[20];\n\nvoid fun(int y, int x){\n    field[y][x] = '#';\n    cnt++;\n    for(int i=0; i<4; ++i){\n        int ny = y + dxy[i+1],\n            nx = x + dxy[i];\n        if(ny < 0 || ny >= H ||nx < 0 || nx >= W || field[ny][nx] != '.') continue;\n        fun(ny, nx);\n    }\n}\n    \nint main(){\n    dxy.push_back(1);\n    dxy.push_back(0);\n    dxy.push_back(-1);\n    dxy.push_back(0);\n    dxy.push_back(1);\n    while(cin >> W >> H, (W||H)){\n        cnt = 0;\n        string str;\n        cin.ignore();\n        for(int i=0; i<H; ++i){\n            cin >> field[i];\n        }\n\n        for(int i=0; i<H; ++i){\n            for(int j=0; j<W; ++j){\n                if(field[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        \n        fun(sy, sx);\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i, a, b) for(int i = ((int) a); i < ((int) b); i++)\n#define rep(i, n) repl(i, 0, n)\n\nint w, h;\nchar tile[20][20];\nbool vis[20][20];\nint dd[] = {-1, 0, 1, 0, -1};\n\nbool range(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint dfs(int y, int x) {\n  if (tile[y][x] == '#') return 0;\n  // cout << y << \" \" << x << endl;\n  vis[y][x] = true;\n  int cnt = 1;\n  rep(i, 4) {\n    int ni = y + dd[i], nj = x + dd[i + 1];\n    if(range(ni, nj) && tile[ni][nj] == '.' && !vis[ni][nj]) {\n      cnt += dfs(ni, nj);\n    }\n  }\n  return cnt;\n}\n\n\nint main(int argc, char const *argv[])\n{\n  while(cin >> w >> h, w | h) {\n    int x, y;\n    memset(vis, 0, sizeof(vis));\n    rep(i, h)rep(j, w) {\n      cin >> tile[i][j];\n      if(tile[i][j] == '@') x = j, y = i;\n    }\n\n    cout << dfs(y, x) <<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint solve( int w, int h, vector< vector<char> > &v );\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(w);\n        for (int i = 0; i < w; i++) {\n            vec[i].resize(h);\n        }\n\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < h; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        sums.push_back( solve( w, h, vec ) );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nint solve( int w, int h, vector< vector<char> > &v ){\n    int w_index, h_index, total;\n    int ans = 0;\n\n    for (auto it = v.begin(); it != v.end(); it++ ) {\n        auto iter = find(it->begin(), it->end(), '@');\n\n        if(iter!=it->end()){\n            w_index = distance( v.begin(), it );\n            h_index = distance( it->begin(), iter );\n        }\n    }\n\n    dfs( w, h, w_index, h_index, v, ans );\n\n    return ans;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[w_index][h_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[nx][ny] == '.' ){\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\nint w,h;\n\nvoid dfs(int x,int y){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif(((x<0||y<0)||x>=h||y>=w)||t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(x+dx[k],y+dy[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\tint sx=-1,sy=-1,cnt;\n\t\nwhile(true){\nscanf(\"%d %d/n\",&w,&h);\nif(!w&&!h) {break;}\nrep(i,h){\ncin >> t[i];\n}\n\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\n\ndfs(sx,sy);\n\ncnt =0;\n\nrep(i,h)rep(j,w)if(t[i][j]=='@') cnt++;\t\n\ncout<<cnt<<endl;;\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass DoubleArray {\n    int X,Y;\n    int *top;\n    public:\n    DoubleArray(int *p,int x,int y);\n    int *operator[](int i);\n    int getx();\n    int gety();\n};\n\nDoubleArray::DoubleArray(int *p,int x,int y){\n    top = p;\n    X = x;\n    Y = y;\n}\n\nint *DoubleArray::operator[](int i){\n    return top + Y*i;\n}\nint DoubleArray::getx(){\n    return X;\n}\nint DoubleArray::gety(){\n    return Y;\n}\n\nint calc(DoubleArray &map){\n    int i,j,a=0;\n    int x = map.getx();\n    int y = map.gety();\n    queue<int> q;\n    for(i=0;i<x;i++){\n        for(j=0;j<y;j++){\n            if(map[i][j]==2){\n                q.push(i);\n                q.push(j);\n                a=1;\n                map[i][j]=0;\n            }\n        }\n    }\n    while(!q.empty()){\n        i=q.front();\n        q.pop();\n        j=q.front();\n        q.pop();\n        if(i>0) if(map[i-1][j]==1){\n            q.push(i-1);\n            q.push(j);\n            a++;\n            map[i-1][j]=0;\n        }\n        if(j>0) if(map[i][j-1]==1){\n            q.push(i);\n            q.push(j-1);\n            a++;\n            map[i][j-1]=0;\n        }\n        if(i<x-1) if(map[i+1][j]==1){\n            q.push(i+1);\n            q.push(j);\n            a++;\n            map[i+1][j]=0;\n        }\n        if(j<y-1) if(map[i][j+1]==1){\n            q.push(i);\n            q.push(j+1);\n            a++;\n            map[i][j+1]=0;\n        }\n    }\n    return a;\n}\n\nint main(){\n    int i,j,x,y,a[10000],b = 0;\n    string c;\n    while(114514){\n        cin >> x;\n        cin >> y;\n        if(x==0&&y==0) break;\n        if(x<1||y<1) continue;\n        int m[x][y];\n        DoubleArray map(&m[0][0],x,y);\n        for(j=0;j<y;j++){\n            for(i=0;i<x;i++){\n                cin >> c;\n                if(c==\"#\") map[i][j]=0;\n                if(c==\".\") map[i][j]=1;\n                if(c==\"@\") map[i][j]=2;\n            }\n        }\n        a[b++] = calc(map);\n    }\n    for(i=0;i<b;i++){\n        cout << a[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<stdio.h>\n#include<queue>\n#include <climits>\n#include <map>\n#include <set>\nconst long long mod = 1e9 + 7;\nconst int INF = 1 << 20;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nchar f[30][30];\nint w,h;\nint dx[4] = {-1,0,0,1};\nint dy[4] = {0,-1,1,0};\nint ans;\n\nvoid dfs(int x,int y)\n{\n    f[y][x] = '#';\n    ans++;\n    for(int i = 0; i < 4; i++){\n        int ny = y+dy[i];\n        int nx = x+dx[i];\n        if(ny >= 0 && ny < h && nx >= 0 && nx < w && f[ny][nx] == '.'){\n            dfs(nx,ny);\n        }\n    }\n    return ;\n    \n}\n\nint main()\n{\n    while(true){\n        cin >> w >> h;\n        ans = 0;\n        if(w == 0 && h == 0) break;\n        int sx,sy;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> f[i][j];\n                if(f[i][j] == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        dfs(sx,sy);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\nusing namespace std;\nvoid dfs(int x, int y);\n\nint cnt = 0;\nstring data[20];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\nint w, h;\n\nint main()\n{\n    while(true){\n      cin >> w >> h;\n      if(w == 0 && h == 0) break;\n      \n      int sx, sy;\n      for(int i = 0 ; i < h ; i++){\n\tcin >> data[i];\n\tfor(int j = 0 ; j < w ; j++){\n\t  if(data[i][j] == '@'){\n\t    sx = i;\n\t    sy = j;\n\t  }\n\t}\n      }\n      dfs(sx, sy);\n      cout << cnt << '\\n';\n      cnt = 0;\n  }\n}\n\nvoid dfs(int x, int y)\n{\n  data[x][y] = '#';\n  cnt++;\n\n  rep(i, 4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && data[nx][ny] == '.'){\n      dfs(nx, ny);\n    }\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//?????????WA????????????\n//????????????????????£??????\n\nint W,H,f[21][21],ans[1000],cnt=0,sx,sy;\nstring m[21];\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tstring t;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tstring t;\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\n  \nint w,h,ans,dx[]={0,-1,0,1}, dy[]={-1,0,1,0};\nchar c[22][22];\n \nvoid solve(int x,int y){\n    ans++;\n    c[x][y]='#';\n    for(int i=0;i<4;i++){\n        int nx=x+dx[i], ny=y+dy[i];\n        if(0<=nx && nx<w && 0<=ny && ny<h && c[nx][ny]=='.')solve(nx,ny);\n    }\n}\n \nint main(){\n    while(cin>>w>>h, w){\n        ans=0;\n        int x,y;\n        for(int i=0;i<h;i++){\n            for(int j=0; j<w; j++){\n                cin>>c[j][i];\n                if(c[j][i]=='@')x=j,y=i;\n            }\n        }\n        \n        solve(x,y);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\n\nvoid dfs(int x, int y) {\n    if (room[y][x] == 0) return;\n    \n    num++;\n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1) dfs(x, y-1);\n    if (y+1 < h) dfs(x, y+1);\n    if (x-1 > -1) dfs(x-1, y);\n    if (x+1 < w) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        \n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nchar table[100][100];\nusing namespace std;\n\n\nint f(int w, int h, int x, int y){\n  int ret = 0;\n  if(x < 0 || y < 0 || x >= w || y >= h){\n    return 0;\n  }\n  if(table[y][x] == '#'){\n    return 0;\n  }\n  ret = 1;\n  table[y][x] = '#';\n  ret += f(w, h, x, y + 1);\n  ret += f(w, h, x, y - 1);\n  ret += f(w, h, x - 1, y);\n  ret += f(w, h, x + 1, y);\n  return ret;\n}\n\nint main(){\n  while(true){\n    int startX, startY;\n    int width, height;\n    cin >> width >> height;\n    if(width == 0 && height == 0){\n      break;\n    }\n    for(int i = 0; i < height; i++){\n      for(int j = 0; j < width; j++){\n        cin >> table[i][j];\n        if(table[i][j] == '@'){\n          //cout << \"startX = \" << j << \" startY = \" << i << endl;\n          startX = j;\n          startY = i;\n          table[i][j] = '.';\n        }\n      }\n      \n    }\n    cout << f(width, height, startX, startY) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w, h, sx, sy;\nchar t[22][22];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid solve(){\n  stack<P> open;\n  int ans = 0;\n\n  open.push(P(sx, sy));\n\n  while(!open.empty()){\n    P p = open.top();\n    open.pop();\n    ans++;\n\n    for(int i = 0; i < 4; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n\n      if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] != '.') continue;\n      t[ny][nx] = '#';\n      open.push(P(nx, ny));\n    }\n  }\n\n  cout << ans - 1 << endl;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == '@'){\n          sx = j;\n          sy = i;\n          t[i][j] = '.';\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(v) sort(ALL(v))\n//#define scanf scanf_s\ntypedef pair<int, int> P;\n\nint w, h;\nchar fld[30][30];\n\nint di[] = { -1, 0, 0, 1 }; int dj[] = { 0, -1, 1, 0 };\nint main()\n{\n\twhile (cin >> w >> h, w)\n\t{\n\t\tqueue<P> que;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tcin >> fld[i][j];\n\t\t\tif (fld[i][j] == '@') que.push(P(i, j));\n\t\t}\n\t\tint cnt = 1;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint x = que.front().first; int y = que.front().second;\n\t\t\tque.pop();\n\t\t\tREP(k, 4)\n\t\t\t{\n\t\t\t\tint nx = x + di[k]; int ny = y + dj[k];\n\t\t\t\tif (nx >= 0 && nx < h&&ny >= 0 && ny < w&&fld[nx][ny] == '.')\n\t\t\t\t{\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t\tfld[nx][ny] = '@';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n        \n    }\n    \n}\n\nint main(){\n    int x,y;\n    while(cin>>x>>y,x|y){\n        int startx,starty;\n        vector<vector<bool> > map;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include \"stdlib.h\"\n#include <queue>\n\nusing namespace std;\n\ntypedef struct Graph graph;\ntypedef uint Result;\n\ntypedef struct {\n    enum {\n        RED, BLACK\n    } color;\n    bool has_probed;\n}tile;\n\ntypedef struct {\n    uint x,y;\n}cordinate;\n\nstruct Graph{\n    tile graph[22][22];\n    uint height,width;\n    uint pos_x,pos_y;\n}checkborad;\n\nResult init_graph(graph* out){\n    uint H,W;\n    scanf(\"%u %u\",&W,&H);\n\n    if(H==0&&W==0)\n        return 0;\n\n    out->height=H;\n    out->width=W;\n\n\n\n    for (uint h=1;h<H+1;h++)\n        for(uint w=1;w<W+1;w++) {\n            char c;\n            c = getchar();\n            if (c == '\\n')\n                c = getchar();\n            switch (c) {\n                case '#':\n                    checkborad.graph[h][w].color = tile::RED;\n                    break;\n                case '@':\n                    checkborad.pos_x = w;\n                    checkborad.pos_y = h;\n                case '.':\n                    checkborad.graph[h][w].color = tile::BLACK;\n                    break;\n            }\n\n            checkborad.graph[h][w].has_probed=false;\n        }\n\n    for (uint i=0;i<H+2;i++){\n        out->graph[i][W+1]={tile::RED,true};\n        out->graph[i][0]={tile::RED,true};\n    }\n\n    for (uint i=0;i<W+2;i++){\n        out->graph[0][i]={tile::RED,true};\n        out->graph[H+1][i]={tile::RED,true};\n    }\n\n\n    return 1;\n}\n\n// return 0 on encountering ending\nuint count_graph(graph* self){\n    //initialization\n    queue<cordinate> q;\n    uint count=1;\n    q.push({self->pos_x,self->pos_y});\n    self->graph[self->pos_y][self->pos_x].has_probed=1;\n\n    while(!q.empty()){\n        auto temp=q.front();\n        q.pop();\n\n        uint left=temp.x-1,right=temp.x+1,top=temp.y-1,bottom=temp.y+1;\n\n        if(\n                self->graph[top][temp.x].color==tile::BLACK\n        &&!self->graph[top][temp.x].has_probed){\n            count++;\n            self->graph[top][temp.x].has_probed=1;\n            q.push({temp.x,top});\n        }\n\n        if(\n                self->graph[bottom][temp.x].color==tile::BLACK\n                &&!self->graph[bottom][temp.x].has_probed){\n            count++;\n            self->graph[bottom][temp.x].has_probed=1;\n            q.push({temp.x,bottom});\n        }\n\n        if(\n                self->graph[temp.y][left].color==tile::BLACK\n                &&!self->graph[temp.y][left].has_probed)\n        {\n            count++;\n            self->graph[temp.y][left].has_probed=1;\n            q.push({left,temp.y});\n        }\n\n        if(\n                self->graph[temp.y][right].color==tile::BLACK\n                &&!self->graph[temp.y][right].has_probed)\n        {\n            count++;\n            self->graph[temp.y][right].has_probed=1;\n            q.push({right,temp.y});\n        }\n\n    }\n\n    return count;\n}\n\nint main() {\n\n    while(1){\n       if (!init_graph(&checkborad))\n           break;\n\n       printf(\"%u\\n\",count_graph(&checkborad));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\nint W, H;\nvector<string> field;\n\nint dfs(int y, int x) {\n    int ans = 1; field[y][x] = '#';\n    for (int k = 0; k < 4; k++) {\n        int ny = y + dy[k], nx = x + dx[k];\n        if (0 <= ny && ny < H && 0 <= nx && nx < W) {\n            if (field[ny][nx] == '.') ans += dfs(ny, nx);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> W >> H, W) {\n        field.resize(H);\n        for (int i = 0; i < H; i++) cin >> field[i];\n        for (int y = 0; y < H; y++) for (int x = 0; x < W; x++) {\n            if (field[y][x] == '@') cout << dfs(y, x) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint walking(vector<vector<char> > &walk, int a, int b, int &count){\n\twalk[a][b] = '#';\n\t\n\tif(walk[a-1][b] == '.'){\n\t\tcount++;\n\t\twalking(walk, a-1, b, count);\n\t}\n\n\tif(walk[a][b-1] == '.'){\n\t\tcount++;\n\t\twalking(walk, a, b-1, count);\n\t}\n\n\tif(walk[a+1][b] == '.'){\n\t\tcount++;\n\t\twalking(walk, a+1, b, count);\n\t}\n\n\tif(walk[a][b+1] == '.'){\n\t\tcount++;\n\t\twalking(walk, a, b+1, count);\n\t}\n\n\treturn count;\n}\n\nint main(){\n\twhile(1){\n\t\tint W, H, a=0, b=0, count=0;\n\t\tstring str;\n\t\tvector<vector<char> > walk;\n\n\t\tcin>>W>>H;\n\t\tif((W == 0) && (H == 0))\n\t\t\tbreak;\n\n\t\twalk.resize(H+2);\n\t\tfor(int i=0;i<H+2;i++){\n\t\t\twalk[i].resize(W+2);\n\n\t\t\tif((i == 0) || (i == H+1)){\n\t\t\t\tfor(int j=0;j<W+2;j++)\n\t\t\t\t\twalk[i][j] = '#';\n\t\t\t}else{\n\t\t\t\twalk[i][0] = '#';\n\t\t\t\twalk[i][W+1] = '#';\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tcin>>str;\n\t\t\t\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\twalk[i][j+1] = str[j];\n\t\t}\n\t\t\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(walk[i][j] == '@'){\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = j;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<walking(walk, a, b, count)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvoid input_field(vector< vector< char > > &field, int w, int h);\nint reach_tile_num(vector< vector< char > > &field);\npair< int, int> search_start(vector< vector< char > > &field);\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint main(){\n  int w, h;\n\n  while(cin >> w >> h, w&&h){\n    vector< vector< char > >field(h+2, vector< char >(w+2, 0));\n    \n    input_field(field, w+2, h+2);\n    cout << reach_tile_num(field) << endl;\n  }\n}\n\n\nvoid input_field(vector< vector< char > > &field, int w, int h){\n  for(int y = 0; y < field.size(); y++){\n    for(int x = 0; x < field[y].size(); x++){\n      //cout << x << y << endl;\n      if(x == 0 || y == 0\n         || x == w-1 || y == h-1){\n\tfield[y][x] = '#';\n      }else{\n\tcin >> field[y][x];\n      }\n    }\n  }\n  //cout << \"input done\" << endl;\n}\n\nint reach_tile_num(vector< vector< char > > &field){\n  int sum = 0;\n  pair< int, int > start, cur;\n  stack< pair< int, int > > s;\n\n  start = search_start(field);\n  s.push(start);\n\n  while(!(s.empty())){\n    cur = s.top();\n    s.pop();\n    if(field[cur.second][cur.first] == '.'\n       || field[cur.second][cur.first] == '@'){\n      sum++;\n      for(int i = 0; i < 4; i++){\n        s.push(make_pair(cur.first+dx[i], cur.second+dy[i]));\n\tfield[cur.second][cur.first] = '#';\n      }\n    }\n  }\n  return sum;\n}\n\npair< int, int> search_start(vector< vector< char > > &field){\n  for(int y = 0; y < field.size(); y++){\n    for(int x = 0; x < field[y].size(); x++){\n      if(field[y][x] == '@') return make_pair(x,y);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef vector<string> VS;\nVS wrap(VS v,char c) {\n\tint R = v.size(), C = v[0].size();\n\tVS ret(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = v[i][j];\n\treturn ret;\n}\nint res ;\nconst int dr[] = { 0,0,1,-1 };\nconst int dc[] = { 1,-1,0,0 };\n\nvoid f(int r, int c,VS&x) {\n\tif (x[r][c] == '#')return;\n\tres++;\n\tx[r][c] = '#';\n\tREP(i, 4) {\n\t\tf(r + dr[i], c + dc[i], x);\n\t}\n}\nint main() {\n\tint R, C;\n\twhile (cin >> C >> R, R + C) {\n\t\tVS in(R);\n\t\tREP(i, R)cin >> in[i];\n\t\tin = wrap(in, '#');\n\t\tint sr, sc;\n\t\tREP(i, R + 2)REP(j, C + 2)if (in[i][j] == '@')sr = i, sc = j;\n\t\tres = 0;\n\t\tf(sr, sc, in);\n\t\tcout << res << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tfunction<void(int, int)> dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <map>\n#include <queue>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing namespace std;\n\ntemplate<class T>\nconstexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\n\nclass UnionFind {\n\n    int n;\npublic:\n    vector<int> uni;\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\nint main() {\n    int h, w;\n    while(cin >> w >> h, h|w){\n        UnionFind uf(h*w);\n        int dx[] {1, -1, 0, 0}, dy[] {0, 0, -1, 1};\n        vector<vector<int>> v(h+2, vector<int> (w+2, 0));\n        int sy = 0, sx = 0;\n        for (int i = 0; i < h; ++i) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; ++j) {\n                if(s[j] == '@') sy = i, sx = j;\n                if(s[j] != '#') v[i+1][j+1] = 1;\n            }\n        }\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if(v[i+1][j+1] == 0) continue;\n                for (int k = 0; k < 4; ++k) {\n                    if(v[i+1+dy[k]][j+1+dx[k]]){\n                        uf.unite(i*w+j, (i+dy[k])*w+(j+dx[k]));\n                    }\n                }\n            }\n        }\n        cout << -uf.uni[uf.root(sy*w+sx)] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> p;\n\nint field[22][22];\nbool visited[22][22];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint sx, sy;\n\nint main(){\n  int w, h;\n  char c;\n  while(cin >> w >> h, w|h){\n    memset(field, 0, sizeof(field));\n    memset(visited, false, sizeof(visited));\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        cin >> c;\n        if(c == '.') field[i][j] = 1;\n        if(c == '@') sx = i, sy = j;\n      }\n    }\n    queue<p> que;\n    int sum = 1;\n    visited[sx][sy] = true;\n    que.push(p(sx, sy));\n    while(!que.empty()){\n      p cur = que.front(); que.pop();\n      for(int i = 0; i < 4; i++){\n        int nx = cur.first + dx[i];\n        int ny = cur.second + dy[i];\n        if(nx < 0 || nx > 20) continue;\n        if(ny < 0 || ny > 20) continue;\n        if(visited[nx][ny]) continue;\n        if(field[nx][ny] == 0) continue;\n        visited[nx][ny] = true;\n        sum++;\n        que.push(p(nx, ny));\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nvoid readVector(int n, vector<T> &v){\n\tfor(int i=0; i<n; ++i){\n\t\tT t;\n\t\tcin >> t;\n\t\tv.push_back(t);\n\t}\n}\ntypedef pair<long long, long long> P;\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nvoid solve(int w, int h){\n\tvector<string> v;\n\treadVector(h, v);\n\tint x = 0, y = 0, ans = 0;\n\tfor(int i=0; i<h; ++i)\n\t\tfor(int j=0; j<w; ++j)\n\t\t\tif(v[i][j] == '@')\n\t\t\t\tx = i, y = j;\n\tqueue<P> q;\n\tq.push(P(x, y));\n\tv[x][y] = ' ';\n\t++ans;\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tint nx = p.first;\n\t\tint ny = p.second;\n\t\tfor(int i=0; i<4; ++i){\n\t\t\tint a = nx + dx[i];\n\t\t\tint b = ny + dy[i];\n\t\t\tif(0<=a && 0<=b && a<h && b<w && v[a][b] == '.'){\n\t\t\t\tq.push(P(a, b));\n\t\t\t\tv[a][b] = ' ';\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tsolve(w, h);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define MP make_pair\ntypedef pair<int,int> pii;\n\nconstexpr int dx[4]={1,0,-1,0};\nconstexpr int dy[4]={0,1,0,-1};\n\nint main(){\n    int W,H;\n    while(cin>>W>>H){\n        if(W==0&&H==0) return 0;\n\n        vector<string> t(H);\n        vector<vector<bool>> used(H,vector<bool>(W,false));\n        for(int i=0;i<H;i++) cin>>t[i];\n\n        int sx,sy;\n        for(int i=0;i<H;i++) for(int j=0;j<W;j++) if(t[i][j]=='@'){\n            sx = i;\n            sy = j;\n        }\n        used[sx][sy]=true;\n\n        queue<pii> que;\n        que.push(make_pair(sx,sy));\n\n        while(que.size()!=0){\n            pii p = que.front();\n            que.pop();\n\n            int x = p.first;\n            int y = p.second;\n\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(nx>=0 && nx<H && ny>=0 && ny<W && t[nx][ny]!='#' && used[nx][ny]==false){\n                    used[nx][ny] = true;\n                    que.push(MP(nx,ny));\n                }\n            }\n        }\n\n        int cnt = 0;\n        for(int i=0;i<H;i++) for(int j=0;j<W;j++) if(used[i][j]==true) cnt++;\n        cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll W, H;\nll cnt;\n\nvoid dfs(vector<string> &A, ll x, ll y){\n    cnt++;\n    A[y][x]='#';\n\n    FOR(i, 0, 4){\n        ll tx = x + dx[i];\n        ll ty = y + dy[i];\n\n        if(0<=tx && tx<W && 0<=ty && ty<H && A[ty][tx]=='.'){\n            dfs(A, tx, ty);\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(;;){\n        cin >> W >> H;\n\n        if(W==0 && H==0){\n            return 0;\n        }\n\n        vector<string> A(H);\n        FOR(i, 0, H){\n            cin >> A[i];\n        }\n\n        ll start_x, start_y;\n        FOR(y, 0, H){\n            FOR(x, 0, W){\n                if(A[y][x]=='@'){\n                    start_x = x;\n                    start_y = y;\n                }\n            }\n        }\n\n        cnt = 0;\n        dfs(A, start_x, start_y);\n        p(cnt);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w, h;\nbool visited[20][20];\nvector<string> field;\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\n\nint dfs(const int x, const int y) {\n\tvisited[y][x] = true;\n\tint res = 1;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\tcontinue;\n\n\t\tif(!visited[ny][nx] && field[ny][nx] != '#')\n\t\t\tres += dfs(nx, ny);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tfield.clear();\n\t\tfield.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tint sx, sy;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tif(field[i][j] == '@')\n\t\t\t\t\tsx = j, sy = i;\n\n\t\tmemset(visited, false, sizeof(visited));\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 1000; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dxdy[4][2] = { {-1,0}, {1,0}, {0,1}, {0,-1} };\n\nint fill(vector<vector<char> >& v, int mi, int mj){\n    int sum = 0;\n    for(int i=0; i < 4; ++i){\n        if(v[ mi+dxdy[i][0] ][ mj+dxdy[i][1] ] == '.'){\n            sum++;\n            v[mi+dxdy[i][0]][mj+dxdy[i][1]] = ':';\n            sum += fill(v, mi + dxdy[i][0], mj + dxdy[i][1]);\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int w, h;\n    int mi, mj;\n    char c;\n    while(true){\n        cin >> w;\n        cin >> h;\n        if(w == 0 && h == 0) break;\n        vector<vector<char> > v(w+2, vector<char>(h+2));\n        for(int j = 0; j <= h+1; ++j){\n            for(int i = 0; i <= w+1; ++i){\n                if(i == 0 || j == 0 || i == w+1 || j == h+1 ){\n                    v[i][j] = '#';\n                } else {\n                    cin >> c;\n                    if(c == '@') {\n                        mi = i, mj = j;\n                        c = ':';\n                    }\n                    v[i][j] = c;\n                }\n            }\n            if( j >= 1 && j <= h ) cin.ignore();\n        }\n\n        cout << fill(v, mi, mj) + 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint h, w;\n\nint solve(bool used[20][20], char s[21][21], int x, int y){\n  int res = 0;\n  if(s[y][x] == '#'){\n    return 0;\n  }else{\n    res++;\n  }\n\n  REP(i,4){\n    int next_x = x + dx[i], next_y = y + dy[i];\n    if(next_x >= 0 && next_x < w && next_y >= 0 && next_y < h){\n      if(!used[next_y][next_x]){\n        used[next_y][next_x] = true;\n        res += solve(used, s, next_x, next_y);\n      }\n    } \n  }\n  return res;\n}\n\nint main(){\n\n  while(true){\n    scanf(\"%d %d\", &w, &h);\n    if(h == 0 && w == 0){\n      break;\n    }\n\n    char s[21][21];\n    REP(i,h){\n      scanf(\"%s\", s[i]);\n    }\n\n    bool found = false;\n    REP(i,h){\n      REP(j,w){\n        if(s[i][j] == '@'){\n          bool used[20][20] = {};\n          used[i][j] = true;\n          int ans = solve(used, s, j, i);\n          printf(\"%d\\n\", ans);\n          break;\n          found = true;\n        }\n      }\n      if(found) break;\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nchar field[20][20];\nint w, h;\nint cnt = 0;\n\nint dfs(int x, int y){\n    field[x][y] = '#';\n    cnt++;\n\n    for(int dx=-1; dx<=1; dx++){\n        for(int dy=-1; dy<=1; dy++){\n            if(dx!=0 && dy!=0) continue;\n            int nx = x + dx;\n            int ny = y + dy;\n            if(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] == '.') dfs(nx,ny);\n        }\n    }\n\n\n}\n\nint main(){\n    while(cin >> w >> h){\n        if(w==0 && h==0) break;\n        char line[w];\n        int start_x, start_y;\n        REP(j,h){\n            cin >> line;\n            REP(i,w){\n                if(line[i] == '@'){\n                    start_x = i;\n                    start_y = j;\n                    field[i][j] = '.';\n                }\n                field[i][j] = line[i];\n            }\n        }\n        cnt = 0;\n        dfs(start_x, start_y);\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint h,w;\nchar s[20][20];\n\nvoid dfs(int y,int x){\n\tif((x<0)||(w<=x)||(y<0)||(h<=y)){\n\t\treturn;\n\t}\n\tif((s[y][x]=='.')||(s[y][x]=='@')){\n\t\ts[y][x]='x';\n\t}else{\n\t\treturn;\n\t}\n\tdfs(y,x+1);\n\tdfs(y,x-1);\n\tdfs(y+1,x);\n\tdfs(y-1,x);\n}\n\nint main(){\n\twhile(cin >> w >> h,h){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]!='@');\n\t\t\t\telse{\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\tj=w;\n\t\t\t\t\ti=h;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(s[i][j]=='x')\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nclass place{\npublic:\n\tint x;\n\tint y;\n};\n\nint main(){\n\tint W,H;\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tbool dt[H][W];\n\t\tint startx,starty;\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tchar c;\n\t\t\t\tcin>>c;\n\t\t\t\tif(c=='.'){\n\t\t\t\t\tdt[i][j]=false;\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tdt[i][j]=true;\n\t\t\t\t}else{\n\t\t\t\t\tstartx=j;\n\t\t\t\t\tstarty=i;\n\t\t\t\t\tdt[i][j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<place> que;\n\t\tplace p;\n\t\tp.x=startx;\n\t\tp.y=starty;\n\t\tque.push(p);\n\t\tint cnt=0;\n\t\tint dirx[4]={1,0,-1,0};\n\t\tint diry[4]={0,1,0,-1};\n\t\twhile(!que.empty()){\n\t\t\tp=que.front();\n\t\t\tque.pop();\n\t\t\tif(!dt[p.y][p.x])cnt++;\n\t\t\tdt[p.y][p.x]=true;\n\t\t\trep(k,4){\n\t\t\t\tint nx=p.x+dirx[k];\n\t\t\t\tint ny=p.y+diry[k];\n\t\t\t\tif(nx>=0 && ny>=0 && nx<W && ny<H && !dt[ny][nx]){\n\t\t\t\t\tplace pp;\n\t\t\t\t\tpp.x=nx;\n\t\t\t\t\tpp.y=ny;\n\t\t\t\t\tque.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//bool c[22][22] = {};\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tp[i / 22][i % 22] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n//\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n//\t\t\t\tcase '.':\n//\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t/*\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\t\t\t//if (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t\t/*if (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\tprintf(\"a\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint cnt;\n\nvoid dp(char fld[20][20], int y, int x)\t{\n\t\n\tfld[y][x] = '#';\n\tcnt++;\n\t///\n\t//printf(\"%d %d\\n\", x, y);\n\t///\n\t\n\tfor (int dy = -1; dy <= 1; dy++)\t{\n\t\tfor (int dx = -1; dx <= 1; dx++)\t{\n\t\t\tif (dy != 0 && dx != 0)\tcontinue;\n\t\t\tif (y + dy < 0 || y + dy >= 20 || x + dx < 0 || x + dx >= 20)\tcontinue;\n\t\t\t\n\t\t\tif (fld[y+dy][x+dx] == '.')\t{\n\t\t\t\tdp(fld, y+dy, x+dx);\n\t\t\t}\n\t\t}\n\t}\t\n}\n\nint main()\t{\n\t\n\tint w, h, cy, cx;\n\tchar temp;\n\tchar fld[20][20];\n\t\n\twhile (true)\t{\n\t\t\n\t\tscanf(\"%d %d%*c\", &w, &h);\n\t\tif (w == 0)\tbreak;\n\t\t\n\t\t// initialize\n\t\tfor (int y = 0; y < 20; y++)\t{\n\t\t\tfor (int x = 0; x < 20; x++)\t{\n\t\t\t\tfld[y][x] = '#';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < h; i++)\t{\n\t\t\t///\n\t\t\t//printf(\"%d列目\\n\", i);\n\t\t\t///\n\t\t\tfor (int j = 0; j < w; j++)\t{\n\t\t\t\tscanf(\"%c\", &temp);\n\t\t\t\tfld[i][j] = temp;\n\t\t\t\t\n\t\t\t\tif (temp == '@')\t{\n\t\t\t\t\tcy = i;\n\t\t\t\t\tcx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (int y = 0; y < 20; y++)\t{\n\t\t\tprintf(\"%2d: \", y);\n\t\t\tfor (int x = 0; x < 20; x++)\t{\n\t\t\t\tprintf(\"%c\", fld[y][x]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\t\n\t\tcnt = 0;\n\t\t\n\t\tdp(fld, cy, cx);\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid checkboard(void);\nvoid startmove(void);\nint checked(int i,int j);\n\nchar board[20][20];\nint H,W,now[2];\n\nint main(void){\n\twhile(1){\n\t\tcin >> H >> W ;\n\t\tif (!H && !W) break;\n\t\t// count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j]=='@'){\n\t\t\t\t\tnow[0]=i;\n\t\t\t\t\tnow[1]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstartmove();\n\t\tcheckboard();\n\t}\n\n}\n\n\nvoid startmove(void){\n\tint n;\n\tdo{\n\t\tn=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@')\n\t\t\t\t\tn+=checked(i,j);\n\t\t\t}\n\t\t}\n\n\t}while(n);\n}\n\nint checked(int i,int j){\n\tint a=0;\n\tif(i>=0 && board[i-1][j]=='.'){\n\t\tboard[i-1][j]='@';\n\t\ta=1;\n\t}\n\tif(i<W && board[i+1][j]=='.'){\n\t\tboard[i+1][j]='@';\n\t\ta=1;\n\t}\n\tif(j>=0 && board[i][j-1]=='.'){\n\t\tboard[i][j-1]='@';\n\t\ta=1;\n\t}\n\tif(j<H && board[i][j+1]=='.'){\n\t\tboard[i][j+1]='@';\n\t\ta=1;\n\t}\n\t// checkboard();\n\treturn a;\n}\nvoid checkboard(void){\n\t\tint count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@') count++; \n\t\t\t\t// cout << board[i][j];\n\t\t\t}\n\t\t}\n\t\t\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool is[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (is[nx][ny]) continue;\n      is[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W && H) {\n      int x, y;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               x = i, y = j;\n            }\n         }\n      }\n\n      is[x][y] = true;\n      dfs(x, y);\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (is[i][j]) cnt++;\n         }\n      }\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nint w, h;\nchar map[21][21];\nint cnt;\n\nvoid dfs(int x, int y)\n{\n    cnt++;\n    map[y][x] = '#';\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx < 0 || ny < 0 || nx >= w || ny >= h) \n            continue;\n        else if (map[ny][nx] == '.') {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main()\n{\n    while (cin >> w >> h, w || h) {\n        int sx, sy;\n\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n                cin >> map[y][x];\n                if (map[y][x] == '@') {\n                    sx = x;\n                    sy = y;\n                }\n            }\n\n        cnt = 0;\n        dfs(sx, sy);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[4] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> C[i];\n\t\t}\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define line() cerr << \"---------------\" << endl;\n\nchar board[30][30];\nbool visited[30][30];\n\nint H, W;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W || H) {\n      memset(visited, false, sizeof(visited));\n\n      int sx = 0, sy = 0; // 人の座標\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      visited[sx][sy] = true;\n      dfs(sx, sy);\n\n      int ans = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) ans++;\n         }\n      }\n      cout << ans << endl;\n\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nint H, W;\nvector<string> field;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool seen[30][30];\n\nvoid dfs(pint x) {\n    seen[x.FI][x.SE] = true;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x.FI + dx[i];\n        int ny = x.SE + dy[i];\n        if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n            if (!seen[nx][ny] && field[nx][ny] != '#') {\n                dfs(MP(nx, ny));\n            }\n        }\n    }\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> W >> H) {\n        if (W == 0) break;\n        \n        field.clear();\n        for (int i = 0; i < H; ++i) {\n            string str;\n            cin >> str;\n            field.PB(str);\n        }\n        \n        pint start;\n        for (int i = 0; i < H; ++i) \n            for (int j = 0; j < W; ++j) \n                if (field[i][j] == '@')\n                    start = MP(i,j);\n        \n        memset(seen, 0, sizeof(seen));\n        dfs(start);\n        \n        int res = 0;\n        for (int i = 0; i < H; ++i)\n            for (int j = 0; j < W; ++j) \n                if (seen[i][j]) ++res;\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < H && nx >= 0 && nx < W && board[ny][nx] == '.') {\n         ret += dfs(y, x);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <utility>\n#include <unordered_set>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h && w > 0 && h > 0){\n        string tmp;\n        pair<int, int> init;\n        vector<vector <int> > grid(25, vector<int>(25, -1));\n        vector<vector <int> > visited(25, vector<int>(25, 0));\n        for(int i = 0; i < h; i++){\n            cin >> tmp;\n            for (int j = 0; j < w; j++){\n                if(tmp[j] == '.'){\n                    grid[i][j] = 0;\n                }else if(tmp[j] == '#'){\n                    grid[i][j] = -1;\n                }else if(tmp[j] == '@'){\n                    grid[i][j] = 0;\n                    init = make_pair(i, j);\n                }\n            }\n        }\n        /*for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                if(grid[i][j] == 0){\n                    if(i == init.first && j == init.second){\n                        cout << \"@\";\n                    }else{\n                        cout << \".\";\n                    }\n                }else if(grid[i][j] == -1){\n                    cout << \"#\";\n                }\n            }\n            cout << endl;\n        }\n        */\n        queue<pair<int, int> > Q;\n        Q.push(init);\n        visited[init.first][init.second] = 1; \n        while(!Q.empty()){\n            pair<int, int> cur = Q.front(); \n            Q.pop();\n            int cur_x = cur.first;\n            int cur_y = cur.second;\n            for(int i = 0; i < 4; i++){\n                pair<int, int> dst = make_pair(cur_x + dx[i], cur_y + dy[i]);\n                int x = dst.first;\n                int y = dst.second;\n                if(0 <= x && 0 <= y && grid[x][y] == 0 && visited[x][y] == 0){\n                    Q.push(dst);\n                    visited[x][y] = 1;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                ans += visited[i][j];\n            }\n        }\n        cout << ans << endl << endl << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nvoid dfs(int mx,int my);\n\n\tchar math[21][21];\n\tconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\tint cnt;\n\tint x,y;\n\tint sx,sy;\n\t\nint main(){\n\t\n\twhile(cin>>x>>y,x&&y){\n\t    cnt=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin>>math[i][j];\n\t\t\t\tif(math[i][j]=='@'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy);\n\t\tcout<<cnt+1<<endl;\n\t}\n}\n\nvoid dfs(int mx,int my){\n\tmath[my][mx]='T';\n\t//移動する方向\n\tfor(int i=0;i<4;i++){\n\t\tint nx=mx+dx[i],ny=my+dy[i];\n\t\t\n\t\tif(0<=nx && nx<x && 0<=ny && ny<y &&\n\t\t   (math[ny][nx]=='.' ||math[ny][nx]=='@')\n\t\t  )\n\t\t  {\n\t\t\tcnt++;\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n\treturn ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && B[ny][nx] == '.') ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      rep (i, H) cin >> B[i];\n      int sy = 0, sx = 0;\n      rep (i, H) rep (j, W) if (B[i][j] == '@') sy = i, sx = j;\n      cout << dfs(sy, sx) << endl;\n   }\n   \n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y,int count);\n\nint w,h;\nint dx[4]={0,-1,0,1};\nint dy[4]={-1,0,1,0};\nint sum=0;\nchar maps[21][21];\n\nint main(){\n  int sx,sy;\n  cin >> h >> w;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> maps[i][j];\n      if(maps[i][j]=='@'){\n\tsy=i;\n\tsx=j;\n      }\n    }\n  }\n  int ans = dfs(sx,sy,0);\n  cout << \"¥\" << ans << endl;\n}\n\nint dfs(int x,int y,int count){\n  int nx,ny;\n  for(int i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    maps[y][x]='#';\n    if(0<=nx && nx<w && 0<=ny && ny<h && maps[ny][nx]!='#'){\n      sum++;\n      dfs(nx,ny,count+1);\n    }\n  }\n  return sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define each(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};\n\nint w,h,res;\nchar field[30][30];\n\nvoid dfs(int y, int x){\n  int i;\n\n  rep(i,4){\n    int my = y + dy[i], mx = x + dx[i];\n    if(0 <= my && 0 <= mx && my < h && mx < w && field[my][mx] != '#'){\n      field[my][mx] = '#';\n      res++;\n      dfs(my,mx);\n    }\n  }\n}\n\nint main(){\n  int i,j;\n\n  while(true){\n    scanf(\"%d %d\",&w,&h);\n    if(w == 0 && h == 0) break;\n    res = 0;\n    rep(i,h) scanf(\"%s\",field[i]);\n    rep(i,h) rep(j,w) if(field[i][j] == '@') dfs(i,j);\n    printf(\"%d\\n\",res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<vector<bool>> d;\nvector<string> m;\nint w, h;\n\nvoid cal(ll x, ll y) {\n\tREP(i, 4) {\n\t\tll nx = x + dx[i];\n\t\tll ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && m[nx][ny] == '.' && !d[nx][ny]) {\n\t\t\td[nx][ny] = true;\n\t\t\tcal(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>w>>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tm.resize(h);\n\t\td.resize(h);\n\t\tREP(i, h) {\n\t\t\td[i].resize(w);\n\t\t\tREP(j, w) {\n\t\t\t\td[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tREP(i, h) cin>>m[i];\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(m[i][j] == '@') {\n\t\t\t\t\td[i][j] = true;\n\t\t\t\t\tcal(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(d[i][j]) ++ ans;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define each(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};\n\nint w,h,res;\nchar field[30][30];\n\nvoid dfs(int y, int x){\n  int i;\n\n  res++;\n  rep(i,4){\n    int my = y + dy[i], mx = x + dx[i];\n    if(0 <= my && 0 <= mx && my < h && mx < w && field[my][mx] != '#' && field[my][mx] != '@'){\n      field[my][mx] = '#';\n      dfs(my,mx);\n    }\n  }\n}\n\nint main(){\n  int i,j;\n\n  while(true){\n    scanf(\"%d %d\",&w,&h);\n    if(w == 0 && h == 0) break;\n    res = 0;\n    rep(i,h) scanf(\"%s\",field[i]);\n    rep(i,h) rep(j,w) if(field[i][j] == '@') dfs(i,j);\n    printf(\"%d\\n\",res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint W, H, sx, sy, cnt;\nvector<int> dxy = { 1, 0, -1, 0, 1 }; \nstring field[20];\n\nvoid fun(int y, int x){\n    field[y][x] = '#';\n    cnt++;\n    for(int i=0; i<4; ++i){\n        int ny = y + dxy[i+1],\n            nx = x + dxy[i];\n        if(ny < 0 || ny >= H ||nx < 0 || nx >= W || field[ny][nx] != '.') continue;\n        fun(ny, nx);\n    }\n}\n    \nint main(){\n    while(cin >> W >> H, (W||H)){\n        cnt = 0;\n        string str;\n        cin.ignore();\n        for(int i=0; i<H; ++i){\n            cin >> field[i];\n        }\n        for(int i=0; i<H; ++i){\n            for(int j=0; j<W; ++j){\n                if(field[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        fun(sy, sx);\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint h,w;\nstring grid[20];\nbool visit[20][20];\n\nint dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};\n\nint rec(int y,int x){      //この場所から到達できるタイルの数を返す\n  if(visit[y][x])return 0; //もう来たことがあるならカウントしない\n  visit[y][x] = true;\n\n  int res = 1;             //今いるタイルですでに1枚到達\n  for(int i=0;i<4;i++){\n    int ny = y+dy[i], nx = x+dx[i];\n\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(grid[ny][nx] == '#')continue;\n    res += rec(ny,nx);     //次の場所から到達できる枚数を足す\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> w >> h,h){\n    for(int i=0;i<h;i++){\n      cin >> grid[i];\n      for(int j=0;j<w;j++)visit[i][j] = false;\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(grid[i][j] == '@')cout << rec(i,j) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint count;\nint w,h;\nint x,y;\nchar map[20][20];\n\nvoid tannkenn(int x,int y);\n\nint main()\n{\n\twhile(cin>>w>>h,w&&h){\n\tcount=0;\n\tfor(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> map[i][j];\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\ttannkenn(x,y);\n\tcout<<count<<endl;\n\t}\n\treturn 0;\n}\n\nvoid tannkenn(int x,int y)\n{\n\tcount++;\n\tmap[x][y]='#';\n\n\tif(x+1<h && map[x+1][y]=='.')\n\t\ttannkenn(x+1,y);\n\tif(y+1<w && map[x][y+1]=='.')\n\t\ttannkenn(x,y+1);\n\tif(x-1>=0 && map[x-1][y]=='.')\n\t\ttannkenn(x-1,y);\n\tif(y-1>=0 && map[x][y-1]=='.')\n\t\ttannkenn(x,y-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nvoid dfs(vector< vector<char> > &plane, int x, int y, int &ans){  \n  plane[x][y] = '#';\n  ans++;\n  for(int i=0; i<4; i++){\n    if(0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h)\n      if(plane[x + dx[i]][y + dy[i]] != '#')\n        dfs(plane, x + dx[i], y + dy[i], ans);\n  }\n  \n  return;\n}\n\nint main(){\n  while(true){\n    cin >> w >> h;\n    if(w == 0)\n      break;\n\n    int sx, sy;\n    vector< vector<char> > plane(w, vector<char>(h));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        cin >> plane[j][i];\n        if(plane[j][i] == '@'){\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n\n    int ans = 0;\n    dfs(plane, sx, sy, ans);\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region _head\n\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<utility>\n#include<regex>\n\nvoid Init() {\n\tstd::cin.tie(0); std::ios::sync_with_stdio(false);\n\tstruct Init_caller { Init_caller() { Init(); } }caller;\n}\n\n#pragma region _define\n\n#define int LL\n#define f(i,a,b) for(LL i=a;i<b;i++)\n#define rep(i,n) for(LL i=0;i<n;i++)\n#define rep2(i,j,a,h,w) for(LL i=0;i<h;i++)for(LL j=0;j<w;j++)cin>>a[i][j]\n#define f_vI(v,n) f(i,0,n)cin>>v[i]\n#define f_v2I(v1,v2,n) f(i,0,n)cin>>v1[i]>>v2[i]\n#define f_v3I(v1,v2,v3,n) f(i,0,n)cin>>v1[i]>>v2[i]>>v3[i]\n#define f_vO(v,n) f(i,0,n)cout<<v[i]<<endl\n#define ei else if\n#define all(a) a.begin(),a.end()\n#define size(s) ((LL)s.size())\n#define F first\n#define S second\n#define check() cout<<\"! ! !\"\n#define endl \"\\n\"\n#define _y() cout<<\"Yes\"<<endl\n#define _Y() cout<<\"YES\"<<endl\n#define _n() cout<<\"No\"<<endl\n#define _N() cout<<\"NO\"<<endl\n#define INT_INF 1<<29\n#define LL_INF 1LL<<60\n#define MOD 1000000007\n\n#pragma endregion\n\n\n\n\n\n#pragma region _using\n\nusing namespace std;\n\nusing LL = long long;\nusing st = string;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vvvd = vector<vvd>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vs = vector<st>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vvvb = vector<vvb>;\nusing qi = queue<int>;\nusing qc = queue<char>;\nusing qs = queue<st>;\nusing si = stack<int>;\nusing sc = stack<char>;\nusing ss = stack<st>;\nusing pi = pair<int, int>;\nusing ppi = pair<pi, int>;\nusing mll = map<int, int>;\nusing mcl = map<char, int>;\nusing msb = map<st, bool>;\nusing vpi = vector<pi>;\nusing vppi = vector<ppi>;\nusing qpi = queue<pi>;\n\n#pragma endregion\n\n//十字移動のみ\nint cross_x[] = { -1,0,0,1 };\nint cross_y[] = { 0,1,-1,0 };\n\n\n\nvoid y_n(bool p) {\n\tp ? _y() : _n();\n}\n\nvoid Y_N(bool p) {\n\tp ? _Y() : _N();\n}\n\nLL vmax(vi v, LL n) {\n\tint MAX = 0;\n\tf(i, 0, n) {\n\t\tMAX = max(MAX, v[i]);\n\t}\n\treturn MAX;\n}\n\nLL vmin(vi v, LL n) {\n\tint MIN = LL_INF;\n\tf(i, 0, n) {\n\t\tMIN = min(MIN, v[i]);\n\t}\n\treturn MIN;\n}\n\nLL gcd(LL a, LL b) {\n\tif (b == 0) {\n\t\tswap(a, b);\n\t}\n\tLL r;\n\twhile ((r = a % b) != 0) {\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn b;\n}\nLL lcm(LL a, LL b) {\n\treturn (a / gcd(a, b) * b);\n}\n\n//素数判定\nbool is_prime(int n) {\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n//素因数分解\nvoid dec_prime(int n) {\n\tint a = 2;\n\twhile (a*a <= n) {\n\t\tif (n % a == 0) {\n\t\t\tcout << a << endl;\n\t\t\tn /= a;\n\t\t}\n\t\telse {\n\t\t\ta++;\n\t\t}\n\t}\n\tcout << n << endl;\n}\n\n//エラトステネスの篩\nvoid sieve_prime(LL n) {\n\tvb s(n + 1, true);\n\tf(i, 2, n + 1) {\n\t\tfor (int j = 2; i*j <= n; j++) {\n\t\t\ts[i*j] = false;\n\t\t}\n\t}\n\tcout << \"2から\" << n << \"までの素数\" << endl;\n\tf(i, 2, n + 1) {\n\t\tif (s[i]) {\n\t\t\tcout << i << \" \";\n\t\t}\n\t}\n}\n\n//階乗計算\nLL factorial(LL n) {\n\tLL a = 1, ret = 1;\n\twhile (a < n) {\n\t\ta++;\n\t\tret *= a;\n\t\t//ret %= MOD;\n\t}\n\treturn ret;\n}\n\n\n#pragma endregion \n\nvi par;\n\nint root(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = root(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tif (root(x) == root(y)) {\n\t\treturn;\n\t}\n\telse {\n\t\tpar[root(x)] = root(y);\n\t\treturn;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\n\nstruct edge {\n\tint to;\n\tint cost;\n};\n\n/*****************************************************************************/\nsigned main() {\n\n\twhile (1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0)break;\n\t\tvs a(h);\n\t\trep(i, h) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (a[i][j] == '@') {\n\t\t\t\t\tqpi q;\n\t\t\t\t\tq.push({ j, i });\n\t\t\t\t\tans++;\n\t\t\t\t\ta[i][j] = '#';\n\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\tpi p = q.front(); q.pop();\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nx = p.first + cross_x[k];\n\t\t\t\t\t\t\tint ny = p.second + cross_y[k];\n\n\t\t\t\t\t\t\tif (nx < 0 || ny < 0 || w <= nx || h <= ny || a[ny][nx] == '#')continue;\n\n\t\t\t\t\t\t\tif (a[ny][nx] == '.')q.push({ nx,ny });\n\t\t\t\t\t\t\ta[ny][nx] = '#';\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF 1000000000\n\n\nint dy[4] = { -1, 0, 1, 0 };\nint dx[4] = { 0, 1, 0, -1 };\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W || H) {\n\t\tint fy, fx;\n\t\tchar field[21][21];\n\t\tbool visit[21][21] = {};\n\t\tREP(i, 0, H) REP(j, 0, W) {\n\t\t\tcin >> field[i][j];\n\t\t\tif (field[i][j] == '@') {\n\t\t\t\tfy = i;\n\t\t\t\tfx = j;\n\t\t\t\tvisit[i][j] = true;\n\t\t\t}\n\t\t}\n\n\t\tqueue<pair<int, int>> q;\n\t\tpair<int, int> pii;\n\t\tq.push(make_pair(fy, fx));\n\t\tvisit[fy][fx] = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tpii = q.front();\n\t\t\tq.pop();\n\n\t\t\tREP(k, 0, 4) {\n\t\t\t\tint y = pii.first + dy[k];\n\t\t\t\tint x = pii.second + dx[k];\n\t\t\t\tif (y < 0 || x < 0 || y >= H || x >= W) continue;\n\t\t\t\tif (field[y][x] == '#' || visit[y][x]) continue;\n\n\t\t\t\tvisit[y][x] = true;\n\t\t\t\tq.push(make_pair(y, x));\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tREP(i, 0, H) {\n\t\t\tREP(j, 0, W) {\n\t\t\t\tif (visit[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <complex>\nusing namespace std;\ntypedef complex<int> P;\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H && !(W == 0 && H == 0)) {\n    vector<string> grid(H);\n    P start;\n    for (int i = 0; i < H; i++) {\n      cin >> grid[i];\n      for (int j = 0; j < W; j++) {\n        if (grid[i][j] == '@') {\n          start = P(i, j);\n          grid[i][j] = '.';\n        }\n      }\n    }\n\n    queue<P> q;\n    q.push(start);\n    vector<vector<bool> > visited(H, vector<bool>(W, false));\n    visited[start.real()][start.imag()] = true;\n    int ans = 0;\n    while (!q.empty()) {\n      const P p = q.front();\n      q.pop();\n      ans++;\n\n      static const P dir[] = {P(-1,0), P(1,0), P(0,-1), P(0,1)};\n      for (int d = 0; d < 4; d++) {\n        const P next = p + dir[d];\n        if (0 <= next.real() && next.real() < H && 0 <= next.imag() && next.imag() < W\n            && grid[next.real()][next.imag()] == '.' && !visited[next.real()][next.imag()]) {\n          visited[next.real()][next.imag()] = true;\n          q.push(next);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <vector>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\nusing std::vector;\n\nint main(){\n\tint w,h;\n\tvector<string> f(30);\n\tvector< vector<int> > g(30,vector<int>(30,0));\n\tint count = 0;\n\tint count2 = 0;\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tcin >> f[i];\n\t\t}\n\n\n\n\t\tfor(int i = 0;i < h; i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tg[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tcount2 = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tif(f[i][j] == '@' && count== 0){\n\t\t\t\t\t\tg[i][j] = 1;\n\t\t\t\t\t\tcount2++;\n\t\t\t\t\t}else if(g[i][j] == 1){\n\t\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\t\tif(f[i-1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i-1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i-1][j] = 1;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tif(f[i+1][j] == '.'){\n\t\t\t\t\t\t\t\tif(g[i+1][j] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i+1][j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tif(f[i][j-1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j-1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j-1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tif(f[i][j+1] == '.'){\n\t\t\t\t\t\t\t\tif(g[i][j+1] == 0){\n\t\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tg[i][j+1] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(count == count2){\n\t\t\t\tcout << count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount = count2;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\n\nvoid dfs(int x, int y) {\n    num++;\n    \n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1 && room[y-1][x] == 0) dfs(x, y-1);\n    if (y+1 < h && room[y+1][x] == 0) dfs(x, y+1);\n    if (x-1 > -1 && room[y][x-1] == 0) dfs(x-1, y);\n    if (x+1 < w && room[y][x+1] == 0) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        if (w == 0 && h == 0) break;\n        \n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\nint ans = 0;\n\nvoid bfs(char **tile, int w, int h){\n  ans++;\n  tile[w][h] = '#';\n\n  if(tile[w][h-1] == '.')\n  bfs(tile, w, h-1);\n\n  if(tile[w][h+1] == '.')\n  bfs(tile, w, h+1);\n\n  if(tile[w-1][h] == '.')\n  bfs(tile, w-1, h);\n\n  if(tile[w+1][h] == '.')\n  bfs(tile, w+1, h);\n\n  return;\n}\n\n\nint main(){\n  int W,H,index_w,index_h;\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n\n    char **tile;\n    tile = new char* [H+2];\n    REP(i,H+2) tile[i] = new char[W+2];\n\n    REP(i,H+2){\n      REP(j,W+2){\n        if(i == 0 || i == H+1 || j == 0 || j == W+1) tile[i][j] = '#'; //sentry?\n        else scanf(\" %c\",&tile[i][j]);\n\n        if(tile[i][j] == '@') {\n          index_h = j;\n          index_w = i;\n        }\n\n      }\n    }\n\n    bfs(tile,index_w,index_h);\n\n    REP(i,H) delete[] tile[i];\n    delete[] tile;\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint flag[20][20];//?????°?????????0\nchar map[20][21];//y:x\nint count;\nint H,W;\nvoid search(int nx,int ny);\nmain(){\n    scanf(\"%d%d\",&W,&H);\n    while(H){\n        memset(flag,0,sizeof(flag));\n        memset(map,0,sizeof(map));\n        for(int i = 0;i < H;i++){\n            scanf(\"%s\",map[i]);\n        }\n        for(int i = 0;i < H;i++){\n            for(int j = 0;j < W;j++){\n                if(map[i][j] == '@'){\n                    count = 0;\n                    search(j,i);\n                    printf(\"%d\\n\",count);\n                }\n            }\n        }\n        scanf(\"%d%d\",&W,&H);\n    }\n}\nvoid search(int nx,int ny){\n    if(nx<0 || ny<0 || nx>W-1 || ny>H-1){\n        return;\n    }\n    if(map[ny][nx] == '#'){\n        return;\n    }\n    if(flag[ny][nx] == 0){\n        flag[ny][nx]++;\n        count++;\n        search(nx+1,ny);\n        search(nx-1,ny);\n        search(nx,ny+1);\n        search(nx,ny-1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tchar B[20][21];\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\tint ans=1;\n\t\trep(_,h*w){\n\t\t\trep(i,h) rep(j,w) if(B[i][j]=='@') {\n\t\t\t\trep(k,4){\n\t\t\t\t\tint y=i+dy[k],x=j+dx[k];\n\t\t\t\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='.') B[y][x]='@', ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid checkboard(void);\nvoid startmove(void);\nint checked(int i,int j);\n\nchar board[21][21];\nint H,W,now[2];\n\nint main(void){\n\twhile(1){\n\t\tcin >> H >> W ;\n\t\tif (!H && !W) break;\n\t\t// count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j]=='@'){\n\t\t\t\t\tnow[0]=i;\n\t\t\t\t\tnow[1]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstartmove();\n\t\tcheckboard();\n\t}\n\n}\n\n\nvoid startmove(void){\n\tint n;\n\tdo{\n\t\tn=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@')\n\t\t\t\t\tn+=checked(i,j);\n\t\t\t}\n\t\t}\n\n\t}while(n);\n}\n\nint checked(int i,int j){\n\tint a=0;\n\tif(i>0 && board[i-1][j]=='.'){\n\t\tboard[i-1][j]='@';\n\t\ta=1;\n\t}\n\tif(i<W && board[i+1][j]=='.'){\n\t\tboard[i+1][j]='@';\n\t\ta=1;\n\t}\n\tif(j>0 && board[i][j-1]=='.'){\n\t\tboard[i][j-1]='@';\n\t\ta=1;\n\t}\n\tif(j<H && board[i][j+1]=='.'){\n\t\tboard[i][j+1]='@';\n\t\ta=1;\n\t}\n\t// checkboard();\n\treturn a;\n}\nvoid checkboard(void){\n\t\tint count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@') count++; \n\t\t\t\t// cout << board[i][j];\n\t\t\t}\n\t\t}\n\t\t\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for (int i=(n)-1;i>=0;i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define REPS(i,f,n) for (int i=(f)-1;i>=(n);i--)\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n\nchar board[21][21];\nint w, h;\nint x, y;// ?????¨?????????\n\nvoid slove(void){\n\tint cnt = 0;\n\tqueue<pint> q;\n\tq.push(make_pair(y, x));//?????¨????????????queue?????\\??????\n\n\twhile(!q.empty()){\n\t\tpint now = q.front(); q.pop();\n\t\trep(i, 4){\n\t\t\tint nowy = now.fi + dy[i];\n\t\t\tint nowx = now.se + dx[i];\n\t\t\tif (0 <= nowy <= h - 1 && 0 <= nowx && nowx <= w - 1){\n\t\t\t\tif (board[nowy][nowx] == '.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tprintf(\"%d\\n\", cnt);\n\t\t\t\t\tboard[nowy][nowx] = 0;\n\t\t\t\t\tq.push(make_pair(nowy, nowx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt + 1);//?§?????????´????????\\??????\n\treturn;\n}\n\nvoid scan(int w, int h){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tcin >> board[i][j];\n\t\t\tif (board[i][j] == '@'){\n\t\t\t\ty = i; x = j;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\t/*\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tprintf(\"%c\", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tslove();\n\treturn;\n}\n\nint main(void){\n\trep(i, 1000){\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\t\tscan(w, h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nint x[4]={1,0,-1,0};\nint y[4]={0,1,0,-1};\nint func(int i,int j,int n,int m,vector<string>& in,int& co){\n  co++;\n  //cout<<co<<endl;\n  in[i][j]='!';\n  rep(k,4){\n    int nx=i+x[k];\n    int ny=j+y[k];\n    if(nx>=0 && nx<=n-1 && ny>=0 && ny<=m-1 && in[nx][ny]!='!' && in[nx][ny]=='.')func(nx,ny,n,m,in,co);\n  }\n  return co;\n}\nint main(){\n  int n,m;\n  while(cin>>m>>n,n||m){\n    vector<string>in(n);\n    int co=0;\n    rep(i,n)cin>>in[i];\n    rep(i,n)rep(j,m)if(in[i][j]=='@')co=func(i,j,n,m,in,co);\n    cout<<co<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring line[30];\nint w, h, x, y, sum;\n\nvoid countup(int x, int y){\n\tif(line[y][x] != '#'){\n\t\tline[y][x] = '#';\n\t\tcountup(x,y-1);\n\t\tcountup(x,y+1);\n\t\tcountup(x+1,y);\n\t\tcountup(x-1,y);\n\t\tsum++;\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif (!w && !h) break;\n\t\tsum = 0;\n\t\tfor(int i = 1;i<=h;i++){\n\t\t\tcin >> line[i];\n\t\t\tline[i] = \"#\" + line[i] + \"#\";\n\t\t\tfor(int j = 0;j<=w+1;j++){\n\t\t\t\tif(line[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tline[h + 1] = line[0] = \"#####################\";\n\t\tfor (int i = 0; i <= h + 1;i++) {\n\t\t\tcout << line[i] << endl;\n\t\t}\n\t\tcout << x << \" \" << y << endl;\n\t\tcountup(x, y);\n\t\tcout << sum << endl;\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\ntypedef vector <string> VS;\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int, LL> PIL;\ntypedef vector <PIL> VPIL;\n\n\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define sort(c) sort((c).begin(),(c).end())\n\n#define range(i,a,b) for(int i=(a); i < (b); i++)\n#define rep(i,n) range(i,0,n)\n\n#define MAX_INT 2147483647\n\ntypedef struct Coor{\n\tint x;\n\tint y;\n\tCoor(int cx,int cy){\n\t\tx = cx;\n\t\ty = cy;\n\t}\n} Coor;\n\nCoor dxy[] = {Coor(1,0), Coor(0,1), Coor(-1,0), Coor(0,-1)};\nstring field[20];\nint dfs(Coor here, Coor lb, Coor ub){\n\tint result = 0;\n\tif(field[here.y][here.x] != '#'){\n\t\tresult++;\n\t\tfield[here.y][here.x] = '#';\n\t\trep(i,4){\n\t\t\tCoor nxt = Coor(here.x + dxy[i].x, here.y + dxy[i].y);\n\t\t\tif (lb.x <= nxt.x && nxt.x < ub.x && lb.y <= nxt.y && nxt.y < ub.y)\n\t\t\t\tresult += dfs(nxt, lb, ub);\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tint W, H;\n\twhile (1){\n\t\tcin >> W >> H;\n\t\tif (!(W and H)) break; \n\t\trep(i,H) cin >> field[i];\n\t\trep(i,H) \n\t\t\trep(j,W) \n\t\t\tif (field[i][j] == '@') \n\t\t\t\tcout << dfs(Coor(j,i),Coor(0,0),Coor(W,H)) << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nstring field[];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == w || y == h) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W) {\n\t\tint ans = 0;\n\t\trep(i, H) cin >> s[i];\n\t\trep(i, H) rep(i, W) {\n\t\t\tif (s[i][j] == '@') solve(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n#define RED false\n#define BLACK true\n\nconst int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, 1, 0, -1 };\nint w,h;\n\nbool valid(int x, int y, const vector<vector<bool> >& area){\n  return 0 <= x && x < w && 0 <= y && y < h && area[x][y];\n}\n\nint main(){\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      return 0;\n\n    vector<vector<bool> > area(w, vector<bool>(h, BLACK));\n    pair<int, int> hito;\n    for(int i = 0; i < h; i++){\n      string line;\n      cin >> line;\n      for(int j = 0; j < w; j++){\n        if(line[j] == '#'){\n          area[j][i] = RED;\n        } else if(line[j] == '@'){\n          hito = { j, i };\n        }\n      }\n    }\n\n    queue<pair<int, int> > qu;\n    qu.push(hito);\n\n    vector<vector<bool> > visit(w, vector<bool>(h, false));\n    visit[hito.first][hito.second] = true;\n\n    int ans = 1;\n\n    while(!qu.empty()){\n      auto now = qu.front();\n      // cout << \"now: \" << now.first << \", \" << now.second << endl;\n      qu.pop();\n      for(int i = 0; i < 4; i++){\n        auto dst = make_pair( now.first + dx[i], now.second + dy[i] );\n        if(valid(dst.first, dst.second, area) && !visit[dst.first][dst.second]){\n          visit[dst.first][dst.second] = true;\n          ans++;\n          qu.push(dst);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(10000);\n    nexty.reserve(10000);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    kaisuu++;\n    cout << sum <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "//Red and Black\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint W, H;\nvector<string> mp;\nint dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n\nvoid solve(int x, int y){\n  if(x<0 || H<=x || y<0 || W<=y || mp[x][y]!='.')return;\n  mp[x][y]='A';\n  rep(i,4)solve(x+dir[i][0], y+dir[i][1]);\n}\n\nint main(){\n  while(true){\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    mp.clear();\n    rep(i,H){\n      string s;\n      cin>>s;\n      mp.push_back(s);\n    }\n    int sx, sy;\n    rep(i,H)rep(j,W)if(mp[i][j]=='@'){sx=i; sy=j; break;}\n    mp[sx][sy]='.';\n    solve(sx, sy);\n\n    int cnt=0;\n    rep(i,H)rep(j,W)if(mp[i][j]=='A')cnt++;\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    while (cin >> M >> N, N || M) {\n        vector<string> v(N);\n        for (auto& i: v) cin >> i;\n\n        int sx, sy;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (v[i][j] == '@') sx = i, sy = j;\n            }\n        }\n\n        queue<pair<int,int>> que;\n        que.push(make_pair(sx, sy));\n\n        vector<vector<int>> flag(N, vector<int>(M));\n        int count = 0;\n        while (que.size()) {\n            auto p = que.front();\n            que.pop();\n\n            int x = p.first;\n            int y = p.second;\n\n            if (flag[x][y]) continue;\n\n            count++;\n            flag[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx < N && 0 <= ny && ny < M && v[nx][ny] == '.' && !flag[nx][ny]) {\n                    que.push(make_pair(nx, ny));\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint H,W,count=0;\nchar **map;\nbool **isCount;\n\nbool valid(int x,int y)\n{\n    return x<=(W-1)&&x>=0&&y<=(H-1)&&y>=0;\n}\n\nvoid bfs(int x,int y)\n{\n    if(valid(x,y)&&map[y][x]!='#' && !isCount[y][x])\n    {\n        count++;\n        isCount[y][x]=true;\n        for(int i=0;i<4;i++)\n            bfs(x+dx[i],y+dy[i]);\n    }\n  /*int D[100];\n  for(int i=0;i<100;i++)\n    D[i]=-1;\n  queue<int>Q;\n  Q.push(src);\n  D[src]=0;\n  while(!Q.empty())\n    {\n      int cur=Q.front();\n      Q.pop();\n       for(int dst=0;dst<n;dst++)\n\t{\n\t  if(M[cur][dst]==1&&D[dst]==-1)\n\t    {\n\t      D[dst]=D[cur]+1;\n\t      Q.push(dst);\n\t    }\n    }\n    }\n    for(int i=0;i<n;i++)\n        cout<<i+1<<' '<<D[i]<<endl;\n        */\n}\n\n\n\nint main()\n{\n    int x,y;\n    cin>>W>>H;\n    while(W!=0&&H!=0)\n    {\n        isCount=new bool*[H];\n        map=new char*[H];\n        for(int i=0;i<H;i++)\n        {\n            isCount[i]=new bool[W];\n            map[i]=new char[W];\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;i<W;j++)\n                isCount[i][j]=false;\n        }\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n            {\n                cin>>map[i][j];\n                if(map[i][j]=='@')\n                {\n                    x=j;\n                    y=i;\n                }\n            }\n        }\n        bfs(x,y);\n        cout << count << endl;\n        delete map;\n        delete isCount;\n        cin>>W>>H;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W, H;\nchar b[20][20];\nint ans;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y) {\n\tans++;\n\tb[y][x] = '#';\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && b[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H , W) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tcin >> b[y][x];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (b[y][x] == '@') {\n\t\t\t\t\tans = 0;\n\t\t\t\t\tdfs(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nint d[20][20];\nconst int inf=1e8;\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)d[i][j]=inf;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      d[sy][sx]=0;\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(d[ni][nj]<=d[now.first][now.second]+1) continue;\n            d[ni][nj]=d[now.first][now.second]+1;\n            Q.push(pii(ni, nj));\n         }\n      }\n\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=(d[i][j]!=inf);\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 0;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 22\n\nint N, Q;\n\nint W, H;\nchar room[MAX][MAX];\nint startx, starty;\nvoid dfs(int y, int x, bool visited[][MAX], int& cnt) {\n\tint i;\n\trep(i, 4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (ny < 0 || H <= ny) continue;\n\t\tif (nx < 0 || W <= nx) continue;\n\t\tif (visited[ny][nx]) continue;\n\t\tif (room[ny][nx] == '#') continue;\n\t\tcnt++;\n\t\tvisited[ny][nx] = true;\n\t\tdfs(ny, nx, visited, cnt);\n\t}\n}\nsigned main(void)\n{\n\tint i, j, k, l;\n\twhile (1) {\n\t\tbool visited[MAX][MAX] = {};\n\t\tint cnt = 0;\n\t\tcin >> W >> H;\n\t\tif (W == 0) break;\n\t\trep(i, H) cin >> room[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (room[i][j] == '@') {\n\t\t\t\tstarty = i; startx = j;\n\t\t\t}\n\t\t}\n\t\tvisited[starty][startx] = true;\n\t\tdfs(starty, startx, visited, cnt);\n\t\tcout << cnt+1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n15 1\n##@........##..\n*/\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for (int i=(n)-1;i>=0;i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define REPS(i,f,n) for (int i=(f)-1;i>=(n);i--)\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n\nchar board[21][21];\nint w, h;\nint x, y;// ?????¨?????????\n\nvoid slove(void){\n\tint cnt = 0;\n\tqueue<pint> q;\n\tq.push(make_pair(y, x));//?????¨????????????queue?????\\??????\n\n\twhile(!q.empty()){\n\t\tpint now = q.front(); q.pop();\n\t\trep(i, 4){\n\t\t\tint nowy = now.fi + dy[i];\n\t\t\tint nowx = now.se + dx[i];\n\t\t\tif (0 <= nowy && nowy <= h - 1 && 0 <= nowx && nowx <= w - 1){\n\t\t\t\tif (board[nowy][nowx] == '.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tboard[nowy][nowx] = 0;\n\t\t\t\t\t//printf(\"board %c\\n\", board[nowy][nowx]);\n\t\t\t\t\tq.push(make_pair(nowy, nowx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tprintf(\"%c\", board[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t}\n\tprintf(\"%d\\n\", cnt + 1);//?§?????????´????????\\??????\n\treturn;\n}\n\nvoid scan(int w, int h){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tcin >> board[i][j];\n\t\t\tif (board[i][j] == '@'){\n\t\t\t\ty = i; x = j;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\n\tslove();\n\treturn;\n}\n\nint main(void){\n\trep(i, 1000){\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\t\tscan(w, h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n \n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nchar grid[100][100];\nint w,h;\nint ans=0;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool searched[100][100];\nint a=0,b=0;\n\nbool inrange(int x,int y){\n  if(x<0||y<0||x>h||y>w) return false;\n  else return true;\n}\n\nvoid search(int x,int y){\n  if((grid[x][y]=='.'||grid[x][y]=='@')&&searched[x][y]==false&&inrange(x,y)){\n\tsearched[x][y]=true;\n\tans++;\n\tREP(i,4) {\n\t  search(x+dx[i],y+dy[i]);\n\t}\n  }\n}\n\nint main(){\n  while(1){\n\tcin >> w >> h;\n\tif(w==0&&h==0) break;\n\tans = 0;\n\tREP(i,h){\n\t  REP(j,w){\n\t\tcin >> grid[i][j];\n\t\tsearched[i][j]=false;\n\t\tif(grid[i][j]=='@'){\n\t\t  a=i;\n\t\t  b=j;\n\t\t}\n\t  }\n\t}\n\tsearch(a,b);\n\n\tcout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nchar room[22][22]={0};\nbool visited[22][22]={0};\n\nint di[4]={0,1,0,-1}, dj[4]={-1,0,1,0};\n\nvoid init(){\n    for(int i=0;i<=20;++i){\n        for(int j=0;j<=20;++j){\n            visited[i][j] = false;\n            room[i][j] = '#';\n        }\n    }\n}\n\nint main(){\n    int h, w;\n    while(cin >> w >> h, w > 0){\n        init();\n        int si, sj;\n        for(int i=0;i<h;++i){\n            for(int j=0;j<w;++j){\n                cin >> room[i][j];\n                if(room[i][j] == '@'){\n                    si = i;\n                    sj = j;\n                }\n            }\n        }\n        queue<pair<int, int>> que;\n        que.push({si, sj});\n        visited[si][sj] = true;\n        int ans = 0;\n        while(!que.empty()){\n            auto cur = que.front(); que.pop();\n            ans++;\n            for(int k=0;k<4;++k){\n                int ni = cur.first+di[k], nj = cur.second+dj[k];\n                if(ni < 0 || ni >= h || nj < 0 || nj >= w)continue;\n                if(room[ni][nj] == '#')continue;\n                if(visited[ni][nj])continue;\n                visited[ni][nj] = true;\n                que.push({ni, nj});\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nint w, h;\nchar tiles[20][21];\n\nint dx[4] = { 0, 1, 0,-1};\nint dy[4] = { 1, 0,-1, 0};\n\nbool isRegion(int x, int y){\n    return x >= 0 && x < w && y >= 0 && y < h;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> tiles[i];\n            for(int j = 0; j < w; j++){\n                if(tiles[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        \n        int cnt = 0;\n        queue<pair<int, int> > q;\n        q.push(make_pair(sx, sy));\n        while(!q.empty()){\n            cnt++;\n            int x = q.front().first, y = q.front().second;\n            q.pop();\n            \n            for(int i = 0; i < 4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                \n                if(isRegion(nx, ny) && tiles[ny][nx] == '.'){\n                    tiles[ny][nx] = '#';\n                    q.push(make_pair(nx, ny));\n                }\n            }\n        }\n        cout << cnt << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= x*w*y*h;\n  return s;\n}\n\nint pointx(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint pointy(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  w = 1;\n  h = 1;\n  cin>>w>>h;\n  while(w!=0){\n    int a[25][25]={};\n    int sx,sy;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=pointx(cur,w);\n      y=pointy(cur,w);\n      if(x>=1&&a[x-1][y]==1&&d[x-1][y]==-1){\n\td[x-1][y]=0;\n\tq.push(point(cur-1,y,w,h));\n      }\n      if(x<=w-2&&a[x+1][y]==1&&d[x+1][y]==-1){\n\td[x+1][y]=0;\n\tq.push(point(cur+1,y,w,h));\n      }\n      if(y>=1&&a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,cur-w,w,h));\n      }\n      if(y<=h-2&&a[x][y+1]==1&&d[x][y+1]==-1){\n\td[x][y-1]=0;\n\tq.push(point(x,cur+w,w,h));\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout << t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w, h;\nchar ma[30][30];\nchar check[30][30];\nint mx[4] = {-1, 0, 1, 0};\nint my[4] = {0, -1, 0, 1};\nint ans;\n\nvoid Rec(int x, int y);\n\nint main(void){\n\twhile(1){\n\t\tans = 0;\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tscanf(\"%s\", ma[i]);\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(ma[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t\tcheck[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcheck[sy][sx] = 1;\n\t\tans++;\n\t\tRec(sx, sy);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\nvoid Rec(int x, int y){\n\tfor(int i=0; i<4; i++){\n\t\tint nx = x + mx[i];\n\t\tint ny = y + my[i];\n\n\t\tif(nx >= 0 && nx < w && ny >= 0 && ny < h && ma[ny][nx] == '.' && check[ny][nx] == 0){\n\t\t\tcheck[ny][nx] = 1;\n\t\t\tans++;\n\t\t\tRec(nx, ny);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint ans = 0,w,h;\nstring s[100];\n\nvoid solve(int x,int y){\n\n  if(s[x][y] == '#') return;\n  s[x][y] = '#';\n  ans++;\n\n  if(x+1 < h) solve(x+1,y);\n  if(y+1 < w) solve(x,y+1);\n  if(x-1 >= 0) solve(x-1,y);\n  if(y-1 >= 0) solve(x,y-1);\n   \n  return;\n}\n\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    ans = 0;\n\n    for(int i=0;i<h;i++) cin >> s[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(s[i][j] == '@') solve(i,j);\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm> \n#include<functional> \n#include<cassert>\n#include<numeric> // std::accumulate(vec.begin(),vec.end(),0) sum of element\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<map>\n#include<set>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef std::pair<int, int> P;\ntypedef vector<int> vi;\n\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define all(c) c.begin(),c.end()\n#define show(x) cout << #x << \" = \" << x << endl\n\n#define fi first\n#define se second\n#define pb push_back\n\n\n\n#define DEBUG\n\n\n// void print_vector(const std::vector<int> &t);\n// void unique_vector(std:: vector<int> &t);\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t);\ntemplate <class X>\nvoid unique_vector(std:: vector<X> &t);\n\n\nint w, h;\n\nvector<int> xl={-1, 0, 1, 0};\nvector<int> yl={0, 1, 0, -1};\n\nint main(){\n\n  vi ans;\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    vector<vector<char>> f(h, vector<char>(w));\n    queue<P> ser;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) {\n\tcin >> f[i][j];\n\tif(f[i][j] == '@')\n\t  ser.push(make_pair(i, j));\n      }\n    }\n    int c = 0;\n    while(!ser.empty()){\n      P t = ser.front();\n      ser.pop();\n      int y = t.fi, x = t.se;\n      // show(x); show(y);\n      if(f[y][x] == '@') f[y][x] = '#';\n      for(int i = 0; i < 4; i++) {\n\tint dx = x+xl[i], dy=y+yl[i];\n\t// cout << dx << ' ' << dy << endl;\n\t// show(dx); show(dy);\n\tif(dy < 0 || dy >= h || dx < 0 || dx >= w || f[dy][dx] == '#')\n\t  continue;\n\t\n\tif(f[dy][dx] == '.'){\n\t  c++;\n\t  ser.push(make_pair(dy, dx));\n\t  f[dy][dx] = '#';\n\t}\n      }\t\n      // for(int i = 0; i < h; i++) {\n      // \tfor(int j = 0; j < w; j++) {\n      // \t  cout << f[i][j] << ' ';\n      // \t}\n      // \tcout << endl;\n      // }\n      // cout << endl;\n    }\n    ans.pb(c+1);\n  }\n  for(auto &i : ans) cout << i << endl;\n}\n\ntemplate <class X>\nvoid unique_vector(std::vector<X> &t)\n{\n  std::sort(t.begin(), t.end());\n  t.erase( std::unique(t.begin(), t.end()), t.end() );\n}\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t){\n  for(auto itr=t.begin(); itr != t.end(); itr++){\n    std::cout << *itr;\n    if(itr != t.end()-1) std::cout << ' ';\n  }\n  std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\nint sx,sy;\n\nvoid solve(){\n    vector<string> t(h);\n    rep(i,h) cin >> t[i];\n\n    rep(i,h) rep(j,w) if(t[i][j]=='@'){\n        sx = i;\n        sy = j;\n        break;\n    }\n\n    bool visited[32][32];\n    rep(i,32) rep(j,32) visited[i][j]=false;\n    visited[sx][sy]=true;\n    queue<pii> que;\n    que.push(pii(sx,sy));\n    while(!que.empty()){\n        auto p = que.front();\n        que.pop();\n\n        int x = p.fi;\n        int y = p.se;\n\n        rep(i,4){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx<0 or ny<0 or nx>=h or ny>=w) continue;\n            if(t[nx][ny]=='#') continue;\n            if(visited[nx][ny]) continue;\n\n            visited[nx][ny] = true;\n            que.push(pii(nx,ny));\n        }\n    }\n\n    int ans = 0;\n    rep(i,h) rep(j,w) if(visited[i][j]) ans++;\n    cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0 and h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define rep(i,n) for(ll i=0;i<(n);i++)\nchar maze[20][20];\nbool reached[20][20];\nll w,h;\nvoid search(ll x,ll y){\n  if(x<0 || w<=x || y<0 || h<=y) return;\n  if(maze[y][x]=='#') return;\n  if(reached[y][x]) return;\n  reached[y][x]=true;\n  search(x-1,y);\n  search(x+1,y);\n  search(x,y-1);\n  search(x,y+1);\n}\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    rep(i,h) rep(j,w) reached[i][j]=false;\n    ll sx,sy;\n    rep(i,h) rep(j,w) cin>>maze[i][j];\n    rep(i,h) rep(j,w){\n      if(maze[i][j]=='@'){\n        sx=j;\n        sy=i;\n      }\n    }\n    search(sx,sy);\n    ll ans=0;\n    rep(i,h) rep(j,w) if(reached[i][j]) ans++;\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define H 20\n\nstring field[H];\nint w, h; \n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint no_black = 0;\nvoid count(int x, int y) {\n    if (x < 0 || w <= x || y < 0 || h <= y || field[y][x] == '#') return;\n    field[y][x] = '#'; no_black++;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        count(nx, ny);\n    }\n}\n\nvoid init() {\n    no_black = 0;\n}\n\nint main() {\n    int x, y;\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        init();\n        for (int i = 0; i < h; i++) {\n            cin >> field[i];\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == '@') {\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n        count(x, y);\n        cout << no_black << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j) for(int (i)=0;(i)<(int)(j);++(i))\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main() {\n    int w, h;\n    char f[20][20];\n    while (cin >> w >> h && w && h) {\n        int c = 1;\n        queue<pair<int, int>> q;\n        rep(y,h) {\n            rep(x,w) {\n                cin >> f[y][x];\n                if (f[y][x] == '@') {\n                    q.push({x, y});\n                    f[y][x] = 'x';\n                }\n            }\n        }\n        while (q.size()) {\n            pair<int, int> p = q.front(); q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = p.first+dx[i];\n                int ny = p.second+dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && f[ny][nx] == '.') {\n                    ++c;\n                    q.push({nx, ny});\n                    f[ny][nx] = 'x';\n                }\n            }\n        }\n        cout << c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define W 21\n#define H 20\n\nint tileCount(char room[H][W], int row, int col, int h, int w);\n\nint main()\n{\n  char room[H][W];\n  int h;    // 部屋の行方向のタイルの枚数\n  int w;    // 部屋の列方向のタイルの枚数\n  int row;  // 最初に人が立っている行位置\n  int col;  // 最初に人が立っている列位置\n  int i, j;\n\n  // 部屋の情報を、配列room[]に文字列として読み込む\n  scanf(\"%d%d\", &w, &h);\n  while (h != 0 && w != 0) {\n    for (i = 0; i < h; i++) {\n      scanf(\"%s\", room[i]);\n      for (j = 0; j < w; j++) {\n        if (room[i][j] == '@') {\n          row = i;  // 最初に人が立っている行位置\n          col = j;  // 最初に人が立っている列位置\n        }\n      }\n    }\n    printf(\"%d\\n\", tileCount(room, row, col, h, w));\n\n    scanf(\"%d%d\", &w, &h);\n  }\n  \n  return(0);\n}\n\nint tileCount(char room[H][W], int row, int col, int h, int w){\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  int nx,ny;\n  int i,j;\n  int cnt=1;\n  if(row<0 || col<0 || col>=w || row>=h || room[row][col]=='#')return 0;\n  room[row][col]='#';\n  for(i=0;i<4;i++){\n    nx=col+dx[i];\n    ny=row+dy[i];\n    cnt+=tileCount(room,ny,nx,h,w);\n  }\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint W,H;\nint x[4]={0,0,1,-1};\nint y[4]={1,-1,0,0};\nint i,j;\nint count=0;\nchar room[100][100];\n\nint dfs(int, int);\n\nint main(){\n  while(1){\n    int sy,sx;\n    scanf(\"%d %d\",&W,&H);\n    if(W==0&&H==0)break;\n    for(i = 0 ; i < H ; i++){\n      scanf(\"%c\",&room[i][0]);\n      for(j = 0 ; j < W ; j++){\n\tscanf(\"%c\",&room[i][j]);\n\tif(room[i][j] == '@'){\n\t  sy = i;\n\t  sx = j; \n\t}\n      }\n    }\n    printf(\"%d\\n\", dfs(sx,sy));\n  }\n  return 0;\n}\n\nint dfs(int ax,int ay){\n  if(ax<0||ay<0)return 0;\n  if(ax>=W||ay>=H)return 0;\n  if(room[ay][ax]=='#')return 0;\n  room[ay][ax]='#';\n  int cnt=1;\n  int i;\n  for(i=0;i<4;i++){\n    int nx=ax+x[i];\n    int ny=ay+y[i];\n    cnt+=dfs(nx,ny);\n  }\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint W, H;\nstring s[30];\nusing P = pair<int, int>;\nvoid solve() {\n    P init;\n    rep(i, H) rep(j, W) if (s[i][j] == '@') init = P(i, j);\n    set<P> visited;\n    queue<P> que;\n    que.push(init);\n    visited.insert(init);\n\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        rep(k, 4) {\n            auto np = p;\n            np.first += dy[k];\n            np.second += dx[k];\n            if (np.first < 0 || np.second < 0) continue;\n            if (H <= np.first || W <= np.second) continue;\n            if (visited.count(np)) continue;\n            if (s[np.first][np.second] == '#') continue;\n\n            que.push(np);\n            visited.insert(np);\n        }\n    }\n    cout << visited.size() << endl;\n}\nint main() {\n    while (cin >> W >> H, W) {\n        rep(i, H) cin >> s[i];\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<vector<char> > field;\n\nint search(field &f, int x, int y)\n{\n    if(f[y][x]=='#') return 0;\n    f[y][x] = '#';\n    int res = 1;\n    if(f[y][x-1]!='#') res += search(f, x-1, y);\n    if(f[y][x+1]!='#') res += search(f, x+1, y);\n    if(f[y-1][x]!='#') res += search(f, x, y-1);\n    if(f[y+1][x]!='#') res += search(f, x, y+1);\n    return res;\n}\n\nint main()\n{\n    int w, h;\n    while(cin >> w >> h, w|h)\n    {\n        field f(h+2, vector<char>(w+2, '#'));\n        int sx, sy;\n        for(int y=0; y<=h+1; y++) f[y].assign(w+2, '#');\n        for(int y=1; y<=h; y++)\n        {\n            string ln;\n            cin >> ln;\n            for(int i=0; i<w; i++)\n            {\n                f[y][i+1] = ln[i];\n                int spos = ln.find('@');\n                if(spos>=0)\n                {\n                    sy = y;\n                    sx = spos + 1;\n                }\n            }\n        }\n        cout << search(f, sx, sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n\ntypedef pair<int, int>P;\n\n\nint w, h;\nint cnt;\nchar f[21][21];\nint dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };\n\nvoid rec(int x, int y) {\n  f[y][x] = '#';\n  cnt++;\n\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\n\tif (nx <= 0 || w < nx || ny <= 0 || h < ny||f[ny][nx]!='.')continue;\n\n\trec(nx, ny);\n  }\n}\n\nint main(){\n  while (cin >> w >> h,(w || h)) {\n\tint sx, sy;\n\tcnt = 0;\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tcin >> f[y][x];\n\t\tif (f[y][x] == '@') {\n\t\t  sx = x;\n\t\t  sy = y;\n\t\t}\n\t  }\n\t}\n\trec(sx, sy);\n\tcout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <valarray>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <list>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <deque>\n#include <unordered_set>\n#include <unordered_map>\n#include <regex>\n#include <array>\n#include <bitset>\n#include <complex>\n#include <tuple>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y, int &sum, vector<string> &field)\n{\n  field[y][x] = '#';\n  sum++;\n  for (int i = 0; i < 4; ++i)\n  {\n    int ny = y + dy[i], nx = x + dx[i];\n    if (0 <= ny && ny < field.size() && 0 <= nx && nx < field[0].size() && field[ny][nx] == '.')\n    {\n      dfs(nx, ny, sum, field);\n    }\n  }\n}\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h, w || h)\n  {\n    vector<string> field(h);\n    for (auto &e : field)\n      cin >> e;\n    int sx, sy;\n    for (int i = 0; i < h; ++i)\n    {\n      for (int j = 0; j < w; ++j)\n      {\n        if (field[i][j] == '@')\n        {\n          sy = i, sx = j;\n          field[i][j] = '#';\n        }\n      }\n    }\n    int sum = 0;\n    dfs(sx, sy, sum, field);\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n#define SUPMaxX 22\n#define SUPMaxY 22\n\ntypedef pair<int,int> Pii;\n\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\nint maxX,maxY;\nchar tizu[SUPMaxX][SUPMaxY];\nqueue<Pii> ps;\n\nint solve(){\n\tint re=1;\n\twhile(!ps.empty()){\n\t\tPii p=ps.front();\n\t\tps.pop();\n\t\tint px=p.F;\n\t\tint py=p.S;\n\t\tFOR(i,0,4){int qx=px+DX[i]; int qy=py+DY[i];\n\t\t\tif(tizu[qx][qy]=='.'){\n\t\t\t\ttizu[qx][qy]='@';\n\t\t\t\tps.push(make_pair(qx,qy));\n\t\t\t\tre++;\n\t\t\t}\n\t\t}\n\t}\n\treturn re;\n}\n\n\nint main(){\n\twhile(true){\n\t\tcin >> maxY >> maxX;\t\t\tif(!maxX) return 0;\n\t\tFOR(x,0,maxX+2) FOR(y,0,maxY+2) tizu[x][y]='#';\n\t\tFOR(x,1,maxX+1) FOR(y,1,maxY+1){\n\t\t\tcin>>tizu[x][y];\n\t\t\tif(tizu[x][y]=='@') ps.push(make_pair(x,y));\n\t\t}\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\nint w,h;\nstring matrix[20];\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nbool valid(int x,int y)\n{\n    return (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(matrix[y][x]!='#');\n}\nint main()\n{\n    while(true)\n    {\n        queue<pair<int,int> > q;\n        pair<int,int> man;\n        int amount=1;\n        \n        cin>>w>>h;\n        if(w==0&&h==0)\n            break;\n        for(int i=0;i<h;i++)\n        {\n            cin>>matrix[i];\n            //cout<<matrix[i]<<endl;\n        }\n        \n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {\n                if(matrix[i][j]=='@')\n                {\n                    man.first=j;\n                    man.second=i;\n                }\n            }\n        }\n        \n        q.push(man);\n        while(!q.empty())\n        {\n            pair<int,int> current;\n            current=q.front();\n            q.pop();\n            \n            for(int i=0;i<4;i++)\n            {\n\n                if(valid(current.first+dx[i],current.second+dy[i]))\n                {\n                    q.push(make_pair(current.first+dx[i],current.second+dy[i]));\n                    matrix[current.second+dy[i]][current.first+dx[i]]='#';\n                    amount++;\n                    //cout<<current.first+dx[i]<<\",\"<<current.second+dy[i]<<endl;\n                }\n            }\n            \n            matrix[current.second][current.first]='#';\n        }\n        \n        cout<<amount<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef pair<int,int> Pii;\n\nint main(){\n    int x[4]={0,1,0,-1};\n    int y[4]={1,0,-1,0};\n    while(1){\n        int w,h;\n        cin>>w>>h;\n        if(h==0&&w==0) break;\n        vector<string> tile(h);\n        vector<vector<bool> > checked(h,vector<bool>(w,false));\n        int cnt=0,sx,sy;\n        rep(i,h) cin>>tile[i];\n        rep(i,h) rep(j,w) if(tile[i][j]=='@'){sx=i;sy=j;}\n        stack<Pii> stk;\n        stk.push(Pii(sx,sy));\n        while(!stk.empty()){\n            int nx=stk.top().first,ny=stk.top().second;\n            stk.pop();\n            if(checked[nx][ny] || tile[nx][ny]=='#') continue; \n            checked[nx][ny]=true;\n            cnt++;\n            rep(k,4){\n                int dx=nx+x[k],dy=ny+y[k];\n                if(dx>=0 && dx<h && dy>=0 && dy<w) stk.push(Pii(dx,dy));\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int h,w;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    cin.ignore();\n    vector<string> s(h);\n    rep(i,h)cin>>s[i];\n    queue<pii> q;\n    vector<vi> used(h,vi(w,0));\n    rep(i,h)rep(j,w)if(s[i][j]=='@'){\n      q.push(pii(i,j));\n      used[i][j]++;\n    }\n    int d[5]={0,1,0,-1,0};\n    while(q.size()){\n      rep(i,4){\n\tint x=q.front().first+d[i];\n\tint y=q.front().second+d[i+1];\n\tif(x>=0 && x<h && y>=0 && y<w && \n\t   s[x][y]=='.' && used[x][y]==0){\n\t     used[x][y]++;\n\t     q.push(pii(x,y));\n\t}\n      }\n      q.pop();\n    }\n    int ans=0;\n    rep(i,h)rep(j,w)if(used[i][j])ans++;\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nstruct P{ P(int x, int y) : x(x), y(y) {} double x, y; };\n\nint main()\n{\n    int w, h;\n    while(cin >> w >> h && w)\n    {\n        vector<vector<char> > m(h, vector<char>(w));\n        P s(0, 0);\n        \n        rep(y, h) rep(x, w)\n        {\n            cin >> m[y][x];\n            if(m[y][x] == '@')\n                s = P(x, y);\n        }\n        \n        int res = 1;\n        queue<P> que;\n        for(que.push(s); !que.empty(); que.pop())\n        {\n            P p = que.front();\n            \n            int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n            rep(i, 4)\n            {\n                int nx = p.x + dx[i], ny = p.y + dy[i];\n                \n                if(0 <= nx && nx < w && 0 <= ny && ny < h && m[ny][nx] == '.')\n                {\n                    m[ny][nx] = '#';\n                    res++;\n                    \n                    que.push(P(nx, ny));\n                }\n            }\n        }\n        \n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\n\nint map[21][21], w, h;\n\nbool check(int j, int k) {\n\treturn (j >= 0 && j < h && k >= 0 && k < w && map[j][k] >= 1);\n}\n\nint main() {\n\twhile (1) {\n\t\tint sj, sk, j, k, diff[] = {-1, 0, 1, 0, -1}, ans;\n\t\tstring input;\n\t\tqueue<pair<int, int> > bfs;\n\n\t\tcin >> w >> h;\n\t\tif (w==0 && h==0) break;\n\n\t\tREP(j, h) { REP(k, w) map[j][k] = -1; }\n\t\tans = 0;\n\n\t\tREP(j, h) {\n\t\t\tcin >> input;\n\t\t\tREP(k, w) {\n\t\t\t\tmap[j][k] = (input[k] == '#') ? 0 : 1;\n\t\t\t\tif (input[k] == '@') {\n\t\t\t\t\tsj = j;\n\t\t\t\t\tsk = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbfs.push(make_pair(sj, sk));\n\t\tmap[sj][sk] = -1;\n\t\tans++;\n\n\t\twhile (!bfs.empty()) {\n\t\t\tj = bfs.front().first;\n\t\t\tk = bfs.front().second;\n\t\t\tbfs.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tif (check(j + diff[i], k + diff[i + 1])) {\n\t\t\t\t\t/*debug(j);\n\t\t\t\t\tdebug(k);\n\t\t\t\t\tdebug(j+diff[i]);\n\t\t\t\t\tdebug(k+diff[i+1]);*/\n\t\t\t\t\tbfs.push(make_pair(j + diff[i], k + diff[i + 1]));\n\t\t\t\t\tmap[j + diff[i]][k + diff[i + 1]] = -1;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint used[20][20];\nchar M[20][20];\nint W, H;\n\nbool in(int sx, int sy) {\n  return 0<=sx && sx<W && 0<=sy && sy<H;\n}\n\nint dfs(int x, int y) {\n  int res = 1;\n  used[y][x] = 1;\n  \n  const int dx[]={-1,1,0,0};\n  const int dy[]={0,0,-1,1};\n  for(int i=0; i<4; i++) {\n    int nx = x+dx[i], ny = y+dy[i];\n    if(in(nx, ny) && M[ny][nx] == '.' && !used[ny][nx])\n      res += dfs(nx, ny);\n  }\n  return res;\n}\n\nint main() {\n  \n  int stx, sty;\n  while(cin >> W >> H, (W|H)) {\n    memset(used, 0, sizeof(used));\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++) {\n\tcin >> M[i][j];\n\tif(M[i][j] == '@') {\n\t  stx = j, sty = i;\n\t  M[i][j] = '.';\n\t}\n      }\n    cout << dfs(stx, sty) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint W, H, sx, sy;\nchar T[20][20];\nbool visited[20][20];\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint dfs(int sy, int sx) {\n  int dd[5] = { 0, 1, 0, -1, 0 };\n  int ret = 1;\n\n  visited[sy][sx] = true;\n\n  REP(i, 0, 4) {\n    int ny = sy + dd[i + 0];\n    int nx = sx + dd[i + 1];\n    if(isin(ny, nx) && !visited[ny][nx] && T[ny][nx] != '#') ret += dfs(ny, nx);\n  }\n\n  return ret;\n}\n\nint main(void) {\n  while(cin >> W >> H, W) {\n    REP(i, 0, H) {\n      cin >> T[i];\n      REP(j, 0, W) {\n        if(T[i][j] == '@') {\n          sy = i;\n          sx = j;\n        }\n      }\n    }\n    REP(i, 0, H) REP(j, 0, W) visited[i][j] = false;\n\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(c,i) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint search(int i,int j,vector<string>& field)\n{\n    int r=field.size(),c=field[0].size();\n    if(i<0 || r<=i || j<0 || c<=j)\n        return 0;\n    if(field[i][j]=='#')\n        return 0;\n    field[i][j]='#';\n    int di[]={-1,1,0,0};\n    int dj[]={0,0,-1,1};\n    int sum=1;\n    rep(k,4)\n        sum+=search(i+di[k],j+dj[k],field);\n    return sum;\n}\n\nint main()\n{\n\tfor(int c,r;cin>>c>>r,c|r;){\n        vector<string> field(r);\n        rep(i,r)\n            cin>>field[i];\n        rep(i,r)\n            rep(j,c)\n                if(field[i][j]=='@')\n                    cout<<search(i,j,field)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\n\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define bit(i) static_cast<bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    FOR(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\nvoid cp(int a1[], int a2[], int l){FOR(i, l) a2[i] = a1[i];};\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nint h, w;\n\nint dfs(string tile[], int y, int x){\n    int count = 1;\n    // 上\n    if(y > 0 && tile[y-1][x] == '.'){\n        tile[y-1][x] = '#';\n        count += dfs(tile, y-1, x);\n    }\n    \n    // 下\n    if(y < h-1 && tile[y+1][x] == '.'){\n        tile[y+1][x] = '#';\n        count += dfs(tile, y+1, x);\n    }\n    \n    // 左\n    if(x > 0 && tile[y][x-1] == '.'){\n        tile[y][x-1] = '#';\n        count += dfs(tile, y, x-1);\n    }\n    \n    // 右\n    if(x < w-1 && tile[y][x+1] == '.'){\n        tile[y][x+1] = '#';\n        count += dfs(tile, y, x+1);\n    }\n    \n    return count;\n};\n       \nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> w >> h;\n        if(h == 0 && w == 0) return 0;\n        \n        string tile[20];\n        FOR(i, h) cin >> tile[i];\n        \n        int sy = 0, sx = 0;\n        FOR(i, h) FOR(j, w){\n            if(tile[i][j] == '@'){\n                sy = i; sx = j;\n                break;\n            }\n        }\n        \n        tile[sy][sx] = '#';\n        cout << dfs(tile, sy, sx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;else return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nbool solve(){\n\tll H,W;\n\tcin >> W >> H;\n\tll dx[] = {0,1,0,-1};\n\tll dy[] = {1,0,-1,0};\n \tif(H==0&&W==0)return false;\n\tstring tile[H];\n\tbool did[H][W];\n\tFOR(i,0,H)FOR(j,0,W)did[i][j]=false;\n\tFOR(i,0,H)cin >> tile[i];\n\tqueue<P> q;\n\tll ans = 0;\n\tFOR(i,0,H)FOR(j,0,W){\n\t\tif(tile[i][j]=='@'){\n\t\t\tq.push({i,j});\n\t\t\tans++;\n\t\t\tdid[i][j]=true;\n\t\t}else if(tile[i][j]=='#'){\n\t\t\tdid[i][j]=true;\n\t\t}\n\t}\n\twhile(not q.empty()){\n\t\tll x = q.front().first;\n\t\tll y = q.front().second;\n\t\tq.pop();\n\t\tFOR(i,0,4){\n\t\t\tif(x+dx[i]<H && x+dx[i]>=0 && y+dy[i]<W && y+dy[i]>=0){\n\t\t\t\tif(not did[x+dx[i]][y+dy[i]]){\n\t\t\t\t\tdid[x+dx[i]][y+dy[i]] = true;\n\t\t\t\t\tans++;\n\t\t\t\t\tq.push({x+dx[i],y+dy[i]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn true;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1){\n\t\tif(not solve())break;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nint W, H;\nint ans = 0;\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == W || y == H) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\trep(i, H) cin >> s[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (s[i][j] == '@') solve(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "'#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tauto dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}'\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define P pair<int, int>\n\nusing namespace std;\nchar field[20][20];\nint W, H,sx,sy,nx,ny;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nint cnt = 1;\n\n\nvoid bfs(){\n\tqueue<P> que;\n\tque.push(P(sx, sy));\n\n\twhile (1){\n\n\t\tif (que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tP p = que.front();\n\t\tque.pop();\n\t\t\n\t\trep(i, 4){\n\t\t\tnx = p.first + dx[i];\n\t\t\tny = p.second + dy[i];\n\t\t\tif (nx >= 0 && nx < W && 0 <= ny && ny < H && field[ny][nx] == '.'){\n\t\t\t\tfield[ny][nx] = '#';\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\n\t\trep(i, H){\n\t\t\trep(j, W){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\t*/\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0; tile[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0]; used[x][y]=1;\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y-1);\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y+1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w;\nqueue<P>q;\nchar c[25][25];\nint si,sj,ans=0;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nbool seen[25][25];\n\nvoid f(){\n        for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                        seen[i][j]=false;\n                }\n        }\n}\n\nvoid bfs(int x,int y){\n        q.push(P(x,y));\n        ans++;\n        seen[x][y]=true;\n        while(q.size()){\n                P p=q.front();q.pop();\n                for(int i=0;i<4;i++){\n                        int nx=p.first+dx[i],ny=p.second+dy[i];\n                        if(0<=nx&&nx<h&&0<=ny&&ny<w&&c[nx][ny]!='#'){\n                                if(!seen[nx][ny]){\n                                        seen[nx][ny]=true;\n                                        q.push(P(nx,ny));\n                                        ans++;\n                                }\n                        }\n                }\n        }\n        return;\n}\n\nint main(){\n        while(cin>>w>>h||w,h){\n                ans=0;\n                f();\n                for(int i=0;i<h;i++){\n                        for(int j=0;j<w;j++){\n                                cin>>c[i][j];\n                                if(c[i][j]=='@')si=i,sj=j;\n                        }\n                }\n                bfs(si,sj);\n                cout<<ans<<endl;\n        }\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\nint mod(ll a){\n    int c=a%1000000007;\n    if(c>=0)return c;\n    else return c+1000000007;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\n#define inf 100000000/*10^8*/\n\n/////////////////////////////////\n\nint w,h;\nint si,sj;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint room[25][25];\nint ans=0;\nint dfs(int x,int y){\n    room[x][y]=2;ans++;\n    for(int i=0;i<=3;i++){\n        int xx=x+dx[i],yy=y+dy[i];\n        if(0<=xx&&xx<=h-1&&0<=yy&&yy<=w-1&&room[xx][yy]==0)dfs(xx,yy);\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0)break;\n        ans=0;\n        for(int i=0;i<=h-1;i++){\n            char s[w+1];cin>>s;\n            for(int j=0;j<=w-1;j++){\n                if(s[j]=='.')room[i][j]=0;\n                else if(s[j]=='#')room[i][j]=1;\n                else if(s[j]=='@')room[i][j]=2,si=i,sj=j;\n            }\n        }\n        cout<<dfs(si,sj)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vec;\ntypedef pair<int, int> P;\n#define rep(n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define out(a) cout << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define INF 100000000\n\nint w, h, res = 1;\nchar f[25][25];\nint dy[] = { 1,0,-1,0 }, dx[] = { 0,1,0,-1 };\nint used[25][25] = { 0 };\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (0 <= ny&&ny < h && 0 <= nx&&nx < w&&f[ny][nx] == '.'&&used[ny][nx] == 0) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tres++;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tres = 1;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (f[i][j] == '@') {\n\t\t\t\t\tused[i][j] = 1;\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint W, H;\nint sx, sy;                 // ?????????????????§?¨?\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = { 0,-1, 1, 0};\n\nbool isVisited[MAX_N][MAX_N];\n\nint dfs(const vector<vector<char>>& masu, int x, int y) {\n    if (!isVisited[y][x] && masu[y][x] != '#') {\n        isVisited[y][x] = true;\n\n        int ret = 1;\n        for (int i = 0; i < 4; i++) {\n            if (0 <= x+dx[i] && x+dx[i] < W && 0 <= y+dy[i] && y+dy[i] < H) {\n                // cout << \"#: x=\" << x+dx[i] << \", y=\" << y+dx[i] << endl;\n                ret += dfs(masu, x+dx[i], y+dy[i]);\n            }\n        }\n\n        return ret;\n    }\n    return 0;\n}\n\nint main(void) {\n\n    while (cin >> W >> H, W) {\n        for (int i = 0; i < MAX_N; i++) {\n            for (int j = 0; j < MAX_N; j++) {\n                isVisited[i][j] = false;\n            }\n        }\n\n        vector<vector<char>> masu(H, vector<char>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> masu[i][j];\n                if (masu[i][j] == '@') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        cout << dfs(masu, sx, sy) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n\nusing namespace std;\nvoid checkPiece(int x, int y);//, char map[][]);\nvoid check(int x, int y);\nchar map[22][22];\nint flag = 1;\n\nint main(){\n\tint W, H;\n\twhile(1){\n\t\tint count = 0;\n\t\tint x, y;\n\t\tcin>>W>>H;\n\t\tif(W == 0 && H == 0) { return 0; }\n\t\t//char map[H+2][W+2];\n\t\t\n\t\tfor (int i = 0; i < H + 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < W + 2; ++j)\n\t\t\t{\n\t\t\t\tmap[j][i] = '#';\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i < H + 1; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j < W + 1; ++j)\n\t\t\t{\n\t\t\t\tcin>>map[j][i];\n\t\t\t\tif(map[j][i]=='@'){x = j; y = i;}\n\t\t\t}\n\t\t}\n\n\t\t//cout<<map[2][1]<<y<<endl;\n\t\tcheck(x, y);\n\twhile(flag){\n\t\tflag = 0;\n\t\tfor (int i = 1; i < H + 1; ++i)\n\t\t{\n\t\t\tfor (int j = 1; j < W + 1; ++j)\n\t\t\t{\n\t\t\t\t//cout<<i<<endl;\n\t\t\t\tcheck(j, i);\n\t\t\t}\n\t\t}\n\t\t//flag = 0;\n\t\t//cout<<flag<<endl;\n\t}\n/*\n\tfor (int i = 0; i < H + 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < W + 2; ++j)\n\t\t\t{\n\t\t\t\tcout<<map[j][i];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n*/\n\t\tfor (int i = 0; i < H + 2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < W + 2; ++j)\n\t\t\t{\n\t\t\t\tif(map[j][i] == '@'){ count++; }\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\n\t}\n\treturn 0;\n\n}\n\nvoid checkPiece(int x, int y){//, char map[][]){\n\tif(map[x][y] == '.') { map[x][y] = '@'; }\n\tif(map[x][y] == '@'){\n\t\tif(map[x+1][y] != '#') return checkPiece(x+1, y);\n\t\telse if(map[x-1][y] != '#') return checkPiece(x-1, y);\n\t\telse if(map[x][y+1] != '#') return checkPiece(x, y+1);\n\t\telse if(map[x][y-1] != '#') return checkPiece(x, y-1);\n\t}\n\treturn;\n}\n\nvoid check(int x, int y){\n\tif(map[x][y] == '@'){\n\t\tif(map[x+1][y] != '#' && map[x+1][y] == '.') { map[x+1][y] = '@'; flag = 1;}\n\t\tif(map[x-1][y] != '#' && map[x-1][y] == '.') { map[x-1][y] = '@'; flag = 1;}\n\t\tif(map[x][y+1] != '#' && map[x][y+1] == '.') { map[x][y+1] = '@'; flag = 1;}\n\t\tif(map[x][y-1] != '#' && map[x][y-1] == '.') { map[x][y-1] = '@'; flag = 1;}\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define EPS 1e-10\nusing namespace std;\ntypedef long long llong;\nvector<vector<char> >v;\nint w, h;\nint ans = 0;\nvoid dfs(int x, int y) {\n\tif (x < 0 || h <= x)return;\n\tif (y < 0 || w <= y)return;\n\n\tif (v[x][y] == '#')return;\n\n\tif (v[x][y] == '.'||v[x][y]=='@') {\n\t\tans++;\n\t\tv[x][y] = '#';\n\t\tdfs(x + 1, y);\n\t\tdfs(x - 1, y);\n\t\tdfs(x, y - 1);\n\t\tdfs(x, y + 1);\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> w >> h, h) {\n\t\tans = 0;\n\t\tint x, y;\n\t\tv = vector<vector<char> >(h, vector<char>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tif (v[i][j] == '@') {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W || H) {\n      memset(visited, false, sizeof(visited));\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      board[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define frp(i,n) for((i)=0;(i)<(n);i++)\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\nint H,W;\nint check(int n1,int n2,int rednum,vector<int> red1,vector<int> red2){\n  for(int i=0;i<rednum;i++){\n    if(n1==red1[i]&&n2==red2[i]||n1<0||n2<0||n1>=H||n2>=W){\n      return 0;\n    }\n  }\n  return 1;\n}\nint main(){\n  int i,j,now1,now2;\n  while(cin>>W>>H,W+H!=0){\n    int num=1;\n    string str2;\n    vector<string> str;\n    vector<int> red1;\n    vector<int> red2;\n    frp(i,H){\n      cin>>str2;\n      str.push_back(str2);\n    }\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='#'){\n\t  red1.push_back(i);\n\t  red2.push_back(j);\n\t}\n      }\n    }\n    queue<pair<int,int> > qii;\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='@'){\n\t  qii.push(make_pair(i,j));\n\t  red1.push_back(i);\n\t  red2.push_back(j);\n\t}\n      }\n    }\n    while(!qii.empty()){\n      now1=qii.front().first;\n      now2=qii.front().second;\n      qii.pop();\n      for(i=0;i<4;i++){\n\tif(check(now1+vx[i],now2+vy[i],red1.size(),red1,red2)==1){\n\t  red1.push_back(now1+vx[i]);\n\t  red2.push_back(now2+vy[i]);\n\t  qii.push(make_pair(now1+vx[i],now2+vy[i]));\n\t  num++;\n\t}\n      }\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint w,h;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nmain()\n{\n\twhile(cin>>w>>h,w)\n\t{\n\t\tqueue<pair<int,int> >P;\n\t\tstring s[22];\n\t\tint cnt=1;\n\t\tbool used[22][22]={};\n\t\tfor(int i=0;i<h;i++)cin>>s[i];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(s[i][j]=='@')\n\t\t\t{\n\t\t\t\tP.push(make_pair(i,j));\n\t\t\t\tused[i][j]=1;\n\t\t\t}\n\t\t}\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first,y=P.front().second;P.pop();\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=dx[r]+x,ty=y+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||s[tx][ty]=='#'||used[tx][ty])continue;\n\t\t\t\tused[tx][ty]=1;\n\t\t\t\tP.push(make_pair(tx,ty));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, cnt = 0;\nconst int MAX = 30;\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\nbool seen[MAX][MAX];\nchar C[MAX][MAX];\n\nvoid dfs(int x, int y){\n    seen[x][y] = true;\n    for(int i = 0; i < 4; i++){\n        int nx, ny;\n        nx = dx[i] + x;\n        ny = dy[i] + y;\n        if(nx < 0 or ny < 0 or nx >= n or ny >= m){\n            continue;\n        }\n        if(seen[nx][ny] or C[nx][ny] == '#'){\n            continue;\n        }\n        cnt++;\n        dfs(nx, ny);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> m >> n){\n        if(n == 0 and m == 0) return 0;\n        \n        int sx, sy;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                seen[i][j] = false;\n                cin >> C[i][j];\n                if(C[i][j] == '@'){\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n\n        cnt = 1;\n        dfs(sx, sy);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <assert.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  FOR(i,0,n)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(s) (s).begin(),(s).end()\n#define ITE(c) typeof((c).begin())\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))\n#define MP(a,b) make_pair((a),(b))\n\n#define MAX 20\n\nusing namespace std;\n\nint Map[MAX][MAX];\n\nint w, h;\nint sx, sy;\n\nint cou;\nint d_x[4]={-1,0,1,0};\nint d_y[4]={0,-1,0,1};\nvoid dfs(int x,int y){\n\tMap[x][y]=0;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+d_x[i];\n\t\tint ny=y+d_y[i];\n\t\tif(nx>=0&&nx<w&&ny>=0&&ny<h&&Map[nx][ny]){\n\t\t\tdfs(nx,ny);\n\t\t\tcou++;\n\t\t}\n\t}\n}\t\t\n\nvoid setMap(int i,int j,char s){\n\tswitch(s){\n\t\tcase '.':Map[i][j]=1;break;\n\t\tcase '#':Map[i][j]=0;break;\n\t\tcase '@':sx=i;sy=j;Map[i][j]=0;break;\n\t}\n}\n\n\nchar getMap(int i,int j){\n\tif(Map[i][j]){\n\t\treturn '.';\n\t}else{\n\t\treturn '#';\n\t}\n}\n\n\nint main(){\n\tchar s;\n\twhile(cin>>w>>h&&w||h){\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin>>s;\n\t\t\t\tsetMap(j,i,s);\n\t\t\t}\n\t\t}\n\t\tcou=1;\n\t\tdfs(sx,sy);\n\t\tcout<<cou<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nchar mp[21][21];\nint cnt = 0;\nint d_x[] = {0,1,0,-1};\nint d_y[] = {1,0,-1,0};\nint W,H;\n\nvoid dfs(int x,int y){\n  mp[y][x] = '#';\n  cnt++;\n  for(int d = 0;d<4;d++){\n    int nx = x+d_x[d],ny = y+d_y[d];\n      if((nx>=0)&&(ny>=0)&&(ny<H)&&(nx<W)&&(mp[ny][nx] == '.')){\n        dfs(nx,ny);\n      }\n  }\n}\nint main(){\n  cin >>W>>H;\n\n  while((W!=0)&&(H!=0)){\n    char mp[21][21] = {'0'};\n    cnt = 0;\n    for(int i = 0;i<H;i++){\n      for(int j = 0;j<W;j++){\n        cin >>mp[i][j];\n      }\n    }\n    for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                if (mp[y][x] == '@') {\n                    dfs(x, y);\n                }\n            }\n        }\n    cout <<cnt<<endl;\n    cin >>W>>H;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n//#include <unordered_map>\n//#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tint w, h;\n\twhile (std::cin >> w >> h) {\n\t\tif (w == 0 && h == 0) break;\n\t\tMAT(char, c, h, w);\n\t\tint dx4[] = { 0,1,0,-1 };\n\t\tint dy4[] = { -1,0,1,0 };\n\t\tint sy, sx;\n\t\tREP(i, h) REP(j, w) {\n\t\t\tif (c[i][j] == '@') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t}\n\t\tint cnt = 1;\n\t\tstd::function<void(int, int)> dfs = [&](int y, int x) {\n\t\t\tstd::vector<PAIR> v;\n\t\t\tREP(d, 4) {\n\t\t\t\tint dx = x + dx4[d];\n\t\t\t\tint dy = y + dy4[d];\n\t\t\t\tif (!IN(0, dx, w) || !IN(0, dy, h)) continue;\n\t\t\t\tif (c[dy][dx] != '.') continue;\n\t\t\t\tc[dy][dx] = 'w';\n\t\t\t\t++cnt;\n\t\t\t\tv.emplace_back(dy, dx);\n\t\t\t}\n\t\t\tfor (auto p : v) {\n\t\t\t\tdfs(p.first, p.second);\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tOUT(cnt)BR;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nchar tiles[21][21];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint ans=0;\nint w,h;\n\nvoid dfs(int x,int y){\n    tiles[x][y]='#';\n    ans++;\n\n    for(int i=0;i<4;i++){\n        int nx=x+dx[i],ny=y+dy[i];\n\n        if(0<=nx && nx<w && 0<=ny && ny<h &&\n          tiles[nx][ny] == '.') dfs(nx,ny);\n    }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n        tiles[i][j]='#';\n      }\n    }\n    ans=0;\n    cin >> w >> h;\n    if(w==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> tiles[j][i];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(tiles[j][i]=='@') dfs(j,i);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int (i)=0; (i)<(n); (i)++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint w, h;\nint m[20][20];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int nw, int nh){\n  REP(i, 4){\n    if(nw + dx[i] < 0 or nw + dx[i] >= w or nh + dy[i] < 0 or nh + dy[i] >= h) continue;\n    if(m[nw+dx[i]][nh+dy[i]] == 1) { m[nw+dx[i]][nh+dy[i]] = 2; dfs(nw+dx[i], nh+dy[i]); }\n  }\n  return;\n}\n\nint main(){\n  while(cin >> w >> h and w + h){\n    int sw, sh;\n    REP(i, h){\n      string str;\n      cin >> str;\n      REP(j, w) { m[j][i] = (str[j] == '#' ? -1 : 1); if(str[j] == '@') { sw = j; sh = i; m[j][i] = 2; } }\n    }\n    dfs(sw, sh);\n    int res = 0;\n    REP(i, h) REP(j, w) if(m[j][i] == 2) res++;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint ans;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\nvoid move(int x,int y){\n\tans++;\n\tmap[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\tmove(x+vec[i][0],y+vec[i][1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tans=0;\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmove(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <queue>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint main(int argc, char const *argv[])\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int h, w; cin >> w >> h, w | h;){\n\t\tVVI table(h, VI(w));\n\t\tPII goal;\n\t\tREP(i, h){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tREP(j, w){\n\t\t\t\tchar letter = line[j];\n\t\t\t\tint value = 0;\n\t\t\t\tif(letter == '@'){\n\t\t\t\t\tgoal = MP(i, j);\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}else if(letter == '#'){\n\t\t\t\t\tvalue = -1;\n\t\t\t\t}\n\t\t\t\ttable[i][j] = value;\n\t\t\t}\n\t\t}\n\t\tqueue<PII> q;\n\t\tq.push(goal);\n\t\tint total = 1;\n\t\twhile(!q.empty()){\n\t\t\tPII p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.second, y = p.first;\n\t\t\tint cv = table[y][x];\n\t\t\tREP(i, 4){\n\t\t\t\tint dx = x + DX[i];\n\t\t\t\tint dy = y + DY[i];\n\t\t\t\tif(0 <= dx && dx < w &&\n\t\t\t\t\t0 <= dy && dy < h &&\n\t\t\t\t\ttable[dy][dx] == 0){\n\t\t\t\t\ttotal++;\n\t\t\t\t\ttable[dy][dx] = 1;\n\t\t\t\t\tq.push(MP(dy, dx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << total << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n#define SUPMaxX 22\n#define SUPMaxY 22\n\ntypedef pair<int,int> Pii;\n\nint DX[4]={1,0,-1,0};\nint DY[4]={0,1,0,-1};\n\nint maxX,maxY;\nchar tizu[SUPMaxX][SUPMaxY];\nint re;\nint initX,initY;\n\nint dfs(int px, int py){\n\tre++;\n\tFOR(i,0,4){int qx=px+DX[i]; int qy=py+DY[i];\n\t\tif(tizu[qx][qy]=='.'){\n\t\t\ttizu[qx][qy]='@';\n\t\t\tdfs(qx,qy);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> maxY >> maxX;\t\t\tif(!maxX) return 0;\n\t\tFOR(x,0,maxX+2) FOR(y,0,maxY+2) tizu[x][y]='#';\n\t\tFOR(x,1,maxX+1) FOR(y,1,maxY+1){\n\t\t\tcin>>tizu[x][y];\n\t\t\tif(tizu[x][y]=='@'){initX=x; initY=y;}\n\t\t}\n\t\tre=0;\n\t\tdfs(initX,initY);\n\t\tcout<<re<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n\ntypedef pair<int, int> Pi;\n#define fi first\n#define se second\n\nint mx[] = {1, 0, -1, 0};\nint my[] = {0, 1, 0, -1};\n\nsigned main()\n{\n  int W, H;\n  char mas[25][25];\n  \n  \n  \n  while(cin >> W >> H, W || H) {\n    queue < Pi > que;\n    int ans = 1;\n    Rep(i, H) Rep(j, W) {\n      cin >> mas[i][j];\n      if(mas[i][j] == '@') {\n\tque.push(Pi(i, j));\n\tmas[i][j] = '#';\n      }\n      \n    }\n\n    while(!que.empty()) {\n      Pi d = que.front(); que.pop();\n      int y = d.fi, x = d.se;\n\n      Rep(i, 4) {\n\tint ny = y + my[i], nx = x + mx[i];\n\tif(ny < 0 || nx < 0 || ny >= H || nx >= W || mas[ny][nx] == '#') continue;\n\tans++, mas[ny][nx] = '#';\n\tque.push(Pi(ny, nx));\n      }\n    }\n\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<utility>\n#include<queue>\n\n#define REP(i,n) for(int i = 0;i < n ;i++)\n#define pa pair<int,int>\n#define pq queue< pair<int,int> >\n\t\n\nusing namespace std;\n\nint w,h;\nchar mp[22][22];\nbool dp[22][22];\nint dx[]={1,0,-1,0},dy[] = {0,1,0,-1};\nint sx,sy;\nint cou;\n\nint main()\n{\n\tfor(;;)\n\t{\n\t\tcin >> w >>h;\n\t\tif(w == 0 && h == 0) break;\n\t\tcou = 1;sx = 0;sy = 0;\n\t\tREP(i,22)REP(j,22)dp[i][j] = 0;\n\t\t\n\t\tREP(i,h)REP(j,w)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t\tif(mp[i][j] == '@'){sx = i;sy = j;}\n\t\t}\n\t\t\n\t\tpq p;\n\t\tp.push(make_pair(sx,sy));\n\t\tdp[sx][sy] = 1;\n//\t\tcout << sx << ' '<<sy<<endl;\n\t\twhile(!p.empty())\n\t\t{\n\t\t\tpa t = p.front();p.pop();\n\t\t\tREP(i,4)\n\t\t\t{\n\t\t\t\tint cx = t.first+dx[i],cy = t.second+dy[i];\n\t\t\t\tif(cx >= 0 && cx < h && cy >= 0 && cy < w)\n\t\t\t\tif( dp[cx][cy] == 0&& mp[cx][cy] != '#')\n\t\t\t\t{\n//\t\t\t\t\tcout << cx << ' ' <<cy << endl;\n\t\t\t\t\tp.push(make_pair(cx,cy));\n\t\t\t\t\tdp[cx][cy] = 1;\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t\t\n\t\tcout << cou << endl;\n\t}\n\treturn 0;\n}\n\t\t\n\t\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint W, H;\nconst int SIZE = 20;\nchar f[SIZE + 1][SIZE + 1];\nbool c[SIZE][SIZE];\n\nint dfs(int x, int y){\n\tif(x < 0 || y < 0 || x >= W || y >= H) return 0;\n\tif(c[y][x] || f[y][x] == '#') return 0;\n\tc[y][x] = true;\n\t\n\treturn 1 + dfs(x + 1, y) + dfs(x, y + 1) + dfs(x - 1, y) + dfs(x, y - 1);\n}\n\nint main(){\n\tint sx, sy;\n\t\n\twhile(true){\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif(H == 0 && W == 0) break;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", f[i]);\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < H; y++){\n\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\tc[y][x] = false;\n\t\t\t\tif(f[y][x] == '@'){\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dfs(sx, sy));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define ii inline int in\nii(int c) {\n\tint n = 0;\n\tbool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\t//return n; }\n\treturn minus ? -n : n; }\nii() {return in(gcu());}\ninline bool scan(int &n) {int c=gcu();return c==EOF?false:(n=in(c),true);}\nvoid scan(string &s) {for (char c; !isspace(c = gcu()); s += c);}\n#undef ii\n#define pcu putchar_unlocked\ntemplate <typename T>\nvoid out(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\tif(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nvoid out(const char *s){while(*s)pcu(*s++);}\nvoid out(char c){pcu(c);}\nvoid out(string &s){for (char c: s) pcu(c);}\ntemplate <typename head, typename... tail>\nvoid out(head&& h, tail&&... t){out(h);out(move(t)...);}\n//template <typename T>\n//void out(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\n//void out(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\n#undef svo\n\ntypedef vector<string> maze;\nint walk(int x, int y, maze &m) {\n\tstatic const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\tif (x < 0 || x >= (int) m[0].size() ||\n\t\ty < 0 || y >= (int) m.size() ||\n\t\tm[y][x] == '#' || m[y][x] == 'X')\n\t\treturn 0;\n\tm[y][x] = 'X';\n\tint c = 1;\n\tfor (int i = 0; i < 4; i++)\n\t\tc += walk(x + dx[i], y + dy[i], m);\n\treturn c;\n}\n\nint main() {\n\tint W, H;\n\twhile(scan(W) && scan(H) && (W || H)) {\n\t\tmaze m(H);\n\t\tint i = 0, x = 0, y = 0;\n\t\tfor (auto &s: m) {\n\t\t\tfor (int c; !isspace(c = gcu()); s += c)\n\t\t\t\tif (c == '@')\n\t\t\t\t\ty = i, x = s.size();\n\t\t\ti++;\n\t\t}\n\t\tout(walk(x, y, m), '\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(100);\n    nexty.reserve(100);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    kaisuu++;\n    cout << sum <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <cstdio>\n#include <bitset>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <cstring>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#define DEBUG_ //!!提出時にコメントアウト!!\n#ifdef DEBUG_\n\t#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#else\n\t#define dump(x)  ;\n#endif\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define eb emplace_back\n\n//#define int long long\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\n\ntemplate <typename T>\nstd::string printVector(const std::vector<T> &data)\n{\n    std::stringstream ss;\n    std::ostream_iterator<T> out_it(ss, \", \");\n    ss << \"[\";\n    std::copy(data.begin(), data.end() - 1, out_it);\n    ss << data.back() << \"]\";\n    return ss.str();\n}\n\nconst int MOD = 1e9+7;\nconst LL LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n\nsigned main(int argc, char const *argv[])\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int H,W; cin >> W >> H;\n        if(H == 0 && W == 0) break;\n\n        int visited[30][30] = {};\n        int masu[30][30] = {};\n        queue<PII> que;\n        int ans = 0;\n        int dx[] = {0,0,-1,1};\n        int dy[] = {-1,1,0,0};\n        REP(i,H){\n            string S; cin >> S;\n            REP(j,W){\n                if(S[j] == '.') masu[i][j] = 1;\n                else if(S[j] == '#') masu[i][j] = 2;\n                else{\n                    que.push(PII(i,j));\n                    visited[i][j] = 1;\n                    ans++;\n                }\n            }\n        }\n        while(!que.empty()){\n            auto p = que.front(); que.pop();\n            int nx = p.first;\n            int ny = p.second;\n            REP(i,4){\n                int x = nx + dx[i];\n                int y = ny + dy[i];\n                if(0 <= x && x < H && 0 <= y && y <= W && masu[x][y] == 1 && visited[x][y] == 0){\n                    que.push(PII(x,y));\n                    visited[x][y] = 1;\n                    ans++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nqueue<pair<int,int> > Q;\npair<int,int> P;\nint sum=0;\nint W,H;\nint ai,aj;\nchar x[25][25];\nint y[25][25];\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nbool valid(int a,int b){\n    if(0<=a && a<H && 0<=b && b<W && x[a][b]=='.'){\n        return 1;\n    }\n    else{\n        return 0;\n    }\n}\n\nint solve( ){\n    sum++;y[ai][aj]=1;\n    while(!Q.empty()){\n        pair<int,int> P2=Q.front();\n        Q.pop();\n        for(int i=0;i<4;i++){\n            if(valid(P2.first+dx[i],P2.second+dy[i])==1&&y[P2.first+dx[i]][P2.second+dy[i]]==0){\n                sum++;\n                y[P2.first+dx[i]][P2.second+dy[i]]=1;\n                P=make_pair(P2.first+dx[i],P2.second+dy[i]);\n                Q.push(P);\n            }\n        }\n    }\n    return sum;\n}\nvoid inits(){\n    sum=0;\n    for(int i=0;i<25;i++ ){\n        for(int j=0;j<25;j++){\n            x[i][j]=0;\n            y[i][j]=0;\n        }\n    }\n}\n\nint main(){\n    while(cin>>W>>H&&W!=0){\n        inits();\n        for(int i=0;i<H;i++)\n            for(int j=0;j<W;j++){\n                cin>>x[i][j];\n                if(x[i][j]=='@'){\n                    ai=i;aj=j;\n                }\n            }\n        P=make_pair(ai,aj);\n        Q.push(P);\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nstruct P\n{\n\tint x, y;\n};\n\nint W, H;\n\nint field[20][20];\n\nint main()\n{\n\tint x, y;\n\tchar c;\n\twhile( 1 )\n\t{\n\t\tcin >> W >> H;\n\t\tif(W==0 && H==0) break;\n\n\t\tmemset(field, 0, sizeof(int) * 400);\n\t\tfor(int j=0; j<H; j++)\n\t\t{\n\t\t\tfor(int i=0; i<W; i++)\n\t\t\t{\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '.')\n\t  \t\t\t\tfield[i][j] = 1;\n\t\t\t\telse if(c == '#')\n\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\telse if(c == '@')\n\t\t\t\t{\n\t\t\t\t\tfield[i][j] = 3;\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint offset[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\tint total = 1;\n\t\tqueue<P> que;\n\t\tP init_p = {x, y};\n\t\tque.push(init_p);\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\n\t\t\tint cx = p.x;\n\t\t\tint cy = p.y;\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tint xx = cx + offset[i][0];\n\t\t\t\tint yy = cy + offset[i][1];\n\t\t\t\tif(xx>=0 && yy>=0 && xx<W && yy<H)\n\t\t\t\t{\n\t\t\t\t\tif(field[xx][yy] == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tP new_p = {xx, yy};\n\t\t\t\t\t\tque.push(new_p);\n\t\t\t\t\t\tfield[xx][yy] = 4;\n\t\t\t\t\t\ttotal++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", total);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nchar S[22][22];\nint count = 0;\n\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n\nvoid a(int i, int j){\n\tif(S[i][j] == '.'){\n\t\tcount++;\n\t\tS[i][j] = '#';\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\ta(i + dy[k],j + dx[k]);\n\t\t}\n\t\t//a(i - 1, j);\n\t\t//a(i + 1, j);\n\t\t//a(i, j + 1);\n\t\t//a(i, j - 1);\n\t}\n}\n\n\nint main(){\n\twhile(true){\n\t\tmemset(S,'#',sizeof(S));\n\t\tcount = 0;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1; i < y + 1; i++){\n\t\t\tfor(int j = 1; j < x + 1; j++){\n\t\t\t\tcin >> S[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint startx, starty;\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tif(S[i][j] == '@'){\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t\tS[i][j] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta(starty, startx);\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <functional>\n#include<algorithm>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\n\nint W,H;\nchar a[30][30];\nvoid se(int x,int y,int (*re)[30],int *u){\n\t\n\tif(x<0||W<=x||y<0||H<=y||a[y][x]=='#')\n\t\treturn;\n\tif(re[y][x]==1)\n\t\treturn;\n\t\n\tre[y][x]=1;\n\t\t*u+=1;\n\t\n\tse(x+1,y,re,u);\n\tse(x-1,y,re,u);\n\tse(x,y+1,re,u);\n\tse(x,y-1,re,u);\n}\n\nint main(){\n\tint x,y;\n\tint x1,y1;\n\twhile(cin>>W>>H){\n\t\tif(W!=0&&H!=0){\n\t\t\tint re[30][30]={0};\n\t\t\tint u=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>a[i][j];\n\t\t\t\tif(a[i][j]=='@'){\n\t\t\t\tx1=j;\n\t\t\t\ty1=i;}\n\t\t\t}\n\t\t}\n\t\t\tse(x1,y1,re,&u);\n\t\t\t\tcout<<u<<endl;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '#';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\txy.pop();\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int h, w;\n        cin >> w >> h;\n        if (w == 0 && h == 0)\n            return 0;\n        vector<string> s(h);\n        for (int i = 0; i < h; ++i) {\n            cin >> s[i];\n        }\n        int sy, sx;\n        [&] {\n            for (int i = 0; i < h; ++i) {\n                for (int j = 0; j < w; ++j) {\n                    if (s[i][j] == '@') {\n                        sy = i;\n                        sx = j;\n                        return;\n                    }\n                }\n            }\n        }();\n        queue<pair<int, int>> q;\n        q.emplace(sy, sx);\n        const int dx[4] = {-1, 1, 0, 0};\n        const int dy[4] = {0, 0, -1, 1};\n        auto inside     = [&](int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; };\n        int ret         = 1;\n        while (q.size() != 0) {\n            auto p = q.front();\n            q.pop();\n            for (int i = 0; i < 4; ++i) {\n                int nx = p.second + dx[i];\n                int ny = p.first + dy[i];\n                if (inside(ny, nx) && s[ny][nx] == '.') {\n                    ret++;\n                    s[ny][nx] = '#';\n                    q.emplace(ny, nx);\n                }\n            }\n        }\n        cout << ret << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n    }\n    \n}\n\nint main(){\n    int x,y;\n    while(cin>>x>>y,x|y){\n        int startx,starty;\n        vector<vector<bool> > map;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <iomanip>\n#include <utility>\n#include <cstdlib>\n#include <sstream>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <ctime>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n\nconst double EPS = 1e-10;\nconst int INF = 100000000;\n\nint x,y;\nchar fie[100][100]={};\nchar visited[100][100]={};\nint c;\n\n\nvoid dfs(int sx,int sy){\n    if(sx<0 || sy<0 || sx>=x || sy>=y)return;\n    if(visited[sy][sx])return;\n    if(fie[sy][sx]!='.' && fie[sy][sx]!='@')return;\n    c++;\n    visited[sy][sx]=true;\n    \n    int d[5]={-1,0,1,0,-1};\n    rep(i,4){\n        dfs(sx+d[i],sy+d[i+1]);\n    }\n}\n\nint main(){\n    \n    \n    while(cin>>x>>y){\n        c=0;\n        rep(i,100)\n        rep(j,100)\n        visited[i][j]=false;\n        \n        int sx=-1,sy=-1;\n        if(x==0 && y==0)break;\n        \n        rep(i,y){\n            rep(j,x){\n                cin>>fie[i][j];\n                if(fie[i][j]=='@'){\n                    sx=j,sy=i;\n                }\n            }\n        }\n        dfs(sx,sy);\n        cout<<c<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<=30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nchar board[23 * 23];\nint way[4] = { -1,1,-23,23 };\nint gCount;\n\nvoid solve(int pos) {\n\tgCount++;\n\tboard[pos] = '#';\n\tfor (int i = 0; i < 4; i++) \n\t\tif (board[pos + way[i]] == '.') \n\t\t\tsolve(pos + way[i]);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint H, W;\n\twhile (cin >> W >> H, W) {\n\t\tfor (int i = 0; i < 23 * 23; i++)\n\t\t\tboard[i] = '#';\n\t\tgCount = 0;\n\t\tint s;\n\t\tfor (int y = 1; y <= H; y++)\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> board[y * 23 + x];\n\t\t\t\tif (board[y * 23 + x] == '@') \n\t\t\t\t\ts = y * 23 + x;\n\t\t\t}\n\t\tsolve(s);\n\t\tcout << gCount << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\nusing namespace std;\nchar field[21][21];\nchar visit[21][21];\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nint W,H;\nvoid dfs(int y, int x){\n  visit[y][x] = 1;\n  rep(i,4){\n    int ny = y+dy[i];\n    int nx = x+dx[i];\n    if(field[ny][nx] == '.'\n       && visit[ny][nx] == 0\n       && nx >= 0\n       && nx < W\n       && ny >= 0\n       && ny < H){\n          dfs(ny,nx);\n        }\n  }\n}\nint main(){\n  while(cin >> W >> H && W){\n    int y,x;\n    rep(i,H){\n      rep(j,W){\n        cin >> field[i][j];\n        if(field[i][j] == '@') y=i,x=j;\n      }\n    }\n    memset(visit,0,sizeof(visit));\n    dfs(y,x);\n    int ans = 0;\n    rep(i,H){\n      rep(j,W){\n        ans += visit[i][j];\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<memory>\n#include<cstdlib>\n\nusing namespace std;\nint W,H;\nvoid solve(int,int);\nchar dfs[20][20];\nint d_x[]={1,0,-1,0},d_y[]={0,1,0,-1};\n\nint main(){\n\t\n\twhile(1){\n\t\tint ans=0;\n\t\tcin>>W>>H;\n\t\tif(W==0&&H==0)\tbreak;\n\n\t\tint dx,dy;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>dfs[j][i];\n\t\t\t\tif(dfs[j][i]=='@'){\n\t\t\t\t\tdx=j;\n\t\t\t\t\tdy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(dx,dy);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(dfs[j][i]=='T')\n\t\t\t\t\tans++;\n\t\tcout<<ans<<endl;\n\t\tmemset(dfs,0,sizeof(dfs));\n\t}\n\treturn 0;\n}\n\nvoid solve(int x,int y){\n\tdfs[x][y]='T';\n\t\n\tfor(int j=0;j<4;j++){\n\t\tint mx=x+d_x[j],my=y+d_y[j];\n\t\tif(mx<0||my<0||mx>W||my>H)\tcontinue;\n\t\tif(dfs[mx][my]=='.')\n\t\t\tsolve(mx,my);\n\t}\n\treturn ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Point\n{\n  int i;\n  int j;\n};\n\nstatic Point minus_point = { -1, -1 };\n\nclass Map\n{\n  public:\n    Map(int height, int width);\n    ~Map();\n\n  public:\n    int Can_go_num(Point p = minus_point);\n\n  private:\n    bool CheckIndex(const Point& p);\n    bool isBlack(const Point& p);\n    bool CanMove(const Point& p);\n\n  private:\n    char** m_map;   //  '.' = black, '#' = red, '@' = start, 'x' = already\n    int m_height;\n    int m_width;\n    Point m_start;\n};\n\nMap::Map(int height, int width)\n{\n  m_height = height;\n  m_width = width;\n\n  m_map = new char*[m_height];\n  for (int i = 0; i < m_height; ++i)\n  {\n    m_map[i] = new char[m_width];\n  }\n\n  for (int i = 0; i < m_height; ++i)\n  {\n    for (int j = 0; j < m_width; ++j)\n    {\n      cin >> m_map[i][j];\n      if (m_map[i][j] == '@')\n      {\n        m_start.i = i;\n        m_start.j = j;\n      }\n    }\n  }\n}\n\nMap::~Map()\n{\n  for (int i = 0; i < m_height; ++i)\n  {\n    delete[] m_map[i];\n  }\n  delete[] m_map;\n}\n\nint Map::Can_go_num(Point p)\n{\n  int result = 1;\n  if (p.i == -1)\n  {\n    p = m_start;\n  }\n  m_map[p.i][p.j] = 'x';\n  Point buf_ps[4] = {\n    { p.i, p.j-1 },\n    { p.i, p.j+1 },\n    { p.i-1, p.j },\n    { p.i+1, p.j },\n  };\n  for (Point buf_p : buf_ps)\n  {\n    if (CanMove(buf_p) )\n    {\n      result += Can_go_num(buf_p);\n    }\n  }\n\n  return result;\n}\n\ninline bool Map::CheckIndex(const Point& p)\n{\n  return (0 <= p.i and p.i < m_height) and (0 <= p.j and p.j < m_width);\n}\n\ninline bool Map::isBlack(const Point& p)\n{\n  return m_map[p.i][p.j] == '.';\n}\n\ninline bool Map::CanMove(const Point& p)\n{\n  return CheckIndex(p) && isBlack(p);\n}\n\nint main(void)\n{\n  int height, width;\n  while (true)\n  {\n    cin >> width >> height;\n    if (height == 0 && width == 0) break;\n    Map map(height, width);\n    cout << map.Can_go_num() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  set<P> s;\n  while (q.size()) {\n    P p = q.front();\n    q.pop();\n    s.insert(p);\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        pair<set<P>::iterator, bool> r = s.insert(P(i, j));\n        if (r.second) q.push(*r.first);\n      }\n    }\n  }\n  return s.size();\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE + 1][MAX_SIZE + 1];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> f[i];\n      for (int j = 0; j < W; ++j) {\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\nusing Int = long long;\n\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int _x, int _y) :x(_x), y(_y){}\n};\n\nchar tile[20][20];\nstack<point> st;\n\nint main()\n{\n\tcin.tie(0); ios::sync_with_stdio(false); \n\tfstream fs(\"input.txt\");\n\t////////////ここから開始///////////\n\n\t\n\tint x(-1), y(-1);\n\twhile (x != 0 && y != 0){\n\t\tREP(i, 20)REP(j, 20)tile[i][j] = '#';\n\t\tcin >> x >> y;\n\t\t//fs >> x >> y;\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\t//fs >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t\tst.emplace(i, j);\n\t\t\t}\n\t\t}\n\n\t\tint dx[]{0, 1, 0, -1};\n\t\tint dy[]{1, 0, -1, 0};\n\t\tint ans(1);\n\n\t\twhile (!st.empty()){\n\t\t\tpoint now = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tint x1 = now.x + dx[i];\n\t\t\t\tint y1 = now.y + dy[i];\n\t\t\t\tif (x1 > 19 || x1 < 0 || y1 > 19 || y1 < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tile[x1][y1] == '.'){\n\t\t\t\t\tst.emplace(x1, y1);\n\t\t\t\t\ttile[x1][y1] = '#';\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\n\nint ans = 0;\nvoid dfs(vector<vector<int> > &a, int x, int y){\n\tans++;\n\ta[x][y] = 0;\n\tif(a[x-1][y]) dfs(a, x-1, y);\n\tif(a[x][y-1]) dfs(a, x, y-1);\n\tif(a[x+1][y]) dfs(a, x+1, y);\n\tif(a[x][y+1]) dfs(a, x, y+1);\n//\treturn res;\t\t//テ」ツ?ゥテ」ツ??」ツつ?」ツつ凝」ツつ禿」ツ??」ツつ催」ツ??」ツ??、ツサツ甘・ツコツヲ\n}\n\nbool solve(){\n\n\twhile(1){\n\t\tans = 0;\n\t\t\n\t\tint w,h;\n\t\tcin>> w>> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tvector<vector<int> > a(h+2, vector<int> (w+2,0));\n\t\tcomplex<int> p;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar in;\n\t\t\t\tcin>> in;\n\t\t\t\tif(in == '#') a[i+1][j+1] = 0;\n\t\t\t\tif(in == '.') a[i+1][j+1] = 1;\n\t\t\t\tif(in == '@'){\n\t\t\t\t\ta[i+1][j+1] = 2;\n\t\t\t\t\tp.real() = i+1;\n\t\t\t\t\tp.imag() = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\tcout<< a[i][j];\n\t\t\t}\n\t\t\tcout<< endl;\n\t\t}\n*/\t\t\n\t\tdfs(a, p.real(), p.imag());\n\t\t\n\t\tcout<< ans<< endl;\n\t}\n\t\n\t\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tsolve();\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nchar ma[100][100];\nint sx,sy; \nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nint cnt;\nint dfs(int px,int py){\n  ma[py][px] = '#';\n  cnt++;\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = px + dx[i],ny = py + dy[i];\n    if(0 <= nx && nx < w && 0 <= ny && ny < h &&\n       ma[ny][nx] != '#'){\n      if(ma[ny][nx] == '.')dfs(nx,ny);\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while( cin >> w >> h, w + h){\n    cnt = 0;\n    for(int i = 0 ; i < h ; i++){\n      for(int j = 0 ; j < w ; j++){\n\tcin >> ma[i][j];\n\tif(ma[i][j] == '@'){sx = j;sy = i;}\n      }\n    }\n    cout << dfs(sx,sy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint W, H;\nint sx, sy;                 // ?????????????????§?¨?\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = { 0,-1, 1, 0};\n\nbool isVisited[MAX_N][MAX_N];\n\nint dfs(const vector<vector<char>>& masu, int x, int y) {\n    if (!isVisited[y][x] && masu[y][x] != '#') {\n        isVisited[y][x] = true;\n\n        int ret = 1;\n        for (int i = 0; i < 4; i++) {\n            if (0 <= x+dx[i] && x+dx[i] < W && 0 <= y+dy[i] && y+dy[i] < H) {\n                // cout << \"#: x=\" << x+dx[i] << \", y=\" << y+dx[i] << endl;\n                ret += dfs(masu, x+dx[i], y+dy[i]);\n            }\n        }\n\n        return ret;\n    }\n    return 0;\n}\n\nint main(void) {\n\n    while (cin >> W >> H, W) {\n        for (int i = 0; i < MAX_N; i++) {\n            for (int j = 0; j < MAX_N; j++) {\n                isVisited[i][j] = false;\n            }\n        }\n\n        vector<vector<char>> masu(H, vector<char>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> masu[i][j];\n                if (masu[i][j] == '@') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        cout << dfs(masu, sx, sy) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar S[21][21];\nint count = 0;\n\nvoid a(int i, int j){\n\tif(S[i][j] == '.'){\n\t\tcount++;\n\t\tS[i][j] = '#';\n\t\ta(i - 1, j);\n\t\ta(i + 1, j);\n\t\ta(i, j + 1);\n\t\ta(i, j - 1);\n\t}\n}\n\n\nint main(){\n\twhile(true){\n\t\tmemset(S,'#',sizeof(S));\n\t\tcount = 0;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> S[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint startx, starty;\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tif(S[i][j] == '@'){\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t\tS[i][j] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta(starty, startx);\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring line[30];\nint w, h, x, y, sum;\n\nvoid countup(int x, int y){\n\tif(line[y][x] != '#'){\n\t\tline[y][x] = '#';\n\t\tcountup(x,y-1);\n\t\tcountup(x,y+1);\n\t\tcountup(x+1,y);\n\t\tcountup(x-1,y);\n\t\tsum++;\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif (!w && !h) break;\n\t\tsum = 0;\n\t\tfor(int i = 1;i<=h;i++){\n\t\t\tcin >> line[i];\n\t\t\tline[i] = \"#\" + line[i] + \"#\";\n\t\t\tfor(int j = 0;j<=w+1;j++){\n\t\t\t\tif(line[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tline[h + 1] = line[0] = \"#####################\";\n\t\tcountup(x, y);\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint COUNT=0;\n\nvoid dfs(vector<string> map,int state[20][20],int x,int y,int W,int H){\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  if(x<0 || x>H-1 || y<0 || y>W-1)return; //????????????\n  if(state[x][y]!=0 || map[x][y]=='#')return; //?????§????????£??????????????????????????????\n  ++COUNT;\n  state[x][y]=1;\n  for(int i=0;i<4;++i)dfs(map,state,x+dx[i],y+dy[i],W,H); //??????????????¨??¢?´¢\n}\n\nint main(){\n  int W,H,x,y;\n  vector<string> map;\n  string a;\n  while(true){\n    COUNT=0;\n    cin >> W >>H;\n  if(!W && !H)break;\n  int state[20][20]={0}; //?????§????????£???????????????\n  for(int i=0;i<H;++i){ //???????????\\???\n    cin >> a;\n    map.push_back(a);\n  }\n  for(int i=0;i<H;++i){//????????????????????¢?´¢\n    if(0<=map[i].find('@') && map[i].find('@')<W){\n      y=map[i].find('@');\n      x=i;\n      break;\n    }\n  }\n  cout << x << y <<endl;\n    dfs(map,state,x,y,W,H);\n    cout << COUNT << endl;\n    map.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\nint main() {\n  int W, H, x, y, ans, c;\n  string s;\n  while (cin >> W >> H, W) {\n    vector<string> M;\n    ans = 0;\n    M.push_back(string(W+2, '#'));\n    for (int i = 0; i < H; ++i) {\n      cin >> s;\n      for (int j = 0; j < W; ++j) {\n\tif (s[j] == '@') {\n\t  x = i+1;\n\t  y = j+1;\n\t  s[j] = '!';\n\t  break;\n\t}\n      }\n      s = '#' + s + '#';\n      M.push_back(s);\n    }\n    M.push_back(string(W+2, '#'));\n    queue<vector<int>> que;\n    que.push({x, y});\n    while (!que.empty()) {\n      ++ans;\n      x = que.front()[0];\n      y = que.front()[1];\n      que.pop();\n      if (M[x-1][y] == '.') {\n\tM[x-1][y] = '!';\n\tque.push({x-1,y});\n      }\n      if (M[x][y-1] == '.') {\n\tM[x][y-1] = '!';\n\tque.push({x,y-1});\n      }\n      if (M[x+1][y] == '.') {\n\tM[x+1][y] = '!';\n\tque.push({x+1,y});\n      }\n      if (M[x][y+1] == '.') {\n\tM[x][y+1] = '!';\n\tque.push({x,y+1});\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nint main(){\n  char c;\n  int x, y, atx, aty, ind, count = 1;\n  std::vector<int> real;\n  std::queue<int> q;\n\n  std::cin >> x;\n  std::cin >> y;\n\n  while(x != 0 || y != 0){\n\n    real.resize(x*y);\n\n    for(int i = 0; i < y; i++){         //地図の読み込みと＠の座標の格納\n      for(int j = 0; j < x; j++){\n        std::cin >> c;\n        if(c == '.'){\n\n          real[i*x + j] = 1;\n\n        }else if(c == '#'){\n\n          real[i*x + j] = 0;\n\n        }else if(c == '@'){\n\n          real[i*x + j] = -1;\n          atx = j;//atx と aty は＠の座標を意味している\n          aty = i;\n\n        }else{\n\n          std::cout << \"unexpected char input!\" << std::endl;\n          return 0;\n\n        }\n      }\n    }\n\n    //＠を起点にして探索を開始する。\n\n    q.push(atx + aty * x);\n\n    while( !q.empty() ){\n\n      ind = q.front();\n      q.pop();\n\n\n      if( ind%x != 0){//左をチェック 左端でなければ\n        if(real[ ind-1 ] == 1 ){\n\n          real[ ind-1 ] = -1;\n          q.push( ind-1 );\n          count++;\n        }\n      }\n\n      if( ind%x != x-1 ){//右をチェック 右端でなければ\n        if(real[ ind+1 ] == 1){\n\n          real[ ind+1 ] = -1;\n          q.push( ind+1 );\n          count++;\n        }\n      }\n\n      if( ind-x > 0 ){//上をチェック 上端でなければ\n        if(real[ ind-x ] == 1){\n\n          real[ ind-x ] = -1;\n          q.push( ind-x );\n          count++;\n        }\n      }\n\n      if( ind+x < x * y){//下をチェック 下端でなければ\n        if(real[ ind+x ] == 1){\n\n          real[ ind+x ] = -1;\n          q.push( ind+x );\n          count++;\n        }\n      }\n\n    }\n\n    std::cout << count << std::endl;\n\n/*\n    for(int i = 0; i < y;i++){\n      for(int j = 0; j < x; j++){\n        std::cout << real[i*x + j];\n      }\n      std::cout << std::endl;\n    }\n//*/\n    std::cin >> x;\n    std::cin >> y;\n    count = 1;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nint main(void) {\n\twhile(true) {\n\t\tint W, H;\n\t\tscanf(\"%d %d\", &W, &H);\n\t\tif ( W==0 ) { break; }\n\t\t\n\t\tchar line[26][26];\n\t\t\n\t\tqueue<pair<int, int> > que;\n\t\t\n\t\tstrcpy(line[0], \"#######################\");\n\t\tstrcpy(line[H+1], \"#######################\");\n\t\t\n\t\tfor(int y=1; y<=H; y++) {\n\t\t\tline[y][0] = '#';\n\t\t\tscanf(\"%s\", &line[y][1]);\n\t\t\t\n\t\t\tif ( char* p = strchr(line[y], '@') ) {\n\t\t\t\tque.push(make_pair(y, p - line[y]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 1;\n\t\t\n\t\twhile(que.size()) {\n\t\t\t\n\t\t\tint y = que.front().first;\n\t\t\tint x = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tint m[][2] = { {-1,0},{1,0},{0,1},{0,-1} };\n\t\t\tREP(d, 4) {\n\t\t\t\tif ( line[y+ m[d][0]] [x+ m[d][1]] == '.' ) {\n\t\t\t\t\tline[y+ m[d][0]] [x+ m[d][1]] = '+';\n\t\t\t\t\tret++;\n\t\t\t\t\tque.push( make_pair(y+ m[d][0], x+ m[d][1]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // C++の入出力\n#include <stdio.h> // C の入出力\n#include <algorithm> // sort などのアルゴリズム\n#include <string.h> // C の文字列用\n#include <ctype.h> // C の文字種用\n#include <string> // C++の文字列\n#include <math.h>\n#include <sstream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\nchar fel[20][20];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid dfs(int i,int x,int y);\nint h,w,sx,sy,cnt=1;\nint main(void){\n    while(true){\n        cin>>w>>h;\n        if(h+w==0)break;\n        for(int s=0;s<h;s++){\n            string in;\n            cin>>in;\n            for(int i=0;i<w;i++){\n                fel[s][i]=in[i];\n                if(fel[s][i]=='@'){\n                    sx=i;\n                    sy=s;\n                }\n            }\n        }\n        dfs(0,sx,sy);\n        cout<<cnt<<endl;\n        cnt=1;\n    }\n    return 0;\n}\n\nvoid dfs(int i,int x,int y){\n    fel[y][x]='#';\n    for(int s=0;s<4;s++){\n        int nx=x+dx[s];\n        int ny=y+dy[s];\n        if(nx>=0&&nx<w&&ny>=0&&ny<h&&fel[ny][nx]=='.'){\n            cnt++;\n            dfs(i+1,nx,ny);\n        }  \n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <deque>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\ntypedef struct point {\n  int x, y;\n} point;\n\nint red_black(point size, point sp, vector<vector<char>> &room) {\n  deque<point> queue(0);\n  queue.push_front(sp);\n  int sum = 0;\n\n  while (queue.size() > 0) {\n    auto p = queue.front();\n    queue.pop_front();\n\n    auto x = p.x;\n    auto y = p.y;\n    if (x < 0 || y < 0 || x == size.x || y == size.y) {\n      continue;\n    }\n\n    auto &tile = room[y][x];\n    if (tile == '#') {\n      continue;\n    }\n\n    sum += 1;\n    tile = '#';\n    queue.push_front(point{x + 1, y});\n    queue.push_front(point{x - 1, y});\n    queue.push_front(point{x, y + 1});\n    queue.push_front(point{x, y - 1});\n  }\n\n  return sum;\n}\n\nint main() {\n  int w, h, sx, sy;\n  char c;\n  while (true) {\n    cin >> w >> h;\n    if (w == 0) {\n      break;\n    }\n\n    vector<vector<char>> room(h, vector<char>(w));\n    rep(y, h) {\n      rep(x, w) {\n        cin >> c;\n        if (c == '@') {\n          sx = x;\n          sy = y;\n        }\n        room[y][x] = c;\n      }\n    }\n\n    auto result = red_black(point{w, h}, point{sx, sy}, room);\n    cout << result << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint W,H,ans;\n\tchar map[100][100];\n\tscanf(\"%d %d\",&W,&H);\n\twhile(W != 0 && H != 0){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",map[i]);\n\t\t}\n\t\tfor(int i = 0; i < 1000; i++){\n\t\t\tfor(int j = 0; j < H - 1; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tif((map[j][k] == '.' && map[j + 1][k] == '@') || (map[j][k] == '@' && map[j + 1][k] == '.')){\n\t\t\t\t\t\tmap[j][k] = '@';\n\t\t\t\t\t\tmap[j + 1][k] = '@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W - 1; k++){\n\t\t\t\t\tif((map[j][k] == '.' && map[j][k + 1] == '@') || (map[j][k] == '@' && map[j][k + 1] == '.')){\n\t\t\t\t\t\tmap[j][k] = '@';\n\t\t\t\t\t\tmap[j][k + 1] = '@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int j = 0; j < H; j++){\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tif(map[j][k] == '@'){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d %d\",&W,&H);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W) {\n\t\tvs field(H);\n\t\tpii s;\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t\tREP(j, W) {\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\ts = pii(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tqueue<pii> Q;\n\t\tQ.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tpii p = Q.front();\n\t\t\tQ.pop();\n\t\t\tans++;\n\t\t\t\n\t\t\tREP(d, 4) {\n\t\t\t\tint nx = p.first + dx[d], ny = p.second + dy[d];\n\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (field[ny][nx] == '.') {\n\t\t\t\t\tfield[ny][nx] = '#';\n\t\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (1){\n\tscanf(\"%d %d\", &w, &h);\n\tif (w == 0 && h == 0) break;\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\tdfs(sx, sy);\n\tprintf(\"%d\\n\", tile);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(a,b) for(int (a)=0;(a)<(b);(a)++)\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0 && h==0)break;\n        int sx,sy;\n        int sum=0;\n        int dy[]={-1,0,1,0};\n        int dx[]={0,-1,0,1};\n    \n    \n        string data[30]={};\n    \n        for(int i=0;i<h;i++){\n            cin>>data[i];\n        }\n    \n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(data[i][j]=='@'){\n                    sx=j;sy=i;\n                    break;\n                }\n            }\n        }\n    \n        bool visited[30][30]={};\n        rep(i,30)rep(j,30)visited[i][j]=false;\n        \n    \n        queue<pair<int,int> > que;\n    \n        que.push( pair<int,int>(sy,sx) );\n        visited[sy][sx]=true;\n    \n        while(que.size()){\n            int qff=que.front().first,qfs=que.front().second;\n            sum++;\n            rep(i,4){\n                if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false && data[ qff+dy[i] ][ qfs+dx[i] ]!='#' ){\n                    que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                    visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n                }\n            }\n            \n            que.pop();\n        }\n        cout<<sum<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar n[100][100];int k[100][100],l[100][100],sum,H,W,i,j,m,s;\n#define A(B,C) if(k[B][C]!=1){l[B][C]=1;}\nint main(){while(true){s=0;memset(l,0,sizeof(l));cin>>W>>H;if(W==0){break;}for(i=1;i<=H;i++){for(j=1;j<=W;j++){cin>>n[i][j];if(n[i][j]=='.'){k[i][j]=0;}else if(n[i][j]=='@'){k[i][j]=2;l[i][j]=1;}else{k[i][j]=1;}}}\nfor(i=0;i<2500;i++){for(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){A(j-1,m);A(j+1,m);A(j,m-1);A(j,m+1);}}}}\nfor(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){s++;}}}cout<<s<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint W,H;\nint posW, posH;\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nbool tiles[21][21] = {};\nbool v_tiles[21][21] = {};\n\nvoid dfs(int x, int y) {\n    if (!(0 <= x && x <= W-1 && 0 <= y && y <= H-1) || v_tiles[x][y] == true || tiles[x][y] == true)\n        return;\n\n    v_tiles[x][y] = true;\n    for (int i = 0; i < 4; i++) {\n        dfs(x+dx[i], y+dy[i]);\n    }\n}\n\nint main() {\n    while (cin>>W>>H && W != 0 && H != 0) {\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                v_tiles[w][h] = false;\n                char tile;\n                cin>>tile;\n                switch (tile) {\n                    case '.':\n                        tiles[w][h] = false;\n                        break;\n\n                    case '#':\n                        tiles[w][h] = true;\n                        break;\n\n                    case '@':\n                        tiles[w][h] = false;\n                        posW = w;\n                        posH = h;\n                        break;\n                }\n            }\n        }\n\n        dfs(posW, posH);\n\n        int count = 0;\n        for (int h = 0; h < H; h++) {\n            for (int w = 0; w < W; w++) {\n                if (v_tiles[w][h] == true) count++;\n            }\n        }\n        cout<<count<<endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint w, h, ans;\nint d[4][2] = { { 1, 0 }, { -1, 0 }, {0, 1}, {0, -1} };\nchar map[20][20];\n\nvoid search_dfs(int x, int y){\n\tif( x < 0 || x >= w || y < 0 || y >= h ) return;\n\tif( map[y][x] != '.' ) return;\n\tans ++;\n\tmap[y][x] = '*';\n\tfor(int i = 0; i < 4; i++)\n\t\tsearch_dfs( x + d[i][0], y + d[i][1] );\n}\n\nint main(void){\n\n\twhile( 1 ) {\n\t\tcin >> w >> h;\n\t\tif( w == 0 && h == 0 ) break;\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tcin >> map[i];\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t\tif( map[i][j] == '@' ) {\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsearch_dfs(j, i);\n\t\t\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX (256)\nusing namespace std;\n\nint N, M;\nchar field[MAX][MAX];\nint sx, sy;\nint ans = 0;\n\nint dx[4]= {1, 0, -1 ,0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs (int x, int y){\n\tif(0 <= x && x < N && 0 <= y && y < M && field[x][y] == '.'){\n\t\tfield[x][y] = '#';\n\t\tans++;\n\t\t\n\t\tfor(int i =0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tdfs(nx, ny);\n\t\t\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(1){\t\n\tcin >> M >> N;\n\t\n\tif(M == 0 && N == 0) break;\n\t\n\tfor(int i =0; i < N; i++){\n\t\tfor(int j =0; j < M; j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i =0; i < N; i++){\n\t\tfor(int j =0; j < M; j++){\n\t\t\tif(field[i][j] == '@'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t\tfield[sx][sy] = '.';\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\tdfs(sx, sy);\n\t\n\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n\nusing namespace std;\n\n\nint W,H;\nint _black_cnt;\nchar sima[21][21];\nbool is_visit[21][21];\nint dw[4] = {1,0,-1,0};\nint dh[4] = {0,1,0,-1};\n\nvoid saiki(int w, int h) {\n\tint aw,ah;\n\trep(i,4) {\n\t\taw = w+dw[i];\n\t\tah = h+dh[i];\n\t\tif ((0 <= aw && aw <= W) || (0 <= ah && ah <= H)) { \n\t\t\tif (sima[aw][ah] == '.' && !is_visit[aw][ah]) {\n\t\t\t\tis_visit[aw][ah] = true;\n\t\t\t\t_black_cnt++;\n\t\t\t\tsaiki(aw,ah);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tis_visit[aw][ah] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main() {\n\tstring a_str;\n\twhile(cin >> W >> H) {\n\t\tif (W==0 && H==0) { break; }\n\n\t\t_black_cnt=0;\n\t\t//初期化\n\t\trep(h,21) {\n\t\t\trep(w,21) {\n\t\t\t\tsima[w][h] = 0;\n\t\t\t\tis_visit[w][h] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//値挿入\n\t\tint fw=0,fh=0;\n\t\trep(h,H) {\n\t\t\tcin >> a_str;\n\t\t\trep(w,W) {\n\t\t\t\tif (a_str[w]=='@') { fw=w; fh=h; }\n\t\t\t\tsima[w][h] = a_str[w];\n\t\t\t}\n\t\t}\n\n\t\tis_visit[fw][fh] = true;\n\t\t_black_cnt=1;\n\t\tsaiki(fw,fh);\n\t\tcout << _black_cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar field[30][30];\nint res;\nint w, h;\nconstexpr int dd[] = {0, 1, 0, -1, 0};\n\nvoid dfs(int y, int x) {\n  res++;\n  field[y][x] = 'x';\n  for (int i = 0; i < 4; ++i) {\n    int ny = dd[i] + y, nx = dd[i + 1] + x;\n    if (0 <= ny && ny < h && 0 <= nx && nx < w) {\n      if (field[ny][nx] == '.') {\n        dfs(ny, nx);\n      }\n    }\n  }\n}\n\nint main() {\n  while (cin >> w >> h, w || h) {\n    int sy, sx;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n        cin >> field[i][j];\n        if (field[i][j] == '@') {\n          sy = i;\n          sx = j;\n          field[i][j] = '.';\n        }\n      }\n    }\n    res = 0;\n    dfs(sy, sx);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<list>\n#include<stack>\n#include<queue>\n#include<cctype>\n#include<iomanip>\n#include<functional>\n#include<numeric>\n#include<map>\n#include<set>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long llong;\nvector<vector<char> >v;\nint cnt;\nint w, h;\n\nvoid dfs(int x, int y) {\n\tif (x == h || x == -1)return;\n\tif (y == -1 || y == w)return;\n\tif (v[x][y] == '#')return;\n\n\tif (v[x][y] == '.'||v[x][y]=='@') {\n\t\tcnt++;\n\t\tv[x][y] = '#';\n\t\tdfs(x + 1, y);\n\t\tdfs(x - 1, y);\n\t\tdfs(x, y + 1);\n\t\tdfs(x, y - 1);\n\n\t}\n\n\treturn;\n\n}\n\nint main() {\n\twhile (cin >> w >> h&&w&&h) {\n\t\tv = vector<vector<char> >(h, vector<char>(w));\n\t\tint x, y;\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tif (v[i][j] == '@') {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\n\t\tcout << cnt << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\nint w,h;\nbool valid(int y,int x){\n    return y >= 0 && x >= 0 && y < h && x < w;\n}\nint dfs(int y,int x,vector<vector<int> > &v){\n    if(v[y][x] != 0){\n        return 0;\n    }\n    v[y][x] = 3;\n    int ret = 1;\n    if(valid(y+1,x)){\n        ret += dfs(y+1,x,v);\n    }\n    if(valid(y-1,x)){\n        ret += dfs(y-1,x,v);\n    }\n    if(valid(y,x+1)){\n        ret += dfs(y,x+1,v);\n    }\n    if(valid(y,x-1)){\n        ret += dfs(y,x-1,v);\n    }\n    return ret;\n}\nvoid solve(int W,int H){\n    vector<vector<int> > v(H,vector<int>(W));\n    w = W;\n    h = H;\n    int sy,sx;\n    rep(i,0,H){\n        rep(j,0,W){\n            char tmp;\n            cin >> tmp;\n            if(tmp == '@'){\n                sy = i;\n                sx = j;\n                v[i][j] = 0;\n            }else if(tmp == '.'){\n                v[i][j] = 0;\n            }else if(tmp == '#'){\n                v[i][j] = 1;\n            }\n        }\n    }\n    cout << dfs(sy,sx,v) << endl;\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0) break;\n        solve(W,H);\n\n\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint serch(int,int);\nchar tile[20][20];\nint W,H;\n\nint main(){\n\tint posx,posy;\n\n\twhile(1){\n\t\tcin >> W >> H;\n\t\tif(W==0&&H==0) break;\n\n\t\t//^CÇÝÝ\n\t\tfor(int j=0;j<H;j++){\n\t\t\tfor(int i=0;i<W;i++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(tile[i][j]=='@'){\n\t\t\t\t\tposx=i,posy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << serch(posx,posy)+1 << endl;\n\t\tfor(int j=0;j<20;j++){\n\t\t\tfor(int i=0;i<20;i++){\n\t\t\t\ttile[i][j]='#';\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint serch(int x,int y){\n\t//cout << \"x=\" << x << \" \" << \"y=\" << y << endl;\n\tint cnt=0;\n\tif(x==0&&y==0){\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==y==0\" << endl;\n\t}else if(x==W&&y==0){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==W&&y==0\" << endl;\n\t}else if(x==0&&y==H){\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"x==0&&y==H\" << endl;\n\t}else if(x==W&&y==H){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"x==W&&y==H\" << endl;\n\t}else if(x==0){\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==0\" << endl;\n\t}else if(x==W){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"x==W\" << endl;\n\t}else if(y==0){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t}\n\t\t//cout << \"y==0\" << endl;\n\t}else if(y==H){\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t}\n\t\t//cout << \"y==H\" << endl;\n\t}else {\n\t\tif(tile[x-1][y]=='.'){\n\t\t\ttile[x-1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x-1,y);\n\t\t\t//cout << \"a---------------a\" << endl;\n\t\t}\n\t\tif(tile[x+1][y]=='.'){\n\t\t\ttile[x+1][y]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x+1,y);\n\t\t\t//cout << \"b---------------b\" << endl;\n\t\t}\n\t\tif(tile[x][y-1]=='.'){\n\t\t\ttile[x][y-1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y-1);\n\t\t\t//cout << \"c---------------c\" << endl;\n\t\t}\n\t\tif(tile[x][y+1]=='.'){\n\t\t\ttile[x][y+1]='@';\n\t\t\tcnt++;\n\t\t\tcnt = cnt + serch(x,y+1);\n\t\t\t//cout << \"d---------------d\" << endl;\n\t\t}\n\t}\n\t//cout << endl;\n\t//for(int j=0;j<H;j++){\n\t//\tfor(int i=0;i<W;i++){\n\t//\t\tcout << tile[i][j];\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\t//\n\treturn cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint32 H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tauto dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <ctime>\n#include <iterator>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\nint main()\n{\n    int nb_lignes,nb_colonnes;\n    while(cin>>nb_colonnes>>nb_lignes)\n    {\n        if(nb_lignes == 0)\n            break;\n        int res = 1;\n        vector<string> lab(nb_lignes);\n        vector<vector<bool> > visites(nb_lignes,vector<bool>(nb_colonnes,false));\n        for(int c=0;c<nb_lignes;c++) cin>>lab[c];\n        int xdep,ydep=0;\n        for(xdep=0;xdep<nb_lignes&&lab[xdep][ydep]!='@';xdep++){ for(ydep=0;ydep<nb_colonnes&&lab[xdep][ydep]!='@';ydep++);if(lab[xdep][ydep]=='@')break;}\n        vector<pair<int,int> > parcours;\n        visites[xdep][ydep]=true;\n        parcours.push_back(make_pair(xdep,ydep));\n        while(parcours.size())\n        {\n            int xact = parcours.back().first;\n            int yact = parcours.back().second;\n            parcours.pop_back();\n            int dx[4]={1,-1,0,0};\n            int dy[4]={0,0,1,-1};\n            for(int c=0;c<4;c++)\n            {\n                int x2 = xact + dx[c];\n                int y2 = yact + dy[c];\n                if(x2>=0&&x2<nb_lignes&&y2>=0&&y2<nb_colonnes&&lab[x2][y2]!='#'&&!visites[x2][y2])\n                {\n                    visites[x2][y2]=true;\n                    res++;\n                    parcours.push_back(make_pair(x2,y2));\n                }\n            }\n        }\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint main(){\n  int W, H;\n  while(cin >> W >> H && W>0 && H>0){\n    int map[400];\n    for(int i=0;i<400;i++)\n      map[i]=0;\n    int at[2];\n\n    for(int i=0;i<H;i++){\n      string s;\n      cin >> s;\n      for(int j=0;j<W;j++){\n        map[20*i+j]=(s[j]=='.'?1:(s[j]=='@'?2:0));\n        if(s[j]=='@'){\n          at[0]=i; at[1]=j;\n        }\n      }\n    }\n\n    vector<int> list[400];  //??£??\\?????????\n    for(int i=0;i<400;i++){\n      if(i>=20) //???\n        if(map[i-20]>0) list[i].push_back(i-20);\n      if(i%20>0) //???\n        if(map[i-1]>0) list[i].push_back(i-1);\n      if(i%20<19) //???\n        if(map[i+1]>0) list[i].push_back(i+1);\n      if(i<380) //???\n        if(map[i+20]>0) list[i].push_back(i+20);\n    }\n\n    bool d[400];\n    for(int i=0;i<400;i++) d[i]=false;\n\n    stack<int> cur;\n    cur.push(at[0]*20+at[1]);\n    d[at[0]*20+at[1]]=true;\n\n    while(!cur.empty()){\n      bool flg=false;\n      for(vector<int>::iterator it=list[cur.top()].begin();it!=list[cur.top()].end();it++){\n        if(!d[*it]){\n          flg=true;\n          cur.push(*it);\n          d[*it]=true;\n          break;\n        }\n      }\n      if(flg) continue;\n      cur.pop();\n    }\n\n    int cnt=0;\n    for(int i=0;i<400;i++)\n      if(d[i]) cnt++;\n\n    cout << cnt << endl;\n  }\n\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint G[1010];\nint R[110][110];\nint D[1010];\nint bfs(int src,int num);\n\nint main() {\n\tint W,H,root;\n\tchar c;\n\n\n\twhile (true) {\n\t\tfor(int i=0;i<100;i++) {\n\t\t\tfor(int j=0;j<100;j++) {\n\t\t\t\tR[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1000;i++) {\n\t\t\tG[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<1000;i++) {\n\t\t\tD[i] = 100;\n\t\t}\n\t\tcin >> W >> H;\n\t\tif((W == 0) && (H == 0)) break;\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tcin >> c;\n\t\t\tif(c == '.') G[i] = 1;\n\t\t\tif(c == '#') G[i] = 0;\n\t\t\tif(c == '@') {\n\t\t\t\tG[i] = 1;\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tif(G[i] == 1) {\n\t\t\t\tif(i%W != 0) { //????????????\n\t\t\t\t\tif(G[i-1] == 1) {//??????????????? \n\t\t\t\t\t\tR[i][i-1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i%W != W-1) { //????????????\n\t\t\t\t\tif(G[i+1] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i+1] = 1;\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t}\n\t\t\t\tif(i > W-1) { //???????????????\n\t\t\t\t\tif(G[i-W] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i-W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t\tif(i < W*H-W) {//???????????????\n\t\t\t\t\tif(G[i+W] == 1){\n\t\t\t\t\t\tR[i][i+W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(root,W*H) << endl;\n\t}\n\t/*\n\tfor(int i=0;i<99;i++) {\n\t\tcout << i << \" \" << G[i] << endl;\n\t}\n\tcout << G[98] << endl;\n\tcout << R[87][98] << endl;\n\t*/\n\t\n}\n\n\n\n\n\nint bfs(int src,int num) {\n\tint cur,dst;\n\tint count = 1;\n\t//cerr << \"bfs root = \" << src << endl;\n\tqueue<int> Q; // ??´??°????????????????????\\????????????\n\tQ.push(src);\n\tD[src] = 0; // ?????????\n\twhile (!Q.empty()) {\n\t\t\n\t\tint cur = Q.front(); // ??????????´????????????????\n\t\tQ.pop();\n// ???????¢??????¨??¨???\n\t\t//cerr << cur << \" \" << D[cur] << endl;\n\t\tfor (int dst=0;dst<num;dst++) { // ???????????? dst ????????????\n\t\t\tif ((R[cur][dst] == 1) && (D[dst] == 100)) { // cur ?????? dst ??????????????????dst ???????¨??????????\n\t\t\t\tD[dst] = D[cur]+1; //\n\t\t\t\tQ.push(dst); // dst ????¨???????????????????\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\n\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int _x, int _y) :x(_x), y(_y){}\n};\n\nchar tile[20][20];\nstack<point> st;\n\nint main()\n{\n\tcin.tie(0); ios::sync_with_stdio(false); \n\t//fstream fs(\"input.txt\");\n\t////////////ここから開始///////////\n\n\t\n\tint x(-1), y(-1);\n\twhile (true){\n\t\tREP(i, 20)REP(j, 20)tile[i][j] = '#';\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)\n\t\t\tbreak;\n\t\t//fs >> x >> y;\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\t//fs >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t\tst.emplace(i, j);\n\t\t\t}\n\t\t}\n\n\t\tint dx[]{0, 1, 0, -1};\n\t\tint dy[]{1, 0, -1, 0};\n\t\tint ans(1);\n\n\t\twhile (!st.empty()){\n\t\t\tpoint now = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tint x1 = now.x + dx[i];\n\t\t\t\tint y1 = now.y + dy[i];\n\t\t\t\tif (x1 > 19 || x1 < 0 || y1 > 19 || y1 < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tile[x1][y1] == '.'){\n\t\t\t\t\tst.emplace(x1, y1);\n\t\t\t\t\ttile[x1][y1] = '#';\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ICPC 2004 à\\I B\n// Red and Black\n// C++ queue Å\n\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nstruct Coord {\n  int col;\n  int row;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  while (1) {\n    int W, H;\n    scanf(\"%d%d\", &W, &H);\n    if (W==0 && H==0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\nint solve (int W, int H) {\n  char M[H+2][W+2];\n  Coord start;\n  //  ÇiÔºjÌÝè \n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  //  f[^ÌÇÝÝ\n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\tstart.col = j;\n      }\n    }\n  }\n\n\n  // X^[gn_ÌÝè\n  queue<Coord> Q;                              // BZðÛ·éL[\n  Q.push(start);                               // X^[gn_ð enqueue\n  int c=1;                                     // BZJE^\n\n  // ÈºTõi±ê©çìéj\n\twhile( !Q.empty()){\n\t\tCoord current = Q.front();Q.pop();\n\t\tint D1[] ={1,0,-1,0};int D2[]={0,-1,0,1};\n\t\tfor ( int d=0;d<4;d++){\n\t\t\tCoord nc = current;\n\t\t\tnc.row += D1[d]; nc.col += D2[d];\n//\t\tprintf(\"r:%d , c:%d\\n\",nc.row ,nc.col);\n\t\t\tif (M[ nc.row ][ nc.col ]=='.'){\n\t\t\t\tM[ nc.row ][ nc.col ]='*';\n\t\t\t\tQ.push(nc);\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\n  return c;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Point\n{\n  int i;\n  int j;\n};\n\nstatic Point minus_point = { -1, -1 };\n\nclass Map\n{\n  public:\n    Map(int height, int width);\n    ~Map();\n\n  public:\n    int Can_go_num(Point p = minus_point);\n\n  private:\n    bool CheckIndex(const Point& p);\n    bool isBlack(const Point& p);\n    bool CanMove(const Point& p);\n\n  private:\n    char** m_map;   //  '.' = black, '#' = red, '@' = start, 'x' = already\n    int m_height;\n    int m_width;\n    Point m_start;\n};\n\nMap::Map(int height, int width)\n{\n  m_height = height;\n  m_width = width;\n\n  m_map = new char*[m_height];\n  for (int i = 0; i < m_height; ++i)\n  {\n    m_map[i] = new char[m_width];\n  }\n\n  for (int i = 0; i < m_height; ++i)\n  {\n    for (int j = 0; j < m_width; ++j)\n    {\n      cin >> m_map[i][j];\n      if (m_map[i][j] == '@')\n      {\n        m_start.i = i;\n        m_start.j = j;\n      }\n    }\n  }\n}\n\nMap::~Map()\n{\n  for (int i = 0; i < m_height; ++i)\n  {\n    delete[] m_map[i];\n  }\n  delete[] m_map;\n}\n\nint Map::Can_go_num(Point p)\n{\n  int result = 1;\n  if (p.i == -1)\n  {\n    p = m_start;\n  }\n  m_map[p.i][p.j] = 'x';\n  Point buf_ps[4] = {\n    { p.i, p.j-1 },\n    { p.i, p.j+1 },\n    { p.i-1, p.j },\n    { p.i+1, p.j },\n  };\n  for (Point buf_p : buf_ps)\n  {\n    if (CanMove(buf_p) )\n    {\n      result += Can_go_num(buf_p);\n    }\n  }\n\n  return result;\n}\n\ninline bool Map::CheckIndex(const Point& p)\n{\n  return (0 <= p.i and p.i < m_height) and (0 <= p.j and p.j < m_width);\n}\n\ninline bool Map::isBlack(const Point& p)\n{\n  return m_map[p.i][p.j] == '.';\n}\n\ninline bool Map::CanMove(const Point& p)\n{\n  return CheckIndex(p) && isBlack(p);\n}\n\nint main(void)\n{\n  int height, width;\n  while (true)\n  {\n    cin >> width >> height;\n    if (height == 0 && width == 0) break;\n    Map map(height, width);\n    cout << map.Can_go_num() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n\nint w, h, cnt = 0;\n\nvoid solve( vector<vector<char>>& f, pair<int, int>& mp ) {\n\n\tif( mp.F - 1 >= 0 && f[mp.S][mp.F - 1] == '.' ) {\n\t\tcnt++;\n\t\tf[mp.S][mp.F - 1] = '#';\n\t\tsolve( f, make_pair( mp.F - 1, mp.S ) );\n\t}\n\tif( mp.F + 1 < w && f[mp.S][mp.F + 1] == '.' ) {\n\t\tf[mp.S][mp.F + 1] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F + 1, mp.S ) );\n\t}\n\tif( mp.S - 1 >= 0 && f[mp.S - 1][mp.F] == '.' ) {\n\t\tf[mp.S - 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S - 1 ) );\n\t}\n\tif( mp.S + 1 < h && f[mp.S + 1][mp.F] == '.' ) {\n\t\tf[mp.S + 1][mp.F] = '#';\n\t\tcnt++;\n\t\tsolve( f, make_pair( mp.F, mp.S + 1 ) );\n\t}\n}\n\nint main() {\n\n\twhile( 1 ) {\n\t\tcin >> w >> h; if( w == 0 && h == 0 ) break;\n\t\t\n\t\tpair<int, int> mp;\n\t\tvector<vector<char>> f;\n\t\tvector<char> tmp( w );\n\t\tREP( i, h ) {\n\t\t\tREP( j, w ) {\n\t\t\t\tcin >> tmp[j];\n\t\t\t\tif( tmp[j] == '@' ) { \n\t\t\t\t\tmp.first = j;\n\t\t\t\t\tmp.second = i; \n\t\t\t\t\ttmp[j] = '#';\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf.push_back( tmp );\n\t\t}\n\t\tsolve( f, mp );\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(50);\n    nexty.reserve(50);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    kaisuu++;\n    cout << sum <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nchar field[20][20];\nint w, h;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid init() {\n  REP(i, w) {\n    REP(j, h) {\n      field[i][j] = '?';\n    }\n  }\n}\n\nvoid trample(int x, int y) {\n  if (x < 0 or w <= x or \n      y < 0 or h <= y or \n      field[x][y] != '@') {\n    return;\n  }\n\n  REP(d, 4) {\n    if (field[x + dx[d]][y + dy[d]] == '.') {\n      field[x + dx[d]][y + dy[d]] = '@';\n      trample(x + dx[d], y + dy[d]);\n    }\n  }\n}\n\nint main() {\n  while (cin >> w >> h and w) {\n    int sx, sy;\n    init();\n    REP(y, h) {\n      string row;\n      cin >> row;\n      REP(x, w) {\n        field[x][y] = row[x];\n        if (row[x] == '@') {\n          sx = x, sy = y;\n        }\n      }\n    }\n\n    trample(sx, sy);\n\n    int accessible = 0;\n    REP(y, h) {\n      REP(x, w) {\n        if (field[x][y] == '@') {\n          accessible++;\n        }\n      }\n    }\n    cout << accessible << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint W,H;\nint count=0;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nvector<vector<char> > M;\n\nvoid go(int x,int y){\n\tif(x<0 || y<0 || x>=W || y>=H) return;\n\tif(M[y][x]=='.' || M[y][x]=='@'){\n\t\tcount++;\n\t\tM[y][x]='#';\n\t\tfor(int r=0;r<4;r++){\n\t\t\tgo(x+dx[r],y+dy[r]);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tcount=0;\n\n\tM.clear();\n\tM.resize(H,vector<char>(W));\n\n\tint sx,sy;\n\tfor(int y=0;y<H;y++){\n\t\tfor(int x=0;x<W;x++){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tM[y][x]=t;\n\t\t\tif(t=='@'){\n\t\t\t\tsx=x;sy=y;\n\t\t\t}\n\t\t}\n\t}\n\n\tgo(sx,sy);\n\tcout<<count<<endl;\n\n}\n\n\nint main(){\n\twhile(cin>>W>>H){\n\t\tif(W==0) return 0;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n\n\nint main(){\n    std::vector<int> tiles;\n    std::queue<int> unvisited_tile_q;\n    int width, height, counter, pos;\n    std::string line;\n\n    while(true){\n        std::cin >> width >> height;\n        if( width == 0 && height == 0 ) break;\n        tiles.resize(width*height);\n        pos = 0;\n        for( int h = 0; h < height; h++ ){\n            std::cin >> line;\n            for(std::string::iterator it = line.begin(); it != line.end(); ++it) {\n                switch(*it){\n                    case '#':\n                        tiles[pos] = 0;\n                        break;\n                    case '@':\n                        unvisited_tile_q.push(pos);\n                    case '.':\n                        tiles[pos] = 1;\n                }\n                pos++;\n            }\n        }\n\n        counter = 0;\n        while( !unvisited_tile_q.empty() ){\n            pos = unvisited_tile_q.front();\n            unvisited_tile_q.pop();\n            if( tiles[pos] == 1 ){\n                counter++;\n                tiles[pos] = -1;\n            } else continue;\n            //left\n            if ( pos - 1 >= 0 && pos % width > 0 && tiles[pos-1] == 1 ) unvisited_tile_q.push(pos-1); \n             //right\n            if ( pos + 1 <= tiles.size() && pos % width < width - 1 && tiles[pos+1] == 1 ) unvisited_tile_q.push(pos+1);\n            //up\n            if ( pos - width >= 0 && tiles[pos-width] == 1 ) unvisited_tile_q.push(pos-width);\n            //down\n            if ( pos + width < tiles.size() && tiles[pos+width] == 1 ) unvisited_tile_q.push(pos+width);\n        }\n\t    //output result\n\t    std::cout << counter << std::endl;\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint G[410];\nint R[410][410];\nint D[410];\nint bfs(int src,int num);\n\nint main() {\n\tint W,H,root;\n\tchar c;\n\n\n\twhile (true) {\n\t\tfor(int i=0;i<400;i++) {\n\t\t\tfor(int j=0;j<400;j++) {\n\t\t\t\tR[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<400;i++) {\n\t\t\tG[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<400;i++) {\n\t\t\tD[i] = 100;\n\t\t}\n\t\tcin >> W >> H;\n\t\tif((W == 0) && (H == 0)) break;\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tcin >> c;\n\t\t\tif(c == '.') G[i] = 1;\n\t\t\tif(c == '#') G[i] = 0;\n\t\t\tif(c == '@') {\n\t\t\t\tG[i] = 1;\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tif(G[i] == 1) {\n\t\t\t\tif(i%W != 0) { //????????????\n\t\t\t\t\tif(G[i-1] == 1) {//??????????????? \n\t\t\t\t\t\tR[i][i-1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i%W != W-1) { //????????????\n\t\t\t\t\tif(G[i+1] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i+1] = 1;\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t}\n\t\t\t\tif(i > W-1) { //???????????????\n\t\t\t\t\tif(G[i-W] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i-W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t\tif(i < W*H-W) {//???????????????\n\t\t\t\t\tif(G[i+W] == 1){\n\t\t\t\t\t\tR[i][i+W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(root,W*H) << endl;\n\t}\n\t/*\n\tfor(int i=0;i<99;i++) {\n\t\tcout << i << \" \" << G[i] << endl;\n\t}\n\tcout << G[98] << endl;\n\tcout << R[87][98] << endl;\n\t*/\n\t\n}\n\n\n\n\n\nint bfs(int src,int num) {\n\tint cur,dst;\n\tint count = 1;\n\t//cerr << \"bfs root = \" << src << endl;\n\tqueue<int> Q; // ??´??°????????????????????\\????????????\n\tQ.push(src);\n\tD[src] = 0; // ?????????\n\twhile (!Q.empty()) {\n\t\t\n\t\tint cur = Q.front(); // ??????????´????????????????\n\t\tQ.pop();\n// ???????¢??????¨??¨???\n\t\t//cerr << cur << \" \" << D[cur] << endl;\n\t\tfor (int dst=0;dst<num;dst++) { // ???????????? dst ????????????\n\t\t\tif ((R[cur][dst] == 1) && (D[dst] == 100)) { // cur ?????? dst ??????????????????dst ???????¨??????????\n\t\t\t\tD[dst] = D[cur]+1; //\n\t\t\t\tQ.push(dst); // dst ????¨???????????????????\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef queue<P> Q;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\n#define mp make_pair\n\nint w,h;\nchar fie[21][21];\n\nvoid bfs(int x, int y){\n    Q q;\n    q.push(mp(x,y));\n    while(!q.empty()){\n        for(int i=0; i<4; i++){\n            int xx = q.front().first + dx[i];\n            int yy = q.front().second + dy[i];\n            if(0 <= xx && xx < w && 0 <= yy && yy < h && fie[yy][xx] == '.'){\n                fie[yy][xx] = '@';\n                q.push(mp(xx,yy));\n            }\n        }\n        q.pop();\n    }\n}\n\nint main(){\n    while(cin >> w >> h , w||h){\n        int sx,sy;\n        for(int i=0; i<h; i++){\n            cin >> fie[i];\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        bfs(sx,sy);\n        int ans = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == '@') ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dx[] = { -1, 0, 1, 0};\nint dy[] = { 0, 1, 0, -1};\n\nint dfs(vector< vector<bool> > &m, int x, int y){\n\tif(!m[x][y])return 0;\n\tint ret = 1;\n\tm[x][y] = false;\n\tfor(int i = 0; i < 4; i++){\n\t\tret += dfs(m, x+dx[i], y+dy[i]);\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(true){\n\t\tint h,w; cin >> w >> h;\n\t\tif(h == 0)break;\n\t\tpair<int,int> s;\n\t\tvector< vector<bool> > m(h+2, vector<bool>(w+2, false));\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif( c == '.'){\n\t\t\t\t\tm[i+1][j+1] = true;\n\t\t\t\t}\n\t\t\t\telse if( c == '@'){\n\t\t\t\t\tm[i+1][j+1] = true;\n\t\t\t\t\ts = make_pair(i+1, j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = dfs(m,s.first, s.second);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nchar map[22][22];\nint h,w,cnt,dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n\nvoid search(int x,int y){\n\tcnt++;\n\tmap[y][x] = '#';\n\tfor(int i = 0; i < 4; i++){\n\t\tif(map[y+dy[i]][x+dx[i]] == '.')\n\t\t\tsearch(x+dx[i],y+dy[i]);\n\t}\n}\n\nint main()\n{\t\n\twhile(scanf(\"%d%d\",&w,&h) && h != 0 && w != 0){\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t}\n\t\tfor(int i = 0; i <= h+1; i++){\n\t\t\tmap[i][0] = '#';\n\t\t\tmap[i][w+1] = '#';\n\t\t}\n\t\tfor(int j = 0; j <= w+1; j++){\n\t\t\tmap[0][j] = '#';\n\t\t\tmap[h+1][j] = '#';\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i <= h+1; i++){\n\t\t\tfor(int j = 0; j <= w+1; j++){\n\t\t\t\tprintf(\"%c\",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tcnt  = 0;\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tif(map[i][j] == '@')\n\t\t\t\t\tsearch(j,i);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint w, h;\nchar d[20][25];\nbool wasOn[20][20];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint solve(int x, int y) {\n  if (x < 0 || y < 0 || x >= w || y >= h) return 0;\n  if (d[y][x] == '#') return 0;\n  if (wasOn[y][x]) return 0;\n  wasOn[y][x] = true;\n  int ans = 1;\n  for (int i = 0; i < 4; i++) ans += solve(x + dx[i], y + dy[i]);\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0) break;\n    for (int i = 0; i < h; i++) scanf(\"%s\", d[i]);\n    int x, y;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        wasOn[i][j] = false;\n        if (d[i][j] == '@') y = i, x = j;\n      }\n    }\n    printf(\"%d\\n\", solve(x, y));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\nusing namespace std;\n\nstring v[20];\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint W,H,x,y;\nint cnt;\n\nvoid search(int y, int x)\n{\n  int i;\n  if(v[y][x]=='#') return;\n  cnt++;\n  v[y][x] = '#';\n  for(i=0;i<4;i++){\n    if(x+dx[i]<0||W<=x+dx[i]) continue;\n    if(y+dy[i]<0||H<=y+dy[i]) continue;\n    if(v[y+dy[i]][x+dx[i]] != '.') continue;\n    search(y+dy[i],x+dx[i]);\n  }\n  return;\n}\n\nint main()\n{\n  int i;\n  while(cin>>W>>H,W||H){\n    for(i=0;i<H;i++){\n      cin>>v[i];\n      if(v[i].find(\"@\")!=string::npos){\n\tx=i;\n\ty=v[i].find(\"@\");\n      }\n    }\n    cnt=0;\n    search(x,y);\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <math.h>\n#include <string>\n#include <climits>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define IS_BIT_ON(bit, i) (bit & (1 << i))\n#define BIT_ON(bit, i) (bit |= (1 << i))\n#define BIT_OFF(bit, i) (bit &= ~(1 << i))\n#define BIT_COUNT(bit) (__builtin_popcount(bit))\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\nvoid print() { std::cout << std::endl; }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { std::cout << head; if (sizeof...(tail) != 0) {std::cout << \" \";} print(std::forward<Tail>(tail)...); }\ntemplate <class T> void print(std::vector<T> &v) {for (auto& a : v) { std::cout << a; if (&a != &v.back()) {std::cout << \" \";} }std::cout << std::endl;}\ntemplate <class T> void print(std::vector<std::vector<T>> &vv) { for (auto& v : vv) { print(v); }}\ninline bool inside(long long y, long long x, long long H, long long W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < (int)v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1u << 30u;\nconst long long LINF = 1ull << 58u;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, 1, 0, -1}, dx4 = {1, 0, -1, 0};    // 右，下，左，上\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nint dfs(int y, int x, vector<vector<int>> &grid) {\n    LL ans = 1;\n    grid[y][x] = 1;\n    FOR(i, 0, 4) {\n        int ny = y + dy4[i];\n        int nx = x + dx4[i];\n\n        if (inside(ny, nx, grid.size(), grid[0].size())) {\n            if (grid[ny][nx] == 0) {\n                ans += dfs(ny, nx, grid);\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        LL W, H;\n        cin >> W >> H;\n\n        if (W == 0 and H == 0) {\n            return 0;\n        }\n\n        auto grid = make_v<int>(H, W);\n        int sy, sx;\n        FOR(y, 0, H) {\n            FOR(x, 0, W) {\n                char C;\n                cin >> C;\n                if (C == '#') {\n                    grid[y][x] = 1;\n                }\n                if (C == '@') {\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n\n        print(dfs(sy, sx, grid));\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long int lint;\ntypedef unsigned long long int ulint;\n\n//#define DEBUG\n\n#ifdef DEBUG\n#\tdefine dump(i) cout << \"[*] \" #i \" : \" << i << endl;\n#\tdefine debug(i) i\n#else\n#\tdefine dump(i)\n#\tdefine debug(i)\n#endif\n#define rep(i, MAX) for (int i = 0; i < (MAX); ++i)\n\nstruct UnionFind\n{\n\tvector<int> par;\n\n\tUnionFind(int n): par(n) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t}\n};\n\ninline void solve() {\n\tint w, h;\n\tconstexpr int MAX = 20;\n\tchar tile[MAX][MAX];\n\tdump(MAX);\n\n\twhile (true) {\n\t\tpair<int, int> at;\n\t\tcin >> w >> h;\n\t\tif (!w && !h) return;\n\t\tint table[MAX] = {};\n\t\tUnionFind uf = UnionFind(200);\n\n\t\tconst int asdf = MAX * MAX;\n\t\tdump(asdf);\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@') {\n\t\t\t\t\tat.first = i;\n\t\t\t\t\tat.second = j;\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint csi = 1;\n\t\tif (tile[0][0] == '.') {\n\t\t\ttile[0][0] = csi++;\n\t\t} else {\n\t\t\ttile[0][0] = 0;\n\t\t}\n\t\ttable[tile[0][0]]++;\n\t\tfor (int i = 1; i < w; ++i) {\n\t\t\tif (tile[0][i] == '.') {\n\t\t\t\ttile[0][i] = tile[0][i-1] != 0 ? tile[0][i-1] : csi++;\n\t\t\t} else {\n\t\t\t\ttile[0][i] = 0;\n\t\t\t}\n\t\t\ttable[tile[0][i]]++;\n\t\t}\n\t\trep(i, h) {\n\t\t\tif (i == 0) continue;\n\t\t\trep(j, w) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\ttile[i][j] = tile[i-1][j] != 0 ? tile[i-1][j] : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\tint tmp = tile[i-1][j];\n\t\t\t\t\t\tif (tmp == 0) {\n\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t} else if (tile[i][j-1] != 0) {\n\t\t\t\t\t\t\tuf.unite(tmp, tile[i][j-1]);\n\t\t\t\t\t\t\tif (tmp > tile[i][j-1]) {\n\t\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttile[i][j] = tmp != 0 ? tmp : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttable[tile[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint iv = tile[at.first][at.second];\n\t\trep(i, csi) {\n\t\t\tif (uf.same(iv, i)) {\n\t\t\t\tans += table[i];\n\t\t\t}\n\t\t}\n\t\tdump(\"tile\");\n\t\tdump(\"table\");\n\t\tdump(\"ans\");\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\t//*\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\t// */\n#ifdef DEBUG\n\tconst auto start = chrono::high_resolution_clock::now();\n#endif\n\tsolve();\n#ifdef DEBUG\n\tconst auto stop = chrono::high_resolution_clock::now();\n\tcerr << \"[*] time: \" << chrono::duration_cast<chrono::milliseconds>(stop-start).count()\n\t\t<< \" [ms]\" << endl;\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans[50],cnt=0,sx,sy;\nstring m[20];\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tstring t;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tstring t;\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdlib.h>\n\nusing namespace std;\n\nchar map[100][100];\nchar smap[100][100];\nint ans;\n\nint serch(int nx,int ny,int maxx,int maxy)\n{\n\tint nextx[4]={1,0,-1,0},nexty[4]={0,1,0,-1};\n\tmap[ny][nx]='0';\n/*///////////////ツ確ツ認ツ用////////////////////\t\n\tgetchar();\n\t\n\tsystem(\"cls\");\n\t\n\tcout << \"nowx:\" << nx << \" mowy:\" << ny << \"maxx:\" << maxx << \" maxy:\" << maxy << endl;\n\tcout << maxx << \" \" << maxy << endl;\n\tfor(int i=0;i<maxy;i++)\n\t{\n\t\tfor(int j=0;j<maxx;j++)\n\t\t{\n\t\t\tcout << smap[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tfor(int i=0;i<maxy;i++)\n\t{\n\t\tfor(int j=0;j<maxx;j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n*//////////////////////////////////////////\t\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(0<=nx+nextx[i] && nx+nextx[i]<maxx && 0<=ny+nexty[i] && ny+nexty[i]<maxy &&map[ny+nexty[i]][nx+nextx[i]]=='.')\n\t\t{\n//\t\t\t\tcout << \"nextx:\" << nx+nextx[i] << \" nexty:\" << ny+nexty[i] << endl;\n\t\t\t\tserch(nx+nextx[i],ny+nexty[i],maxx,maxy);\n\t\t}\n\t}\n\treturn ans++;\n}\n\nint main()\n{\n\tint x,y;\n\tint i,j;\n\tint sx,sy;\n\t\n\tfor(;;)\n\t{\n\t\tcin >> x >> y ;\n\t\t\n\t\tif(x==0 && y==0)\n\t\t\tbreak;\n\t\t\n\t\tfor(i=0;i<y;i++)\n\t\t{\n\t\t\tfor(j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tsmap[i][j]=map[i][j];\n\t\t\t\tif(map[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans=0;\n\t\tserch(sx,sy,x,y);\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<memory>\n#include<cstdlib>\n\nusing namespace std;\nint W,H;\nvoid solve(int,int);\nchar dfs[20][20];\nint d_x[]={1,0,-1,0},d_y[]={0,1,0,-1};\n\nint main(){\n\t\n\twhile(1){\n\t\tint ans=0;\n\t\tcin>>W>>H;\n\t\tif(W==0&&H==0)\tbreak;\n\n\t\tint dx,dy;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>dfs[j][i];\n\t\t\t\tif(dfs[j][i]=='@'){\n\t\t\t\t\tdx=j;\n\t\t\t\t\tdy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(dx,dy);\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(dfs[j][i]=='T')\n\t\t\t\t\tans++;\n\t\tcout<<ans<<endl;\n\t\tmemset(dfs,0,sizeof(dfs));\n\t}\n}\n\nvoid solve(int x,int y){\n\tdfs[x][y]='T';\n\t\n\tfor(int j=0;j<4;j++){\n\t\tint mx=x+d_x[j],my=y+d_y[j];\n\t\tif(mx<0||my<0||mx>W||my>H)\tcontinue;\n\t\tif(dfs[mx][my]=='.')\n\t\t\tsolve(mx,my);\n\t}\n\treturn ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { -1,  0,  0,  1 };\n  int dy[4] = {  0, -1,  1,  0 };\n\n  while( true ) {\n\n    int w, h;\n\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    string input;\n    vector< string > map;\n\n    queue<int> qx;\n    queue<int> qy;\n\n    for ( int i = 0; i < h; i++ ) {\n      cin >> input;\n      map.push_back( input );\n      for ( int j = 0; j < w; j++ ) {\n\tif ( map[i][j] == '@' ) {\n\t  qx.push(j);\n\t  qy.push(i);\n\t}\n      }\n    }\n\n    int ans = 1;\n\n    while( qx.size() > 0 ) {\n\n      int x = qx.front();\n      int y = qy.front();\n      qx.pop();\n      qy.pop();\n\n      for ( int i = 0; i < 4; i++ ) {\n\tint cx = x + dx[i];\n\tint cy = y + dy[i];\n\tif ( cx < 0 || cx >= w || cy < 0 || cy >= h ) continue;\n\tif ( map[cy][cx] == '.' ) {\n\t  ans++;\n\t  map[cy][cx] = '@';\n\t  qx.push(cx);\n\t  qy.push(cy);\n\t}\n      }\n\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nconst int vx[4] = { 0, 1, 0, -1 }, vy[4] = { 1, 0, -1, 0 };\n\nint W, H;\nstd::string s[21];\nbool is_searched[21][21];\n\nint solve() {\n  int sx, sy;\n\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      if (s[i][j] == '@') {\n        sx = i, sy = j;\n        break;\n      }\n    }\n  }\n\n  std::memset(is_searched, false, sizeof is_searched);\n\n  int ans = 1;\n\n  std::queue<std::pair<int, int> > que;\n  que.push({ sx, sy });\n  is_searched[sx][sy] = true;\n\n  while (!que.empty()) {\n    std::pair<int, int> p = que.front();\n    que.pop();\n\n    for (int i = 0; i < 4; ++i) {\n      int nx = p.first + vx[i], ny = p.second + vy[i];\n\n      if (0 <= nx && nx < H && 0 <= ny && ny < W && !is_searched[nx][ny] && s[nx][ny] == '.') {\n        ans++;\n        is_searched[nx][ny] = true;\n        que.push({ nx, ny });\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n  while (cin >> W >> H, H | W) {\n    for (int i = 0; i < H; ++i) {\n      cin >> s[i];\n    }\n\n    int ans = solve();\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\n\nclass P {\npublic:\n\tint x, y;\n\tP() {}\n\tP(int _x, int _y) : x(_x), y(_y) {}\n};\n\nint w, h;\nchar map[22][22];\n\nint dx[] = { 0, 1, 0, -1};\nint dy[] = {-1, 0, 1,  0};\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tP start;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> map[i];\n\t\t\tchar* at = strchr(map[i], '@');//文字列から文字を検索する\n\t\t\tif (at != NULL) {//@が存在したらスタート地点なので記録\n\t\t\t\tstart.x = at - map[i];\n\t\t\t\tstart.y = i;\n\t\t\t}\n\t\t}\n\t\t//深さ優先探索\n\t\tstack<P> deq;\n\t\tint count = 0;\n\t\tdeq.push(start);//初期位置をpush\n\t\twhile (!deq.empty()) {\n\t\t\tP current = deq.top();//pop\n\t\t\tdeq.pop();\n\t\t\tcount++;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nextX = dx[i] + current.x;\n\t\t\t\tint nextY = dy[i] + current.y;\n\t\t\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h\n\t\t\t\t\t\t&& map[nextY][nextX] == '.') {\n\t\t\t\t\tdeq.push(P(nextX, nextY));//次のノードをpush\n\t\t\t\t\tmap[nextY][nextX] = '#';//戻らないように埋める\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n\n/*\tポイント\n\t\t領域の塗りつぶし問題\n\t\t再帰による実装の方が一般的かも\n\t\t埋めるタイミングが間違ってて詰まってた\n\t\tmapはy,xの順の添字で使うと入力が楽\n\t\t\tでもその分参照は注意\n\t\t探索の基礎\n\t\t\tpush()\n\t\t\twhile (!empty) {\n\t\t\t\tpop()\n\t\t\t\tif (ゴール判定) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (次のノードの条件) {\n\t\t\t\t\tpush()\n\t\t\t\t}\n\t\t\t}\n\t\t\t※stackで深さ,queueで幅,priority_queueでダイクストラ(コストがpriority)\n*/"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\"%d\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]==true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%W;\n\t        int y=cur/W;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[j];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*W);\n  visited[ny][nx]=true;\n\n    }\n   }\n \n }\n\n\n \n \n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <utility>\n#include <unordered_set>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h && w > 0 && h > 0){\n        string tmp;\n        pair<int, int> init;\n        vector<vector <int> > grid(25, vector<int>(25, -1));\n        vector<vector <int> > visited(25, vector<int>(25, 0));\n        for(int i = 0; i < h; i++){\n            cin >> tmp;\n            for (int j = 0; j < w; j++){\n                if(tmp[j] == '.'){\n                    grid[i][j] = 0;\n                }else if(tmp[j] == '#'){\n                    grid[i][j] = -1;\n                }else if(tmp[j] == '@'){\n                    grid[i][j] = 0;\n                    init = make_pair(i, j);\n                }\n            }\n        }\n        queue<pair<int, int> > Q;\n        Q.push(init);\n        visited[init.first][init.second] = 1; \n        while(!Q.empty()){\n            pair<int, int> cur = Q.front(); \n            Q.pop();\n            int cur_x = cur.first;\n            int cur_y = cur.second;\n            for(int i = 0; i < 4; i++){\n                pair<int, int> dst = make_pair(cur_x + dx[i], cur_y + dy[i]);\n                int x = dst.first;\n                int y = dst.second;\n                if(0 <= x && 0 <= y && grid[x][y] == 0 && visited[x][y] == 0){\n                    Q.push(dst);\n                    visited[x][y] = 1;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                ans += visited[i][j];\n            }\n        }\n        cout << ans << endl << endl << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint w,h;\nchar B[20][21];\n\nint dfs(int i,int j){\n\tB[i][j]='#';\n\tint res=1;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='.') res+=dfs(y,x);\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\t\trep(i,h) rep(j,w) if(B[i][j]=='@') printf(\"%d\\n\",dfs(i,j));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n\nint H,W;\nvector<vector<char>> board;\nvector<vector<bool>> check;\n\nconst vector<int> dy = {-1,0,0,1};\nconst vector<int> dx = {0,-1,1,0};\n\nvoid dfs(int y, int x) {\n    check[y][x] = true;\n    rep(i,4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (board[ny][nx] != '#' && !check[ny][nx]) dfs(ny,nx);\n    }\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while(true) {\n        cin >> W >> H;\n        if (W == 0 && H == 0) break;\n        board.assign(H+2, vector<char>(W+2,'#'));\n        rep(i,H) rep(j,W) cin >> board[i+1][j+1];\n      \n        int sy,sx;\n        rep(i,H) {\n            rep(j,W) {\n                if (board[i+1][j+1] == '@') {\n                    sy = i+1;\n                    sx = j+1;\n                }\n            }\n        }\n\n        check.assign(H+2, vector<bool>(W+2,false));\n        dfs(sy,sx);\n\n        int count = 0;\n        rep(i,H) rep (j,W) if (check[i+1][j+1]) count++;\n        cout << count << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nint num =1,d[10000][10000];\nchar A[10000][10000];\nbool valid(int x,int y,int W,int H)\n{\n    return (x>=0&&x<W)&&(y>=0&&y<H);\n}\nvoid Init(int W,int H)\n{\n    int i,j;\n    num=1;\n    for(i=0;i<W;i++)\n        for(j=0;j<H;j++)\n            d[i][j]=0;\n}\nvoid dfs(int x, int y, int W, int H, char A[10000][10000])\n{\n    int i;\n    for(i=0;i<4;i++)\n    {\n        if(valid(x+dx[i],y+dy[i],W,H))\n        {\n            if(A[x+dx[i]][y+dy[i]]=='.' && d[x+dx[i]][y+dy[i]]==0)\n            {\n                num++;\n                A[x+dx[i]][y+dy[i]]='#';\n                d[x+dx[i]][y+dy[i]]=1;\n                dfs(x+dx[i],y+dy[i],W, H,A);\n            }\n        }\n    }\n}\nint main()\n{\n    int W,H,i,j,x,y;\n    queue<int> Q;\n    cin >> H >> W;\n    while(W && H)\n    {\n        for(i=0;i<W;i++)\n        {\n            for(j=0;j<H;j++)\n                cin >> A[i][j];\n        }\n        for(i=0;i<W;i++)\n            for(j=0;j<H;j++)\n            {\n                if(A[i][j]=='@')\n                {\n                    x=i;\n                    y=j;\n                }\n            }\n        Init(W,H);\n        d[x][y]=1;\n        dfs(x, y, W, H, A);\n        cout << num << endl;\n        cin >> H >> W;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nchar map[20][20];\nint W, H;\nint sh, sw;\nint dw[4] = {-1, 0, 1, 0};\nint dh[4] = {0, 1, 0, -1};\nint cnt;\n\nvoid print_map(){\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      cout << map[i][j];\n    }\n    cout << endl;\n  }\n}\n\nvoid solve(int w, int h){\n  map[h][w] = '#';\n  cnt++;\n  for(int i = 0; i < 4; i++){\n    int nh = h + dh[i], nw = w + dw[i];\n    if(0 <= nh && nh < H && 0 <= nw && nw < W && map[nh][nw] == '.') solve(nw, nh);\n  }\n  return;\n}\n\nint main(void){\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    cnt = 0;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> map[i][j];\n        if(map[i][j] == '@'){\n          sh = i;\n          sw = j;\n        }\n      }\n    }\n    solve(sw, sh);\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0 && h==0)break;\n        int sx,sy;\n        int sum=0;\n        int dy[]={-1,0,1,0};\n        int dx[]={0,-1,0,1};\n    \n    \n        string data[30]={};\n    \n        for(int i=0;i<h;i++){\n            cin>>data[i];\n        }\n    \n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(data[i][j]=='@'){\n                    sx=j;sy=i;\n                    break;\n                }\n            }\n        }\n    \n        bool visited[30][30]={};\n        rep(i,30)rep(j,30)visited[i][j]=false;\n        \n    \n        queue<pair<int,int> > que;\n    \n        que.push( pair<int,int>(sy,sx) );\n        visited[sy][sx]=true;\n    \n        while(que.size()){\n            int qff=que.front().first,qfs=que.front().second;\n            sum++;\n            rep(i,4){\n                if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false && data[ qff+dy[i] ][ qfs+dx[i] ]!='#' ){\n                    que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                    visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n                }\n            }\n            \n            que.pop();\n        }\n        cout<<sum<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef  long long ll;\nusing vll=vector<ll>;\nusing vvll=vector<vll>;\nusing vi=vector<int>;\nusing vvi=vector<vector<int>>;\nusing vb=vector<bool>;\nusing pii=pair<int,int>;\nusing vpii=vector<pair<int,int>>;\nusing plli=pair<ll,int>;\nusing vplli=vector<pair<ll,int>>;\nusing pllll=pair<ll,ll>;\nusing vpllll=vector<pair<ll,ll>>;\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b;return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b;return true;}return false;}\n\n#define rep(i, begin_i, end_i) for (ll i = (ll)begin_i; i < (ll)end_i; i++)\n//試験導入\n#define irep(i, end_i, begin_i) for (ll i = (ll)begin_i-1; i >= (ll)end_i; i--)\n\nlong long INF = 1LL<<60;\nint main( ){\n    while(true){\n        int H,W;\n        cin>>W>>H;\n        if(H==0&&W==0)\n            break;\n        string s[H];\n        int si,sj;\n        rep(i,0,H){\n            cin>>s[i];\n            rep(j,0,W){\n                if(s[i][j]=='@')\n                    si=i,sj=j;\n            }\n        }\n        queue<pii> q;\n        q.emplace(si,sj);\n        vector<vb> is_v(H,vb(W,false));\n        is_v[si][sj]=true;\n        int cnt=1;\n        while(!q.empty()){\n            pii e=q.front();\n            q.pop();\n            int i=e.first,j=e.second;\n            int di[]={1,-1,0,0};\n            int dj[]={0,0,1,-1};\n            rep(w,0,4){\n                int ni=i+di[w],nj=j+dj[w];\n                if((ni<0||ni>H-1)||(nj<0||nj>W-1))\n                    continue;\n                if(is_v[ni][nj])\n                    continue;\n                is_v[ni][nj]=true;\n                if(s[ni][nj]=='.'){\n                    cnt++;\n                    q.emplace(ni,nj);\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define endl '\\n';\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr double INFD = 1e100;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ios::sync_with_stdio(false);\n// cin.tie(nullptr);\n// ---------------------------------------------------------------------------\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int W,H;\n    cin >> W >> H;\n    while(W!=0){\n        vector<string> G(H);\n        for(int i=0; i<H; i++){\n            cin >> G[i];\n        }\n        vector<vector<bool>> dist(H,vector<bool> (W,false));\n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                if(G[i][j] == '@'){\n                    int ans = 1;\n                    queue<P> que;\n                    que.push(P(i,j));\n                    dist[i][j] = true;\n                    while(que.size()){\n                        P v = que.front();\n                        que.pop();\n                        for(int i=0; i<4; i++){\n                            int ny = v.first + dy[i];\n                            int nx = v.second + dx[i];\n                            if(ny<0 or ny>=H or nx<0 or nx>=W) continue;\n                            if(G[ny][nx] == '#') continue;\n                            if(dist[ny][nx]) continue;\n                            ans++;\n                            dist[ny][nx] = true;\n                            que.push(P(ny,nx));\n                        }\n                    }\n                    cout << ans << endl;\n                }\n            }\n        }\n        cin >> W >> H;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint solve(int n,int m){\n\tint flag[21][21]={};\n\tint field[21][21]={};\n\tqueue<pair<int,int> >q;\n\tfor(int i=0;i<m;i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(s[j]=='.')field[i][j]=0;\n\t\t\tif(s[j]=='#')field[i][j]=-1;\n\t\t\tif(s[j]=='@'){\n\t\t\t\tfield[i][j]=1;\n\t\t\t\tflag[i][j]=1;\n\t\t\t\tq.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.front();\n\t\tq.pop();\n\t\tint a = p.first;\n\t\tint b = p.second;\n\t\tif(a>0){\n\t\t\tif(flag[a-1][b]==0&&field[a-1][b]==0){\n\t\t\t\tq.push(make_pair(a-1,b));\n\t\t\t\tflag[a-1][b]=1;\n\t\t\t}\n\t\t}\n\t\tif(a<m-1){\n\t\t\tif(flag[a+1][b]==0&&field[a+1][b]==0){\n\t\t\t\tq.push(make_pair(a+1,b));\n\t\t\t\tflag[a+1][b]=1;\n\t\t\t}\n\t\t}\n\t\tif(b>0){\n\t\t\tif(flag[a][b-1]==0&&field[a][b-1]==0){\n\t\t\t\tq.push(make_pair(a,b-1));\n\t\t\t\tflag[a][b-1]=1;\n\t\t\t}\n\t\t}\n\t\tif(b<n-1){\n\t\t\tif(flag[a][b+1]==0&&field[a][b+1]==0){\n\t\t\t\tq.push(make_pair(a,b+1));\n\t\t\t\tflag[a][b+1]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(flag[i][j]==1)ans+=1;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tcout << solve(n,m) <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n\nint map[50][50] = {};\nint w,h;\nint ans;\nint dx[4] = {0,-1,0,1};\nint dy[4] = {-1,0,1,0};\n\nvoid search(int y, int x){\n\n  map[y][x] = 0;\n  for(int t = 0; t < 4 ; t++){ \n    int ny = y + dy[t], nx = x + dx[t]; \n    if(nx >= 0 && ny >= 0 && nx < w && ny < h && map[ny][nx] == 1){\n      //cout << \"IN \";\n      ans++;\n      search(ny,nx);\n    }\n  }\n}\n\n\nint main(){\n  \n  while(1){\n    for(int j = 0; j < 50 ; j++){\n      for(int i = 0; i < 50 ; i++){\n\tmap[j][i] = 0;\n      }\n    }\n    \n    ans = 1;\n\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    int stx,sty;\n    for(int k = 0; k < h ; k++){\n      string s;\n      cin >> s;\n      for(int i = 0; i < w ; i++){\n\tif(s[i] == '.') map[k][i] = 1;\n\tif(s[i] == '#') map[k][i] = 0;\n\tif(s[i] == '@') {\n\t  map[k][i] = 2;\n\t  stx = i;\n\t  sty = k;\n\t}\n      }\n    }\n\n\n \n    //竪臓即巽造尊\n    /*\n    for(int j = 0; j < h ; j++){\n      for(int i = 0; i < w ; i++){\n\tcout << map[j][i];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    search(sty,stx);\n    cout << ans << endl;\n\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#ifndef LIB_DEBUG_HPP\n#define LIB_DEBUG_HPP\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n#endif\n#ifndef repeat\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#endif\n#ifndef repeat_from\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#endif\n#ifndef repeat_one\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#endif\n#ifndef repeat_rev\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#endif\n#ifndef foreach\n#define foreach(it, cont) for (typeof(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\n#ifndef LIB_DEBUG_HPP\n#define LIB_DEBUG_HPP\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\n#endif\nusing namespace std;\nconst int D4[4][2] = { {0,-1}, {0,1}, {-1,0}, {1,0} };\nint H, W;\nvector<vector<bool> > tile;\nvector<vector<bool> > used;\nint dfs(int h, int w) {\n    if (used[h][w]) return 0;\n    used[h][w] = true;\n    int acc = 1;\n    repeat (d,4) {\n        int h0 = h + D4[d][0];\n        int w0 = w + D4[d][1];\n        if (0 <= h0 and h0 < H and 0 <= w0 and w0 < W and not used[h0][w0]) {\n            if (tile[h0][w0] == false) {\n                acc += dfs(h0, w0);\n            }\n        }\n    }\n    return acc;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    while (true) {\n        cin >> W >> H; cin.ignore();\n        if (W == 0 and H == 0) break;\n        tile = vector<vector<bool> >(H, vector<bool>(W));\n        pair<int,int> p;\n        repeat (h,H) {\n            repeat (w,W) {\n                char c; cin >> c;\n                if (c == '.') {\n                    tile[h][w] = false;\n                } else if (c == '#') {\n                    tile[h][w] = true;\n                } else if (c == '@') {\n                    tile[h][w] = false;\n                    p = make_pair(h,w);\n                } else {\n                    debug (assert (false));\n                }\n            }\n            cin.ignore();\n        }\n        used = vector<vector<bool> >(H, vector<bool>(W, false));\n        cout << dfs(p.first, p.second) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#define ld long double\n#define ll long long int\n#define ull unsigned long long int\n#define rep(i,n) for(i=0;i<n;i++)\n#define fin(ans) cout<<(ans)<<endl\n#define INF INT_MAX\n#define vi vector<int>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pair<int,int> >\n#define vvi vector<vector<int> >\n#define vvc vector<vector<char> >\n#define vvs vector<vector<string> >\n#define P 1000000007\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nconst long long LLINF=1LL<<60;\n//set<int>::iterator it;\n//|\\_\n//g++ -std=c++1z temp.cpp\n//./a.out\n\nint ans=0;\nvvc v(30,vector<char> (30,'a'));\nint dfs(int x,int y,int h,int w){\n    // cout<<x<<\" \"<<y<<\" \"<<ans<<endl;\n    if(v[y][x]=='%')return 0;\n    if(v[y][x]=='@'||v[y][x]=='.'){\n        ans++;\n        v[y][x]='%';\n        if(x+1<w&&v[y][x+1]=='.')dfs(x+1,y,h,w);\n        if(x-1>=0&&v[y][x-1]=='.')dfs(x-1,y,h,w);\n        if(y+1<h&&v[y+1][x]=='.')dfs(x,y+1,h,w);\n        if(y-1>=0&&v[y-1][x]=='.')dfs(x,y-1,h,w);\n\n    }\n    else return 0;\n    return 0;\n}\n\nint main(void){ios::sync_with_stdio(false);cin.tie(0);\n//////////////////////////////////////////////////////\n    \n    \n    int h,w,i,j,x,y;\n    while(1){\n        cin>>w>>h;\n        ans=0;\n        if(h==0&&w==0)break;\n        rep(i,30)rep(j,30)v[i][j]='%';\n        rep(i,h){\n            rep(j,w){\n                cin>>v[i][j];\n                if(v[i][j]=='@'){\n                    // cout<<i<<\" \"<<j<<endl;\n                    y=i;\n                    x=j;\n                }\n            }\n        }\n        dfs(x,y,h,w);\n        cout<<ans<<endl;\n    }\n    \n    \n\n//////////////////////////////////////////////////////\nreturn 0;}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<sstream>\n#include<cstdio>\n#include<ctime>\n#include<utility>\n#include<cstdlib>\n#include<iterator>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long llong;\ntypedef unsigned long long ullong;\ntypedef unsigned int uint;\n#define int long long\nconst int INF = 9223372036854775807;\n\n\nnamespace G {\n}\n//vector<vector<char>> map;\n//vector<vector<bool>> flag;\nint w, h;\nint ans = 0;\nint X, Y; //@?????????\nqueue<pair<int, int>> que;\n\n/*\nvoid check() {\n\tauto xy = que.front();\n\tque.pop();\n\tint x = xy.first;\n\tint y = xy.second;\n\tif (!flag[x][y]) {\n\t\tans += 1;\n\t\tflag[x][y] = true;\n\t}\n\telse return;\n\t\n\tif ((map[x + 1][y] == '.') && (!flag[x + 1][y])) que.push(pair<int, int>(x + 1, y));\n\tif ((map[x - 1][y] == '.') && (!flag[x - 1][y])) que.push(pair<int, int>(x - 1, y));\n\tif ((map[x][y + 1] == '.') && (!flag[x][y + 1])) que.push(pair<int, int>(x, y + 1));\n\tif ((map[x][y - 1] == '.') && (!flag[x][y - 1])) que.push(pair<int, int>(x, y - 1));\n}\n*/\n\nvoid check(vector<vector<char>> &map, vector<vector<bool>> &flag) {\n\tauto xy = que.front();\n\tque.pop();\n\tint x = xy.first;\n\tint y = xy.second;\n\tif (!flag[x][y]) {\n\t\tans += 1;\n\t\tflag[x][y] = true;\n\t}\n\telse return;\n\n\tif ((map[x + 1][y] == '.') && (!flag[x + 1][y])) que.push(pair<int, int>(x + 1, y));\n\tif ((map[x - 1][y] == '.') && (!flag[x - 1][y])) que.push(pair<int, int>(x - 1, y));\n\tif ((map[x][y + 1] == '.') && (!flag[x][y + 1])) que.push(pair<int, int>(x, y + 1));\n\tif ((map[x][y - 1] == '.') && (!flag[x][y - 1])) que.push(pair<int, int>(x, y - 1));\n}\n\n\n\nsigned main() {\n\tcin >> w >> h;\n\twhile ((w != 0) && (h != 0)) {\n\t\tvector<vector<char>> map;\n\t\tvector<vector<bool>> flag;\n\t\t//cout << \"w=\" << w << \" h=\" << h << endl << endl;\n\t\tmap = vector<vector<char>>(h + 2, vector<char>(w + 2,'#'));\n\t\tflag = vector<vector<bool>>(h + 2, vector<bool>(w + 2,true));\n\t\tfor (int i = 1; i < h + 1; ++i) {\n\t\t\tfor (int j = 1 ; j < w + 1; ++j) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tflag[i][j] = false;\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tX = j;\n\t\t\t\t\tY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//cout << \"map=\" << map.size() << \" map1=\" << map[0].size() << endl;\n\t\t//cout << \"X=\" << X << \" Y=\" << Y << endl;\n\n\t\tans = 0;\n\t\twhile (!que.empty()) que.pop();\n\t\tque.push(pair<int,int>(Y,X));\n\t\twhile (!que.empty()) {\n\t\t\tcheck(map,flag);\n\t\t}\n\n\n\t\t/*\n\t\tfor (auto ngo : map) {\n\t\t\tfor (auto ngoo : ngo) {\n\t\t\t\tcout << ngoo;\n\t\t\t}cout << endl;\n\t\t}\n\t\tcin >> w >> h;\n\t\t*/\n\t\tcout << ans << endl;\n\t\tcin >> w >> h;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { -1, 1, 0, 0 };\nint dy[4] = { 0, 0, -1, 1 };\n\nint search(vector<string> v) {\n\n  pair<int,int> init;\n  for(int i=0; i<v.size(); i++) {\n    for(int j=0; j<v[i].length(); j++) {\n      if( v[i][j] == '@' )\n\tinit.second = i,init.first = j;\n    }\n  }\n\n  int res = 0;\n\n  queue< pair<int,int> > que;\n  que.push(init);\n  while(!que.empty()) {\n    pair<int,int> q = que.front();\n    que.pop();\n\n    for(int i=0; i<4; i++) {\n      int x=q.first+dx[i];\n      int y=q.second+dy[i];\n      if( x >= 0 && x < v[q.second].length() ) {\n\tif( y >= 0 && y < v.size() ) {\n\t  if( v[y][x] == '.') {\n\t    v[y][x] = '@';\n\t    pair<int,int> p;\n\t    p.first = x;\n\t    p.second = y;\n\t    que.push(p);\n\t  }\n\t}\n      }\n    }\n\n  }\n\n  for(int i=0; i<v.size(); i++) {\n    for(int j=0; j<v[i].length(); j++) {\n      //cout<<v[i][j];\n      if(v[i][j] == '@') res++;\n    }\n    //cout<<endl;\n  }\n  return res;\n\n}\n\nint main() {\n\n  int w,h;\n  while(true) {\n\n    cin>>w>>h;\n    if(!w&&!h) break;\n    vector<string> v;\n    string s;\n\n    for(int i=0; i<h; i++) {\n      cin>>s;\n      v.push_back(s);\n    }\n\n    cout<<search(v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 2; k++) {\n            bool flag=true;\n\t\t\tfor (int i = 0; i >= 0; (flag ? i++ : i--)) {\n\t\t\t\tfor (int j = 0; j >=0 ; (flag ? j++ : j--)) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n                    if (i==h-1 && j==w-1) {\n                        flag=!flag;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j >= 0; flag ? j-- : j++) {\n\t\t\t\tfor (int i = 0; i >= 0; flag ? i-- : i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n                    if (i==h-1 && j==w-1) {\n                        flag=!flag;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool flags[21][21];\nchar maps[21][21];\nint W, H;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint dfs(int x, int y)\n{\n  if(x < 0 || y < 0 || x >= H || y >= W || flags[x][y] || maps[x][y] == '#')return 0;\n\n  flags[x][y] = true;\n  int sum = 0;\n  for(int i = 0; i < 4; i++){\n    sum += dfs(x + dx[i], y + dy[i]);\n  }\n  \n  return sum + 1;\n}\n\nint main()\n{\n  while(cin >> W >> H && !((W * H) == 0))\n    {\n      memset(maps, 0, 21 * 21 * sizeof(char));\n      memset(flags, 0, 21 * 21 * sizeof(bool));\n\n      int sx, sy;\n\n      for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n          cin >> maps[i][j];\n          if(maps[i][j] == '@'){\n            sx = i;sy = j;\n          }\n        }\n      }\n      cout << dfs(sx, sy) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <limits>\n#include <cstring>\n\n#define FOR(i,b,n) for(int i=b;i<n; i++)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n\nusing namespace std;\n\nint w, h, sx, sy;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\nchar field[30][30] = {0};\nbool visit[30][30] = {0};\n\nint solve();\nvoid solve_rec(int, int);\n\nint solve()\n{\n\tint res = 0;\n\tCLR(visit);\n\tsolve_rec(sx, sy);\n\t\n\tFOR(j,0,h)\n\t\tFOR(i,0,w)\n\t\t{\n\t\t\tif( visit[j][i] == true\t)\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\n\treturn res;\n}\n\nvoid solve_rec(int x, int y)\n{\n\tif( !(x < 0 || x >= w || y < 0 || y >= h\n\t|| field[y][x] == '#' || visit[y][x] == true ) )\n\t{\n\t\tvisit[y][x] = true;\n\t\t\n\t\tFOR(i, 0, 4)\n\t\t{\n\t\t\tsolve_rec(x+dx[i], y+dy[i]);\n\t\t}\n\t}\n\t\n\treturn;\n}\n\t\nint main()\n{\n\twhile(cin >> w >> h, (w||h))\n\t{\n\t\tFOR(j,0,h)\n\t\t\tFOR(i,0,w)\n\t\t\t{\n\t\t\t\tcin >> field[j][i];\n\t\t\t\t\n\t\t\t\tif( field[j][i] == '@')\n\t\t\t\t{\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcout << solve() << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nint W, H;\nchar t[25][25], s[25][25];\npair<int, int>pd;\nint answer[25];\npair<int, int>alpha;\n\nconst int dx[] = {1,0,-1,0}, dy[]={0,-1,0,1}; //上下左右への移動\n\nvoid bfs(int x, int y){\n\n\tqueue<pair<int, int> >Q;\n\tQ.push(pair<int, int>(x,y));\n\tint cnt = 0;\n\tanswer[cnt] = 0;\n\twhile(!Q.empty()){\n\t\tpair<int, int> cur =  Q.front();\n\n\t\tQ.pop();\n\t\t\n\t\t\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tif(s[cur.first + dx[i]][cur.second + dy[i]] == 1){\n\t\t\t\tQ.push(pair<int, int>(cur.first + dx[i], cur.second + dy[i]));\n\t\t\t\ts[cur.first + dx[i]][cur.second + dy[i]] = 2;\n\t\t\t\t++answer[cnt];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tcout << answer[cnt] + 1 << endl;\n\tcnt++;\n\t\n}\n\nint main(){\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\ts[i][j] = 0;\n\t\t}\n\t}\n\twhile(cin >> W >> H && W != 0){\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tcin >> t[i][j];\n\t\t\t\t//cout << t[i][j]; // 入力の確認\n\t\t\t\tif(t[i][j] == '@'){\n\t\t\t\t\talpha.first = i ;\n\t\t\t\t\talpha.second = j;\n\t\t\t\t\t//cout << alpha.first; //確認用\n\t\t\t\t}else if(t[i][j] == '.'){\n\t\t\t\t\ts[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl; //入力の確認\n\t\t\t\n\t\t}\n\t\tbfs(alpha.first, alpha.second);\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nusing namespace std;\n\nint d4x[] = {0, 1, 0, -1};\nint d4y[] = {-1, 0, 1, 0};\n\nint W, H;\nint reachable(vector<string>& map, int x, int y){\n  //cout << x << \",\" << y << endl;\n  map[y][x] = '#';\n  int res = 0;\n  rep(i, 4){\n    int sx = d4x[i] + x, sy = d4y[i] + y;\n    if(0 <= sx && sx < W && 0 <= sy && sy < H){\n      if(map[sy][sx] != '#'){\n        res += reachable(map, sx, sy);\n      }\n    }\n  }\n  return res + 1;\n}\n\nint main(){\n  while(cin >> W >> H, W != 0){\n    vector<string> map(H);\n    rep(i, H) cin >> map[i];\n    int gy, gx;\n    rep(y, H) {\n      rep(x, W) {\n        if (map[y][x] == '@'){\n          gy = y; gx = x;\n          break;\n        }\n      }\n    }\n    //cout << \"OK\" << endl;\n    cout << reachable(map, gx, gy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n, N) for(ll i=(n); i < N; i++)\n#define CK(N, A, B) (A <= N && N < B)\n#define p(s) cout << (s) << endl\n#define p2(a, b) cout << (a) << ' ' << (b) << endl\nusing namespace std;\ntypedef long long ll;\n\nconst int NODE_SIZE=10101;\nint H;\nint W;\nint start_y, start_x;\n\nstring field_s[NODE_SIZE];\n\nint d[NODE_SIZE][NODE_SIZE];\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nvoid bfs(){\n    queue<pair<int,int>> q;\n    bool visited[H][W];\n    REP(i,0,H) REP(j,0,W) visited[i][j]=false;\n    REP(i,0,H) REP(j,0,W) d[i][j]=-1;\n    q.push({start_y, start_x});\n    d[start_y][start_x]=0;\n    while(!q.empty()){\n        int cur_y = q.front().first;\n        int cur_x = q.front().second;\n        int curStep = d[cur_y][cur_x];\n        q.pop();\n        if(visited[cur_y][cur_x]) continue;\n        visited[cur_y][cur_x] = true;\n\n        REP(k,0,4){\n            int next_y = cur_y + dy[k];\n            int next_x = cur_x + dx[k];\n\n            if(!CK(next_y,0,H) || !CK(next_x,0,W))continue;\n            if(field_s[next_y][next_x]=='#')continue;\n            if(field_s[next_y][next_x]=='.')field_s[next_y][next_x]='@';\n            if(!visited[next_y][next_x]){\n                q.push({next_y, next_x});\n                d[next_y][next_x] = d[cur_y][cur_x] + 1;\n            }\n        }\n    }\n}\n\nint main() {\n\n    while(cin >> W >> H && W) {\n\n        string s;\n        REP(i,0,H){\n            cin >> field_s[i];\n        }\n        REP(i,0,H) REP(j,0,W) if(field_s[i][j]=='@'){\n            start_x = j;\n            start_y = i;\n        }\n        bfs();\n        int cnt=0;\n\n        REP(i,0,H) REP(j,0,W) if(field_s[i][j]=='@')cnt++;\n        p(cnt);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define BLACK   ('.')\n#define RED     ('#')\n#define MAN     ('@')\n#define VISITED ('X')\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nint dfs(std::vector<std::vector<char> >& tiles, const int width, const int height, const int x, const int y) {\n  if (tiles[y][x] == VISITED)\n    return 0;\n  tiles[y][x] = VISITED;\n  int retval = 1;\n  for (int i = 0; i < 4; ++i) {\n    int cx = x + dx[i], cy = y + dy[i];\n    if (cx < 0 || cy < 0 || width <= cx || height <= cy || tiles[cy][cx] == VISITED || tiles[cy][cx] == RED)\n      continue;\n    retval += dfs(tiles, width, height, cx, cy);\n  }\n  return retval;\n}\n\nint main(int argc, char const* argv[])\n{\n  while (true) {\n    int W, H;\n    std::cin >> W >> H;\n    if (W == 0 && H == 0)\n      break;\n    int ix, iy;\n    std::vector<std::vector<char> > tiles(H, std::vector<char>(W, '\\0'));\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        std::cin >> tiles[y][x];\n        if (tiles[y][x] == MAN) {\n          ix = x;\n          iy = y;\n        }\n      }\n    }\n    std::cout << dfs(tiles, W, H, ix, iy) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<list>\n#include<map>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<iomanip>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define debug(x) cout << \"debug\" << x << endl;\nusing namespace std;\n\nint ans;\n\nvoid solve(char map[][22], int x, int y){\n    ans++;\n    map[x][y] = '#';\n    if(map[x+1][y] == '.')\n        solve(map, x+1, y);\n    if(map[x][y+1] == '.')\n        solve(map, x, y+1);\n    if(map[x-1][y] == '.')\n        solve(map, x-1, y);\n    if(map[x][y-1] == '.')\n        solve(map, x, y-1);\n}\n\nint main(){\n    int width, height;\n    while(cin >> width >> height, width||height){\n        char map[22][22], str[22];\n        rep(i,22)\n            rep(j,22)\n                map[i][j] = '#';\n        int x, y;\n        ans = 0;\n        range(i, 1, height + 1){\n            cin >> str;\n            range(j, 1, width + 1){\n                map[i][j] = str[j-1];\n                if(map[i][j] == '@'){\n                    x = i; y = j;\n                }\n            }\n        }\n        solve(map, x, y);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n\nint w , h , count ;\nchar map[21][21] = {} ;\nint dx[] = { -1,0,1,0 } ;\nint dy[] = { 0,1,0,-1 } ;\n\nvoid move( int ny , int nx ){\n\tmap[ny][nx] = '0' ;\n\t\n\tfor( int i=0 ; i<4 ; i++ ){\n\t\tif( ny+dy[i] >= 0 && ny+dy[i] < h &&\n\t\t\tnx+dx[i] >= 0 && nx+dx[i] < w &&\n\t\t\tmap[ny+dy[i]][nx+dx[i]] == '.' ){\n\t\t\t\tcount++;\n\t\t\t\tmove( ny+dy[i] , nx+dx[i] ) ;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint sx , sy ;\n\t\n\twhile(1){\n\t\tcin >> w >> h ;\n\t\tif( w==0 && h==0 ) break ;\n\t\t\n\t\tcount = 1 ;\n\t\tfor( int i=0 ; i<h ; i++ ){\n\t\t\tfor( int j=0 ; j<w ; j++ ){\n\t\t\t\tcin >> map[i][j] ;\n\t\t\t\tif( map[i][j] == '@' ){\n\t\t\t\t\tsx = j ;\n\t\t\t\t\tsy = i ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmove(sy,sx) ;\n\t\t\n\t\tcout << count << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define DECIM8  fixed<<setprecision(8) \n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nint field[32][32];\nint dfs(int x,int y){\n  int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\n  if(field[x][y]==0) return 0;\n  field[x][y]=0;\n  int answer=1;\n  REP(i,4) answer += dfs(x+dx[i],y+dy[i]);\n  return answer;\n}\nint main(void)\n{\n  for(;;){\n    int w,h;\n    cin >> w >> h;\n    if(!w&&!h) return 0;\n    REP(i,32) REP(j,32) field[i][j]=0;\n    vector<string> fi;\n    fi.resize(h);\n    REP(i,h) cin >> fi[i];\n    REP(i,h) REP(j,w) if(fi[i][j]!='#') field[i+5][j+5]=1;\n    REP(i,h) REP(j,w) if(fi[i][j]=='@')\n      cout << dfs(i+5,j+5) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ans;\nint w, h;\nchar map[20][20];\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nvoid solve(int x, int y)\n{\n\tans++;\n\tmap[x][y] = '#';\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (0 <= X && X < w && 0 <= Y && Y < h && map[X][Y] != '#')\n\t\t{\n\t\t\tsolve(X, Y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w + h)\n\t{\n\t\tans = 0;\n\t\tfor (int y = 0; y < h; y++)\n\t\t{\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t{\n\t\t\t\tcin >> map[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; y++)\n\t\t{\n\t\t\tfor (int x = 0; x < w; x++)\n\t\t\t{\n\t\t\t\tif (map[x][y] == '@') solve(x, y);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nchar map[20][20]={0};\nint number=1;\nint h,w;\n\nvoid debug(void) {\n\tfor(int i=0;i<h;i++) { for(int j=0;j<w;j++) putchar(map[i][j]); putchar('\\n'); }\n}\n\nvoid trace(int x,int y) {\n\tif(x-1 >= 0 && map[y][x-1]=='.') {\n\t\tmap[y][x-1] = '@';\n\t\ttrace(x-1,y);\n\n\t\tnumber++;\n\t}\n\n\tif(x+1 < w && map[y][x+1]=='.') {\n\t\tmap[y][x+1] = '@';\n\t\ttrace(x+1,y);\n\t\tnumber++;\n\t}\n\tif(y-1 >= 0 && map[y-1][x]=='.') {\n\t\tmap[y-1][x] = '@';\n\t\ttrace(x,y-1);\n\t\tnumber++;\n\t}\n\n\tif(y+1 < h && map[y+1][x]=='.') {\n\t\tmap[y+1][x] = '@';\n\t\ttrace(x,y+1);\n\t\tnumber++;\n\t}\n}\n\nint main(void) {\n\tchar buf[21];\n\n\tint x,y;\n\n\n\tfor(;;) {\n\n\t\tnumber=1;\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\n\t\tif(w==0 || h==0) break;\n\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tfgets(buf,1024,stdin);\n\n\t\t\tmemcpy(&map[i],buf,w);\n\t\t}\n\n\n\t\tfor(int j=0;j<h;j++) {\n\t\t\tfor(int i=0;i<w;i++) {\n\t\t\t\tif(map[j][i] == '@'){\n\t\t\t\t\tx=i;y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\ttrace(x,y);\n\n\t\tprintf(\"%d\\n\",number);\n\n\t}\n\n\t//debug();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\n\nvoid debugprint(vector<vector<char>> &data) {\n    cerr << endl;\n    for(int h=0; h<H; h++) {\n        for(int w=0; w<W; w++) {\n            cerr << data[h][w];\n        }\n        cerr << endl;\n    }\n    cerr << endl;\n}\n\nint tansaku(vector<vector<char>> &data, int w, int h)\n{\n    int counter = 0;\n    data[h][w] = 'x';\n    counter += 1;\n    if(w+1<W && data[h][w+1]=='.') counter += tansaku(data, w+1, h);\n    if(w-1>=0 && data[h][w-1]=='.') counter += tansaku(data, w-1, h);\n    if(h-1>=0 && data[h-1][w]=='.') counter += tansaku(data, w, h-1);\n    if(h+1<H && data[h+1][w]=='.') counter += tansaku(data, w, h+1);\n    return counter;\n}\n\nint solve() {\n    int start_pos_w, start_pos_h;\n    cin >> W >> H;\n    if(W==0&&H==0) return 0;\n\n    vector<vector<char>> datas;\n    datas.resize(H);\n\n    for(int h=0; h<H; h++) {\n        for(int w=0; w<W; w++) {\n            char data;        \n            cin>>data;\n            if(data=='@') {\n                start_pos_w = w;\n                start_pos_h = h;\n            }\n            datas[h].push_back(data);\n        }\n    }\n\n    int count = tansaku(datas, start_pos_w, start_pos_h);\n    cout << count << endl;\n    return 1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(solve()){}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint W, H;\nint lab[20][20];\nstring tmp;\nqueue<pair<int, int> > now;\nint dirs[4][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\nbool check_point(pair<int, int> point) {\n    bool ret = true;\n    ret &= point.first > -1;\n    ret &= point.second > -1;\n    ret &= point.first < H;\n    ret &= point.second < W;\n    ret &= lab[point.first][point.second] == int_max;\n    return ret;\n}\nint bfs() {\n    int cnt = 1;\n    while (!now.empty()) {\n        pair<int, int> start = now.front();\n        now.pop();\n        for (auto dir : dirs) {\n            auto next = make_pair(start.first + dir[0], start.second + dir[1]);\n            if (check_point(next)) {\n                now.push(next);\n                lab[next.first][next.second] = lab[start.first][start.second] + 1;\n                ++cnt;\n            }\n        }\n    }\n    return cnt;\n}\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> W >> H && W && H) {\n        rep(h, H) {\n            cin >> tmp;\n            rep(w, W) {\n                switch (tmp[w]) {\n                    case '.':\n                        lab[h][w] = int_max;\n                        break;\n                    case '#':\n                        lab[h][w] = int_min;\n                        break;\n                    case '@':\n                        lab[h][w] = 0;\n                        now.push(make_pair(h, w));\n                        break;\n                }\n            }\n        }\n        cout << bfs() << endl;\n    }    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar maze[21][21];\n#define r(z,x) for(int z=0;z<x;z++)\nint ans;\nvoid dfs(int x,int y){\n\tint dx[4]={0,-1,0,1};\n\tint dy[4]={1,0,-1,0};\n\tmaze[x][y]='#';\n\tans++;\n\tr(i,4)if(maze[x+dx[i]][y+dy[i]]=='.')dfs(x+dx[i],y+dy[i]);\n}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a||b){\n\t\tans=0;\n\t\tfill(maze[0],maze[20],'#');\n\t\tr(i,b)r(j,a)cin>>maze[i][j];\n\t\tr(i,b)r(j,a)if(maze[i][j]=='@')dfs(i,j),cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <functional>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nconst int vx[4] = {0, 1, 0, -1}, vy[4] = {1, 0, -1, 0};\n\nint W, H;\nstd::string s[21];\nbool is_searched[21][21];\n\nint dfs(int x, int y) {\n\tint ret = 0;\n\tis_searched[x][y] = true;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i];\n\n\t\tif(0 <= nx && nx < H && 0 <= ny && ny < W &&\n\t\t   !is_searched[nx][ny] && s[nx][ny] == '.') {\n\n\t\t\tret += dfs(nx, ny) + 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint solve() {\n\tint ret = 0;\n\tint sx, sy;\n\n\tstd::memset(is_searched, false, sizeof is_searched);\n\n\tfor(int i = 0; i < H; ++i) {\n\t\tfor(int j = 0; j < W; ++j) {\n\t\t\tif(s[i][j] == '@') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = dfs(sx, sy) + 1; // +1 は'@' の分\n\n\treturn ret;\n}\n\nint main() {\n\n\twhile(cin >> W >> H, W | H) {\n\t\tfor(int i = 0; i < H; ++i) {\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tint ans = solve();\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint explorer(vector<string> *map,int i, int j){\n\tif(map->at(i)[j]=='#') return 0;\n\t\n\tint cnt=1;\n\tvector<int>vi;\n    vi.reserve(4);\n\tvector<int>vj;\n    vj.reserve(4);\n\t\n\tmap->at(i)[j]='#';\n\t\n\tif(i!=0&&map->at(i-1)[j]=='.'){\n\t\tvi.push_back(i-1);\n\t\tvj.push_back(j);\n\t}if(i+1!=map->size()&&map->at(i+1)[j]=='.'){\n\t\tvi.push_back(i+1);\n\t\tvj.push_back(j);\t\t\n\t}if(j!=0&&map->at(i)[j-1]=='.'){\n\t\tvi.push_back(i);\n\t\tvj.push_back(j-1);\t\t\n\t}if(j+1!=map->at(i).size()&&map->at(i)[j+1]=='.'){\n\t\tvi.push_back(i);\n\t\tvj.push_back(j+1);\t\t\n\t}\n\n\twhile(!vi.empty()){\n    cout<<i<<j<<endl;\n\t\tcnt += explorer(map,vi.back(),vj.back());\n\t\tvi.pop_back();\n\t\tvj.pop_back();\n\t}\n\n\treturn cnt;\n}\n\nint main() {\n\tint w,h;\n\t\n\twhile(cin >> w >> h,w){\n\tvector<string> map;\n\tint psx=0,psy=0;\n\tmap.resize(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> map[i];\n\t\t\n\t\tif(psx==0){\n\t\t\tif(map[i].find('@')!=-1){\n\t\t\t\tpsx=map[i].find('@');\n\t\t\t\tpsy=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << explorer(&map,psy,psx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\n\nconst int MAX=30;\n\nint count=0;\n\nint w,h;\nint tile[MAX][MAX];//0->rot 1->schwarz 2->besucht\n\nint search(int a,int b)\n{\n    if(a<0 || a>=h || b<0 || b>=w)\n    {\n        return 0;\n    }\n    switch(tile[a][b])\n    {\n        case 0:\n        case 2:\n            return 0;\n        case 1:\n        {\n            count++;\n            tile[a][b]=2;\n            search(a-1,b);\n            search(a+1,b);\n            search(a,b-1);\n            search(a,b+1);\n        }\n    }\n    return 1;\n}\n\n\nint main(void)\n{\n    while(scanf(\"%d%d\",&w,&h)==2 &&(w||h))\n    {\n        int rc=0;\n        int sa,sb;\n        while(rc<w*h)\n        {\n            int ch=getchar();\n            switch(ch)\n            {\n                case '.':\n                    tile[rc/w][rc%w]=1;\n                    rc++;\n                    break;\n                case '#':\n                    tile[rc/w][rc%w]=0;\n                    rc++;\n                    break;\n                case '@':\n                    tile[rc/w][rc%w]=1;\n                    sa=rc/w;\n                    sb=rc%w;\n                    rc++;\n                    break;\n            }\n        }\n        count=0;\n        search(sa,sb);\n        printf(\"%d\\n\",count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint ch[22][22],cnt;\nint dfs(int,int);\nint main(){\n  int w,h,i,j,k,l,result;\n  string in[20];\n  while(1){\n    cnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> in[i];\n    }\n    for(i=0;i<h+2;i++){\n      for(j=0;j<w+2;j++){\n\tch[i][j]=1;\n      }\n    }\n    for(i=0,k=1;k<h+1;i++,k++){\n      for(j=0,l=1;l<w+1;l++,j++){\n\tif(in[i][j]=='.') ch[k][l]=0;\n\telse if(in[i][j]=='#') ch[k][l]=1;\n\telse ch[k][l]=2;\n      }\n    }\n    for(i=1;i<h;i++){\n      for(j=1;j<w;j++){\n\tif(ch[i][j]==2) result=dfs(i,j);\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nint dfs(int i,int j){\n  if(ch[i][j]==1) return 0;\n  ch[i][j]=1;\n  cnt++;\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j-1);\n  dfs(i,j+1);\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define frp(i,n) for((i)=0;(i)<(n);i++)\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\nint H,W;\nvector<int> red1;\nvector<int> red2;\nint check(int n1,int n2){\n  for(int i=0;i<red1.size();i++){\n    if(n1==red1[i]&&n2==red2[i]||n1<0||n2<0||n1>H||n2>W)\n      return 0;\n  }\n  return 1;\n}\nint main(){\n  int i,j;\n  string str2;\n  vector<string> str;\n  while(cin>>W>>H,W+H!=0){\n    int num=1;\n    frp(i,H){\n      cin>>str2;\n      str.push_back(str2);\n    }\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='#'){\n\t  red1.push_back(i);\n\t  red2.push_back(j);\n\t}\n      }\n    }\n    queue<pair<int,int> > qii;\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='@')\n\t  qii.push(make_pair(i,j));\n      }\n    }\n    while(!qii.empty()){\n      int now1=qii.front().first;\n      int now2=qii.front().second;\n      qii.pop();//?????????????´??????´?£?\n      for(i=0;i<4;i++){\n\tif(check(now1+vx[i],now2+vy[i])==1){\n\t  red1.push_back(now1);\n\t  red2.push_back(now2);\n\t  qii.push(make_pair(now1+vx[i],now2+vy[i]));\n\t  num++;\n\t}\n      }\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint h,w;\nchar ta[22][22];\n//int cheak[22][22]={0};\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint cou=0;\n\nint main(){\n  int a,b;\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    cou=0;\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> ta[i][j];\n\tcheak[i][j]=0;\n\tif(ta[i][j] == '@'){\n\t  a=i,b=j;\n\t}\n      }\n    }\n    //cout << a << \" \" << b << endl;\n    cout << dfs(a,b) << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n      cout << cheak[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n}\n\nvoid dfs(int x,int y){\n  //cheak[x][y]=1;\n  ta[nx][ny]='#';\n  cou++;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx>=0 && nx<h && ny>=0 && ny<w && ta[nx][ny]=='.'){\n      dfs(nx,ny);\n    }\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\nvvi f;\nint ans=0;\nvoid search(int x,int y){\n    vi v={1,0,-1,0,1};\n    rep(i,4){\n        if(f[y+v[i]][x+v[i+1]]==1){\n            f[y+v[i]][x+v[i+1]]=0;\n            ans++;\n            search(x+v[i+1],y+v[i]);\n        }\n    }\n}\n\nint main(void){\n    int w,h;\n    while(cin>>w>>h,w){\n        ans=0;\n        f=vvi(h+2,vi(w+2,0));\n        int x,y;\n        rep(i,h)rep(j,w){\n            char c; cin>>c;\n            if(c=='.')f[i+1][j+1]=1;\n            if(c=='@')y=i+1,x=j+1;\n        }\n        search(x,y);\n        cout<<ans+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> C[i][j];\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n?????????????????????????????????\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tint tot=1; //?????£????????????(?????????????????????)\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\ttot++;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n\tcout << tot <<endl;\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int mp[21][21];\n  int w,h;\n  int x[4]={1,-1,0,0};\n  int y[4]={0,0,1,-1};\n  int m;\n  bool b;\n  char s;\n  int ans;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    ans=0;\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\tmp[i][j]=0;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>s;\n\tif(s=='#') mp[i][j]=1;\n\telse if(s=='@') mp[i][j]=2;\n      }\n    }\n    b=true;\n    while(b){\n      b=false;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(mp[i][j]==2){\n\t    /*for(int k=0;k<4;k++){*/\n\t      if(mp[i+1][j]==0){\n\t\tmp[i+1][j]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i-1][j]==0){\n\t\tmp[i-1][j]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i][j+1]==0){\n\t\tmp[i][j+1]=2;\n\t\tb=true;\n\t      }\n\t      if(mp[i][j-1]==0){\n\t\tmp[i][j-1]=2;\n\t\tb=true;\n\t      }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\t/*cout<<mp[i][j]<<\" \";*/\n\tif(mp[i][j]==2) ans++;\n      }\n      /* cout<<endl;*/\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n  \n    \n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\nint ans = 0;\n\nvoid bfs(char **tile, int w, int h){\n  ans++;\n  tile[w][h] = '#';\n\n  if(tile[w][h-1] == '.')\n  bfs(tile, w, h-1);\n\n  if(tile[w][h+1] == '.')\n  bfs(tile, w, h+1);\n\n  if(tile[w-1][h] == '.')\n  bfs(tile, w-1, h);\n\n  if(tile[w+1][h] == '.')\n  bfs(tile, w+1, h);\n\n  return;\n}\n\n\nint main(){\n  int W,H,index_w,index_h;\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n\n    char **tile;\n    tile = new char* [H+2];\n    REP(i,H+2) tile[i] = new char[W+2];\n\n    REP(i,H+2){\n      REP(j,W+2){\n        if(i == 0 || i == H+1 || j == 0 || j == W+1) tile[i][j] = '#'; //sentry\n        else scanf(\" %c\",&tile[i][j]);\n\n        if(tile[i][j] == '@') {\n          index_h = j;\n          index_w = i;\n        }\n\n      }\n    }\n    ans = 0;\n    bfs(tile,index_w,index_h);\n    \n    REP(i,H) delete[] tile[i];\n    delete[] tile;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nchar n[100][100];int k[100][100],l[100][100],sum,H,W,i,j,m,s;\n#define A(B,C) if(k[B][C]!=1){l[B][C]=1;}\nint main(){while(true){s=0;memset(l,0,sizeof(l));std::cin>>W>>H;if(W==0){break;}for(i=1;i<=H;i++){for(j=1;j<=W;j++){std::cin>>n[i][j];if(n[i][j]=='.'){k[i][j]=0;}else if(n[i][j]=='@'){k[i][j]=2;l[i][j]=1;}else{k[i][j]=1;}}}\nfor(i=0;i<2500;i++){for(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){A(j-1,m);A(j+1,m);A(j,m-1);A(j,m+1);}}}}\nfor(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){s++;}}}scanf(\"%d\\n\",s);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 20\nusing namespace std;\n\ntypedef pair<int,int> P;\nint X, Y, ans;\n\nchar field[MAX][MAX];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nvoid bfs(int px, int py)\n{\n     field[px][py] = '#';\n     ans++;\n     for (int i = 0; i < 4; i++) {\n\t  int x = px + dx[i], y = py + dy[i];\n\t  if (0 <= x && x < X && 0 <= y && y < Y && field[x][y] == '.') bfs(x,y);\n     }\n}\n\nint main(void)\n{\n     int x, y;\n     while (cin >> Y >> X && X && Y) {\n\t  for (int i = 0; i < X; i++)\n\t       for (int j = 0; j < Y; j++) {\n\t\t    cin >> field[i][j];\n\t\t    if (field[i][j] == '@') {\n\t\t\t x = i;\n\t\t\t y = j;\n\t\t    }\n\t       }\n\t  ans = 0;\n\t  bfs(x,y);\n\t  cout << ans << endl;\n     }\n\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nint w, h;\nchar field[100][100];\n\nint dfs(int x, int y) {\n  if (field[y][x] == '#') { return 0; }\n  field[y][x] = '#';\n  int ret = 1;\n  const int dx[4] = { 1, -1, 0, 0 };\n  const int dy[4] = { 0, 0, 1, -1 };\n  REP(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    ret += dfs(nx, ny);\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(field, '#');\n    int sx, sy;\n    FOR(y, 1, h + 1) FOR(x, 1, w + 1) {\n      scanf(\" %c \", &field[y][x]);\n      if (field[y][x] == '@') {\n        field[y][x] = '.';\n        sx = x; sy =y;\n      }\n    }\n    printf(\"%d\\n\", dfs(sx, sy));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint W, H, ans;\nchar maze[20][20];\n\nbool check(int x, int y){\n\treturn x >= 0 && x < W && y >= 0 && y < H;\n}\n\nvoid dfs(int x, int y){\n\t\n\t\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(check(nx, ny) && maze[ny][nx] != '#'){\n\t\t\tmaze[ny][nx] = '#';\n\t\t\tans++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> W >> H && (W || H)){\n\t\tfor(int i = 0; i < H; ++i)\n\t\t\tfor(int j = 0; j < W; ++j)\n\t\t\t\tcin >> maze[i][j];\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(maze[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n\nusing namespace std;\n\n\n#define YES cout<<\"YES\"<<endl\n#define NO cout<<\"NO\"<<endl\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl\n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\n\n#define Tof(x) (x) ? Yes : No\n#define TOF(x) (x) ? YES : NO\n#define tof(x) (x) ? yes : no\n\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1050000000;\n\n\n/*vectorの要素を全部確認するやつだよ。普通に拡張for文したほうがいいよ。\n\nfor (vector<int>::iterator itr = ans.begin(); itr != ans.end(); ++itr) {\n\tcout << *itr << \" \";\n}\n\n*/\n\n\n/*for文でx,yを上下左右確認するやつだよ。正直使いづらいよ。\n\nint dy[] = { 0, 1, 0, -1 };\nint dx[] = { 1, 0, -1, 0 };\n\n\nfor (int i = 0; i < 4; i++) {\n\tint ny = y + dy[i];\n\tint nx = x + dx[i];\n}\n\n*/\n\n\n/*繰り返し二乗法だよ。modもとってくれるよ。n^kをmodで割った余りでやってくれるよ。\n\nll POW_MOD(ll n, ll k, ll mod) {\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\n\n*/\n\n\n/*実行開始からの経過時間を表すよ。\n\nwhile (clock() < 1900000) {  }\n\n*/\n\n\n/*まだ使えないテクニックのメモだよ。\n\nfor (int bit = 0; bit < (1<<n); ++bit)//bit全探索用のfor文だよ\n\n*/\n\n\n/*2重for文書くのめんどくなった時用だよ。\n\nfor (int i = 0; i < h; ++i) {\n\tfor (int j = 0; j < w; ++j) {\n\n\t}\n}\n\n*/\n\nint dy[] = { 0, 1, 0, -1 };\nint dx[] = { 1, 0, -1, 0 };\n\nint main() {\n\tint w, h;\n\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) { return 0; }\n\n\t\tchar a[22][22];\n\t\tmemset(a, '!', sizeof(a));\n\n\t\tbool check[22][22];\n\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcheck[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tqueue<pair<int, int>> q;\n\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == '@') { q.push(make_pair(i, j)); check[i][j] = true; }\n\t\t\t}\n\t\t}\n\n\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> n = q.front(); q.pop();\n\n\t\t\tint x = n.first;\n\t\t\tint y = n.second;\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (a[x + dx[i]][y + dy[i]] == '.' && check[x + dx[i]][y + dy[i]] == false) {\n\t\t\t\t\tcheck[x + dx[i]][y + dy[i]] = true; q.push(make_pair(x + dx[i], y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (check[i][j]) { ans++; }\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n */\n\n\n#include <iostream>\n#include <limits>\n\nconstexpr size_t MAX_HEIGHT = 20;\nconst char START_TILE = '@';\nconst char PASSABLE_TILE = '.';\nconst char PROHIBITED_TILE = '#';\nconst char PASSED_TILE = 'P';\n\nbool is_wall(std::string world[MAX_HEIGHT], size_t x, size_t y) {\n\tchar tile = world[y][x];\n\treturn tile == PROHIBITED_TILE || tile == PASSED_TILE;\n}\n\nbool valid(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\treturn x < width && y < height // x and y is unsigned\n\t\t   && !is_wall(world, x, y);\n}\n\nint walk(std::string world[MAX_HEIGHT], size_t width, size_t height, size_t x, size_t y) {\n\tif (!valid(world, width, height, x, y)) {\n\t\treturn 0; // ????????????????????\\?????????????£?or??¢?´¢??????\n\t}\n\tint total = 1; // ????????????????????\\?????????1?????¨??????????????????\n\tworld[y][x] = PASSED_TILE; // ??????????????¨????????????????????¨?????????????????????????????????\n\t// ?????????????????§??????????????????valid???????????????walk????????§\n\ttotal += walk(world, width, height, x - 1, y);\n\ttotal += walk(world, width, height, x + 1, y);\n\ttotal += walk(world, width, height, x, y - 1);\n\ttotal += walk(world, width, height, x, y + 1);\n\treturn total;\n}\n\nvoid process(size_t width, size_t height) {\n\tstd::string world[MAX_HEIGHT];\n\tsize_t x = std::numeric_limits<size_t>::max(), y = std::numeric_limits<size_t>::max();\n\tfor (size_t i = 0; i < height; ++i) {\n\t\tstd::cin >> world[i];\n\t\tsize_t start_index = world[i].find(START_TILE);\n\t\tif (start_index != std::string::npos) {\n\t\t\tx = start_index;\n\t\t\ty = i;\n\t\t}\n\t}\n\n\tstd::cout << walk(world, width, height, x, y) << std::endl;\n}\n\nint main() {\n\tsize_t width, height;\n\twhile (true) {\n\t\tstd::cin >> width >> height;\n\t\tif (width == 0 || height == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tprocess(width, height);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<stdlib.h>\n#include<set>\n#include<string>\n#include<queue>\n#include<map>\n#include<stack>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint w, h;\n\tint sx, sy;\n\tint dx[4] = { 1, 0, -1, 0 }, dy[4] = {0 , 1 , 0 , -1};\n\tchar str[20];\n\n\tcin >> w >> h;\n\tdo{\n\t\tint masu[20][20] = { 0 };\n\t\tint check_masu[20][20] = { 0 };\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> str;\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tmasu[j][i] = str[j];\n\t\t\t\tif (masu[j][i] == '@'){\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\t\tint count = 0; //count looked check\n\t\tstack< pair<int, int> > s;\n\t\ts.push(make_pair(sx, sy));\t//set start place \n\t\twhile (s.size()){\n\t\t\tx = s.top().first;\n\t\t\ty = s.top().second;\n\t\t\ts.pop();\n\n\t\t\tif (check_masu[x][y] == 'c' || masu[x][y] == '#')\n\t\t\t\tcontinue;\n\n\t\t\tcheck_masu[x][y] = 'c';\t//looked\n\t\t\tcount++;\n\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif ((0 <= x + dx[i] && x + dx[i] < w)\n\t\t\t\t\t&& (0 <= y + dy[i] && y + dy[i] < h)){\n\n\t\t\t\t\ts.push(make_pair(x + dx[i], y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\n\t\tcin >> w >> h;\n\t} while (w != 0 && h != 0);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nint cnt, w, h;\nchar m[20][20];\n\nvoid dfs(pii);\n\nint main(void){\n    while(cin >> w >> h, w){\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n\n        dfs(p);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if(p.X < 0 || w <= p.X ||\n            p.Y < 0 || h <= p.Y) return;\n\n    if(m[p.Y][p.X] == '.'){ cnt ++; m[p.Y][p.X] = '#';}\n    else return;\n    rep(i, 4){\n        pii next = mp(p.X + dx[i], p.Y + dy[i]);\n        dfs(next);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\ninline bool in(int x, int y,int w,int h){\n    return 0<=x&&0<=y && y<h && x<w;\n}\n\nint solve(vs & g){\n    int h=g.size();int w=g[0].size();\n    int sx,sy;\n    rep(i,h)rep(j,w)if(g[i][j]=='@'){\n        sx=j;sy=i;\n    }\n\n\n    while(1){\n        bool fine=true;\n        \n        rep(y,h)rep(x,w){\n            if(g[y][x]=='@'){\n                rep(d,4){\n                    int nx=x+dx[d];\n                    int ny=y+dy[d];\n                    if(!in(nx,ny,w,h)) continue;\n                    if(g[ny][nx]!='.') continue;\n                    g[ny][nx]='@';\n                    fine=false;\n                }\n            }\n        }\n        \n        if(fine)break;\n    }\n\n    // rep(i,h)cout<<g[i]<<endl;\n\n    int c=0;\n    rep(i,h)rep(j,w)c+=g[i][j]=='@';\n    return c;\n}\n\n\nint main(){\n    int w,h;\n    while(cin>>w>>h && w){\n        vs g(h);\n        rep(i,h)cin>>g[i];\n        cout<<solve(g)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint explorer(vector<string> *map,int i, int j){\n\tif(map->at(i)[j]=='#') return 0;\n\t\n\tint cnt=1;\n\tvector<int>vi;\n    vi.reserve(4);\n\tvector<int>vj;\n    vj.reserve(4);\n\t\n\tmap->at(i)[j]='#';\n\t\n\tif(i!=0&&map->at(i-1)[j]=='.'){\n\t\tvi.push_back(i-1);\n\t\tvj.push_back(j);\n\t}if(i+1!=map->size()&&map->at(i+1)[j]=='.'){\n\t\tvi.push_back(i+1);\n\t\tvj.push_back(j);\t\t\n\t}if(j!=0&&map->at(i)[j-1]=='.'){\n\t\tvi.push_back(i);\n\t\tvj.push_back(j-1);\t\t\n\t}if(j+1!=map->at(i).size()&&map->at(i)[j+1]=='.'){\n\t\tvi.push_back(i);\n\t\tvj.push_back(j+1);\t\t\n\t}\n\n\twhile(!vi.empty()){\n\t\tcnt += explorer(map,vi.back(),vj.back());\n\t\tvi.pop_back();\n\t\tvj.pop_back();\n\t}\n\n\treturn cnt;\n}\n\nint main() {\n\tint w,h;\n\t\n\twhile(cin >> w >> h,w){\n\tvector<string> map;\n\tint psx=0,psy=0;\n\tmap.resize(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> map[i];\n\t\t\n\t\tif(psx==0){\n\t\t\tif(map[i].find('@')!=-1){\n\t\t\t\tpsx=map[i].find('@');\n\t\t\t\tpsy=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << explorer(&map,psy,psx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(){\n    int W,H,x0,y0,sum=0;\n    char t[20][20];\n    bool visit[20][20];\n    const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n    typedef pair<int,int>P;\n    queue<P>Q;\n    while(cin>>W>>H){\n        if(W==0||H==0)break;\n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                cin>>t[i][j];\n                if(t[i][j]=='@'){\n                    x0=j;\n                    y0=i;\n                }\n                visit[i][j]=true;\n            }\n        }\n        Q.push(P(x0,y0));\n        visit[y0][x0]=false;\n        while(!Q.empty()){\n            int srcx=Q.front().first;\n            int srcy=Q.front().second;\n            Q.pop();\n            sum++;\n            for(int i=0;i<4;++i){\n                int curx=srcx+dx[i];\n                int cury=srcy+dy[i];\n                if(t[cury][curx]=='#') continue;\n                if(curx<0||curx>=W||cury<0||cury>=H) continue;\n                if(!visit[cury][curx]) continue;\n                visit[cury][curx]=false;\n                Q.push(P(curx,cury));\n            }\n            \n        }\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nchar ban[21][21];\nint cont = 0;\n\n\tint w, h;\n\t\n\tint MAX = 0;\n\nvoid saiki(int y, int x)\n{\n\tcont++;\n\tban[y][x] = '_';\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcout << ban[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tcout << w << h << endl;\n\t\n\tgetchar();\n\t\n\tcout << cont << endl;;\n\t*/\n\t\n\tif(ban[y+1][x] == '.'){\n\t\tsaiki(y+1,x);\n\t}\n\tif(ban[y-1][x] == '.' && y-1 > -1){\n\t\tsaiki(y-1,x);\n\t} \n\tif(ban[y][x-1] == '.' && x-1 > -1){\n\t\tsaiki(y,x-1);\n\t}\n\tif(ban[y][x+1] == '.'){\n\t\tsaiki(y,x+1);\n\t}\n\t\n\tif(cont > MAX){\n\t\tMAX = cont;\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tint st_x, st_y;\n\t\tMAX = cont = 0;\n\t\t\n\t\tcin >> w >> h;\n\t\t\n\t\tif( w == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tban[i][j] = '0';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> ban[i][j];\n\t\t\t\tif(ban[i][j] == '@'){\n\t\t\t\t\tst_x = j;\n\t\t\t\t\tst_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tsaiki(st_y,st_x);\n\t\t\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[4] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tscanf(\"%s\", C[i]);\n\t\t}\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 横型探索\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint w, h;\nint mx[] = {0, 0, -1, 1};\nint my[] = {-1, 1, 0, 0};\n\nint main() {\n    while ( true ) {\n        int x, y, cnt = 0;\n        cin >> w >> h;\n        if ( w == 0 && h == 0 ) break;\n\n        vector<string> v(h);\n        queue<int> s;\n\n        for ( int i = 0; i < h; i++ ) {\n            cin >> v[i];\n\n            // @の座標を記録\n            for ( int j = 0; j < v[i].size(); j++ ) {\n                if ( v[i][j] == '@' ) {\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n\n        // キューにスタート地点を追加\n        s.push(x);\n        s.push(y);\n\n        while(!s.empty()) {\n            x = s.front(); s.pop();\n            y = s.front(); s.pop();\n\n            for ( int i = 0; i < 4; i++ ) {\n                int nx = x + mx[i], ny = y + my[i];\n                if ( 0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == '.' ) {\n                    v[ny][nx] = '#';\n                    s.push(nx);\n                    s.push(ny);\n                }\n            }\n            cnt++;\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\ttot++;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\n\nint main() {\n  int n,m;\n  while(cin >> m >> n && n) {\n    string s[n];\n    for(int i=0; i<n; i++) cin >> s[i];\n    queue<P> que;\n    bool u[n][m];\n    memset(u,0,sizeof(u));\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n        if(s[i][j]=='@') {\n          que.push(P(i,j));\n          u[i][j]=1;\n        }\n      }\n    }\n    while(!que.empty()) {\n      P p=que.front();que.pop();\n      int xx=p.first,yy=p.second;\n      for(int i=0; i<4; i++) {\n        int x=xx+dx[i],y=yy+dy[i];\n        if(!check(n,m,x,y)||u[x][y]||s[x][y]=='#') continue;\n        u[x][y]=1;\n        que.push(P(x,y));\n      }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)ans+=u[i][j];\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\n#include <tuple>\n#include <cctype>\n#include <bitset>\n#include <complex>\n#include <cmath>\n#include <array>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3fLL\n#define MOD 1000000007\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pint;\ntypedef pair<ll,ll> pll;\ntypedef tuple<int,int,int> tint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\nint dx[8]={0,0,-1,1,1,1,-1,-1};\nint dy[8]={-1,1,0,0,1,-1,1,-1};\nconst int SIZE=100050;\n//ここまでテンプレ\nint main(){\n\twhile(1){\n\t\tint W,H;\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)\n\t\t\treturn 0;\n\t\tint ans=1;\n\t\tvector<string> S;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tS.pb(s);\n\t\t}\n\t\tqueue<pint> Q;\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(S[i][j]=='@')\n\t\t\t\t\tQ.push(mp(j,i));\n\t\twhile(Q.size()){\n\t\t\tpint P=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint X=P.first+dx[k],Y=P.second+dy[k];\n\t\t\t\tif(X<0 || W<=X || Y<0 || H<=Y)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(S[Y][X]=='.'){\n\t\t\t\t\tQ.push(mp(X,Y));\n\t\t\t\t\tS[Y][X]='@';\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar map[20][20];\n\nint W, H, start_x, start_y, ans = 0;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y)\n{\n  ans++;\n  if(map[x][y] != '#'){\n    map[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n      int next_x = x + dx[i], next_y = y + dy[i];\n      if(next_x < W && next_x >= 0 && next_y < H && next_y >= 0){\n\tif(map[next_x][next_y] == '#')\n\t  continue;\n\tdfs(next_x, next_y);\n      }else{\n\tcontinue;\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0){\n      break;\n    }else{\n      for(int i = 0; i < H; i++){\n\tfor(int j = 0; j < W; j++){\n\t  cin >> map[j][i];\n\t  if(map[j][i] == '@'){\n\t    start_x = j;\n\t    start_y = i;\n\t  }\n\t}\n      }\n      dfs(start_x, start_y);\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a ; i<b ; i++)\n#define dump(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\nint h, w;\nchar maze[20][20];\nint reach[20][20];\npair<int, int> st;\n\nvoid disp(){\n\trep(i,0,h){\n\t\trep(j,0,w) cout << maze[i][j];\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\trep(i,0,h){\n\t\trep(j,0,w) cout << reach[i][j];\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint dr[4] = {0, -1, 0, 1};\nint dc[4] = {-1, 0, 1, 0};\n\nvoid dfs(int r, int c){\n\tif(r<0 or r>h-1 or c<0 or c>w-1) return ;\n\tif(maze[r][c] == '#' or reach[r][c] == 1) return ;\n\n\treach[r][c] = 1;\n\trep(i,0,4){\n\t\tdfs(r+dr[i], c+dc[i]);\n\t}\n\treturn;\n}\n\nvoid solve(){\n\tint ans=0;\n\n\trep(i,0,h) rep(j,0,w){\n\t\tif(reach[i][j] == 1) ans++;\n\t}\n\tcout << ans << endl;\n\treturn;\n}\n\nint main(){\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(h == 0) break;\n\n\t\trep(i,0,h) rep(j,0,w){\n\t\t\tcin >> maze[i][j];\n\t\t\treach[i][j] = 0;\n\t\t\tif(maze[i][j] == '@'){\n\t\t\t\tst.first = i;\n\t\t\t\tst.second = j;\n\t\t\t}\n\t\t}\n\t\tdfs(st.first, st.second);\n\t\tsolve();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nconst int tx[] = {0,1,0,-1};\nconst int ty[] = {1,0,-1,0};\n\nchar stage[20][20];\n\nint main(){\n\tint W,H;\n\twhile(~scanf(\"%d %d\",&W,&H)){\n\t\tif(W==H && H==0) break;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tchar buf[32];\n\t\t\tscanf(\"%s\",buf);\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tstage[y][x] = buf[x];\n\t\t\t}\n\t\t}\n\n\t\tint sx=0;\n\t\tint sy=0;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(stage[y][x] == '@'){\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nfound:;\n\t\tqueue<P> que;\n\t\tque.push(P(sx,sy));\n\n\t\tint res = 0;\n\t\tbool visited[20][20];\n\t\tmemset(visited,0,sizeof(visited));\n\n\t\tvisited[sy][sx] = true;\n\t\twhile(!que.empty()){\n\t\t\tint sx = que.front().first;\n\t\t\tint sy = que.front().second;\n\t\t\tres++;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint dx = sx + tx[i];\n\t\t\t\tint dy = sy + ty[i];\n\n\t\t\t\tif(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n\t\t\t\tif(stage[dy][dx]=='#') continue;\n\t\t\t\tif(visited[dy][dx]) continue;\n\n\t\t\t\tvisited[dy][dx] = true;\n\t\t\t\t\n\t\t\t\tque.push(P(dx,dy));\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nint xd[]={1,0,0,-1};\nint yd[]={0,1,-1,0};\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H,W!=0){\n\t\tvector<string> board(H);\n\t\tqueue<pair<int,int>> q;\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin>>board[i];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tstring::iterator\n\t\t\tp=find(board[i].begin(),board[i].end(),'@');\n\t\t\tif(p!=board[i].end()){\n\t\t\t\tq.push(pair<int,int>(i,p-board[i].begin()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> v=q.front();\n\t\t\tq.pop();\n\t\t\tif(board[v.first][v.second]=='#')continue;\n\t\t\tboard[v.first][v.second]='#';\n\t\t\tcount++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint newx=xd[i]+v.first;\n\t\t\t\tint newy=yd[i]+v.second;\n\t\t\t\tif(0<=newx&&newx<H&&0<=newy&&newy<W\n\t\t\t\t\t\t&&board[newx][newy]=='.')\n\t\t\t\t\tq.push(pair<int,int>(newx,newy));\n\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n#define MAX 20\n#define NIL -1\n\nstatic char M[MAX][MAX];\nstatic int color[MAX][MAX];\nint W, H;\nint cnt;\n\nvoid dfs(int h, int w) {\n\tcnt++;\n\tcolor[h][w] = 0;\n\tif (h != H - 1 && M[h + 1][w] == '.'&&color[h + 1][w] == NIL)\n\t\tdfs(h + 1, w);\n\tif (h != 0 && M[h - 1][w] == '.'&&color[h - 1][w] == NIL)\n\t\tdfs(h - 1, w);\n\tif (w != W - 1 && M[h][w + 1] == '.'&&color[h][w + 1] == NIL)\n\t\tdfs(h, w + 1);\n\tif (w != 0 && M[h][w - 1] == '.'&&color[h][w - 1] == NIL)\n\t\tdfs(h, w - 1);\n}\n\nstruct { int x; int y; } s;\n\nint main() {\n\twhile (cin >> W >> H&&H&&W) {\n\t\tfor (int h = 0; h < H; h++) {\n\t\t\tfor (int w = 0; w < W; w++) {\n\t\t\t\tcin >> M[h][w];\n\t\t\t\tif (M[h][w] == '@')s.x = w, s.y = h;\n\t\t\t}\n\t\t}\n\t\tfill(color[0], color[MAX], NIL);\n\t\tcnt = 0;\n\t\tdfs(s.y, s.x);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\n\n\nint main() {\n\tint W,H;\n\tint q[20][20];\n\tchar p[20][20];\n\tqueue<pair<int,int> > M;\n\tpair<int,int> X;\n\twhile(cin >> W >> H){\n\t\tfor (int i=1; i <= 21; i++){\n\t\t\tfor (int j=1; j <= 21; j++){\n\t\t\t\tq[i][j] = 0;\n\t\t\t\tp[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tif (W == 0) return 0;\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@'){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tW = M.front().first;\n\t\t\tH = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int i = 0; i <= 3; i++){\t\t\n\t\t\t\tif (p[W+dx[i]][H+dy[i]] == '.' && q[W+dx[i]][H+dy[i]] == 0){\n\t\t\t\t\tM.push(make_pair(W + dx[i], H + dy[i]));\n\t\t\t\t\tq[W + dx[i]][H + dy[i]] = 1;\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans=0,sx,sy;//finded\nstring m[20][20],t;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans++;\n\tcout<<x<<\",\"<<y<<\",\"<<ans<<endl;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\tcin>>W>>H;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>m[j][i];\n\t\t\tt=m[j][i];\n\t\t\tif(t==\"@\"){\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t}\n\t\t}\n\t}\n\tfind(sx,sy);\n\t\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int x,int y);\nint w,h;\n \nint count;\nbool flag;\nchar maze[21][21];\nbool reached[501][501];\n \nint main(){\n        int w,h;\n\n    while(cin>>w>>h){\n        \n            if(w==0&&h==0){\n                break;\n            }\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    cin>>maze[i][j];\n                }\n            }\n\n            //  for(int i=0;i<h;i++){\n            //     for(int j=0;j<w;j++){\n            //         cout<<maze[i][j];\n            //     }\n            //     cout<<endl;\n            // }\n\n            // cout<<endl\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(maze[i][j]=='@'){\n                        dfs(j,i);\n                    }\n                }\n            }\n\n            // for(int i=0;i<h;i++){\n            //     for(int j=0;j<w;j++){\n            //         cout<<maze[i][j];\n            //     }\n            //     cout<<endl;\n            // }\n\n            count=0;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(maze[i][j]=='!')count++;\n                }\n            }\n\n            cout<<count<<endl;\n\n\n\n\n        }\n    \n    // int s_x=0;\n    // int s_y=0;\n    // int g_x=0;\n    // int g_y=0;\n \n    // cin>>w>>h;\n \n \n    // for(int i=0;i<w;i++){\n    //     for(int j=0;j<h;j++){\n    //         if(maze[i][j]=='s'){\n    //             s_x=i;\n    //             s_y=j;\n    //             dfs(i,j);\n    //         }\n    //     }\n    // }\n\n    // for(int i=0;i<h;i++){\n    //     for(int j=0;j<w;j++){\n    //         if(reached[i][j])count++;\n    //     }\n    // }\n    \n\n \n    return 0;\n}\n \n \nvoid dfs(int x,int y){\n    maze[y][x]='!';\n\n    for(int i=0;i<4;i++){\n        int mx=x+dx[i];\n        int my=y+dy[i];\n        if(maze[my][mx]=='.'){\n            dfs(mx,my);\n        }\n        if(mx<0||w<=mx||my<0||h<=my){\n            continue;\n        }//??????????????´?????´???->???????????????\n        \n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {-1, 1, 0, 0};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < H && nx >= 0 && nx < W && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0 ; i < H; i++) {\n         cin >> board[i];\n      }\n\n      for (int i = 0 ; i < H; i++) {\n         for (int j = 0 ; j < H; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define MOD 1000000007\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define PDD pair<double, double>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\n\nLL modinv(LL a){\n    LL b = MOD, u = 1, v = 0;\n    while(b){\n        LL t = a / b;\n        a -= t * b;swap(a, b);\n        u -= t * v;swap(u, v);\n    }\n    u%=MOD;\n    if(u < 0) u += MOD;\n    return u;\n\n}\n\nLL exp(LL a, LL b){\n    LL sum = a;\n    LL res = 1;\n    while(b){\n        if(b&1){\n            res = (res * sum)%MOD;\n        }\n        sum = (sum * sum) % MOD;\n        b>>=1;\n    }\n    return res;\n}\n\nint N, M;\nvector<string> tail;\nint mx[]={1, 0, -1, 0}, my[]={0, 1, 0, -1};\n\nint main(){\n    while(cin>>N>>M&&N){\n        tail.assign(M, \"\");\n        foreach(i, tail)cin>>i;\n        int fx, fy;\n        REP(i, M){\n            REP(j, N){\n                if(tail[i][j]=='@'){\n                    fy=i;\n                    fx=j;\n                    tail[i][j]='#';\n                    break;\n                }\n            }\n        }\n        int ans = 1;\n        queue<PII> que;\n        que.push(PII(fy, fx));\n        while(!que.empty()){\n            PII d = que.front();\n            que.pop();\n            REP(i, 4){\n                int ny = d.first + my[i];\n                int nx = d.second + mx[i];\n                if(nx==-1||ny==-1||nx==N||ny==M||tail[ny][nx]=='#')continue;\n                ++ans;\n                tail[ny][nx]='#';\n                que.push(PII(ny, nx));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\nint A[30][30];\nint x,y;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint dfs(int x,int y){\n    A[x][y]=1;\n    int ans=0;\n    REP(i,4){\n        int xx=dx[i]+x;\n        int yy=dy[i]+y;\n        if(A[xx][yy]==0){\n           ans+=dfs(xx,yy);\n        }\n    }\n    return ans+1;\n}\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W+H){\n        REP(i,30){\n            REP(j,30){\n                A[i][j]=1;\n            }\n        }\n        REP(i,H){\n            string s;\n            cin>>s;\n            REP(j,W){\n                if(s[j]=='.')A[i+1][j+1]=0;\n                if(s[j]=='@'){\n                   A[i+1][j+1]=0;\n                   x=i+1;\n                   y=j+1;\n                }\n            }\n        }\n        cout<<dfs(x,y)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nint w;\nint h;\nchar field[1145][1419];\nbool used[1145][1419];\nqueue<Pair> q;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || h <= y) return false;\n  if (x < 0 || w <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &w, &h);\n    if (w == 0 && h == 0) return 0;\n\n    for (int i=0; i<h; i++) {\n      for (int j=0; j<w; j++) {\n        scanf(\" %c\", &field[i][j]);\n        if (field[i][j] == '@') q.push(Pair(i, j));\n        used[i][j] = false;\n      }\n    }\n\n    int ans = 0;\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      int y = p.first;\n      int x = p.second;\n  \n      if (used[y][x]) continue;    \n      used[y][x] = true;\n      ans++;\n\n      for (int i=0; i<4; i++) {\n        int newy = y + dy[i];\n        int newx = x + dx[i];\n        if (!WithinRange(newy, newx)) continue;\n        if (field[newy][newx] == '#') continue;\n        if (used[newy][newx]) continue;\n        \n        q.push(Pair(newy, newx));\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n \nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      if(used[ni][nj]) continue;\n      if(fld[ni][nj]=='#') continue;\n      rec(ni, nj);\n   }\n}\n \nint main(){\n \n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n \n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n \n   }\n \n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint W, H;\nchar v[30][30];\nint sum;\nint  dfs(int w, int h){\n    int sum = 0;\n    if(0<=w && w<W && 0<=h && h<H){\n    if(v[w][h]=='.'){\n        v[w][h] = '!';\n        return 1;\n    }\n    sum += dfs(w+1, h);\n    sum +=dfs(w-1, h);\n    sum +=dfs(w, h+1);\n    sum +=dfs(w, h-1);\n    }\n    return sum;\n}\n\nint main(void){\n    string str;\n    while(cin >> W >> H){\n        v[30][30];\n        if(W == 0 && H == 0)    break;\n        for(int i=0; i<H; i++){\n            cin >> str;\n            for(int j=0; j<W; j++){\n                v[i][j] = str[j];\n                if(v[i][j] == '@')\n                    dfs(i, j);\n            }\n        }\n        cout << sum <<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, black;\nchar tile[24][24];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y){\n    black++;\n    tile[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n        if( x+dx[i] >= 0 && x+dx[i] < h &&\n           y+dy[i] >= 0 && y+dy[i] < w &&\n           tile[ x+dx[i] ][ y+dy[i] ] == '.' ){\n            dfs( x+dx[i], y+dy[i] );\n        }\n    }\n}\n\nint main(){\n    int i, j;\n    while( cin >> w >> h, w||h ){\n        for(i=0;i<w;i++){\n            for(j = 0; j < h; j++){\n                cin >> tile[i][j];\n            }\n        }\n        black = 0;\n        for(i = 0; i < h && !black; i++){\n            for(j = 0; j < w && !black; j++){\n                if( tile[i][j] == '@' ){\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << black << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <array>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <set>\n#include <deque>\n#include <utility>\n#include <map>\n\n#define ll long long int\n#define MAX_W 20\n#define MAX_H 20\n\nusing namespace std;\n\nchar field[MAX_W][MAX_H];\nbool reach[MAX_W][MAX_H];\nint h, w;\nint cou = 0;\n\n\nvoid search(int x, int y)\n{\n\tif (x < 0 || w <= x || y < 0 || h <= y || field[x][y] == '#') {\n\t\treturn;\n\t}\n\n\tif (reach[x][y] == true) {\n\t\treturn;\n\t}\n\n\treach[x][y] = true;\n\n\n\tcou++;\n\n\n\n\tsearch(x - 1, y);\n\tsearch(x + 1, y);\n\tsearch(x, y + 1);\n\tsearch(x, y - 1);\n\n}\n\nint main(void)\n{\n\tvector <string> s;\n\tvector <int> ans;\n\tint i, j;\n\n\tint dx, dy; //start\n\n\tstring temp;\n\n\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tcin >> temp;\n\t\t\ts.push_back(temp);\n\t\t}\n\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tfield[j][i] = s[i][j];\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tdx = j;\n\t\t\t\t\tdy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\tsearch(dx, dy);\n\n\t\tans.push_back(cou);\n\t\tcou = 0;\n\n\t\ts.clear();\n\n\t\tfor (i = 0; i < MAX_W; i++) {\n\t\t\t\n\t\t\tfor (j = 0; j < MAX_H; j++) {\n\n\n\t\t\t\tfield[i][j] = '#';\n\t\t\t\treach[i][j] = false;\n\t\t\t}\n\t\t}\n\n\n\t}\n\tfor (i = 0; i < ans.size(); i++) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  int vx[4]={1,0,-1,0};\n  int vy[4]={0,-1,0,1};\n  while(cin>>w>>h,h+w){\n    string str[h];\n    for(int i=0;i<h;i++)cin>>str[i];\n    bool Map[h][w]={};\n    queue<pair<int,int> >que;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(str[i][j]=='@'){\n\t  que.push(mp(i,j));\n\t  Map[i][j]=true;\n\t}\n      }\n    }\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      for(int i=0;i<4;i++){\n\tif(now.F+vy[i]>=0&&now.S+vy[i]<w&&now.F+vx[i]>=0&&now.F+vx[i]<h&&(!Map[now.F+vx[i]][now.S+vy[i]])&&str[now.F+vx[i]][now.S+vy[i]]=='.'){\n\t  Map[now.F+vx[i]][now.S+vy[i]]=true;\n\t  que.push(mp(now.F+vx[i],now.S+vy[i]));\n\t}\n      }\n    }\n    ll ans=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(Map[i][j])\n\t  ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(1000);\n    nexty.reserve(1000);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    kaisuu++;\n    cout << sum <<endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostrem>\n#include<utility>\n#include<queue>\nusing namespace std;\nchar room[21][21];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> p;\n\n\nint main(){\n\tint x,y;\n\tqueue<p> que;\n\tint w,h;\n\tcin>>w>>h;\n\tif(w+h==0) return;\n\tfor(int a=0;a<h;a++){\n\t\tfor(int b=0;b<w;b++){\n\t\t\tcin>>room[a][b];\n\t\t\tif(room[a][b]=='@'){\n\t\t\t\tx=b,y=a;\n\t\t\t\tque.push(p(b,a));\n\t\t\t\troom[a][b]='#';\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=1;\n\tint nx,ny;\n\twhile(que.size()){\n\t\tp ap=que.front();\n\t\tque.pop;\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tnx=ap.first+dx[i];\n\t\t\tny=ap.second+dy[i];\n\t\t\tif(0<=nx&&nx<=w&&0<=ny&&ny<=h&&room[ny][nx]!='#'){\n\t\t\t\troom[ny][nx]='#';\n\t\t\t\tque.push(p(nx,ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\n\nusing namespace std;\n\n#define MAX_W 50\n#define MAX_H 50\n\nint main(){\n\n  int w,h;\n  char tile[MAX_H][MAX_W];\n\n  cin>>w>>h;\n  while(w!=0 && h!=0){\n    pair<int,int> s;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>tile[i][j];\n\tif(tile[i][j] == '@'){\n\t  s = make_pair(i,j);\n\t}\n      }\n    }\n\n    int ans = 0;\n    queue<pair<int,int> > que;\n    que.push(s);\n    int next[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\n\n    while(!que.empty()){\n      pair<int,int> now = que.front();\n      que.pop();\n\n      if(tile[now.first][now.second] != '#'){\n\tans++;\n\ttile[now.first][now.second] = '#';\n\n\tfor(int i=0;i<4;i++){\n\t  int ny = now.first + next[i][0];\n\t  int nx = now.second + next[i][1];\n\t  if(ny>=0 && ny<h && nx>=0 && nx<w && tile[ny][nx]!='#'){\n\t    que.push(make_pair(ny,nx));\n\t  }\n\t}\n      }\n    }\n\n    cout<<ans<<endl;\n    cin>>w>>h;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h;\nchar tile[21][21];\n\nconst int mx[] = {0, 0, 1, -1};\nconst int my[] = {1, -1, 0, 0};\n\nint func(int x, int y){\n\tif(x < 0 || x >= w || y < 0 || y >= h || tile[y][x] == '#'){\n\t\treturn 0;\n\t}\n\tint res = 1;\n\ttile[y][x] = '#';\n\tfor(int i = 0; i < 4; ++i){\n\t\tfor(int j = 0; j < 4; ++j){\n\t\t\tres += func(x + mx[i], y + my[i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(cin >> w >> h && w != 0 && h != 0){\n\t\n\t\tint sx = 0, sy = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif(tile[i][j] == '@'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << func(sx, sy) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint w=1;\nint h=1;\nchar map_data[21][21];\nbool reacher[21][21];\nint count=0;\nchar a;\nint sx,sy;\n\nvoid searth(int x,int y){\n//cout<<w<<\",\"<<y<<endl;\nif(x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#' ){return;}\n\n\nif (reacher[y][x]){return;}\n//cout<<count;\nreacher[y][x]=true;\ncount++;\n\n\nsearth(x+1,y);\nsearth(x,y+1);\nsearth(x-1,y);\nsearth(x,y-1);\n//cout<<count;\n\n\n\n}\n\n\n\nint main(){\n\n   \n\n    while(w>0 and h>0){\n        cin>>w>>h;\n        if(w==0 and h==0){\n            break;\n\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>a;\n                map_data[i][j]=a;\n                \n                reacher[i][j]=0;\n\n                if(a=='@'){\n                 \n                    sx=j;\n                    sy=i;\n                } \n    \n            }\n        }\n        //cout<<\"sx\"<<sx<<\"sy\"<<sy<<endl;\n        //rep(i,h)rep(j,w)cout<<map_data[i][j];\n        //rep(i,h)rep(j,w)cout<<reacher[i][j];\n        searth(sx,sy);\n        cout<<count<<endl;\n        count=0;\n        //rep(i,h)rep(j,w)cout<<map_data[i][j];\n    }\n\n   \n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col] != '*' && M[nc.row][nc.col] != '#' && M[nc.row][nc.col] != '@')\n\t{\n\t  S.push(nc);\n\t  M[nc.row][nc.col] = '*';\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == w || y == h) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W) {\n\t\tint ans = 0;\n\t\trep(i, H) cin >> s[i];\n\t\trep(i, H) rep(i, W) {\n\t\t\tif (s[i][j] == '@') solve(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint w,h;\nchar map[20][20];\nint cnt;\n\nint dirx[4] = {1,0,-1,0};\nint diry[4] = {0,1,0,-1};\n\nbool inField(int x,int y){\n\treturn (0<=x) && (x<w) && (0<=y) && (y<h);\n}\n\n//深さ優先探索\nvoid dfs(int posx,int posy){\n\tcnt ++;\n\tmap[posy][posx] = '#';\n\tfor(int i=0;i<4;i++){\n\t\tint nextx = posx + dirx[i];\n\t\tint nexty = posy + diry[i];\n\t\tif(inField(nextx,nexty) && map[nexty][nextx] != '#'){\n\t\t\tdfs(nextx,nexty);\n\t\t}\n\t}\n\t\n}\n//名簿\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tcnt =0;\n\t\tint posx,posy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tposx = j;\n\t\t\t\t\tposy = i;\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tdfs(posx,posy);\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\nint W, H, sx, sy, cnt;\nvector<int> dxy = { 1, 0, -1, 0, 1 }; \nstring field[20];\n\nvoid fun(int y, int x){\n    field[y][x] = '#';\n    cnt++;\n    for(int i=0; i<4; ++i){\n        int ny = y + dxy[i+1],\n            nx = x + dxy[i];\n        if(ny < 0 || ny >= H ||nx < 0 || nx >= W || field[ny][nx] != '.') continue;\n        fun(ny, nx);\n    }\n}\n    \nint main(){\n    while(cin >> W >> H, (W||H)){\n        cnt = 0;\n        string str;\n        cin.ignore();\n        for(int i=0; i<H; ++i){\n            cin >> field[i];\n        }\n        for(int i=0; i<H; ++i){\n            for(int j=0; j<W; ++j){\n                if(field[i][j] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n        fun(sy, sx);\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\nint dx[]={0, 0, 1, -1};\nint dy[]={1, -1, 0, 0};\nchar fld[20][21];\nint used[20][20];\nint W, H;\n\nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(int k=0; k<4; k++){\n      int ni=i+dy[k];\n      int nj=j+dx[k];\n      if(0<=ni&&ni<H&&0<=nj&&nj<W&&fld[ni][nj]!='#'&&used[ni][nj]==0){\n         rec(ni, nj);\n      }\n   }\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# -*- coding: utf-8 -*-\n\ncount = 0\ndef dfs(i, j, island):\n    global count\n    print i, j\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    \n    if i < 0 or i >= len(island) or j < 0 or j >= len(island[0]):\n        return\n\n    if island[i][j] == '#' or island[i][j] == 'x':\n        return\n\n    island[i][j] = 'x'\n    count += 1\n    \n    for d in dxy:\n        dfs(i+d[0], j+d[1], island)\n\ndef solve(w, h, island):\n    s_i = 0\n    s_j = 0\n    for i, row in enumerate(island):\n        for j, s in enumerate(row):\n            if s == '@':\n                s_i = i\n                s_j = j\n                break\n\n    dfs(s_i, s_j, island)\n    print count\n\ndef func():\n    '''\n\n    '''\n    while True:\n        global count\n        wh = map(int, raw_input().split())\n        w = wh[0]\n        h = wh[1]\n        island = []\n        count = 0\n        for i in range(h):\n            row = []\n            line = raw_input()\n            for j in line:\n                row.append(j)\n            island.append(row)\n        \n        for row in island:\n            for j in row:\n                print j\n            print ''\n\n        solve(w, h, island)\n    return None\n\n\nfunc()\n    "
  },
  {
    "language": "C++",
    "code": "6 9\n....#.\n.....#\n......\n......\n......\n......\n......\n#@...#\n.#..#."
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<string>\n#include <deque>\n#include<queue>\n#include<map>\n#include<type_traits>\nusing namespace std;\nchar D[28][28];\nint Y = 0;\nvoid serch(int X, int Q) {\n\tif (D[X][Q] == '.'||D[X][Q]=='@') {\n\t\tY++;\n\t\tD[X][Q] = '#';\n\t\tserch(X - 1, Q);\n\t\tserch(X + 1, Q);\n\t\tserch(X , Q-1);\n\t\tserch(X , Q+1);\n\t\t\n\n\t}\n\telse return;\n}\n\n\nint main() {\n\tint H, W;\n\tcin >> W >> H;\n\tfor (int i = 0; i <28; i++) {\n\t\tfor (int j = 0; j <28; j++) {\n\t\t\tD[i][j] = '#';\n\t\t}\n\t}\n\tint Sx,Sy;\n\twhile (H) {\n\t\t Y = 0;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> D[j][i];\n\t\t\t\tif (D[j][i] == '@') {\n\t\t\t\t\tSx = j;\n\t\t\t\t\tSy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tserch(Sx, Sy);\n\t\t\n\t\tcout <<\"Y\"<< Y << endl;\n\t\tfor (int i = 0; i <28; i++) {\n\t\t\tfor (int j = 0; j <28; j++) {\n\t\t\t\tD[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n\nint W,H;\nchar data[30][30];\nbool come[30][30];\nint human_h,human_w;\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nint canGo(int w,int h){\n\tif(w < 0 || h < 0 || w >= W || h >= H) return 0;\n\tif(data[h][w] == '#') return 0;\n\tif(come[h][w]) return 0;\n\tcome[h][w] = true;\n\tint ret = 1;\n\tret += canGo(w+1,h);\n\tret += canGo(w-1,h);\n\tret += canGo(w,h+1);\n\tret += canGo(w,h-1);\n\treturn ret;\n}\n\nsigned main(){\n\t// your code goes here\n\twhile(true){\n\t\tW=read(),H=read();\n\t\tif(W==0 || H==0) break;\n\t\tREP(i,H){\n\t\t\tREP(j,W){\n\t\t\t\tcome[i][j] = false;\n\t\t\t\tcin >> data[i][j];\n\t\t\t\tif(data[i][j] == '@'){\n\t\t\t\t\thuman_h = i;\n\t\t\t\t\thuman_w = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<\tcanGo(human_w,human_h) << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%W;\n\t        int y=cur/W;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[j];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*W);\n  visited[ny][nx]=true;\n\n    }\n   }\n \n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h, ret;\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};\nstring data[25];\n\nvoid func(int nx, int ny)\n{\n\tret++;\n\tdata[ny][nx] = '#';\n\tif (nx+1 < w && data[ny][nx+1] == '.') func(nx+1, ny);\n\tif (0 <= nx-1 && data[ny][nx-1] == '.') func(nx-1, ny);\n\tif (ny+1 < h && data[ny+1][nx] == '.') func(nx, ny+1);\n\tif (0 <= ny-1 && data[ny-1][nx] == '.') func(nx, ny-1);\n\t\n\treturn;\n}\n\nint main(void)\n{\n\twhile (cin >> w >> h, w && h){\n\t\tfor (int i = 0; i < 25; i++) data[i].clear();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> data[i];\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < w; i++){\n\t\t\tfor (int j = 0; j < h; j++){\n\t\t\t\tif (data[j][i] == '@'){\n\t\t\t\t\tsx = i, sy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tdata[sy][sx] = '#';\n\t\tfunc(sx, sy);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\n\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y);\n\twhile(!q.empty()){\n\t\tp=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(p.first+dx[i],p.second+dy[i]))\n\t\t\t\ttot+=1;\n\t\t\t\tp.first+=dx[i]; p.second+=dy[i];\n\t\t\t\tq.push(p);\n\t\t}\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[j][i];\n\t\t\t\tif(P[j][i]=='@')\n\t\t\t\t\tx1=j; y1=i; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t\tcout << tot << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nint dfs(int x, int y, vector<vector<bool> >& Cango){\n  \n  int counter = 0;\n  Cango[x][y] = false;\n  counter++;\n\n  for(int i = 0; i < 4; i++){\n    int nextx = x + dx[i];\n    int nexty = y + dy[i];\n    \n    if(Cango[nextx][nexty]) counter += dfs(nextx, nexty, Cango);\n\n  }\n\n  return counter;\n}\n\nint main(void)\n{\n  \n  int w, h;\n  int si, sj;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    vector<vector<bool> > Cango(h + 2, vector<bool>(w + 2, false));\n    for(int i = 1 ; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tchar input; cin >> input;\n\tif(input != '#') Cango[i][j] = true;\n\tif(input == '@'){\n\t  si = i;\n\t  sj = j;\n\t}\n      }\n    }\n    int ans = dfs(si, sj, Cango);\n   \n    cout << ans << endl;\n  }\n\n  return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]==true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%W;\n\t        int y=cur/W;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[j];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*W);\n  visited[ny][nx]=true;\n\n    }\n   }\n \n }\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint n, m;\nchar map[20][20];\nint ans = 0;\n\nint dfs(int x, int y){\n\tif(0 <= x && x < m && 0 <= y && y < n){\n\t\tif(map[x][y] != '.') return 0;\n\t\tmap[x][y] = '@';\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i=0; i<20; i++){\n\t\t\tfor(int j=0; j<20; j++){\n\t\t\t\tmap[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", map[i]);\n\t\t}\n\t\tint x, y;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@') ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tans = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nsigned main()\n{\n    int h, w;\n    while(cin>>w>>h, w) {\n        char field[h+1][w+1];\n        int sx, sy;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                char c;\n                cin >> c;\n                if(c=='@') {\n                    sx = i;\n                    sy = j;\n                }\n                field[i][j] = c;\n            }\n        }\n\n        queue<pair<int, int> > q;\n        q.push(make_pair(sx, sy));\n        int ans = 0;\n        while(!q.empty()) {\n            ans++;\n            pair<int, int> p = q.front();\n            q.pop();\n            int x = p.first;\n            int y = p.second;\n            for(int i=0; i<4; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(nx>=0&&nx<=h&&ny>=0&&ny<=w&&field[nx][ny]=='.') {\n                    q.push(make_pair(nx, ny));\n                    field[nx][ny] = '#';\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define REP(i,n) for (int i = 0; i < n; i++)\n#define FORI(i,a,b) for (int i = (a); i <= (b); i++)\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nint W,H,res;\nint dx[4] = {1,0,-1,0},dy[4]= {0,1,0,-1};\nchar field[MAX_W][MAX_H];\nvoid solve();\n\nint main() {solve(); return 0;}\n\nvoid dfs(int x, int y) {\n  field[x][y] = '#';\n  REP(i,4) {\n    int X = x + dx[i], Y = y + dy[i];\n    if (0 <= X && 0 <= Y && X < W && Y < H && field[X][Y] == '.') {\n      dfs(X,Y);\n    }\n  }\n  return ;\n}\nvoid solve() {\n  while (true) {\n    res = 1;\n    cin >> W >> H;\n    if (W==0&&H==0) break;\n    int x0,y0;\n    REP(i,H) {REP(j,W) {\n      cin >> field[j][i];\n      if (field[j][i] == '@') x0=j,y0=i;\n    } }\n\n\n    dfs(x0,y0);\n    cout << res << endl;\n  }\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, black;\nchar tile[24][24];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y){\n    black++;\n    tile[x][y] = '#';\n    for(int i = 0; i < 4; i++){\n        if( x+dx[i] >= 0 && x+dx[i] < h &&\n           y+dy[i] >= 0 && y+dy[i] < w &&\n           tile[ x+dx[i] ][ y+dy[i] ] == '.' ){\n            dfs( x+dx[i], y+dy[i] );\n        }\n    }\n}\n\nint main(){\n    int i, j;\n    while( cin >> w >> h){\n        if(w==0&&h==0)\n            break;\n        for(i = 0; i < h; i++){\n            for(j=0;j<w;j++){\n                cin >> tile[i][j];\n            }\n        }\n        black = 0;\n        for(j = 0; j < w && !black; j++){\n            for(i = 0; i < h && !black; i++){\n                if( tile[i][j] == '@' ){\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << black << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nstruct P {\n    using T = int;\n    T y, x;\n\n    P(T _y = 0, T _x = 0) :y(_y), x(_x) {}\n\n    inline bool operator == (P p) const { return y == p.y && x == p.x; }\n    inline bool operator < (P p) const { return y == p.y ? x < p.x : y < p.y; }\n    inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n    inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n    inline P operator+=(P p) { y += p.y; x += p.x; return *this; }\n    inline P operator-=(P p) { y -= p.y; x -= p.x; return *this; }\n};\n\n\n\ntemplate<typename T>\n// using T = int;\nstruct F {\n    int height, width;\n    vector<T> data;\n\n    F(int h = 1, int w = 1) :height(h), width(w), data(h*w) {}\n\n    inline T& operator()(int y, int x) { return data[x + y * width]; }\n    inline T& operator()(P p) { return data[p.x + p.y * width]; }\n    inline T operator()(int y, int x) const { return data[x + y * width]; }\n    inline T operator()(P p) const { return data[p.x + p.y * width]; }\n\n    inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n    inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n    inline void fill(T e) { std::fill(ALL(data), e); }\n    inline void resize(int h, int w) { height = h; width = w; data.resize(h*w); }\n\n    void print(ostream& os, int setw_arg = 4) {\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x)\n                os << setw(setw_arg) << operator()(y, x) << ' ';\n            os << '\\n';\n        }\n    }\n};\n\n\nint moving[][2] = { {0,1},{1,0},{-1,0},{0,1} };\n\n\nint solve() {\n    int H, W;\n    scanner >> H >> W;\n\n    if (H == 0 && W == 0) return 1;\n\n    F<int> field(H, W);\n    P start;\n\n    repeat(y, H) {\n        string str;\n        scanner >> str;\n        repeat(x, W) {\n            field(y, x) = !(str[x] == '#');\n            if (str[x] == '@') start = P(y, x);\n        }\n    }\n\n    queue<P> q;\n    q.push(start);\n\n    ll ans = 1;\n\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        for (auto mv : moving) {\n            int vy = mv[0], vx = mv[1];\n            if (field.safe(p + P(vy, vx)) && field(p + P(vy, vx))) {\n                q.push(p + P(vy, vx));\n                ans += 1;\n                field(p + P(vy, vx)) = 0;\n            }\n        }\n    }\n\n    printer << ans << '\\n';\n    return 0;\n}\n\n\nint main() {\n\n    while (!solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(int i=0;i<n;++i)\n#define RREP(i,n) for(int i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(int i=m;i<n;++i)\n#define RFOR(i,m,n) for(int i=m-1;i>=n;--i)\n#define ALL(v) v.begin(),v.end()\n#define PB(a) push_back(a)\n#define INF 1000000001\n#define MOD 1000000007\n\nconst int dx[4] = { 1,0,-1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nusing namespace std;\n\nvoid dfs(const vector<string> &v, vector<vector<bool>> &b, int x, int y, int& cnt) {\n\tb[y][x] = true;\n\tcnt++;\n\tREP(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx<v[y].size() && nx >= 0 && ny >= 0 && ny<v.size() &&v[ny][nx] == '.' && !b[ny][nx])\n\t\t\tdfs(v, b, nx, ny,cnt);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h, w;\n\twhile (cin >> w >> h&&h) {\n\t\tvector<string> v(h);\n\t\tREP(i, h) {\n\t\t\tcin >> v[i];\n\t\t}\n\t\tvector<bool> b(w, false);\n\t\tvector<vector<bool> > visited(h, b);\n\t\tint y=0, x=0;\n\t\tREP(i, h) {\n\t\t\tif (v[i].find('@')!=size_t(-1)) {\n\t\t\t\ty = i;\n\t\t\t\tx = v[i].find('@');\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tdfs(v, visited, x, y, cnt);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint solve(int x,int y);\nchar room[30][30];\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint w,h;\nint main(void){\n  int ans;\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0) break;\n    ans=0;\n    for(int i=0;i<h;i++) scanf(\"%s\",room[i]);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(room[i][j]=='@') ans=solve(i,j);\n      }\n      if(ans)break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint solve(int x,int y){\n  int res=1;\n  room[x][y]='#';\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(0<=nx && nx<h && 0<=ny && ny<w){\n      if(room[nx][ny]=='.') res+=solve(nx,ny);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n        \n    }\n    \n}\n\nint main(){\n    while(1){\n        int x,y,startx,starty;\n        vector<vector<bool> > map;\n        cin>>x>>y;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring map[21];\nint sx,sy,ans,x,y;\n\nvoid search(int xx,int yy){\n\tans++;\n\tmap[yy][xx]='#';\n\tif(xx<x-1&&map[yy][xx+1]=='.')search(xx+1,yy);\n\tif(xx>0&&map[yy][xx-1]=='.')search(xx-1,yy);\n\tif(yy<y-1&&map[yy+1][xx]=='.')search(xx,yy+1);\n\tif(yy>0&&map[yy-1][xx]=='.')search(xx,yy-1);\n}\n\nint main(){\n\twhile(cin>>x>>y,x||y){\n\t\tans=0;\n\t\tfor(int i=0;i<y;i++)cin>>map[i];\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(map[i][j]=='@')sy=i,sx=j;\n\t\t\t}\n\t\t}\n\t\tsearch(sx,sy);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#define INF 100000\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef queue<pii> que;\nint w,h;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nstring map[30];\n\nint bfs(pii p){\n  que q;\n  int nx,ny,ans=1;\n  q.push(p);\n  while(q.size()!=0){\n    for(int i=0;i<4;i++){\n      nx=q.front().first+dx[i];ny=q.front().second+dy[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && map[ny][nx]=='.'){\n\tmap[ny][nx]='$';\n\t//cout<<nx<<ny<<endl;\n\tq.push(make_pair(nx,ny));\n\tans++;\n      }\n    }\n    q.pop();\n  }\n  return ans;\n}\n\nint main(){\n  pii start;\n  while(cin>>w>>h,h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>map[i][j];\n\tif(map[i][j]=='@') start=make_pair(j,i);\n      }\n    }\n    cout<<bfs(start)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n#define loop(i,a,b) for(int i = a ; i < b ; i++)\n#define rep(i,a) for(int i = 0 ; i < a ; i++) \n\nchar maze[21][21];\nint dx[4] = { 0, 0,-1, 1};\nint dy[4] = {-1, 1, 0, 0};\nint H,W;\nbool inmaze(int x,int y){\n  return (0<=x && x<H) && (0<=y && y<W);\n}\n\nint dfs(int x,int y){\n  if(!inmaze(x,y))return 0;\n  maze[x][y] = '#';\n  int res = 1;\n  rep(i,4){\n    if(maze[x+dx[i]][y+dy[i]] == '.'){\n      res += dfs(x+dx[i],y+dy[i]);\n    }\n  }\n  return res;\n}\nint main(void){\n  while(cin>>W>>H,H+W){\n    int sx,sy;\n    rep(i,H){\n      string s;\n      cin>>s;\n      rep(j,W){\n\tmaze[i][j] = s[j];\n\tif(s[j] == '@'){\n\t  sx = i;sy = j;\n\t}\n      }\n    }\n    maze[sx][sy] = '.';\n    cout<<dfs(sx,sy)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <map>\n#include <stack>\nusing namespace std;\n\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\n\nint main() {\nint yoko,tate,px,py;\nwhile(cin>>yoko>>tate &&yoko){\n\n\tint m[25][25];\n\nstring st;\n//cin>>yoko>>tate;\nfor(int i=1;i<tate+1;i++){\ncin>>st;\nfor(int j=1;j<yoko+1;j++){\nif(st[j-1]=='#') m[i][j]=-1;\nelse if(st[j-1]=='.') m[i][j]=0;\nelse if(st[j-1]=='@'){\n m[i][j]=1;\npx=i;\npy=j;\n}\n}\n}\nint ans=1;\nstack<pair<int,int> > s;\ns.push(make_pair(px,py));\n//cout<<\"pxpy \"<<px<<\" \"<<py<<endl;\nwhile(s.empty()==false){\npx=s.top().first;\npy=s.top().second;\ns.pop();\n\nfor(int i=0;i<4;i++){\n//cout<<px+dx[i]<<\" \"<<py+dy[i]<<endl;\n\tif(0<px+dx[i] && px+dx[i]<tate+1 && py+dy[i]>0 && py+dy[i]<yoko+1){\n\t\n\t\tif(m[px+dx[i]][py+dy[i]]==0){\n\t\t\tm[px+dx[i]][py+dy[i]]=1;\n\t\t\ts.push(make_pair(px+dx[i],py+dy[i]));\n\t\t\tans++;\n//cout<<px+dx[i]<<\" \"<<py+dy[i]<<\" \"<<ans<<endl;\n\t\t}\n\n\t}}\n}\n\ncout<<ans<<endl;\n\n}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\n\nint dy[4] = {1,0,-1,0}; // n e s w\nint dx[4] = {0,1,0,-1};\nchar m[21][21];\nint cnt;\n\nvoid bfs(int sx, int sy, int w, int h)\n{\n\trep(i,0,4) {\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\tif (m[ny][nx] == '.') {\n\t\t\tm[ny][nx] = '@';\n\t\t\tcnt++;\n\t\t\tbfs(nx, ny, w, h);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\tint sx, sy;\n\t\tcnt = 0;\n\t\trep(i,0,h) rep(j,0,w) {\n\t\t\tcin >> m[i][j];\n\t\t\tif (m[i][j] == '@') {\n\t\t\t\tcnt++;\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,h) { rep(j,0,w) cout << m[i][j]; cout << endl; }\n\t\tbfs(sx, sy, w, h);\n\t\tcout << cnt << endl;\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nint w,h;\nint ans=1;\nchar tile[21][21];\n\nvoid saiki(int x,int y){\n\tif(x<0 | x>h | y<0 | y>w)return;\n\ttile[x][y]='#';\n\tif(tile[x-1][y]=='.')ans++,saiki(x-1,y);\n\tif(tile[x+1][y]=='.')ans++,saiki(x+1,y);\n\tif(tile[x][y-1]=='.')ans++,saiki(x,y-1);\n\tif(tile[x][y+1]=='.')ans++,saiki(x,y+1);\n}\n\nint main(void){\n\tint a,b; \n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tans=1;\n\t\tmemset(tile,0,sizeof(tile));\n\t\tfor(a=0;a<h;a++){\n\t\t\tscanf(\"%s\",tile[a]);\n\t\t}\n\t\tfor(a=0;a<h;a++){\n\t\t\tfor(b=0;b<w;b++){\n\t\t\t\tif(tile[a][b]=='@')saiki(a,b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n    int w,h;\n    while(cin >> w >> h && w!=0){\n        int t[w+2][h+2];\n        for(int i=0;i<w+2;i++){\n            for(int j=0;j<h+2;j++){\n                t[i][j] = 0;\n            }\n        }\n\n        int ** matrix = new int*[w*h];\n        for( int i=0; i<w*h; i++ ) {\n            matrix[i] = new int[w*h];\n        }\n\n        int start;\n        for(int i=0;i<h+2;i++){\n            for(int j=0;j<w+2;j++){\n                if(i==0 || j==0 || i==w+1 || j==h+1)\n                    t[i][j]=0;\n                else{\n                    char tmp; cin >> tmp;\n                    if(tmp=='.'){\n                        t[i][j] = 1;\n                    }\n                    else if(tmp=='#'){\n                        t[i][j] = 0;\n                    }\n                    else{\n                        t[i][j] = 1;\n                        start = i*w+j;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<w*h;i++){\n            for(int j=0;j<w*h;j++){\n                matrix[i][j] = 0;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i==0 || j==0 || i==w || j==h)\n                    continue;\n                else{\n                    int id = i*w+h;\n                    if(t[(id-w)/w+1][(id-w)%w+1] == 1)\n                        matrix[id][id-w] = 1;\n                    if(t[(id+w)/w+1][(id+w)/w+1] == 1)\n                        matrix[id][id+w] = 1;\n                    if(t[(id-1)/w+1][(id-1)/w+1] == 1)\n                        matrix[id][id-1] = 1;\n                    if(t[(id+1)/w+1][(id+1)/w+1] == 1)\n                        matrix[id][id+1] = 1;\n                }\n            }\n        }\n        int count = 1;\n        queue<int> Q;\n        int came[w*h];\n        for(int i=0;i<w*h;i++){\n            came[i] = 0;\n        }\n        Q.push(start);\n        came[start] = 1;\n        while(Q.size()!=0){\n            int cur = Q.front();\n            for(int i=0;i<w*h;i++){\n                if(matrix[cur][i]==1 && came[i] == 0){\n                    Q.push(i);\n                    came[i] = 1;\n                    count++;\n                }\n            }\n            Q.pop();\n        }\n        cout << count << endl;\n        for( int i=0; i<w*h; i++ ) {\n            delete[] matrix[i];\n        }\n        delete[] matrix;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nstruct P {\n    using T = int;\n    T y, x;\n\n    P(T _y = 0, T _x = 0) :y(_y), x(_x) {}\n\n    inline bool operator == (P p) const { return y == p.y && x == p.x; }\n    inline bool operator < (P p) const { return y == p.y ? x < p.x : y < p.y; }\n    inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n    inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n    inline P operator+=(P p) { y += p.y; x += p.x; return *this; }\n    inline P operator-=(P p) { y -= p.y; x -= p.x; return *this; }\n};\n\n\n\ntemplate<typename T>\n// using T = int;\nstruct F {\n    int height, width;\n    vector<T> data;\n\n    F(int h = 1, int w = 1) :height(h), width(w), data(h*w) {}\n\n    inline T& operator()(int y, int x) { return data[x + y * width]; }\n    inline T& operator()(P p) { return data[p.x + p.y * width]; }\n    inline T operator()(int y, int x) const { return data[x + y * width]; }\n    inline T operator()(P p) const { return data[p.x + p.y * width]; }\n\n    inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n    inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n    inline void fill(T e) { std::fill(ALL(data), e); }\n    inline void resize(int h, int w) { height = h; width = w; data.resize(h*w); }\n\n    void print(ostream& os, int setw_arg = 4) {\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x)\n                os << setw(setw_arg) << operator()(y, x) << ' ';\n            os << '\\n';\n        }\n    }\n};\n\n\nint moving[][2] = { {0,1},{1,0},{-1,0},{0,-1} };\n\n\nint solve() {\n    int H, W;\n    scanner >> W >> H;\n\n    if (H == 0 && W == 0) return 1;\n\n    F<int> field(H, W);\n    P start;\n\n    repeat(y, H) {\n        string str;\n        scanner >> str;\n        repeat(x, W) {\n            field(y, x) = !(str[x] == '#');\n            if (str[x] == '@') start = P(y, x);\n        }\n    }\n\n    queue<P> q;\n    q.push(start);\n    field(start) = 0;\n\n    ll ans = 1;\n\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        for (auto mv : moving) {\n            int vy = mv[0], vx = mv[1];\n            if (field.safe(p + P(vy, vx)) && field(p + P(vy, vx))) {\n                q.push(p + P(vy, vx));\n                ans += 1;\n                field(p + P(vy, vx)) = 0;\n            }\n        }\n    }\n\n    printer << ans << '\\n';\n    return 0;\n}\n\n\nint main() {\n\n    while (!solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,h,a[21][21],count=0,m;\n  char in;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>in;\n\tif(in=='#') a[i][j]=0;\n\telse if(in=='@') {\n\t  a[i][j]=2;\n\t}\n\telse a[i][j]=1;\n      }\n    }\n    count=0;\n    while(1){\n      m=0;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(a[i][j]==2){\n\t    m=1;\n\t    count++;\n\t    a[i][j]=3;\n\t    if(i==0){\n\t      if(j==0){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t    }\n\t    else if(j==0){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t    else if(i==h-1){\n\t      if(j==w-1){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t    }\n\t    else if(j==w-1){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t    }\n\t    else {\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(m==0) break;\n      \n    }\n    cout<<count<<endl;\n  }\n    \n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint main()\n{\n    int w, h;\n    while (scanf(\"%d%d\", &w, &h), w | h)\n    {\n\tchar tile[32][32];\n\tmemset(tile, '#', sizeof(tile));\n\tfor (int i = 1; i <= h; ++i)\n\t{\n\t    scanf(\"%s\", tile[i] + 1);\n\t    tile[i][w + 1] = '#';\n\t}\n\n\tint sx, sy;\n\tfor (int y = 1; y <= h; ++y)\n\t    for (int x = 1; x <= w; ++x)\n\t\tif (tile[y][x] == '@')\n\t\t    sx = x, sy = y;\n\n\tint res = 0;\n\tqueue<pint> q;\n\tq.push(pint(sx, sy));\n\twhile (!q.empty())\n\t{\n\t    pint t = q.front(); q.pop();\n\t    int x = t.first, y = t.second;\n\n\t    if (tile[y][x] == '#')\n\t\tcontinue;\n\n\t    ++res;\n\t    tile[y][x] = '#';\n\n\t    for (int i = 0; i < 4; ++i)\n\t\tq.push(pint(x + dx[i], y + dy[i]));\n\t}\n\tprintf(\"%d\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n\n      rep (i, H) cin >> B[i];\n\n      rep (i, H) {\n         rep (j, W) {\n            if (B[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvoid saiki(int x,int y,vector<vector<char> > &field,vector<vector<char> > &k){\n    if(field[y][x] == '#' || k[y][x] == 'x'){\n        return;\n    }\n\n    field[y][x] = '#';\n    k[y][x] = 'x';\n    saiki(x-1,y,field,k);\n    saiki(x+1,y,field,k);\n    saiki(x,y-1,field,k);\n    saiki(x,y+1,field,k);\n    field[y][x] = '.';\n    return;\n}\n\nint solve(int w,int h){\n    //char field[w+2][h+2];\n    vector<vector<char> > field(h+2,vector<char>(w+2));\n    vector<vector<char> > k(h+2,vector<char>(w+2));\n\n    int x,y;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            field[i][j] = '#';\n        }\n    }\n\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin >> field[i][j];\n            if(field[i][j] == '@'){\n                y = i;\n                x = j;\n            }\n            k[i][j] = field[i][j];\n        }\n    }\n\n#ifdef DEB\n    cout << \"X:\" << x << \" Y:\" << y << endl;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n#endif\n    saiki(x,y,field,k);\n\n    int m = 0;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            if(k[i][j] == 'x'){\n                m++;\n            }\n        }\n    }\n    cout << m << endl;\n}\n\nint main(){\n    int x,y;\n    while(cin >> x >> y){\n        if(x==0 && y == 0){\n            break;\n        }\n        solve(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REAP(i,a,n) for(int i=(a);i<(n);i++)\n#define YES cout<<\"Yes\"<<endl\n#define NO cout<<\"No\"<<endl\n#define fr first\n#define sc second\n#define pb push_back\n#define All(v) v.begin(),v.end()\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h,w;\nstring table[21];\nint dp[21][21];\nint ans;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid puts_max(){\n    REP(i,h+1){\n        REP(j,w+1){\n            dp[i][j]=INT_MAX;\n        }\n    }\n}\n\nvoid solve(int y,int x){\n    ans++;\n    dp[y][x]=0;\n    REP(i,4){\n        if(y+dy[i]>=0 && y+dy[i]<h && x+dx[i]>=0 && x+dx[i]<w){\n            if(dp[y+dy[i]][x+dx[i]]!=0 && table[y+dy[i]][x+dx[i]]!='#'){\n                solve(y+dy[i],x+dx[i]);\n            }\n        }\n    }\n}\n\nint main(){\n    P st;\n    while(cin>>w>>h,w){\n        ans=0;\n        REP(i,h)cin >> table[i];\n\n        //cout << 1 << endl;\n        REP(i,h){\n            REP(j,w){\n                if(table[i][j]=='@'){\n                    st.fr=i;\n                    st.sc=j;\n                }\n            }\n        }\n        puts_max();\n        solve(st.fr,st.sc);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint w,h;\nint map[21][21];\n\nint count;\nint init_x,init_y;\n\nvoid dfs(int x,int y) {\n  \n  //cout << x << \" \" << y << endl;\n\n  if(x<0 || x>=w || y<0 || y>=h) return;\n\n  //if(map[x][y]==2) map[x][y]=0;\n\n  if(map[x][y]>0) return;\n\n  map[x][y]=3;\n\n  count++;\n\n  for(int i=0;i<4;i++) dfs(x+dx[i],y+dy[i]);\n\n}\n\nint main() {\n\n  string buf;\n\n  while(cin >> w >> h) {\n\n    if(w==0 && h==0) break;\n\n    getline(cin,buf);\n\n    for(int i=0;i<h;i++) {\n\n      getline(cin,buf);\n\n      for(int j=0;j<w;j++) {\n\n\tswitch(buf[j]) {\n\n\tcase '.':\n\t  map[j][i]=0;\n\t  break;\n\n\tcase '#':\n\t  map[j][i]=1;\n\t  break;\n\n\tcase '@':\n\t  map[j][i]=0;\n\t  init_x=j;\n\t  init_y=i;\n\t  break;\n\n\t}\n\n      }\n\n    }\n\n    for(int i=0;i<h;i++) {\n\n      for(int j=0;j<w;j++) {\n\n\tcout << map[j][i];\n\n      }\n\n      cout << endl;\n\n    }\n\n    cout << endl;\n\n    cout << map[5][7] << endl;\n\n    count=0;\n\n    dfs(init_x,init_y);\n\n    cout << init_x << \" \" << init_y << endl;\n\n    for(int i=0;i<h;i++) {\n\n      for(int j=0;j<w;j++) {\n\n\tcout << map[j][i];\n\n      }\n\n      cout << endl;\n\n    }\n\n    cout << count << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint main()\n{\n\tint W, H;\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\twhile (cin >> W >> H && W != 0 && H != 0)\n\t{\n\t\tbool path[20 + 1][20 + 1];\n\t\tfor (int i = 1; i <= H; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= W; j++)\n\t\t\t{\n\t\t\t\tpath[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tchar field[20 + 1][20 + 1];\n\t\tint startx, starty;\n\t\tfor (int i = 1; i <= H; i++)\n\t\t{\n\t\t\tchar buf[21];\n\t\t\tcin >> buf;\n\t\t\tstring str = buf;\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = str.at(j);\n\t\t\t\tif (str.at(j) == '@')\n\t\t\t\t{\n\t\t\t\t\tstartx = j + 1;\n\t\t\t\t\tstarty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint tiles = 0;\n\t\tqueue<pair<int,int>> q;\n\t\tq.push(make_pair(startx, starty));\n\t\tpath[starty][startx] = true;\n\t\twhile(q.size() > 0)\n\t\t{\n\t\t\tpair<int,int> p = q.front();\n\t\t\tq.pop();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\ttiles++;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (nx > W || ny > H || nx < 1 || ny < 1)continue;\n\t\t\t\tif (path[ny][nx])continue;\n\t\t\t\tif (field[ny][nx] == '#')continue;\n\t\t\t\tpath[ny][nx] = true;\n\t\t\t\tq.push(make_pair(nx, ny));\n\t\t\t}\n\t\t}\n\t\tcout << tiles << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint w,h;\nchar m[22][32];\n\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nint dfs(int y,int x){\n\tif(m[y][x]=='#')return 0;\n\tint res=1;\n\tm[y][x]='#';\n\tfor(int i=0;i<4;i++){\n\t\tres+=dfs(y+dy[i],x+dx[i]);\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>w>>h,w|h){\n\t\tmemset(m,'#',sizeof(m));\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)cin>>m[i][j];\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(m[i][j]!='@')continue;\n\t\t\t\tcout<<dfs(i,j)<<endl;\n\t\t\t\tgoto BREAK;\n\t\t\t}\n\t\t}\n\t\tBREAK:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\ncompute();\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%H;\n\t        int y=cur/H;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[i];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny&&ny<H))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*H);\n  visited[ny][nx]=true;\n++answer;\n    }\n   }\n //cout << answer << endl;\n printf(\"%d\\n\",answer);\n }\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define MOD 1000000007\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nstatic int cnt;\n\nvoid check(int pw,int ph,char **dt,int w,int h);\nvoid dtallput(int h,int w,char **dt);\n\nint main(void){\n\tint w,h;\n\tint ph,pw;\n\tchar c;\n\n\twhile(1){\n\n\t//入力\n\tcin >> w >> h;\n\tif(w==0&&h==0)break;\n\n\tchar **dt = new char*[h+2];\n\tfor(int i=0; i<h+2; i++){\n\t\tdt[i] = new char[w+2];\n\t\tmemset(dt[i],'#',sizeof(char)*(w+2));\n\t}\n\t\n\tc=getchar();\n\tfor(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t\tc=getchar();\n\t\t\tif(c=='.'||c=='#')\n\t\t\t\tdt[i+1][j+1]=c;\n\t\t\telse if(c=='@'){\n\t\t\t\tdt[i+1][j+1]=c;\n\t\t\t\tph=i+1; pw=j+1;\n\t\t\t}\n\t\t}\n\t\tc=getchar();\n\t}\n\t\n\t//測定\n\tcnt=1;\n\tcheck(pw,ph,dt,w,h);\n\n\t//出力\n\tcout << cnt << endl;\n\n\t}\n\treturn 0;\n}\n\nvoid check(int pw,int ph,char **dt,int w,int h){\n\tint dw[]={0,0,1,-1};\n\tint dh[]={1,-1,0,0};\n\n\tfor(int i=0; i<4; i++){\n\t\tif(dt[ph+dh[i]][pw+dw[i]]=='.'){\t\n\t\t\tdt[ph+dh[i]][pw+dw[i]]='@';\n\t\t\tcnt++;\n\t\t\tcheck(pw+dw[i],ph+dh[i],dt,w,h);\n\t\t}\n\t}\n}\n\nvoid dtallput(int h,int w,char **dt){\n\tcout << endl;\n\tfor(int i=0; i<h+2; i++){\n\t\tfor(int j=0; j<w+2; j++){\n\t\t\tcout << dt[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nconst int MAX_W = 23;\nbool visited[MAX_W][MAX_W];\nchar map[MAX_W][MAX_W] = {};\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint dfs(int x, int y) {\n  if (map[y][x] != '.') return 0;\n  int ret = 1;\n  map[y][x] = '#';\n  rep(i,4) {\n    ret += dfs(x + dx[i], y + dy[i]);\n  }\n  return ret;\n}\n\nvoid solve(int w, int h) {\n  int sx, sy;\n  rep(i, MAX_W) rep(j, MAX_W) map[i][j] = 0;\n  rep(i,h) {\n    string s;\n    cin >> s;\n    rep(j,w) {\n      if (s[j] == '@') {\n        sx = j+1;\n        sy = i+1;\n        s[j] = '.';\n      }\n      map[i+1][j+1] = s[j];\n    }\n  }\n  cout << dfs(sx, sy) << endl;\n}\n\nint main() {\n  int w, h;\n  while(true) {\n    cin >> w >> h;\n    if (w == 0) return 0;\n    solve(w, h);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return x < h && y < w;\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\n\tint initX, initY;\n\t\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i; initY = j;\n\t\t}\n\t    }\n\t}\n\t\n\tmove(initX, initY);\n\t\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct D\n{\n  bool movable[20][20];\n};\n\nint const dir[][2] = {\n  {  1, 0 },\n  { -1, 0 },\n  { 0,  1 },\n  { 0, -1 }\n};\n\nvoid count( D& d, int& num, int const px, int const py )\n{\n  if ( !d.movable[px][py] )\n    return;\n\n  ++num;\n  d.movable[px][py] = false;\n\n  for( int i=0; i<4; ++i ) {\n    int const npx = px + dir[i][0];\n    int const npy = py + dir[i][1];\n    if ( npx < 0 || npy < 0 || npx >= 20 || npy >= 20 )\n      continue;\n    count( d, num, npx, npy );\n  }\n}\n\nint main()\n{\n  int w, h;\n  while( cin >> w >> h ) {\n    if ( w == 0 && h == 0 )\n      break;\n\n    D d = {};\n    int px, py;\n    for( int y=0; y<h; ++y ) {\n      for( int x=0; x<w; ++x ) {\n        char c;\n        cin >> c;\n        if ( c == '@' ) {\n          px = x;\n          py = y;\n        }\n\n        d.movable[x][y] = ( c != '#' );\n      }\n    }\n\n    int num = 0;\n    count( d, num, px, py );\n    cout << num << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX 21\n \nstring str[MAX];\nint n,m,cnt,dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n \nvoid dfs(int x,int y){\n    str[x][y] = '#';\n \n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = x + dx[i] , ny = y + dy[i];\n\tif(0 <= nx && nx < m && 0 <= ny && ny < n){\n\t    if(str[nx][ny] == '.'){\n\t\tcnt++;\n\t\tdfs(nx,ny);\n\t    }\n\t}\n    }\n}\n \nint main(){\n    while(cin >> n >> m , n + m){\n\tfor(int i = 0 ; i < m ; i++){\n\t    cin >> str[i];\n\t}\n     \n\tint x,y;\n\tfor(int i = 0 ; i < n ; i++){\n\t    for(int j = 0 ; j < m ; j++){\n\t\tif(str[j][i] == '@'){\n\t\t    x = j;\n\t\t    y = i;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tcnt = 1;\n\tdfs(x,y);\n\tcout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntemplate<typename A,typename B> inline void chmin(A &a,B b){if(a>b) a=b;}\ntemplate<typename A,typename B> inline void chmax(A &a,B b){if(a<b) a=b;}\n\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n//-----------------------------------------------------------------------\n\nint w,h;\nchar M[25][25];\n\nint dfs(int y,int x)\n{\n    int res=1;\n    M[y][x]='#';\n    REP(i,4){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(0<=ny && ny<h && 0<=nx && nx<w && M[ny][nx]=='.'){\n            res+=dfs(ny,nx);\n        }\n    }\n    return res;\n}\nint main()\n{   \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(cin>>w>>h,w|h)\n    {   \n        REP(i,h) cin>>M[i];\n        REP(i,h) REP(j,w){\n            if(M[i][j]=='@'){\n                cout<<dfs(i,j)<<endl;\n                i=h,j=w;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (ll)n; i++)\n#define PI 3.14159265358979323846\n#define vll vector<long long>\n#define vvll vector<vector<long long>>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\n// ----本問について----\n// 問題：Red and Black\n// 問題文URL：https://onlinejudge.u-aizu.ac.jp/problems/1130\n// 所要時間：\n// 学んだこと：\n// ------------------\n\n// ----ここから本問のソースコード----\nconst ll dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\n// グローバル変数（入力）\nll w, h, state[25][25], tiles[25][25];\npair<ll, ll> start;\n\n// 入力\nvoid input() {\n  rep(y, h) {\n    string s;\n    cin >> s;\n    rep(x, w) {\n      if (s[x] == '.') {\n        tiles[y][x] = 0;\n      } else if (s[x] == '#') {\n        tiles[y][x] = 1;\n      } else {\n        tiles[y][x] = 0;\n        start = make_pair(x, y);\n      }\n      // cout << tiles[y][x];\n      // if (x != w-1){cout << \" \";}\n    }\n  }\n}\n\n// (x,y)にいけるかどうか\nbool valid(ll x, ll y) {\n  if ((0 <= x && x < w) && (0 <= y && y < h)) {\n    if (tiles[y][x] == 0) { return true; }\n  }\n  return false;\n}\n\n// 深さ優先探索\nvoid dfs(ll x, ll y) {\n  state[y][x] = 1; // 訪問済み\n  // cout << \"x:\" << x << \" y:\" << y << endl;\n  rep(i, 4) {\n    ll x2 = x + dx[i];\n    ll y2 = y + dy[i];\n    if (valid(x2, y2) && state[y2][x2]==0) { \n      dfs(x2, y2); \n    }\n  }\n}\n\nvoid solve() {\n  // state初期化\n  rep(i, h) {\n    rep(j, w) { state[i][j] = 0; }\n  }\n\n  // 始点から探索\n  dfs(start.first, start.second);\n\n  // 出力\n  ll ans = 0;\n  rep(i, h) {\n    rep(j, w) {\n      if (state[i][j] == 1) { ans++; }\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  while (cin >> w >> h && w > 0) {\n    input();\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n#define ll long long\n#define pb push_back\n\n// 前に&をつけるとvectorの参照渡しになる\nint solve(int x, int y, vector<vector<char> > tile, int H, int W, int count, vector<vector<bool> >& flag) {\n    // cout << count << \":\" << y << \",\"<< x << endl;\n    count++;\n    if (!flag[y][x]) {\n        return count;\n    } else {\n        flag[y][x] = false;\n    }\n    if (y + 1 < H) {\n        if (tile[y + 1][x] == '.' && flag[y + 1][x]) {\n            count = solve(x, y + 1, tile, H, W, count, flag);\n        }\n    }\n    if (y - 1 >= 0) {\n        if (tile[y - 1][x] == '.' && flag[y - 1][x]) {\n            count = solve(x, y - 1, tile, H, W, count, flag);\n        }\n    }\n    if (x + 1 < W) {\n        if (tile[y][x + 1] == '.' && flag[y][x + 1]) {\n            count = solve(x + 1, y, tile, H, W, count, flag);\n        }\n    }\n    if (x - 1 >= 0) {\n        if (tile[y][x - 1] == '.' && flag[y][x - 1]) {\n            count = solve(x - 1, y, tile, H, W, count, flag);\n        }\n    }\n    return count;\n}\n\nint main() {\n\n    int H, W;\n    while(true) {\n        cin  >> W >> H;\n        if (W==0 && H == 0) break;\n        vector<vector<char> > tile(H, vector<char>(W));\n        vector<vector<bool> > flag(H, vector<bool>(W, true));\n        int x, y, count = 0;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> tile[i][j];\n                if (tile[i][j] == '@') {\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n\n        count = solve(x, y, tile, H, W, count, flag);\n        cout << count << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long int lint;\ntypedef unsigned long long int ulint;\n\n//#define DEBUG\n\n#ifdef DEBUG\n#\tdefine dump(i) cout << \"[*] \" #i \" : \" << i << endl;\n#\tdefine debug(i) i\nvoid print(char map[20][20], int w, int h) {\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tcout << static_cast<int>(map[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid print(int* arr, int size) {\n\tfor (int i = 0; i < size; ++i) {\n\t\tcout << arr[i] << endl;\n\t}\n}\n#else\n#\tdefine dump(i)\n#\tdefine debug(i)\n# define print(i, j, k)\n# define print(j, k)\n#endif\n#define rep(i, MAX) for (int i = 0; i < (MAX); ++i)\n\nstruct UnionFind\n{\n\tvector<int> par;\n\n\tUnionFind(int n): par(n) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t}\n};\n\ninline void solve() {\n\tint w, h;\n\tconstexpr int MAX = 20;\n\tchar tile[MAX][MAX];\n\tdump(MAX);\n\n\twhile (true) {\n\t\tpair<int, int> at;\n\t\tcin >> w >> h;\n\t\tif (!w && !h) return;\n\t\tint table[MAX] = {};\n\t\tUnionFind uf = UnionFind(200);\n\n\t\tconst int asdf = MAX * MAX;\n\t\tdump(asdf);\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@') {\n\t\t\t\t\tat.first = i;\n\t\t\t\t\tat.second = j;\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint csi = 1;\n\t\tif (tile[0][0] == '.') {\n\t\t\ttile[0][0] = csi++;\n\t\t} else {\n\t\t\ttile[0][0] = 0;\n\t\t}\n\t\ttable[tile[0][0]]++;\n\t\tfor (int i = 1; i < w; ++i) {\n\t\t\tif (tile[0][i] == '.') {\n\t\t\t\ttile[0][i] = tile[0][i-1] != 0 ? tile[0][i-1] : csi++;\n\t\t\t} else {\n\t\t\t\ttile[0][i] = 0;\n\t\t\t}\n\t\t\ttable[tile[0][i]]++;\n\t\t}\n\t\trep(i, h) {\n\t\t\tif (i == 0) continue;\n\t\t\trep(j, w) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\ttile[i][j] = tile[i-1][j] != 0 ? tile[i-1][j] : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tile[i][j] == '.') {\n\t\t\t\t\t\tint tmp = tile[i-1][j];\n\t\t\t\t\t\tif (tmp == 0) {\n\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t} else if (tile[i][j-1] != 0) {\n\t\t\t\t\t\t\tuf.unite(tmp, tile[i][j-1]);\n\t\t\t\t\t\t\tif (tmp > tile[i][j-1]) {\n\t\t\t\t\t\t\t\ttmp = tile[i][j-1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttile[i][j] = tmp != 0 ? tmp : csi++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttile[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttable[tile[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint iv = tile[at.first][at.second];\n\t\trep(i, csi) {\n\t\t\tif (uf.same(iv, i)) {\n\t\t\t\tans += table[i];\n\t\t\t}\n\t\t}\n\t\tdump(\"tile\");\n\t\tprint(tile, w, h);\n\t\tdump(\"table\");\n\t\tprint(table, csi);\n\t\tdump(\"ans\");\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\t//*\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\t// */\n#ifdef DEBUG\n\tconst auto start = chrono::high_resolution_clock::now();\n#endif\n\tsolve();\n#ifdef DEBUG\n\tconst auto stop = chrono::high_resolution_clock::now();\n\tcerr << \"[*] time: \" << chrono::duration_cast<chrono::milliseconds>(stop-start).count()\n\t\t<< \" [ms]\" << endl;\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//PKU 1979\n#include<iostream>\n#include<cstdio>\nchar mat[21][21];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint w,h;\nusing namespace std;\n\nvoid check(int x,int y){\n\tint i;\n\tint mx,my;\n\tfor(i=0;i<4;i++){\n\t\tmx=x+dx[i];\n\t\tmy=y+dy[i];\n\t\tif(mx<w && my<h && mx>=0 && my>=0){\n\t\t\tif(mat[my][mx]=='.'){\n\t\t\t\tmat[my][mx]='z';\n\t\t\t\tcheck(mx,my);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\tint mx,my;\n\n\twhile(cin>>w>>h,(w||h)){\n\t\tfor(i=0;i<21;i++)for(j=0;j<21;j++)mat[i][j]=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tcin>>mat[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(mat[i][j]=='@'){\n\t\t\t\t\tmx=j,my=i;\n\t\t\t\t\tmat[my][mx]='z';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcheck(mx,my);//4ツ陛サツ古シツづ個づづェツつゥツ行ツつュ\n\n\t\tint cnt=0;\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(mat[i][j]=='z'){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long L;\nchar grid[25][25];\nL w,h,xi,yi,c=1,flg=1;\nL X[]={0,1,0,-1},Y[]={1,0,-1,0},mark[25][25];\nvoid dfs(L x,L y){\n    mark[x][y]=1;\n    for(L i=0;i<4;i++){\n        if(X[i]+x<0||X[i]+x>=h || Y[i]+y<0||Y[i]+y>=w || mark[X[i]+x][Y[i]+y] )continue;\n        if(grid[X[i]+x][Y[i]+y]=='.'){\n            c++;\n            dfs(X[i]+x,Y[i]+y);\n        }\n    }\n}\nint main(){\n    while(scanf(\"%lld%lld\",&w,&h)){flg=1;\n        if(w==0&&h==0)return 0;\n        for(L i=0;i<h;i++){\n           scanf(\"%s\",grid[i]);\n           for(L j=0;j<w&&flg;j++){\n            if(grid[i][j]=='@'){\n                xi=i;yi=j;flg=0;\n            }\n           }\n\n        }\n        dfs(xi,yi);\n        cout<<c<<\"\\n\";\n        c=1;memset(mark,0,sizeof(mark));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e9\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint main() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\tvector<string> s;\n\t\tint xe[4] = { 1,-1,0,0 };\n\t\tint ye[4] = { 0,0,1,-1 };\n\t\tqueue<pair<int, int>> next;\n\t\tint visited[21][21] = {};\n\t\tREP(i, h) {\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\ts.push_back(a);\n\t\t\tREP(q, a.length()) {\n\t\t\t\tif (a[q] == '@') {\n\t\t\t\t\tnext.push(make_pair(i, q));\n\t\t\t\t\tvisited[i][q] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\twhile (next.empty() == false) {\n\t\t\tpair<int, int> now = next.front();\n\t\t\tnext.pop();\n\t\t\tREP(q, 4) {\n\t\t\t\tint now_x = now.first + xe[q];\n\t\t\t\tint now_y = now.second + ye[q];\n\t\t\t\tif (now_x >= 0 && now_x < h && now_y >= 0 && now_y < w) {\n\t\t\t\t\tif (visited[now_x][now_y] == 0 && s[now_x][now_y] != '#') {\n\t\t\t\t\t\tvisited[now_x][now_y] = 1;\n\t\t\t\t\t\tnext.push(make_pair(now_x, now_y));\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint w, h;\nint mx[] = {0, 0, -1, 1};\nint my[] = {-1, 1, 0, 0};\n\nint dfs(int x, int y, vector<string> &v) {\n    int cnt = 1;\n    for ( int i = 0; i < 4; i++ ) {\n        int nx = x + mx[i], ny = y + my[i];\n        if ( 0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == '.' ) {\n            v[ny][nx] = '#';\n            cnt += dfs(nx, ny, v);\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while ( true ) {\n        int x, y;\n        cin >> w >> h;\n        if ( w == 0 && h == 0 ) break;\n\n        vector<string> v(h);\n\n        for ( int i = 0; i < h; i++ ) {\n            cin >> v[i];\n\n            for ( int j = 0; j < v[i].size(); j++ ) {\n                if ( v[i][j] == '@' ) {\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n\n        cout << dfs(x, y, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (cin >> w >> h, w || h){\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\n\tdfs(sx, sy);\n\n\tcout << tile << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing std::cin;\nusing std::cout;\n\nint cnt = 0;\nchar map[21][21];\n\nvoid dfs(int x, int y, int mx, int my){\n    if((x < 0) || (x >= mx)){\n        return;\n    }\n    if((y < 0) || (y >= my)){\n        return;\n    }\n    if(map[x][y] == '#'){\n        return;\n    }\n    map[x][y] = '#';\n    cnt++;\n    dfs(x+1, y, mx, my);\n    dfs(x-1, y, mx, my);\n    dfs(x, y+1, mx, my);\n    dfs(x, y-1, mx, my);\n}\n\nint main(){\n    int W, H, sx, sy;\n    cin >> W >> H;\n\n    while(W != 0 && H != 0){\n        for(int i = 0; i < H; i++){\n            scanf(\"%20s\", map[i]);\n            if(std::string(map[i]).find('@') != std::string::npos){\n                sx = i;\n                sy = std::string(map[i]).find('@');\n            }\n        }\n        dfs(sx, sy, H, W);\n        cout << cnt << std::endl;\n\n        cin >> W >> H;\n        cnt = 0;\n        \n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tqueue<pair<int, int> > q;\n\t\tchar map[114][514];\n\t\tfor (int i = 1; i <= w; i++) {\n\t\t\tfor (int j = 1; j <= h; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')q.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\twhile (q.size()) {\n\t\t\tans++;\n\t\t\tint x = q.back().first;\n\t\t\tint y = q.back().second;\n\t\t\tq.pop();\n\t\t\tmap[x][y] = '#';\n\t\t\tif (map[x - 1][y] == '.')\n\t\t\t\tq.push(make_pair(x - 1, y));\n\t\t\tif (map[x + 1][y] == '.')\n\t\t\t\tq.push(make_pair(x + 1, y));\n\t\t\tif (map[x][y - 1] == '.')\n\t\t\t\tq.push(make_pair(x, y - 1));\n\t\t\tif (map[x][y + 1] == '.')\n\t\t\t\tq.push(make_pair(x, y + 1));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[20][20] = {} ;\nint cnt,w, h, p[20][20] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 400; i++) {\n\t\t\tc[i / 20][i % 20] = p[i / 20][i % 20] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j][i] = 0;\n\t\t\t\t\tp[j][i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j][i] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1 || p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[0][i] == 0 && (p[0][i + 1] == 1 || p[0][i - 1] == 1)) {\n\t\t\t\t\t\tp[0][i] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i][0] == 0 && (p[i + 1][0] == 1 || p[i - 1][0] == 1)) {\n\t\t\t\t\t\tp[i][0] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*for (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j][i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h][i%h] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\nvector<int> ans;\ntypedef pair <int, int> P;\n\nint  main(){\n  int W,H;\n  cin >> W >> H;\n  int tate[4] = {0,1,0,-1};\n  int yoko[4] = {1,0,-1,0};\n  while(W){\n    int count = 0;\n    queue < P > zahyou;\n    vector< vector<int> > room(H, vector<int>(W));\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        char a;\n        cin >> a;\n        if(a == '.')room[i][j] = 1;\n        else if(a == '@'){\n          zahyou.push( P (i,j) );\n          room[i][j] = 1;\n        }\n        else room[i][j] = 0;\n      }\n    }\n    while(zahyou.size()){\n      pair<int, int> now = zahyou.front();\n      zahyou.pop();\n      if(room[now.first][now.second] == 1){\n        count++;\n        room[now.first][now.second] = 0;\n        for(int i = 0; i < 4 ; i++){\n          if(now.first+tate[i]>=0 && now.first+tate[i] < H && now.second+yoko[i] >= 0 && now.second+yoko[i] < W && room[now.first+tate[i]][now.second+yoko[i]] == 1)\n            zahyou.push( P (now.first+tate[i], now.second+yoko[i]));\n        }\n      }\n    }\n    ans.push_back(count);\n    cin >> W >> H;\n  }\n  for(int i = 0 ; i < ans.size(); i++)\n    cout << ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n\nchar N[21][21]={};\nchar L[21]={};\n\nint W,H;\nwhile(1){\ncin>>W>>H;if(W==0&&H==0)break;\n\n\nfor(int i=0;i<H;i++){\nscanf(\"%s\",L);\nfor(int j=0;j<W;j++)\nN[i][j]=L[j];\n}\n\nint n[22][22]={};int c=0;\nfor(int i=1;i<H+1;i++)\nfor(int j=1;j<W+1;j++)\n{if(n[i][j]==0&&(N[i-1][j-1]=='@'||N[i-1][j-1]=='.')){c++;\nn[i][j]=c;}\nif(N[i-1][j-1]=='@'||N[i-1][j-1]=='.'){\nif(N[i-1][j+1-1]=='@'||N[i-1][j+1-1]=='.')n[i][j+1]=n[i][j];\nif(N[i+1-1][j-1]=='@'||N[i+1-1][j-1]=='.')n[i+1][j]=n[i][j];\n}\n}\n\nfor(int i=0;i<H+1;i++)\nfor(int j=0;j<W+1;j++)\n{if(n[i][j]!=0&&n[i][j+1]>n[i][j]){\nint t=n[i][j+1];\nfor(int ii=0;ii<H+1;ii++)\nfor(int jj=0;jj<W+1;jj++)\nif(n[ii][jj]==t)n[ii][jj]=n[i][j];\n}\nif(n[i][j]!=0&&n[i][j-1]>n[i][j]){\nint t=n[i][j-1];\nfor(int ii=0;ii<H+1;ii++)\nfor(int jj=0;jj<W+1;jj++)\nif(n[ii][jj]==t)n[ii][jj]=n[i][j];\n}\nif(n[i][j]!=0&&n[i+1][j]>n[i][j]){\nint t=n[i+1][j];\nfor(int ii=0;ii<H+1;ii++)\nfor(int jj=0;jj<W+1;jj++)\nif(n[ii][jj]==t)n[ii][jj]=n[i][j];\n}\nif(n[i][j]!=0&&n[i-1][j]>n[i][j]){\nint t=n[i-1][j];\nfor(int ii=0;ii<H+1;ii++)\nfor(int jj=0;jj<W+1;jj++)\nif(n[ii][jj]==t)n[ii][jj]=n[i][j];\n}\n}\n\nint p=0;\nfor(int i=0;i<H;i++)\nfor(int j=0;j<W;j++)\nif(N[i][j]=='@')p=n[i+1][j+1];\n/*\nfor(int i=1;i<H+2;i++){\nfor(int j=1;j<W+2;j++)\n\tcout<<n[i][j];\ncout<<endl;\n}*/\n\nint g=0;\nfor(int i=1;i<H+1;i++)\nfor(int j=1;j<W+1;j++)\nif(n[i][j]==p)g++;\n\ncout<<g<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 20\nint ans,baseX,baseY;\nint w,h;\nchar tile[MAX][MAX];\nvoid seek(int x,int y);\nusing namespace std;\nint main() {\n  while(1){\n    cin >> w;\n    cin >> h;\n    if(w==0&&h==0) return 0;\n    rep(i,h){\n      rep(j,w){\n        cin >> tile[i][j];\n        if(tile[i][j] == '@'){\n          baseX = i;\n          baseY = j;\n        }\n      }\n      tile[i][w] = '#';\n    }\n    rep(i,w) tile[h][i] = '#';\n    ans = 1;\n    seek(baseX,baseY);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nvoid seek(int x,int y){\n  if(tile[x+1][y] == '.'){\n    tile[x+1][y] = '#';\n    ans++;\n    seek(x+1,y);\n  }\n  if(tile[x][y+1] == '.'){\n    tile[x][y+1] = '#';\n    ans++;\n    seek(x,y+1);\n  }\n  if(tile[x-1][y] == '.'){\n    tile[x-1][y] = '#';\n    ans++;\n    seek(x-1,y);\n  }\n  if(tile[x][y-1] == '.'){\n    tile[x][y-1] = '#';\n    ans++;\n    seek(x,y-1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n//#include<fstream>\n\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    n++;\n    map[starty][startx]=false;\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        dfs(x,y,map);}\n    }\n    \n}\n\nint main(){\n    int x,y;\n    //ofstream outputfile(\"test.txt\");\n    while(cin>>x>>y,x|y){\n        int startx,starty;\n        vector<vector<bool> > map;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        //outputfile<<n;\n        //outputfile<<\"\\n\";\n        cout<<n<<endl;\n        \n    }\n    //outputfile.close();\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool mp[50][50];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint h,w;\nint dfs(int y,int x){\n  if(mp[y][x])return 0;\n  int ret=1;\n  mp[y][x]=1;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n    ret+=dfs(ny,nx);\n  }\n  return ret;\n}\n  \nint main(){\n  string s;\n  int si,sj;\n  while(cin>>w>>h && w&&h){\n    memset(mp,0,sizeof(mp));\n    for(int i=0;i<h;i++){\n      cin>>s;\n      for(int j=0;j<w;j++){\n        if(s[j]=='#') mp[i][j]=1;\n        else if(s[j]=='@') {si=i;sj=j;}\n      }\n    }\n    cout<<dfs(si,sj)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nint visited[20][20];\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)visited[i][j]=0;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         visited[now.first][now.second]=1;\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(visited[ni][nj]) continue;\n            Q.push(pii(ni, nj));\n         }\n      }\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=visited[i][j];\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define BLACK 1\n#define RED 2\n#define ARUKERUYO 10\nusing namespace std;\n\nvoid aaa(int *data, int n, int a, int b){\n\n  data[n] = ARUKERUYO;\n\n  if(data[n-a] == BLACK && n-a >= 0) aaa(data,n-a,a,b);\n  if(data[n-1] == BLACK && n%a != 0) aaa(data,n-1,a,b);\n  if(data[n+1] == BLACK && n%a != a-1) aaa(data,n+1,a,b);\n  if(data[n+a] == BLACK && n+a <= a*b-1) aaa(data,n+a,a,b);\n\n  return;\n}\n\nint main(){\n  int a,b;\n\n  while(cin>>a>>b){\n    if(a==0&&b==0)\n      break;\n    char sym;\n    int data[a*b];\n    int stand;\n\n    for(int i=0;i<a*b;i++){\n      cin >> sym;\n      if(sym=='.')\n\tdata[i] = BLACK;\n      else if(sym=='#')\n\tdata[i] = RED;\n      else\n\tstand = i;\n    }\n    aaa(data,stand,a,b);\n    stand = 0;\n    for(int i=0;i<a*b;i++)\n      if(data[i] == ARUKERUYO)\n\tstand++;\n    cout << stand << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint W,H,res;\nstring board[30];\n\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,1,-1};\n\nvoid dfs(int y, int x){\n  int i;\n\n  res++;\n  board[y][x] = '#';\n  rep(i,4){\n    int my = y + dy[i];\n    int mx = x + dx[i];\n    if(0 <= my && my < H && 0 <= mx && mx < W && board[my][mx] == '.') dfs(my,mx);\n  }\n}\n\nint main(){\n  int i,j;\n\n  while(1){\n    scanf(\"%d %d\",&W,&H);\n    if(W == 0 && H == 0) break;\n\n    rep(i,H) cin >> board[i];\n\n    res = 0;\n    rep(i,H) rep(j,W) if(board[i][j] == '@') dfs(i,j);\n    printf(\"%d\\n\",res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint w, h;\nchar ch[50][50];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid bfs(int y, int x) {\n    rep(i, 4) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 > ny or 0 > nx or ny >= h or nx >= w) continue;\n        if (ch[ny][nx] == '.') {\n            ch[ny][nx] = 'a';\n        }\n    }\n}\n\nint main() {\n    while (cin >> w >> h and w and h) {\n        int py = 0, px = 0;\n        rep(i, h) rep(j, w) {\n            cin >> ch[i][j];\n            if (ch[i][j] == '@') {\n                py = i, px = j;\n                ch[i][j] = '.';\n            }\n        }\n        bfs(py, px);\n        int ans = 0;\n        rep(i, h) rep(j, w) if (ch[i][j] == 'a') ans++;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<tuple>\n#include<list>\n#include<unordered_map>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\n\nll dx[4] ={1,0,-1,0} , dy[4] ={0,1,0,-1};\nll h,w;\nll nowx,nowy;\nchar field[30][30];\n\nvoid bfs(){\n    ll d[30][30];\n    queue<pll> que;\n    rep(i,h)rep(j,w) d[i][j]=0;\n    d[nowx][nowy]=1;\n    que.push(pll(nowx,nowy));\n    ll ans=1;\n    while(!que.empty()){\n        pll p = que.front();\n        que.pop();\n        rep(i,4){\n            ll nx = p.first + dx[i] , ny = p.second + dy[i];\n            if( nx>=0 && nx <h && ny >=0 && ny < w  && d[nx][ny] == 0 ){\n                if(field[nx][ny]=='.'){\n                    que.push(pll(nx,ny));\n                    ans++;\n                }\n                d[nx][ny]=1;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return ;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    \n    while(true){\n        cin>>w>>h;\n        if(w==0&&h==0) break;\n        rep(i,h)rep(j,w){\n            cin>>field[i][j];\n            if(field[i][j]=='@') {\n                nowx=i,nowy=j;\n            }\n        }\n        bfs();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n// #define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n\nint w,h,fx,fy;\nchar ban[30][30];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nbool inrange(int px,int py){\n  if(px<0||py<0||px>=h||py>=w) return false;\n  else return true;\n}\nint bsearch(int px,int py){\n  int cnt = 0;\n  REP(i,4){\n    int nx = px+ dx[i]; int ny = py+dy[i];\n    if(!inrange(nx,ny)) continue;\n    if(ban[nx][ny]=='#') continue;\n    //cnt++;\n    //cout << nx << \" \" <<ny<<endl;\n    if(ban[nx][ny]=='.'){\n      ban[nx][ny]='!';\n      cnt++;\n      cnt += bsearch(nx,ny);\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while(1){\n    cin >> w >> h;\n    if((w==0)&&(h==0)) break;\n    REP(i,h){\n      char buf[21];\n      cin >> buf;\n      REP(j,w) {\n        ban[i][j] = buf[j];\n        if(ban[i][j] == '@'){\n          fx = i; fy = j;\n        }\n      }\n    } \n    cout << bsearch(fx,fy)+1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\tif( 0 <= x && x < W && 0 <= y && y < H && room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '*';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\txy.pop();\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar mp[21][21];\nint alred[21][21];\nint hai = 0;\nvoid init(){\n  for(int i = 0; 20 > i; i++){\n    for(int j = 0; 20 > j; j++){\n      mp[i][j] = ' ';\n      alred[i][j] = 0;\n    }\n  }\n  hai = 0;\n}\nint tansa(int w, int h, int sw, int sh,int ret){\n  if(mp[sw][sh] == '.')ret++,alred[sw][sh] = 1;\n  if(((sw+1)!=w) && (mp[sw+1][sh] == '.' && alred[sw+1][sh] == 0))ret+=tansa(w,h,sw+1,sh,0);\n  if((sw!=0) &&(mp[sw-1][sh] == '.' && alred[sw-1][sh] == 0))ret+=tansa(w,h,sw-1,sh,0);\n  if(((sh+1)!=h) && (mp[sw][sh+1] == '.' && alred[sw][sh+1] == 0))ret+=tansa(w,h,sw,sh+1,0);\n  if((sh!=0) && (mp[sw][sh-1] == '.' && alred[sw][sh-1] == 0))ret+=tansa(w,h,sw,sh-1,0);\n  return ret;\n}\nint main(){\n  while(true){\n    int w,h;cin>>w>>h;\n    init();\n    int sw,sh;\n    if(w == 0)break;\n    for(int i = 0; h > i; i++){\n      for(int j = 0; w > j; j++){\n        cin >> mp[i][j];\n        if(mp[i][j] == '@'){\n          sw = i;\n          sh = j;\n        }\n      }\n    }\n    cout << tansa(h,w,sw,sh,0)+1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/* vim:set foldmethod=marker: */\n#include <bits/stdc++.h>\nusing namespace std;\n\n//{{{\n#define all(x) (x).begin(),(x).end()\n#define REP(i,a,b) for(int i=(int)(a); i<(int)(b); i++)\n#define RREP(i,a,b) for(int i=(int)(a); i>=b; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,n,0)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vp;\n\n#define dump(x) (cerr << #x << \"=\" << x << endl)\ntemplate<class T> ostream& osContainer(ostream& os,T c) { os<<'[';for(decltype(c.begin()) it=c.begin();it!=c.end();it++)os<<*it<<',';os<<']';return os; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { return osContainer(os,v); }\ntemplate<class T> ostream& operator<<(ostream& os,const set<T>& s) { return osContainer(os,s); }\ntemplate<class T> ostream& operator<<(ostream& os,const multiset<T>& s) { return osContainer(os,s); }\ntemplate<class T,class S> ostream& operator<<(ostream& os,const map<T,S>& m) { return osContainer(os,m); }\ntemplate<class T,class S> ostream& operator<<(ostream& os,const multimap<T,S>& m) { return osContainer(os,m); }\ntemplate<class T1,class T2>\nostream& operator<<(ostream& os, const pair<T1,T2>& p){ os << '(' << p.first << ',' << p.second << ')'; return os; }\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n//}}}\n//\n\nchar check[20][20];\nchar field[21][21];\n\nvoid solve()\n{\n    int w, h;\n    while (cin >> w >> h, w || h) {\n        memset(check, 0, sizeof(check));\n\n        int sx, sy;\n\n        rep(i, h) {\n            rep(j, w){\n                char c;\n                cin >> c;\n                field[i][j] = c;\n                if (c == '@') {\n                    sy = i, sx = j;\n                    check[sy][sx] = 1;\n                }\n            }\n            cin.ignore();\n        }\n\n        queue<pair<int, int>> q;\n        q.push(mp(sy, sx));\n\n        int s = 1;\n\n        while(!q.empty()) {\n            auto p = q.front();q.pop();\n            int y = p.first, x = p.second;\n\n            rep(i, 4) {\n                int ddy = y + dy[i], ddx = x + dx[i];\n\n                if (0 <= ddy && ddy < h && 0 <= ddx & ddx < w && field[ddy][ddx] == '.' && !check[ddy][ddx]) {\n                    s++;\n                    check[ddy][ddx] = 1;\n                    q.push(mp(ddy, ddx));\n                }\n            }\n        }\n\n        cout << s << endl;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "/*********\n深さ優先探索\n**********/\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nvoid saiki(int xx,int yy);\n\nint x,y;\nint ans=0;\nchar tail[20][20]={};\nint i,j;\n\n\n\nint main(){\n  \n  while(1){\n  scanf(\"%d %d\",&x,&y);\n  if(x==0 && y==0);\n  for(i=0;i<y;i++) scanf(\"%s\",tail[i]);\n  \n  for(i=0;i<y;i++){\n    for(j=0;j<x;j++){\n      if(tail[i][j]=='@'){\n\tsaiki(j,i); break;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  ans=0;\n  }\n  \n  return 0;\n}\n\n\nvoid saiki(int xx,int yy){\n\n  ans++;\n  tail[yy][xx]='#';\n\n  int ny=yy-1,nx=xx;\n  if(0<=nx && nx<x && 0<=ny && ny<y && tail[ny][nx]=='.') saiki(nx,ny);//水たまりだったら再起\n  ny=yy,nx=xx-1;\n  if(0<=nx && nx<x && 0<=ny && ny<y && tail[ny][nx]=='.') saiki(nx,ny);\n  ny=yy,nx=xx+1;\n  if(0<=nx && nx<x && 0<=ny && ny<y && tail[ny][nx]=='.') saiki(nx,ny);\n  ny=yy+1,nx=xx;\n  if(0<=nx && nx<x && 0<=ny && ny<y && tail[ny][nx]=='.') saiki(nx,ny);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nconst int MAX_W = 50;\nconst int MAX_H = 20;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nint H, W;\nbool ok[MAX_H][MAX_W];\nchar maze[MAX_H][MAX_W+1];\nint sx, sy;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < H && 0 <= hy && hy < W; }\n\nint main()\n{\n  while((cin >> W >> H) && W){\n    rep(i, H) cin >> maze[i];\n\n    rep(i, H) rep(j, W) ok[i][j] = false;\n    rep(i, H) rep(j, W) if(maze[i][j] == '@') sx = i,  sy = j;\n\n    stack<pii> st;\n    st.push(mp(sx, sy));\n    maze[sx][sy] = '.';\n    ok[sx][sy] = true;\n    while(!st.empty()){\n      pii here = st.top();  st.pop();\n      int hx = here.first;\n      int hy = here.second;\n      rep(k, 4){\n        int nx = hx + dx[k];\n        int ny = hy + dy[k];\n        if(!check(nx, ny) || maze[nx][ny] == '#') continue;\n        if(ok[nx][ny]) continue;\n        ok[nx][ny] = true;\n        st.push(mp(nx, ny));\n      }\n    }\n\n    int res = 0;\n    rep(i, H) rep(j, W) if(ok[i][j]) res += 1;\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stack>\n#include <string>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(void){\n\tint h,w;\n\tstack<pii> s;\n\tstring m[21];\n\twhile(cin>>w>>h,w||h){\n\t\tfor(int i=0;i<h;i++)cin>>m[i];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='@'){\n\t\t\t\t\ts.push(pii(i,j));\n\t\t\t\t\ti=j=999;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c=0;\n\t\twhile(!s.empty()){\n\t\t\tpii a=s.top();s.pop();\n\t\t\tint i=a.first;\n\t\t\tint j=a.second;\n\t\t\tif(!(0<=i&&i<h&&0<=j&&j<w))continue;\n\t\t\tif(m[i][j]=='#')continue;\n\t\t\tc++;\n\t\t\tm[i][j]='#';\n\t\t\ts.push(pii(i+1,j));\n\t\t\ts.push(pii(i-1,j));\n\t\t\ts.push(pii(i,j+1));\n\t\t\ts.push(pii(i,j-1));\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <utility>\n\n#define ll (long long)\n#define REP(i,n) for(int i = 0;i<(int)n;i++)\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (a);i>(b);i--)\n#define COUNTER int i= 0,j = 0,k = 0,l = 0,m = 0, n= 0;\n#define RETURN cout << endl;\n/*vector<vector<int>>ArrayName = vector<vector<int>>(sizeofx, vector<int>(sizeofy, 0));*/\nusing namespace std;\n\n\n\nint dfs (int x,int y,vector<vector<char>>&v);\n\nint lim_x,lim_y;\nint mx[] = {-1,1,0,0};\nint my[] = {0,0,-1,1,};\n\nint main (void){\n    \n    int x,y;\n    int sh_x = 0,sh_y = 0;\n    \n    while(cin >> lim_x >> lim_y,lim_x+lim_y)\n        {\n            vector<vector<char>>v = vector<vector<char>>(lim_y, vector<char>(lim_x, 0));\n            REP(i,lim_y)\n            REP(j,lim_x)\n            {\n                cin >> v[i][j];\n                if(v[i][j] == '@')\n                    {\n                        sh_y = i;\n                        sh_x = j;\n                    }\n            }\n            //cout << lim_x << \" \" << lim_y << endl;\n            //cout << sh_x  <<\" \"<< sh_y << endl;\n            cout << dfs(sh_x,sh_y,v) << endl;\n            /*v is array name(pointer)*/\n      \n        }\n    return 0;\n}\n\nint dfs(int x,int y, vector<vector<char>>&v)\n{\n    int counter = 1;\n    for(int i = 0; i<4;i++){\n            int tx = x+mx[i],ty = y+my[i];\n            if((tx >= 0 && tx<lim_x) && (ty >= 0 && ty <lim_y) && (v[ty][tx] == '.'))\n            {\n                v[ty][tx] = '#';\n                //cout << v[ty][tx] << endl;\n                counter += dfs(tx, ty, v);\n                //cout << \"come on !\" << endl;\n            }\n                \n        }\n            \n    return counter;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid search(int x, int y, int w, int h, int tile[20][20], int& num){\n  if(tile[y][x] != 0){\n    num++;\n    tile[y][x] = 0;\n  \n    if(x-1 >= 0){\n      search(x-1, y, w, h, tile, num);\n    }\n    if(x+1 < w){\n      search(x+1, y, w, h, tile, num);\n    }\n    if(y-1 >= 0){\n      search(x, y-1, w, h, tile, num);\n    }\n    if(y+1 < h){\n      search(x, y+1, w, h, tile, num);\n    }\n  }\n}\n\nint main(void){\n  int w, h, x, y;\n  char c[20][21];\n  int tile[20][20];\n  while(1){\n    scanf(\"%d%d\", &w, &h);\n    if(w==0 && h==0){\n      break;\n    }\n    int num = 0;\n    for(int i=0; i<h; i++){\n      scanf(\"%s\", c[i]);\n    }\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(c[i][j] == '.'){\n\t  tile[i][j] = 1;\n\t}else if(c[i][j] == '@'){\n\t  tile[i][j] = 1;\n\t  x = j;\n\t  y = i;\n\t}else if(c[i][j] == '#'){\n\t  tile[i][j] = 0;\n\t}\n      }\n    }\n    search(x, y, w, h, tile, num);\n    printf(\"%d\\n\", num);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\n\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int _x, int _y) :x(_x), y(_y){}\n};\n\nchar tile[20][20];\nstack<point> st;\n\nint main()\n{\n\tcin.tie(0); ios::sync_with_stdio(false); \n\tfstream fs(\"input.txt\");\n\t////////////ここから開始///////////\n\n\t\n\tint x(-1), y(-1);\n\twhile (x != 0 && y != 0){\n\t\tREP(i, 20)REP(j, 20)tile[i][j] = '#';\n\t\tcin >> x >> y;\n\t\t//fs >> x >> y;\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\t//fs >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t\tst.emplace(i, j);\n\t\t\t}\n\t\t}\n\n\t\tint dx[]{0, 1, 0, -1};\n\t\tint dy[]{1, 0, -1, 0};\n\t\tint ans(1);\n\n\t\twhile (!st.empty()){\n\t\t\tpoint now = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tint x1 = now.x + dx[i];\n\t\t\t\tint y1 = now.y + dy[i];\n\t\t\t\tif (x1 > 19 || x1 < 0 || y1 > 19 || y1 < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tile[x1][y1] == '.'){\n\t\t\t\t\tst.emplace(x1, y1);\n\t\t\t\t\ttile[x1][y1] = '#';\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <complex>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint main(){\n\twhile(1){\n\t\tint h,w,ret=0;\n\t\tcin>>w>>h;\n\t\tif(w==0)return 0;\n\t\tVS board(h);\n\t\tREP(i,h)cin>>board[i];\n\t\tpriority_queue<PII> q;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tif(board[i][j]=='@'){\n\t\t\t\t\tboard[i][j]='.';\n\t\t\t\t\tq.push(MP(i,j));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPII tmp = q.top();\n\t\t\tq.pop();\n\t\t\tif(board[tmp.first][tmp.second] != '.')continue;\n\t\t\tboard[tmp.first][tmp.second] = '#';\n\t\t\tret++;\n\t\t\tREP(i,4){\n\t\t\t\tif(tmp.first+dy[i] < h&& 0<= tmp.first+dy[i] && tmp.second+dx[i]<w && 0<=tmp.second+dx[i])\n\t\t\t\t\tq.push(MP(tmp.first+dy[i], tmp.second+dx[i]));\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 500;\nbool vis[N][N];\nchar m[N][N];\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\nint cnt;\n\nvoid dfs(int r,int c,int y,int x){\n  if (vis[y][x])return;\n  vis[y][x]=true;\n  cnt++;\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex == -1 || ney == -1 || nex == c || ney == r ||\n\tm[ney][nex] == '#')continue;\n    dfs(r,c,ney,nex);\n  }\n\n\n}\n\nmain(){\n  int c,r;\n  while(cin>>c>>r){\n    if (c == 0 && r == 0)break;\n    int sy=0,sx=0;\n    cnt=0;\n    rep(i,r)rep(j,c)vis[i][j]=false;\n    rep(i,r){\n      cin>>m[i];\n      rep(j,c)if (m[i][j] == '@')sy=i,sx=j;\n    }\n    dfs(r,c,sy,sx);\n    cout << cnt << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define vec vector\n\nint dp[22][22];\nint dx[4] = {1, -1, 0,  0};\nint dy[4] = {0,  0, 1, -1};\nint ans;\nvec<string> a;\n\nvoid solve(int p, int q)\n{\n    if (dp[p + 1][q + 1]) return;\n    dp[p + 1][q + 1] = 1;\n    if (a[p][q] != '#') {\n        ans++;\n    } else return;\n    rep(i, 4) solve(p + dx[i], q + dy[i]);\n}\n\nint main(void)\n{\n    while(1) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) break;\n        rep(i, h + 2) rep(j, w + 2) dp[i][j] = 0;\n        rep(i, w + 2) {\n            dp[0][i] = -1;\n            dp[h + 1][i] = -1;\n        }\n        rep(i, h + 2) {\n            dp[i][0] = -1;\n            dp[i][w + 1] = -1;\n        }\n        a.clear();\n        a.resize(h);\n        pair<int, int> start;\n        rep(i, h) {\n            cin >> a[i];\n            rep(j, w) if (a[i][j] == '@') start = make_pair(i, j);\n        }\n        //dp[start.first + 1][start.second + 1] = 1;\n        ans = 0;\n        solve(start.first, start.second);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]){\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    int w, h;\n    int cnt = 0;\n    int sx, sy;\n    while(true){\n        cnt = 0;\n        vector<string> v = {};\n        string tmp;\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        rep(i, h){\n            cin >> tmp;\n            v.push_back(tmp);\n            if(tmp.find('@') != string::npos){\n                sx = i;\n                sy = tmp.find('@');\n            }\n        }\n        \n        queue<pair<int, int>> q;\n        q.push({sx, sy});\n        while(!q.empty()){\n            pair<int, int> p = q.front();\n            q.pop();\n            // cout << \"Now : \" << p.first << \" \" << p.second << endl;\n            if(p.first >= h\n                || p.second >= w\n                || p.first  < 0\n                || p.second < 0\n            )continue;\n            if((v[p.first][p.second] == '.' || v[p.first][p.second] == '@')) {\n                v[p.first][p.second] = '#';\n                cnt++;\n                rep(i, 4){\n                    q.push({p.first + dx[i], p.second + dy[i]});\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<functional>\n#include<stack>\n#include<list>\n#include<string>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define PII pair<int,int>\n#define PCC pair<char,char>\n#define PCI pair<char,int>\n#define PIC pair<int,char>\n#define MP make_pair\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\nchar MAP[20][20];\nint ans;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nvoid dfs(int x, int y,int w,int h) \n{\n\tif (x < 0 || x>=w || y < 0 || y>=h)return;\n\telse if (MAP[y][x] == '#')return;\n\telse\n\t{\n\t\tMAP[y][x] = '#';\n\t\t::ans++;\n\t\tfor (int r = 0; r < 4; r++)\n\t\t{\n\t\t\tint nx = x + dx[r];\n\t\t\tint ny = y + dy[r];\n\t\t\tdfs(nx, ny,w,h);\n\t\t}\n\t}\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tint w, h;\n\t\t::ans = 0;\n\t\tcin >> w >> h;\n\t\tif (w == 0)break;\n\t\tPII self;\n\t\tREP(y, h)\n\t\t{\n\t\t\tREP(x, w)\n\t\t\t{\n\t\t\t\tcin >> MAP[y][x];\n\t\t\t\tif (MAP[y][x] == '@')self = MP(y, x);\n\t\t\t}\n\t\t}\n\t\tdfs(self.second, self.first,w,h);\n\t\tcout << ::ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n    int w, h;\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    char map[20][20];\n    while (true) {\n        int count = 1;\n        queue<P> q;\n        cin >> w >> h;\n        if (w == 0) {\n            return 0;\n        }\n        for (int y=0; y<h; y++) {\n            for (int x=0; x<w; x++) {\n                cin >> map[x][y];\n                if (map[x][y] == '@') {\n                    q.push(P(x, y));\n                }\n            }\n        }\n        while (!q.empty()) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            for (int i=0; i<4; i++) {\n                int nx = x+dx[i];\n                int ny = y+dy[i];\n                if (nx < 0 || w <= nx || ny < 0 || h <= ny) {\n                    continue;\n                }\n                if (map[nx][ny] != '.') {\n                    continue;\n                }\n                map[nx][ny] = '#';\n                q.push(P(nx, ny));\n                count++;\n            }\n        }\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  set<P> s;\n  while (q.size()) {\n    P p = q.front();\n    q.pop();\n    s.insert(p);\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        pair<set<P>::iterator, bool> r = s.insert(P(i, j));\n        if (r.second) q.push(*r.first);\n      }\n    }\n  }\n  return s.size();\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE][MAX_SIZE];\n  char c[MAX_SIZE + 1];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> c;\n      for (int j = 0; j < W; ++j) {\n        f[i][j] = c[j];\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define SIZE 100000\ntypedef struct{\n  int x;\n  int y;\n}Zahyo;\nZahyo  z[SIZE];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nmain(){\n  int h,w;\n  int head=0;\n  int tail=0;\n  int cnt=0;\n  char maps[30][30];\n  int i,j;\n  scanf(\"%d %d\",&w,&h);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%c\",&maps[i][j]);\n      if(maps[i][j]=='@'){\n\tz[0]=(Zahyo){j,i};\n\ttail=(tail+1)%SIZE;\n      }\n    }\n  }\n  while(head != tail){\n    int x = z[head].x; int y = z[head].y; head = (head+1) % SIZE;\n    if(0 <= x && 0 <= y && x < w && y < h && maps[y][x] != '#'){\n      maps[y][x] = '#';\n      cnt++;\n      for(i=0;i<4;i++){\n\tint nx = x + dx[i]; int ny = y + dy[i];\n\tz[(tail+i) % SIZE] = (Zahyo){ nx,ny };\n      }\n      tail = (tail+4) % SIZE;\n    }\n  }\n  printf(\"%d\\n\",cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int h,w;\n    cin >> w >> h;\n    if(w==0) return 0;\n    vector<vector<int>> field(h,vector<int>(w));\n    vector<vector<bool>> searched(h,vector<bool>(w,false));\n    char c;\n    int sx,sy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        if(c=='.'){\n          field[i][j]=0;\n        }else if(c=='#'){\n          field[i][j]=1;\n        }else{\n          sx=j;\n          sy=i;\n          field[i][j]=0;\n        }\n      }\n    }\n    searched[sy][sx]=true;\n    queue<pair<int,int>> bfs;\n    bfs.push({sx,sy});\n    int nx,ny,houkou[5]={0,1,0,-1,0};\n    int count=1;\n    while(!bfs.empty()){\n      pair<int,int> now=bfs.front();\n      bfs.pop();\n      for(int i=0;i<4;i++){\n        nx=now.first+houkou[i];\n        ny=now.second+houkou[i+1];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(!searched[ny][nx]&&field[ny][nx]==0){\n            searched[ny][nx]=true;\n            bfs.push({nx,ny});\n            count++;\n          }\n        }\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass DoubleArray {\n    int X,Y;\n    int *top;\n    public:\n    DoubleArray(int *p,int x,int y);\n    int *operator[](int i);\n    int getx();\n    int gety();\n};\n\nDoubleArray::DoubleArray(int *p,int x,int y){\n    top = p;\n    X = x;\n    Y = y;\n}\n\nint *DoubleArray::operator[](int i){\n    return top + Y*i;\n}\nint DoubleArray::getx(){\n    return X;\n}\nint DoubleArray::gety(){\n    return Y;\n}\n\nint calc(DoubleArray &map){\n    int i,j,a=0;\n    int x = map.getx();\n    int y = map.gety();\n    queue<int> q;\n    for(i=0;i<x;i++){\n        for(j=0;j<y;j++){\n            if(map[i][j]==2){\n                q.push(i);\n                q.push(j);\n                a=1;\n                map[i][j]=0;\n            }\n        }\n    }\n    while(!q.empty()){\n        i=q.front();\n        q.pop();\n        j=q.front();\n        q.pop();\n        if(i>0) if(map[i-1][j]==1){\n            q.push(i-1);\n            q.push(j);\n            a++;\n            map[i-1][j]=0;\n        }\n        if(j>0) if(map[i][j-1]==1){\n            q.push(i);\n            q.push(j-1);\n            a++;\n            map[i][j-1]=0;\n        }\n        if(i<x-1) if(map[i+1][j]==1){\n            q.push(i+1);\n            q.push(j);\n            a++;\n            map[i+1][j]=0;\n        }\n        if(j<y-1) if(map[i][j+1]==1){\n            q.push(i);\n            q.push(j+1);\n            a++;\n            map[i][j+1]=0;\n        }\n    }\n    return a;\n}\n\nint main(){\n    int i,j,x,y,a[10000],b = 0;\n    string c;\n    for(b=0; b<10000; b++){\n        cin >> x;\n        cin >> y;\n        if(x==0&&y==0) break;\n        if(x>20) x=20;\n        if(y>20) y=20;\n        if(x<1||y<1) continue;\n        int m[x][y];\n        DoubleArray map(&m[0][0],x,y);\n        for(j=0;j<y;j++){\n            for(i=0;i<x;i++){\n                cin >> c;\n                if(c==\"#\") map[i][j]=0;\n                if(c==\".\") map[i][j]=1;\n                if(c==\"@\") map[i][j]=2;\n            }\n        }\n        a[b] = calc(map);\n    }\n    for(i=0;i<b;i++){\n        cout << a[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconst int IINF = (1 << 30) - 1;\nconst long long LLINF = 1LL << 61;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nint dfs(int y, int x, vector< vector<char> > &v){\n    v[y][x] = '#';\n\n    int res = 1;\n    rep(i, 4){\n        if(v[y + dy4[i]][x + dx4[i]] == '.'){\n            res += dfs(y + dy4[i], x + dx4[i], v);\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n    while(cin >> w >> h, w){\n        vector< vector<char> > v(h + 2, vector<char>(w + 2, '#'));\n        int sy, sx;\n        reps(i, h){\n            reps(j, w){\n                cin >> v[i][j];\n                if(v[i][j] == '@'){\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n\n        int ans = dfs(sy, sx, v);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#define INF 10000000000\nusing namespace std;\n\ntypedef pair<int, int>P;\n\nchar maze[20][20];\nint H,W;\nint sx,sy,gx,gy;\nint d[20][20];\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint bfs(){\n  int rel=1;\n  queue<P> que;\n\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++) d[i][j]=0;\n\n  que.push(P(sx,sy));\n  d[sx][sy]=1;\n \n  while(que.size()){\n    P p=que.front();\n    que.pop();\n\n    for(int i=0;i<4;i++){\n      int nx=p.first+dx[i],ny=p.second+dy[i];\n      if(0<=nx&&nx<H&&0<=ny&&ny<W&&maze[nx][ny]!='#'&&d[nx][ny]==0){\n\tque.push(P(nx,ny));\n\td[nx][ny]=1;\n\trel++;\n      }\n    }\n  }\n  return rel;\n}\n\nvoid solve(){\n  int res=bfs();\n  cout<<res<<endl;\n}\n\nint main(){\n  char s;\n\n  while(1){\n    cin>>W>>H;\n    if(W+H==0)break;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>maze[i][j];\n\tif(maze[i][j]=='@'){\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n \n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n \nusing namespace std;\n \n int dx[4] = {1,0,-1,0};\n int dy[4] = {0,1,0,-1};\n\nvoid dfs(vector<string> &map,vector<vector<bool> > &move,int x,int y,int h, int w){\n  \n    if(x < 0 || x >=w || y < 0 || y >=h){\n      return ;\n    }\n\n    if(map[y][x] == '#'){\n      return;\n    }\n\n    if(move[y][x]){\n      return;\n    }\n\n    move[y][x] = true;\n\n    for(int i=0;i<4;i++){\n      dfs(map,move,x+dx[i],y+dy[i],h,w);\n    }\n\n    return;\n}\n\n\nint main()\n{\n\n  while(true){\n\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0&&h==0){\n      break;\n    }\n\n    vector<string> map(h);    \n    vector<vector<bool> > move(h,vector<bool>(w,false));\n    int x=0,y=0;\n    int count=0;\n\n    for(int i=0;i<h;i++){\n      cin >> map[i];\n      //cout << map[i] << endl;\n    }\n\n    for(int i=0;i<w;i++){\n      for(int k=0;k<h;k++){\n        if(map[k][i]=='@'){\n          x=i;\n          y=k;\n       \n        //  cout << w << \",\" << h << endl;\n        // cout << x << \",\" << y << endl; \n        }\n        \n     }\n    \n    }\n\n\n    dfs(map,move,x,y,h,w);\n\n   for(int i=0;i<w;i++){\n    for(int k=0;k<h;k++){\n      if(move[k][i]){\n        count++;\n      }\n    }\n   }\n  \n    cout << count << endl;\n\n  }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\n\nstruct pos{\n\tpos(int X,int Y){\n\t\tx=X,y=Y;\n\t}\n\tint x,y;\n};\n\nint move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tstack<pos> bfs;\n\tbfs.push(pos(x,y));\n\twhile(!bfs.empty()){\n\t\tpos n=bfs.top();bfs.pop();\n\t\tans++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\t\tmap[x+vec[i][0]][y+vec[i][1]]='#';\n\t\t\t\t\tbfs.push(pos(x+vec[i][0],y+vec[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool map[20][20];\nint w,h;\n\n\nint Search(int x,int y, int sum){\n\n  sum++;\n  map[y][x]=false;\n\n  cout << \"x,y=\" << x << ',' << y << endl;\n\n  if(x!=w-1){\n    if(map[y][x+1]==true){\n      sum = Search(x+1,y,sum);\n    }\n  }\n  if(x!=0){\n    if(map[y][x-1]==true){\n      sum = Search(x-1,y,sum);\n    }\n  }\n  if(y!=h-1){\n    if(map[y+1][x]==true){\n      sum = Search(x,y+1,sum);\n    }\n  }\n  if(y!=0){\n    if(map[y-1][x]==true){\n      sum = Search(x,y-1,sum);\n    }\n  }\n\n  return sum;\n\n}\n\n\nint main(){\n\n  int x,y;\n  char info;\n\n  while(cin >> w >> h){\n    if(w==0 && h==0){ break; }\n\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n          cin >> info;\n          if(info == '.'){ map[i][j]=true;}\n          else if(info == '#'){ map[i][j]=false;}\n          else{ x=j; y=i; map[i][j]=false;}\n        }\n    }\n\n    cout << Search(x,y,0) << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint w,h;\nchar rb[20][20];\t//redblack\nint n = 0;\t//乗れる\nvoid rob(int,int);\t//red or black\n\nint main(){\n\n\tint k = 0;\t//セットの数\n\tqueue<int> able;\t//乗れる数メモ\n\twhile(1){\n\t\tint x,y;\n\t\tcin >> w >> h ;\n\t\tif (w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> rb[j][i];\n\t\t\t\tif(rb[j][i] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t//入力終了\n\n\trob(x,y);\n\table.push(n);\n\tn = 0;\n\tk++;\n\t}\n\tfor(int i = 0; i < k; i++){\n\t\tcout << able.front() << endl;\n\t\table.pop();\n\t}\n\treturn 0;\n}\n\n\tvoid rob(int x,int y){\n\t\trb[x][y] = '#';\n\t\tn++;\n\t\tif(0 <= x-1 && rb[x-1][y] == '.'){\n\t\t\trob(x-1,y);\n\t\t}\n\t\tif(x+1 < w && rb[x+1][y] == '.'){\n\t\t\trob(x+1,y);\n\t\t}\n\t\tif(0 <= y-1 && rb[x][y-1] == '.'){\n\t\t\trob(x,y-1);\n\t\t}\n\t\tif(y+1 < h && rb[x][y+1] == '.'){\n\t\t\trob(x,y+1);\n\t\t}\t//十字\n\n\t\treturn ;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\nint W, H;\nstring s[20];\nint num;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nvoid dfs(int x, int y){\n  num++;\n  s[y][x] = '#';\n  for(int i=0; i<4; i++){\n    if(0<=x+dx[i] && x+dx[i]<W && 0<=y+dy[i] && y+dy<H && s[y+dy[i]][x+dx[i]]=='.'){\n      dfs(x+dx[i], y+dy[i]);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W || H){\n    for(int i=0; i<H; i++){\n      cin >> s[i];\n    }\n    int x, y;\n    for(int i=0; i<H; i++){\n      for(int j=0; j<W; j++){\n\tif(s[i][j] == '@'){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n    num = 0;\n    dfs(x, y);\n    cout << num << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 金子先生へ\n// ITC-LMSの「第9回提出物」の提出期間が6/23までで、期間後の提出が不可になっています。\n// しかし月曜までに今回の課題全部は解き終わらないので、いつもの様に7月末までにしてくださると幸いです。\n// 多分、今回の課題は全部解けそうです。\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility> // pair<int,int> xxxx;  make_pair(first,second);\nusing namespace std;\n\nint W,H;\nint X,Y; // 自分の位置\nchar s[20+10];\nchar c;\nbool tile[20+10][20+10]; // タイルの状態。trueは黒、falseは赤(または壁)。\nbool visited[20+10][20+10];\nint answer;\n\n// 右、上、左、下\nconst int dx[4] = { 1, 0, -1, 0 }; \nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool valid (int x, int y) {\n  return 0 <= x && x < H && 0 <= y && y < W && tile[x][y] ;\n}\n\nvoid init() { // 初期化\n  fill(&tile[0][0], &tile[0][0]+20*20, 0);\n  fill(&visited[0][0], &visited[0][0]+20*20, 0);\n  answer = 0;\n}\n\nvoid make_tile() { // タイル読み込み\n  for (int i=0; i<H; i++) {\n    scanf(\"%s\", s);\n    for (int j=0; j<W; j++) {\n      c = s[j];\n      if (c == '.') {\n\ttile[i][j] = true;\n      } else if (c == '#') {\n\ttile[i][j] = false;\n      } else if (c == '@') {\n\ttile[i][j] = true;\n\tX = i;\n\tY = j;\n      }\n    }\n  }\n}\n\nvoid count_tile() {\n  queue<pair<int,int>> Q; // 幅優先探索を使う。特に理由はないが、周辺から徐々に探査する感じになるのでイメージしやすい。\n  pair<int,int> cur = make_pair(X,Y);\n  Q.push(cur);\n  while (!Q.empty()) {\n    cur = Q.front();\n    Q.pop();\n    if (visited[cur.first][cur.second]) {\n      continue;\n    }\n    visited[cur.first][cur.second] = true;\n    answer++;\n    for (int i=0; i<4; i++) {\n      int a = cur.first+dx[i];\n      int b = cur.second+dy[i];\n      if (valid(a, b) && !visited[a][b]) {\n\tQ.push(make_pair(a, b));\n      }\n    }\n  }\n  printf(\"%d\\n\", answer);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &W, &H) && W && H) {\n    init();\n    make_tile();\n    count_tile();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint sum = 1;\nvoid solve(bool a[21][21], int i, int j,int n,int m) {\n\tif (i + 1 < n&&a[i + 1][j]) {\n\t\tsum++;\n\t\ta[i][j] = false;\n\t\tsolve(a,i+1,j, n, m);\n\t}\n\tif (i - 1 >= 0 && a[i - 1][j]) {\n\t\tsum++;\n\t\ta[i][j] = false;\n\t\tsolve(a, i-1, j, n, m);\n\t}\n\tif (j + 1 < m&&a[i][j + 1]) {\n\t\tsum++;\n\t\ta[i][j] = false;\n\t\tsolve(a, i, j+1, n, m);\n\t}\n\tif (j - 1 >= 0 && a[i][j - 1]) {\n\t\tsum++;\n\t\ta[i][j] = false;\n\t\tsolve(a, i, j-1, n, m);\n\t}\n}\nint main() {\n\tint n, m;\n\twhile (cin >> m >> n&&n != 0) {\n\t\tbool a[21][21];\n\t\tint b[2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring u;\n\t\t\tcin >> u;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (u[j] == '@') {\n\t\t\t\t\ta[i][j] = true;\n\t\t\t\t\tb[0] = i;\n\t\t\t\t\tb[1] = j;\n\t\t\t\t}\n\t\t\t\telse if (u[j] = '.')\n\t\t\t\t\ta[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\ta[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tsum = 1;\n\t\tsolve(a, b[0], b[1],n,m);\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H) {\n\t\tif (W == 0 && H == 0) return 0;\n\t\tvector<string> S(H);\n\t\tfor (int i = 0; i < H; i++) cin >> S[i];\n\t\tint SX, SY;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (S[i][j] == '@') SX = i, SY = j;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > Q;\n\t\tQ.push({ SX, SY });\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int> P = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint NX = P.first + dx[i], NY = P.second + dy[i];\n\t\t\t\tif (0 <= NX && NX < H && 0 <= NY && NY < W) {\n\t\t\t\t\tif (S[NX][NY] == '.') {\n\t\t\t\t\t\tS[NX][NY] = '@';\n\t\t\t\t\t\tQ.push({ NX, NY });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ANS = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (S[i][j] == '@') ANS++;\n\t\t\t}\n\t\t}\n\t\tcout << ANS << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint w,h;\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint dfs(vs &f, vvi &visited,int x,int y){\n\tint ret=1;\n\tvisited[y][x]=1;\n\tREP(i,4){\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\tif(xx>=0&&yy>=0&&xx<w&&yy<h){\n\t\t\tif(f[yy][xx]!='#'&&!visited[yy][xx]){\n\t\t\t\tret+=dfs(f,visited,xx,yy);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tvs f(h,string(w,' '));\n\t\tint sx,sy;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>f[i][j];\n\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\tsx=j;sy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvi visited(h,vi(w));\n\t\tcout<<dfs(f,visited,sx,sy)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main(void){\n    int h, w;\n    while (cin >> w >> h) {\n        if (h * w == 0) return 0;\n        \n        int on_h, on_c;\n        bool check[30][30] = {};\n        char s[30][30];\n        for (int i = 0; i < h; i++) {\n            cin >> s[i];\n            for (int j = 0; j < w; j++) {\n                if (s[i][j] == '@') {\n                    on_h = i;  on_c = j;\n                }\n                else if (s[i][j] == '.') check[i][j] = true;\n            }\n        }\n        \n        int ans = 1, dh[4] = {1, 0, -1, 0}, dc[4] = {0, 1, 0, -1};\n        queue<int> que_h, que_c;\n        que_h.push(on_h);\n        que_c.push(on_c);\n        \n        while (!que_h.empty()) {\n            int qh = que_h.front(), qc = que_c.front();\n            for (int i = 0; i < 4; i++) {\n                if (qh + dh[i] >= 0 && qh + dh[i] < h && qc + dc[i] >= 0 && qc + dc[i] < w \n                && check[qh + dh[i]][qc + dc[i]]) {\n                    ans++;\n                    check[qh + dh[i]][qc + dc[i]] = false;\n                    que_h.push(qh + dh[i]);\n                    que_c.push(qc + dc[i]);\n                }\n            }\n            que_h.pop();\n            que_c.pop();\n        }\n        \n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint W, H;\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {-1, 0, 1, 0};\nchar field[22][22];     // 1-origin\n\nint dfs(int y, int x)\n{\n  if (field[y][x] == '#') {\n    return 0;\n  }\n  \n  field[y][x] = '#';\n  int res = 1;\n  for (int k = 0; k < 4; k++) {\n    res += dfs(y + dy[k], x + dx[k]);\n  }\n\n  return res;\n}\n\nint main()\n{\n  // pre exec\n  for (int i = 0; i < 22; i++)\n    for (int j = 0; j < 22; j++) \n      field[i][j] = '#';\n\n  while (cin >> W >> H && (W && H)) {\n\n    // read\n    int sx = 1, sy = 1;\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n        cin >> field[i][j];\n        if (field[i][j] == '@') {\n          sx = j; sy = i;\n          field[i][j] = '*';\n        }\n      }\n    }\n\n    // depth first search\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nusing P = std::pair<int, int>;\n\n\nint main() {\n    int W, H;\n    while(cin >> W >> H, W) {\n        vector<vector<char>> tile(W, vector<char>(H));\n        vector<vector<int>> ret(W, vector<int>(H));\n        queue<P> que;\n        for(int i=0; i<H; ++i) {\n            for(int j=0; j<W; ++j) {\n                cin >> tile[j][i];\n                if(tile[j][i] == '@') {\n                    que.push(make_pair(j, i));\n                    ret[j][i] = 1;\n                }\n            }\n        }\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        while(!que.empty()) {\n            P p = que.front();\n            que.pop();\n            for(int i=0; i<4; ++i) {\n                int nx = p.first + dx[i];\n                int ny = p.second + dy[i];\n                if(nx >= 0 && nx < W && ny >= 0 && ny < H && tile[nx][ny] != '#' && ret[nx][ny] == 0) {\n                    ret[nx][ny] = ret[p.first][p.second] + 1;\n                    que.push(make_pair(nx, ny));\n                }\n            }\n        }\n        int ans = 0;\n        for(int i=0; i<H; ++i) {\n            for(int j=0; j<W; ++j) {\n                if(ret[j][i] != 0) {\n                    ans += 1;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> f;\nvoid init(){\n  f.clear();\n}\n\nint input(){\n  int w,h;\n  cin>>w>>h;\n  if(w==0&&h==0)return false;\n  string s;\n  for(int i=0;i<h;i++){\n    cin>>s;\n    f.push_back(s);\n  }\n  return true;\n}\n\nint vx[] = {0,0,1,-1};\nint vy[] = {1,-1,0,0};\n\nint rec(int x,int y){\n  if(f[x][y]!='.')return 0;\n  f[x][y]='#';\n  int res = 1;\n  for(int i=0;i<4;i++){\n    res += rec(x+vx[i],y+vy[i]);\n  }\n  return res;\n}\n\nint solve(){\n  int x,y;\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      if(f[i][j]=='@'){\n        x = i;\n        y = j;\n        f[i][j] = '.';\n      }\n    }\n  }\n  return rec(x,y);\n}\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\n\nvoid dfs(int x, int y) {\n    if (room[y][x] == 0) return;\n    \n    num++;\n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1 && room[y-1][x]) dfs(x, y-1);\n    if (y+1 < h && room[y-1][x]) dfs(x, y+1);\n    if (x-1 > -1 && room[y-1][x]) dfs(x-1, y);\n    if (x+1 < w && room[y-1][x]) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        \n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <string.h>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define FOR(i,s,e) for (int i = int(s); i != int(e); i++)\n#define REP(i,e) for (int i = 0; i != int(e); i++)\n#define FORIT(i, A) for (auto i : A)\n#define ISEQ(c) (c).begin(), (c).end()\n#define PRINT(x) cout << (x) << endl\n#define SZ(x) ((int)(x).size())\n\nint main(int argc, char const *argv[])\n{\n\tint w, h;\n\tchar world[21][21];\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0) break;\n\t\tint sx = -1, sy = -1;\n\t\tint memo[20][20];\n\t\tmemset(memo, 0, 20 * 20 * sizeof(int));\n\t\tREP(i, h)\n\t\t{\n\t\t\tscanf(\"%s\", world[i]);\n\t\t\tif (sx == -1)\n\t\t\t{\n\t\t\t\tREP(j, w)\n\t\t\t\t\tif (world[i][j] == '@')\n\t\t\t\t\t{\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::queue<std::pair<int, int> > q;\n\t\tq.push(std::make_pair(sx, sy));\n\t\tmemo[sy][sx] = 1;\n\t\tint area = 0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tstd::pair<int, int> p = q.front();\n\t\t\tq.pop();\n\t\t\tarea++;\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\t// left\n\t\t\tif (x > 0 && world[y][x-1] == '.' && memo[y][x-1] == 0)\n\t\t\t{\n\t\t\t\tmemo[y][x-1] = 1;\n\t\t\t\tq.push(make_pair(x-1, y));\n\t\t\t}\n\t\t\tif (x < (w-1) && world[y][x+1] == '.' && memo[y][x+1] == 0)\n\t\t\t{\n\t\t\t\tmemo[y][x+1] = 1;\n\t\t\t\tq.push(make_pair(x+1, y));\n\t\t\t}\n\t\t\t// up\n\t\t\tif (y > 0 && world[y-1][x] == '.' && memo[y-1][x] == 0)\n\t\t\t{\n\t\t\t\tmemo[y-1][x] = 1;\n\t\t\t\tq.push(make_pair(x, y-1));\n\t\t\t}\n\t\t\tif (y < (h-1) && world[y+1][x] == '.' && memo[y+1][x] == 0)\n\t\t\t{\n\t\t\t\tmemo[y+1][x] = 1;\n\t\t\t\tq.push(make_pair(x, y+1));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", area);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint W,H,result,up;\n\tchar c;\n\tint a[22][22];\n\twhile(1){\n\t\tfor(int i = 0;i <= 21;i++){\n\t\t\tfor(int j = 0;j <= 21;j++){\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tresult = 1;\n\t\tcin >> W >> H;\n\t\tif(W == 0)break;\n\t\tfor(int i = 1;i <= H;i++){\n\t\t\tfor(int j = 1;j <= W;j++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '.')a[i][j] = 1;\n\t\t\t\telse if(c == '@')a[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tup = 0;\n\t\tfor(int i = 1;i <= H;i++){\n\t\t\tfor(int j = 1;j <= W;j++){\n\t\t\t\tif(a[i][j] == 2 && a[i-1][j] == 1){\n\t\t\t\t\ta[i-1][j] = 2;\n\t\t\t\t\tup++;\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == 2 && a[i][j-1] == 1){\n\t\t\t\t\ta[i][j-1] = 2;\n\t\t\t\t\tup++;\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == 2 && a[i+1][j] == 1){\n\t\t\t\t\ta[i+1][j] = 2;\n\t\t\t\t\tup++;\n\t\t\t\t}\n\t\t\t\tif(a[i][j] == 2 && a[i][j+1] == 1){\n\t\t\t\t\ta[i][j+1] = 2;\n\t\t\t\t\tup++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult += up;\n\t\tif(up == 0)break;\t\n\t\t}\n\tcout << result <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n\nusing namespace std;\n\nint W,H;\n\nchar maze[22][22];\n\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint sy,sx;\n\nint DFS(int posy,int posx){\n\n    maze[posy][posx]='#';\n\n    int ret=1;\n    for(int i=0;i<4;i++){\n        int y,x;\n        y=posy+dy[i];\n        x=posx+dx[i];\n\n        if (y<1||y>H) continue;\n        if (x<1||x>W) continue;\n        if (maze[y][x]=='#') continue;\n\n\n        ret+=DFS(y,x);\n    }\n    return ret;\n}\n\nint main(){\n\n    while(scanf(\"%d%d\",&W,&H)&&W!=0&&H!=0){\n        getchar();\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                maze[i][j]=getchar();\n                if (maze[i][j]=='@') sy=i,sx=j;\n            }\n            getchar();\n        }\n\n        printf(\"%d\\n\",DFS(sy,sx));\n\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nint W, H;\nstring m[30];\nbool visit[30][30];\nconst int di[4] = {0,0,-1,1};\nconst int dj[4] = {1,-1,0,0};\n\nint dfs(const int ci, const int cj) {\n  int ret = 1;\n  for (int i = 0; i < 4; ++i) {\n    int ni = ci + di[i], nj = cj + dj[i];\n    if (ni < 0 || nj < 0 || H <= ni || W <= nj) continue;\n    if (m[ni][nj] == '#' || visit[ni][nj]) continue;\n    visit[ni][nj] = true;\n    ret += dfs(ni, nj);\n  }\n  return ret;\n}\n\nint solve() {\n  memset(visit, 0, sizeof visit);\n  int ret = 0;\n  for (int i = 0; i < H; ++i)\n    for (int j = 0; j < W; ++j)\n      if (m[i][j] == '@')\n        visit[i][j] = true , ret = dfs(i, j);\n  return ret;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  while (cin >> W >> H, W && H) {\n    for (int i = 0; i < H; ++i)\n      cin >> m[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t\tcout << tot << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    int si, sj;\n    vs m(h);\n    rep(i, h) {\n      cin >> m[i];\n      rep(j, m[i].size()) {\n        if (m[i][j] == '@') {\n          si = i;\n          sj = j;\n        }\n      }\n    }\n    int c = 0;\n    fn<void(int, int)> f = [&](int i, int j) {\n      if (i < 0 || j < 0 || i >= h || j >= w || m[i][j] == '#') return;\n      c++;\n      m[i][j]  = '#';\n      int di[] = {1, 0, -1, 0}, dj[] = {0, 1, 0, -1};\n      rep(k, 4) f(i + di[k], j + dj[k]);\n    };\n    f(si, sj);\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n\n#define FOR(i,k,n) for(int (i) = (k); (i) < (n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n\nusing namespace std;\ntypedef pair<int, int> i_i;\n\nint a,w,h;\nbool t[22][22],s[22][22];\n\nvoid dfs(i_i p) {\n    s[p.first][p.second] = 1;\n    a += 1;\n    rep(j,2){\n        if(t[p.first][p.second+(int)pow(-1,j)] && s[p.first][p.second+(int)pow(-1,j)] == 0) {\n            dfs(make_pair(p.first,p.second+(int)pow(-1,j)));\n        }\n    }\n    rep(i,2) {\n        if(t[p.first+(int)pow(-1,i)][p.second] && s[p.first+(int)pow(-1,i)][p.second] == 0) {\n            dfs(make_pair(p.first+(int)pow(-1,i),p.second));\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        i_i m;\n        scanf(\"%d %d\",&w,&h);\n        if(w == 0) break;\n        FOR(i,1,h+1){\n            char a[20];\n            scanf(\"%s\",a);\n            FOR(j,1,w+1) {\n                if(a[j-1] == '.') t[i][j] = 1; \n                if(a[j-1] == '@') m = make_pair(i,j);\n            }\n        }\n        dfs(m);\n        printf(\"%d\\n\",a);\n        a = 0;\n        rep(i,22) {\n            rep(j,22) {\n                t[i][j] = 0,s[i][j] =0;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <array>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint height, width;\nint sx, sy;\n\n\nvoid bfs(vector<vector<char>>& field)\n{\n    int ans = 1;\n    array<int, 4> dx = {0, 0, 1, -1};\n    array<int, 4> dy = {1, -1, 0, 0};\n\n    queue<pii> p;\n    p.push({sx, sy});\n    \n    while (!p.empty()) {\n        pii q = p.front(); p.pop();\n        \n        //??????\n        int cx = q.first;\n        int cy = q.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx.at(i);\n            int ny = cy + dy.at(i);\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height \n                    && field.at(ny).at(nx) == '.') {\n\n                ans++;\n                field.at(ny).at(nx) = '#';\n                p.push({nx, ny});\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\nint main()\n{\n    while (cin >> width >> height) {\n        if (height == 0 && width == 0) break;\n\n        vector<vector<char>> field(height, vector<char>(width));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                cin >> field.at(y).at(x);\n\n                if (field.at(y).at(x) == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n\n        bfs(field);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\n\nint W,H;\n\nchar r[1000][1000];\n\nint sh,sw;\nint bnum=0;\n\nint solve(int i,int j){\n    int ans=0;\n\n    if(i <0 || H <= i || j < 0 || W <= j)\n        return 0;\n    if(r[i][j] == '#'){\n        return 0;\n    }\n    ans = 1;\n    r[i][j] = '#';\n    ans += solve(i-1,j);\n    ans += solve(i+1,j);\n    ans += solve(i,j-1);\n    ans += solve(i,j+1);\n\n    return ans;\n}\n\n\nint main(){\n\n    while(1){\n        scanf(\"%d %d\",&W,&H);\n        if(W == 0 && H == 0) break;\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> r[i][j];\n                if(r[i][j] == '@'){\n                    sh = i;\n                    sw = j;\n                    r[i][j] = '.';\n                }\n            }\n        }\n        cout << solve(sh,sw) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n\tcout << tot <<endl;\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing std::cin;\nusing std::cout;\n\nint cnt = 0;\nchar map[21][21];\n\nvoid dfs(int x, int y, int mx, int my){\n    if((x < 0) || (x >= mx)){\n        return;\n    }\n    if((y < 0) || (y >= my)){\n        return;\n    }\n    if(map[x][y] == '#'){\n        return;\n    }\n    map[x][y] = '#';\n    cnt++;\n    dfs(x+1, y, mx, my);\n    dfs(x-1, y, mx, my);\n    dfs(x, y+1, mx, my);\n    dfs(x, y-1, mx, my);\n}\n\nint main(){\n    int W, H, sx, sy;\n    cin >> W >> H;\n\n    while(W != 0 && H != 0){\n        for(int i = 0; i < H; i++){\n            scanf(\"%20s\", map[i]);\n            if(std::string(map[i]).find('@') != std::string::npos){\n                sx = i;\n                sy = std::string(map[i]).find('@');\n            }\n        }\n        dfs(sx, sy, H, W);\n        cout << cnt << std::endl;\n\n        cin >> W >> H;\n        cnt = 0;\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n#define WH 22\n\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nint main(int argc, char const *argv[])\n{\n\tint w,h;\n\tchar f[WH][WH];\n\n\tchar c;\n\tint cnt;\n\n\tint x,y;\n\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w+h==0) break;\n\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tf[i1][i2]='#';\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int,int> > q;\n\t\tcnt=1;\n\n\t\tfor(int i1=1;i1<=h;i1++){\n\t\t\tfor(int i2=1;i2<=w;i2++){\n\t\t\t\tcin>>f[i1][i2];\n\t\t\t\tif(f[i1][i2]=='@'){\n\t\t\t\t\tx=i2;\n\t\t\t\t\ty=i1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tq.push(make_pair(x,y));\n\t\twhile(!q.empty()){\n\t\t\tx=q.front().first;\n\t\t\ty=q.front().second;\n\t\t\tq.pop();\n\n\t\t\tfor(int i1=0;i1<4;i1++){\n\t\t\t\tif(f[y+dy[i1]][x+dx[i1]]=='.') {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tq.push(make_pair(x+dx[i1],y+dy[i1]));\n\t\t\t\t\tf[y+dy[i1]][x+dx[i1]]='@';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <utility>\n#include <unordered_set>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h && w > 0 && h > 0){\n        string tmp;\n        pair<int, int> init;\n        vector<vector <int> > grid(25, vector<int>(25, -1));\n        vector<vector <int> > visited(25, vector<int>(25, 0));\n        for(int i = 0; i < h; i++){\n            cin >> tmp;\n            for (int j = 0; j < w; j++){\n                if(tmp[j] == '.'){\n                    grid[i][j] = 0;\n                }else if(tmp[j] == '#'){\n                    grid[i][j] = -1;\n                }else if(tmp[j] == '@'){\n                    grid[i][j] = 0;\n                    init = make_pair(i, j);\n                }\n            }\n        }\n        /*for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                if(grid[i][j] == 0){\n                    if(i == init.first && j == init.second){\n                        cout << \"@\";\n                    }else{\n                        cout << \".\";\n                    }\n                }else if(grid[i][j] == -1){\n                    cout << \"#\";\n                }\n            }\n            cout << endl;\n        }\n        */\n        queue<pair<int, int> > Q;\n        Q.push(init);\n        visited[init.first][init.second] = 1; \n        while(!Q.empty()){\n            pair<int, int> cur = Q.front(); \n            Q.pop();\n            int cur_x = cur.first;\n            int cur_y = cur.second;\n            for(int i = 0; i < 4; i++){\n                pair<int, int> dst = make_pair(cur_x + dx[i], cur_y + dy[i]);\n                int x = dst.first;\n                int y = dst.second;\n                if(0 <= x && 0 <= y && grid[x][y] == 0 && visited[x][y] == 0){\n                    Q.push(dst);\n                    visited[x][y] = 1;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                ans += visited[i][j];\n            }\n        }\n        cout << ans << endl << endl << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h, w;\n\nint main (void){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(!h&&!w)break;\n\t\tvector<string> s(h);\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tqueue<pair<int, int>> q;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tq.push(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dx[] = {0,1,0,-1};\n\t\tint dy[] = {1,0,-1,0};\n\t\tint cnt = 1;\n\t\twhile(!q.empty()){\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif(nx<0||nx>=h||ny<0||ny>=w) continue;\n\t\t\t\tif(s[nx][ny]=='.'){\n\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\ts[nx][ny] = '!';\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n\ntypedef long long ll;\n\nint w,h;\nint a[20][20];\nint dx[4] = {1,-1,0,0} , dy[4] = {0,0,1,-1};\nint ans;\n\nvoid dfs(int i , int j){\n    a[i][j]=0;\n    ans++;\n    REP(k,4){\n        int ii=i+dx[k] , jj=j+dy[k];\n        if (ii>=0 && ii<h && jj>=0 && jj<w && a[ii][jj]){\n            dfs(ii,jj);\n        }\n    }\n}\n\nint main(void) {\n    while (cin>>w>>h && w){\n        int x , y;\n        REP(i,h){\n            REP(j,w){\n                char c;\n                cin >> c;\n                if (c=='.')\n                    a[i][j]=1;\n                else if (c=='#')\n                    a[i][j]=0;\n                else{\n                    a[i][j]=1;\n                    x=i;\n                    y=j;\n                }\n            }\n        }\n        ans = 0;\n        dfs(x,y);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nconst int dy[] = {1, -1, 0, 0};\nconst int dx[] = {0, 0, 1, -1};\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) {}\n  bool merge(int x, int y){\n    x = root(x), y = root(y);\n    if (x != y){\n      if (data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n    return x != y;\n  }\n  bool isSame(int x, int y){\n    return root(x) != root(y);\n  }\n  int size(int x){\n    return -data[root(x)];\n  }\n  int root(int x){\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n};\n\nint main()\n{\n  int w, h;\n  while (w = in(), h = in(), w){\n    UnionFind uf(w * h);\n    vector<string> field;\n    rep(i, h){\n      string s;\n      cin >> s;\n      field.push_back(s);\n    }\n    int sx, sy;\n    rep(y, h){\n      rep(x, w){\n        char cell = field[y][x];\n        if (cell == '#') continue;\n        if (cell == '@') {\n          sx = x;\n          sy = y;\n        }\n        rep(d, 4){\n          int nx = x + dx[d];\n          int ny = y + dy[d];\n          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n          if (field[ny][nx] != '#') uf.merge(y * w + x, ny * w + nx);\n        }\n      }\n    }\n    printf(\"%d\\n\", uf.size(sy * w + sx));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nchar table[20][20];\nint n,m,si,sj;\nint solve(int a,int b){\n\tint xx[]={a,a+1,a,a-1},yy[]={a+1,a,a-1,a},res=1;\n\tif(table[a][b]!='.')return 0;\n\ttable[a][b]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif(xx[i]<0 || xx[i]>=m || yy[i]<0 || yy[i]>=n)continue;\n\t\tres+=solve(xx[i],yy[i]);\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\" %c\",&table[i][j]);\n\t\t\tif(table[i][j]=='@')si=i,sj=j,table[i][j]='.';\n\t\t}\t\n\t}\n\tprintf(\"%d\\n\",solve(si,sj));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nint w, h;\nchar t[20][20];\nvoid dfs(int i, int j) {\n\tt[i][j] = '*';\n\tfor (int di = -1; di <= 1;di++) {\n\t\t\tfor (int dj = -1;dj <= 1;dj++) {\n\t\t\t\tint ni = i + di;\n\t\t\t\tint nj = j + dj;\n\t\t\t\tif (di!=dj && di+dj!=0 && ni >= 0 && ni < h&&nj >= 0 && nj < w&&t[ni][nj] == '.') {\n\t\t\t\t\tdfs(ni, nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn;\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tvector<int>ans;\n\twhile (1) {\n\n\t\tcin >> w >> h;\n\t\tif (w == 0)break;\n\t\trep(i, h) {\n\t\t\trep(j,w) {\n\t\t\t\tcin >> t[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (t[i][j] == '@') {\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (t[i][j] == '*') {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(count);\n\t}\n\trep(i, ans.size()) {\n\t\tcout << ans[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint vis[25][25];\n\nvoid inti(){\n  for(int i=0;i<25;i++){\n    for(int j=0;j<25;j++){\n      vis[i][j]=0;\n    }\n  }\n}\n\nvoid dfs(int i,int j){\n  if(vis[i][j]==0 || vis[i][j]==2)return;\n  vis[i][j]=0;\n\n    dfs(i-1,j);\n    dfs(i,j-1);\n    dfs(i,j+1);\n    dfs(i+1,j);\n}\n\nint main(){\n  int w,h;\n  int i,j;\n  char ch;\n  int cnt;\n\n  while(1){\n    inti();\n    cnt=0;\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tcin >> ch;\n\tif(ch=='.'){\n\t  vis[i][j]=1;\n\t}else if(ch=='#'){\n\t  vis[i][j]=2;\n\t}else{\n\t  vis[i][j]=5;\n\t}\n      }\n    }\n     for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(vis[i][j]==5)dfs(i,j);\n      }\n     }\n      for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(vis[i][j]==0)cnt++;\n      }\n     }\n      cout << cnt << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <array>\n\nusing namespace std;\n\n\ntypedef std::array<uint32_t, 2> Idx;\n\n\nuint32_t checkAndSetIdx(vector<string>& mp, vector<Idx>& stack, uint32_t i, uint32_t j)\n{\n    if(i > mp.size()-1 || j > mp.at(0).size()-1)\n        return 0;\n\n    if(mp[i][j] == '.'){\n        mp[i][j] = 'x';\n        stack.push_back(Idx({i, j}));\n        return 1;\n    }\n\n    return 0;\n}\n\n\nint main()\n{\n    while(1)\n    {\n        uint32_t h, w;\n        cin >> w >> h;\n\n        if(w == 0 && h == 0)\n            break;\n\n\n        Idx iniPos;\n\n        vector<string> mp;\n        for(uint32_t i = 0; i < h; ++i){\n            mp.push_back([](){string str; cin >> str; return str;}());\n\n            for(uint32_t j = 0; j < w; ++j){\n                if(mp[i][j] == '@'){\n                    iniPos = Idx({i, j});\n                    mp[i][j] = 'x';\n                }\n            }\n        }\n\n\n        vector<Idx> stack;\n        stack.push_back(iniPos);\n        uint32_t cnt = 1;\n\n\n        while(stack.size() != 0){\n            auto nowPos = stack.at(stack.size() - 1);\n            stack.pop_back();\n            const auto i = nowPos[0],\n                       j = nowPos[1];\n\n            cnt += checkAndSetIdx(mp, stack, i+1, j);\n            cnt += checkAndSetIdx(mp, stack, i-1, j);\n            cnt += checkAndSetIdx(mp, stack, i, j+1);\n            cnt += checkAndSetIdx(mp, stack, i, j-1);\n        }\n\n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n//#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n//#include <stack>\n//#include <limits>\n#include <sstream>\n//#include <functional>\nusing namespace std;\n\n#define len(array)  (sizeof (array) / sizeof *(array))\n#define rep(i, s, e) for(int i = s;i < e;i++)\n#define rrep(i, e, s) for(int i = e;s <= i;i--)\n#define vrange(v) v.begin(), v.end()\n#define vrrange(v) v.rbegin(), v.rend()\n#define vsort(v) sort(vrange(v))\n#define vrsort(v) sort(vrrange(v))\n#define arange(a) a, a + len(a)\n#define asort(a) sort(arange(a))\n#define arsort(a, t) sort(arange(a), greater<t>())\n#define afill(a, v) fill(arange(a), v)\n#define afill2(a, v, t) fill((t *)a, (t *)(a + len(a)), v)\n#define fmax(a, b) (a < b? b : a)\n#define fmin(a, b) (a > b? b : a)\n#define fabs(a) (a < 0? -a : a)\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-10;\nconst int dx[] = {1, -1, 0, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 0, 1, -1, -1, -1, 1, 1};\n//const int weight[] = {0,1,10,100,1000,10000,100000,1000000,10000000};\n//priority_queue< int, vector<int>, greater<int> > q;\n\nvoid doIt(){\n\tint w, h, sx, sy;\n\tstring f[21];\n\tbool visited[21][21];\n\tqueue<P> q;\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w + h == 0) break;\n\t\trep(i, 0, h){\n\t\t\tcin >> f[i];\n\t\t}\n\t\tafill2(visited, false, bool);\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\tif(f[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push(P(sy, sx));\n\t\twhile(!q.empty()){\n\t\t\tP e = q.front();\n\t\t\tint yy = e.first, xx = e.second;\n\t\t\t// cout << xx << \", \" << yy << endl;\n\t\t\tq.pop();\n\t\t\tif(0 <= yy && yy < h && 0 <= xx && xx < w && visited[yy][xx] == false){\n\t\t\t\tvisited[yy][xx] = true;\n\t\t\t\t// cout << xx << \", \" << yy << endl;\n\t\t\t\tif(f[yy][xx] == '@' || f[yy][xx] == '.' ){\n\t\t\t\t\trep(i, 0, 4){\n\t\t\t\t\t\tq.push(P(yy + dy[i], xx + dx[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\tif(visited[i][j] && f[i][j] == '.'){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans + 1 << endl;\n\n\t}\t\n\n}\n\nint main() {\n\tdoIt();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(){\nwhile(true){\n        int w,h;\n        cin >>w >>h;\n        if(w==0&&h==0)break;\n        char map[w][h];\n        bool is_reached[w][h];\n        queue<pair<int,int> >recentpos;\n        int ans =0;\n        for(int j =0;j<h;++j){\n                for(int i = 0;i<w;++i){\n                        char temp;\n                        cin >>temp;\n                        map[i][j]=temp;\n                        is_reached[i][j]=false;\n                        if(temp=='@'){\n                                recentpos.push(pair<int,int>(i,j));\n                                is_reached[i][j]=true;\n                                ans++;\n                      }\n                }\n        }\n        while(!recentpos.empty()){\n                int old_x=recentpos.front().first;\n                int old_y=recentpos.front().second;\n                recentpos.pop();\n                for(int dx =-1;dx<2;dx++){\n                        for(int dy=-1;dy<2;dy++){\n                                if(dx*dy!=0)continue;\n                                int x=old_x+dx;\n                                int y=old_y+dy;\n                                if(x<0||x>=w||y<0||y>=h)continue;\n                                if(is_reached[x][y]||map[x][y]=='#')continue;\n                                recentpos.push(pair<int,int>(x,y));\n                                is_reached[x][y]=true;\n                                ans++;\n                        }\n                }\n        }\n        cout<<ans<<'\\n';\n        }\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint ans;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\nvoid move(int x,int y){\n\tans++;\n\tmap[x][y]='#';\n\tfor(int i=0;i<4;i++){\n\t\tif((x+vec[i][0]>=0)&&(y+vec[i][1]>=0)&&(x+vec[i][0]<h)&&(y+vec[i][1]<w)){\n\t\t\tif(map[x+vec[i][0]][y+vec[i][1]]=='.'){\n\t\t\t\tmove(x+vec[i][0],y+vec[i][1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tans=0;\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmove(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp*/\n\n#include <iostream>\n\nusing namespace std;\n\nstruct point{\n    int x;\n    int y;\n};\n\nchar map[20][21];\n\nint move(const struct point p,int h,int w){\n    int count=1;\n    map[p.x][p.y]='/';\n    for (int i = 0; i < 4; ++i) {\n        struct point tmp=p;\n\n        switch (i){\n            case 0:\n                tmp.x++;\n                break;\n            case 1:\n                tmp.x--;\n                break;\n            case 2:\n                tmp.y++;\n                break;\n            case 3:\n                tmp.y--;\n                break;\n            default:\n                break;\n        }\n        if (tmp.x<w && tmp.y<h && map[tmp.x][tmp.y]=='.') {\n            count+=move(tmp,h,w);\n        }\n    }\n    return count;\n}\n\nint main(){\n    int w,h;\n\n    while (cin>>w>>h && (w>0 || h>0)){\n        struct point start;\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin>>map[j][i];\n                if(map[j][i]=='@'){\n                    start.x=j;\n                    start.y=i;\n                }\n            }\n        }\n        cout<<move(start,h,w)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y, int x, vector<string> &g){\n  if(g[y][x] == '.')return 0;\n  g[y][x] = '.';\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=(int)g.size() || nx>=(int)g[0].size())continue;\n    res += dfs(ny,nx,g);\n  }\n  return res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n\n    vector<string> g(h);\n    int y=0,x=0;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == '@')y = i, x = j;\n      }\n    }\n\n    cout << dfs(y,x,g) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[22][22] = {} ;\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  int vx[4]={1,0,-1,0};\n  int vy[4]={0,-1,0,1};\n  while(cin>>w>>h,h+w){\n    string str[h];\n    for(int i=0;i<h;i++)cin>>str[i];\n    bool Map[h][w];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tMap[i][j]=false;\n    queue<pair<int,int> >que;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(str[i][j]=='@'){\n\t  que.push(mp(i,j));\n\t  Map[i][j]=true;\n\t}\n      }\n    }\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      //cout<<now.F<<\" \"<<now.S<<endl;\n      for(int i=0;i<4;i++){\n\tif(now.S+vy[i]>=0&&now.S+vy[i]<w&&now.F+vx[i]>=0&&now.F+vx[i]<h&&(!Map[now.F+vx[i]][now.S+vy[i]])&&str[now.F+vx[i]][now.S+vy[i]]=='.'){\n\t  Map[now.F+vx[i]][now.S+vy[i]]=true;\n\t  que.push(mp(now.F+vx[i],now.S+vy[i]));\n\t}\n      }\n    }\n    ll ans=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(Map[i][j])\n\t  ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint W,H,map[20][20];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nvoid dfs(int x,int y) {\n\tmap[x][y]=0;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<W&&0<=ny&&ny<H&&map[nx][ny]=='.') dfs(nx,ny);\n\t}\n}\n\nint main() {\n\tint x,y;\n\twhile(scanf(\"%d %d\",&W,&H),W||H) {\n\t\tgetchar();\n\t\tfor(int j=0;j<H;j++) {\n\t\t\tfor(int i=0;i<W;i++) {\n\t\t\t\tmap[i][j]=getchar();\n\t\t\t\tif(map[i][j]=='@') {\n\t\t\t\t\tmap[i][j]='.';\n\t\t\t\t\tx=i,y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tdfs(x,y);\n\t\tint ans=0;\n\t\tfor(int j=0;j<H;j++) {\n\t\t\tfor(int i=0;i<W;i++) {\n\t\t\t\tans+=!map[i][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\nint w, h;\nbool b[20][20];\nbool ok[20][20];\n\nchar dx[] = {-1, 1, 0, 0};\nchar dy[] = {0, 0, -1, 1};\n\nvoid dfs(int x, int y){\n\tfor(int i=0;i<4;i++){\n\t\tif(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h){\n\t\t\tif(!b[y+dy[i]][x+dx[i]]) continue;\n\t\t\tif(ok[y+dy[i]][x+dx[i]]) continue;\n\t\t\tok[y+dy[i]][x+dx[i]] = true;\n\t\t\tdfs(x+dx[i],y+dy[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(!w) break;\n\t\tint x, y;\n\t\tstring s;\n\t\tmemset(b,false,sizeof(b));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >> s;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tb[i][j] = (s[j] !='#');\n\t\t\t\tif(s[j]=='@') x = j, y = i;\n\t\t\t}\n\t\t}\n\t\tmemset(ok,false,sizeof(ok));\n\t\tok[y][x] = true;\n\t\tdfs(x,y);\n\t\tint count = 0;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tcount += ok[i][j];\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\n#define rep(i, a) for (int (i) = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int (i) = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int (i) = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int (i) = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\nint W, H;\nbool m[20][20];\nbool hou[20][20];\n\nint dfs(int r, int c)\n{\n\tif (r < 0 || c < 0 || r >= H || c >= W) return 0;\n\tif (hou[r][c] || !m[r][c]) return 0;\n\thou[r][c] = true;\n\tint res = 1;\n\tint dr[] = {-1, 0, 0, 1};\n\tint dc[] = { 0,-1, 1, 0};\n\trep(i, 4) res += dfs(r+dr[i], c+dc[i]);\n\treturn res;\n}\n\nsigned main()\n{\n\tcin >> W >> H;\n\twhile (W) {\n\t\tint r=0, c=0;\n\t\trep(i, H) rep(j, W) {\n\t\t\tCIN(char, t);\n\t\t\tif (t == '#') m[i][j] = false;\n\t\t\telse {\n\t\t\t\tm[i][j] = true;\n\t\t\t\tif (t == '@') {\n\t\t\t\t\tr = i;\n\t\t\t\t\tc = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(r, c) << endl;\n\t\tcin >> W >> H;\n\t\trep(i, 20) rep(j, 20) hou[i][j] = false;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define LOOP(i, a, n) for (int i = (int)a; i < (int)n; ++i)\n#define REP(i, n) LOOP(i, 0, n)\n#define MOD 1000000007\n#define INF 1000000000\n#define PI 3.14159265359\n#define MAX_H 20\n#define MAX_W 20\n\nint dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0}, w, h, ans = 0;\nstring board[MAX_H];\n\nint dfs(int x, int y) {\n  if (board[y][x] == '#') {\n    return 0;\n  } else {\n    ans++;\n    board[y][x] = '#';\n  }\n\n  for (int i = 0; i < 4; i++) {\n    int nextx = x + dx[i], nexty = y + dy[i];\n    if (nextx >= w || nextx < 0 || nexty >= h || nexty < 0)\n      continue;\n    dfs(x + dx[i], y + dy[i]);\n  }\n\n  return ans;\n}\n\nint main(void) {\n  vector<int> ret;\n  while (true) {\n    ans = 0;\n    scanf(\"%d %d\", &w, &h);\n    if (w == 0 && h == 0)\n      break;\n    for (int i = 0; i < h; i++)\n      cin >> board[i];\n\n    int sx = 0, sy = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (board[i][j] == '@') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n\n    dfs(sx, sy);\n    ret.push_back(ans);\n  }\n\n  for (int i = 0; i < ret.size(); i++) {\n    cout << ret[i] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tint w,h;// =<20\n\tchar map[20][20];\n\tint res[20][20]={};\n\tint result=0;\n\tint x,y;\n\tint start;// xxyy\n\tint stage;\n\tint check;\n\tint finish=0;\n\t\n\tscanf(\"%d%d\",&w,&h);\n\twhile(finish==0){\n\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y]=='@'){start=x*100+y;}\n\t\t}\n\t}\n\t\n\tx=start/100;\n\ty=start%100;\n\tres[x][y]=1;\n\tstage=1;\n\tcheck=1;\n\twhile(check==1){\n\t\tcheck=0;\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tif(res[x][y]==stage){\n\t\t\t\t\tif(x>0){\n\t\t\t\t\t\tif((map[x-1][y]=='.')&&(res[x-1][y]==0)){res[x-1][y]=stage+1;check=1;}\n\t\t\t\t\t}\n\t\t\t\t\tif(y>0){\n\t\t\t\t\t\tif((map[x][y-1]=='.')&&(res[x][y-1]==0)){res[x][y-1]=stage+1;check=1;}\n\t\t\t\t\t}\n\t\t\t\t\tif(x<w-1){\n\t\t\t\t\t\tif((map[x+1][y]=='.')&&(res[x+1][y]==0)){res[x+1][y]=stage+1;check=1;}\n\t\t\t\t\t}\n\t\t\t\t\tif(y<h-1){\n\t\t\t\t\t\tif((map[x][y+1]=='.')&&(res[x][y+1]==0)){res[x][y+1]=stage+1;check=1;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstage+=1;\n\t}\n\n\tresult=0;\n\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tif(res[x][y]!=0){result+=1;}\n\t\t}\n\t}\n\tcout << result << endl;\n\n\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tmap[x][y]=0;\n\t\t\tres[x][y]=0;\n\t\t}\n\t}\n\n\tscanf(\"%d%d\",&w,&h);\n\tif((w==0)&&(h==0)){\n\t\tfinish=1;\n\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring place[20];\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},n,m;\nint serch(int y,int x)\n{\n\tint ans=1;\n\tplace[y][x]='#';\n\tfor(int i=0,ax,ay;i<4;i++)if((ay=dy[i]+y)<m&&(ax=dx[i]+x)<n&&ay>=0&&ax>=0&&place[ay][ax]=='.')ans+=serch(ay,ax);\n\treturn ans;\n}\n\nint main() {\n\twhile(cin>>n>>m,n,m){\n\t\tfor(int i=0;i<m;i++)cin>>place[i];\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++)if(place[i][j]=='@')cout<<serch(i,j)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint cor2Idx(const int i, const int j, const int width)\n{\n    return i * width + j;\n}\n\nvoid idx2Cor(const int idx, int &i, int &j, const int width)\n{\n    i = idx / width;\n    j = idx % width;\n}\n\nbool isRange(const int i, const int j, const int w, const int h)\n{\n    return i >= 0 && i < h && j >= 0 && j < w;\n}\n\nvoid refine(vector<char> &v, const int i, const int j, const int w, const int h, int &ans)\n{\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n\n    for (int k = 0; k < 4; k++)\n    {\n        if (!isRange(i + dx[k], j + dy[k], w, h))\n            continue;\n        int idx = cor2Idx(i + dx[k], j + dy[k], w);\n        if (v[idx] == '-' || v[idx] == '#')\n            continue;\n        else if (v[idx] == '.')\n        {\n            v[idx] = '-';\n            ans++;\n            refine(v, i + dx[k], j + dy[k], w, h, ans);\n        }\n    }\n}\n\nint main()\n{\n    while (true)\n    {\n        int w;\n        scanf(\"%d\", &w);\n        int h;\n        scanf(\"%d\", &h);\n\n        if (w == 0 && h == 0)\n            break;\n\n        int si, sj;\n        vector<char> v(w * h);\n        for (int i = 0; i < w * h; i++)\n        {\n            char buf;\n            scanf(\"%c\", &buf);\n            if (buf == '\\n')\n                i--;\n            else\n            {\n                v[i] = buf;\n                if (buf == '@')\n                    idx2Cor(i, si, sj, w);\n            }\n        }\n\n        int ans = 1;\n        refine(v, si, sj, w, h, ans);\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint cnt, a[23][23];  //black : 0, red : 1\n\nvoid dfs(int x, int y){\n    cnt++;\n    a[x][y] = 1;\n    if(!a[x + 1][y]) dfs(x + 1, y);\n    if(!a[x - 1][y]) dfs(x - 1, y);\n    if(!a[x][y + 1]) dfs(x, y + 1);\n    if(!a[x][y - 1]) dfs(x, y - 1);\n    return;\n}\n\nint main(){\n    while(1){\n        int i, j, w, h, si, sj;\n        char in;\n        cin >> w >> h;\n        if(w == 0)break;\n        \n        cnt = 0;\n        for(i = 0; i <= h + 1; i++){\n            a[i][0] = a[i][w + 1] = 1;\n        }\n        for(j = 0; j <= w + 1; j++){\n            a[0][j] = a[h + 1][j] = 1;\n        }\n       \n        i = 1;\n        j = 1;\n        while(i <= h){\n            while(j <= w){\n                cin >> in;\n                //cout << \"~~\" << endl;\n                if(in == '.'){\n                   a[i][j] = 0;\n                   j++; \n                }else if(in == '#'){\n                    a[i][j] = 1;\n                    j++;\n                }else if(in == '@'){\n                    si = i;\n                    sj = j;\n                    a[i][j] = 1;\n                    j++;\n                }\n                //cout << j << endl;\n            \n            \n            \n            }\n            i++;\n            j = 1;\n        }\n        dfs(si, sj);\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint count;\nint w,h;\nint x,y;\nchar map[20][20];\n\nvoid tannkenn(int x,int y);\n\nint main()\n{\n\tcin>>w>>h;\n\tcount=0;\n\tfor(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> map[i][j];\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\ttannkenn(x,y);\n\tcout<<count<<endl;\n\n\treturn 0;\n}\n\nvoid tannkenn(int x,int y)\n{\n\tcount++;\n\tmap[x][y]='#';\n\n\tif(x+1<h && map[x+1][y]=='.')\n\t\ttannkenn(x+1,y);\n\tif(y+1<w && map[x][y+1]=='.')\n\t\ttannkenn(x,y+1);\n\tif(x-1>=0 && map[x-1][y]=='.')\n\t\ttannkenn(x-1,y);\n\tif(y-1>=0 && map[x][y-1]=='.')\n\t\ttannkenn(x,y-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nint W, H;\nint ans;\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == W || y == H) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tans = 0;\n\t\trep(i, H) cin >> field[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (field[i][j] == '@') dfs(i, j);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n#define all(n) n.begin(),n.end()\n\nconst int MAXW = 25, MAXH = 25;\nconst char B = '.', R = '#';\nchar tile[MAXW][MAXH];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint solve(int x, int y)\n{\n    int ans = 1;\n\n    REP(4)if(tile[x + dx[i]][y + dy[i]] == B)\n    {\n        tile[x + dx[i]][y + dy[i]] = R;\n        ans += solve(x + dx[i], y + dy[i]);\n    }\n\n    return ans;\n}\n\nint main()\n{\n    int w, h;\n    while(cin >> w >> h && ( w || h))\n    {\n        memset(tile, R, sizeof(tile));\n\n        int x, y; char t;\n        rep(j, h)rep(i, w)\n        {\n            cin >> tile[i + 1][j + 1];\n            if(tile[i + 1][j + 1] == '@'){ x = i + 1; y = j + 1; tile[i + 1][j + 1] = R;}\n        }\n            cout << solve(x, y) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nbool used[20][20];\nint W, H;\n \nvoid rec(int i, int j){\n   used[i][j]=1;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if((0<=ni&&ni<H&&0<=nj&&nj<W)&&fld[ni][nj]!='#'&&used[ni][nj]==0){\n         rec(ni, nj);\n      }\n   }\n}\n \nint main(){\n \n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n \n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=0;\n      used[sy][sx]=1;\n      rec(sy, sx);\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=used[i][j];\n      }\n      cout<< ans<< endl;\n \n   }\n \n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\ntypedef long long ll;\nconst int INF = 100000000;\nconst int MOD = 1000000007;\nint cou=0;\nvoid dfs(int x,int y,int a,int b,vector<vector<char> > &v){\n  v[x][y]='#';\n  cou++;\n  \n  int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};\n  for (int i = 0; i < 4; i++) {\n    /* code */\n    int nx=x+dx[i],ny=y+dy[i];\n    if(0<=nx&&nx<a&&0<=ny&&ny<b&&v[nx][ny]=='.')dfs(nx,ny,a,b,v);\n  }\n}\nint main(){\n  for (;;) {\n    int a,b;\n    cou=0;\n    std::cin >> a>>b;\n    if(a==0&&b==0)exit(0);\n    vector<vector<char> > v(a,vector<char>(b));\n    int s1,s2;\n     rep(j,b){\n      rep(i,a){\n        std::cin >> v[i][j];\n        if(v[i][j]=='@'){s1=i;s2=j;}\n      }\n    }\n    dfs(s1,s2,a,b,v);\n    /* code */\n    std::cout << cou << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint W, H;\nvector<string> map;\nint ans;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = { 0,-1, 0, 1};\n\nvoid dfs(int x, int y) {\n\tmap[y][x] = '*';\n\tans++;\n\t\n\tfor (int d=0; d<4; d++) {\n\t\tif (!(0 <= y + dy[d] && y + dy[d] < H && 0 <= x + dx[d] && x + dx[d] < W)) continue;\n\t\tif (map[ y + dy[d] ][ x + dx[d] ] == '.') {\n\t\t\tdfs(x + dx[d], y + dy[d]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H; if (W == 0 && H == 0) break;\n\t\tmap.assign(H, \"\");\n\t\t\n\t\tint sx, sy;\n\t\tfor (int i=0; i<H; i++) {\n\t\t\tcin >> map[i];\n\t\t\tfor (int j=0; j<W; j++) if (map[i][j] == '@') { sx = j; sy = i; }\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tdfs(sx, sy);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define REP(i,a) for(int i=0;i<(a);i++)\n#define MOD 1000000007\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nchar a[21][21];\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint count;\n\nint W, H;\n\nvoid dfs(int x, int y)\n{\n    a[x][y] = 0;\n    for (int i = 0; i < 4; i++)\n    {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < H && 0 <= ny && ny < W && a[nx][ny] == '.')\n        {\n            count++;\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main()\n{\n    while (cin >> W >> H, W && H)\n    {\n        count = 1;\n        for (int i = 0; i < H; i++)\n        {\n            cin >> a[i];\n        }\n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if (a[i][j] == '@')\n                {\n                    dfs(i, j);\n                    break;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 1000\n#define EMPTY 10000\n\ntypedef struct queue\n{\n    int data[N];\n    int left;\n    int right;\n} Queue;\n\nvoid initialize(Queue *queue)\n{\n    int i;\n\n    queue->left = 0;\n    queue->right = 0;\n    for (i = 0; i < N; ++i)\n    {\n        queue->data[i] = 0;\n    }\n}\nvoid enqueue(Queue *queue, int num)\n{\n    queue->right = (queue->right + 1) % N;\n    if (queue->left == queue->right)\n    {\n        //printf(\"Full!!\\n\");\n    }\n    else queue->data[queue->right] = num;\n}\nint dequeue(Queue *queue)\n{\n    if (queue->left == queue->right)\n    {\n        //printf(\"Empty!!\\n\");\n        return EMPTY;\n    }\n    queue->left = (queue->left + 1) % N;\n    return queue->data[queue->left];\n}\n\nint main(){\n\n    int x, y, W, H,i;\n    char area[22][22];\n    Queue queue;\n    int count,next,position,flag;\n    int direction[4];\n\n    while(1)\n    {\n        scanf(\"%d %d\", &W, &H);\n        //printf(\"%d %d\\n\", H, W);\n        if(W==0&&H==0){\n            //getchar();\n            //putchar('$');\n            return 0;\n        }\n        direction[0] = -(W + 1); //上\n        direction[1] = 1;        //右\n        direction[2] = W + 1;    //下\n        direction[3] = -1;       //左\n        for (y = 0; y < 22; y++)\n        {\n            for (x = 0; x < 22; x++)\n            {\n                area[y][x]='#';\n            }\n        }\n        for (y = 0; y < H; y++)\n        {\n            scanf(\"%s\", area[y]);\n        }\n        flag = 0;\n        for (y = 0; y < H; y++)\n        {\n            for (x = 0; x < W + 1; x++)\n            {\n                if (area[y][x] == '@')\n                {\n                    flag = 1;\n                    break;\n                }\n                /*\n                    printf(\"%c\", area[y][x]); \n                 */\n            }\n            if(flag)break;\n        }\n        //printf(\"%d %d\\n\", x, y);\n        initialize(&queue);\n        //enqueue(&queue, (W + 1) * y + x);\n        position = (W + 1) * y + x;\n        //printf(\"#%d\\n\", position);\n\n        count = 0;\n        while(position!=EMPTY)\n        {\n            for (i = 0; i < 4;i++)\n            {\n                next = position + direction[i];\n                x = next % (W + 1);\n                y = (next - x) / (W + 1);\n                if(area[y][x]=='.'){\n                    area[y][x] = 'a';\n                    enqueue(&queue,next);\n                    count++;    \n                    //printf(\"#%d %d\\n\",x,y);\n                }\n            }/*\n            for (y = 0; y < H; y++)\n            {\n                for (x = 0; x < W + 1; x++)\n                {\n                    printf(\"%c\", area[y][x]);\n                }\n            }\n            printf(\"\\n\");\n             */\n            position = dequeue(&queue);\n        }\n        printf(\"%d\\n\", count+1);\n        /*\n        */\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar S[21][21];\nint count = 0;\n\nvoid a(int i, int j){\n\tif(S[i][j] == '.'){\n\t\tcount++;\n\t\tS[i][j] = '#';\n\t\ta(i - 1, j);\n\t\ta(i + 1, j);\n\t\ta(i, j + 1);\n\t\ta(i, j - 1);\n\t}\n}\n\n\nint main(){\n\twhile(true){\n\t\tcount = 0;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> S[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint startx, starty;\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tif(S[i][j] == '@'){\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t\tS[i][j] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta(starty, startx);\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint G[1010];\nint R[110][110];\nint D[1010];\nint bfs(int src,int num);\n\nint main() {\n\tint W,H,root;\n\tchar c;\n\n\n\twhile (true) {\n\t\tfor(int i=0;i<100;i++) {\n\t\t\tfor(int j=0;j<100;j++) {\n\t\t\t\tR[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1000;i++) {\n\t\t\tG[i] = 0;\n\t\t}\n\t\tfor(int i=0;i<1000;i++) {\n\t\t\tD[i] = 100;\n\t\t}\n\t\tcin >> W >> H;\n\t\tif((W == 0) && (H == 0)) break;\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tcin >> c;\n\t\t\tif(c == '.') G[i] = 1;\n\t\t\tif(c == '#') G[i] = 0;\n\t\t\tif(c == '@') {\n\t\t\t\tG[i] = 1;\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<W*H;i++) {\n\t\t\tif(G[i] == 1) {\n\t\t\t\tif(i%W != 0) { //????????????\n\t\t\t\t\tif(G[i-1] == 1) {//??????????????? \n\t\t\t\t\t\tR[i][i-1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i%W != W-1) { //????????????\n\t\t\t\t\tif(G[i+1] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i+1] = 1;\n\t\t\t\t\t}\t\t\t\n\n\t\t\t\t}\n\t\t\t\tif(i > W-1) { //???????????????\n\t\t\t\t\tif(G[i-W] == 1) { //???????????????\n\t\t\t\t\t\tR[i][i-W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t\tif(i < W*H-W) {//???????????????\n\t\t\t\t\tif(G[i+W] == 1){\n\t\t\t\t\t\tR[i][i+W] = 1;\n\t\t\t\t\t}\t\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bfs(root,W*H) << endl;\n\t}\n\t/*\n\tfor(int i=0;i<99;i++) {\n\t\tcout << i << \" \" << G[i] << endl;\n\t}\n\tcout << G[98] << endl;\n\tcout << R[87][98] << endl;\n\t*/\n\t\n}\n\n\n\n\n\nint bfs(int src,int num) {\n\tint cur,dst;\n\tint count = 1;\n\t//cerr << \"bfs root = \" << src << endl;\n\tqueue<int> Q; // ??´??°????????????????????\\????????????\n\tQ.push(src);\n\tD[src] = 0; // ?????????\n\twhile (!Q.empty()) {\n\t\t\n\t\tint cur = Q.front(); // ??????????´????????????????\n\t\tQ.pop();\n// ???????¢??????¨??¨???\n\t\t//cerr << cur << \" \" << D[cur] << endl;\n\t\tfor (int dst=0;dst<num;dst++) { // ???????????? dst ????????????\n\t\t\tif ((R[cur][dst] == 1) && (D[dst] == 100)) { // cur ?????? dst ??????????????????dst ???????¨??????????\n\t\t\t\tD[dst] = D[cur]+1; //\n\t\t\t\tQ.push(dst); // dst ????¨???????????????????\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\n\nint main(){\n    std::vector<int> row;\n    int prev_col, width, height, max = 0, last = 0;\n    bool connect_prev_row;\n    \n    while(true){\n        std::cin >> width >> height;\n        if( width == 0 && height == 0 ) break;\n        row.resize(width+1);\n        for( int i = 0; i <= width; i++ ) row[i] = 0;\n\n        std::string line;\n        for( int h = 0; h < height; h++ ){\n            std::cin >> line;\n            connect_prev_row = false;\n            for(std::string::size_type i = 0; i < line.size(); i++ ){\n                if( line[i] == '.' ){\n                    if( connect_prev_row ){\n                        if( row[i] > 0 ) row[i+1] = row[i] + 1;\n                        else row[i+1] = row[i] - 1;\n                    } else {\n                        connect_prev_row = true;\n                        if( row[i] <= 0 && row[i+1] <= 0 ) row[i+1] = row[i+1] + row[i] - 1;\n                        else row[i+1] = std::abs(row[i+1]) + std::abs(row[i]) + 1;\n                    }\n                } else if( line[i] == '@' ) {\n                    if ( connect_prev_row ) row[i+1] = - row[i] + 1;\n                    else {\n                        connect_prev_row = true;\n                        row[i+1] = - row[i+1] - row[i] + 1;\n                    }\n                } else {\n                    row[i+1] = 0;\n                    connect_prev_row = false;\n                }\n                max = max > row[i+1] ? max : row[i+1];\n            }\n            last = 0;\n            for( int i = line.size(); i > 0; i-- ) {\n                if( row[i] == 0 ) last = 0;\n                else if( row[i] > 0 ){\n                    if(  last == 0 ) last = row[i];\n                    else row[i] = last;\n                } else {\n                    if(  last == 0 ) last = row[i];\n                    else row[i] = last;\n                } \n            }\n        }\n            \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T& t, const V& v) { t = v; }\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T& t, const V& v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\n\n#define ARRAY_MAX 100005\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\nint dx[4] = { 1,0,0,-1 };\nint dy[4] = { 0,1,-1,0 };\n\n\nstruct Combination {\n\n\tvector<ll> fact, rfact;\n\n\tCombination(ll sz) : fact(sz + 1), rfact(sz + 1) {\n\n\t\tfact[0] = 1;\n\t\tfor (ll i = 1; i < fact.size(); i++) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\t//逆元\n\t\trfact[sz] = inv(fact[sz]);\n\t\tfor (ll i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % MOD;\n\t\t}\n\t}\n\n\tll inv(ll x) {\n\t\t//modpow\n\t\treturn pow(x, MOD - 2);\n\t}\n\tll pow(ll x, ll n) {\n\t\t//累乗\n\t\tll ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= MOD;\n\t\t\t(x *= x) %= MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\tll P(ll n, ll r) {\n\t\t//順列\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (fact[n] * rfact[n - r] % MOD);\n\t}\n\n\tll C(ll p, ll q) {\n\t\t//組み合わせ\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (fact[p] * rfact[q] % MOD * rfact[p - q] % MOD);\n\t}\n\n\tll H(ll n, ll r) {\n\t\t//重複組み合わせ\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\n\n\n/******************************************************************************************/\n\nchar mp[25][25];\nint flag[25][25];\n\nint main() {\n\n\tint h, w;\n\tint sx, sy;\n\n\twhile (cin >> w >> h, h | w) {\n\n\t\tint ans = 0;\n\n\n\t\tfor (int i = 0; i < 25; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 25; j++) {\n\n\t\t\t\tflag[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tcin >> mp[i][j];\n\t\t\t\tif (mp[i][j] == '@') {\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t\tif (mp[i][j] == '#') {\n\t\t\t\t\tflag[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pii> que;\n\n\t\tque.push(pii(sy, sx));\n\t\twhile (!que.empty()) {\n\n\t\t\tpii hoge = que.front();\n\t\t\tque.pop();\n\t\t\tflag[hoge.first][hoge.second] = 1;\n\t\t\t\n\t\t\t//cout << hoge.second << \" \" << hoge.first << endl;\n\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tint ny = hoge.first + dy[i];\n\t\t\t\tint nx = hoge.second + dx[i];\n\n\t\t\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w && mp[ny][nx] != '#' && flag[ny][nx] < 0) {\n\t\t\t\t\tque.push(pii(ny, nx));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tif (flag[i][j] == 1) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\t\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nint sx,sy,h,w;\nstring fld[20];\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint bfs() {\n\tbool used[h][w];\n\tREP(i,h) REP(j,w) used[i][j]=false;\n\tint cnt=1;\n\tqueue<P> q;\n\tused[sy][sx]=true;\n\tq.push(P(sx,sy));\n\twhile(!q.empty()) {\n\t\tP p=q.front();q.pop();\n\t\tREP(i,4) {\n\t\t\tint nx=p.fi+dx[i],ny=p.se+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h||used[ny][nx]||fld[ny][nx]=='#') continue;\n\t\t\tused[ny][nx]=true;\n\t\t\tcnt++;\n\t\t\tq.push(P(nx,ny));\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\tcin>>w>>h;\n\t\tREP(i,h) {\n\t\t\tcin>>fld[i];\n\t\t\tREP(j,w) if(fld[i][j]=='@') sx=j,sy=i;\n\t\t}\n\t\tcout<<bfs()<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n// #include<stdio.h>\n// \n\n/*\n..#.#..\n..#.#..\n###.###\n...@...\n###.###\n..#.#..\n..#.#..\n */\n\nusing namespace std;\n\nint W,H;\nchar c[100][101]; // c[H][W]\n\nbool visited[100][100]; // <----\n\nint dx[4] = {1,0,-1,0}; // ??? ??? ??? ???\nint dy[4] = {0,1,0,-1};\n\nvoid compute() {\n\n  memset(visited,false,sizeof visited); //memset(???????????????????????????1bit???????????????????????????) ?????????1bit????????§?????????\n\n  queue<int> que;\n  int i,j;\n  for(i=0;i<H;++i) {\n    for(j=0;j<W;++j) {\n      if( c[i][j] == '@' ) {\n\tque.push(j+i*W);\n\tvisited[i][j] = true;\n\t//break;\n\tgoto Skip;\n      }\n    }\n  }\n Skip:;\n\n  int answer = 1; // <---???????????????\n  while( !que.empty() ) { // !0 => 1  !1 => 0\n    int cur = que.front(); que.pop(); // que -> [1,2,3,4], front -> 1, pop -> [2,3,4]\n    int x = cur % W, y = cur / W; //???????????§?¨?\n    \n    for(i=0;i<4;++i) {\n      int nx = x + dx[i], ny = y + dy[i]; //?¬??????§?¨?????¨?????????§?¨?\n\n      if( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue; // 0 && 0 => 0, 1 && 0 => 0, 0 && 1 => 0, 1 && 1 => 1\n      if( c[ny][nx] == '#' || visited[ny][nx] ) continue;         // 0 || 0 => 0, 1 || 0 => 1, 0 || 1 => 1, 1 || 1 => 1\n      \n      que.push(nx+ny*W);\n      visited[ny][nx] = true;\n      ++answer;// <---???????????????\n\n    }\n    \n  }\n\n  cout << answer << endl;// <---???????????????\n\n}\n\nint main() {\n  while( scanf(\"%d %d\",&W,&H), W | H ) {\n    //while( scanf(\"%d %d\",&W,&H), W == 0 && H == 0 ) {\n    int i;\n    for(i=0;i<H;++i) {\n      scanf(\" %s\",&c[i][0]);  // c[y][x]\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint solve( int w, int h, vector< vector<char> > &v );\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(w);\n        for (int i = 0; i < w; i++) {\n            vec[i].resize(h);\n        }\n\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < h; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        sums.push_back( solve( w, h, vec ) );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nint solve( int w, int h, vector< vector<char> > &v ){\n    int w_index, h_index, total;\n    int ans = 0;\n\n    for (auto it = v.begin(); it != v.end(); it++ ) {\n        auto iter = find(it->begin(), it->end(), '@');\n\n        if(iter!=it->end()){\n            w_index = distance( v.begin(), it );\n            h_index = distance( it->begin(), iter );\n        }\n    }\n\n    dfs( w, h, w_index, h_index, v, ans );\n\n    return ans;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[w_index][h_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[nx][ny] == '.' ){\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct D\n{\n  bool movable[20][20] = {};\n};\n\nint const dir[][2] = {\n  {  1, 0 },\n  { -1, 0 },\n  { 0,  1 },\n  { 0, -1 }\n};\n\nvoid count( D& d, int& num, int const px, int const py )\n{\n  if ( !d.movable[px][py] )\n    return;\n\n  ++num;\n  d.movable[px][py] = false;\n\n  for( int i=0; i<4; ++i ) {\n    int const npx = px + dir[i][0];\n    int const npy = py + dir[i][1];\n    if ( npx < 0 || npy < 0 || npx >= 20 || npy >= 20 )\n      continue;\n    count( d, num, npx, npy );\n  }\n}\n\nint main()\n{\n  int w, h;\n  while( cin >> w >> h ) {\n    if ( w == 0 && h == 0 )\n      break;\n\n    D d;\n    int px, py;\n    for( int y=0; y<h; ++y ) {\n      for( int x=0; x<w; ++x ) {\n        char c;\n        cin >> c;\n        if ( c == '@' ) {\n          px = x;\n          py = y;\n        }\n\n        d.movable[x][y] = ( c != '#' );\n      }\n    }\n\n    int num = 0;\n    count( d, num, px, py );\n    cout << num << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( x < H && y < W && room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '*';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\txy.pop();\n\t\t}\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcout << room[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nconst int di[4] = {+1, 0, -1, 0};\nconst int dj[4] = {0, -1, 0, +1};\n\nint w, h;\nstring tiles[20];\n\nint solve(int si, int sj){\n    int res = 0;\n    queue<pair<int, int> > Q;\n    bool visited[h][w];\n    memset(visited, false, sizeof visited);\n    visited[si][sj] = true;\n    res++;\n    Q.push(make_pair(si, sj));\n    while(!Q.empty()){\n        pair<int, int> p = Q.front();\n        Q.pop();\n        int pi = p.first, pj = p.second;\n        for(int k=0;k<4;k++){\n            int ni = pi + di[k];\n            int nj = pj + dj[k];\n            if(ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n            if(!visited[ni][nj] && tiles[ni][nj] == '.'){\n                visited[ni][nj] = true;\n                Q.push(make_pair(ni, nj));\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        int si, sj;\n        for(int i=0;i<h;i++){\n            cin >> tiles[i];\n            for(int j=0;j<w;j++){\n                if(tiles[i][j] == '@'){\n                   si = i;  \n                   sj = j;\n                }\n            }\n        }\n        int ans = solve(si, sj);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint ans=1,n,m;\nchar map[30][30];\n\nvoid d(int x,int y){\n  if(x==m||y==n||x<0||y<0)return;\n  if(map[x][y]=='.')ans++;\n  if(map[x][y]=='#')return;\n  map[x][y]='#';\n  d(x+1,y),d(x-1,y),d(x,y+1),d(x,y-1);\n}\n\nint main(){\n  while(cin>>n>>m,n){\n  int x,y;\n  ans=1;\n  r(i,m)r(j,n){\n    cin>>map[i][j];\n    if(map[i][j]=='@')x=i,y=j;\n  }\n  d(x,y);\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvoid saiki(int x,int y,vector<vector<char> > &field,vector<vector<char> > &k){\n    if(field[y][x] == '#' || k[y][x] == 'x'){\n        return;\n    }\n\n    field[y][x] = '#';\n    k[y][x] = 'x';\n    saiki(x-1,y,field,k);\n    saiki(x+1,y,field,k);\n    saiki(x,y-1,field,k);\n    saiki(x,y+1,field,k);\n    field[y][x] = '.';\n    return;\n}\n\nint solve(int w,int h){\n    //char field[w+2][h+2];\n    vector<vector<char> > field(h+2,vector<char>(w+2));\n    vector<vector<char> > k(h+2,vector<char>(w+2));\n\n    int x,y;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            field[i][j] = '#';\n        }\n    }\n\n    for(int i=1;i<=h;i++){\n        for(int j=1;j<=w;j++){\n            cin >> field[i][j];\n            if(field[i][j] == '@'){\n                y = i;\n                x = j;\n            }\n            k[i][j] = field[i][j];\n        }\n    }\n\n#ifdef DEB\n    cout << \"X:\" << x << \" Y:\" << y << endl;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n#endif\n    saiki(x,y,field,k);\n\n    int m = 0;\n    for(int i=0;i<h+2;i++){\n        for(int j=0;j<w+2;j++){\n            if(k[i][j] == 'x'){\n                m++;\n            }\n        }\n    }\n    cout << m << endl;\n}\n\nint main(){\n    int x,y;\n    while(cin >> x >> y){\n        if(x==0 && y == 0){\n            break;\n        }\n        solve(x,y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint tile[22][22] = {};\nint w, h;\nint cnt;\n\nvoid fill(int x, int y) {\n\ttile[x][y] = 0;\n\tcnt++;\n\tif (tile[x - 1][y] == 1) fill(x - 1, y);\n\tif (tile[x][y - 1] == 1) fill(x, y - 1);\n\tif (tile[x][y + 1] == 1) fill(x, y + 1);\n\tif (tile[x + 1][y] == 1) fill(x + 1, y);\n}\n\nint main() {\n\tint x = 0, y = 0;\n\twhile (cin >> w >> h && (w || h)) {\n\t\tcnt = 0;\n\t\tfor (int i = 1; i <= h; ++i){\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif (tmp == '.') tile[i][j] = 1;\n\t\t\t\telse if (tmp == '#') tile[i][j] = 0;\n\t\t\t\telse x = i, y = j, tile[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfill(x, y);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <array>\n\nconst int kSize = 20 + 2;\n\nstd::array<int, 4> ways = {-1, -kSize, +1, +kSize};\n\ninline int xy2pos(const int x, const int y){\n    return x + y * kSize;\n}\n\nstd::array<bool, kSize*kSize> Bfs(const std::array<bool, kSize*kSize> &tiles, int pos){\n    std::array<bool, kSize*kSize> arrived;\n    std::queue<int> q;\n    q.push(pos);\n    std::fill(arrived.begin(), arrived.end(), false);\n    while(!q.empty()){\n        pos = q.front();\n        q.pop();\n        arrived[pos] = true;\n        for(int way : ways)\n            if(tiles.at(pos + way) && !arrived.at(pos + way))\n                q.push(pos + way);\n    }\n    return arrived;\n}\n\nint main(){\n    int w,h;\n    std::array<bool,kSize*kSize> tiles; ///< true if black\n    while((std::cin >> w >> h) && w != 0){\n        std::fill(tiles.begin(), tiles.end(), false);\n        int pos;\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                char c;\n                std::cin >> c;\n                tiles[xy2pos(x,y)] = (c == '.');\n                if(c == '@'){\n                    pos = xy2pos(x,y);\n                    tiles[pos] = true;\n                }\n            }\n        }\n        auto arrived = Bfs(tiles, pos);\n        int sum = 0;\n        for(bool v : arrived)\n            sum += (v) ? 1 : 0;\n        std::cout << sum << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    if (map[y][x] == '@') tile--;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (1){\n\tscanf(\"%d %d\", &w, &h);\n\tif (w == 0 && h == 0) break;\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\tdfs(sx, sy);\n\tprintf(\"%d\\n\", tile);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col]!='#' && M[nc.row][nc.col]!='*' && M[nc.row][nc.col]!='@')\n\t{\n\t  M[nc.row][nc.col] = '*';\n\t  S.push(nc);\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tfunction<void(int, int)> dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}'\n"
  },
  {
    "language": "C++",
    "code": "  1 #include <bits/stdc++.h>\n  2\n  3 using namespace std;\n  4\n  5 int w, h, cnt;\n  6 int vx[] = {0, 1, 0, -1};\n  7 int vy[] = {1, 0, -1, 0};\n  8 char field[20][20];\n  9\n 10 void solve(int x, int y){\n 11\n 12     ++cnt;\n 13     field[y][x] = '#';\n 14\n 15     for(int i = 0; i < 4; ++i){\n 16\n 17         int nx = x + vx[i];\n 18         int ny = y + vy[i];\n 19\n 20         if(nx >= 0 && nx < w && ny >= 0 && ny < h && field[ny][nx] == '.')\n 21             solve(nx, ny);\n 22\n 23     }\n 24\n 25 }\n 26\n 27 int main(){\n 28\n 29     int sx, sy;\n 30     while(cin >> w >> h){\n 31\n 32         if(!(w || h)) break;\n 33\n 34         for(int i = 0; i < h; ++i){\n 35             for(int j = 0; j < w; ++j){\n 36                 cin >> field[i][j];\n 37                 if(field[i][j] == '@'){\n 38                     sx = j;\n 39                     sy = i;\n 40                 }\n 41             }\n 42         }\n 43\n 44         cnt = 0;\n 45\n 46         solve(sx, sy);\n 47\n 48         cout << cnt << endl;\n 49\n 50     }\n 51\n 52 }\n~"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nvin dx={-1,0,1,0};\nvin dy={0,1,0,-1};\nint w,h;\n\nint dfs(vvch &c,int x,int y,int &res){\n    c[y][x]='?';\n    int nx,ny;\n    rep(i,4){\n        nx=x+dx[i];\n        ny=y+dy[i];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h&&c[ny][nx]=='.'){\n            res++;\n            dfs(c,nx,ny,res);\n        }\n    }\n    return res;\n}\n\nint main(){\n    queue<int> ans;int res;\n    while(1){\n        cin>>w>>h;\n        if(w==0)break;\n        vvch c(h,vch(w));int sx,sy;\n        rep(i,h)rep(j,w){\n            cin>>c[i][j];\n            if(c[i][j]=='@'){\n                sx=j;\n                sy=i;\n            }\n        }\n        res=1;\n        ans.push(dfs(c,sx,sy,res));\n    }\n    while(ans.size()){\n        cout<<ans.front()<<endl;\n        ans.pop();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define REP(i, s, n) for(int i = s; i < n; ++i)\n#define rep(i, n)\t\t REP(i, 0, n)\n#define SORT(c)\t\t\t sort((c).begin(), (c).end())\n#define IINF\t\t\t\t\tINT_MAX\n#define LLINF\t\t\t\t\tLLONG_MAX\n#define DEBUG\t\t\t\t\tfalse\n \ntypedef long long\t\t\t\tll;\ntypedef pair <int, int> ii;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\t\n\tint w, h;\n\t\n\twhile(cin >> w >> h, w, h){\n\t\tvector<string> mp(h);\n\t\t//vector<vector<bool> > used(h, vector<int>(w));\n\t\trep(i, h) cin >> mp[i];\n\t\t\n\t\tint sx, sy;\n\t\trep(i, h){\n\t\t\trep(j, w) if(mp[i][j] == '@'){\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<ii> qu;\n\t\tqu.push(make_pair(sx, sy));\n\t\t\n\t\tint ans = 0;\n\t\twhile(!qu.empty()){\n\t\t\tii tmp = qu.front();\n\t\t\tqu.pop();\n\t\t\tans++;\n\t\t\t\n\t\t\t\n\t\t\trep(i, 4){\n\t\t\t\tint nx = tmp.first + dx[i];\n\t\t\t\tint ny = tmp.second + dy[i];\n\t\t\t\n\t\t\t\tif(nx < 0 || w <= nx) continue;\n\t\t\t\tif(ny < 0 || h <= ny) continue;\n\t\t\t\t\n\t\t\t\tif(mp[ny][nx] == '.'){\n\t\t\t\t\tqu.push(make_pair(nx, ny));\n\t\t\t\t\tmp[ny][nx] = '#';\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool map[20][20];//true??????\nint W,H,X,Y;\nint ct;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nbool valid(int x,int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H && map[x][y];\n}\n\nvoid dfs(int x,int y) {\n\tmap[x][y] = false;\n\tct++;\n\tfor(int i = 0;i < 4;i++) {\n\t\tif(valid(x + dx[i],y + dy[i])) dfs(x + dx[i],y + dy[i]);\n\t}\n}\n\nint main() {\n\twhile(cin >> W >> H && !(W == 0 && H == 0)) {\n\t\tct = 0;\n\t\tfor(int y = 0;y < H;y++) {\n\t\t\tchar c;\n\t\t\tfor(int x = 0;x < W;x++) {\n\t\t\t\tcin >> c;\n\t\t\t\tmap[x][y] = !(c == '#');\n\t\t\t\tif(c == '@') {\n\t\t\t\t\tX = x;\n\t\t\t\t\tY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(X,Y);\n\t\tcout << ct << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct DataSet{\n    int x, y;\n    int ax, ay;\n    string str;\n};\n\nint search(int xSize, int ySize, int x, int y, string& s){\n    //cout << '[' << x << ',' << y << ']' << endl;\n    int ret = 0;\n    int nowPos = x + y * xSize;\n    s[nowPos] = '#';\n    ++ret;\n    \n    if(s[nowPos - 1] == '.' && x != 0){\n        ret += search(xSize, ySize, x-1, y, s);\n    }\n    if(s[nowPos + 1] == '.' && x + 1 != xSize){\n        ret += search(xSize, ySize, x+1, y, s);\n    }\n    if(s[nowPos - xSize] == '.' && y != 0){\n        ret += search(xSize, ySize,x, y-1, s);\n    }\n    if(s[nowPos + xSize] == '.' && y + 1 != ySize){\n        ret += search(xSize, ySize, x, y+1, s);\n    }\n    return ret;\n}\n\nint main()\n{\n    vector<DataSet> dataSets;\n    char word;\n    \n    while(cin){\n        DataSet dataSet;\n        cin >> dataSet.x >> dataSet.y;\n        for(int i = 0; i < dataSet.y * dataSet.x; i++){\n            cin >> word;\n            if(word == '@'){\n                dataSet.ax = i % dataSet.x;\n                dataSet.ay = i / dataSet.x;\n            }\n            //cout << line << endl;\n            dataSet.str += word;\n        }\n        dataSets.push_back(dataSet);\n    }\n    dataSets.pop_back();\n    \n    //cout << dataSets.back().x << ' ' << dataSets.back().y << endl;\n    //cout << dataSets.back().ax << ' ' << dataSets.back().ay << endl;\n    //cout << dataSets.back().str;\n    \n    for(auto dataSet : dataSets){\n        if(dataSet.x == 0) continue;\n        cout << search(dataSet.x, dataSet.y, dataSet.ax, dataSet.ay, dataSet.str) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include <utility>\n#include <functional>\n//#include<>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n//#define int long long;\nsigned main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    int cnt{};\n    vector<string> v(h);\n    for(int i = 0; i < h; ++i){\n      cin >> v[i];\n    }\n    //initialize\n    pair<int, int> p;\n    queue<pair<int, int>> q;\t\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n\tif(v[i][j] == '@'){\n\t  p = make_pair(i,j);\n\t  q.push(p);\n\t}\n      }\n    }\n    while(!q.empty()){\n      pair<int, int> p;\n      p = q.front();\n      q.pop();\n\n      for(int k = 0; k < 4; ++k){\n\tint x = p.first + dx[k]; int y = p.second + dy[k];\n\tif(0 > x || h <= x || 0 > y || w <= y)continue;\n\tif('.' == v[x][y]){\n\t  v[x][y] = '@';\n\t  ++cn\n\t  q.push(make_pair(x, y));\n\t}\n      }\n    }\n    cout << cnt+1 << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define iota(i,n,b,s) for(int i=int(b);i!=int((b)+(s)*(n));i+=(s))\n#define range(i,n,m) iota(i,(((n)>(m))?((n)-(m)+1):((m)-(n)+1)),(n),((n)>(m)?-1:1))\n#define rep(i,n) iota(i,(n),0,1)\n\n#define INF (1e9)\n#define EPS (1e-9)\n#define cons(a,b) (make_pair(a,b))\n#define car(a) (a.first)\n#define cdr(a) (a.second)\n#define cadr(a) (car(cdr(a)))\n#define cddr(a) (cdr(cdr(a)))\n#define all(a) a.begin(), a.end()\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n\ntypedef long long INTEGER;\ntypedef double FLOAT;\n\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T> p) {\n  os << '(' << car(p) << \", \" << cdr(p) << ')';\n  return os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T> v) {\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\nint main()\n{\nentry:;\n\n  int w, h; cin >> w >> h;\n  if (!w && !h) return 0;\n\n  int f[h][w];\n  int ci, cj;\n  rep (i, h) {\n    string s; cin >> s;\n    rep (j, s.size()) {\n      if (s[j] == '.') {\n        f[i][j] = 1;\n      } else if (s[j] == '@') {\n        f[i][j] = 1;\n        ci = i;\n        cj = j;\n      } else {\n        f[i][j] = 0;\n      }\n    }\n  }\n\n  stack<pair<int,int>> s;\n  s.push(cons(ci, cj));\n\n  int ans = 0;\n  while (!s.empty()) {\n    pair<int, int> x = s.top(); s.pop();\n    if (f[car(x)][cdr(x)] == 0) continue;\n    f[car(x)][cdr(x)] = 0;\n    ++ans;\n\n    if (car(x) > 0) s.push(cons(car(x) - 1, cdr(x)));\n    if (cdr(x) > 0) s.push(cons(car(x), cdr(x) - 1));\n    if (car(x) < h - 1) s.push(cons(car(x) + 1, cdr(x)));\n    if (cdr(x) < w - 1) s.push(cons(car(x), cdr(x) + 1));\n\n  }\n\n  cout << ans << endl;\n\n  goto entry;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define iota(i,n,b,s) for(int i=int(b);i!=int((b)+(s)*(n));i+=(s))\n#define range(i,n,m) iota(i,(((n)>(m))?((n)-(m)+1):((m)-(n)+1)),(n),((n)>(m)?-1:1))\n#define rep(i,n) iota(i,(n),0,1)\n\n#define INF (1e9)\n#define EPS (1e-9)\n#define cons(a,b) (make_pair(a,b))\n#define car(a) (a.first)\n#define cdr(a) (a.second)\n#define cadr(a) (car(cdr(a)))\n#define cddr(a) (cdr(cdr(a)))\n#define all(a) a.begin(), a.end()\n#define trace(var) cerr<<\">>> \"<<#var<<\" = \"<<var<<endl;\n\ntypedef long long INTEGER;\ntypedef double FLOAT;\n\ntemplate<class S, class T>\nostream& operator<<(ostream& os, pair<S,T> p) {\n  os << '(' << car(p) << \", \" << cdr(p) << ')';\n  return os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T> v) {\n  os << v[0];\n  for (int i=1, len=v.size(); i<len; ++i) os << ' ' << v[i];\n  return os;\n}\n\nint main()\n{\nentry:;\n\n  int w, h; cin >> w >> h;\n  if (!w && !h) return 0;\n\n  int f[h][w];\n  int ci, cj;\n  rep (i, h) {\n    string s; cin >> s;\n    rep (j, s.size()) {\n      if (s[j] == '.') {\n        f[i][j] = 1;\n      } else if (s[j] == '@') {\n        f[i][j] = 1;\n        ci = i;\n        cj = j;\n      } else {\n        f[i][j] = 0;\n      }\n    }\n  }\n\n  stack<pair<int,int>> s;\n  s.push(cons(ci, cj));\n\n  int ans = 0;\n  while (!s.empty()) {\n    pair<int, int> x = s.top(); s.pop();\n    if (f[car(x)][cdr(x)] == 0) continue;\n    f[car(x)][cdr(x)] = 0;\n    ++ans;\n\n    if (car(x) > 0) s.push(cons(car(x) - 1, cdr(x)));\n    if (cdr(x) > 0) s.push(cons(car(x), cdr(x) - 1));\n    if (car(x) < h - 1) s.push(cons(car(x) + 1, cdr(x)));\n    if (cdr(x) < w - 1) s.push(cons(car(x), cdr(x) + 1));\n\n  }\n\n  cout << ans << endl;\n\n  goto entry;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ICPC 2004 à\\I B\n// Red and Black\n// C++ queue Å\n\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nstruct Coord {\n  int col;\n  int row;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  while (1) {\n    int W, H;\n    scanf(\"%d%d\", &W, &H);\n    if (W==0 && H==0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\nint solve (int W, int H) {\n  char M[H+2][W+2];\n  Coord start;\n  //  ÇiÔºjÌÝè \n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  //  f[^ÌÇÝÝ\n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\tstart.col = j;\n      }\n    }\n  }\n\n\n  // X^[gn_ÌÝè\n  queue<Coord> Q;                              // BZðÛ·éL[\n  Q.push(start);                               // X^[gn_ð enqueue\n  int c=1;                                     // BZJE^\n\n  // ÈºTõi±ê©çìéj\n\twhile( !Q.empty()){\n\t\tCoord current = Q.front();Q.pop();\n\t\tint D1[] ={1,0,-1,0};int D2[]={0,-1,0,1};\n\t\tfor ( int d=0;d<4;d++){\n\t\t\tCoord nc = current;\n\t\t\tnc.row += D1[d]; nc.col += D2[d];\n\t\tprintf(\"r:%d , c:%d\\n\",nc.row ,nc.col);\n\t\t\tif (M[ nc.row ][ nc.col ]=='.'){\n\t\t\t\tM[ nc.row ][ nc.col ]='*';\n\t\t\t\tQ.push(nc);\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\n  return c;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <memory>\n#include <functional>\nusing namespace std;\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long LL;\ntypedef long long int LLI;\n\nint memo[20][20];\n\nint mx[] = {0,0,-1,1};\nint my[] = {-1,1,0,0};\n\nchar table[21][21];\n\nint dfs(int x,int y);\nint W=0,H=0;\n\nint main(void)\n{\n    while(1){\n    int i,j;\n    int x,y;\n    int ans=0;\n    cin>> W >> H;\n    \n    if(W==0 && H==0)break;\n    \n    REP(i,0,H){\n        REP(j,0,W){\n            cin >> table[i][j];\n            if(table[i][j] == '@'){\n                x=i;\n                y=j;\n            }\n        }\n    }\n    ans = dfs(x,y);\n    cout << ans << endl;\n    }\n    return 0;\n}\n\nint dfs(int x,int y){\n    int cnt=1;\n    for(int i=0;i<4;i++){\n        int nx = x+mx[i],ny = y+my[i];\n        if(0 <= nx && 0 <= ny && ny < W && nx < H && table[nx][ny] == '.'){\n            table[nx][ny] = '#';\n            cnt += dfs(nx,ny);\n        }\n    }\n    return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define MAX_H 22\n#define MAX_W 22\n\nint W, H, X, Y, A;\n\nchar tile[MAX_H][MAX_W];\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '@';\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (0 <= x + dx[i] && x + dx[i] <= W - 1 && 0 <= y + dy[i] && y + dy[i] <= H - 1)\n\t\t{\n\t\t\tif (tile[y + dy[i]][x + dx[i]] == '.')\n\t\t\t{\n\t\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> tile[i][j];\n\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tX = j;\n\t\t\t\t\tY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(X, Y);\n\n\t\tA = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tA++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << A << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define endl '\\n'\nint mod=1e9+7;\nint mod2=998244353;\n\nsigned main(){\n  while(true){\n    int h,w;\n    cin>>w>>h;\n    if(!h&&!w)break;\n    vector<string> hw(h);\n    for(int i=0;i<h;i++)cin>>hw[i];\n    queue<int> x;\n    queue<int> y;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(hw[i][j]=='@'){\n          x.push(j);\n          y.push(i);\n        }\n      }\n    }\n    int ans=0;\n    int px[]={1,0,-1,0};\n    int py[]={0,-1,0,1};\n\n    while(x.size()){\n      int nx=x.front();\n      int ny=y.front();\n      x.pop();\n      y.pop();\n      ans++;\n      for(int i=0;i<4;i++){\n        if(nx+px[i]>=0&&nx+px[i]<w&&ny+py[i]>=0&&ny+py[i]<h&&hw[ny+py[i]][nx+px[i]]=='.'){\n          x.push(nx+px[i]);\n          y.push(ny+py[i]);\n          hw[ny+py[i]][nx+px[i]]='@';\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]){\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    int w, h;\n    int cnt = 0;\n    int sx, sy;\n    vector<string> v;\n    while(true){\n        cnt = 0;\n        string tmp;\n        v.clear();\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        rep(i, h){\n            cin >> tmp;\n            v.push_back(tmp);\n            if(tmp.find('@') != string::npos){\n                sx = i;\n                sy = tmp.find('@');\n            }\n        }\n        \n        queue<pair<int, int> > q;\n        q.push({sx, sy});\n        while(!q.empty()){\n            pair<int, int> p = q.front();\n            q.pop();\n            // cout << \"Now : \" << p.first << \" \" << p.second << endl;\n            if(p.first >= h\n                || p.second >= w\n                || p.first  < 0\n                || p.second < 0\n            )continue;\n            if((v[p.first][p.second] == '.' || v[p.first][p.second] == '@')) {\n                v[p.first][p.second] = '#';\n                cnt++;\n                rep(i, 4){\n                    q.push({p.first + dx[i], p.second + dy[i]});\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int>    VI;\ntypedef vector<bool>   VB;\ntypedef vector<string> VS;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(x)  (x).begin(),(x).end()\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define RANGE(x, min, max) min <= x && x <= max\n\nint w, h;\nVS tbl;\n\nconst int DX[] = {-1, 0, 1, 0}, DY[] = {0, -1, 0, 1};\n\nint dfs(int y, int x) {\n\tint res = 1;\n\ttbl[y][x] = '#';\n\trep (i, 4) {\n\t\tint ny = y + DY[i], nx = x + DX[i];\n\t\tif (RANGE(ny, 0, h - 1) && RANGE(nx, 0, w - 1) && tbl[ny][nx] == '.') {\n\t\t\tres += dfs(ny, nx);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void) {\n\twhile (1) {\n\t\ttbl.clear();\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\trep (i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ttbl.PB(s);\n\t\t}\n\t\tint sy, sx;\n\t\trep (i, h) rep (j, w) {\n\t\t\tif (tbl[i][j] == '@') {\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(sy, sx) << endl;\t\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconstexpr size_t di[]={size_t(-1), 0, 1, 0};\nconstexpr size_t dj[]={0, size_t(-1), 0, 1};\n\nint testcase_ends() {\n  size_t W, H;\n  scanf(\"%zu %zu\", &W, &H);\n\n  if (W == 0 && H == 0)\n    return 1;\n\n  std::vector<std::string> S(H);\n  size_t h=0, w=0;\n  for (size_t i=0; i<H; ++i) {\n    char buf[32]={};\n    scanf(\"%s\", buf);\n    S[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (S[i][j] == '@') {\n        h = i;\n        w = j;\n        break;\n      }\n    }\n  }\n\n  std::queue<std::pair<size_t, size_t>> q;\n  q.emplace(h, w);\n  int res=1;\n  while (!q.empty()) {\n    const auto p=q.front();\n    q.pop();\n\n    size_t i=p.first, j=p.second;\n    S[i][j] = '*';\n    for (size_t k=0; k<4; ++k) {\n      size_t ni=i+di[k], nj=j+dj[k];\n      if (!(ni < H && nj < W)) continue;\n\n      if (S[ni][nj] == '.') {\n        q.emplace(ni, nj);\n        ++res;\n        S[ni][nj] = '*';\n      }\n    }\n  }\n\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h && w > 0 && h > 0){\n        string tmp;\n        pair<int, int> init;\n        vector<vector <int> > grid(25, vector<int>(25, -1));\n        vector<vector <int> > visited(25, vector<int>(25, 0));\n        for(int i = 0; i < h; i++){\n            cin >> tmp;\n            for (int j = 0; j < w; j++){\n                if(tmp[j] == '.'){\n                    grid[i][j] = 0;\n                }else if(tmp[j] == '#'){\n                    grid[i][j] = -1;\n                }else if(tmp[j] == '@'){\n                    grid[i][j] = 0;\n                    init = make_pair(i, j);\n                }\n            }\n        }\n        queue<pair<int, int> > Q;\n        Q.push(init);\n        visited[init.first][init.second] = 1; \n        while(!Q.empty()){\n            pair<int, int> cur = Q.front(); \n            Q.pop();\n            int cur_x = cur.first;\n            int cur_y = cur.second;\n            for(int i = 0; i < 4; i++){\n                pair<int, int> dst = make_pair(cur_x + dx[i], cur_y + dy[i]);\n                int x = dst.first;\n                int y = dst.second;\n                if(0 <= x && 0 <= y && grid[x][y] == 0 && visited[x][y] == 0){\n                    Q.push(dst);\n                    visited[x][y] = 1;\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                ans += visited[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint count=0;\nvoid move(int x,int y,vector<vector<char> > &room,int w,int h){\n    count++;\n    if(x>0){\n        if(room[x-1][y]=='.'){\n            room[x-1][y]='@';\n            move(x-1,y,room,w,h);\n        }\n    }\n    if(x<h-1){\n        if(room[x+1][y]=='.'){\n            room[x+1][y]='@';\n            move(x+1,y,room,w,h);\n        }\n    }\n    if(y<w-1){\n        if(room[x][y+1]=='.'){\n            room[x][y+1]='@';\n            move(x,y+1,room,w,h);\n        }\n    }\n    if(y>0){\n        if(room[x][y-1]=='.'){\n            room[x][y-1]='@';\n            move(x,y-1,room,w,h);\n        }\n    }\n}\n\nint main(void){\n    int w=1,h=1,x,y;\n    vector<vector<char> > room;\n    while(w|h){\n        count=0;\n        room.clear();\n        cin>>w;\n        cin>>h;\n        if((w|h)==0)break;\n        room.resize(h);\n        for(int i=0;i<h;i++){\n            room[i].resize(w);\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>room[i][j];\n                if(room[i][j]=='@'){\n                    x=i;y=j;\n                }\n            }\n        }\n        move(x,y,room,w,h);\n        cout<<count<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%H;\n\t        int y=cur/H;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[i];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny&&ny<H))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*H);\n  visited[ny][nx]=true;\n\n    }\n   }\n \n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint H,W;\nchar fld[20][20];\nint main(){\n\tqueue<pair<int,int> > p;\n\twhile(cin>>W>>H,H,W){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>fld[j][i];\n\t\t\t\tif(fld[j][i]=='@'){\n\t\t\t\t\tfld[j][i]='#';\n\t\t\t\t\tp.push(make_pair(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=1;\n\t\twhile(!p.empty()){\n\t\t\tint x=p.front().first,y=p.front().second;\n\t\t\tp.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\tif(nx>=0 && nx<W && ny>=0 && ny<H && fld[nx][ny]=='.'){\n\t\t\t\t\tfld[nx][ny]='#';\n\t\t\t\t\tp.push(make_pair(nx,ny));\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint field[20][20];\nint w,h;\nint bfs(int, int);\n\nint main(){\n  int x,y;\n\n  while(cin>>w>>h&&w!=0&&h!=0){\n    for(int j=0;j<h;j++){\n      for(int i=0;i<w;i++){\n        char c;\n        cin >> c;\n        if(c=='.')field[i][j]=1;\n        else if(c=='#')field[i][j]=-1;\n        else if(c=='@'){\n          field[i][j]=0; \n          x=i;\n          y=j;\n        }\n      }\n    }\n    int ans=bfs(x, y);\n    cout << ans+1 << endl;\n  }\n\n  return 0;\n}\n\nint bfs(int x, int y){\n  int count=0;\n  if(y-1>=0&&field[x][y-1]==1){\n    field[x][y-1]=-1;\n    count++;\n    count+=bfs(x, y-1);\n  }\n  if(y+1<h&&field[x][y+1]==1){\n    field[x][y+1]=-1;\n    count++;\n    count+=bfs(x, y+1);\n  }\n  if(x-1>=0&&field[x-1][y]==1){\n    field[x-1][y]=-1;\n    count++;\n    count+=bfs(x-1, y);\n  }\n  if(x+1<w&&field[x+1][y]==1){\n    field[x+1][y]=-1;\n    count++;\n    count+=bfs(x+1, y);\n  }\n  return count;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define MOD 1000000007\n#define REP(i, N) for (int i = 0; i < N; ++i)\n#define REP1(i, N) for (int i = 1; i <= N; ++i)\n#define RREP(i, N) for (int i = N - 1; i >= 0; --i)\n#define ALL(a) a.begin(), a.end()\n\nint w, h;\n\nchar c[20][20];\nbool visit[20][20];\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid dfs(int y, int x) {\n  visit[y][x] = true;\n  REP(i, 4) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (0 <= ny && ny < h && 0 <= nx && nx < w && c[ny][nx] == '.' &&\n        !visit[ny][nx])\n      dfs(ny, nx);\n  }\n}\n\nint main() {\n  while (cin >> w >> h) {\n    if (w == 0 && h == 0) break;\n    REP(i, h) REP(j, w) cin >> c[i][j];\n    REP(i, h) REP(j, w) visit[i][j] = false;\n    REP(i, h) REP(j, w) {\n      if (c[i][j] == '@') dfs(i, j);\n    }\n    int ans = 0;\n    REP(i, h) REP(j, w) {\n      if (visit[i][j]) ans++;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <sstream>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define all(i) i.begin(), i.end()\n#define ll long long\n#define bl bool\n#define nn printf(\"\\n\");\n#define mod 1000000007\n\nusing namespace std;\n\nint w, h, cnt;\nvoid srch(int x, int y, vector<vector<char>> &inp, vector < vector <bool>> &hit)\n{\n\tif (x < 0 || w <= x || y < 0 || h <= y || inp[x][y] == '#') { return; }\n\tif (hit[x][y]) return;\n\thit[x][y] = true;\n\tcnt += 1;\n\tsrch(x + 1, y, inp, hit);\n\tsrch(x - 1, y, inp, hit);\n\tsrch(x, y + 1, inp, hit);\n\tsrch(x, y - 1, inp, hit);\n}\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) { break; }\n\t\tcnt = 0;\n\t\tvector<vector<char>> inp(w, vector<char>(h, 0));\n\t\tvector<vector<bool>> hit(w, vector<bool>(h, false));\n\t\tint x = 0, y = 0;\n\t\trep(i, h)\n\t\t{\n\t\t\trep(j, w)\n\t\t\t{\n\t\t\t\tcin >> inp[j][i];\n\t\t\t\tif (inp[j][i] == '@'){ x = j; y = i; }\n\t\t\t}\n\t\t}\n\t\tsrch(x, y, inp, hit);\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[20][20] = {} ;\nint cnt,w, h, p[20][20] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 400; i++) {\n\t\t\tc[i / 20][i % 20] = p[i / 20][i % 20] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j][i] = 0;\n\t\t\t\t\tp[j][i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j][i] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1 || p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*for (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j][i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h][i%h] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int dm[] = {-1, 0, 1, 0}, dn[] = {0, -1, 0, 1};\nint h, w, count;\nvector< vector<int> > field;\n\nbool valid(int m, int n) {\n    return 0 <= m && m < h && 0 <= n && n < w && field[m][n] == 1;\n}\n\nvoid dfs(int m, int n) {\n    field[m][n] = 0;\n    count++;\n\n    for(int i = 0; i < 4; i++) {\n        if(valid(m + dm[i], n + dn[i])) {\n            dfs(m + dm[i], n + dn[i]);\n        }\n    }\n}\n\nint main() {\n    while(1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        field.resize(h);\n        int m, n;\n        for (int i = 0; i < h; i++) {\n            string input;\n            cin >> input;\n\n            field[i].resize(w);\n\n            for (int j = 0; j < w; j++) {\n                if(input[j] == '@') {\n                    m = i;\n                    n = j;\n                }\n                if(input[j] == '#') {\n                    field[i][j] = 0;\n                } else {\n                    field[i][j] = 1;\n                }\n            }\n        }\n\n        count = 0;\n        dfs(m, n);\n\n        cout << count << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n#define F first\n#define S second\nusing namespace std;\n\nchar c[33][33];\nint w,h;\n\nint solve(int x, int y){\n  typedef pair < int, int > P;\n  queue < P > que;\n  int count = 0;\n\n  que.push( P(x, y) );\n  \n  while(!que.empty()){\n    P q = que.front(); que.pop();\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    for(int i=0;i<4;i++){\n      int xx = dx[i] + q.F;\n      int yy = dy[i] + q.S;\n\n      if(xx < 0 || yy < 0 || xx == w || yy == h) continue;\n      if(c[yy][xx] == '#') continue;\n\n      c[yy][xx] = '#';\n      que.push( P(xx, yy) );\n      count++;\n    }\n\n  }\n\n  return count;\n}\n\nint main(){\n\n  int sx, sy;\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> c[i][j];\n\tif(c[i][j] == '@') sx = j, sy = i;\n      }\n    }\n\n    cout << solve(sx, sy) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\n#include<random>\n#include<ctime>\n#include<set>\nusing namespace std;\n\n\nconst long long int mod=1000000007;\nconst long long int INF=99999999999999999;\n\n\nlong long int h,w;\nstring str[25];\nint main() {\n\tcout << fixed << setprecision(18);\n\tcin>>w>>h;\n\twhile(w!=0){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>str[i];\n\t\t}\n\t\tlong long int start_h,start_w;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[i][j]=='@'){\n\t\t\t\t\tstart_h=i;\n\t\t\t\t\tstart_w=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int num=1;\n\t\tqueue<pair<long long int,long long int> >task;\n\t\ttask.push({start_h,start_w});\n\t\tbool used[25][25]={};\n\t\tused[start_h][start_w]=true;\n\t\twhile(!task.empty()){\n\t\t\tlong long int hnow=task.front().first;\n\t\t\tlong long int wnow=task.front().second;\n\t\t\tif(hnow!=0&&str[hnow-1][wnow]=='.'&&!used[hnow-1][wnow]){\n\t\t\t\tused[hnow-1][wnow]=true;\n\t\t\t\tnum++;\n\t\t\t\ttask.push({hnow-1,wnow});\n\t\t\t}\n\t\t\tif(hnow!=h-1&&str[hnow+1][wnow]=='.'&&!used[hnow+1][wnow]){\n\t\t\t\tused[hnow+1][wnow]=true;\n\t\t\t\tnum++;\n\t\t\t\ttask.push({hnow+1,wnow});\n\t\t\t}\n\t\t\tif(wnow!=0&&str[hnow][wnow-1]=='.'&&!used[hnow][wnow-1]){\n\t\t\t\tused[hnow][wnow-1]=true;\n\t\t\t\tnum++;\n\t\t\t\ttask.push({hnow,wnow-1});\n\t\t\t}\n\t\t\tif(wnow!=w-1&&str[hnow][wnow+1]=='.'&&!used[hnow][wnow+1]){\n\t\t\t\tused[hnow][wnow+1]=true;\n\t\t\t\tnum++;\n\t\t\t\ttask.push({hnow,wnow+1});\n\t\t\t}\n\t\t\t//cout<<\"DEBUG\"<<hnow<<\" \"<<wnow<<endl;\n\t\t\ttask.pop();\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t//cout<<used[i][j]<<\" \";\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<num<<endl;\n\t\tcin>>w>>h;\n\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar mas[20][20];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint sx,sy;\nint w,h,cnt;\n\nvoid dfs(int x,int y);\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>mas[i][j];\n\tif(mas[i][j]=='@'){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    cnt=0;\n    dfs(sx,sy);\n    cout<<cnt<<endl;\n  }\n}\n\nvoid dfs(int x,int y){\n  mas[y][x]='#';\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nextx=x+dx[i];\n    int nexty=y+dy[i];\n    if(0<=nextx && nextx<w && 0<=nexty && nexty<h && mas[nexty][nextx]=='.'){\n      dfs(nextx,nexty);\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y, int x, vector<string> &g){\n  if(g[y][x] == '#')return 0;\n  g[y][x] = '#';\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=(int)g.size() || nx>=(int)g[0].size())continue;\n    res += dfs(ny,nx,g);\n  }\n  return res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n\n    vector<string> g(h);\n    int y=0,x=0;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == '@')y = i, x = j;\n      }\n    }\n\n    cout << dfs(y,x,g) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\nint mod(ll a){\n    int c=a%1000000007;\n    if(c>=0)return c;\n    else return c+1000000007;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\n#define inf 100000000/*10^8*/\n\n/////////////////////////////////\n\nint w,h;\nint si,sj;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint room[25][25];\nint ans=0;\nint dfs(int x,int y){\n    room[x][y]=2;ans++;\n    for(int i=0;i<=3;i++){\n        int xx=x+dx[i],yy=y+dy[i];\n        if(0<=xx&&xx<=h-1&&0<=yy&&yy<=w-1&&room[xx][yy]==0)dfs(xx,yy);\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0)break;\n        ans=0;\n        for(int i=0;i<=h-1;i++){\n            char s[w+1];cin>>s;\n            for(int j=0;j<=w-1;j++){\n                if(s[j]=='.')room[i][j]=0;\n                else if(s[j]=='#')room[i][j]=1;\n                else if(s[j]=='@')room[i][j]=2,si=i,sj=j;\n            }\n        }\n       /* cout<<dfs(si,sj)<<endl;*/\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint w,h;\nint ret;\nchar f[32][32];\nbool visited[32][32];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(!(h|w)) break;\n\t\tint x, y;\n\t\tdeque<pair<int,int> > q;\n\t\tfill((char *)f, (char *)f+32*32, '#');\n\t\tfill((bool *)visited, (bool *)visited+32*32, false);\n\t\tret = 0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j] == '@'){\n\t\t\t\t\t\tq.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tx = q.front().first;\n\t\t\ty = q.front().second;\n\t\t\tq.pop_front();\n\t\t\tvisited[x][y] = true;\n\t\t\tret++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(f[x+dx[i]][y+dy[i]] == '.' &&\n\t\t\t\t   visited[x+dx[i]][y+dy[i]] == false &&\n\t\t\t\tfind(q.begin(),q.end(),make_pair(x+dx[i], y+dy[i])) == q.end()){\n\t\t\t\t\tq.push_back(make_pair(x+dx[i], y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint W,H;\n\nvoid dfs(vector<string> &field, vector<vector<bool> > &move,int now_x, int now_y)\n{\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\n\tif(now_x < 0 || now_x >= W || now_y < 0 || now_y >= H){ return; }\n\t\n\tif(field[now_y][now_x] == '#'){ return; }\n\n\tif(move[now_y][now_x]){ return; }\n\n\tmove[now_y][now_x] = true;\n\n\trep(i,4){\n\t\tdfs(field, move, now_x+dx[i], now_y+dy[i]);\n\t}\n\n\treturn;\n}\n\nint main() {\n\n\twhile(cin >> W >> H && W && H)\n\t{\n\n\t\tvector<string> field(H);\n\t\tvector<vector<bool> > move(H, vector<bool>(W,false));\n\n\t\trep(y,H){\n\t\t\tcin >> field[y];\n\t\t}\n\n\t\tpair<int, int> start;\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\tif(field[y][x] == '@'){start = make_pair(x,y);}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tdfs(field, move, start.first, start.second);\n\n\t\tint count=0;\n\t\trep(y,H){\n\t\t\trep(x,W){\n\t\t\t\tif(move[y][x]){ count++; }\n\t\t\t}\n\t\t}\n\n\t\tcout << count << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0 && h==0)break;\n        int sx,sy;\n        int sum=0;\n        int dy[]={-1,0,1,0};\n        int dx[]={0,-1,0,1};\n    \n    \n        string data[30]={};\n    \n        for(int i=0;i<h;i++){\n            cin>>data[i];\n        }\n    \n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(data[i][j]=='@'){\n                    sx=j;sy=i;\n                    break;\n                }\n            }\n        }\n    \n        bool visited[30][30]={};\n//        rep(i,30)rep(j,30)visited[i][j]=false;\n        \n    \n        queue<pair<int,int> > que;\n    \n        que.push( pair<int,int>(sy,sx) );\n        visited[sy][sx]=true;\n    \n        while(que.size()){\n            int qff=que.front().first,qfs=que.front().second;\n            sum++;\n            rep(i,4){\n                if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false && data[ qff+dy[i] ][ qfs+dx[i] ]!='#' ){\n                    que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                    visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n                }\n            }\n            \n            que.pop();\n        }\n        cout<<sum<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n \nint w, h;\n \nint dfs(int y, int x, vector<string> &v){\n  int my[] = {-1,0,1,0};\n  int mx[] = {0,-1,0,1};\n  int ret = 1;\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(0<=ny&&ny<h&&0<=nx&&nx<w && v[ny][nx] == '.'){\n      v[ny][nx] = '#';\n      ret += dfs(ny, nx, v);\n    }\n  }\n  return ret;\n}\n \nint main(){\n  while(cin >>w >>h && w){\n    vector<string> v(h);\n    REP(i, h) cin >>v[i];\n    REP(i, h) REP(j, w) if(v[i][j] == '@') cout <<dfs(i, j, v) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct node{\n  node(){};\n  int x,y;\n  node(int y,int x):y(y),x(x){}\n};\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint main(){\n  int w,h,i,j;\n  while(cin >> w >> h && w){\n    char tile[h][w];\n    int ans = 0;\n    struct node now,next;\n    queue<struct node> que;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        cin >> tile[i][j];\n        if(tile[i][j]=='@'){\n          que.push(node(i,j));\n          tile[i][j]='#';\n        }\n      }\n    }\n    while(!que.empty()){\n      now = que.front();\n      ans++;\n      que.pop();\n      for(i=0;i<4;i++){\n        int ddx = dx[i] + now.x;\n        int ddy = dy[i] + now.y;\n        if(ddx>w-1 || ddx<0 || ddy>h-1 || ddy<0)continue;\n        if(tile[ddy][ddx]=='.'){\n          que.push(node(ddy,ddx));\n          tile[ddy][ddx] = '#';\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nstruct P {\n    using T = int;\n    T y, x;\n\n    P(T _y = 0, T _x = 0) :y(_y), x(_x) {}\n\n    inline bool operator == (P p) const { return y == p.y && x == p.x; }\n    inline bool operator < (P p) const { return y == p.y ? x < p.x : y < p.y; }\n    inline P operator+(P p) const { return P(y + p.y, x + p.x); }\n    inline P operator-(P p) const { return P(y - p.y, x - p.x); }\n    inline P operator+=(P p) { y += p.y; x += p.x; return *this; }\n    inline P operator-=(P p) { y -= p.y; x -= p.x; return *this; }\n};\n\n\n\ntemplate<typename T>\n// using T = int;\nstruct F {\n    int height, width;\n    vector<T> data;\n\n    F(int h = 1, int w = 1) :height(h), width(w), data(h*w) {}\n\n    inline T& operator()(int y, int x) { return data[x + y * width]; }\n    inline T& operator()(P p) { return data[p.x + p.y * width]; }\n    inline T operator()(int y, int x) const { return data[x + y * width]; }\n    inline T operator()(P p) const { return data[p.x + p.y * width]; }\n\n    inline bool safe(int y, int x) const { return 0 <= y && y < height && 0 <= x && x < width; }\n    inline bool safe(P p) const { return 0 <= p.y && p.y < height && 0 <= p.x && p.x < width; }\n\n    inline void fill(T e) { std::fill(ALL(data), e); }\n    inline void resize(int h, int w) { height = h; width = w; data.resize(h*w); }\n\n    void print(ostream& os, int setw_arg = 4) {\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x)\n                os << setw(setw_arg) << operator()(y, x) << ' ';\n            os << '\\n';\n        }\n    }\n};\n\n\nint moving[][2] = { {0,1},{1,0},{-1,0},{0,1} };\n\n\nint solve() {\n    int H, W;\n    scanner >> H >> W;\n\n    if (H == 0 && W == 0) return 1;\n\n    F<int> field(H, W);\n    P start;\n\n    repeat(y, H) {\n        string str;\n        scanner >> str;\n        repeat(x, W) {\n            field(y, x) = !(str[x] == '#');\n            if (str[x] == '@') start = P(y, x);\n        }\n    }\n\n    queue<P> q;\n    q.push(start);\n\n    ll ans = 1;\n\n    while (!q.empty()) {\n        P p = q.front(); q.pop();\n        for (auto mv : moving) {\n            int vy = mv[0], vx = mv[1];\n            if (field.safe(p + P(vy, vx)) && field(p + P(vy, vx))) {\n                q.push(p + P(vy, vx));\n                ans += 1;\n                field(p + P(vy, vx)) = 0;\n            }\n        }\n    }\n\n    printer << ans << endl;\n    return 0;\n}\n\n\nint main() {\n\n    while (!solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar fe[20][20];\nint flag[20][20];\nint W, H;\n\nvoid dfs(int x, int y){\n\n  if(flag[y][x] == 1) return;\n\n  //  cout << x << \" \" << y << endl;\n\n  flag[y][x] = 1;\n\n  if(fe[y+1][x] == '.' && y < H-1) dfs(x, y+1);\n  if(fe[y-1][x] == '.' && y > 0) dfs(x, y-1);\n  if(fe[y][x+1] == '.' && x < W-1) dfs(x+1, y);\n  if(fe[y][x-1] == '.' && x > 0) dfs(x-1, y);\n\n\n}\n\nint main(){\n\n  while(cin >> W >> H && (W || H)){\n\n    memset(flag,0,sizeof(flag));\n\n    int x, y, cnt = 0;\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> fe[i][j];\n\tif(fe[i][j] == '@'){\n\t  x = j; \n\t  y = i;\n\t}\n      }\n    }\n\n    dfs(x, y);\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tif(flag[i][j] == 1) cnt++;\n      }\n    }\n    //  cout << x << \" \" << y << endl;\n    cout << cnt << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h;\nchar tail[21][21];\nint a[]={-1,0,1,0};\nint b[]={0,1,0,-1};\nint cnt=0;\nvoid func(int x,int y);\nmain(){\n  int sx,sy;\n  while(cin>> w>> h){\n    cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>> tail[i][j];\n\tif(tail[i][j]=='@'){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    func(sx,sy);\n    cout<< cnt<< endl;\n  }\n}\n\nvoid func(int x,int y){\n  tail[y][x]='#';\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nx=x+a[i];\n    int ny=y+b[i];\n    if(nx>=0 && nx<w && ny>=0 && ny<h && tail[ny][nx]!='#'){\n      func(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N+1];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\tmemset(memo,0, sizeof(memo));\n\t//for (int i = 0; i < y; i++) {\n\t\t//for (int j = 0; j < x; j++) {\n\t\t\t//memo[i][j] = 0;\n\t//\t}\n\t//}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nint cnt = 0;\nint W, H;\n\nvoid search(char data[][22], int self_i, int self_j) {\n  //  printf(\"self_i = %d  self_j = %d\\n\", self_i, self_j);\n  data[self_i][self_j] = '#';\n  cnt++;\n  if (self_i-1 >= 0 && data[self_i-1][self_j] == '.') {\n\tsearch(data, self_i-1, self_j);\n  }\n  if (self_j-1 >= 0 && data[self_i][self_j-1] == '.') {\n\tsearch(data, self_i, self_j-1);\n  }\n  if (self_j+1 <= W && data[self_i][self_j+1] == '.') {\n\tsearch(data, self_i, self_j+1);\n  }\n  if (self_i+1 <= H && data[self_i+1][self_j] == '.') {\n\tsearch(data, self_i+1, self_j);\n  }\n}\n\nint main(void) {\n  while(1) {\n\tcnt = 0;\n\tscanf(\"%d%d\", &W, &H);\n\tif (W == H && W == 0) break;\n\tchar data[22][22] = {{0}};\n\tfor (int i = 0; i < H; i++) {\n\t  scanf(\"%s\", data[i]);\n\t}\n\tint self_i, self_j;\n\tfor (int i = 0; i < H; i++) {\n\t  for (int j = 0; j < W; j++) {\n\t\tif (data[i][j] == '@') {\n\t\t  self_j = j;\n\t\t  self_i = i;\n\t\t  goto L1;\n\t\t}\n\t  }\n\t}\n  L1:\n\tsearch(data, self_i, self_j);\n\tprintf(\"%d\\n\", cnt);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[20][21];\nint h, w, n;\nvoid dfs(int x, int y)\n{\n\tint i, j, nx, ny, dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\tm[y][x] = '#';\n\tn++;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tnx = x + dx[i];\n\t\tny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && m[ny][nx] == '.') dfs(nx, ny);\n\t}\n\treturn;\n}\nint main()\n{\n\tint i, j;\n\twhile (cin >> w >> h)\n\t{\n\t\tif (h == 0 && w == 0) break;\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> m[i];\n\t\t\tif (cin.eof()) return 0;\n\t\t}\n\t\tn = 0;\n\t\tfor (i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (m[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << n << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "1>------ テ」ツδ禿」ツδォテ」ツδ嘉ゥツ鳴凝・ツァツ? テ」ツδ療」ツδュテ」ツつクテ」ツつァテ」ツつッテ」ツδ?4_3, テヲツァツ凝ヲツ按?Debug Win32 ------\n1>  Source3.cpp\n1>  4_3.vcxproj -> C:\\Users\\hokiken\\Documents\\programming\\contest5\\Debug\\4_3.exe\n========== テ」ツδ禿」ツδォテ」ツδ? 1 テヲツュツ」テ・ツクツクテァツオツづ、ツコツ?」ツ?? テ・ツ、ツアテヲツ閉療」ツ?? テヲツ崢エテヲツ鳴ーテ、ツクツ催ィツヲツ?」ツ?? テ」ツつケテ」ツつュテ」ツδε」ツδ?=========="
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\n\nusing namespace std;\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int _x, int _y) :x(_x), y(_y){}\n};\n\nchar tile[20][20];\nstack<point> st;\n\nint main()\n{\n\tcin.tie(0); ios::sync_with_stdio(false); \n\tfstream fs(\"input.txt\");\n\t////////////ここから開始///////////\n\n\t\n\tint x(-1), y(-1);\n\twhile (true){\n\t\tREP(i, 20)REP(j, 20)tile[i][j] = '#';\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)\n\t\t\tbreak;\n\t\t//fs >> x >> y;\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\t//fs >> tile[i][j];\n\t\t\t}\n\t\t}\n\n\t\tREP(i, y){\n\t\t\tREP(j, x){\n\t\t\t\tif (tile[i][j] == '@')\n\t\t\t\t\tst.emplace(i, j);\n\t\t\t}\n\t\t}\n\n\t\tint dx[]{0, 1, 0, -1};\n\t\tint dy[]{1, 0, -1, 0};\n\t\tint ans(1);\n\n\t\twhile (!st.empty()){\n\t\t\tpoint now = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4){\n\t\t\t\tint x1 = now.x + dx[i];\n\t\t\t\tint y1 = now.y + dy[i];\n\t\t\t\tif (x1 > 19 || x1 < 0 || y1 > 19 || y1 < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tile[x1][y1] == '.'){\n\t\t\t\t\tst.emplace(x1, y1);\n\t\t\t\t\ttile[x1][y1] = '#';\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfs << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, j, n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(),i.rend()\n#define inf 1e9\n#define Puts(x) puts(x? \"Yes\":\"No\")\nconst int mod = 1e9 + 7;\n\nint gcd(int n, int m) {return (m == 0? n : gcd(m, n % m));}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\ntypedef pair<int, int> pi;\ntypedef long long i64;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\nint w, h;\nint cou;\n\nvoid dfs(int y, int x, auto &grid, auto &visited) {\n  if(!grid[y][x] || visited[y][x]) return;\n\n  cou++;\n  visited[y][x] = true;\n  rep(i, 0, 4) {\n    dfs(y + dy[i], x + dx[i], grid, visited);\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(cin >> w >> h, w && h) {\n    vvt<bool> grid(h + 2, vt<bool>(w + 2, false));\n    vvt<bool> visited(h + 2, vt<bool>(w + 2, false));\n    int sx, sy;\n\n    rep(i, 0, h) {\n      string s;\n      cin >> s;\n      rep(j, 0, w) {\n        if(s[j] == '.') grid[i + 1][j + 1] = true;\n        if(s[j] == '@') {\n          sx = j + 1;\n          sy = i + 1;\n          grid[sy][sx] = true;\n        }\n      }\n    }\n\n    cou = 0;\n    dfs(sy, sx, grid, visited);\n    cout << cou << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n#define ISIN(x, y) ((x) >= 0 && (x) < (w) && (y) >= 0 && (y) < (h))\n\nint main(void)\n{\n\tchar s[100][100];\n\tchar f[100][100];\n\tint w, h;\n\tint px, py;\n\tint count, ago;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif (w == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tscanf(\"%s\", s[y]);\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (s[y][x] == '@'){\n\t\t\t\t\tpx = x;\n\t\t\t\t\tpy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tago = count = 1;\n\t\tmemset(f, 0, sizeof(f));\n\t\tf[py][px] = 1;\n\t\tdo {\n\t\t\tago = count;\n\t\t\tfor (int y = 0; y < h; y++){\n\t\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\t\tif (f[y][x] == 1){\n\t\t\t\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tif (s[y + dy[i]][x + dx[i]] != '#' && f[y + dy[i]][x + dx[i]] == 0 && ISIN(x + dx[i], y + dy[i])){\n\t\t\t\t\t\t\t\tf[y + dy[i]][x + dx[i]] = 1;\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (ago != count);\n\t\t\n\t\tprintf(\"%d\\n\", count);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,n) for(int i=(a); i<(n); i++)\n#define all(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nvector<string> mat;\nvector<vector<bool>> seen;\nint h, w;\n\nconst int dh[4] = {-1, 0, 1, 0};\nconst int dw[4] = {0, -1, 0, 1};\n\nvoid dfs(int sh, int sw) {\n    seen[sh][sw] = true;\n    rep(i, 4) {\n        int nh = sh+dh[i], nw = sw+dw[i];\n        if (nh<0 || nh>h-1 || nw<0 || nw>w-1) continue;\n        if (seen[nh][nw]) continue;\n        if (mat[nh][nw] == '#') continue;\n        dfs(nh, nw);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    \n    while(true) {\n        cin >> w >> h;\n        if (w+h == 0) break;\n        mat.clear();\n        rep(i, h) {\n            string s; cin >> s;\n            mat.push_back(s);\n        }\n\n        int sh, sw;\n        rep(i, h) rep(j, w) if (mat[i][j]=='@') sh=i, sw=j;\n\n        seen.assign(h, vector<bool>(w, false));\n        dfs(sh, sw);\n\n        int ans = 0;\n        rep(i, h) rep(j, w) if(seen[i][j]) ans++;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[21][21];\nbool used[20][20];\nint W, H;\n\nint rec(int i, int j){\n\n   if(fld[i][j]=='#') return 0;\n   if(used[i][j]) return 0;\n   used[i][j]=true;\n   int ret=0;\n   for(pii dd: dxdy){\n      int ni=i+dd.first;\n      int nj=j+dd.second;\n      if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n      ret+=rec(ni, nj);\n   }\n\n   return ret+1;\n}\n\nint main(){\n\n   while(1){\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n               fld[i][j]='.';\n            }\n         }\n      }\n\n      for(int i=0; i<20; i++)for(int j=0; j<20; j++) used[i][j]=false;\n      cout<< rec(sy, sx)<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint ch[23][23],cnt;\nint dfs(int,int);\nint main(){\n  int w,h,i,j,k,l,result;\n  string in[21];\n  while(1){\n    cnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> in[i];\n    }\n    for(i=0;i<h+2;i++){\n      for(j=0;j<w+2;j++){\n\tch[i][j]=1;\n      }\n    }\n    for(i=0,k=1;k<h+1;i++,k++){\n      for(j=0,l=1;l<w+1;l++,j++){\n\tif(in[i][j]=='.') ch[k][l]=0;\n\telse if(in[i][j]=='#') ch[k][l]=1;\n\telse ch[k][l]=2;\n      }\n    }\n    for(i=1;i<h;i++){\n      for(j=1;j<w;j++){\n\tif(ch[i][j]==2) result=dfs(i,j);\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nint dfs(int i,int j){\n  if(ch[i][j]==1) return 0;\n  ch[i][j]=1;\n  cnt++;\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j-1);\n  dfs(i,j+1);\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst char RED_TILE = '#';\nconst char AT_TILE = '@';\n\nint vx[4] = {0,1,0,-1};\nint vy[4] = {-1,0,1,0};\n\nint w,h;\nint visited[20][20];\nint map[20][20];\n\nint search(int x, int y){\n\tint count = 1;\n\tvisited[x][y] = true;\n\tfor (int i=0;i<4;++i){\n\t\tint tx=x+vx[i];\n\t\tint ty=y+vy[i];\n\t\tif (tx<0 || tx>=w || ty<0 || ty>=h) continue;\n\t\tif (!visited[tx][ty] && map[tx][ty]){\n\t\t\tcount += search(tx,ty);\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\twhile (true){\n\t\tcin >> w >> h;\n\t\tif (w==0 && h==0) break;\n\t\tint sx, sy;\n\t\tfor (int i=0;i<h;++i){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int l=0;l<w;++l){\n\t\t\t\tif (s[l] == RED_TILE) {\n\t\t\t\t\tmap[l][i] = false;\n\t\t\t\t} else if (s[l] == AT_TILE) {\n\t\t\t\t\tmap[l][i] = true;\n\t\t\t\t\tsx = l;\n\t\t\t\t\tsy = i;\n\t\t\t\t} else {\n\t\t\t\t\tmap[l][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<20;++i) for (int l=0;l<20;++l) visited[i][l]=false;\n\t\tint result = search(sx,sy);\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\n\n#define MAX_W 20\n#define MAX_H 20\nint W, H;\nint sx, sy;\nchar maze[MAX_H][MAX_W];\n\nvector<int> ans_list;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint solve(int x, int y){\n  int tmp = 1;\n  maze[y][x] = '#';\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < W && ny >= 0 && ny < H && maze[ny][nx] != '#'){\n      tmp += solve(nx, ny);\n    }\n  }\n  return tmp;\n}\n\nint main(){\n\n  while(true){\n    \n    cin >> W >> H;\n    if(W == 0 && H == 0)\n      break;\n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tcin >> maze[i][j];\n\tif(maze[i][j] == '@'){\n\t  sy = i;\n\t  sx = j;\n\t}\n      }\n    }\n\n    ans_list.push_back(solve(sx, sy));\n    \n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\nchar maze[25][25];\nbool visited[25][25];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint W,H,ans;\n\nvoid init()\n{\n\trep(i,25)\n\t{\n\t\trep(j,25)\n\t\t{\n\t\t\tvisited[i][j] = false;\n\t\t}\n\t}\n}\n\nvoid dfs(int x, int y)\n{\n\tvisited[x][y] = true;\n\tans++;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint x2 = x + dx[i];\n\t\tint y2 = y + dy[i];\n\n\t\tif (x2 >= 0 && x2 < H && y2 >= 0 && y2 < W)\n\t\t{\n\t\t\tif (!visited[x2][y2] && maze[x2][y2] != '#')\n\t\t\t{\n\t\t\t\tdfs(x2,y2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tans = 0;\n\t\tint si,sj;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) return 0;\n\t\trep(i,H)\n\t\t{\n\t\t\trep(j,W)\n\t\t\t{\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinit();\n\n\t\tdfs(si,sj);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<tuple>\n#include<utility>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<iomanip>\n#include<map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\nint dx[8] = { 1,0,-1,0,1,1,-1,-1 };\nint dy[8] = { 0,1,0,-1,1,-1,1,-1 };\n\nint w, h;\nint cnt = 0;\nchar s[55][55];\nvoid dfs(int y, int x) {\n\n\ts[y][x] = '#';\n\tcnt++;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w && s[ny][nx] == '.') {\n\t\t\tdfs(ny, nx);\n\t\t}\n\n\n\t}\n\n\n}\n\n\n\nint main() {\n\tint sy ;\n\tint\tsx ;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> s[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(sy, sx);\n\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm> \n#include <queue>\n#include <functional>\n#include <map>\n#include <string>\nusing namespace std;\nint w, h;\nchar field[25][25];\nbool used[25][25];\nint vx[] = { 1, 0, -1, 0 };\nint vy[] = { 0, 1, 0, -1 };\n\nint dfs(int x,int y){\n    \n    int ret = 1;\n    used[x][y] = true;\n\n    for (int i = 0; i < 4; i++){\n        int nx, ny;\n        nx = x + vx[i]; ny = y + vy[i];\n        if (nx != 0 && nx != w + 1 && ny != 0 && ny != h + 1 && field[nx][ny] != '#'&&\n            !used[nx][ny]){\n            ret += dfs(nx, ny);\n        }\n    }\n\n    return ret;\n}\n\nint main(void){\n\n    while (true){\n        cin >> w >> h;\n        if (w == 0 && h == 0)break;\n        for (int i = 1; i <= w; i++){\n            for (int j = 1; j <= h; j++){\n                used[i][j] = false;\n            }\n        }\n        int sx, sy;\n        for (int i = 1; i <= h; i++){\n            for (int j = 1; j <= w; j++){\n                cin >> field[j][i];\n                if (field[j][i] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        int ans;\n        ans = dfs(sx, sy);\n        cout << ans << endl;\n        \n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\n  if(y!=0)\n    if(a[y-1][x]=='.')\n      dfs(y-1,x);\n  if(y!=20)\n    if(a[y+1][x]=='.')\n      dfs(y+1,x);\n  if(x!=0)\n    if(a[y][x-1]=='.')\n      dfs(y,x-1);\n  if(x!=20)\n    if(a[y][x+1]=='.')\n      dfs(y,x+1);\n}\nint main(){\n  int w,h,i,j;\n  char b[21];\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n\tscanf(\"%s\",b);\n\tfor(j=0;b[j]!='\\0';j++){\n\t  a[i][j]=b[j];\n\t}\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w;\nvvi a;\n\nint dfs(int x,int y){\n\tint t=1;\n\ta[x][y]++;\n\tfor(int i=0;i<4;i++){\n\t\tint X=x+dx[i],Y=y+dy[i];\n\t\tif(!a[X][Y]) t+=dfs(X,Y);\n\t}\n\treturn t;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(!h) break;\n\t\tint s,t;\n\t\ta=vvi(h+2,vi(w+2,1));\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c!='#') a[i][j]--;\n\t\t\tif(c=='@') s=i,t=j;\n\t\t}\n\t\tcout<<dfs(s,t)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nqueue<pair<int,int> > M;\nint W,H;\nint q[20+5][20+5] = {};\t\nchar p[20+5][20+5];\nint counter;\nint x,y;\nint main() {\n\twhile(cin >> W >> H && W != 0){\n\t\tcounter = 0;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@' ){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcounter = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tx = M.front().first;\n\t\t\ty = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t{\t\t\n\t\t\t\tif (p[x+dx[k]][y+dy[k]] == '.' && q[x+dx[k]][y+dy[k]] == 0)\n\t\t\t\t{\n\t\t\t\t\tM.push(make_pair(x+dx[k], y+dy[k]));\n\t\t\t\t\tq[x+dx[k]][y+dy[k]] = 1;\n\t\t\t\t\tcounter += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nbool tile[20][20];\nbool visited[20][20];\n\nvoid visit(int x, int y) {\n  visited[y][x] = true;\n  if (x > 0 && tile[y][x-1] && !visited[y][x-1]) visit(x-1, y);\n  if (x < 19 && tile[y][x+1] && !visited[y][x+1]) visit(x+1, y);\n  if (y > 0 && tile[y-1][x] && !visited[y-1][x]) visit(x, y-1);\n  if (y < 19 && tile[y+1][x] && !visited[y+1][x]) visit(x, y+1);\n}\n\nint main() {\n  int w, h, x, y, count;\n  string tmp;\n  while (cin >> w >> h, w | h) {\n    for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n        visited[i][j] = false;\n        tile[i][j] = false;\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      cin >> tmp;\n      for (int j = 0; j < w; j++) {\n        if (tmp[j] == '.') {\n          tile[i][j] = true;\n        } else if (tmp[j] == '@') {\n          x = j;\n          y = i;\n          tile[i][j] = true;\n        }\n      }\n    }\n    visit(x, y);\n    count = 0;\n    for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n        if (visited[i][j]) count++;\n      }\n    }\n    cout << count << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint x, y;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '@')\n\t\t\t{\n\t\t\t\tx = i, y = j;\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tqueue<pii> que;\n\t\tque.push(pii(x, y));\n\t\tint cnt = 0;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint tx = que.front().first, ty = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (fld[tx][ty] == '.')\n\t\t\t{\n\t\t\t\tfld[tx][ty] = '$';\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] == '.')\n\t\t\t\t{\n\t\t\t\t\tque.push(pii(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint check[25][25];\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        char tile[23][23];\n        queue<P> black;\n        int ans = 0;\n        for(int i = 0;i < h;i++){\n            cin >> tile[i];\n            for(int j = 0;j < w;j++){\n                check[i][j] = 0;\n                if(tile[i][j] == '@'){\n                    black.push(P(i,j));\n                }\n            }\n        }\n        while(!black.empty()){\n            P q = black.front(); black.pop();\n            if(check[q.fs][q.sc] != 0) continue;\n            ans++;\n            check[q.fs][q.sc] = 1;\n            for(int i = 0;i < 4;i++){\n                int ni = q.fs+dx[i];\n                int nj = q.sc+dy[i];\n                if( min(ni,nj) >= 0 && ni < h && nj < w && check[ni][nj] == 0 && tile[ni][nj] == '.'){\n                    black.push(P(ni,nj));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\n\n\nvoid dfs(int y,int x){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif((x<0||y<0)||t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(y+dy[k],x+dx[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\n\tint w,h,sx,sy,cnt;\n\trep(i,20)rep(j,20){\nt[i][j]=='#';\t\n\t}\n\nwhile(true){\nscanf(\"%d %d\",&w,&h);\nif(!w&&!h) {break;}\nrep(i,h){\ncin >> t[i];\n}\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\ndfs(sy,sx);\ncnt =0;\n\nrep(i,h){ \n\trep(j,w)if(t[i][j]=='@') cnt++;\t\n}\n\ncout <<endl<<cnt;;\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][22],int b[][22],int x,int y){\n  int sm=0;\n  if(b[x][y]==0&&a[x][y]!=-1){\n    b[x][y]=1;\n    sm++;\n    sm+=f(a,b,x-1,y);\n    sm+=f(a,b,x,y-1);\n    sm+=f(a,b,x+1,y);\n    sm+=f(a,b,x,y+1);\n  }\n  return sm;\n}\nint main(){\n  int i,j;\n  int a[22][22],b[22][22],x,y,w,h;\n  char c;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>c;\n\tif(c=='#')\n\t  a[j+1][i+1]=-1;\n\telse{\n\t  a[j+1][i+1]=0;\n\t  if(c=='@'){\n\t    x=j+1;\n\t    y=i+1;\n\t  }\n\t}\n      }\n    }\n    memset(b,0,sizeof(b));\n    cout<<f(a,b,x,y)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\nint w,h;\nstring matrix[20];\n\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nbool valid(int x,int y)\n{\n    return x>=0&&x<w&&y>=0&&y<h&&matrix[x][y]!='#';\n}\nint main()\n{\n    while(true)\n    {\n        queue<pair<int,int> > q;\n        pair<int,int> man;\n        int amount=0;\n        \n        cin>>w>>h;\n        if(w==0&&h==0)\n            break;\n        for(int i=0;i<h;i++)\n        {\n            cin>>matrix[i];\n        }\n        \n        for(int i=0;i<h;i++)\n        {\n            for(int j=0;j<w;j++)\n            {\n                if(matrix[i][j]=='@')\n                {\n                    man.first=i;\n                    man.second=j;\n                }\n            }\n        }\n        \n        q.push(man);\n        while(!q.empty())\n        {\n            pair<int,int> current;\n            current=q.front();\n            q.pop();\n            \n            for(int i=0;i<4;i++)\n            {\n                if(valid(current.first+dx[i],current.second+dy[i]))\n                {\n                    q.push(make_pair(current.first+dx[i],current.second+dy[i]));\n                    amount++;\n                }\n            }\n            \n            matrix[current.first][current.second]='#';\n        }\n        \n        cout<<amount<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <fstream>\nusing namespace std;\n\nint main(){\n  //std::ifstream in(\"input.txt\");\n  //std::cin.rdbuf(in.rdbuf());\n  int ans[1024] = {0};\n  int dataCounter = 0;\n  int i = 0;\n  while(1){\n    int visited[20][20] = {0};\n    int data[20][20];\n    int x,y;\n    int w = 0;\n    int h = 0;\n    queue<int> xst;\n    queue<int> yst;\n    cin >> w;\n    cin >> h;\n    if(w == 0 && h == 0) break;\n    for(i=0;i<h;i++){\n      int inputCounter = 0;\n      char d;\n      while(cin >> d){\n        if(d == '.')\n          data[i][inputCounter] = 0;\n        else if(d == '#')\n          data[i][inputCounter] = 1;\n        else if(d == '@'){\n          data[i][inputCounter] = 2;\n          x = inputCounter;\n          y = i;\n        }\n        if(inputCounter == w-1)break;\n        inputCounter++;\n      }\n    }\n    int j=0;\n    xst.push(x);\n    yst.push(y);\n    while(!xst.empty()){\n      x = xst.front();\n      y = yst.front();\n      xst.pop();\n      yst.pop();\n      if(x < 0 || w <= x || y < 0 || h <= y)continue;\n      if(visited[y][x]==1 || data[y][x] == 1)continue;\n      visited[y][x] = 1;\n      ans[dataCounter]++;\n      xst.push(x+1);\n      yst.push(y);\n      xst.push(x);\n      yst.push(y+1);\n      xst.push(x-1);\n      yst.push(y);\n      xst.push(x);\n      yst.push(y-1);\n    }\n\n    dataCounter++;\n  }\n  for(i=0;i<dataCounter;i++){\n    cout << ans[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nvoid rec(int x,int y);\nchar map[30][30];\nbool isVisit[30][30];\nint count=0;\n//start_pos\nint start_x;\nint start_y;\nint h,w;\n\nint main()\n{\n    while (cin >> w >> h) \n    {\n        count = 0;\n        //start pos\n        int start_x;\n        int start_y;\n\n        for (int i = 0; i < h; i++) \n        {\n            for (int j = 0; j < w; j++) \n            {\n                cin >> map[j][i];\n                if (map[j][i] == '@') \n                {\n                    start_x=j;\n                    start_y=i;\n                }\n                //ついでにisVisit初期化\n                isVisit[j][i]=false;\n            }\n        }\n        rec(start_x,start_y);\n        cout <<count<<endl;\n    }\n\n}\n\nvoid rec(int x,int y)\n{\n    if ( y<0 || x<0 || h<=y || w<=x) {return;}\n    if ( map[x][y] == '#') {return;}\n    if (isVisit[x][y]) { return;}\n    isVisit[x][y] = true;\n    count++;\n\n    rec(x, y-1);\n    rec(x+1, y);\n    rec(x, y+1);\n    rec(x-1, y);\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint m,n,ans;\nchar ice[22][22];\n\nvoid saiki(int w,int h){\n\tice[w][h]='*';\n\t\n\tif(ice[w+1][h]=='.')saiki(w+1,h);\n\tif(ice[w][h+1]=='.')saiki(w,h+1);\n\tif(w!=0)if(ice[w-1][h]=='.')saiki(w-1,h);\n\tif(h!=0)if(ice[w][h-1]=='.')saiki(w,h-1);\n}\n\nint main(void){\n\n\tfor(;;){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(!m||!n)break;\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",&ice[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i][j]=='@')saiki(i,j);\n\t\t\t}\n\t\t}\n\t\t//puts(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//printf(\"%s\\n\",ice[i+1]);\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i][j]=='*')ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint W, H;\nchar Map[25][25];\nint d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n\nint dfs(int x, int y){\n\tif(Map[y][x] == '#') return 0;\n\tMap[y][x] = '#';\n\tint ret = 1;\n\tfor(int i=0;i<4;i++){\n\t\tret += dfs(x+d[i][1],y+d[i][0]);\n\t}\n\treturn ret;\n}\nmain(){\n\tint i,j;\n\twhile(cin >> W >> H, W){\n\t\tint sx, sy;\n\t\tfor(i=0;i<=H+1;i++)\n\t\t\tfor(j=0;j<=W+1;j++)\n\t\t\t\tMap[i][j] = '#';\n\t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tcin >> Map[i][j];\n\t\t\t\tif(Map[i][j] == '@'){\n\t\t\t\t\tsx = j;sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N+1];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\tmemset(memo,0, sizeof(memo));\n\t//for (int i = 0; i < y; i++) {\n\t\t//for (int j = 0; j < x; j++) {\n\t\t\t//memo[i][j] = 0;\n\t//\t}\n\t//}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct PAD{\n    char M;\n    int x;\n    int y;\n    int flag = 0; \n}; \nint main(){\n    queue<struct PAD> que;\n    struct PAD pad[20][20+1];\n    int W,H,count;\n    int start_x,start_y;\n    char baf_char;\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    while(1){\n        count = 0;\n        cin >> W >> H;\n        if(W==0&&H==0)break;\n        for(int i=0;i<H;i++){\n            for(int k=0;k<W;k++){\n                cin >> baf_char;\n                if(baf_char=='@'){\n                    start_x = k;\n                    start_y = i;\n                    pad[i][k].flag = 1;\n                }else if(baf_char=='#'){\n                    pad[i][k].flag = 1;\n                }else{\n                    pad[i][k].flag = 0;\n                }\n                pad[i][k].x=k;\n                pad[i][k].y=i;\n                pad[i][k].M = baf_char;\n            }\n        }\n        //pad[start_y][start_x].flag = 1;\n        que.push(pad[start_y][start_x]);\n        while(que.size()!=0){\n            struct PAD p = que.front();\n            que.pop();\n            for(int j = 0;j<4;j++){\n                int nx = p.x + dx[j];\n                int ny = p.y + dy[j];\n                if(ny>=0&&nx>=0&&ny<=(H-1) && nx<=(W-1) && pad[ny][nx].flag == 0 && pad[ny][nx].M == '.'){\n                    pad[ny][nx].flag = 1;\n                    que.push(pad[ny][nx]);\n                    count++;\n                }\n            }\n        }\n        cout << count+1 << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n#define F first\n#define S second\nusing namespace std;\n\nchar c[33][33];\nint w,h;\n\nint solve(int x, int y){\n  typedef pair < int, int > P;\n  queue < P > que;\n  int count = 1;\n\n  que.push( P(x, y) );\n  c[y][x] = '#';\n\n  while(!que.empty()){\n    P q = que.front(); que.pop();\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    for(int i=0;i<4;i++){\n      int xx = dx[i] + q.F;\n      int yy = dy[i] + q.S;\n\n      if(xx < 0 || yy < 0 || xx == w || yy == h) continue;\n      if(c[yy][xx] == '#') continue;\n\n      c[yy][xx] = '#';\n      que.push( P(xx, yy) );\n      count++;\n    }\n\n  }\n\n  return count;\n}\n\nint main(){\n\n  int sx, sy;\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> c[i][j];\n\tif(c[i][j] == '@') sx = j, sy = i;\n      }\n    }\n\n    cout << solve(sx, sy) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint W, H;\nint x, y;\nchar tile[20][20];\nint checked[20][20];\nint dfs(int x, int y){\n    checked[x][y] = 1;\n    bool dead = false;\n    if((x==0 || tile[x-1][y] == '#' || checked[x-1][y] == 1) &&\n    (x==W-1 || tile[x+1][y] == '#' || checked[x+1][y] == 1) &&\n    (y==0 || tile[x][y-1] == '#' || checked[x][y-1] == 1) &&\n    (y==H-1 || tile[x][y+1] == '#' || checked[x][y+1] == 1)) dead = true;\n    if(dead){\n        return 1;\n    }\n    int tmp=0;\n    if(x>0 && tile[x-1][y] == '.' && checked[x-1][y] == 0) tmp += dfs(x-1, y);\n    if(x<W-1 && tile[x+1][y] == '.' && checked[x+1][y] == 0) tmp += dfs(x+1, y);\n    if(y>0 && tile[x][y-1] == '.' && checked[x][y-1] == 0) tmp += dfs(x, y-1);\n    if(y<H-1&&tile[x][y+1] == '.' && checked[x][y+1] == 0) tmp += dfs(x, y+1);\n    return 1+tmp;\n}\nint main(){\n    char tmp;\n    while(cin >> W >> H && W && H){\n        for(int j=0; j<H; ++j){\n            for(int i=0; i<W; ++i){\n                checked[i][j] = 0;\n                cin >> tmp;\n                switch(tmp){\n                    case '.':\n                        tile[i][j] = '.';\n                        break;\n                    case '#':\n                        tile[i][j] = '#';\n                        break;\n                    case '@':\n                        tile[i][j] = '.';\n                        x = i;\n                        y = j;\n                        break;\n                }\n            }\n        }\n        cout << dfs(x, y) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2)\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tauto dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}'\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst int MAX = 20;\nchar map[MAX][MAX];\nbool book[MAX][MAX];\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x = 0, int y = 0) :x(x), y(y) {}\n}start;\nint sum = 0;\nvoid depthFSearch(int H, int W, Point start)\n{\n\tint next[4][2] = { {0,1},{1,0},{0,-1},{-1,0} };\n\tfor (int k = 0; k <= 3; k++)\n\t{\n\t\tint nx = start.x + next[k][0];\n\t\tint ny = start.y + next[k][1];\n\t\tif (nx < 0 || nx >= H || ny < 0 || ny >= W||map[nx][ny]=='#')\n\t\t\tcontinue;\n\t\tif (!book[nx][ny] && map[nx][ny] == '.')\n\t\t{\n\t\t\tbook[nx][ny] = true;\n\t\t\tPoint p(nx, ny);\n\t\t\tsum++;\n\t\t\tdepthFSearch(H, W, p);\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tint H, W;\n\t\tcin >> H >> W;\n\t\tif (!H && !W)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')\n\t\t\t\t\tstart = Point(i, j);\n\t\t\t}\n\t\tbook[start.x][start.y] = true;\n\t\tsum = 1;\n\t\tdepthFSearch(H, W, start);\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nint w,h;\nint ans=1;\nchar tile[21][21];\n\nvoid saiki(int x,int y){\n\tif(x<0 | x>h | y<0 | y>w)return;\n\ttile[x][y]='#';\n\tif(tile[x-1][y]=='.')ans++,saiki(x-1,y);\n\tif(tile[x+1][y]=='.')ans++,saiki(x+1,y);\n\tif(tile[x][y-1]=='.')ans++,saiki(x,y-1);\n\tif(tile[x][y+1]=='.')ans++,saiki(x,y+1);\n}\n\nint main(void){\n\tint a,b; \n\twhile(1){\n\t\tfor(a=0;a<21;a++){\n\t\t\tfor(b=0;b<21;b++){\n\t\t\t\ttile[a][b]='\\0';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tans=1;\n\t\tfor(a=0;a<h;a++){\n\t\t\tscanf(\"%s\",tile[a]);\n\t\t}\n\t\tfor(a=0;a<h;a++){\n\t\t\tfor(b=0;b<w;b++){\n\t\t\t\tif(tile[a][b]=='@')saiki(a,b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<queue>\nusing namespace std;\n\nconst int INF = 10000009;\nchar maze[20][20];\nint W, H, sx, sy;\nint ans = 1;\nint d[20][20];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\nvoid bfs() {\n\tqueue< pair<int, int> > que;\n\tfor (int i = 0; i < H; i++)for (int j = 0; j < W; j++) d[i][j] = INF;\n\tque.push(make_pair(sx, sy));\n\td[sy][sx] = 0;\n\twhile (que.size()) {\n\t\tpair<int, int> p = que.front(); que.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H && maze[ny][nx] != '#') {\n\t\t\t\tif (d[ny][nx] == INF) {\n\t\t\t\t\tque.push(make_pair(nx, ny));\n\t\t\t\t\td[ny][nx] = 0;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> W >> H && W + H) {\n\t\tans = 1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nint main(void) {\n\twhile(true) {\n\t\tint W, H;\n\t\tscanf(\"%d %d\", &W, &H);\n\t\tif ( W==0 ) { break; }\n\t\t\n\t\tchar line[26][26];\n\t\t\n\t\tqueue<pair<int, int> > que;\n\t\t\n\t\tstrcpy(line[0], \"#######################\");\n\t\tstrcpy(line[H+1], \"#######################\");\n\t\t\n\t\tfor(int y=1; y<=H; y++) {\n\t\t\tline[y][0] = '#';\n\t\t\tscanf(\"%s\", &line[y][1]);\n\t\t\t\n\t\t\tif ( char* p = strchr(line[y], '@') ) {\n\t\t\t\tque.push(make_pair(y, p - line[y]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 1;\n\t\t\n\t\twhile(que.size()) {\n\t\t\t\n\t\t\tint y = que.front().first;\n\t\t\tint x = que.front().second;\n\t\t\tque.pop();\n\t\t\t\n\t\t\tint m[][2] = { {-1,0},{1,0},{0,1},{0,-1} };\n\t\t\tREP(d, 4) {\n\t\t\t\tif ( line[y+ m[d][0]] [x+ m[d][1]] == '.' ) {\n\t\t\t\t\tline[y+ m[d][0]] [x+ m[d][1]] = '+';\n\t\t\t\t\tret++;\n\t\t\t\t\tque.push( make_pair(y+ m[d][0], x+ m[d][1]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%H;\n\t        int y=cur/H;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[j];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*H);\n  visited[ny][nx]=true;\n\n    }\n   }\n \n }\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(int w,int h){\n  string s[100];\n  int sx,sy;\n\n  rep(i,h){\n    cin>>s[i];\n    rep(j,w){\n      if(s[i][j]=='@'){\n        sx=j;sy=i;\n      }\n    }\n  }\n\n  bool a[100][100]={};\n  queue<P> p;\n  p.push(P(sx,sy));\n  int ans=1;\n  while(p.size()){\n    P q = p.front(); p.pop();\n    rep(i,4){\n      int x = q.first+vx[i];\n      int y = q.second+vy[i];\n      if(0<=x&&x<w&&0<=y&&y<h){\n        if(s[y][x]=='.'&&!a[y][x]){\n          ans++;\n          a[y][x]=true;\n          p.push(P(x,y));\n        }\n      }\n    }\n  }\n\n  cout<<ans<<endl;\n}\n\n\n\nint main(){\n  \n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(n==0) break;\n    f(n,m);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <unordered_map>\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nusing namespace std;\nusing LL = long long;\n\nchar maze[21][21];\nbool ok[21][21];\nint h, w;\nint sx, sy;\n\nvoid dfs(int hpos, int wpos) {\n\tok[hpos][wpos] = true;\n\tmaze[hpos][wpos] = '#';\n\tint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = wpos + dx[i], ny = hpos + dy[i];\n\t\tif (0 <= nx&&nx < w && 0 <= ny&&ny < h&&maze[ny][nx] == '.')dfs(ny, nx);\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h&&w&&h) {\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tfor (int j = 0; j < 20; j++) {\n\t\t\t\tok[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@')sx = j, sy = i;\n\t\t\t}\n\t\t}\n\t\tdfs(sy, sx);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (ok[i][j])ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint W, H;\nchar visit[21][21];\nint dfs(int h, int w){\n  int sum=1;\n  if(0>w || w==W || 0>h || h==H) return 0;\n  if(visit[h][w]=='#')  return 0;\n  if(visit[h][w]=='!')   return 0;\n    visit[h][w] = '!';\n    sum += dfs(h, w+1);\n    sum += dfs(h, w-1);\n    sum += dfs(h+1, w);\n    sum += dfs(h-1, w);\n   \n  return sum;\n}\n\nint main(void){\n  int w1, h1;\n  string str;\n  while(cin >> W >> H){\n    if(W == 0 && H == 0)  break;\n    for(int i=0; i<H; i++){\n      cin >> str;\n      for(int j=0; j<W; j++){\n        visit[i][j] = str[j];\n        if(visit[i][j] == '@'){\n          visit[i][j] = '.';\n          w1 = j; h1 = i;  \n        }\n      }\n    }\n    cout << dfs(h1, w1) <<endl;\n  }\n   \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nbool arrive[25][25];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvoid dfs(vector<string> &grid, int x, int y){\n  REP(r,4){\n    if(arrive[y+dy[r]][x+dx[r]]==false&&grid[y+dy[r]][x+dx[r]]=='.'){\n      arrive[y+dy[r]][x+dx[r]] = true;\n      dfs(grid,x+dx[r],y+dy[r]);\n    }\n  }\n}\nint main(void){\n  int W,H;\n  while(cin>>W>>H,W){\n    memset(arrive,0,sizeof(arrive));\n    vector<string> grid;\n    string tmp;\n    REP(i,W+2)tmp+=\"#\";\n    grid.push_back(tmp);\n    REP(i,H){\n      string tmp;\n      cin>>tmp;\n      tmp = \"#\"+tmp+\"#\";\n      grid.push_back(tmp);\n    }\n    grid.push_back(tmp);\n    REP(y,grid.size())REP(x,grid[0].size())if(grid[y][x]=='@')dfs(grid,x,y);\n    int ans=1;\n    REP(y,25)REP(x,25)if(arrive[y][x])ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define in(h, w) 0<=h&&h<H&&0<=w&&w<W\n\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint main(){\n    int W, H;\n    while (cin >> W >> H and W and H) {\n        int h, w;\n        vector< vector<char> > map(H, vector<char>(W));\n        for (int i = 0; i < H; i++)\n            for (int j = 0; j < W; j++) {\n                cin >> map[i][j];\n                if (map[i][j] == '@') {\n                    h = i;\n                    w = j;\n                }\n            }\n        int res = 1;\n        queue<pair<int, int> > q;\n        q.push(make_pair(h, w));\n        while (!q.empty()) {\n            h = q.front().first;\n            w = q.front().second;\n            q.pop();\n            if (map[h][w] == '.') {\n                res++;\n                map[h][w] = '#';\n            }\n            for (int i = 0; i < 4; i++) {\n                int th = h+dh[i];\n                int tw = w+dw[i];\n                if (0<=th&&th<H&&0<=tw&&tw<W) {\n                    if (map[th][tw] == '.')\n                        q.push(make_pair(th, tw));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint w,h;\nchar ba[20][20];\n\nint const dx[] = {0,1,0,-1};\nint const dy[] = {-1,0,1,0};\nint go(int sx, int sy) {\n  int ans = 0;\n  REP(i,4) {\n    int xx = sx+dx[i];\n    int yy = sy+dy[i];\n    if (xx<0||xx>=w||yy<0||yy>=h) continue;\n    if (ba[xx][yy] == '.') {\n      ba[xx][yy] = '#';\n      ans++;\n      ans += go(xx,yy);\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while(cin >> w >> h, w+h) {\n    int sx, sy;\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba[x][y];\n        if (ba[x][y]=='@') {\n          sx = x;\n          sy = y;\n        }\n      }\n    }\n    cout << go(sx,sy)+1 << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nstring grid[20];\nbool used[20][20];\nint move_h[4] = {-1, 1, 0, 0};\nint move_w[4] = {0, 0, -1, 1};\n\nvoid dfs(int cur_h, int cur_w, int h, int w){\n  used[cur_h][cur_w] = true;\n  for(int i = 0; i < 4; i++){\n    int next_h = cur_h + move_h[i];\n    int next_w = cur_w + move_w[i];\n    if(0 <= next_h && next_h < h && 0 <= next_w && next_w < w\n        && !used[next_h][next_w] && grid[next_h][next_w] != '#'){\n      dfs(next_h, next_w, h, w);\n    }\n  }\n}\n\nint main(){\n  while(true){\n    int W;\n    int H;\n    cin >> W >> H;\n    if(W == 0 && H == 0){\n      break;\n    }\n    for(int i = 0; i < H; i ++){\n      cin >> grid[i];  \n    }\n\n    int start_h = 0;\n    int start_w = 0;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        used[i][j] = false;\n        if(grid[i][j] == '@'){\n          start_h = i;\n          start_w = j;\n        }\n      }\n    }\n\n    dfs(start_h, start_w, H, W);\n\n    int ans = 0;\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        if(used[i][j]){\n          ans ++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint cnt = 0;\nvoid depth_first_search(int,int,vector< vector<char> > &);\nint main(){\n\n  while(true){\n    int w,h;\n    cin >> w;\n    cin >> h;\n    \n    int fx;\n    int fy;\n    if(w == 0 && h ==0 )return 0;\n    vector< vector<char> > map(w, vector<char>(h));\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tcin >> map[j][i];\n\t\n\tif(map[j][i] == '@'){\n\t  fx = j;\n\t  fy = i;\n\t}\n      }\n    }\n    cnt = 1;\n    depth_first_search(fx,fy,map);\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid depth_first_search(int x,int y,vector< vector<char> > &map){\n  int dx[4] = {0,1,-1,0};\n  int dy[4] = {1,0,0,-1};\n\n  for(int i = 0;i < 4;i++){\n    if(!(x+dx[i] == -1 \n\t|| x+dx[i] == map.size() \n\t|| y+dy[i] == -1 \n\t|| y+dy[i] == map[0].size()\n\t)\n\t&& map[x+dx[i]][y+dy[i]] == '.' \n       ){\n      map[x+dx[i]][y+dy[i]] = '1';\n      cnt++;\n      \n      depth_first_search(x+dx[i],y+dy[i],map);\n      \n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int w,h,a[20][20],str1,str2,count=0,m;\n  char in;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>in;\n\tif(in=='#') a[i][j]=0;\n\telse if(in=='@') {\n\t  a[i][j]=2;\n\t}\n\telse a[i][j]=1;\n      }\n    }\n    count=0;\n    while(1){\n      m=0;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(a[i][j]==2){\n\t    m=1;\n\t    count++;\n\t    a[i][j]=3;\n\t    if(i==0){\n\t      if(j==0){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t      }\n\t    }\n\t    else if(j==0){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t    else if(i==h-1){\n\t      if(j==w-1){\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t      else {\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t      }\n\t    }\n\t    else if(j==w-1){\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t    }\n\t    else {\n\t\tif(a[i+1][j]==1) a[i+1][j]=2;\n\t\tif(a[i-1][j]==1) a[i-1][j]=2;\n\t\tif(a[i][j-1]==1) a[i][j-1]=2;\n\t\tif(a[i][j+1]==1) a[i][j+1]=2;\n\t    }\n\t  }\n\t}\n      }\n      if(m==0) break;\n    }\n    cout<<count<<endl;\n  }\n    \n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define REP(i, a, b) for (int i = (int)a; i < (int)b; ++i)\n#define rer(i, a, b) for (int i = (int)a; i <= (int)b; ++i)\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define all(v) v.begin(), v.end()\n#define mset(a, n) memset(a, n, sizeof(a))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int inf = 1000000000;\nconst int mod = 1000000007;\nconst double eps = 1e-9;\nconst int dx[] = { -1, 0, 1, 0};\nconst int dy[] = { 0, -1, 0, 1};\n\nint W, H;\nint ans;\nstring field[100];\n\nvoid dfs(int y, int x) {\n\tif (x < 0 || y < 0 || x == W || y == H) return;\n\tif (field[y][x] == '#') return;\n\tans++;\n\tfield[y][x] = '#';\n\trep(i, 4) dfs(y + dy[i], x + dx[i]);\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tans = 0;\n\t\trep(i, H) cin >> field[i];\n\t\trep(i, H) rep(j, W) {\n\t\t\tif (field[i][j] == '@') dfs(i, j);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <fstream>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <numeric>\n#include <sstream>\n#include <list>\n#include <map>\n#include <functional>\n#include <iterator>\n\n#define rep(i,p,n) for(int i=(int)p;i<(int)n;i++)\n#define repp(i,p,n) for(int i=(int)p;i>=(int)n;i--)\n#define Sort(x) sort(x.begin(),x.end())\n#define PSort(x) sort(begin(x), end(x), pairCompare)\n#define ll long long\n#define INF 2000000000\n#define pb push_back\n#define mp make_pair\n#define PI 3.14159265358979\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nusing namespace std;\n\nint w, h;\n\nvector<vector<char>> v;\nint ans = 0;\n\nvoid dfs(int y,int x) {\n\tif (v[y][x] == '.') {\n\t\tv[y][x] = '#';\n\t\tans++;\n\t}\n\n\trep(i, 0, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && 0 <= ny&&nx < w&&ny < h&&v[ny][nx] == '.')dfs(ny, nx);\n\t}\n}\n\nint main(){\n\twhile (1) {\n\t\tint sx, sy;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0)break;\n\t\tv.resize(h, vector<char>(w));\n\t\trep(i, 0, h) {\n\t\t\trep(j, 0, w) {\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tif (v[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(sy, sx);\n\t\tcout << ans << endl;\n\n\t\tv.clear();\n\t\tans = 0;\n\t}\n\n\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nvector<vector<char>> c;\nint ans;\n\nvoid dfs(int i, int j) {\n    c[i][j] = '#';\n    ++ ans;\n    rep(k, 4) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if(0 <= ni and ni < h and 0 <= nj and nj < w and c[ni][nj] == '.') {\n            dfs(ni, nj);\n        }\n    }\n}\n\nvoid solve() {\n\twhile(cin >> w >> h) {\n        if(w == 0 and h == 0) break;\n        c.assign(h, vector<char>(w));\n        int si, sj;\n        rep(i, h) {\n            rep(j, w) {\n                cin >> c[i][j];\n                if(c[i][j] == '@') {\n                    c[i][j] = '.';\n                    si = i, sj = j;\n                }\n            }\n        }\n        ans = 0;\n        dfs(si, sj);\n        cout << ans << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar m[21][21];\nint w,h,ans;\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nvoid solve(int x,int y) {\n  m[y][x]='#';\n  ans++;\n  \n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx>=0 && nx<w && ny>=0 && ny<h && m[ny][nx]!='#') {\n\tsolve(nx,ny);\n    }\n  }\n}\n\nint main() {\n  int sx,sy;\n  while(cin>>w>>h,w||h) {\n    ans=0;\n    for(int y=0;y<h;y++) {\n      for(int x=0;x<w;x++) {\n\tcin>>m[y][x];\n\tif(m[y][x]=='@') {\n\t  sx=x;sy=y;\n\t}\n      }\n    }\n    solve(sx,sy);\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint h, w;\nint sx, sy;\nint ct;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y, vector<vector<char> > &v) {\n  v[x][y] = '#';\n  ++ct;\n  for(int i = 0; i < 4; ++i) {\n    int nx = dx[i] + x;\n    int ny = dy[i] + y;\n    if(nx >= 0 && ny >= 0 && ny < h && nx < w && v[nx][ny] == '.') {\n      dfs(nx, ny, v);\n    }\n  }\n  return;\n}\nint main() {\n  for(;;) {\n    scanf(\"%d %d\", &w, &h);\n    if(w == 0 && h == 0) break;\n    vector<vector<char> > v(w, vector<char>(h));\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\" %c\", &v[j][i]);\n      }\n    }\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        if(v[j][i] == '@') {\n          sx = j, sy = i;\n          break;\n        }\n      }\n    }\n    dfs(sx, sy, v);\n    printf(\"%d\\n\", ct);\n    h = 0, w = 0, sx = 0, sy = 0, ct = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int H, W;\n  while(scanf(\"%d%d\", &W, &H)){\n    if ((H == 0) && (W == 0)){\n      break;\n    }\n    vector<vector<char> > m(H, vector<char>(W, ' '));\n    pair<int,int> start(0,0);\n    for (int i = 0; i < H; i++){\n      for (int j = 0; j < W; j++){\n        scanf(\" %c\", &(m[i][j]));\n        if (m[i][j] == '@'){\n          start.first = j;\n          start.second = i;\n\t}\n      }\n    }\n    set<pair<int,int> > q;\n    set<pair<int,int> > already;\n    q.insert(start);\n    while(!q.empty()){\n      pair<int,int> next = *(q.begin());\n      q.erase(q.begin());\n      if (already.find(next) == already.end()){\n        already.insert(next);\n        if ((next.first > 0) && (m[next.second][next.first-1] == '.')){\n          q.insert(pair<int,int>(next.first-1, next.second));\n\t}\n        if ((next.first < W-1) && (m[next.second][next.first+1] == '.')){\n          q.insert(pair<int,int>(next.first+1, next.second));\n\t}\n        if ((next.second > 0) && (m[next.second-1][next.first] == '.')){\n          q.insert(pair<int,int>(next.first, next.second-1));\n\t}\n        if ((next.second < H-1) && (m[next.second+1][next.first] == '.')){\n          q.insert(pair<int,int>(next.first, next.second+1));\n\t}\n      }\n    }\n    printf(\"%d\\n\", (int)already.size());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h;\nchar a[100][100];\nint dfs(int i,int j){\n    if(i==h||j==w||i<0||j<0)return 0;\n    if(a[i][j]=='#')return 0;\n    int s=1;\n    a[i][j]='#';\n    s+=dfs(i+1,j);\n    s+=dfs(i-1,j);\n    s+=dfs(i,j+1);\n    s+=dfs(i,j-1);\n    return s;\n}\nint main(){\n    int i,j;\n    while(cin>>w>>h,w!=0&&h!=0){\n    //char a[h][w];\n    for(i=0;i<h;i++)cin>>a[i];\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='@')cout<<dfs(i,j)<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n//グローバルで宣言するとmain関数、再帰関数の両方から参照できて便利\nint h,w;\nstring grid[20];\nbool visit[20][20];\n\nvoid rec(int y,int x);\n\nint main(){\n  while(cin >> w >> h,h){\n    for(int i=0;i<h;i++){\n      cin >> grid[i];      //string型を使うと入力読み込みが楽になる\n      for(int j=0;j<w;j++)visit[i][j] = false;\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(grid[i][j] == '@')rec(i,j);  //初期位置から再帰探索をスタート\n      }\n    }\n\n    int ans = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(visit[i][j])ans++;           //到達できたタイルの数を数える\n      }\n    }\n\n    cout << ans << endl;\n  }\n}\n\nint dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1};     //次の移動を定義する配列\n\nvoid rec(int y,int x){\n  if(visit[y][x])return;\n  visit[y][x] = true;\n\n  for(int i=0;i<4;i++){\n    int ny = y+dy[i], nx = x+dx[i];             //次の移動\n\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue; //枠外\n    if(grid[ny][nx] == '#')continue;            //赤いタイル=障害物\n    rec(ny,nx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef long long int llint;\n#define MM 1000000000\n#define MOD MM+7\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n#define chmax(a,b) (a<b ? a=b:0)\n#define chmin(a,b) (a>b ? a=b:0)\nconst long double PI = acos(-1);\nconst long long INF = 1e15;\nint dx[8] = {-1,0,1,0,-1,-1,1,1};\nint dy[8] = {0,-1,0,1,-1,1,1,-1};\ntemplate<typename T>\nT GCD(T u,T v){\n    return v ? GCD(v,u%v) : u;\n}\nchar s[22][22];\nbool visited[22][22];\nvoid init(int H, int W){\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            s[i][j] = 'a';\n            visited[i][j] = false;\n        }\n    }\n}\nvoid bfs(int sh, int sw, int h, int w){\n    queue<pair<int,int> > que;\n    que.push(make_pair(sh,sw));\n    while(que.size()){\n        pair<int,int> F = que.front();\n        visited[F.first][F.second] = true;\n        que.pop();\n        for(int i = 0; i < 4; i++){\n            int ny = F.first + dy[i];\n            int nx = F.second + dx[i];\n            if (s[ny][nx] == '#') continue;\n            if (visited[ny][nx] == false && 0 <= nx && 0 <= ny && nx < w && ny < h && (s[ny][nx] == '.' || s[ny][nx] == '@')){\n                que.push(make_pair(ny,nx));\n                visited[ny][nx] = true;\n            }\n        }\n    }\n}\nint check(int h, int w){\n    int cnt = 0;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if (visited[i][j] == true && (s[i][j] == '.' || s[i][j] == '@')){\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\nvoid display(int h, int w){\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cout << visited[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n\nint main(){\n    vector<int> v(0);\n    while(true){\n        int h,w; cin >> w >> h;\n        if (h == 0 && w == 0) break;\n        init(h,w);\n        pair<int,int> start;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> s[i][j];\n                if (s[i][j] == '@'){\n                    start.first = i;\n                    start.second = j;\n                }\n            }\n        }\n        bfs(start.first, start.second, h, w);\n        v.push_back(check(h, w));\n        //display(h,w);\n    }\n    for(int i = 0; i < v.size(); i++){\n        cout << v[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nint w,h;\nchar map[21][21];\nint dfs(int si,int sj){\n    int ans=1;\n    if(si<=-1||si>=h)return 0;\n    if(sj<=-1||sj>=w)return 0;\n    if(map[si][sj]=='#') return 0;\n    map[si][sj]='#';\n    ans+=dfs(si+1,sj);\n    ans+=dfs(si,sj+1);\n    ans+=dfs(si-1,sj);\n    ans+=dfs(si,sj-1);\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        scanf(\"%d %d\",&w,&h);\n        if(w==0 && h==0)break;\n        int i,j,si=0,sj=0;\n        for(i=0;i<=h-1;i++){\n        scanf(\"%s\",map[i]);\n        }\n        for(i=0;i<=h-1;i++){\n            for(j=0;j<=w-1;j++){\n                if(map[i][j]=='@'){\n                    si=i;\n                    sj=j;\n                }\n            }\n        }\n        printf(\"%d\\n\",dfs(si,sj));\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n#define N (1000000000+7)\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint h,w;\nchar board[30][30];\nbool board1[30][30];\nbool check(int i,int j){\n    return (i>=1)&&(i<=h)&&(j>=1)&&(j<=w)&&((board[i][j]=='.')||(board[i][j]=='@'))&&(!board1[i][j]);\n}\n\nint dfs(int i,int j){\n    if(check(i,j)){\n        board1[i][j]=true;\n        return dfs(i+1,j)+dfs(i-1,j)+dfs(i,j+1)+dfs(i,j-1)+1;\n    }\n    else return 0;\n}\n\nint main(void){\n    while(true){\n        cin>>w>>h;\n        int sx=0,sy=0;\n        if((h==0)&&(w==0))break;\n        for(int i=0;i<30;i++){\n            for(int j=0;j<30;j++){\n                board1[i][j]=false;\n            }\n        }\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin>>board[i][j];\n                if(board[i][j]=='@'){\n                    sx=i;\n                    sy=j;\n                }\n            }\n        }\n        cout<<dfs(sx,sy)<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n//#include <map>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\nint W, H, sw, sh, cnt;\nchar tiles[20][20];\nint dw[4] = {-1, 0, 0, 1};\nint dh[4] = {0, -1, 1, 0};\n\n\nvoid dfs(int w, int h)\n{\n\ttiles[h][w] = '#';\n\tcnt++;\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tint nw = w + dw[i];\n\t\tint nh = h + dh[i];\n\t\t\n\t\tif (0<=nw && nw<W && 0<=nh && nh<H && tiles[nh][nw]=='.')\n\t\t{\n\t\t\tdfs(nw, nh);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> W >> H)\n\t{\n\t\tif (W == 0 && H == 0) break;\n\t\t\n\t\t//入力\n\t\tfor (int i=0; i<H; i++)\n\t\t{\n\t\t\tcin >> tiles[i];\n\t\t}\n\t\t\n\t\t//スタート地点を探す\n\t\tfor (int i=0; i<H; i++)\n\t\t{\n\t\t\tfor (int j=0; j<W; j++)\n\t\t\t{\n\t\t\t\tif (tiles[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsw = j;\n\t\t\t\t\tsh = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tdfs(sw, sh);\n\t\tcout << cnt << endl;\n\t\t\n\t\t//cout << \"sw = \" << sw << \" : sh = \" << sh << endl;\n\t\t\n\t\t/*\n\t\t//テスト出力\n\t\tfor (int i=0; i<H; i++)\n\t\t{\n\t\t\tcout << tiles[i] << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w,h;\nstring room[20];\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\ninline bool isRegion(int x, int y){\n    return x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint dfs(int x, int y){\n    int cnt = 1;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        \n        if(isRegion(nx,ny) && room[ny][nx] == '.'){\n            room[ny][nx] = '#';\n            cnt += dfs(nx, ny);\n        }\n    }\n    return cnt;\n}\n\nint main(int argc, const char * argv[]) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin >> w >> h;\n        if(!w && !h) break;\n        \n        int sx, sy;\n        for(int i = 0; i < h; i++){\n            cin >> room[i];\n            if(room[i].find('@') != -1){\n                sx = room[i].find('@');\n                sy = i;\n            }\n        }\n        \n        cout << dfs(sx, sy) << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};//{1,0,-1,0,1,1,-1,-1};//8??????\nint dy[4] = {0, 1, 0, -1};//{0,1,0,-1,-1,1,1,-1};//8??????\n\nint px;\nint py;\nint cnt;\nint xr,yr;\nvector<string> field;\n\nint dfs(int x, int y) {\n  //(x, y) ????????????????????????????????????\n    \n    if(yr<=y || xr<=x || 0>x || 0>y) return 0;\n    if(field[y][x]=='#') return 0;\n    if(field[y][x]=='.' || field[y][x]=='@') {field[y][x]='#';cnt++;}\n    // ??¨???4??????????????????\n    for(int r = 0; r < 4; r++) {\n      int nx = x + dx[r];\n      int ny = y + dy[r];\n      dfs(nx, ny);\n    }\n  return 0;\n}\n\nint main(){\n\n while(1){\n    int x,y;\n    cin >> x >> y;\n    if(x==0 && y==0) break;\n    xr=x; yr=y;\n    field.clear(); \n    cnt=0;\n    rep(i,y){\n      string str;\n      cin >> str;\n      rep(j,str.size()){\n        if(str[j]=='@'){\n          px=j;\n          py=i;\n        }\n      }\n      field.push_back(str);\n    }\n   dfs(px,py);\n   \n   cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nint a[30][30];\nint w, h, cnt;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid search(int x, int y);\n\nbool issearched[30][30];\n\nint main()\n{\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tchar c;\n\t\tint is, js;\n\t\tcnt = 1;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '.') a[i][j] = 1;\n\t\t\t\telse if(c == '#') a[i][j] = -1;\n\t\t\t\telse if(c == '@'){\n\t\t\t\t\tis = i;\n\t\t\t\t\tjs = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsearch(is, js);\n\t\tcout << cnt << endl;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tissearched[i][j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid search(int x, int y)\n{\n\tint nx, ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = x + dx[i];\n\t\tny = y + dy[i];\n\t\tissearched[x][y] = true;\n\t\tif(nx >= h || ny >=w || nx < 0 || ny < 0) continue;\n\t\tif(a[nx][ny] == 1 && !issearched[nx][ny]){\n\t\t\tcnt++;\n\t\t\tsearch(nx, ny);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nvoid Tile1(vector<string>&, int, int, int, int);\nvoid Tile2(vector<string>&, int, int, int, int);\n\nint main(){\n  int i, j, w, h, isFound, count;\n  string str;\n  vector<string> data;\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(i=0; i<h; ++i){\n      cin >> str;\n      data.push_back(str);\n    }\n\n    for(i=0, isFound=0; i<h; ++i){\n      for(j=0; j<w; ++j){\n        if(data[i][j] == '@'){\n\t  isFound = 1;\n\t  break;\n\t}\n      }\n      if(isFound == 1) break;\n    }\n\n    Tile1(data, i, j, w, h);\n\n    for(i=0, count=0; i<h; ++i){\n      for(j=0; j<w; ++j){\n        if(data[i][j] == '@') ++count;\n      }\n    }\n\n    cout << count << endl;\n    data.clear();\n  }\n\n  return 0;\n}\n\nvoid Tile1(vector<string>& data, int i, int j, int w, int h){\n  data[i][j] = '@';\n  Tile2(data, i-1, j, w, h);\n  Tile2(data, i, j-1, w, h);\n  Tile2(data, i+1, j, w, h);\n  Tile2(data, i, j+1, w, h);\n}\n\nvoid Tile2(vector<string>& data, int i, int j, int w, int h){\n  if(i>-1 && i<h && j>-1 && j<w && data[i][j]=='.')\n    Tile1(data, i, j, w, h);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nusing Point = pair<int,int>;\n\nint main(){\n  int W,H;\n  while((cin>>W>>H)&&W>0&&H>0){\n    int map[22][22]={0};\n    int sy,sx;\n    for(int i=1;i<=H;++i){\n      for(int j=1;j<=W;++j){\n        char c;\n        cin >> c;\n        if(c=='.'){\n          map[i][j] = 1;\n        }else if(c=='@'){\n          map[i][j] = 1;\n          sy = i ; sx = j;\n        }\n      }\n    }\n\n    stack<Point> s;\n    s.push(make_pair(sy,sx));\n    int tile = 0;\n    while(!s.empty()){\n      auto p = s.top();s.pop();\n      int y = p.first , x = p.second;\n      if(map[y][x]){\n        map[y][x] = 0;\n        tile++;\n      }else{\n        continue;\n      }\n\n      s.push(make_pair(y-1,x));\n      s.push(make_pair(y+1,x));\n      s.push(make_pair(y,x-1));\n      s.push(make_pair(y,x+1));\n    }\n\n    cout << tile << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tint w = 1;\n\t\t\tint h = 1;\n\t\t\tint moveCan = 0;\n\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\n\t\t\tchar[][] table = new char[h][w];\n\t\t\t// int[][] num = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t// for (int j = 0; j < w; j++) {\n\t\t\t\ttable[i]/* [j] */= scan.next().toCharArray();\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tmoveCan = AtCheck(table, w, h);\n\t\t\tSystem.out.println(moveCan);\n\t\t}\n\n\t\tscan.close();\n\t}\n\n\tpublic static int AtCheck(char table[][], int w, int h) {\n\t\tint befAtNum = 0;\n\t\tint aftAtNum = 0;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@')\n\t\t\t\t\tbefAtNum++;\n\t\t\t}\n\t\t}\n\n\t\tint[][] atPlace = new int[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@') {\n\t\t\t\t\tatPlace[i][j] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i - 1][j - 1]=='.')\n\t\t\t\t\t// atPlace[i - 1][j - 1] = 1;\n\t\t\t\t\tif (j != 0 && table[i][j - 1] == '.')\n\t\t\t\t\t\tatPlace[i][j - 1] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i + 1][j - 1]=='.')\n\t\t\t\t\t// atPlace[i + 1][j - 1] = 1;\n\t\t\t\t\tif (i != 0 && table[i - 1][j] == '.')\n\t\t\t\t\t\tatPlace[i - 1][j] = 1;\n\t\t\t\t\tif (i != (h - 1) && table[i + 1][j] == '.')\n\t\t\t\t\t\tatPlace[i + 1][j] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i - 1][j + 1]=='.')\n\t\t\t\t\t// atPlace[i - 1][j + 1] = 1;\n\t\t\t\t\tif (j != (w - 1) && table[i][j + 1] == '.')\n\t\t\t\t\t\tatPlace[i][j + 1] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i + 1][j + 1]=='.')\n\t\t\t\t\t// atPlace[i + 1][j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (atPlace[i][j] == 1)\n\t\t\t\t\ttable[i][j] = '@';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@')\n\t\t\t\t\taftAtNum++;\n\t\t\t}\n\t\t}\n\t\tif (befAtNum != aftAtNum) {\n\t\t\treturn AtCheck(table, w, h);\n\t\t} else {\n\t\t\treturn aftAtNum;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h,count;\nchar room[20][20];\n\nvoid rec(int y, int x){\n  if(y<0||x<0||y>=h||x>=w){\n      return;\n    }\n    if(room[y][x] == '#'){\n      return;\n    }\n    count++;\n    room[y][x] = '#';\n    rec(y-1,x);\n    rec(y,x+1);\n    rec(y+1,x);\n    rec(y,x-1);\n    }\n  \n  int main(){\n    \n    int i,j,x,y;\n    while(1){\n      count=0;\n      cin >> w >> h;\n      if( w==0 && h==0){\n\tbreak;\n      }\n      for(j = 0;j < h;j++){\n\tfor(i = 0;i < w;i++){ \n\t  cin >> room[j][i] ;\n\t  if(room[j][i] =='@'){\n\t    x = i;\n\t    y = j;\n\t  }\n\t}\n      }\n\n      rec(y,x);\n      cout << count << endl;\n    }\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n  while(1){\n    int H,W,count=0,kaisuu=0,kosuu,sum=1,judge;\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    char map[W][H];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(1000);\n    nexty.reserve(1000);\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[0].push_back(cW);\n\t    nexty[0].push_back(cH);\n\t  }\n\t}\n    }\n    \n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    \n    cout << sum <<endl;\n    \n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cout << map[cW][cH];\n\t}\n\tcout << endl;\n    }\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar maze[21][21];\n#define r(z,x) for(int z=0;z<x;z++)\nint ans,a,b;\nvoid dfs(int x,int y){\n\tint dx[4]={0,-1,0,1},dy[4]={1,0,-1,0};\n\tmaze[x][y]='#',ans++;\n\tr(i,4)if(maze[x+dx[i]][y+dy[i]]=='.')dfs(x+dx[i],y+dy[i]);\n}\nint main(){\n\twhile(cin>>a>>b,a||b){\n\t\tans=0;\n\t\tfill(maze[0],maze[20],'#');\n\t\tr(i,b)r(j,a)cin>>maze[i][j];\n\t\tr(i,b)r(j,a)if(maze[i][j]=='@')dfs(i,j),cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid room_search(int w, int h, const vector<string>& room, vector< vector<int> >& visited, int W, int H, int& ret) {\n    int dw[] = {1, 0, -1, 0}, dh[] = {0, 1, 0, -1};\n    visited[h][w] = 1;\n    ret++;\n    for (int i = 0; i < 4; i++) {\n        int nw = w + dw[i], nh = h + dh[i];\n        if (0 <= nw && nw < W && 0 <= nh && nh < H && visited[nh][nw] != 1 && room[nh][nw] == '.')  {\n            room_search(nw, nh, room, visited, W, H, ret);\n        }\n    }\n}\n\nint main() {\n    while(true) {\n        int W, H;\n        cin >> W >> H;\n        if(W == 0 && H == 0) break;\n        vector<string> room;\n        vector< vector<int> > visited;\n        int iw, ih;\n        for(int h = 0; h < H; h++) {\n            string s;\n            cin >> s;\n            for(int w = 0; w < W; w++) {\n                if(s[w] == '@') {\n                    iw = w;\n                    ih = h;\n                }\n            }\n            room.push_back(s);\n            visited.push_back(vector<int>(W, 0));\n        }\n        int ret = 0;\n        room_search(iw, ih, room, visited, W, H, ret);\n        cout << ret << endl;\n    }\n}\n// [Problem] Red and Black\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint i,j,w,h;\nstring tile[21];\nint cnt=0;\nint result=0;\nint si,sj;\n\nvoid rec(int i,int j){\n  if(tile[i][j]=='.'){\n    tile[i][j]='#';\n    cnt++;\n  }\n\n  if(i+1 < h && tile[i+1][j]=='.')  rec(i+1,j);\n  if(j+1 <w && tile[i][j+1]=='.')  rec(i,j+1);\n  if(j-1 >=0 && tile[i][j-1]=='.')  rec(i,j-1);\n  if(i-1 >=0 && tile[i-1][j]=='.' )  rec(i-1,j);\n}\n\nint main(){\n\n  while(1){\n    cnt=0;\n    result=0;\n  cin >> w >> h;\n  if(w==0 && h==0)break;\n  for(i = 0; i < h; i++){\n    cin >> tile[i];\n    for(j = 0; j < w; j++){\n     \n      if(tile[i][j]=='@'){\n\tsi=i;\n\tsj=j;\n      }\n    }\n  }\n \n  rec(si,sj);\n \n \n  cout << cnt+1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX (256)\n\nchar field[MAX][MAX];\nint W, H;\nint ans = 0;\nint sx, sy;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y){\n\tif(0 <= x && x < H && 0 <= y && y < W && field[x][y] == '.'){\n\t\tans++;\n\t\tfield[x][y] = '#';\n\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H, W || H){\n\t\tans = 0;\n\t\tfor(int i=0; i < H; i++){\n\t\t\tfor(int j=0; j < W; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx, sy);\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e12;\nconst int inf = 1e9;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef set<int> S;\nll n;\nchar maze[25][25];\nint dist[25][25];\nint sx,sy;\nint h,w;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvector<int> ans;\nvoid bfs(){\n    queue<P> que;\n    for(int i = 0;i < 25; i++){\n        for(int j = 0;j < 25; j++){\n            dist[i][j]=-1; //距離の初期化\n        }\n    }\n    que.push(P(sy,sx));\n    dist[sy][sx]=0;\n    while(que.size()){\n        P p=que.front();\n        que.pop(); //キューの先頭を取り出す\n        for(int i=0;i<4;i++){\n            int ny = p.first + dy[i] , nx = p.second + dx[i]; \n            if(0<=nx && nx <= (w-1) && 0<=ny && ny <= (h-1) && maze[ny][nx]!='#' && dist[ny][nx] == -1){\n            que.push(P(ny,nx));\n            dist[ny][nx]=dist[p.first][p.second]+1;\n            }\n        }\n    }\n    int cnt=0;\n    for(int i=0;i<25;i++){\n        for(int j=0;j<25;j++){\n            if(dist[i][j]!=-1) cnt++;\n        }\n    }\n    ans.push_back(cnt);\n}\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(h==0 && w==0){\n            for(int i=0;i<ans.size();i++) cout<<ans[i]<<endl;\n            return 0;\n        }\n        //入力と初期位置の決定\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>maze[i][j];\n                if(maze[i][j]=='@'){\n                    sx=j;\n                    sy=i;\n                }\n            }\n        }\n        //cout<<sx<<\" \"<<sy<<endl;\n        bfs();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n ; i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x) // decltypeで型取得、引数があればva_argsのところに入れる\nusing namespace std;\ntypedef long long ll; // long longをllでかけるようにした\nconst int INF = 1e9;\nint n, m, ans = 0;\nchar W[100][100];\n\nvoid dfs(int y, int x){\n    W[y][x] = '#';\n    for(int dx = -1; dx <= 1; dx++){\n        for(int dy = -1; dy <= 1; dy++){\n            if(dx == dy and dx != 0 and dy != 0) continue;\n            else if(dx == -dy) continue;\n            int nx = dx + x;\n            int ny = dy + y;\n            if(W[ny][nx] == '.' and 0 <= nx and nx < n and 0 <= ny and ny < m){\n                dfs(ny, nx);\n                ans++;\n            }\n        }\n    }\n    return ;\n}\n\nint main(void){\n    while(true){\n        ans = 0; // 新しいデータセットの度に初期化\n        cin >> n >> m;\n        if(n == 0 and m == 0) return 0;\n        REP(i, m){\n            REP(j, n){\n                cin >> W[i][j];\n            }\n        }\n\n        REP(i, m){\n            REP(j, n){\n                if(W[i][j] == '@'){\n                    ans++;\n                    dfs(i, j);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint COUNT=0;\n\nvoid dfs(vector<string> map,int state[20][20],int x,int y,int W,int H){\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  if(x<0 || x>H-1 || y<0 || y>W-1)return; //????????????\n  if(state[x][y]!=0 || map[x][y]=='#')return; //?????§????????£??????????????????????????????\n  ++COUNT;\n  state[x][y]=1;\n  for(int i=0;i<4;++i)dfs(map,state,x+dx[i],y+dy[i],W,H); //??????????????¨??¢?´¢\n}\n\nint main(){\n  int W,H,x,y;\n  vector<string> map;\n  string a;\n  while(true){\n    COUNT=0;\n    cin >> W >>H;\n  if(!W && !H)break;\n  int state[20][20]={0}; //?????§????????£???????????????\n  for(int i=0;i<H;++i){ //???????????\\???\n    cin >> a;\n    map.push_back(a);\n  }\n  for(int i=0;i<H;++i){//????????????????????¢?´¢\n    if(0<=map[i].find('@') && map[i].find('@')<W){\n      y=map[i].find('@');\n      x=i;\n      break;\n    }\n  }\n    dfs(map,state,x,y,W,H);\n    cout << COUNT << endl;\n    map.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nchar f[50][50];\nbool v[50][50];\n\nint M,N;\n\nint dfs(int x, int y)\n{\n\tint ret=1;\n\tv[x][y]=1;\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint tx=x+dx[i], ty=y+dy[i];\n\t\tif(tx<0||tx>=M||ty<0||ty>=N) continue;\n\t\tif(f[tx][ty]=='#') continue;\n\t\tif(v[tx][ty]) continue;\n\n\t\tret+=dfs(tx,ty);\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile(cin >> M >> N, (M||N))\n\t{\n\t\tint sx,sy;\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<M; j++)\n\t\t{\n\t\t\tcin >> f[j][i];\n\t\t\tif(f[j][i]=='@')\n\t\t\t{\n\t\t\t\tsx=j;\n\t\t\t\tsy=i;\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(sx,sy) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\n\n\nvoid dfs(int x,int y){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif((x<0||y<0)||t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(x+dx[k],y+dy[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\n\tint w,h,sx,sy,cnt;\n\trep(i,20)rep(j,20){\nt[i][j]=='#';\t\n\t}\n\nwhile(true){\nscanf(\"%d %d/n\",&w,&h);\nif(!w&&!h) {break;}\nrep(i,h){\ncin >> t[i];\n}\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\ndfs(sx,sy);\ncnt =0;\n\nrep(i,h){ \n\trep(j,w)if(t[i][j]=='@') cnt++;\t\n}\n\ncout <<cnt <<endl;;\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[20][20] = {} ;\nint cnt,w, h, p[20][20] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 400; i++) {\n\t\t\tc[i / 20][i % 20] = p[i / 20][i % 20] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j][i] = 0;\n\t\t\t\t\tp[j][i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j][i] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1 || p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[0][i] == 0 && (p[0][i + 1] == 1 || p[0][i - 1] == 1)) {\n\t\t\t\t\t\tp[0][i] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i][0] == 0 && (p[i + 1][0] == 1 || p[i - 1][0] == 1)) {\n\t\t\t\t\t\tp[i][0] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*for (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j][i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h][i%h] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 金子先生へ\n// ITC-LMSの「第9回提出物」の提出期間が6/23までで、期間後の提出が不可になっています。\n// しかし月曜までに今回の課題全部は解き終わらないので、いつもの様に7月末までにしてくださると幸いです。\n// 多分、今回の課題は全部解けそうです。\n\n// Sampleは全部正解を出しましたが、ジャッジは通りませんでした。\n// 反例も作成できなかったです。\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility> // pair<int,int> xxxx;  make_pair(first,second);\n// 今から考えればstructで十分だった……\nusing namespace std;\n\nint W,H;\nint X,Y; // 自分の位置\nchar s[20+10];\nchar c;\nbool tile[20+10][20+10]; // タイルの状態。trueは黒、falseは赤(または壁)。\nbool visited[20+10][20+10];\nint answer;\n\n// 下方向がx軸(第1成分)、右方向がy軸(第2成分)。\n\nconst int dx[4] = { 1, 0, -1, 0 }; \nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool valid (int x, int y) {\n  return 0 <= x && x < H && 0 <= y && y < W && tile[x][y] ;\n}\n\nvoid init() { // 初期化\n  fill(&tile[0][0], &tile[0][0]+30*30, 0);\n  fill(&visited[0][0], &visited[0][0]+30*30, 0);\n  answer = 0;\n}\n\nvoid make_tile() { // タイル読み込み\n  for (int i=0; i<H; i++) {\n    scanf(\"%s\", s);\n    for (int j=0; j<W; j++) {\n      c = s[j];\n      if (c == '.') {\n\ttile[i][j] = true;\n      } else if (c == '@') {\n\ttile[i][j] = true;\n\tX = i;\n\tY = j;\n      }\n    }\n  }\n}\n\nvoid count_tile() {\n  queue<pair<int,int>> Q; // 幅優先探索を使う。周辺から徐々に探査する感じになるのでイメージしやすい。\n  pair<int,int> cur = make_pair(X,Y);\n  Q.push(cur);\n  while (!Q.empty()) {\n    cur = Q.front();\n    Q.pop();\n    if (visited[cur.first][cur.second]) {\n      continue;\n    }\n    visited[cur.first][cur.second] = true;\n    answer++;\n    for (int i=0; i<4; i++) {\n      int a = cur.first+dx[i];\n      int b = cur.second+dy[i];\n      if (valid(a, b) && !visited[a][b]) {\n\tQ.push(make_pair(a, b));\n      }\n    }\n  }\n  printf(\"%d\\n\", answer);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &W, &H) && W && H) {\n    init();\n    make_tile();\n    count_tile();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct TILE {\n\tchar tile;\n\tbool hantei;\n};\n\ntypedef pair<int, int> P;\n\nTILE yuka[20][20];\nint w, h;\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint si, sj;\n\t\tint imove[4] = {1, 0, -1, 0};\n\t\tint jmove[4] = {0, 1, 0, -1};\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> (yuka[i][j]).tile;\n\t\t\t\t(yuka[i][j]).hantei = false;\n\t\t\t\tif ((yuka[i][j]).tile == '@') {\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<P> q;\n\t\tq.push(P(si, sj));\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\t\t\t(yuka[p.first][p.second]).hantei = true;\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tif (0 <= p.first+imove[k] && p.first+imove[k] < h \n\t\t\t\t\t&& 0 <= p.second+jmove[k] && p.second+jmove[k] < w \n\t\t\t\t\t&& (yuka[p.first+imove[k]][p.second+jmove[k]]).tile == '.' \n\t\t\t\t\t&& !(yuka[p.first+imove[k]][p.second+jmove[k]]).hantei) {\n\t\t\t\t\t\tq.push(P(p.first+imove[k], p.second+jmove[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint counter = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif ((yuka[i][j]).hantei) {\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n\tint W=0,H=0;\n\tint posW=0,posH=0;\n\tint ans=0;\n\tint fposW=0,fposH=0;\n\tint n=0;\n\n\twhile(1){\n\tcin >> W >> H;\n\n\tif(H==0&&W==0) return 0;\n\n\tchar tile[20][20];\n\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin >> tile[i][j];\n\t\t}\n\t}\n\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(tile[i][j] == '@'){\n\t\t\t\tfposH = i;\n\t\t\t\tfposW = j;\n\t\t\t}\n\t\t}\n\t}\n\tposH = fposH;\n\tposW = fposW;\n\n\tfor(int n=0;n<1000*W*H;n++){\n\t\tif(tile[posH][posW-1]=='.'){\n\t\t\tans++;\n\t\t\ttile[posH][posW-1]='@';\n\t\t\tposW--;\n\t\t}\n\t\telse if(tile[posH-1][posW]=='.'){\n\t\t\tans++;\n\t\t\ttile[posH-1][posW]='@';\n\t\t\tposH--;\n\t\t}\n\t\telse if(tile[posH][posW+1]=='.'){\n\t\t\tans++;\n\t\t\ttile[posH][posW+1]='@';\n\t\t\tposW++;\n\t\t}\n\t\telse if(tile[posH+1][posW]=='.'){\n\t\t\tans++;\n\t\t\ttile[posH+1][posW]='@';\n\t\t\tposH++;\n\t\t}\n\t\telse if(tile[posH+1][posW]=='@'&&n%4==0){\n\t\t\tposH++;\n\t\t}\n\t\telse if(tile[posH][posW+1]=='@'&&n%4==1){\n\t\t\tposW++;\n\t\t}\n\t\telse if(tile[posH-1][posW]=='@'&&n%4==2){\n\t\t\tposH--;\n\t\t}\n\t\telse if(tile[posH][posW-1]=='@'&&n%4==3){\n\t\t\tposW--;\n\t\t}\n\t\tif(n==(1000*H*W)/4){\n\t\t\tposH=fposH;\n\t\t\tposW=fposW;\n\t\t}\n\t\tif(n==(1000*H*W)/2){\n\t\t\tposH=fposH;\n\t\t\tposW=fposW;\n\t\t}if(n==(1000*H*W*3)/4){\n\t\t\tposH=fposH;\n\t\t\tposW=fposW;\n\t\t}\n\t\t\n\t\t}\n\n\tcout << ans+1 << endl;\n\tans = 0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\ttile[i][j]='#';\n\t\t}\n\t}\n\tposH=0;\n\tposW=0;\n\tfposH=0;\n\tfposW=0;\n\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nvoid input_field(vector< vector< char > > &field, int w, int h);\nint reach_tile_num(vector< vector< char > > &field);\npair< int, int> search_start(vector< vector< char > > &field);\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint main(){\n  int w, h;\n\n  while(cin >> w >> h, w&&h){\n    vector< vector< char > >field(w+2, vector< char >(h+2, 0));\n    \n    input_field(field, w+2, h+2);\n    cout << reach_tile_num(field) << endl;\n  }\n}\n\n\nvoid input_field(vector< vector< char > > &field, int w, int h){\n  for(int y = 0; y < h; y++){\n    for(int x = 0; x < w; x++){\n      if(x == 0 || y == 0\n         || x == w-1 || y == h-1){\n\tfield[y][x] = '#';\n      }else{\n\tcin >> field[y][x];\n      }\n    }\n  }\n}\n\nint reach_tile_num(vector< vector< char > > &field){\n  int sum = 0;\n  pair< int, int > start, cur;\n  stack< pair< int, int > > s;\n\n  start = search_start(field);\n  s.push(start);\n\n  while(!(s.empty())){\n    cur = s.top();\n    s.pop();\n    if(field[cur.second][cur.first] == '.'\n       || field[cur.second][cur.first] == '@'){\n      sum++;\n      for(int i = 0; i < 4; i++){\n        s.push(make_pair(cur.first+dx[i], cur.second+dy[i]));\n\tfield[cur.second][cur.first] = '#';\n      }\n    }\n  }\n  return sum;\n}\n\npair< int, int> search_start(vector< vector< char > > &field){\n  for(int y = 0; y < field.size(); y++){\n    for(int x = 0; x < field[y].size(); x++){\n      if(field[y][x] == '@') return make_pair(x,y);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\nconst int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\nconst int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\nvoid dfs(int ci, int cj, vector<string>& board, VVI& visited, int h,int w){\n  visited[ci][cj] = 1;\n  rep(dir,4){\n    if((ci + dy[dir]) < h && (cj + dx[dir]) < w &&\n       (ci + dy[dir]) >= 0 && (cj + dx[dir]) >= 0  &&\n       visited[(ci + dy[dir])][(cj + dx[dir])] == 0 &&\n       board[(ci + dy[dir])][(cj + dx[dir])] == '.'){\n      dfs((ci + dy[dir]),(cj + dx[dir]),board,visited,h,w);\n    }\n  }\n}\n\nvoid solve(int h, int w){\n  vector<string> board(h);\n  rep(i,h) cin >> board[i];\n  VVI visited(h,VI(w,0));\n  int sy = 0;\n  int sx = 0;\n\n  rep(i,h)rep(j,w){\n    if(board[i][j] == '@'){\n      sx = j;\n      sy = i;\n      break;\n    }\n  }\n  dfs(sy,sx,board,visited,h,w);\n\n  int cnt = 0;\n  rep(i,h)rep(j,w) if(visited[i][j]) cnt++;\n  cout << cnt << endl;\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int h,w;\n  while(true){\n    cin >> w >> h;\n    if(h == 0 &&  w == 0){\n      break;\n    }\n    solve( h,  w);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n\nint w,h,ans,dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nchar c[22][22];\n\nvoid dfs(int y,int x){\n\tans++;\n\tc[y][x]='#';\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(c[ny][nx]=='.')dfs(ny,nx);\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\tans=0;\n\t\tint y,x;\n\t\trep2(i,1,h+1)rep2(j,1,w+1){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='@')y=i,x=j;\n\t\t}\n\t\tdfs(y,x);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint main()\n{\n    int w,h;\n    while(cin >> w >> h)\n    {\n        if(w == 0 && h == 0) break;\n\n        vector<string> s(h);\n        rep(i,h) cin >> s[i];\n\n        int sy,sx;\n        rep(i,h) {\n            rep(j,w) {\n                if(s[i][j] == '@') {\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n        \n        int ans = 1;\n        bool memo[25][25];\n        memset(memo,0,sizeof(memo));\n\n        queue<pair<int,int> > que;\n        que.push(make_pair(sy,sx));\n        memo[sy][sx] = true;\n        \n        while(que.size()) {\n            pair<int,int> p = que.front();\n            que.pop();\n            \n            rep(i,4) {\n                int ny = p.first + dy[i];\n                int nx = p.second + dx[i];\n\n                if(0 <= ny && ny < h && 0 <= nx && nx < w) {\n                    if(s[ny][nx] == '.' && !memo[ny][nx]) {\n                        ans++;\n                        memo[ny][nx] = true;\n                        que.push(make_pair(ny,nx));\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\n\nint main(){\n    std::vector<int> row;\n    int prev_col, width, height, max = 0, last = 0;\n    bool connect_prev_row;\n    \n    std::cin >> width >> height;\n    row.resize(width+1);\n    for( int i = 0; i <= width; i++ ) row[i] = 0;\n\n    std::string line;\n    while( true ){\n        std::cin >> line;\n        if( line == \"00\" ) {\n            std::cout << max;\n            break;\n        }\n        connect_prev_row = false;\n        for(std::string::size_type i = 0; i < line.size(); i++ ){\n            if( line[i] == '.' ){\n                if( connect_prev_row ){\n                    if( row[i] > 0 ) row[i+1] = row[i] + 1;\n                    else row[i+1] = row[i] - 1;\n                } else {\n                    connect_prev_row = true;\n                    if( row[i] <= 0 && row[i+1] <= 0 ) row[i+1] = row[i+1] + row[i] - 1;\n                    else row[i+1] = std::abs(row[i+1]) + std::abs(row[i]) + 1;\n                }\n            } else if( line[i] == '@' ) {\n                if ( connect_prev_row ) row[i+1] = - row[i] + 1;\n                else {\n                    connect_prev_row = true;\n                    row[i+1] = - row[i+1] - row[i] + 1;\n                }\n            } else {\n                row[i+1] = 0;\n                connect_prev_row = false;\n            }\n            max = max > row[i+1] ? max : row[i+1];\n        }\n        last = 0;\n        for( int i = line.size(); i > 0; i-- ) {\n            if( row[i] == 0 ) last = 0;\n            else if( row[i] > 0 ){\n                if(  last == 0 ) last = row[i];\n                else row[i] = last;\n            } else {\n                if(  last == 0 ) last = row[i];\n                else row[i] = last;\n            } \n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_INT  100005\nusing namespace std;\n\n//??\\???????????§???\n#define MAX_X  22\n#define MAX_Y  22\n\n//?????°\nchar field[MAX_X][MAX_Y];\nint X, Y;\nint px, py;                     // players position\n\n\n//?§????4?????????????????????\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1,  0, -1};\n\n\nvoid initialize_field() {\n  for (int y = 0; y < Y; y++ ) {\n    for (int x = 0; x < X; x++ ) {\n      field[x][y] = '#';\n    }\n  }\n}\n\nvoid print_field() {\n  for (int y = 0; y < Y; y++ ) {\n    for (int x = 0; x < X; x++ ) {\n      cout << field[x][y];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n\nvoid dfs(int x, int y) {\n\n  field[x][y] = '$';            // ?¨????????????¨?????°\n\n  for (int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(field[nx][ny] == '.') {\n      dfs(nx, ny);\n    }\n  }\n\n}\n\n\nint main() {\n\n  while(true) {\n\n    initialize_field();\n\n    cin >> X >> Y;\n\n    if(X == 0 && Y == 0) break;\n\n    for(int y = 0; y < Y; y++ ){\n      for(int x = 0; x < X; x++ ){\n        cin >> field[x][y];\n        if( field[x][y] == '@' ) { px = x; py = y; }\n      }\n    }\n\n    dfs(px, py);\n\n    // ?¨?????????´????????°??????\n    int res = 0;\n    for(int y = 0; y < Y; y++ ){\n      for(int x = 0; x < X; x++ ){\n        if ( field[x][y] == '$' ) { res++; }\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint rec(string field[], int x, int y, int w, int h){\n    int count=1;\n    int f=0;\n    field[y][x] = ',';\n    if(x+1<w && field[y][x+1] == '.'){\n        count += rec(field, x+1, y, w, h);\n    }\n    if(y+1<h && field[y+1][x] == '.'){\n        count += rec(field, x, y+1, w, h);\n    }\n    if(x-1>=0 && field[y][x-1] == '.'){\n        count += rec(field, x-1, y, w, h);\n    }\n    if(y-1>=0 && field[y-1][x] == '.'){\n        count += rec(field, x, y-1, w, h);\n    }\n    return count;\n}\n\nint main(){\n    int w, h;\n    string field[20];\n    int x, y;\n    cin >> w >> h;\n    while(w || h){\n        x = string::npos;\n        for(int i=0;i<h;++i){\n            cin >> field[i];\n            if(x==string::npos){\n                x = field[i].find('@');\n                y = i;\n            }\n        }\n        cout << rec(field, x, y, w, h) << endl;\n        cin >> w >> h;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n// #define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n\nint w,h,fx,fy;\nchar ban[30][30];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nbool inrange(int px,int py){\n  if(px<0||py<0||px>=h||py>=w) return false;\n  else return true;\n}\nint bsearch(int px,int py){\n  int cnt = 0;\n  REP(i,4){\n    int nx = px+ dx[i]; int ny = py+dy[i];\n    if(!inrange(nx,ny)) continue;\n    if(ban[nx][ny]=='#') continue;\n    //cnt++;\n    //cout << nx << \" \" <<ny<<endl;\n    if(ban[nx][ny]=='.'){\n      ban[nx][ny]='!';\n      cnt++;\n      cnt += bsearch(nx,ny);\n    }\n  }\n  return cnt;\n}\n\nint main(){\n  while(1){\n    cin >> w >> h;\n    if((w==0)&&(h==0)) break;\n    REP(i,h){\n      char buf[21];\n      cin >> buf;\n      REP(j,w) {\n        ban[i][j] = buf[j];\n        if(ban[i][j] == '@'){\n          fx = i; fy = j;\n        }\n      }\n    } \n    cout << bsearch(fx,fy)+1 << endl;\n    REP(i,h){\n      REP(j,w){\n        cout << ban[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<math.h>\n\nusing namespace::std;\n\nchar gMap[22][22];\nbool MapFlg[22][22];\nint gRedCount;\nvoid initMap(void)\n{\n  for(int i = 0; i < 22; i++)\n    {\n      for(int j = 0; j < 22; j++)\n\t{\n\t  gMap[i][j] = '#';\n\t  MapFlg[i][j] = false;\n\t}\n    }\n  gRedCount = 0;\n}\n\nvoid showMap(void)\n{\n  for(int i = 0; i < 22; i++)\n    {\n      for(int j = 0; j < 22; j++)\n\t{\n\t  cout << gMap[i][j];\n\t}\n      cout << endl;\n    } \n}\n\nint countMap(int x , int y)\n{\n  int dx[] = { 0  , 1 , -1 , 0 };\n  int dy[] = { -1 , 0 ,  0 , 1 };\n\n  for(int i = 0; i < 4; i++)\n    {\n      int mx = x + dx[i];\n      int my = y + dy[i];\n\n      if( gMap[my][mx] != '@' && gMap[my][mx] != '#' && MapFlg[my][mx] == false)\n\t{\n\t  gRedCount++;\n\t  MapFlg[my][mx] = true;\n\t  countMap(mx , my);\n\t}\n    }\n\n  return gRedCount;\n\n}\n\nvoid calcAns(int sx, int sy)\n{\n  cout << countMap(sx,sy) + 1 << endl;\n}\n\nint main(void)\n{\n\n  int w,h;\n\n  while( cin >> w >> h  && (w != 0 && h != 0))\n    {\n      int sx,sy;\n      initMap();\n      for(int i = 1; i <= h; i++)\n\t{\n\t  for(int j = 1; j <= w; j++)\n\t    {\n\t      cin >> gMap[i][j];\n\t      if( gMap[i][j] == '@')\n\t\t{\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t}\n\t    }\n\t}\n      calcAns(sx,sy);\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint W,H;\nint t[20][20];\nint c;\nchar ch;\n\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nbool inField(int y,int x){\n  if( 0<=y && y<H && 0<=x && x<W ){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nvoid visit(int y,int x){\n  c++;\n  t[y][x]=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if( inField(ny,nx) && t[ny][nx]==0){\n      visit(ny,nx);\n    }\n  }\n}\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    int sy,sx;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>ch;\n        if(ch=='.'){\n          t[i][j]=0;\n        }\n        if(ch=='@'){\n          sy=i;\n          sx=j;\n        }\n        if(ch=='#'){\n          t[i][j]=-1;\n        }\n      }\n    }\n    c=0;\n    visit(sy,sx);\n    cout<<c<<endl;\n  }\n  return 0; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint h, w;\n\twhile (cin >> w >> h, h)\n\t{\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint st;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '@')\n\t\t\t{\n\t\t\t\tst = place(i, j, w);\n\t\t\t\tfld[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(h*w);\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tREP(k, 4)\n\t\t\t{\n\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '#') continue;\n\t\t\t\tuf.unite(place(i, j, w), place(nx, ny, w));\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tREP(i, h*w)\n\t\t{\n\t\t\tif (uf.same(i, st)) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n  while(1){\n    int H,W,count=0,kaisuu=0,kosuu,sum=1,judge;\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    char map[W][H];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(20);\n    nexty.reserve(20);\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[0].push_back(cW);\n\t    nexty[0].push_back(cH);\n\t  }\n\t}\n    }\n    \n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    \n    cout << sum <<endl;\n    \n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cout << map[cW][cH];\n\t}\n\tcout << endl;\n    }\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nstruct MapHeader {\n\tint w;\n\tint h;\n};\n\nMapHeader read_header() {\n\tstd::string line;\n\tstd::getline(std::cin, line);\n\tstd::istringstream line_stream(line);\n\tMapHeader result;\n\tline_stream >> result.w >> result.h;\n\treturn result;\n}\n\nstruct SearchContext {\n\tMapHeader header;\n\tstd::vector<bool> map;\n\tstd::vector<bool> reached_map;\n\n\tSearchContext(MapHeader header)\n\t\t: header(header),\n\t\treached_map(header.w * header.h)\n\t{\n\t\tmap.reserve(header.w * header.h);\n\t}\n\n\tsize_t index(int x, int y) {\n\t\treturn (size_t)header.w * y + x;\n\t}\n};\n\nvoid search(SearchContext& context, int x, int y) {\n\tif (x < 0 || x >= context.header.w || y < 0 || y >= context.header.h) return;\n\n\tsize_t index = context.index(x, y);\n\tif (context.reached_map[index] || !context.map[index]) return;\n\n\tcontext.reached_map[index] = true;\n\t\n\tsearch(context, x + 1, y);\n\tsearch(context, x - 1, y);\n\tsearch(context, x, y + 1);\n\tsearch(context, x, y - 1);\n}\n\nint main()\n{\n\twhile (true) {\n\t\tMapHeader header = read_header();\n\t\tif (header.w == 0 && header.h == 0) break;\n\n\t\tSearchContext context(header);\n\t\tint start_x, start_y;\n\n\t\tfor (int y = 0; y < header.h; y++) {\n\t\t\tstd::string line;\n\t\t\tstd::getline(std::cin, line);\n\n\t\t\tfor (int x = 0; x < header.w; x++) {\n\t\t\t\tswitch (line[x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tcontext.map.push_back(true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tcontext.map.push_back(false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tstart_x = x;\n\t\t\t\t\tstart_y = y;\n\t\t\t\t\tcontext.map.push_back(true);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsearch(context, start_x, start_y);\n\n\t\tsize_t count = 0;\n\t\tfor (bool b : context.reached_map) {\n\t\t\tif (b) count++;\n\t\t}\n\t\t\n\t\tstd::cout << count << std::endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 現在地から四方向みて、移動先が黒いタイル.ならカウントをインクリメントしていく。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// タイルの行数\nint w;\nint h;\n\n// 現在地（初期位置）\nchar field[22][22];\n\n// カウント\nint cnt;\n\n// 移動　　　右　左　上　下\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\n\nvoid dfs(int x, int y) {\n  // カウント追加\n  cnt++;\n  // 確認済みの印として赤いタイル#に変更\n  field[x][y] = '#';\n  // 四方向を確認する\n  for (int i = 0; i < 4; ++i) {\n    // 確認する座標\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    // 確認する座標が、タイル範囲からはみ出していない&&黒いタイル.である\n    if (0 <= nx &&\n        nx < w &&\n        0 <= ny &&\n        ny < h &&\n        field[nx][ny] == '.') {\n      // 確認する座標へ移動して、そこからまた四方向を確認する\n      dfs(nx, ny);\n    }\n  }\n}\n\nint main() {\n  // 入力データセットがある限り繰り返す\n  while(cin >> w >> h, w) {\n    cnt = 0;\n    int x;\n    int y;\n    // 一行ずつタイルを調べて人@を探す [0][0], [1][0], [2][0]...\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> field[j][i];\n        if (field[j][i] == '@') {\n          x = j;\n          y = i;\n        }\n      }\n    }\n    // 人@のタイルからdfs実行\n    dfs(x, y);\n    cout << cnt << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans[50],cnt=0,sx,sy;\nstring m[20],t,s;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tqueue<pair<int, int>> q;\n\t\tchar map[114][514];\n\t\tbool b[114][514] = {};\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')q.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\twhile (q.size()) {\n\t\t\tans++;\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\tmap[x][y] = '#';\n\t\t\tb[x][y] = true;\n\t\t\tif (map[x - 1][y] == '.' && !b[x - 1][y]) {\n\t\t\t\tq.push(make_pair(x - 1, y));\n\t\t\t\tb[x - 1][y] = true;\n\t\t\t}\n\t\t\tif (map[x + 1][y] == '.' && !b[x + 1][y]) {\n\t\t\t\tq.push(make_pair(x + 1, y));\n\t\t\t\tb[x + 1][y] = true;\n\t\t\t}\n\t\t\tif (map[x][y - 1] == '.' && !b[x][y - 1]) {\n\t\t\t\tq.push(make_pair(x, y - 1));\n\t\t\t\tb[x][y - 1] = true;\n\t\t\t}\n\t\t\tif (map[x][y + 1] == '.' && !b[x][y + 1]) {\n\t\t\t\tb[x][y + 1] = true;\n\t\t\t\tq.push(make_pair(x, y + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(a,b) for(int (a)=0;(a)<(b);(a)++)\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n    if(w==0 && h==0)break;\n    int sx,sy;\n    int sum=0;\n    int dy[]={-1,0,1,0};\n    int dx[]={0,-1,0,1};\n    \n    \n    string data[30]={};\n    \n    for(int i=0;i<h;i++){\n        cin>>data[i];\n    }\n    \n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(data[i][j]=='@'){\n                sx=j;sy=i;\n                break;\n            }\n        }\n    }\n    \n    bool visited[30][30]={};\n    \n    queue<pair<int,int> > que;\n    \n    que.push( pair<int,int>(sy,sx) );\n    visited[sy][sx]=true;\n    \n    while(que.size()){\n        int qff=que.front().first,qfs=que.front().second;\n        sum++;\n        rep(i,4){\n            if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false && data[ qff+dy[i] ][ qfs+dx[i] ]=='.' ){\n                que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n            }\n        }\n            \n        que.pop();\n    }\n    \n    cout<<sum<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nint solve(int width, int height) {\n    std::vector<bool> available((width + 2) * (height + 2));\n    std::vector<std::pair<int, int>> fringe;\n    auto access = [&](int x, int y){ return available[y * (width + 2) + x]; };\n\n    int current_x = 0, current_y = 0;\n\n    for (int y = 1; y <= height; y++) {\n        for (int x = 1; x <= width; x++) {\n            char c;\n            std::cin >> c;\n            access(x,y) = c == '.';\n            switch (c){\n                case '.':\n                    access(x, y) = true;\n                    break;\n                case '@':\n                    access(x, y) = true;\n                    current_x = x;\n                    current_y = y;\n                    break;\n            }\n        }\n    }\n\n    fringe.push_back(std::make_pair(current_x, current_y));\n\n    int num = 0;\n    while (!fringe.empty()) {\n        auto top = fringe.back();\n        fringe.pop_back();\n        auto x = top.first, y = top.second;\n        if (access(x, y)) {\n            num++;\n            access(x, y) = false;\n            fringe.push_back(std::make_pair(x + 1, y));\n            fringe.push_back(std::make_pair(x - 1, y));\n            fringe.push_back(std::make_pair(x, y + 1));\n            fringe.push_back(std::make_pair(x, y - 1));\n        }\n    }\n\n    return num;\n}\n\nint main() {\n    int w, h;\n    while (std::cin >> w >> h) {\n        if (w == 0 && h == 0) {\n            break;\n        }\n        std::cout << solve(w, h) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MAX_WH 20\n\nusing namespace std;\n\nvoid solve();\nvoid dfs(int x, int y);\n\nint W,H,count;\nchar field[MAX_WH][MAX_WH+1];\n\nint main()\n{\n    while (1) {\n        cin>>W>>H;\n        if (W==0&&H==0) break;\n        for (int i=0; i<H; i++) cin>>field[i];\n        solve();\n    }\n    return 0;\n}\n\nvoid solve()\n{\n    for (int i=0; i<H; i++) {\n        for (int j=0; j<W; j++) {\n            if (field[i][j]=='@') {\n                count=1;\n                dfs(i,j);\n                cout<<count<<endl;\n                return ;\n            }\n        }\n    }\n}\n\nvoid dfs(int x, int y)\n{\n    field[x][y]='#';\n    \n    \n    if (x-1>=0&&field[x-1][y]=='.') {\n        count++;\n        dfs(x-1,y);\n    }\n    if (y-1>=0&&field[x][y-1]=='.') {\n        count++;\n        dfs(x,y-1);\n    }\n    if (x+1<H&&field[x+1][y]=='.') {\n        count++;\n        dfs(x+1,y);\n    }\n    if (y+1<W&&field[x][y+1]=='.') {\n    \tcount++;\n        dfs(x,y+1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1};\nint dx[] = {1, -1, 0, 0};\n\nvoid datasets(int h, int w) {\n    \n    char table[h][w];\n    rep(i, h) rep(j, w) cin >> table[i][j];\n    queue<pii> q;\n    int sum = 1;\n    rep(i, h) rep(j, w) if (table[i][j] == '@') {q.push({i, j}); table[i][j] = 'r';}\n    while (!q.empty()) {\n        int y = q.front().first;\n        int x = q.front().second;\n        q.pop();\n        rep(i, 4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n            if (table[ny][nx] == '#' || table[ny][nx] == 'r') continue;\n            q.push({ny, nx});\n            table[ny][nx] = 'r';\n            sum++;\n        }\n    }/*\n    rep(i, h) {\n        rep(j, w) cout << table[i][j] << \" \";\n        cout << endl;\n    }*/\n    cout << sum << endl;\n    \n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int h, w;\n    while (cin >> w >> h && w) {\n        datasets(h, w);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_N 50\n#define MAX_R 50\n\n#define MAX_W 20\n#define MAX_H 20\n\nint W, H;\nint ans = 0;\nchar maze[MAX_W][MAX_H];\n\nvoid dfs(int sx, int sy){\n\t\n\tint dx[] = { 1, 0, -1, 0 };\n\tint dy[] = { 0, 1, 0, -1 };\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H && maze[ny][nx] != '#'){\n\t\t\tmaze[ny][nx] = '#';\n\t\t\tans++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile (true){\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint sx;\n\t\tint sy;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tdfs(sx,sy);\n\t\tcout << ans << endl;\n\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int di[4] = {\n\t1, 0, -1, 0\n};\nconst int di2[4] = {\n\t0, 1, 0, -1\n};\n\nconst int max_size = 20;\nint move(char area[max_size+2][max_size+2], int sh, int sw){\n\tif(area[sh][sw] == '#') return 0;\n\tint count = 1;\n\tarea[sh][sw] = '#';\n\tfor(int i = 0; i < 4; i++){\n\t\tcount += move(area, sh + di[i], sw + di2[i]);\n\t}\n\treturn count;\n}\n\nint main(){\n\tchar area[max_size+2][max_size+2];\n\tint sh, sw;\n\tint h, w;\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(int i = 0;i < max_size+2; i++){\n\t\t\tfor(int j = 0; j < max_size+2; j++){\n\t\t\t\tarea[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tcin >> area[i][j];\n\t\t\t\tif(area[i][j] == '@'){\n\t\t\t\t\tsh = i; sw = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << move(area, sh, sw) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nchar map_[20][20];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint fill(int x, int y) {\n    int count = 1;\n    map_[x][y] = '#';\n    for (int i=0; i<4; i++) {\n        int x_new = x+dx[i];\n        int y_new = y+dy[i];\n        if (0 <= x_new && x_new < w && 0 <= y_new && y_new < h) {\n            if (map_[x_new][y_new] == '.') {\n                count += fill(x_new, y_new);\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int x_start, y_start;\n    while (true) {\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                cin >> map_[j][i];\n                if (map_[j][i] == '@') {\n                    x_start = j;\n                    y_start = i;\n                }\n            }\n            cin.ignore(1);\n        }\n        cout << fill(x_start, y_start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nchar maps[22][22];\nint count;\nint me[2];\nint w,h;\n\nvoid init(){\n  for(int i = 0; i < 22; i++){\n    for(int j = 0; j < 22; j++){\n      maps[i][j] = '#';\n    }\n  }\n}\n\nvoid where(int w,int h){\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(maps[i][j] == '@'){\n\tme[0] = i;\n\tme[1] = j;\n\tmaps[i][j] = '.';\n\treturn;\n      }\n    }\n  }\n}\n\nvoid search(int y, int x){\n  maps[y][x] = '#';\n  count++;\n  if(maps[y - 1][x] == '.' && y > 0){\n    search(y - 1, x);\n  }\n  if(maps[y + 1][x] == '.' && y < h){\n    search(y + 1, x);\n  }\n  if(maps[y][x - 1] == '.' && x > 0){\n    search(y, x - 1);\n  }\n  if(maps[y][x + 1] == '.' && x < w){\n    search(y, x + 1);\n  }\n  return;\n}\n  \nint main(){\n  while(true){\n    // input \n    cin >> w >> h;\n    if(!w && !h){\n      break;\n    }\n    init();\n    for(int i = 0; i < h; i++){\n      cin >> maps[i];\n    }\n    count = 0;\n    where(w, h);\n    search(me[0], me[1]);\n\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std;\n\n#define HMAX 20\n#define WMAX 20\n\nchar room[HMAX+5][WMAX+5];\nint W,H;\n\ntypedef struct{\n\tint x;\n\tint y;\n}map;\n\nint solve(int x,int y){\n\tint dx[4]={ 0, 0, 1,-1};\n\tint dy[4]={ 1,-1, 0, 0};\n\tint cnt=0;\n\n\troom[y][x]='#';\n\t\n\tfor(int i=0;i<4;i++){\n\t\tif(x+dx[i]>=0&&x+dx[i]<W&&y+dy[i]>=0&&y+dy[i]<H){\n\t\t\tif(room[y+dy[i]][x+dx[i]]=='.'){\n\t\t\t\tcnt+=solve(x+dx[i],y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt+1;\n}\n\nint main(void){\n\n\tmap start;\n\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0&&H==0) break;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>room[i][j];\n\t\t\t\tif(room[i][j]=='@') start.x=j,start.y=i;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(start.x,start.y)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\ttot++;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      char fld[H][W];\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      bool visited[H][W];\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)visited[i][j]=0;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         visited[now.first][now.second]=1;\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#') continue;\n            if(visited[ni][nj]) continue;\n            Q.push(pii(ni, nj));\n         }\n      }\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=visited[i][j];\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring place[20];\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0},n,m;\nint serch(int y,int x)\n{\n\tint ans=1;\n\tplace[y][x]='#';\n\tfor(int i=0,ax,ay;i<4;i++)if((ay=dy[i]+y)<m&&(ax=dx[i]+x)<n&&ay>=0&&ax>=0&&place[ay][ax]=='.')ans+=serch(ay,ax);\n\treturn ans;\n}\nint main() {\n\twhile(cin>>n>>m,n,m){\n\t\tfor(int i=0;i<m;i++)cin>>place[i];\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++)if(place[i][j]=='@')cout<<serch(i,j)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm> \n#include<functional> \n#include<cassert>\n#include<numeric> // std::accumulate(vec.begin(),vec.end(),0) sum of element\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<queue>\n#include<map>\n#include<set>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef std::pair<int, int> P;\ntypedef vector<int> vi;\n\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define all(c) c.begin(),c.end()\n#define show(x) cout << #x << \" = \" << x << endl\n\n#define fi first\n#define se second\n#define pb push_back\n\n\n\n#define DEBUG\n\n\n// void print_vector(const std::vector<int> &t);\n// void unique_vector(std:: vector<int> &t);\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t);\ntemplate <class X>\nvoid unique_vector(std:: vector<X> &t);\n\n\nint w, h;\n\nvector<int> xl={-1, 0, 1, 0};\nvector<int> yl={0, 1, 0, -1};\n\nint main(){\n\n  vi ans;\n  while(true){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    vector<vector<char>> f(h, vector<char>(w));\n    queue<P> ser;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) {\n\tcin >> f[i][j];\n\tif(f[i][j] == '@')\n\t  ser.push(make_pair(i, j));\n      }\n    }\n    int c = 0;\n    while(!ser.empty()){\n      P t = ser.front();\n      ser.pop();\n      int y = t.fi, x = t.se;\n      // show(x); show(y);\n      if(f[y][x] == '@') f[y][x] = '#';\n      for(int i = 0; i < 4; i++) {\n\tint dx = x+xl[i], dy=y+yl[i];\n\t// cout << dx << ' ' << dy << endl;\n\t// show(dx); show(dy);\n\tif(dy < 0 || dy >= h || dx < 0 || dx >= w || f[dy][dx] == '#')\n\t  continue;\n\t\n\tif(f[dy][dx] == '.'){\n\t  c++;\n\t  ser.push(make_pair(dy, dx));\n\t  f[dy][dx] = '#';\n\t}\n      }\t\n      // for(int i = 0; i < h; i++) {\n      // \tfor(int j = 0; j < w; j++) {\n      // \t  cout << f[i][j] << ' ';\n      // \t}\n      // \tcout << endl;\n      // }\n      // cout << endl;\n    }\n    ans.pb(c+1);\n  }\n  for(auto &i : ans) cout << i << endl;\n}\n\ntemplate <class X>\nvoid unique_vector(std::vector<X> &t)\n{\n  std::sort(t.begin(), t.end());\n  t.erase( std::unique(t.begin(), t.end()), t.end() );\n}\n\ntemplate <class X>\nvoid print_vector(const std::vector<X> &t){\n  for(auto itr=t.begin(); itr != t.end(); itr++){\n    std::cout << *itr;\n    if(itr != t.end()-1) std::cout << ' ';\n  }\n  std::cout << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#define rep(i, n) for (int i=0; i<n; ++i)\n#define FOR(i, a, b) for (int i=a; i<b; ++i)\n#define pb(x) push_back(x)\n#define ll long long\n#define ul unsigned long long\n#define dbg(x) cout  << #x << \" : \" << (x) << endl\n#define out(x) cout << (x)\n#define outl(x) cout << (x) << endl\n#define int(n); int n; cin >> n;\n#define long(n); long long n; cin >> n;\n#define dbl(f); double f; cin >> f;\n#define s(s); string s; cin >> s;\n#define into(a, n) for (int i = 0; i < n; ++i) cin >> a[i]\nusing namespace std;\n\nconst int inf =1500000000;\nchar a[20][20];\nint cnt; \nint w,h; \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1}; \nvoid dfs(int x, int y) {\n  a[x][y] = '#';\n  cnt++;\n  rep(i, 4) {\n    int nx=x+dx[i];\n    int ny=y+dy[i]; \n    if(nx<w&&ny<h&&nx>=0&&ny>=0&&a[ny][nx]=='.') dfs(nx, ny);\n  }\n}\n\nint main () {\n  while(1){\n    cnt = 0;\n    cin>>w>>h;\n    if (!w && !h) break;\n    int x0,y0;\n    rep(i, h) {\n      rep(j, w) {\n        cin>>a[i][j];\n        if(a[i][j]=='@' ) {\n          x0=j; y0=i;\n          a[i][j]='.';\n        }\n      } \n    } \n    dfs(x0, y0);\n    outl(cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n\nusing namespace std;\n \nconst double eps=1e-10;\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\n\nint main()\n{\n\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<string> t(h);\n\t\tvector< vector<bool> > visited(h,vector<bool>(w,false));\n\t\tint x,y,res=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>t[i];\n\t\t\tif(t[i].find(\"@\")!=string::npos){\n\t\t\t\tx=t[i].find(\"@\"); y=i;\n\t\t\t}\n\t\t}\n\n\t\tqueue< pair<int,int> > q;\n\t\tq.push(make_pair(y,x));\n\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> p=q.front();\n\t\t\tq.pop();\n\t\t\ty=p.first; x=p.second;\n\n\t\t\tif(!visited[y][x]){\n\t\t\t\tres++;\n\t\t\t\tvisited[y][x]=true;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h && t[ny][nx]=='.') q.push(make_pair(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\n  if(a[y-1][x]=='.'&&y!=0)dfs(y-1,x);\n  if(a[y+1][x]=='.'&&y!=20)dfs(y+1,x);\n  if(a[y][x-1]=='.'&&x!=0)dfs(y,x-1);\n  if(a[y][x+1]=='.'&&x!=20)dfs(y,x+1);\n  return;\n}\nint main(){\n  int w,h,i,j;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%c\",&a[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nclass Field {\n  public:\n  vector<vector<bool> > field;\n  int nx, ny;\n  bool def;\n  Field(int nnx, int nny, bool firs, bool ddef) {\n    def = ddef;\n    nx = nnx;\n    ny = nny;\n    vector<vector<bool> > buff(nnx, vector<bool>(nny, firs));\n    field = buff;\n  }\n  void set(int x, int y, bool flag) {\n    field[x][y] = flag;\n  }\n  bool get(int x, int y) {\n    if(x >= nx || y >= ny || x < 0 || y < 0) return def;\n    return field[x][y];\n  }\n  void print() {\n    for(int i = 0; i < ny; ++i) {\n      for(int j = 0; j < nx; ++j) {\n        cout << field[j][i];\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n};\nint mark(Field&, Field&, int x, int y);\n\nint main() {\n  while(1) {\n    int nx, ny;\n    cin >> nx >> ny;\n    if(!nx && !ny) break;\n    Field field(nx, ny, false, false);\n    int startx, starty;\n    for(int i = 0; i < ny; ++i) {\n      for(int j = 0; j < nx; ++j) {\n        char c;\n        cin >> c;\n        field.set(j, i, ((c == '#') ? false : true));\n        if(c == '@') {\n          startx = j;\n          starty = i;\n        }\n      }\n    }\n    //for(auto i = field.begin(); i != field.end(); ++i) {\n    //  for(auto j = field[i].begin(); j != field[j].end(); ++j) {\n    //    cout << field[i][j];\n    //  }\n    //  cout << endl;\n    //}\n    Field result(nx, ny, false, true);\n    cout << mark(field, result, startx, starty) << endl;\n  }\n  return 0;\n}\n\nint mark(Field &field, Field &result, int x, int y) {\n  int count;\n  if(field.get(x, y) && !result.get(x, y)) {\n    result.set(x, y, true);\n    count = mark(field, result, x + 1, y);\n    count += mark(field, result, x, y + 1);\n    count += mark(field, result, x - 1, y);\n    count += mark(field, result, x, y - 1);\n    ++count;\n    return count;\n  } else {\n    return 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nint box[20][20];\nint  kazoe(int p,int P){\n  a++;\n  box[p][P]=0;\n  if(box[p][P+1]==1) kazoe(p,P+1);\n  if(box[p][P-1]==1) kazoe(p,P-1);\n  if(box[p-1][P]==1) kazoe(p-1,P);\n  if(box[p+1][P]==1) kazoe(p+1,P);\n  return a;\n}\nint main(){\n  int i,I,H,W,p,P;\n  \n  char v;\n  while(1){\n  cin>>W>>H;\n  if(W==0&&H==0) break;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  cout<<kazoe(p,P)<<endl;\n  a=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint dx[4] = {0,1,0,-1}, dy[4] = {1,0,-1,0};\n\nint W, H, ans;\nstring grid[22];\n\nint rec(int x, int y) {\n\tint res = 1;\n\t\n\tgrid[y][x] = '#';\n\t\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n\t\tif (grid[ny][nx] == '#') continue;\n\t\tres += rec(nx, ny);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(i,0,H) cin >> grid[i];\n\t\t\n\t\tfor_(i,0,H) for_(j,0,W) if (grid[i][j] == '@') cout << rec(j, i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar c[25][25];\nvoid dfs(int x,int y,int w,int h) {\n\tc[x][y] = '!';\n\n\tfor (int i = -1;i <= 1;i++) {\n\t\tint ax = x + i;\n\t\tif (ax >= 0 && ax < h&&c[ax][y] == '.')dfs(ax, y, w, h);\n\t}\n\tfor (int i = -1;i<= 1;i++) {\n\t\tint ay = y + i;\n\t\tif (ay >= 0 && ay < w&&c[x][ay] == '.')dfs(x, ay, w, h);\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h,w,h) {\n\t\tfor (int i = 0;i < h;i++) {\n\t\t\tfor (int j = 0;j < w;j++)cin >> c[i][j];\n\t\t}\n\n\t\tfor (int i = 0;i < h;i++) {\n\t\t\tfor (int j = 0;j < w;j++) {\n\t\t\t\tif (c[i][j] == '@')dfs(i,j,w,h);\n\t\t\t}\n\t\t}\n\t\tint al = 0;\n\t\tfor (int i = 0;i < h;i++) {\n\t\t\tfor (int j = 0;j < w;j++) {\n\t\t\t\tif (c[i][j] == '!')al++;\n\t\t\t}\n\t\t}\n\t\tcout << al << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n\nint w,h,ans,dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nchar c[22][22];\n\nvoid dfs(int y,int x){\n\tans++;\n\tc[y][x]='#';\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(0<=ny && ny<h && 0<=nx && nx<w && c[ny][nx]=='.')dfs(ny,nx);\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\tans=0;\n\t\tint y,x;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]=='@')y=i,x=j;\n\t\t}\n\t\tdfs(y,x);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <array>\n\nconst int kSize = 20 + 2;\n\nstd::array<int, 4> ways = {-1, -kSize, +1, +kSize};\n\ninline int xy2pos(const int x, const int y){\n    return x + y * kSize;\n}\n\nstd::array<bool, kSize*kSize> Bfs(const std::array<bool, kSize*kSize> &tiles, int pos){\n    std::array<bool, kSize*kSize> arrived;\n    std::queue<int> q;\n    q.push(pos);\n    std::fill(arrived.begin(), arrived.end(), false);\n    while(!q.empty()){\n        pos = q.front();\n        q.pop();\n        arrived[pos] = true;\n        for(int way : ways)\n            if(tiles.at(pos + way) && !arrived.at(pos + way))\n                q.push(pos + way);\n    }\n    return arrived;\n}\n\nint main(){\n    int w,h;\n    std::array<bool,kSize*kSize> tiles; ///< true if black\n    while((std::cin >> w >> h) && w != 0){\n        std::fill(tiles.begin(), tiles.end(), false);\n        int pos;\n        for(int y=1; y<=h; ++y){\n            for(int x=1; x<=w; ++x){\n                char c;\n                std::cin >> c;\n                tiles[xy2pos(x,y)] = (c == '.');\n                if(c == '@'){\n                    pos = xy2pos(x,y);\n                    tiles[pos] = true;\n                }\n            }\n        }\n        auto arrived = Bfs(tiles, pos);\n        int sum = 0;\n        for(bool v : arrived)\n            sum += (v) ? 1 : 0;\n        std::cout << sum << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint INF=1e9;\n\nint main(){\n\tint dx[4]={0,1,0,-1};\n    int dy[4]={1,0,-1,0};\n\n\tint w,h;\n\twhile(cin>>w>>h and w>0){\n\t\tqueue<pair<int,int>> q;\n\t    int sy,sx;\n\t\tchar c[h][w]; int d[h][w];\n\t\trep(i,h){\n\t        rep(j,w){\n\t            cin>>c[i][j]; d[i][j]=INF;\n\t\t\t\tif(c[i][j]=='@'){\n\t\t\t\t\tsy=i; sx=j;\n\t\t\t\t}\n\t        }\n\t    }\n\t\td[sy][sx]=0;\n\t    q.push(make_pair(sy,sx));\n\n\t\tint ans=1;\n\t\twhile(q.size()){\n\t        pair<int,int> p=q.front(); //キューの先頭を取り出す\n\t        q.pop(); //取り出したら削除\n\t        int prev=d[p.first][p.second]; //一手前の手数prev\n\t        rep(i,4){ //4方向探索\n\t            int cy=p.first+dy[i];\n\t            int cx=p.second+dx[i];\n\t            if(c[cy][cx]=='.' and d[cy][cx]==INF){ //通行可能かつ未到達\n\t\t\t\t\tif(0<=cy and cy<h){\n\t\t\t\t\t\tif(0<=cx and cx<w){\n\t\t\t\t\t\t\td[cy][cx]=prev+1;\n\t\t\t                q.push(make_pair(cy,cx));\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t            }\n\t        }\n\t    }\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<stdio.h>\n    //#include <bits/stdc++.h>\n    #include<vector>\n    #include<float.h>\n    #include<iomanip>\n    #include<algorithm>\n    #include<string>\n    #include<cstring>\n    #include<math.h>\n    #include<cmath>\n    #include<sstream>\n    #include<set>\n    #include<map>\n    #include<queue>\n    #include<cassert>\n    #include<cmath>\n    #include<cstdint>\nusing namespace std;\n\nbool seen[55][55];\nvector<string> s(55);\nint w, h;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nint res;\n\nvoid dfs(int y, int x){\n    seen[y][x] = true;\n\n    for(int i = 0; i < 4; i++){\n        \n            \n            int ny = y + dy[i], nx = x + dx[i];\n            \n            if(ny < 0 || ny >= h || nx < 0 || nx >= w)continue;\n            if(seen[ny][nx])continue;\n            if(s[ny][nx] == '#' || s[ny][nx] == '@')continue;\n            res++;\n            dfs(ny, nx);\n        \n    }\n}\n\nint main(){\n    while(cin >> w >> h){\n      if(w == 0 && h == 0)return 0;\n      res = 0;\n    int sy, sx;\n    for(int i = 0; i < h; i++)cin >> s[i];\n    for(int i = 0; i < h; i++)for(int j = 0; j < w; j++){\n        if(s[i][j] == '@')sy = i, sx = j;\n        seen[i][j] = false;\n    }\n    dfs(sy, sx);\n    cout << res + 1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define pb push_back\n#define debug(x) cout<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cout<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<i_i, int> p_i;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\n\nint main() {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (h == 0) { break; }\n    vvi tiles(h+2, vi(w+2, -1)); // -1 : red, 0 : black, 1 : reached\n    di current(2); // w(x), h(y)\n    for (int ih = 1; ih <= h; ++ih) {\n      for (int iw = 1; iw <= w; ++iw) {\n        char c_tmp;\n        cin >> c_tmp;\n        if (c_tmp != '#') {\n          tiles[ih][iw] = 0;\n        }\n        if (c_tmp == '@') {\n          current = {ih, iw};\n          tiles[ih][iw] = 1;\n        }\n      }\n    }\n\n    ddi s;\n    s.pb(current);\n    int reachable = 1;\n    while ( !s.empty() ) {\n      current = s.front();\n      vvi search = {{1,0},{0,1},{-1,0},{0,-1}};\n      for (auto v : search) {\n        int next_h = current[0] + v[0];\n        int next_w = current[1] + v[1];\n        if (tiles[next_h][next_w] == 0) {\n          tiles[next_h][next_w] = 1;\n          reachable += 1;\n          s.pb({next_h, next_w});\n        }\n      }\n      s.pop_front();\n    }\n    printf(\"%d\\n\", reachable);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid move(const vector<vector<char>> &board, vector<vector<bool>> &reached, int x, int y, int w, int h) {\n    if (x < 0 || w <= x || y < 0 || h <= y) {\n        return;\n    } else if (board[x][y] == '#') {\n        return;\n    } else if (reached[x][y]) {\n        return;\n    }\n    reached[x][y] = true;\n    int dxAry[] = {0, 1, 0, -1};\n    int dyAry[] = {-1, 0, 1, 0};\n    for (int i = 0; i < 4; ++i) {\n        move(board, reached, x + dxAry[i], y + dyAry[i], w, h);\n    }\n}\nint main(void){\n    int w, h;\n    while (cin >> w >> h && w && h) {\n        vector<vector<char>> board(w, vector<char>(h));\n        int sx, sy;\n        for (int i = 0; i < h; ++i) {\n            string row;\n            cin >> row;\n            for (int j = 0; j < row.length(); ++j) {\n                board[j][i] = row[j];\n                if (row[j] == '@') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        vector<vector<bool>> reached(w, vector<bool>(h, false));\n        move(board, reached, sx, sy, w, h);\n        int count = 0;\n        for (int y = 0; y < h; ++y)\n            for (int x = 0; x < w; ++x)\n                count += reached[x][y];\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define MAX 22\nusing namespace std;\nchar map[ MAX ][ MAX ];\nint n;\nvoid visit( int i, int j ){\n  if( map[ i ][ j ] == '#' ){ return; }\n  n++;\n  map[ i ][ j ] = '#';\n  visit( i - 1, j );\n  visit( i, j - 1 );\n  visit( i + 1, j );\n  visit( i, j + 1 );\n}\nint main(){\n  while( 1 ){\n    int w, h;\n    int pi, pj;\n    n = 0;\n    cin >> w >> h;\n    if( !w || !h ){ return 0; }\n    for( int i = 0; i <= h + 1; i++ ){\n      if( i == 0 || i == h + 1 ){\n        for( int j = 0; j <= w + 1; j++ ){\n          map[ i ][ j ] = '#';\n        }\n        continue;\n      }\n      string line;\n      cin >> line;\n      for( int j = 0; j <= w + 1; j++ ){\n        if( j == 0 || j == w + 1 ){\n          map[ i ][ j ] = '#';\n          continue;\n        }\n        map[ i ][ j ] = line[ j - 1 ];\n        if( map[ i ][ j ] == '@' ){\n          pi = i;\n          pj = j;\n        }\n      }\n    }\n    visit( pi, pj );\n    cout << n << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1000000007;\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint ans;\nchar c[40][40];\nint a,b;\n\n\nvoid bfs(int sx, int sy) {\n\tqueue<pair<int,int>> q;\n\tqueue<PII> qp;\n\tq.push(MP(sx,sy));\n\tc[sx][sy] = 'x';\n\tfor (int i = 1; i < 1000; i++) {\n\t\twhile (!q.empty()) {\n\t\t\tPII v = q.front(); //get value\n\t\t\tq.pop();\n\t\t\tint x = v.first, y = v.second;\n\t\t\tif (c[x+1][y] == '.'){ qp.push(MP(x+1,y)); c[x+1][y] = 'x'; ans++; }\n\t\t\tif (c[x-1][y] == '.'){ qp.push(MP(x-1,y)); c[x-1][y] = 'x'; ans++; }\n\t\t\tif (c[x][y+1] == '.'){ qp.push(MP(x,y+1)); c[x][y+1] = 'x'; ans++; }\n\t\t\tif (c[x][y-1] == '.'){ qp.push(MP(x,y-1)); c[x][y-1] = 'x'; ans++; }\n\n\t\t}\n\t\twhile (!qp.empty()) {\n\t\t\tq.push(qp.front());\n\t\t\tqp.pop();\n\t\t}\n//\t\tfor (int h = 0; h < b+2; h++) {\n//\t\t\tfor (int w = 0; w < a+2; w++) {\n//\t\t\t\tcout << c[w][h];\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n//\t\tcout << endl;\n\n\t}\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (true) {\n\t\tint sx,sy;\n\t\tcin >> a >> b;\n\t\tif (a == 0 && b == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int h = 0; h < b+2; h++) {\n\t\t\tfor (int w = 0; w < a+2; w++) {\n\t\t\t\tif (h == 0 || w == 0 || h == b+1 || w == a+1) {\n\t\t\t\t\tc[w][h] = '#';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> c[w][h];\n\t\t\t\t\tif (c[w][h] == '@') {\n\t\t\t\t\t\tsx = w;\n\t\t\t\t\t\tsy = h;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tbfs(sx,sy);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n\nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nbool check(int x, int y, int h, int w){\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\nint main(){\n\tint w, h;\n\twhile(cin>>w>>h && w > 0 && h > 0){\n\t\tvector<string> v(h);\n\t\trep(i, h) cin>>v[i];\n\t\tpii s;\n\t\trep(i, h) rep(j, w) if(v[i][j] == '@') s.fi = i, s.se = j;\n\t\tint ans = 0;\n\t\tset<pii> used;\n\t\tused.insert(s);\n\t\tans++;\n\t\tqueue<pii> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tpii p = q.front();\n\t\t\tq.pop();\n\n\t\t\tint x = p.se, y = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif(check(nx, ny, h, w) || used.count({ny, nx}) || v[ny][nx] == '#') continue;\n\t\t\t\tused.insert({ny, nx});\n\t\t\t\tq.push({ny, nx});\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nqueue<pair<int,int> > M;\nint W,H;\nint q[20+5][20+5] = {};\t\nchar p[20+5][20+5];\nint counter;\nint x,y;\n\nint main() {\n\twhile(cin >> W >> H && W != 0){\n\t\tcounter = 0;\n\t\tfor (int i = 1; i <= 22; i++){\n\t\t\tfor (int j = 1; j <= 22; j++){\n\t\t\t\t\tq[i][j] = 0;\n\t\t\t\t\tp[i][j] = ' ';\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@' ){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcounter = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tx = M.front().first;\n\t\t\ty = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t{\t\t\n\t\t\t\tif (p[x+dx[k]][y+dy[k]] == '.' && q[x+dx[k]][y+dy[k]] == 0)\n\t\t\t\t{\n\t\t\t\t\tM.push(make_pair(x+dx[k], y+dy[k]));\n\t\t\t\t\tq[x+dx[k]][y+dy[k]] = 1;\n\t\t\t\t\tcounter += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nint W,H;\nint q[22][22] = {};\nchar p[22][22];\n\nint main() {\n\tqueue<pair<int,int> > M;\n\twhile(cin >> W >> H){\n\t\tif (W == 0) return 0;\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@' ){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tW = M.front().first;\n\t\t\tH = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int i = 0; i <= 3; i++)\n\t\t\t{\t\t\n\t\t\t\tif (p[W+dx[i]][H+dy[i]] == '.' && q[W+dx[i]][H+dy[i]] == 0)\n\t\t\t\t{\n\t\t\t\t\tM.push(make_pair(W + dx[i], H + dy[i]));\n\t\t\t\t\tq[W + dx[i]][H + dy[i]] = 1;\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<array>\n#include<vector>\n\nusing namespace std;\n\nvector<vector<int>>tile(22, vector<int>(22));\n\narray<int, 4>mx = { -1,0,0,1 };\narray<int, 4>my = { 0,-1,1,0 };\n\nvoid walk(int x, int y) {\n\ttile[x][y] = 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (tile[x + mx[i]][y + my[i]] != 0)continue;\n\t\twalk(x + mx[i], y + my[i]);\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tint stx, sty;\n\t\tfor (auto &i : tile) {\n\t\t\tfor (auto &j : i) {\n\t\t\t\tj = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tchar ti;\n\t\t\t\tcin >> ti;\n\t\t\t\tif (ti == '.')tile[j][i] = 0;\n\t\t\t\telse if (ti == '#')tile[j][i] = -1;\n\t\t\t\telse {\n\t\t\t\t\ttile[j][i] = 1;\n\t\t\t\t\tstx = j; sty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalk(stx, sty);\n\t\tint ans = 0;\n\t\tfor (auto i : tile) {\n\t\t\tfor (auto j : i) {\n\t\t\t\tif (j == 1)ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 900\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; ++i){\n      cin >> line;\n      for(int j=0; j < width ; ++j){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 400; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; ++i){\n    for(int j=0; j < width ; ++j){\n      cout << setw(3)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >  width || y < 0 || y > height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h, m;\nstring s[20];\n\nvoid dfs(int i, int j) {\n\ts[i][j] = '#';\n\tm++;\n\n\tif (i > 0 && s[i - 1][j] == '.')\n\t\tdfs(i - 1, j);\n\tif (i < h - 1 && s[i + 1][j] == '.')\n\t\tdfs(i + 1, j);\n\n\tif (j > 0 && s[i][j - 1] == '.')\n\t\tdfs(i, j - 1);\n\n\tif (j < w - 1 && s[i][j + 1] == '.')\n\t\tdfs(i, j + 1);\n}\n\nint main()\n{\n\tcin >> w >> h;\n\n\twhile (w > 0 && h > 0) {\n\t\tm = 0;\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tcin >> s[i];\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t\tif (s[i][j] == '@')\n\t\t\t\t\tdfs(i, j);\n\n\t\tcout << m << endl;\n\t\tcin >> w >> h;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h;\nchar tail[21][21];\nint a[]={-1,0,1,0};\nint b[]={0,1,0,-1};\nint cnt=0;\nvoid func(int x,int y);\nmain(){\n  int sx,sy;\n  while(1){\n    cin>> w>> h;\n      if(w==0&&h==0) break;\n    cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>> tail[i][j];\n\tif(tail[i][j]=='@'){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    func(sx,sy);\n    cout<< cnt<< endl;\n  }\n}\n\nvoid func(int x,int y){\n  tail[y][x]='#';\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nx=x+a[i];\n    int ny=y+b[i];\n    if(nx>=0 && nx<w && ny>=0 && ny<h && tail[ny][nx]!='#'){\n      func(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> s;\nvector<vector<bool> > done;\nint w,h;\nint dy[] = {-1,1,0,0};\nint dx[] = {0,0,-1,1};\nint ans = 0;\n\nvoid dfs(int y, int x)\n{\n\t\tans++;\n        done[y][x] = true;\n        for(int i=0;i<4;i++)\n        {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if(0<=ny && ny<h && 0<=nx && nx<w && s[ny][nx]=='.' && !done[ny][nx])\n                {\n                        dfs(ny,nx);\n                }\n        }\n}\n \nsigned\nmain()\n{\n    while(cin >> w >> h and !(w==0 & h==0))\n    {\n            s = vector<string>(h);\n            done = vector<vector<bool> >(h,vector<bool>(w, false));\n\n\t\t\tint sy,sx;\n            for(int y=0;y<h;y++)\n\t\t\t{\n\t\t\t\t\tcin >> s[y];\n\t\t\t\t\tfor(int x=0;x<w;x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[y][x]=='@')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsy = y;\n\t\t\t\t\t\t\t\tsx = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n \t\t\tdfs(sy,sx);\n            cout << ans << endl;\n\t\t\tans = 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint check(int j){\n\tif (j==2 || j==4 ||j==3)\n\treturn j;\n\telse\n\treturn 3;\n}\nint main(){\n\tint board[22][22];\n\tint w,h;\n\tchar t;\n\twhile(1){\n\t\tcin >>w >>h;\n\t\tfor(int i=0;i<=21;i++){\n\t\t\tfor(int j = 0;j<=21;j++){\n\t\t\t\tboard[j][i]=4;\n\t\t\t}\n\t\t}//initialization\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> t ;\n\t\t\t\tif(t == '.')board[j][i] = 1;\n\t\t\t\telse if(t=='#')board[j][i]=2;\n\t\t\t\telse board[j][i] = 3;\n\t\t\t}\n\t\t}// input end\n\t\tint cmem = 2000;\n\t\tint c  = 0;\n\t\twhile(cmem-c !=0){\n\t\t\t\tcmem = c;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor (int j= 1;j<=w;j++){\n\t\t\t\t\tif(board[j][i] ==3){\n\t\t\t\t\tboard[j-1][i] =check(board[j-1][i]);\n\t\t\t\t\tboard[j+1][i] =check(board[j+1][i]);\n\t\t\t\t\tboard[j][i-1] =check(board[j][i-1]);\n\t\t\t\t\tboard[j][i+1] =check(board[j][i+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor (int j= 1;j<=w;j++){\n\t\t\t\t\tif (board[j][i] ==3) c+=1;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t}\t\n\t\n\t\tcout <<c << endl;\t\n\t}//while loop end\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 1000000007\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\ntypedef long long int ll;\n\n#define ARRAY_MAX 25\n\nint h,w;\nchar mp[ARRAY_MAX][ARRAY_MAX];\nint sx,sy;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\nint ans = 1;\n\nvoid dfs(int sy,int sx){\n\n    mp[sy][sx] = '$';//今いるところを塗りつぶす\n    \n    for(int i = 0;i < 4;i++){\n        int nx = sx + dx[i];\n        int ny = sy + dy[i];\n        if(nx >= 0 && nx < w && ny >= 0 && ny < h && mp[ny][nx] == '.'){\n            //mpの範囲内で.があれば調べる\n            ans++;\n            dfs(ny,nx);\n        }\n    }\n}\n\nint main(){\n\n    while(cin >> w >> h,w){\n\n        REP(i,h){\n            REP(j,w){\n                cin >> mp[i][j];\n                if(mp[i][j] == '@'){\n                    sy = i;\n                    sx = j;//スタート一を保存\n                }\n            }\n        }\n        dfs(sy,sx);\n        cout << ans << endl;\n        ans = 1;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ-1130-2\n//\n//  Created by Kenta Kodera on 2017/06/18.\n//  Copyright ?? 2017??´ Kenta Kodera. All rights reserved.\n//\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\n#include <ctype.h> // isdigit\n#include <cassert>\nusing namespace std;\n\nint W, H;\n\nint dfs(vector<string> &room, int h, int w){\n  \n  int dh[4] = {1, 0, -1, 0};\n  int dw[4] = {0, 1, 0, -1};\n  room[h][w] = '#';\n  \n  int ans = 1;\n  for(int i=0; i<4; i++){\n    int nh = h + dh[i];\n    int nw = w + dw[i];\n    if(0<=nh && nh<H && 0<=nw && nw<W && room[nh][nw] == '.'){\n      ans += dfs(room, nh, nw);\n    }\n  }\n  return ans;\n}\n\nint main(){\n  \n  while(cin >> W >> H, W|H){\n    \n    vector<string> room(H);\n    for(int i=0; i<H; i++){\n      cin >> room[i];\n    }\n    \n    for(int h=0; h<H; h++){\n      for(int w=0; w<W; w++){\n        if(room[h][w] == '@'){\n          cout << dfs(room, h, w) << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint n, m;\nchar map[20][20];\nint ans = 0;\n\nint dfs(int x, int y){\n\tif(0 <= x && x < m && 0 <= y && y < n){\n\t\tif(map[x][y] != '.') return 0;\n\t\tmap[x][y] = '@';\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i=0; i<20; i++){\n\t\t\tfor(int j=0; j<20; j++){\n\t\t\t\tmap[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", map[i]);\n\t\t}\n\t\tint x, y;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@') ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tans = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nint main(){\n  int w,h,count;\n  queue<int> que;\n  int xx[4]={1,0,-1,0};\n  int yy[4]={0,1,0,-1};\n  int pos;\n  string tt;\n  while(true){\n    cin >> w >> h;\n    if(!w&&!h)\n      break;\n    int mmap[w+2][h+2];\n    for(int x=0;x<w+2;x++){\n      mmap[x][0] = -1;\n      mmap[x][h+1] = -1;\n    }\n    for(int y=0;y<h+2;y++){\n      mmap[0][y] = -1;\n      mmap[w+1][y] = -1;\n    }\n        \n    for(int y=0;y<h;y++){\n      cin >> tt;\n      for(int x=0;x<w;x++){\n\tswitch(tt[x]){\n\tcase '.':\n\t  mmap[x+1][y+1] = 0;\n\t  break;\n\tcase '#':\n\t  mmap[x+1][y+1] = -1;\t  \n\t  break;\n\tcase '@':\n\t  mmap[x+1][y+1] = 1;\n\t  que.push(y*w+x);\n\t  break;\n\t}\n      }\n    }\n    count = 1;\n    while(!que.empty()){\n      pos = que.front();\n      for(int dir=0;dir<4;dir++){\n\tif (mmap[pos%w+xx[dir]+1][pos/w+yy[dir]+1]==0){\n\t  que.push(pos+yy[dir]*w+xx[dir]);\n\t  mmap[pos%w+xx[dir]+1][pos/w+yy[dir]+1] = 1;\n\t  count++;\n\t}\n      }\n      que.pop();\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= x*w*y*h;\n  return s;\n}\n\nint point_x(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint point_y(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  while(w!=0){\n    int a[21][21]={};\n    int sx,sy;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=point_x(cur,w);\n      y=point_y(cur,w);\n      if(x>=1){\n\tif(a[x-1][y]==1&&d[x-1][y]==-1){\n\t  d[x-1][y]=0;\n\t  q.push(point(x-1,y,w,h));\n\t}\n      }\n      if(x<=w-2){\n\tif(a[x+1][y]==1&&d[x+1][y]==-1){\n\t  d[x+1][y]=0;\n\t  q.push(point(x+1,y,w,h));\n\t}\n      }\n      if(y>=1){\n\tif(a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,y-w,w,h));\n\t}\n      }\n      if(y<=h-2){\n\tif(a[x][y+1]==1&&d[x][y+1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,y+w,w,h));\n\t}\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout << t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar c[21][21];\nint w, h;\nint sy, sx;\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[21][21];\nint ans = 0;\n\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nvoid dfs(int y, int x){\n    f[y][x] = true;\n    ans++;\n    for(int i = 0; i < 4; i++){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(contain(ny, nx) == true && f[ny][nx] == false && c[ny][nx] != '#'){\n            dfs(ny, nx);\n        }\n    }\n    return;\n}\n\nint main(){\n    while(cin >> w >> h, w, h){\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> c[i][j];\n                if(c[i][j] == '@'){\n                    sy = i;\n                    sx = j;\n                }\n                f[i][j] = false;\n            }\n        }\n        ans = 0;\n        dfs(sy, sx);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h,w,cnt;\nint color[21][21];\nchar m[21][21];\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nvoid dfs(int x,int y){\n    color[y][x] = 1;\n    for(int i=0; i<4; i++){\n        int vx = x+dx[i];\n        int vy = y+dy[i];\n        if(m[vy][vx] == '.' && color[vy][vx] == 0 && vx<w && vx >= 0 && vy<h && vy >=0){\n            dfs(vx,vy);\n        }\n    }\n}\n\nint main(){\n    while(1){    \n        cin>>w>>h;\n        cnt=0;\n        if(w==0 && h==0) break;\n        for(int i=0; i<21; i++){\n            for(int j=0; j<21; j++){\n                color[i][j]  =0;\n            }\n        }\n\n        int x,y;\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>>m[i][j];\n                if(m[i][j] == '@'){\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n\n        dfs(x,y);\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(color[i][j] != 0) cnt++;\n            }\n        }\n\n        cout<<cnt<<endl;\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main(void) {\n\tint W,H;\n\tcin >> W;\n\tcin >> H;\n\n\twhile (W!=0||H!=0) {\n\t\tint count = 0;\n\t\tchar c;\n\t\tstd::stack<int> st_x;\n\t\tstd::stack<int> st_y;\n\t\tint xn,yn;\n\t\tstd::vector< std::vector<bool> > tile(W+2, std::vector<bool>(H+2));\n\t\tfor (int i = 0; i < H+2; i++) {\n\t\t\tfor (int j = 0; j < W+2; j++) {\n\t\t\t\tif (i==0||i==H+1||j==0||j==W+1) {\n\t\t\t\t\ttile[j][i] = false;\n\t\t\t\t} else {\n\t\t\t\t\tcin >> c;\n\t\t\t\t\tif (c=='.') {\n\t\t\t\t\t\ttile[j][i] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='#') {\n\t\t\t\t\t\ttile[j][i] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='@') {\n\t\t\t\t\t\ttile[j][i] = false;\n\t\t\t\t\t\tst_x.push(j);\n\t\t\t\t\t\tst_y.push(i);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!st_x.empty()) {\n\t\t\txn = st_x.top();\n\t\t\tyn = st_y.top();\n\t\t\tst_x.pop();\n\t\t\tst_y.pop();\n\n\t\t\tif (tile[xn+1][yn]) {\n\t\t\t\tst_x.push(xn+1);\n\t\t\t\tst_y.push(yn);\n\t\t\t\ttile[xn+1][yn] = false;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (tile[xn-1][yn]) {\n\t\t\t\tst_x.push(xn-1);\n\t\t\t\tst_y.push(yn);\n\t\t\t\ttile[xn-1][yn] = false;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (tile[xn][yn+1]) {\n\t\t\t\tst_x.push(xn);\n\t\t\t\tst_y.push(yn+1);\n\t\t\t\ttile[xn][yn+1] = false;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (tile[xn][yn-1]) {\n\t\t\t\tst_x.push(xn);\n\t\t\t\tst_y.push(yn-1);\n\t\t\t\ttile[xn][yn-1] = false;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\n\t\tcin >> W;\n\t\tcin >> H;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint W, H, ans;\nchar maze[20][20];\n\nbool check(int x, int y){\n\treturn x >= 0 && x < W && y >= 0 && y < H && maze[y][x] != '#';\n}\n\nvoid dfs(int x, int y){\n\t\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(check(nx, ny)){\n\t\t\tmaze[ny][nx] = '#';\n\t\t\tans++;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> W >> H && (W || H)){\n\t\tfor(int i = 0; i < H; ++i)\n\t\t\tfor(int j = 0; j < W; ++j)\n\t\t\t\tcin >> maze[i][j];\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < H; ++i){\n\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\tif(maze[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<queue>\nusing namespace std;\nint W,H;\nchar c[101][101];\nbool visited [100][100];\n\nint dx[4]={1,0,-1,0};\nint dy [4]={0,1,0,-1} ;\n\nvoid compute(){\n  memset(visited,false,sizeof visited);\n\n\n  queue<int> que;\nint i,j;\n for(i=0;i<H;++i){\n   for(j=0;j<W;++j){\n     if(c[i][j]=='@'){\n       que.push(j+i*W);\n       visited[i][j]=true;\n       break;}\n       \n\t }\n\n\n   }\n int answer=1;\n \n while(!que.empty()){\n   int cur = que.front();\n   que.pop();\n   int x = cur % W,y=cur/W;\n\n   for(i=0;i<4;i++)\n     {int nx = x + dx[i],ny= y+dy[i];\n       if(!(0<=nx && nx< W && 0<=ny && ny < H))continue;\n       if(c[ny][nx]=='#'||visited[ny][nx])continue;\n       \n       que.push(nx+ny*W);\n       visited[ny][nx]=true;\n       ++answer;\n       \n     }\n }\n cout<<answer<<endl;\n \n}\n\n\n\n\n\nint main(){\n  while(cin>>W>>H,W|H) {\n    for(int i=0;i<H;++i) {\n      cin>>c[i];\t    \n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE + 1], queue<P> q, int W, int H) {\n  set<P> s;\n  while (q.size()) {\n    P p = q.front();\n    q.pop();\n    s.insert(p);\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        pair<set<P>::iterator, bool> r = s.insert(P(i, j));\n        if (r.second) q.push(*r.first);\n      }\n    }\n  }\n  return s.size();\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE + 1][MAX_SIZE + 1];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> f[i];\n      for (int j = 0; j < W; ++j) {\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H, W;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W || H) {\n      memset(visited, false, sizeof(visited));\n\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      visited[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n      cout << cnt << endl;\n\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint ch[23][23],cnt;\nvoid dfs(int,int);\nint main(){\n  int w,h,i,j,k,l;\n  string in[21];\n  while(1){\n    cnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> in[i];\n    }\n    for(i=0;i<h+2;i++){\n      for(j=0;j<w+2;j++){\n\tch[i][j]=1;\n      }\n    }\n    for(i=0,k=1;k<h+1;i++,k++){\n      for(j=0,l=1;l<w+1;l++,j++){\n\tif(in[i][j]=='.') ch[k][l]=0;\n\telse if(in[i][j]=='#') ch[k][l]=1;\n\telse ch[k][l]=2;\n      }\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(ch[i][j]==2) dfs(i,j);\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}\nvoid dfs(int i,int j){\n  if(ch[i][j]==1) return ;\n  ch[i][j]=1;\n  cnt++;\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j-1);\n  dfs(i,j+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 20\nint ans,baseX,baseY;\nint w,h;\nchar tile[MAX][MAX];\nvoid seek(int x,int y);\nusing namespace std;\nint main() {\n  while(1){\n    cin >> w;\n    cin >> h;\n    if(w==0&&h==0) return 0;\n    rep(i,h){\n      rep(j,w){\n        cin >> tile[i][j];\n        if(tile[i][j] == '@'){\n          baseX = i;\n          baseY = j;\n        }\n      }\n      tile[i][w] = '#';\n    }\n    rep(i,w) tile[h][i] = '#';\n    ans = 1;\n    seek(baseX,baseY);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nvoid seek(int x,int y){\n  if(tile[x+1][y] == '.'){\n    tile[x+1][y] = '#';\n    ans++;\n    seek(x+1,y);\n  }\n  if(tile[x][y+1] == '.'){\n    tile[x][y+1] = '#';\n    ans++;\n    seek(x,y+1);\n  }\n  if(tile[x-1][y] == '.'){\n    tile[x-1][y] = '#';\n    ans++;\n    seek(x-1,y);\n  }\n  if(tile[x][y-1] == '.'){\n    tile[x][y-1] = '#';\n    ans++;\n    seek(x,y-1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar tile[20][20];\nint canVisit[20][20];\n\nvoid bfs(int x, int y, int w, int h)\n{  \n  if (tile[y][x] == '#') return;\n  if (canVisit[y][x] == 1) return;\n  \n  if (canVisit[y][x] == 0) {\n    canVisit[y][x] = 1;\n  }\n  \n  int dx[] = { -1,  0,  0,  1 };\n  int dy[] = {  0,  1, -1,  0 };\n\n  for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 4; j++) {\n      if (x + dx[i] >= 0 && x + dx[i] < w\n          && y + dy[i] >= 0 && y + dy[i] < h) {\n        bfs(x + dx[i], y + dy[i], w, h);\n\n      }\n    }\n  }\n}\n\nint main()\n{\n  int w, h;\n  int init_x, init_y;\n  \n  while (1) {\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n\n    for (int i = 0; i < 20; i++) {\n      for (int j = 0; j < 20; j++) {\n        tile[i][j] = '#';\n        canVisit[i][j] = 0;\n      }\n    }\n    \n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> tile[i][j];\n        if (tile[i][j] == '@') {\n          init_x = j;\n          init_y = i;\n        }\n      }\n    }\n\n    bfs(init_x, init_y, w, h);\n    \n    int sum_of_tile = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        sum_of_tile += canVisit[i][j];\n      }\n    }\n    cout << sum_of_tile << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<string>\n#include<limits.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define nrep(i,a,b) for(int i=a;i<b;i++)\n#define mrep(i,a) for(int i=a;i<=0;i++)\n#define INF LLONG_MAX\nusing namespace std;\n\n// .:true #:false\nvector<pair<ll,ll> > idou(4);\nll w, h, ans;\n\nvoid dfs(vector<vector<bool> > &map,ll tate, ll yoko) {\n\tans++;\n\tmap[tate][yoko] = false;\n\tll t, y;\n\trep(i, 4) {\n\t\tt = tate+idou[i].first;\n\t\ty = yoko+idou[i].second;\n\t\tif (0 <= t && t < h && 0 <= y && y < w && map[t][y]) {\n\t\t\tdfs(map,t, y);\n\t\t}\n\t}\n}\n\nint main() {\n\n\t//???\n\tidou[0].first = -1;\n\tidou[0].second = 0;\n\t//???\n\tidou[1].first = 0;\n\tidou[1].second = 1;\n\t//???\n\tidou[2].first = 1;\n\tidou[2].second = 0;\n\t//???\n\tidou[3].first = 0;\n\tidou[3].second = -1;\n\n\twhile (1) {\n\t\tans = 0;\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\tvector<vector<bool> > map(h, vector<bool>(w));\n\t\tll s_t, s_y;\n\t\trep(i, h) {\n\t\t\tstring s; cin >> s;\n\t\t\trep(j, w) {\n\t\t\t\tif (s[j] == '@') {\n\t\t\t\t\ts_t = i;\n\t\t\t\t\ts_y = j;\n\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse map[i][j] = (s[j] == '.');\n\t\t\t}\n\t\t}dfs(map,s_t, s_y);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n// #include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint main()\n{\n  int N, M;\n  int sx, sy;\n  while (cin >> M >> N)\n  {\n    if (M == 0 && N == 0)\n      return 0;\n    int count = 0;\n    queue<P> que;\n    char d[21][21];\n    for (int i = 0; i < N; i++)\n    {\n      for (int j = 0; j < M; j++)\n      {\n        cin >> d[i][j];\n        if (d[i][j] == '@')\n        {\n          sx = j;\n          sy = i;\n          d[i][j] = '#';\n          count++;\n        }\n      }\n    }\n    que.push(P(sx, sy));\n\n    while (que.size())\n    {\n      P p = que.front();\n      que.pop();\n      for (int i = 0; i < 4; i++)\n      {\n        int nx = p.first + dx[i], ny = p.second + dy[i];\n        if (0 <= nx && nx < M && 0 <= ny && ny < N && d[ny][nx] != '#')\n        {\n          que.push(P(nx, ny));\n          d[ny][nx] = '#';\n          count++;\n        }\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  1130.cpp\n// Author: ymiyamoto\n//\n// Created on Sat Nov 11 02:36:17 2017\n//\n\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int32_t H, int32_t W, array<array<char, 20>, 20> &tiles, array<array<bool, 20>, 20> &visited, int32_t i, int32_t j, char index)\n{\n  visited[i][j] = true;\n  tiles[i][j] = index;\n\n  for (int32_t l = -1; l <= 1; l++) {\n    if (0 <= j + l && j + l < W) {\n      if (tiles[i][j + l] == '.') {\n        dfs(H, W, tiles, visited, i, j + l, index);\n      }\n    }\n  }\n\n  for (int32_t k = -1; k <= 1; k++) {\n    if (0 <= i + k && i + k < H) {\n      if (tiles[i + k][j] == '.') {\n        dfs(H, W, tiles, visited, i + k, j, index);\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    int32_t W, H;\n    cin >> W >> H;\n    if (W == 0) break;\n\n    array<array<char, 20>, 20> tiles;\n    array<array<bool, 20>, 20> visited;\n    uint32_t start_x = 0;\n    uint32_t start_y = 0;\n    for (int32_t i = 0; i < H; i++) {\n      for (int32_t j = 0; j < W; j++) {\n        cin >> tiles[i][j];\n        if (tiles[i][j] == '@') {\n          start_x = i;\n          start_y = j;\n          tiles[i][j] = '.';\n        }\n      }\n    }\n\n    char index = 0;\n    for (int32_t i = 0; i < H; i++) {\n      for (int32_t j = 0; j < W; j++) {\n        if (tiles[i][j] == '.') {\n          dfs(H, W, tiles, visited, i, j, index);\n          index++;\n        }\n      }\n    }\n\n    char start_index = tiles[start_x][start_y];\n    uint32_t count = 0;\n    for (int32_t i = 0; i < H; i++) {\n      for (int32_t j = 0; j < W; j++) {\n        if (tiles[i][j] == start_index) {\n          count++;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans=0,sx,sy;//finded\nstring m[20],t,s;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\nint ans = 0;\n\nvoid bfs(char **tile, int w, int h){\n  ans++;\n  tile[w][h] = '#';\n\n  if(tile[w][h-1] == '.')\n  bfs(tile, w, h-1);\n\n  if(tile[w][h+1] == '.')\n  bfs(tile, w, h+1);\n\n  if(tile[w-1][h] == '.')\n  bfs(tile, w-1, h);\n\n  if(tile[w+1][h] == '.')\n  bfs(tile, w+1, h);\n\n  return;\n}\n\n\nint main(){\n  int W,H,index_w,index_h;\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n\n    char **tile;\n    tile = new char* [H+2];\n    REP(i,H+2) tile[i] = new char[W+2];\n\n    REP(i,H+2){\n      REP(j,W+2){\n        if(i == 0 || i == H+1 || j == 0 || j == W+1) tile[i][j] = '#'; //sentry?\n        else scanf(\" %c\",&tile[i][j]);\n\n        if(tile[i][j] == '@') {\n          index_h = j;\n          index_w = i;\n        }\n\n      }\n    }\n    ans = 0;\n    bfs(tile,index_w,index_h);\n    \n    REP(i,H) delete[] tile[i];\n    delete[] tile;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar m[25][25];\nint cou;\n\nvoid dfs(int i,int j){\n  //printf(\"%d %d\\n\",i,j);///\n  m[i][j]='#';\n  if(m[i+1][j]=='.'){\n    cou++;    \n    dfs(i+1,j);\n  }\n  if(m[i][j+1]=='.'){\n    cou++;\n    dfs(i,j+1);  \n  }\n  if(m[i-1][j]=='.'){\n    cou++;\n    dfs(i-1,j);\n  }\n  if(m[i][j-1]=='.'){\n    cou++;\n    dfs(i,j-1);\n  }\n}\n\nint main(){\n  int a,b,i,j;\n  char o;\n  while(1){\n    cou=0;\n    scanf(\"%d %d%c\",&a,&b,&o);\n    if(a==0&&b==0)break;\n    for(i=1;i<b+1;i++){\n      for(j=1;j<=a+1;j++){\n\tscanf(\"%c\",&m[i][j]);\n      }\n    }\n    for(i=1;i<b+1;i++){\n      for(j=1;j<=a+1;j++){\n\tif(m[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",cou+1);\n    for(i=1;i<b+1;i++){\n      for(j=1;j<=a+1;j++){\n\tm[i][j]='0';\n      }\n    }\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\nint ans = 0;\n\nvoid bfs(char **tile, int w, int h){\n  ans++;\n  tile[w][h] = '#';\n\n  if(tile[w][h-1] == '.')\n  bfs(tile, w, h-1);\n\n  if(tile[w][h+1] == '.')\n  bfs(tile, w, h+1);\n\n  if(tile[w-1][h] == '.')\n  bfs(tile, w-1, h);\n\n  if(tile[w+1][h] == '.')\n  bfs(tile, w+1, h);\n\n  return;\n}\n\n\nint main(){\n  int W,H,index_w,index_h;\n\n  while(true){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n\n    char **tile;\n    tile = new char* [H+2];\n    REP(i,H+2) tile[i] = new char[W+2];\n\n    REP(i,H+2){\n      REP(j,W+2){\n        if(i == 0 || i == H+1 || j == 0 || j == W+1) tile[i][j] = '#'; //sentry?\n        else scanf(\" %c\",&tile[i][j]);\n\n        if(tile[i][j] == '@') {\n          index_h = j;\n          index_w = i;\n        }\n\n      }\n    }\n    count = 0;\n    bfs(tile,index_w,index_h);\n    \n    REP(i,H) delete[] tile[i];\n    delete[] tile;\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar rb[21][21];\nbool ch[21][21]={0};\nint x,y,h,w,ans;\nint d[4]={0,1,0,-1};\n\nvoid solve(int nx,int ny);\n\nint main(){\n  int i,j;\n  while(1){\n    cin >> w >> h;\n    if(w+h==0)break;\n    ans = 0;\n    for(i=0;i<h;i++)for(j=0;j<w;j++)ch[i][j]=0;\n    for(i=0;i<h;i++)for(j=0;j<w;j++){\n\tcin >> rb[i][j];\n\tif(rb[i][j]=='@'){\n\t  x=i;\n\t  y=j;\n\t  ch[i][j]=1;\n\t  rb[i][j]='#';\n\t}\n      }\n    solve(x,y);\n    cout << ans+1 << endl;\n  }\n  return 0;\n}\n\nvoid solve(int nx,int ny){\n  int nex,ney,i;\n  for(i=0;i<4;i++){\n    nex = nx+d[i];\n    ney = ny+d[i^1];\n    if(nex>=0&&nex<h&&ney>=0&&ney<w&&rb[nex][ney]=='.'&&ch[nex][ney]==0){\n      ans++;\n      ch[nex][ney]=1;\n      rb[nex][ney]='#';\n      solve(nex,ney);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,N,k) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pii pair<int,int>\n#define fi first\n#define se second\nint main(){\n\n\n    ifstream in(\"b_in.txt\");\n    cin.rdbuf(in.rdbuf());\n\n    int w,h;\n    while(cin >> w >> h,w){\n        int sx,sy;\n        string s[30];\n        rep(i,h) cin >> s[i];\n        rep(y,h)rep(x,w) if(s[y][x]=='@') s[y][x]='.',sx=x,sy=y;\n\n        queue<pii> que;\n        que.push(pii(sx,sy));\n        bool u[30][30] = {};\n        u[sy][sx] = true;\n        int cnt = 1;\n        while(!que.empty()){\n            int x,y;\n            tie(x,y) = que.front();\n            que.pop();\n            rep(i,4){\n                const int dx[] = {0,1,0,-1,0};\n                int nx = x + dx[i];\n                int ny = y + dx[i+1];\n                if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n                if(s[ny][nx] == '#') continue;\n                if(u[ny][nx]) continue;\n                u[ny][nx] = true;\n                cnt += 1;\n                que.push(pii(nx,ny));\n            }\n        }\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n\n#define EACH(i, c) \\\n  for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define SORT(c) sort((c).begin(), (c).end())\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\nconst double PI = acos(-1.0);\n#define CLR(a) memset((a), 0, sizeof(a))\n\nchar field[20][20];\n\nint p, q;\n\nvoid ta(int i, int j) {\n  if (i < 0 || j < 0 || i >= q || j >= p) return;\n  if (field[i][j] == '.' or field[i][j] == '@') {\n    field[i][j] = 'x';\n    ta(i + 1, j);\n    ta(i, j + 1);\n    ta(i - 1, j);\n    ta(i, j - 1);\n  }\n}\n\nvoid solve(int p, int q) {\n  REP(i, q) {  // i:y\n    REP(j, p) { cin >> field[i][j]; }\n  }\n  REP(i, q) {  // i:y\n    REP(j, p) {\n      if (field[i][j] == '@') ta(i, j);\n    }\n  }\n  int ans = 0;\n  REP(i, q) {  // i:y\n    REP(j, p) {\n      if (field[i][j] == 'x') ans++;\n    }\n  }\n  cout << ans << \"\\n\";\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // int p,q;\n  while (cin >> p >> q && p && q) {\n    solve(p, q);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define Cout(x) cout << (x) << endl\n#define Cout2(x, y) cout << (x) << \" \" << (y) << endl\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<string> VS;\ntypedef vector<bool> VB;\ntypedef vector<vector<int>> VVI;\ntypedef pair<int, int> PII;\nconst int inf = 1e9;\nconst double pi = acos(-1.0);\n\nint w, h;\nvector<VB> a(20, VB(20));\nvector<VB> v(20, VB(20));\nint dx[] = { 1,0,-1,0 }, dy[] = { 0,1,0,-1 };\n\nvoid Dfs(int x, int y) {\n\tif (x < 0 || y < 0 || x >= w || y >= h || !a[y][x] || v[y][x])return;\n\tv[y][x] = true;\n\trep(i, 4)Dfs(x + dx[i], y + dy[i]);\n}\n\nint main() {\n\twhile (cin >> w >> h && (w || h)) {\n\t\tVS s(h); rep(i, h)cin >> s[i];\n\t\tint sx, sy;\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == '.')a[i][j] = true;\n\t\t\t\tif (s[i][j] == '@') { a[i][j] = true; sx = j; sy = i; }\n\t\t\t\tif (s[i][j] == '#')a[i][j] = false;\n\t\t\t}\n\t\t}\n\t\trep(i, 20)rep(j, 20)v[i][j] = false;\n\n\t\tDfs(sx, sy);\n\n\t\tint ans = 0;\n\t\trep(i, h) {\n\t\t\trep(j, w)ans += v[i][j];\n\t\t}\n\t\tCout(ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define P pair<int, int>\n\nusing namespace std;\nchar field[20][20];\nint W, H,sx,sy,nx,ny;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nint cnt = 1;\n\n\nvoid bfs(){\n\tqueue<P> que;\n\tque.push(P(sx, sy));\n\n\twhile (1){\n\n\t\tif (que.empty()){\n\t\t\tbreak;\n\t\t}\n\t\tP p = que.front();\n\t\tque.pop();\n\t\t\n\t\trep(i, 4){\n\t\t\tnx = p.first + dx[i];\n\t\t\tny = p.second + dy[i];\n\t\t\tif (nx >= 0 && nx < W && 0 <= ny && ny < H && field[ny][nx] == '.'){\n\t\t\t\tfield[ny][nx] = '#';\n\t\t\t\tque.push(P(nx, ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\n\t\trep(i, H){\n\t\t\trep(j, W){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\t*/\n\t}\n\n\n\n}\n\n\n\n\n\nint main(){\n\twhile (1){\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i, H){\n\t\t\trep(j, W){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tcout << cnt << endl;\n\t\tcnt = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint w,h;\nint map[21][21];\n\nint count;\nint init_x,init_y;\n\nvoid dfs(int x,int y) {\n  \n  //cout << x << \" \" << y << endl;\n\n  if(x<0 || x>=w || y<0 || y>=h) return;\n\n  //if(map[x][y]==2) map[x][y]=0;\n\n  if(map[x][y]>0) return;\n\n  map[x][y]=3;\n\n  count++;\n\n  for(int i=0;i<4;i++) dfs(x+dx[i],y+dy[i]);\n\n}\n\nint main() {\n\n  string buf;\n\n  while(cin >> w >> h) {\n\n    if(w==0 && h==0) break;\n\n    getline(cin,buf);\n\n    for(int i=0;i<h;i++) {\n\n      getline(cin,buf);\n\n      for(int j=0;j<w;j++) {\n\n\tswitch(buf[j]) {\n\n\tcase '.':\n\t  map[j][i]=0;\n\t  break;\n\n\tcase '#':\n\t  map[j][i]=1;\n\t  break;\n\n\tcase '@':\n\t  map[j][i]=0;\n\t  init_x=j;\n\t  init_y=i;\n\t  break;\n\n\t}\n\n      }\n\n    }\n    /*\n    for(int i=0;i<h;i++) {\n\n      for(int j=0;j<w;j++) {\n\n\tcout << map[j][i];\n\n      }\n\n      cout << endl;\n\n    }\n    \n    cout << endl;\n\n    cout << map[5][7] << endl;\n    */\n    count=0;\n\n    dfs(init_x,init_y);\n    /*\n    cout << init_x << \" \" << init_y << endl;\n    \n    for(int i=0;i<h;i++) {\n\n      for(int j=0;j<w;j++) {\n\n\tcout << map[j][i];\n\n      }\n\n      cout << endl;\n\n    }\n    */\n    cout << count << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( 0 <= x && x < W && 0 <= y && y < H && room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '*';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\txy.pop();\n\t\t}\n\t\t/*for( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcout << room[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Tile {\n\tint row,\n\t\tcol;\n};\n\nint main()\n{\n\tint x, y, row, col, c;\n\tvector<string> v(20);\n\tqueue<Tile> t;\n\n\twhile (cin >> x >> y, x != 0 && y != 0) {\n\t\tc = 1;\n\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tcin >> v.at(i);\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (v.at(i).at(j) == '@') {\n\t\t\t\t\tt.push({ i,j });\n\t\t\t\t\tv.at(i).at(j) = '#';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!t.empty()) {\n\t\t\trow = t.front().row;\n\t\t\tcol = t.front().col;\n\t\t\tt.pop();\n\n\t\t\tif (row - 1 >= 0 && v.at(row-1).at(col) == '.') {\n\t\t\t\tv.at(row-1).at(col) = '#';\n\t\t\t\tt.push({row-1,col});\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tif (row + 1 < y && v.at(row+1).at(col) == '.') {\n\t\t\t\tv.at(row+1).at(col) = '#';\n\t\t\t\tt.push({ row+1,col });\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tif (col - 1 >= 0 && v.at(row).at(col-1) == '.') {\n\t\t\t\tv.at(row).at(col-1) = '#';\n\t\t\t\tt.push({ row,col-1 });\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tif (col + 1 < x && v.at(row).at(col+1) == '.') {\n\t\t\t\tv.at(row).at(col+1) = '#';\n\t\t\t\tt.push({ row,col+1 });\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\n\t\tcout << c << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nusing P = pair<ll, ll>;\n\nint dx[4] = {0, 1, 0, -1},\n    dy[4] = {1, 0, -1, 0};\n\nint dfs(vector<string> const& v, vector<vector<bool>>& visited, int y, int x) {\n    visited[y][x] = true;\n    int res = 1;\n    for(int i=0; i<4; ++i) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny < 0 || v.size() <= ny || nx < 0 || v[0].size() <= nx || v[ny][nx] == '#' || visited[ny][nx]) {\n            continue;\n        }\n        res += dfs(v, visited, ny, nx);\n    }\n    return res;\n}\n\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<string> v(h);\n        for(int i=0; i<h; ++i) {\n            cin >> v[i];\n        }\n        int sy, sx;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                if(v[i][j] == '@') {\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n        vector<vector<bool>> visited(h, vector<bool>(w));\n        cout << dfs(v, visited, sy, sx) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid calcCanReach( char c[20][20], int x, int y, int a, int b )\n{\n    c[b][a] = '@';\n    if( b - 1 >= 0 && c[b-1][a] == '.' )\n        calcCanReach( c, x, y, a, b - 1 );\n    if( b + 1 < y && c[b+1][a] == '.' )\n        calcCanReach( c, x, y, a, b + 1 );\n    if( a - 1 >= 0 && c[b][a-1] == '.' )\n        calcCanReach( c, x, y, a - 1, b );\n    if( a + 1 < x && c[b][a+1] == '.' )\n        calcCanReach( c, x, y, a + 1, b );\n}\n\nint main()\n{\n    char c[20][20];\n    int x, y, a, b;\n\n    while( cin >> x >> y )\n    {\n        if( x == 0 && y == 0 )\n            break;\n\n        for( int i = 0; i < y; i++ )\n            for( int j = 0; j < x; j++ )\n            {\n                cin >> c[i][j];\n                if( c[i][j] == '@' )\n                {\n                    a = j;\n                    b = i;\n                }\n            }\n        \n        calcCanReach( c, x, y, a, b );\n\n        int cnt = 0;\n        for( int i = 0; i < y; i++ )\n            for( int j = 0; j < x; j++ )\n                if( c[i][j] == '@' )\n                    cnt++;\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nchar field[20][20];\nbool flag[20][20];\nint W, H, ans;\n\nvoid dfs(int x, int y) {\n  //field[x][y] = '.';\n  //cout << x << ' ' << y << endl;\n  //cout << flag[x][y] << endl;\n  //cout << ans << endl;\n  for(int i = 0 ; i < 4 ; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < H && 0 <= ny && ny < W && field[nx][ny] == '.' &&\n       flag[nx][ny] == false) {\n      ans++; flag[nx][ny] = true; dfs(nx, ny);\n      //cout << \"OK\" << endl;\n    }\n    //else dfs(nx, ny);\n  }\n}\n\nint main(void) {\n  int x, y;\n  int res;\n  \n  while(cin >> W >> H, W != 0 && H != 0) {\n    memset(flag, false, sizeof(flag));\n    ans = 1;\n    for(int i = 0 ; i < H ; i++) {\n      for(int j = 0 ; j < W ; j++) {\n\tcin >> field[i][j];\n\tif(field[i][j] == '@') x = i, y = j;\n      }\n    }\n    /*for(int i = 0 ; i < H ; i++) {\n      for(int j = 0 ; j < W ; j++) {\n\tcout << field[i][j];\n      }\n      cout << endl;\n      }*/\n    //printf(\"@x = %d, @y = %d\\n\", x, y);\n    dfs(x, y);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return x < h && y < w;\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\tmoved = 0;\n\tint initX, initY;\n\t\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i; initY = j;\n\t\t}\n\t    }\n\t}\n\t\n\tmove(initX, initY);\n\t\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar maze[21][21];\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {1, -1, 0, 0};\nint ans = 0;\nint h, w;\n\nvoid dfs(int y, int x){\n\tans += 1;\n\tmaze[y][x] = '#';\n\tfor(int i=0; i<4; i++){\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif(0 <= nx and nx < w and 0 <= ny and ny < h and maze[ny][nx] == '.'){\n\t\t\t\tdfs(ny, nx);\n\t\t\t\t//ans += 1;\n\t\t\t}\n\t\t}\n\treturn;\n}\n\nint main(){\nwhile(1){\t\n\tans = 0;\n\tint sx, sy;\n\tcin >> w >> h;\n\tif(w == 0 and h == 0) break;\n\tfor(int i=0; i < h; i++){\n\t\tfor(int j=0; j < w; j++){\n\t\t\tcin >> maze[i][j];\n\t\t\tif(maze[i][j] == '@'){\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(sy, sx);\n\tcout << ans << endl;\n\t/*\n\tfor(int i=0; i < h; i++){\n\t\tfor(int j=0; j < w; j++){\n\t\t\tcout << maze[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}//end\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint calc(std::vector<std::vector<char> >&v, int sx, int sy){\n\n\tv[sx][sy] = '#';\n\n\tint res = 1;\n\tif (sx - 1 >= 0 && v[sx - 1][sy] == '.')res += calc(v, sx - 1, sy);\n\tif (sx + 1 < v.size() && v[sx + 1][sy] == '.')res += calc(v, sx + 1, sy);\n\tif (sy - 1 >= 0 && v[sx][sy - 1] == '.')res += calc(v, sx, sy - 1);\n\tif (sy + 1 < v[sx].size() && v[sx][sy + 1] == '.')res += calc(v, sx, sy + 1);\n\n\treturn res;\n\n}\n\nint main(){\n\n\tint w, h;\n\twhile (std::cin >> w >> h){\n\t\tif (w == 0 && h == 0)break;\n\n\t\tstd::vector<std::vector<char> >v(h, std::vector<char>(w));\n\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tstd::cin >> v[i][j];\n\t\t\t\tif (v[i][j] == '@')sx = i, sy = j;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << calc(v, sx, sy) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a=0;\nvoid kazoeruyo(int p,int P,int box[20][20]){\n  a++;\n  if(box[p][P+1]==1) {\n    box[p][P+1]=0;\n    P=P+1;\n    kazoeruyo(p,P,box);\n  }\n  if(box[p+1][P]==1){\n    box[p+1][P]=0;\n    p=p+1;\n    kazoeruyo(p,P,box);\n  }\n  if(box[p][P-1]==1){\n    box[p][P-1]=0;\n    P=P-1;\n    kazoeruyo(p,P,box);\n  }\n  if(box[p-1][P]==1){\n    box[p-1][P]=0;\n    p=p-1;\n    kazoeruyo(p,P,box);\n  }\n}\nint main(){\n  int i,I,H,W,p,P;\n  int  box[20][20];\n  char v;\n  while(1){\n  cin>>W>>H;\n  if(W==0&&H==0) break;\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cin>>v;\n      if(v=='.') box[i][I]=1;\n      if(v=='#') box[i][I]=2;\n      if(v=='@') {\n\tbox[i][I]=0;\n\tp=i;\n\tP=I;\n      }\n    }\n  }\n  kazoeruyo(p,P,box);\n  for(i=0;i<H;i++){\n    for(I=0;I<W;I++){\n      cout<<box[i][I];\n    }\n    cout<<endl;\n  }\n\n  cout<<a<<endl;\n \n  a=0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,x,y,i,j,k,masu[22][22],checked[22][22],*g,cont;\nvoid check(int xx,int yy){\ncont++;\nchecked[xx][yy]=1;\nint m,n;m=1;n=0;\nif(checked[xx+m][yy+n]==0 && \nmasu[xx+m][yy+n]==0)\ncheck(xx+m,yy+n);\nm=0;n=1;\nif(checked[xx+m][yy+n]==0 && \nmasu[xx+m][yy+n]==0)\ncheck(xx+m,yy+n);\nm=-1;n=0;\nif(checked[xx+m][yy+n]==0 && \nmasu[xx+m][yy+n]==0)\ncheck(xx+m,yy+n);\nm=0;n=-1;\nif(checked[xx+m][yy+n]==0 && \nmasu[xx+m][yy+n]==0)\ncheck(xx+m,yy+n);\n}\nint main(void){\nchar a[22];\nwhile(1){\nscanf(\"%d%d\",&w,&h);\nif(w==0 && h==0)\nbreak;\ncont=0;\nfor(j=0;j<22;j++)\nfor(i=0;i<22;i++){\nmasu[i][j]=1;\nchecked[i][j]=0;\n}\nfor(j=1;j<=h;j++){\nscanf(\"%s\",a);\nfor(i=1;i<=w;i++)\nswitch(a[i-1]){\ncase '@':x=i;y=j;\ncase '.':masu[i][j]=0;break;\n}\n}\ncheck(x,y);\nprintf(\"%d\\n\",cont);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\nint xd[]={1,0,0,-1};\nint yd[]={0,1,-1,0};\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H,W!=0){\n\t\tvector<string> board(H);\n\t\tqueue<pair<int,int> > q;\n\t\tfor(int i=0;i<H;i++)\n\t\t\tcin>>board[i];\n\t\tfor(int i=0;i<H;i++){\n\t\t\tstring::iterator\n\t\t\tp=find(board[i].begin(),board[i].end(),'@');\n\t\t\tif(p!=board[i].end()){\n\t\t\t\tq.push(pair<int,int>(i,p-board[i].begin()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint count=0;\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> v=q.front();\n\t\t\tq.pop();\n\t\t\tif(board[v.first][v.second]=='#')continue;\n\t\t\tboard[v.first][v.second]='#';\n\t\t\tcount++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint newx=xd[i]+v.first;\n\t\t\t\tint newy=yd[i]+v.second;\n\t\t\t\tif(0<=newx&&newx<H&&0<=newy&&newy<W\n\t\t\t\t\t\t&&board[newx][newy]=='.')\n\t\t\t\t\tq.push(pair<int,int>(newx,newy));\n\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nchar field[21][21];\nint direction_x[] = {1, -1, 0, 0};\nint direction_y[] = {0, 0, 1, -1};\nint w, h;\nint lx = 0, ly = 0;\nint cnt = 0;\n\nvoid set_data(int w, int h){\n    for(int i=0; i < h; i++){\n        for(int j=0; j < w; j++){\n            cin >> field[i][j];\n            if(field[i][j] == '@'){\n                ly = i;\n                lx = j;\n            }\n        }\n    }\n}\n\nvoid count(int x, int y){\n    field[y][x] ='#';\n    cnt++;\n    int nx = 0, ny = 0;\n\n    for(int i=0; i<4; i++){\n        nx = x + direction_x[i];\n        ny = y + direction_y[i];\n\n        if(nx < 0 || nx >= w){\n            continue;\n        }\n        if(ny < 0 || ny >= h){\n            continue;\n        }\n        if(field[ny][nx] != '.'){\n            continue;\n        }\n        count(nx,ny);\n    }\n\n}\n\nint main(void){\n\n    while(1){\n        cnt = 0;\n        cin >> w >> h;\n        if(w==0 || h==0){\n            break;\n        }\n\n        set_data(w,h);\n        count(lx,ly);\n\n        cout << cnt << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint n,m;\nvector<string> area;\nbool ok(int x,int y,int nx,int ny){\n  bool res = 0<=nx&&nx<n&&0<=ny&&ny<m;\n  if(res){\n    res = (area[y][x]=='.'||area[y][x]=='@')&&(area[ny][nx]=='.'||area[ny][nx]=='@');\n  }\n  return res;\n}\nstruct union_find{//rank,経路圧縮で高速化\n  vector<long long> data;//そのノードがrootであれば-（集合のサイズ）を表し、そうでなければ親ノードidを示す。\n  union_find(long long size):data(size,-1){}//コンストラクタ,size個のノードを作成し、-1で初期化\n  inline long long root(long long a){//根を探す,経路圧縮\n    return data[a] < 0 ? a : data[a]=root(data[a]);\n  }\n  inline bool find(long long a,long long b){//a,bが同じ集合に属するか調べる\n    return root(a) == root(b);\n  }\n  inline bool unite(long long a,long long b){//小さい方の木の根に大きい方の根を上書きする\n    a = root(a),b = root(b);\n    if(a==b) return false;//根が同じなら終了,uniteが失敗したことを出力\n    if(data[a]<data[b]) swap(a,b); //集合サイズの大きい方の根に低い方の根をつける\n    data[b] += data[a];//集合サイズを統合\n    data[a] = b;//yの親にxをつける\n    return true;//unite成功を出力\n  }\n  inline long long size(long long a){//aが属する集合のサイズを出力\n    return -data[root(a)];\n  }\n};\nint main(){\n  while(cin>>n>>m,n){\n    union_find uf(n*m);\n    area.resize(m);\n    REP(i,m) cin >> area[i];\n    int person = -1;\n    REP(i,m)REP(j,n){\n      if(area[i][j]=='@') person = i*n+j;\n      REP(k,4){\n        if(ok(j,i,j+dx[k],i+dy[k])){\n          uf.unite(i*n+j,(i+dy[k])*n+j+dx[k]);\n        }\n      }\n    }\n    cout << uf.size(person) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#define rp(i,a,b) for(int (i)=(int)(a);i<(int)(b);++i)\n\ntypedef long long ll;\n\nint mx[]={-1,1,0,0};\nint my[]={0,0,-1,1};\nusing namespace std;\nint n=0;\nvoid dfs(int startx,int starty,vector<vector<bool> > &map){\n    for(int i=0;i<4;i++){\n        int x=startx+mx[i],y=starty+my[i];\n        if(x>=0 and y>=0 and y<map.size() and x<map[0].size() and map[y][x]==true){\n        map[y][x]=false;\n        n++;\n        dfs(x,y,map);}\n        \n    }\n    \n}\n\nint main(){\n    while(1){\n        int x,y,startx,starty;\n        vector<vector<bool> > map;\n        cin>>x>>y;\n\n        if(x==0 and y==0) return 0;\n        for(int i=0;i<y;i++){\n            vector<bool> tmp;\n            string s;\n            cin>>s;\n            for(int j=0;j<x;j++){\n\n                if(s[j]=='@') {startx=j;starty=i;tmp.push_back(true);}\n                else if(s[j]=='.') tmp.push_back(true);\n                else tmp.push_back(false);    \n            }\n            map.push_back((tmp));\n        }\n        n=0;\n        dfs(startx,starty,map);\n        cout<<n<<endl;\n        \n    }\n\n    return 0;\n};"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint vis[25][25];\n\nvoid dfs(int i,int j){\n  if(vis[i][j]==0 || vis[i][j]==2)return;\n  vis[i][j]=0;\n\n    dfs(i-1,j);\n    dfs(i,j-1);\n    dfs(i,j+1);\n    dfs(i+1,j);\n}\n\nint main(){\n  int w,h;\n  int i,j;\n  char ch;\n  int cnt;\n\n  while(1){\n    cnt=0;\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tcin >> ch;\n\tif(ch=='.'){\n\t  vis[i][j]=1;\n\t}else if(ch=='#'){\n\t  vis[i][j]=2;\n\t}else{\n\t  vis[i][j]=5;\n\t}\n      }\n    }\n     for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(vis[i][j]==5)dfs(i,j);\n      }\n     }\n      for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(vis[i][j]==0)cnt++;\n      }\n     }\n      cout << cnt << endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint dfs(int x,int y);\nint w,h;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint sum=1;\nchar maps[21][21];\n\nint main(){\n  int sx,sy;\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> maps[i][j];\n\tif(maps[i][j]=='@'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    \n    dfs(sx,sy);\n    cout << sum << endl;\n    sum=1;\n  }\n  return(0);\n}\n\nint dfs(int x,int y){\n  int nx,ny;\n  for(int i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    maps[y][x]='#';\n    if(0<=nx && nx<w && 0<=ny && ny<h && maps[ny][nx]!='#'){\n      dfs(nx,ny);\n      sum++;\n    } \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint ans;\nbool dfs(int y,int x,vector<vector<bool> >& canGo){\ncanGo[x][y]=false;\nans+=1;\nif(canGo[y+1][x])dfs(y+1,x,canGo);\nif(canGo[y-1][x])dfs(y-1,x,canGo);\nif(canGo[y][x+1])dfs(y,x+1,canGo);\nif(canGo[y][x-1])dfs(y,x-1,canGo);\nreturn false;\n}\n\nint main(void){\nint h,w;\nint i,j,k;\nint x,y;\nstring s;\nvector<vector<bool> >canGo;\n\nwhile(true){\ncin>>h>>w;\nif(h==0)return 0;\ncanGo=vector<vector<bool> >(h+2,vector<bool>(w+2,false));\nans=0;\nfor(i=0;i<h;i++){\n\tcin>>s;\n\tfor(j=0;j<w;j++){\n\t\tif(s[j]=='.')canGo[i+1][j+1]=true;\n\t\telse if(s[j]=='@'){y=i+1;x=j+1;canGo[i+1][j+1]=true;}\n\t}\n}\ndfs(y,x,canGo);\ncout<<ans<<endl;\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint W, H;\nchar map[25][25];\nint sx, sy;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nint dfs(int x, int y)\n{\n  int ret = 1;\n  map[x][y] = '#';\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n    if(map[nx][ny] == '#') continue;\n    ret += dfs(nx, ny);\n  }\n  return ret;\n}\n\nint main(void)\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        cin >> map[x][y];\n        if(map[x][y] == '@'){\n          sx = x, sy = y;\n          map[x][y] = '.';\n        }\n      }\n    }\n    cout << dfs(sx, sy) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\nbool B[25][25]; int N, M;\nvoid dfs(int ty, int tx, vs S)\n{\n\tfor (int r = 0; r < 4; r++)\n\t{\n\t\tint y = ty + dd[r];\n\t\tint x = tx + dd[r + 1];\n\t\tif (y < 0 || y >= N || x < 0 || x >= M)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (S[y][x] == '.' && B[y][x] == false)\n\t\t{\n\t\t\tB[y][x] = true;\n\t\t\tdfs(y, x, S);\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tcin >> M >> N;\n\t\tif (N == 0 && M == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tvs S(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> S[i];\n\t\t}\n\t\tint sy = -1, sx = -1;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (S[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tB[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tdfs(sy, sx, S);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (B[i][j])\n\t\t\t\t{\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans+1) << endl;\n\t}\n\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint W, H, x, y;\nstring f[20];\nchar v[20][20];\n\nint ofs[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\n\nint bfs() {\n\tint n = 0;\n\tmemset(&v[0][0], 0, sizeof(char) * 20 * 20);\n\n\tqueue<pii> que;\n\tque.push(pii(x, y));\n\twhile(!que.empty()) {\n\t\tpii p = que.front();\n\t\tque.pop();\n\t\tif(v[p.second][p.first] == 0) {\n\t\t\tv[p.second][p.first] = 1;\n\t\t\tn++;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,4) {\n\t\t\tint nx = p.first + ofs[i][0];\n\t\t\tint ny = p.second + ofs[i][1];\n\t\t\tif(nx >= 0 && ny >= 0 && nx < W && ny < H && v[ny][nx] == 0 && f[ny][nx] == '.') {\n\t\t\t\tque.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn n;\n}\n\nint main() {\n\twhile(cin>>W>>H, W|H) {\n\t\trep(i,H) {\n\t\t\tcin >> f[i];\n\t\t\tint j = f[i].find_first_of('@');\n\t\t\tif(j != string::npos) {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t\tcout << bfs() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint table[22][22],count;\n\n\nvoid DFS(int,int);\n\nint main(){\n  int W,H,firstW,firstH;\n  char a;\n\n\n  while(cin >> W && cin >> H && W && H){\n      count = 0;\n  for(int i= 0;i < H+2;i++){\n    for(int j = 0;j < W+2;j++){\n      if(i == 0 || i == H+1)table[j][i] = 0;\n      else table[0][i] = table[W+1][i] = 0;\n    }\n  }\n\n  \n    for(int i=1;i<H+1;i++){\n      for(int j=1;j<W+1;j++){\n          cin >> a;\n          if(a == '.') table[j][i] = 1;\n          if(a == '#') table[j][i] = 0;\n          if(a == '@') table[j][i] = 1,firstW = j,firstH = i;\n        }\n      \n    }\n\n\n    DFS(firstW,firstH);\n    cout << count << endl;\n  }\n  return 0;\n}\n\nvoid DFS(int W,int H) {\n  count++;\n  table[W][H] = 0;\n  if(table[W-1][H] == 1) DFS(W-1,H);\n  if(table[W][H-1] == 1) DFS(W,H-1);\n  if(table[W+1][H] == 1) DFS(W+1,H);\n  if(table[W][H+1] == 1) DFS(W,H+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint x[21][21],ans=0,w,h;\nstring d[21];\nvoid f(int i,int j){\n\tans++;\n\tx[i][j]=1;\n\tif(i+1<h){\n\t\tif(x[i+1][j]==0 && d[i+1][j]=='.')\n\t\tf(i+1,j);\n\t}\n\tif(i-1>=0){\n\t\tif(x[i-1][j]==0 && d[i-1][j]=='.')\n\t\tf(i-1,j);\n\t}\n\tif(j+1<w){\n\t\tif(x[i][j+1]==0 && d[i][j+1]=='.')\n\t\tf(i,j+1);\n\t}\n\tif(j-1>=0){\n\t\tif(x[i][j-1]==0 && d[i][j-1]=='.')\n\t\tf(i,j-1);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint a,b;\n\t\tans=0;\n\t\tfor(int i=0;i<21;i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tx[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>d[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d[i][j]=='@'){\n\t\t\t\t\ta=j;\n\t\t\t\t\tb=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf(b,a);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n\ntypedef pair<int, int>P;\n\n\nint w, h;\nint cnt;\nchar f[21][21];\nint dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };\n\nvoid rec(int x, int y) {\n  f[y][x] = '#';\n  cnt++;\n\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\n\tif (nx <= 0 || w < nx || ny <= 0 || h < ny||f[y][x]!=',')continue;\n\n\trec(nx, ny);\n  }\n}\n\nint main(){\n  while (cin >> w >> h,(w || h)) {\n\tint sx, sy;\n\tcnt = 0;\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tcin >> f[y][x];\n\t\tif (f[y][x] == '@') {\n\t\t  sx = x;\n\t\t  sy = y;\n\t\t}\n\t  }\n\t}\n\trec(sx, sy);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define yesno(flg) if(flg){cout<<\"YES\"<<endl;}else{cout<<\"NO\"<<endl;}\n#define MAX_N 1002\n#define i197 1000000007\n#define Vi vector<int>\n#define Vl vector<long long>\n#define pb(a) push_back(a)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P1;\ntypedef pair<int,int> Pi;\ntypedef pair<double,Pi> Pdi;\ntypedef pair<ll,int>Pli;\ntypedef pair<P1,ll> P2;\nconst ll INF=10000000000000000001;\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nstruct Road{double cost;int a,b;};\nstruct edge{int to,cost;};\nstruct pos{\n\tint x,y;\n};\n\nint main() {\n\n\twhile(1){\n\t\tint h,w;\n\t\tchar c[21][21]={};\n\t\tint dp[21][21]={},ans=0;\n\t\tcin>>h>>w;\n\t\tif(h==0&&w==0)return 0;\n\t\tqueue<pos> que;\n\t\tint si=0,sj=0;\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\tcin>>c[j][i];\n\t\t\t\tif(c[j][i]=='@'){\n\t\t\t\t\tdp[j][i]=1;\n\t\t\t\t\tsj=j;\n\t\t\t\t\tsi=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpos pos1={sj,si};\n\t\tque.push(pos1);\n\t\twhile(!que.empty()){\n\t\t\tpos pos2=que.front();que.pop();\n\t\t\tans++;\n\t\t\tif(c[pos2.x+1][pos2.y]=='.'&&dp[pos2.x+1][pos2.y]==0){\n\t\t\t\tpos pos3={pos2.x+1,pos2.y};\n\t\t\t\tque.push(pos3);\n\t\t\t\tdp[pos2.x+1][pos2.y]=1;\n\t\t\t}\n\t\t\tif(c[pos2.x-1][pos2.y]=='.'&&dp[pos2.x-1][pos2.y]==0){\n\t\t\t\tpos pos4={pos2.x-1,pos2.y};\n\t\t\t\tque.push(pos4);\n\t\t\t\tdp[pos2.x-1][pos2.y]=1;\n\t\t\t}\n\t\t\tif(c[pos2.x][pos2.y+1]=='.'&&dp[pos2.x][pos2.y+1]==0){\n\t\t\t\tpos pos5={pos2.x,pos2.y+1};\n\t\t\t\tque.push(pos5);\n\t\t\t\tdp[pos2.x][pos2.y+1]=1;\n\t\t\t}\n\t\t\tif(c[pos2.x][pos2.y-1]=='.'&&dp[pos2.x][pos2.y-1]==0){\n\t\t\t\tpos pos6={pos2.x,pos2.y-1};\n\t\t\t\tque.push(pos6);\n\t\t\t\tdp[pos2.x][pos2.y-1]=1;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nint cnt, w, h;\nchar m[100][100];\n\nvoid dfs(pii);\n\nint main(void){\n    while(cin >> w >> h, w){\n        MEMSET(m, '#');\n\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n\n        dfs(p);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if((p.X < 0 || w <= p.X) ||\n       (p.Y < 0 || h <= p.Y)) return;\n\n    if(m[p.Y][p.X] == '.') cnt ++;\n    else return;\n    m[p.Y][p.X] = '#';\n\n    rep(i, 4){\n        pii next = mp(p.X + dx[i], p.Y + dy[i]);\n        dfs(next);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\nusing namespace std;\ntypedef pair<int, int> P;\nint w, h;\nstring f[20];\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\nbool isin(int x, int y) { return x>=0&&x<h&&y>=0&&y<w; }\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        int sx=-1,sy=-1;\n        for (int i=0; i<h; i++) {\n            cin>>f[i];\n            for (int j=0; j<w; j++) if (f[i][j]=='@') {\n                sx=i; sy=j;\n                f[i][j]='#';\n            }\n        }\n        queue<P> que;\n        que.push(P(sx,sy));\n        int res=1;\n        while (!que.empty()) {\n            int x=que.front().first, y=que.front().second;\n            que.pop();\n            for (int i=0; i<4; i++) {\n                int nx=x+dx[i], ny=y+dy[i];\n                if (isin(nx,ny)&&f[nx][ny]=='.') {\n                    que.push(P(nx,ny));\n                    f[nx][ny]='#';\n                    res++;\n                }\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint tile[22][22] = {};\nint w, h;\nint cnt;\n\nvoid fill(int x, int y) {\n\ttile[x][y] = 0;\n\tcnt++;\n\tif (tile[x - 1][y] == 1) fill(x - 1, y);\n\tif (tile[x][y - 1] == 1) fill(x, y - 1);\n\tif (tile[x][y + 1] == 1) fill(x, y + 1);\n\tif (tile[x + 1][y] == 1) fill(x + 1, y);\n}\n\nint main() {\n\tint x = 0, y = 0;\n\twhile (cin >> w >> h && (w || h)) {\n\t\tcnt = 0;\n\t\tfor (int i = 1; i <= h; ++i){\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tchar tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tif (tmp == '.') tile[i][j] = 1;\n\t\t\t\telse if (tmp == '#') tile[i][j] = 0;\n\t\t\t\telse x = i, y = j, tile[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfill(x, y);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w, h;\nchar tile[20][20];\nint cnt = 0;\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nvoid f(int x, int y){\n\ttile[x][y] = '#';\n\tcnt++;\n\tint X = 0;\n\tint Y = 0;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (tile[x + dx[i]][y + dy[i]] == '.' && 0 <= x && x < w && 0 <= y && y < h){\n\t\t\tX = x + dx[i];\n\t\t\tY = y + dy[i];\n\t\t\tf(X, Y);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile (cin >> w >> h, w + h != 0){\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tcin >> tile[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; y++){\n\t\t\tfor (int x = 0; x < w; x++){\n\t\t\t\tif (tile[x][y] == '@') f(x, y);\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define uniq(x) (x).erase(unique(all(x)),(x).end())\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef std::priority_queue<int> IntPrioQueue; //Z->A\ntypedef std::priority_queue<int, std::vector<int>, std::greater<int> > IntReversePrioQueue; //A->Z\n\nconst int MAX = 32;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst int MOD = 1000000007;\n\nint w, h, sx, sy, cnt;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint maze[MAX][MAX];\n\nbool range(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nvoid dfs(int x, int y){\n    maze[y][x] = 0;\n    cnt++;\n    rep(4, d) {\n        if (range(x+dx[d], y+dy[d]) && maze[y+dy[d]][x+dx[d]]) {\n            dfs(x+dx[d], y+dy[d]);\n        }\n    }\n    return;\n}\n\nvoid solve(void){\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        cnt = 0;\n        rep(h, y) rep(w, x) {\n            char c; cin >> c;\n            if (c == '#') maze[y][x] = 0;\n            else maze[y][x] = 1;\n            if (c == '@') {\n                sx = x; sy = y;\n            }\n        }\n        dfs(sx, sy);\n        printf(\"%d\\n\", cnt);\n    }\n}\n\nint main(void){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint h, w;\nint sy, sx;\nchar field[22][22];\n\nint main(){\n \n  while(cin >> w >> h && (h || w)){\n    fill(&field[0][0], &field[21][21] + 1, '#');\n    for(int i = 1; i <= h; i++){\n      for(int j = 1 ; j <= w; j++){\n\tcin >> field[i][j];\n\tif(field[i][j] == '@'){\n\t  sy = i;\n\t  sx = j;\n\t  field[i][j] = '#';\n\t}\n      }\n    }\n    queue<P> que;\n    que.push(P(sy, sx));\n    int res = 1;\n    while(!que.empty()){\n      P p = que.front();\n      que.pop();\n      int y = p.first;\n      int x = p.second;\n      for(int i = 0; i < 4; i++){\n\tint y2 = y + dy[i];\n\tint x2 = x + dx[i];\n\tif(field[y2][x2] == '.'){\n\t  res++;\n\t  field[y2][x2] = '#';\n\t  que.push(P(y2, x2));\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint field[52][52];\n\nvoid DFS(int x, int y){\n    if(field[x][y]==1/*||field[x][y]==-1*/){\n        field[x][y]=-1;\n        DFS(x,y-1);\n        DFS(x-1,y);\n        DFS(x+1,y);\n        DFS(x,y+1);\n    }\n}\n\n\nint main(){\n    int w,h;\n    while(cin>>w>>h){\n        if(w==0&&h==0)break;\n        for(int i=0; i<50; i++){\n            for(int j=0; j<50; j++){\n                field[i][j]=0;\n            }\n        }\n        \n        int start_x;\n        int start_y;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                char temp;\n                cin>>temp;\n                if(temp=='#')field[i][j]=0;\n                else field[i][j]=1;\n                \n                if(temp=='@'){\n                    start_x=i;\n                    start_y=j;\n                }\n            }\n        }\n        \n        DFS(start_x,start_y);\n        \n        int sum=0;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                if(field[i][j]==-1){\n                    sum++;\n                }\n            }\n        }\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define pb emplace_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \")\n{ if (!v.size()) puts(\"\"); rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nstruct UnionFind {\n\tvector<int> p, r;\n\n\tUnionFind() {}\n\tUnionFind(int size) { init(size); }\n\n\tvoid init(int size) {\n\t\tp.resize(size);\n\t\tr.resize(size);\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tp[i] = i; r[i] = 1;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = root(p[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\n\t\tif (x == y) return;\n\n\t\tif (r[x] > r[y]) swap(x, y);\n\t\tr[x] += r[y];\n\t\tp[y] = x;\n\t}\n\n\tbool is_root(int x) {\n\t\treturn root(x) == x;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint element_count(int x) {\n\t\tx = root(x);\n\t\treturn r[x];\n\t}\n};\n\nsigned main() {\n  int h, w;\n  while (cin >> w >> h, w) {\n    char c[30][30];\n    rep(i, 30) rep(j, 30) c[i][j] = '#';\n\n    for (int i = 1; i <= h; ++i) {\n      for (int j = 1; j <= w; ++j) {\n        cin >> c[i][j];\n      }\n    }\n\n    UnionFind uf(h * w + 200);\n\n    int s = -1;\n\n    for (int i = 1; i <= h; ++i) {\n      for (int j = 1; j <= w; ++j) {\n        if (c[i][j] == '#') continue;\n        if (c[i][j] == '@') {\n          s = i * w + j;\n        }\n\n        int v = i * w + j;\n\n        rep(k, 4) {\n          int y = i + dy[k];\n          int x = j + dx[k];\n          if (c[y][x] == '#') continue;\n\n          int u = y * w + x;\n\n          uf.unite(u, v);\n        }\n      }\n    }\n\n    cout << uf.element_count(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst ll MOD=1000000007;\nconst ll INF=1000000000LL;\nconst int MAX=100001;\nconst double EPS=1e-10;\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nint w,h;\nchar c[21][21];\nbool visited[21][21];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool field(int x,int y){\n    if(x>=0&&y>=0&&x<w&&y<h&&(!visited[y][x])&&(c[y][x]=='.')){\n        return true;\n    }\n    return false;\n}\nvoid dfs(int x,int y){\n    visited[y][x]=true;\n    for(int i=0;i<4;i++){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(field(nx,ny)){\n            dfs(nx,ny);\n        }\n    }\n    return;\n}\nint main(){\n    while(cin>>w>>h,w+h){\n        int sx,sy;\n        for(int i=0;i<h;i++){\n            cin>>c[i];\n            for(int j=0;j<w;j++){\n                if(c[i][j]=='@'){\n                    sx=j;\n                    sy=i;\n                }\n            }\n        }\n        int ans=0;\n        dfs(sx,sy);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(visited[i][j]){\n                    ans++;\n                    visited[i][j]=false;\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\nvoid RB(int x,int y){\n    int W,H;\n    long count = 0;\n    char area[22][22]={};\n    char temp;\n    using P = pair <int,int>;\n    queue <P> que;\n    const int direction[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; \n\n    W = x;\n    H = y;\n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n            cin >> temp;\n            switch (temp){\n                case '.':\n                    area[i][j] = 1;\n                    break;\n                case '#':\n                    break;\n                case '@':\n                    area[i][j] = 0;\n                    que.push(P(i,j));\n                    break;\n            }\n        }\n    }\n\n    while(!que.empty()){\n        P temppair = que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int tempx = temppair.first + direction[i][0];\n            int tempy = temppair.second + direction[i][1];\n            if(area[tempx][tempy]==1){\n                que.push(P(tempx,tempy));\n                area[tempx][tempy] = 0;\n            }\n        }\n        count++;\n    }\n\n    cout << count << endl;\n\n}\n\nint main(){\n    int x,y;\n    while(1){\n        cin >> x >> y;\n        if(x == 0 && y == 0) break;\n        RB(x,y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <time.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <bitset>\nusing namespace std;\n#define FOR(I,F,N) for(int I = F; I < (int)(N); I++)\n#define rep(i, n) FOR(i, 0, n)\n#define FIN(V) cout<<V<<endl\n#define pb push_back\n#define INF (1 << 28)\n\ntemplate<typename T>\nvoid remove(vector<T>& vector, unsigned int index){\nvector.erase(vector.begin() + index);\n}\n\ntypedef pair<int, int> P;\ntypedef long long ll;\ntypedef priority_queue<int> pq;\nint StrToInt(string);\nstring IntToStr(int);\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nint w, h;\nint state[21][21];\nbool memo[21][21] = {0};\nint ans;\nvoid dfs(int x, int y){\n\tif(!memo[x][y]){\n\t\tmemo[x][y] = true;\n\t\tans++;\n\t}else return;\n\tint res = 0;\n\trep(k,4){\n\t\tint nx = x + dx[k];\n\t\tint ny = y + dy[k];\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)continue;\n\t\tif(state[nx][ny])continue;\n\t\tdfs(nx, ny);\n\t}\n}\nint main(void){\n\twhile(cin >> w >> h, w|h){\n\t\tans = 0;\n\t\tfill_n(*memo, 21*21, false);\n\t\tint sx, sy;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tstate[j][i] = 2;\n\t\t\t\t}else if(c == '.'){\n\t\t\t\t\tstate[j][i] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tstate[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx, sy);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n\n\nint StrToInt(string s){\n\tstringstream ss;\n\tss << s;\n\tint val;\n\tss >> val;\n\treturn val;\n}\nstring IntToStr(int i){\n\tstringstream ss;\n\tss << i;\n\treturn ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst int INF = 99999999;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint H, W;\nvector<string> s;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nint bfs(int sx, int sy) {\n    queue<P> que;\n    que.push(P(sx, sy));\n    vector<vector<int>> d(H, vector<int>(W, INF));\n    d[sx][sy] = 0;\n    int ans = 0;\n\n    while (!que.empty()) {\n        P p = que.front(); que.pop();\n        ans++;\n\n        rep(k, 4) {\n            int nx = p.first + dx[k], ny = p.second + dy[k];\n\n            if (inside(nx, ny) && s[nx][ny] != '#' && d[nx][ny] == INF) {\n                que.push(P(nx, ny));\n                d[nx][ny] = d[p.first][p.second] + 1;\n            }\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> W >> H, W) {\n        s.clear();\n        s.resize(H);\n        int sx, sy;\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (s[i][j] == '@') {\n                    sx = i, sy = j;\n                }\n            }\n        }\n        cout << bfs(sx, sy) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nint h,w;\nstring g[25];\n\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\n\nint dfs(int x, int y){\n  g[y][x]='#';\n  int ans=0;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i],ny=y+dy[i];\n    if(0<=nx && nx<w && 0<=ny && ny < h && g[ny][nx]!='#'){\n      ans+=dfs(nx,ny);\n    }\n  }\n  return ans+1;\n}\n\nint main(void){\n\n  while(cin >> w >> h, h|w){\n    for(int i=0;i<h;i++)cin >> g[i];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(g[i][j]=='@')cout << dfs(j,i) << endl;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint paint(vector<string> &field, int x, int y) {\n    int cnt = 0;\n\n    for(int i = 0; i < 4; ++i) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(xx < 0 || field[0].size() <= xx || yy < 0 || field.size() <= yy) continue;\n\n        if(field[yy][xx] == '.') {\n            field[yy][xx] = '#';\n            cnt += paint(field, xx, yy)+1;\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while(true) {\n        int W, H;\n        cin >> W >> H;\n\n        if(!W && !H) break;\n\n        int sx, sy;\n        vector<string> field(H);\n        for(int i = 0; i < H; ++i) {\n            cin >> field[i];\n            for(int x = 0; x < W; ++x) {\n                if(field[i][x] == '@') {\n                    sx = x;\n                    sy = i;\n                }\n            }\n        }\n\n        cout << paint(field, sx, sy)+1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\nint mapToNum(char c)\n{\n\tswitch (c) {\n\tcase '#':\n\t\t\treturn -1;\n\tcase '.':\n\t\t\treturn 0;\n\tcase '@':\n\t\t\treturn 1;\n\tdefault:\n\t\t\treturn -2;\n\t}\n}\n\nint main()\n{\n\twhile (1) {\n\t\tint w, h;\n\t\t\n\t\tcin >> w >> h;\n\t\t\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tstack< pair<int, int> > stk;\n\t\tvector< vector<int> > tiles(h + 2, vector<int>(w + 2));\n\t\tchar c;\n\t\t\n\t\tfor (int i = 0; i < w + 2; ++i) tiles.at(0).at(i) = tiles.at(h + 1).at(i) = -1;\n\t\t\n\t\tfor (int i = 1; i < h + 1; ++i) {\n\t\t\ttiles.at(i).at(0) = tiles.at(i).at(w + 1) = -1;\n\t\t\tfor (int j = 1; j < w + 1; ++j) {\n\t\t\t\tcin >> c;\n\t\t\t\ttiles.at(i).at(j) = mapToNum(c);\n\t\t\t\tif (c == '@') stk.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint num = 0;\n\t\t\n\t\twhile (!stk.empty()) {\n\t\t\tpair<int, int> p = stk.top();\n\t\t\tstk.pop();\n\t\t\tint x = 1, y = 0, t;\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tif (tiles.at(p.first + x).at(p.second + y) != -1) {\n\t\t\t\t\ttiles.at(p.first + x).at(p.second + y) = -1;\n\t\t\t\t\tstk.push(make_pair(p.first + x, p.second + y));\n\t\t\t\t\t++num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tt = -y;\n\t\t\t\ty = x;\n\t\t\t\tx = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << num << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint map[20][20];\n\n\nint solve(int x,int y){\n\tint count = 0;\n\tif(map[y][x] == 0){\n\t\tcount++;\n\t\tmap[y][x] = 1;\n\t\tif(x-1 >= 0){\n\t\t\tcount += solve(x-1,y);\n\t\t}\n\t\tif(y-1 >= 0){\n\t\t\tcount += solve(x,y-1);\n\t\t}\n\t\tif(20 > x+1){\n\t\t\tcount += solve(x+1,y);\n\t\t}\n\t\tif(20 > y+1){\n\t\t\tcount += solve(x,y+1);\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tint w,h;\n\tint startX,startY;\n\n\twhile(true){\n\t\tcin >> w >> h;\n\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<20;j++){\n\t\t\t\tmap[i][j] = 1;\n\t\t\t}\n\t\t}\n\n\t\tchar c;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '.':\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\tstartX = j;\n\t\t\t\t\tstartY = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(startX,startY) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint data[22][22];\nint vis[22][22];\nint cnt = 0;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nvoid dfs(int x, int y){\n  vis[x][y] = 1;\n  cnt++;\n  for(int i = 0; i < 4; i++){\n    if(data[x + dx[i]][y + dy[i]] == 1 && vis[x + dx[i]][y + dy[i]] == 0){\n      dfs(x + dx[i], y + dy[i]);\n    }\n  }\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h && w + h){\n    cnt = 0;\n    for(int i = 0; i < 22; i++){\n      for(int k = 0; k < 22; k++){\n\tdata[i][k] = vis[i][k] = 0;\n      }\n    }\n    pair<int,int> start;\n    for(int i = 0; i < h; i++){\n      string s;\n      cin >> s;\n      for(int k = 0; k < w; k++){\n\tif(s[k] == '.')\n\t  data[i + 1][k + 1] = 1;\n\telse if(s[k] == '@')\n\t  start.first = i + 1,start.second = k + 1;\n      }\n    }\n    dfs(start.first, start.second);\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1E9\n#define EPS 1E-9\n#define MOD (ll)(1E9+7)\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n\n\nint main() {\n\tint w, h;\n\tint dx[4] = { -1,0,1,0 };\n\tint dy[4] = { 0,-1,0,1 };\n\tchar input;\n\twhile (1) {\n\t\tpair<int, int> start;\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\t\tvector<vector<int>> field(h + 2, vector<int>(w + 2, 1));\n\t\tfor (int i = 1; i < h + 1; i++) {\n\t\t\tfor (int j = 1; j < w + 1; j++) {\n\t\t\t\tcin >> input;\n\t\t\t\tif (input == '.') {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse if (input == '@') {\n\t\t\t\t\tstart.first = i;\n\t\t\t\t\tstart.second = j;\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i, h + 2) {\n\t\t\trep(j, w + 2) {\n\t\t\t\tcout << field[i][j] << \" \" ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t\tqueue<pair<int, int>> que;\n\t\tint ans = 0;\n\t\tque.emplace(start.first, start.second);\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> now = que.front();\n\t\t\tque.pop();\n\t\t\tif (field[now.first][now.second] == 1) continue;\n\t\t\tans++;\n\t\t\tfield[now.first][now.second] = 1;\n\t\t\trep(k, 4) {\n\t\t\t\t//cout << now.first + dy[k] << \" \" << now.second + dx[k] << endl;\n\t\t\t\t//cout << field[now.first + dy[k]][now.second + dx[k]] << endl;\n\t\t\t\t\n\t\t\t\tif (field[now.first + dy[k]][now.second + dx[k]] == 0) {\n\t\t\t\t\tque.emplace(now.first + dy[k], now.second + dx[k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;               // 行番号\n  int col;               // 列番号\n};\n\n// プロトタイプ宣言\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col] != '*' && M[nc.row][nc.col] != '#' && M[nc.row][nc.col] != '@')\n\t{\n\t  S.push(nc);\n\t  M[nc.row][nc.col] = '*';\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid search(int a, int b);\n\nchar wh[22][22];\nbool judge[22][22];\n\nint ans = 0;\n\nint main(void){\n\nwhile(1) {\n\tint x;\n\tint y;\n\tcin >> x >> y;\n\tif(x == 0 && y == 0) return 0;\n\n\tint i;\n\tint j;\n\n\t// 初期化\n\tfor(i = 0; i < 22; i++){\n\t\tfor(j = 0; j < 22; j++){\n\t\t\twh[j][i] = '#';\n\t\t\tjudge[j][i] = false;\n\t\t}\n\t}\n\n// 入力\n\tint xs, ys;\n\tfor(i = 1; i < y+1; i++){\n\t\tfor(j = 1; j < x+1; j++){\n\t\t\tcin >> wh[j][i];\n\t\t\tif(wh[j][i] == '@') {\n\t\t\t\txs = j;\n\t\t\t \tys = i;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// for(i = 0; i < 22; i++){\n\t// \tfor(j = 0; j < 22; j++){\n\t// \t\tprintf(\"%c\",wh[j][i]);\n\t// \t}\n\t// \tprintf(\"\\n\");\n\t// }\n\n\tsearch(xs, ys);\n\n\tcout << ans << endl;\n\tans = 0;\n}\n\n\treturn 0;\n}\n\nvoid search(int a,int b) {\n\tif(wh[a][b] == '#' || judge[a][b] == true) return;\n\n\tans++;\n\tjudge[a][b] = true;\n\t// 左\n\tsearch(a-1,b);\n\t// 右\n\tsearch(a+1,b);\n\t// 上\n\tsearch(a,b+1);\n\t// 下\n\tsearch(a,b-1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w,h;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvector<string> m;\nint ans = 0;\n\nvoid dfs(int x, int y){\n  m[y][x] = '#';\n  ans++;\n  for(int i=0; i<4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= w || nx < 0 || ny >= h || ny < 0) continue;\n    if(m[ny][nx] == '.'){\n      dfs(nx,ny);\n    }\n  }\n}\n\n\nint main(){\n\n  while(1){\n    cin >> w >> h;\n    if(!w and !h) break;\n    m.clear();\n    \n    for(int i=0; i<h; i++){\n      string s; cin >> s;\n      m.push_back(s);\n    }\n\n    int sx,sy;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(m[i][j] == '@'){\n\t  sx = j;\n\t  sy = i;\n\t}\n      }\n    }\n    ans =0;\n    dfs(sx,sy);\n    cout << ans <<  endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dfs(int x,int y,int f[32][32]) {\n\tint n = 1;\n\tf[x][y] = 0;\n\tif (f[x + 1][y] == 1)\n\t\tn += dfs(x + 1, y, f);\n\tif (f[x - 1][y] == 1)\n\t\tn += dfs(x - 1, y, f);\n\tif (f[x][y + 1] == 1)\n\t\tn += dfs(x, y + 1, f);\n\tif (f[x][y - 1] == 1)\n\t\tn += dfs(x, y - 1, f);\n\treturn n;\n}\n\n\nint main()\n{\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0)break;\n\t\tint floor[32][32] = {};\n\t\tint startX = 0;\n\t\tint startY = 0;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '.' || c == '@') {\n\t\t\t\t\tfloor[i][j] = 1;\n\t\t\t\t\tif (c == '@') {\n\t\t\t\t\t\tstartX = i;\n\t\t\t\t\t\tstartY = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c == '#')floor[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint cnt = dfs(startX, startY, floor);\n\t\tcout << cnt << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= x*w*y*h;\n  return s;\n}\n\nint pointx(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint pointy(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  w = 1;\n  h = 1;\n  cin>>w>>h;\n  while(w!=0){\n    int a[w][h];\n    int sx,sy;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=pointx(cur,w);\n      y=pointy(cur,w);\n      if(x>=1&&a[x-1][y]==1&&d[x-1][y]==-1){\n\td[x-1][y]=0;\n\tq.push(point(cur-1,y,w,h));\n      }\n      if(x<=w-2&&a[x+1][y]==1&&d[x+1][y]==-1){\n\td[x+1][y]=0;\n\tq.push(point(cur+1,y,w,h));\n      }\n      if(y>=1&&a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,cur-w,w,h));\n      }\n      if(y<=h-2&&a[x][y+1]==1&&d[x][y+1]==-1){\n\td[x][y-1]=0;\n\tq.push(point(x,cur+w,w,h));\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout << t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h && w != 0) {\n    vector<string> grid(h);\n    P start;\n    for (int i = 0; i < h; i++) {\n      cin >> grid[i];\n      for (int j = 0; j < w; j++) {\n        if (grid[i][j] == '@') {\n          start = make_pair(i, j);\n          grid[i][j] = '#';\n        }\n      }\n    }\n\n    queue<P> q;\n    q.push(start);\n    int ans = 0;\n    while (!q.empty()) {\n      const P p = q.front();\n      q.pop();\n\n      ans++;\n      for (int d = 0; d < 4; d++) {\n        static const int dir_h[] = {-1, 1, 0, 0};\n        static const int dir_w[] = {0, 0, -1, 1};\n        const int next_h = p.first+dir_h[d];\n        const int next_w = p.second+dir_w[d];\n        if (next_h >= 0 && next_h < h && next_w >= 0 && next_w < w\n            && grid[next_h][next_w] == '.') {\n          q.push(make_pair(next_h, next_w));\n          grid[next_h][next_w] = '#';\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint H, W;\nint map[20][20];\nint c;\nusing namespace std;\n\nvoid printArray();\nvoid check(int, int);\n\nint main() {\n  while (true) {\n    cin  >> W >> H;\n    if ((W | H) == 0) {\n      break;\n    }\n    int sy, sx;\n    for (int i = 0; i < H; i++) {\n      string line;\n      cin >> line;\n      for (int j = 0; j < W; j++) {\n        if (line[j] == '@') {\n          sy = i;\n          sx = j;\n          map[i][j] = 0;\n        } else if (line[j] == '.') {\n          map[i][j] = 0;\n        } else if (line[j] == '#') {\n          map[i][j] = 1;\n        }\n      }\n    }\n    // printArray();\n    c = 0;\n    check(sy, sx);\n    // printArray();\n    cout << c << endl;\n  }\n  return 0;\n}\n\nvoid check(int y, int x) {\n  if (y < 0 || x < 0 || y >= H || x >= W || map[y][x] == 1) {\n    return;\n  }\n  map[y][x] = 1;\n  c++;\n  check(y + 1, x);\n  check(y - 1, x);\n  check(y, x + 1);\n  check(y, x - 1);\n}\n\nvoid printArray() {\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cout << map[i][j];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\nchar room[21][21];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> p;\n\n\nint main(){\n\tint x,y;\n\tqueue<p> que;\n\tint w,h;\n\tcin>>w>>h;\n\t\n\tfor(int a=0;a<h;a++){\n\t\tfor(int b=0;b<w;b++){\n\t\t\tcin>>room[a][b];\n\t\t\tif(room[a][b]=='@'){\n\t\t\t\tx=b,y=a;\n\t\t\t\tque.push(p(b,a));\n\t\t\t\troom[a][b]='#';\n\t\t\t}\n\t\t}\n\t}\n\tif(room[20]==\"00\")return 0;\n\tint cnt=1;\n\tint nx,ny;\n\twhile(que.size()){\n\t\tp ap=que.front();\n\t\tque.pop();\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tnx=ap.first+dx[i];\n\t\t\tny=ap.second+dy[i];\n\t\t\tif(0<=nx&&nx<=w&&0<=ny&&ny<=h&&room[ny][nx]!='#'){\n\t\t\t\troom[ny][nx]='#';\n\t\t\t\tque.push(p(nx,ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nstruct grid{\n\tint x,y;\n};\nint main(){\n\twhile(true){\n\t\tint w,h;\tcin>>w>>h;\n\t\tif(w==0)\treturn 0;\n\t\tvector<string> s(h);\n\t\tfor(int i=0;i<h;i++)\tcin>>s[i];\n\t\tqueue<grid> q;\n\t\tbool visited[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tvisited[i][j]=false;\n\t\t\t\tif(s[i][j]=='@'){\n\t\t\t\t\tvisited[i][j]=true;\n\t\t\t\t\tq.push((grid){j,i});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tgrid c=q.front();\tq.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=c.y+dy[i],nx=c.x+dx[i];\n\t\t\t\tif(ny<0||h<=ny)\tcontinue;\n\t\t\t\tif(nx<0||w<=nx)\tcontinue;\n\t\t\t\tif(s[ny][nx]=='#')\tcontinue;\n\t\t\t\tif(!visited[ny][nx]){\n\t\t\t\t\tvisited[ny][nx]=true;\n\t\t\t\t\tq.push((grid){nx,ny});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(visited[i][j])\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint count_black (vector<vector<bool>> &is_black, int i, int j, int rows, int columns)\n{\n\tif (i < 0 || rows <= i || j < 0 || columns <= j)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tif (is_black[i][j])\n\t{\n\t\tis_black[i][j] = false;\n\t\tint sum = 1;\n\t\tsum += count_black(is_black, i-1, j, rows, columns);\n\t\tsum += count_black(is_black, i+1, j, rows, columns);\n\t\tsum += count_black(is_black, i, j-1, rows, columns);\n\t\tsum += count_black(is_black, i, j+1, rows, columns);\n\t\treturn sum;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\nint main ()\n{\n\twhile (true)\n\t{\n\t\tint rows, columns;\n\t\tcin >> columns >> rows;\n\n\t\tif (0 == rows && 0 == columns) break;\n\n\t\tvector<vector<bool>> is_black(rows);\n\t\tint start_i = 0, start_j = 0;\n\t\tfor (int i=0; i<rows; ++i)\n\t\t{\n\t\t\tis_black[i].resize(columns, false);\n\t\t\tfor (int j=0; j<columns; ++j)\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\n\t\t\t\tif ('.' == c)\n\t\t\t\t{\n\t\t\t\t\tis_black[i][j] = true;\n\t\t\t\t}\n\t\t\t\telse if ('@' == c)\n\t\t\t\t{\n\t\t\t\t\tis_black[i][j] = true;\n\t\t\t\t\tstart_i = i;\n\t\t\t\t\tstart_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count_black(is_black, start_i, start_j, rows, columns) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\nchar room[100][100];\nbool fin[100][100];\n\nint dfs(int i,int j){\n    int sum = 1;\n\n    fin[i][j] = false;\n\n    for(int k = 0;k < 4;k++){\n        int ii = i + dy[k];int jj = j + dx[k];\n        if(fin[ii][jj] && room[ii][jj] == '.')\n            sum += dfs(ii,jj);\n    }\n    return sum;\n}\n\nint main(){\n    int w,h;\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n\n        if(w == 0 && h == 0)\n            break;\n\n        for(int i = 0;i < h;i++)\n            scanf(\"%s\",&room[i][0]);\n\n        for(int i = 0;i < h;i++)\n            for(int j = 0;j < w;j++)\n                fin[i][j] = true;\n\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                if(room[i][j] == '@')\n                    printf(\"%d\\n\",dfs(i,j));\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\nusing namespace std;\nint sum = 0;\nchar a[20][20];\nvoid solve(int h, int w,  int i,int  j) {\n\tif (i + 1 < h&&a[i + 1][j] == '.') {\n\t\tsum++;\n\t\ta[i + 1][j] = '#';\n\t\tsolve(h, w,  i+1, j);\n\t}\n\tif (i - 1 >= 0&&a[i - 1][j] == '.') {\n\t\tsum++;\n\t\ta[i - 1][j] = '#';\n\t\tsolve(h, w,  i-1, j);\n\t}\n\tif (j + 1 < w&&a[i][j+1] == '.') {\n\t\tsum++;\n\t\ta[i][j+1] = '#';\n\t\tsolve(h, w,  i, j+1);\n\t}\n\tif (j - 1 >= 0&&a[i][j-1] == '.') {\n\t\tsum++;\n\t\ta[i][j-1] = '#';\n\t\tsolve(h, w,  i, j-1);\n\t}\n}\nint main() {\n\tint h, w;\n\twhile (cin >> w >> h&&w != 0 && h != 0) {\n\t\tstring b;\n\t\tint h2, w2;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> b;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ta[i][j] = b[j];\n\t\t\t\tif (a[i][j] == '@') {\n\t\t\t\t\th2 = i;\n\t\t\t\t\tw2 = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tsolve(h, w,  h2, w2);\n\t\tcout << ++sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <functional>\n#include<algorithm>\n#include <cmath>\n#include <string>\n#include <map>\nusing namespace std;\n\nint W,H;\nchar a[30][30];\nbool re[30][30];\n\nvoid se(int x,int y,int *c){\n\tif(x<0||W<=x||y<0||H<=y||a[y][x]=='#')\n\t\treturn;\n\tif(re[y][x])\n\t\treturn;\n\t\n\tre[y][x]=true;\n\t\t*c=*c+1;\n\t\n\tse(x+1,y,c);\n\tse(x,y+1,c);\n\tse(x-1,y,c);\n\tse(x,y-1,c);\n}\n\nint main(){\n\tint x,y;\n\tint x1,y1;\n\twhile(cin>>W>>H){\n\t\tif(W!=0&&H!=0){\n\t\t\tint k=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\tcin>>a[i][j];\n\t\t\t\tif(a[i][j]=='@'){\n\t\t\t\tx1=j;\n\t\t\t\ty1=i;}\n\t\t\t}\n\t\t}\n\t\tse(x1,y1,&k);\n\t\tcout<<k<<endl;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h, w_index, h_index, ans;\n    vector<int> sums;\n\n    while (1) {\n        ans = 1;\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(h);\n        for (int i = 0; i < h; i++) {\n            vec[i].resize(w);\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        for (auto it = vec.begin(); it != vec.end(); it++ ) {\n            auto iter = find(it->begin(), it->end(), '@');\n\n            if(iter!=it->end()){\n                h_index = distance( vec.begin(), it );\n                w_index = distance( it->begin(), iter );\n            }\n        }\n\n        dfs( w, h, w_index, h_index, vec, ans );\n\n        sums.push_back( ans );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &v , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    v[h_index][w_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && v[ny][nx] != '#' ){\n            ans++;\n            dfs( W, H, nx, ny, v, ans );\n        }\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nint visit(int a, int b);\n\nusing namespace std;\n\nvector<string> cell;\nvector< vector<bool> > check;\nint c, d;\n\nint main(){\n    \n    while(cin >> c >> d, c | d){\n        string temp;\n        int x = 0, y = 0;\n        \n        for(int i = 0; i < d; i++){\n            cin >> temp;\n            cell.push_back(temp);\n        }\n        \n        for(int i = 0; i < d; i++){\n            for(int j = 0; j < c; j++){\n                if(cell[i][j] == '@'){\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n        \n        for(int i = 0; i < d; i++){\n            vector<bool> temp2;\n            for(int j = 0; j < c; j++){\n                temp2.push_back(false);\n            }\n            check.push_back(temp2);\n        }\n        \n        cout << visit(y, x) << endl;\n        \n        cell.clear();\n        check.clear();\n        \n        \n    }\n    \n    return 0;\n}\n\nint visit(int a, int b){\n    int ans = 0;\n    \n    check[a][b] = true;\n    \n    if(a + 1 < d && cell[a + 1][b] != '#' && !check[a + 1][b]){\n        ans += visit(a + 1, b);\n    }\n    \n    if(b + 1 < c && cell[a][b + 1] != '#' && !check[a][b + 1]){\n        ans += visit(a, b + 1);\n    }\n    \n    if(a - 1 > -1 && cell[a - 1][b] != '#' && !check[a - 1][b]){\n        ans += visit(a - 1, b);\n    }\n    \n    if(b - 1 > -1 && cell[a][b - 1] != '#' && !check[a][b - 1]){\n        ans += visit(a, b - 1);\n    }\n    \n    ans++;\n    \n    return ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp*/\n\n#include <iostream>\n\nusing namespace std;\n\nstruct point{\n    int x;\n    int y;\n};\n\nchar map[20][20];\n\nint move(const struct point p,int h,int w){\n    int count=1;\n    map[p.x][p.y]='/';\n    for (int i = 0; i < 4; ++i) {\n        struct point tmp=p;\n\n        switch (i){\n            case 0:\n                tmp.x++;\n                break;\n            case 1:\n                tmp.x--;\n                break;\n            case 2:\n                tmp.y++;\n                break;\n            case 3:\n                tmp.y--;\n                break;\n            default:\n                break;\n        }\n        if (tmp.x<w && tmp.y<h && map[tmp.x][tmp.y]=='.') {\n            count+=move(tmp,h,w);\n        }\n    }\n    return count;\n}\n\nint main(){\n    int w,h;\n\n    while (cin>>w>>h && (w>0 || h>0)){\n        struct point start;\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                cin>>map[j][i];\n                if(map[j][i]=='@'){\n                    start.x=j;\n                    start.y=i;\n                }\n            }\n        }\n        cout<<move(start,h,w)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint solve( int w, int h, vector< vector<char> > &v );\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(w);\n        for (int i = 0; i < w; i++) {\n            vec[i].resize(h);\n        }\n\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < h; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        sums.push_back( solve( w, h, vec ) );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nint solve( int w, int h, vector< vector<char> > &v ){\n    int w_index, h_index, total;\n    int ans = 0;\n\n    for (auto it = v.begin(); it != v.end(); it++ ) {\n        auto iter = find(it->begin(), it->end(), '@');\n\n        if(iter!=it->end()){\n            w_index = distance( v.begin(), it );\n            h_index = distance( it->begin(), iter );\n        }\n    }\n\n    dfs( w, h, w_index, h_index, v, ans );\n\n    return ans;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[w_index][h_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[nx][ny] == '.' ){\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\n\nvoid dfs(int x, int y) {\n    num++;\n    \n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1 && room[y-1][x] == 0) dfs(x, y-1);\n    if (y+1 < h && room[y+1][x] == 0) dfs(x, y+1);\n    if (x-1 > -1 && room[y][x-1] == 0) dfs(x-1, y);\n    if (x+1 < w && room[y][x+1] == 0) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid dfs(char **data, int x, int y, int &count){\n  if (data[y][x] == '.' || data[y][x] == '@'){\n    data[y][x] = '#';\n    ++count;\n    //cout << count << endl;\n    dfs(data, (x-1), y, count);\n    dfs(data, x, (y-1), count);\n    dfs(data, (x+1), y, count);\n    dfs(data, x, (y+1), count);  \n  }\n  return;\n}\n\nint main(int argc, char* argv[]){\n  int w, h;\n  \n  while (cin >> w >> h && w!=0 && h!=0){\n    char **data = new char*[h+2];\n    for (int i=0; i<(h+2); ++i){\n      data[i] = new char[w+2];\n    }\n    \n    int x,y;\n    \n    for (int i=0; i<(h+2); ++i){\n      for (int j=0; j<(w+2); ++j){\n\tif ( i==0 || j==0 || i==(h+1) || j==(w+1)){\n\t  data[i][j] = '#';\n\t}\n\telse{\n\t  cin >> data[i][j];\n\t  //black: .   red: #   person: @\n\t  if (data[i][j] == '@'){\n\t    x = j;\n\t    y = i;\n\t  }\n\t}      \n      }\n    }\n    /*\n    cout << endl << endl;\n    for (int i=0; i<(h+2); ++i){\n      for (int j=0; j<(w+2); ++j){\n\tcout << data[i][j];\n      }\n      cout << endl;\n    }\n    */\n    int count = 0;\n    dfs(data, x, y, count);\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\n\n\nvoid dfs(int x,int y){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif((x<0||y<0)||t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(x+dx[k],y+dy[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\n\tint w,h,sx,sy,cnt;\n\trep(i,20)rep(j,20){\nt[i][j]=='#';\t\n\t}\n\nwhile(true){\nscanf(\"%d %d\",&w,&h);\nif(!w&&!h) {break;}\nrep(i,h){\ncin >> t[i];\n}\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\ndfs(sx,sy);\ncnt =0;\n\nrep(i,h){ \n\trep(j,w)if(t[i][j]=='@') cnt++;\t\n}\n\ncout <<endl<<cnt;;\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint W, H;\nchar tile[25][25];\nint cnt;\n\nvoid dfs(int y, int x){\n\tcnt++;\n\ttile[y][x] = '#';\n\tint dy[4] = { 0, 1, 0, -1 };\n\tint dx[4] = { 1, 0, -1, 0 };\n\tfor (int i = 0; i < 4; i++){\n\t\tint Y = y + dy[i];\n\t\tint X = x + dx[i];\n\t\tif (0 <= Y&&Y < H && 0 <= X&&X < W&&tile[Y][X] != '#')dfs(Y, X);\n\t}\n}\n\nint main(){\n\t\n\t\n\twhile (cin >> W >> H,W != 0 && H != 0){\n\t\tcnt = 0;\n\n\t\tint y, x;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(y, x);\n\n\t\tcout << cnt << endl;\n\n\t}\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\nint main(int argc, char *argv[]) {\n\tint w,h;\n\twhile (true) {\n\t\tcin>>w>>h;\n\t\tcin.ignore();\n\t\tif (w == 0 && h == 0) break;\n\t\tvector<string> map(h);\n\t\tfor (int i=0;i<h;i++) getline(cin,map[i]);\n\t\t//for (int i=0;i<h;i++) cout<<map[i]<<endl;\n\t\t// search @\n\t\tint si,sj;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// bfs\n\t\tqueue<pair<int,int> > mQue;\n\t\tint count = 0;\n\t\tmQue.push(make_pair(si,sj));\n\t\tvector<vector<bool> > check(h,vector<bool>(w,true));\n\t\twhile (mQue.size() > 0) {\n\t\t\tint ti,tj;\n\t\t\tpair<int,int> tp = mQue.front();\n\t\t\tmQue.pop();\n\t\t\tti = tp.first;\n\t\t\ttj = tp.second;\n\t\t\t//cout<<tj<<\":\"<<ti<<endl;\n\t\t\t// count\n\t\t\tif (check[ti][tj]) {\n\t\t\t\tcount++;\n\t\t\t\tcheck[ti][tj] = false;\n\t\t\t}\n\t\t\t// deque\n\t\t\tif (ti-1>=0 && map[ti-1][tj] == '.' && check[ti-1][tj]) {\n\t\t\t\tmQue.push(make_pair(ti-1,tj));\n\t\t\t}\n\t\t\tif (tj+1<w && map[ti][tj+1] == '.' && check[ti][tj+1]) {\n\t\t\t\tmQue.push(make_pair(ti,tj+1));\n\t\t\t}\n\t\t\tif (ti+1<h && map[ti+1][tj] == '.' && check[ti+1][tj]) {\n\t\t\t\tmQue.push(make_pair(ti+1,tj));\n\t\t\t}\n\t\t\tif (tj-1>=0 && map[ti][tj-1] == '.' && check[ti][tj-1]) {\n\t\t\t\tmQue.push(make_pair(ti,tj-1));\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint cnt;\nint w, h;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nchar tile[20][20];\n\nvoid dfs(int x, int y);\n\nint main()\n{\n\tint x, y;\n\n\twhile (true){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif (w == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", tile[i]);\n\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tdfs(x, y);\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\n\treturn (0);\n}\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '#';\n\tcnt++;\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && tile[ny][nx] == '.'){\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\nusing namespace std;\nint w,h;\nstring map[40];\nint vec[4][2]={{0,1},{0,-1},{-1,0},{1,0}};\n\nstruct pos{\n\tpos(int X,int Y){\n\t\tx=X,y=Y;\n\t}\n\tint x,y;\n};\n\nint move(int x,int y){\n\tint ans=0;\n\tmap[x][y]='#';\n\tstack<pos> bfs;\n\tbfs.push(pos(x,y));\n\twhile(!bfs.empty()){\n\t\tpos n=bfs.top();bfs.pop();\n\t\tans++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif((n.x+vec[i][0]>=0)&&(n.y+vec[i][1]>=0)&&(n.x+vec[i][0]<h)&&(n.y+vec[i][1]<w)){\n\t\t\t\tif(map[n.x+vec[i][0]][n.y+vec[i][1]]=='.'){\n\t\t\t\t\tmap[n.x+vec[i][0]][n.y+vec[i][1]]='#';\n\t\t\t\t\tbfs.push(pos(n.x+vec[i][0],n.y+vec[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint fx,fy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tfx=i;\n\t\t\t\t\tfy=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=move(fx,fy);\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint m,n,ans;\nchar ice[22][22];\n\nvoid saiki(int w,int h){\n\tice[w+1][h]='*';\n\t\n\tif(ice[w+2][h]=='.')saiki(w+1,h);\n\tif(ice[w+1][h+1]=='.')saiki(w,h+1);\n\tif(ice[w][h]=='.')saiki(w-1,h);\n\tif(h!=0)if(ice[w+1][h-1]=='.')saiki(w,h-1);\n}\n\nint main(void){\n\n\tfor(;;){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(!m||!n)break;\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",&ice[i+1]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i+1][j]=='@')saiki(i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i+1][j]=='*')ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint nx[]={0,1,0,-1};\nint ny[]={-1,0,1,0};\nint w,h;\nchar mp[101][101];\nint dfs(int y,int x);\nint a,b;\nint main()\n{\n  while(1){\n    cin >> w >> h;\n    if(w==0&&h==0){\n      break;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mp[i][j];\n\tif(mp[i][j]=='@'){\n\t  a=i;\n\t  b=j;\n\t}\n      }\n    }\n    cout << dfs(a,b) << endl;\n  }\n  return(0);\n}\n\nint dfs(int y,int x){\n  if(0>y||0>x||y>=h||x>=w){\n    return(0);\n  }\n  if(mp[y][x]=='#'){\n    return(0);\n  }\n  mp[y][x]='#';\n  int ans=0;\n  for(int i=0;i<4;i++){\n    ans=ans+dfs(y+ny[i],x+nx[i]);\n  }\n  return ans+1;\n}\n    \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint masu[20][20];\nint W,H;\n\nint dfs(int x,int y){\n     if(x>=W||y>=H||x<0||y<0)return 0;\n     if(masu[x][y]==1)return 0;\n     masu[x][y]=1;\n     return dfs(x+1,y)+dfs(x,y+1)+dfs(x-1,y)+dfs(x,y-1)+1;\n}\n\nint main(){\n     while(1){\n\t  cin>>W>>H;\n\t  if(W==0)break;\n\t  int pos[2];\n\t  for(int j=0;j<H;j++){\n\t       string temp;\n\t       cin>>temp;\n\t       for(int i=0;i<W;i++){\n\t\t    switch(temp[i]){\n\t\t    case '.':\n\t\t\t masu[i][j]=0;\n\t\t\t break;\n\t\t    case '@':\n\t\t\t masu[i][j]=0;\n\t\t\t pos[0]=i;pos[1]=j;\n\t\t\t break;\n\t\t    case '#':\n\t\t\t masu[i][j]=1;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  int ans=dfs(pos[0],pos[1]);\n\t  cout<<ans<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1000000007;\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint ans;\nchar c[40][40];\nint a,b;\n\n\nvoid bfs(int sx, int sy) {\n\tqueue< pair<int,int> > q;\n\tqueue< PII > qp;\n\tq.push(MP(sx,sy));\n\tc[sx][sy] = 'x';\n\tfor (int i = 1; i < 1000; i++) {\n\t\twhile (!q.empty()) {\n\t\t\tPII v = q.front(); //get value\n\t\t\tq.pop();\n\t\t\tint x = v.first, y = v.second;\n\t\t\tif (c[x+1][y] == '.'){ qp.push(MP(x+1,y)); c[x+1][y] = 'x'; ans++; }\n\t\t\tif (c[x-1][y] == '.'){ qp.push(MP(x-1,y)); c[x-1][y] = 'x'; ans++; }\n\t\t\tif (c[x][y+1] == '.'){ qp.push(MP(x,y+1)); c[x][y+1] = 'x'; ans++; }\n\t\t\tif (c[x][y-1] == '.'){ qp.push(MP(x,y-1)); c[x][y-1] = 'x'; ans++; }\n\n\t\t}\n\t\twhile (!qp.empty()) {\n\t\t\tq.push(qp.front());\n\t\t\tqp.pop();\n\t\t}\n\t\t//\t\tfor (int h = 0; h < b+2; h++) {\n\t\t//\t\t\tfor (int w = 0; w < a+2; w++) {\n\t\t//\t\t\t\tcout << c[w][h];\n\t\t//\t\t\t}\n\t\t//\t\t\tcout << endl;\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\n\t}\n}\n\nint main(int argc, char const* argv[])\n{\n\twhile (true) {\n\t\tint sx,sy;\n\t\tcin >> a >> b;\n\t\tif (a == 0 && b == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int h = 0; h < b+2; h++) {\n\t\t\tfor (int w = 0; w < a+2; w++) {\n\t\t\t\tif (h == 0 || w == 0 || h == b+1 || w == a+1) {\n\t\t\t\t\tc[w][h] = '#';\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> c[w][h];\n\t\t\t\t\tif (c[w][h] == '@') {\n\t\t\t\t\t\tsx = w;\n\t\t\t\t\t\tsy = h;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1;\n\t\tbfs(sx,sy);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\nvoid init(vec & parent, vec & size)\n{\n\tfor (int i = 0; i < parent.size(); ++i)\n\t{\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\n\n\nint find(vec & parent, int x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\treturn x = find(parent,parent[x]);\n}\n\n\nvoid unite(vec & parent, vec & size, int x, int y)\n{\n\tx = find(parent, x);\n\ty = find(parent, y);\n\n\tif (x == y)return;\n\n\tparent[y] = x;\n\tsize[x] += size[y];\n}\n\n\nint change(int y,int x,int W)\n{\n\treturn y*W + x;\n}\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0)return 0;\n\n\t\tmat color(H, vec(W));\n\t\tvec parent(W*H);\n\t\tvec size(W*H);\n\n\t\tinit(parent, size);\n\n\t\tint start;\n\n\t\tfor (int y = 0; y < H; ++y)\n\t\t{\n\t\t\tstring c;\n\t\t\tcin >> c;\n\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (c[x] == '.') { \n\t\t\t\t\t\n\t\t\t\t\tcolor[y][x] = 0; \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (c[x] == '#') { color[y][x] = 1; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor[y][x] = 0;\n\t\t\t\t\tstart = change(y, x, W);\n\t\t\t\t}\n\n\t\t\t\tif (x != 0 && color[y][x] == color[y][x - 1])\n\t\t\t\t{\n\t\t\t\t\tunite(parent, size, change(y, x, W), change(y, x - 1, W));\n\t\t\t\t}\n\t\t\t\tif (y != 0 && color[y][x] == color[y - 1][x])\n\t\t\t\t{\t\n\t\t\t\t\tunite(parent, size, change(y, x, W), change(y - 1, x, W));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tcout << size[find(parent, start)] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <array>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint height, width;\nint sx, sy;\nint ans = 0;\narray<int, 4> dx = {0, 0, 1, -1};\narray<int, 4> dy = {1, -1, 0, 0};\n\n\nvoid bfs(vector<vector<char>>& field)\n{\n    queue<pii> p;\n    p.push({sx, sy});\n    \n    while (!p.empty()) {\n        pii q = p.front(); p.pop();\n        \n        //??????\n        int cx = q.first;\n        int cy = q.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = cx + dx.at(i);\n            int ny = cy + dy.at(i);\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height \n                    && field.at(ny).at(nx) == '.') {\n\n                ans++;\n                p.push({nx, ny});\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\nint main()\n{\n    while (cin >> height >> width) {\n        if (height == 0 && width == 0) break;\n\n        ans = 0;\n        \n        vector<vector<char>> field(height, vector<char>(width));\n\n        for (int y = 0; y < height; ++y) {\n            for (int x = 0; x < width; ++x) {\n                cin >> field.at(y).at(x);\n\n                if (field.at(y).at(x) == '@') {\n                    sx = x; sy = y;\n                }\n            }\n        }\n\n        bfs(field);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef std::pair<int, int> P;\n\nint W = 0;\nint H = 0;\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nvoid display(std::string *tile){\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      std::cout << tile[i][j] << \" \";\n    }\n    std::cout << std::endl;\n  }\n  std::cout << std::endl;\n}\n\nP getStart(std::string *tile){\n  P start;\n  bool flag = false;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      if(tile[i][j] == '@'){\n        start.first = i;\n        start.second = j;\n        flag = true;\n        break;\n      }\n      if(flag) break;\n    }\n  }\n  return start;\n}\n\nint main(){\n  while(1){\n    std::cin >> W >> H;\n    if(W + H == 0) break;\n    std::vector<std::string> tile(H);\n    for(int i = 0; i < H; i++){\n      std::cin >> tile[i];\n    }\n\n    //display(tile.data());\n    P s = getStart(tile.data());\n\n    std::vector<std::vector<bool> > visited(H, std::vector<bool>(W, false));\n\n    std::queue<P> que;\n    que.push(s);\n    int ans = 1;\n    while(que.size()){\n      P now = que.front();que.pop();\n      for(int i = 0; i < 4; i++){\n        int nx = now.second + dx[i], ny = now.first + dy[i];\n        if(0 <= nx && nx < W && 0 <= ny && ny < H && !visited[ny][nx] && tile[ny][nx] == '.'){\n          que.push(P(ny, nx));\n          visited[ny][nx] = true;\n          ans++;\n        }\n      }\n    }\n    \n    std::cout << ans << std::endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned next = 1U;\n\t\tchar** room = new char*[h];\n\t\tunsigned** group = new unsigned*[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = 0U;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tfor (int j = w - 1; j >=0; j--) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif ((group[i][j] & group[y][x]) != 0U) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint room[23][23];\nint main(){\n\t\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tint sh,sw;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar a;\n\t\t\t\tcin>>a;\n\t\t\t\tif(a=='.')room[i][j]=0;\n\t\t\t\tif(a=='#')room[i][j]=-1;\n\t\t\t\tif(a=='@'){\n\t\t\t\t\troom[i][j]=1;\n\t\t\t\t\tsh=i;sw=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=1;\n\t\tqueue<pair<int,int> > q;\n\t\tq.push(pair<int,int>(sh,sw) );\n\t\twhile(q.size()){\n\t\t\tpair<int,int> pp=q.front();q.pop();\n\t\t\tif(pp.first>0&&room[pp.first-1][pp.second]==0){\n\t\t\t\tq.push(pair<int,int>(pp.first-1,pp.second));\n\t\t\t\troom[pp.first-1][pp.second]=1;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(pp.first<h-1&&room[pp.first+1][pp.second]==0){\n\t\t\t\tq.push(pair<int,int>(pp.first+1,pp.second));\n\t\t\t\tans++;\n\t\t\t\troom[pp.first+1][pp.second]=1;\n\t\t\t}\n\t\t\tif(pp.second>0&&room[pp.first][pp.second-1]==0){\n\t\t\t\tq.push(pair<int,int>(pp.first,pp.second-1));\n\t\t\t\tans++;\n\t\t\t\troom[pp.first][pp.second-1]=1;\n\t\t\t}\n\t\t\tif(pp.second<w-1&&room[pp.first][pp.second+1]==0){\n\t\t\t\tq.push(pair<int,int>(pp.first,pp.second+1));\n\t\t\t\tans++;\n\t\t\t\troom[pp.first][pp.second+1]=1;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tfor(int i=0;i<23;i++){\n\t\t\tfor(int j=0;j<23;j++){\n\t\t\t\troom[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint W, H;\nchar tile[21][21];\n\nint search(int y, int x) {\n  if (tile[y][x] == '#') return 0;\n  int cnt = 1;\n  tile[y][x] = '#';\n  if (y > 0)   cnt += search(y-1, x);\n  if (y < H-1) cnt += search(y+1, x);\n  if (x > 0)   cnt += search(y, x-1);\n  if (x < W-1) cnt += search(y, x+1);\n  return cnt;\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &W, &H);\n    if (W == 0 && H == 0) break;\n    for (int i=0;i<H;i++) scanf(\"%s\", tile[i]);\n    int cnt = 0;\n    for (int i=0;i<H;i++) {\n      for (int j=0;j<W;j++) {\n        if (tile[i][j] == '@') {\n          cnt = search(i, j);\n          break;\n        }\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(!w)break;\n    vector<string> t(h);\n    REP(i,h)cin>>t[i];\n    int si,sj;\n    REP(i,h)REP(j,w){\n      if(t[i][j] == '@'){\n        si = i;\n        sj = j;\n      }\n    }\n    vector<vector<bool>> vis(h,vector<bool>(w,false));\n    vis[si][sj] = true;\n    queue<pair<int,int>> q;\n    q.push(make_pair(si,sj));\n    while(!q.empty()){\n      auto p = q.front();q.pop();\n      int i,j;\n      tie(i,j) = p;\n      int di[] = {1,0,-1,0};\n      int dj[] = {0,1,0,-1};\n      REP(k,4){\n        int ni=i+di[k];\n        int nj=j+dj[k];\n        if(ni<0||ni>=h||nj<0|nj>=w)continue;\n        if(t[ni][nj] == '#')continue;\n        if(vis[ni][nj]) continue;\n        q.push(make_pair(ni,nj));\n        vis[ni][nj] = true;\n      }\n    }\n    int cnt = 0;\n    REP(i,h)REP(j,w){\n      if(vis[i][j])++cnt;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 縦型探索\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint w, h;\nint mx[] = {0, 0, -1, 1};\nint my[] = {-1, 1, 0, 0};\n\nint dfs(int x, int y, vector<string> &v) {\n    int cnt = 1;\n    for ( int i = 0; i < 4; i++ ) {\n        int nx = x + mx[i], ny = y + my[i];\n        if ( 0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == '.' ) {\n            v[ny][nx] = '#';\n            cnt += dfs(nx, ny, v);\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    while ( true ) {\n        int x, y;\n        cin >> w >> h;\n        if ( w == 0 && h == 0 ) break;\n\n        vector<string> v(h);\n\n        for ( int i = 0; i < h; i++ ) {\n            cin >> v[i];\n\n            for ( int j = 0; j < v[i].size(); j++ ) {\n                if ( v[i][j] == '@' ) {\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n\n        cout << dfs(x, y, v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n \n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nchar grid[100][100];\nint w,h;\nint ans=0;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool searched[100][100];\nint a=0,b=0;\n\nbool inrange(int x,int y){\n  if(x<0||y<0||x>=h||y>=w) return false;\n  else return true;\n}\n\nvoid search(int x,int y){\n  if((grid[x][y]=='.'||grid[x][y]=='@')&&searched[x][y]==false&&inrange(x,y)){\n\tsearched[x][y]=true;\n\tans++;\n\t//\tcout <<x <<' '<<y << endl;\n\t  REP(i,4) {\n\t  search(x+dx[i],y+dy[i]);\n\t}\n  }\n}\n\nint main(){\n  while(1){\n\tcin >> w >> h;\n\tif(w==0&&h==0) break;\n\tans = 0;\n\tREP(i,h){\n\t  REP(j,w){\n\t\tcin >> grid[i][j];\n\t\tsearched[i][j]=false;\n\t\tif(grid[i][j]=='@'){\n\t\t  a=i;\n\t\t  b=j;\n\t\t}\n\t  }\n\t}\n\tsearch(a,b);\n\n\tcout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(u) begin(u),end(u)\n#define PB push_back\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long int ll;\nconst int INF = (1<<30) - 1;\nconst double EPS = 1e-9;\nconst int MOD = 1000000007;\n\nint W, H;\nint dw[] = {0, 0, 1, -1};\nint dh[] = {1, -1, 0, 0};\n\nint dfs(vector<string> &field, int h, int w){\n    field[h][w] = '#';\n    \n    int res = 1;\n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(0<=nh && nh<H && 0<=nw && nw<W && field[nh][nw]=='.'){\n            res += dfs(field, nh, nw);\n        }\n    }\n    return res;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin >> W >> H, W|H){\n        vector<string> field(H);\n        for(auto &l: field)\n            cin >> l;\n        \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++) if(field[i][j] == '@')\n                cout << dfs(field, i, j) << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nstruct aa {\n\tint y;\n\tint x;\n\tbool black;\n};\n\nint main() {\n\twhile (1) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (!w)break;\n\t\tvector<vector<int>>field(h + 2, vector<int>(w + 2, 0));\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i + 1][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (st[j] == '#') {\n\t\t\t\t\t\tfield[i + 1][j + 1] = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsx = j + 1;\n\t\t\t\t\t\tsy = i + 1;\n\t\t\t\t\t\tfield[i + 1][j + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<aa>que;\n\t\tque.push_back(aa{ sy, sx, true });\n\t\tint ans = 1;\n\t\tvector<vector<bool>>used(h + 2, vector<bool>(w + 2, false));\n\t\tused[sy][sx] = true;\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.back());\n\t\t\tque.pop_back();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tif (atop.black) {\n\t\t\t\t\tif (field[ny][nx] == 2) {\n\t\t\t\t\t\tif (!used[ny][nx]) {\n\t\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\tque.push_back(aa{ ny,nx,!atop.black });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[ny][nx] == 1) {\n\t\t\t\t\t\tif (!used[ny][nx]) {\n\t\t\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\tque.push_back(aa{ ny,nx,!atop.black });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nchar tile[20][20];\nint cnt;\nint add_y[4] = {0, 0, 1,-1};\nint add_x[4] = {1,-1, 0, 0};\n\nvoid sarch(int y, int x, int h, int w){\n\tif(y<0 || y==h || x<0 || x==w) return;\n\n\tif(tile[y][x] == '.'){\n\t\tcnt++;\n\t\ttile[y][x] = '#';\n\n\t\t/*\n\t\tfor(int i=0 ; i<h ; i++){\n\t\t\tfor(int j=0 ; j<w ; j++){\n\t\t\t\tcout << tile[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\n\t}else if(tile[y][x] == '#'){\n\t\treturn;\n\t}\n\n\tfor(int i=0 ; i<4 ; i++){\n\t\tsarch(y+add_y[i], x+add_x[i], h, w);\n\t}\n\treturn;\n}\n\nint main(){\n\n\tint w, h;\n\tint y, x;\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0) break;\n\n\t\tcnt = 0;\n\n\t\tfor(int i=0 ; i<20 ; i++){\n\t\t\tfor(int j=0 ; j<20 ; j++){\n\t\t\t\ttile[i][j] = '_';\n\t\t\t}\n\t\t}\n\n\t\tstring temp[h];\n\t\tgetline(cin , temp[0]);\n\t\tfor(int i=0 ; i<h ; i++){\n\t\t\tgetline(cin , temp[i]);\n\t\t\tfor(int j=0 ; j<w ; j++){\n\t\t\t\ttile[i][j] = temp[i][j];\n\t\t\t\tif(tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsarch(y, x, h, w);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int W = 20, H = 20;\nchar board[H][W];\nint w, h;\n\nint dfs(int x, int y){\n\tint dx[] = {0, -1, 1, 0}, dy[] = {-1, 0, 0, 1};\n\tint c = 1;\n\tboard[y][x] = '#';\n\tfor(int i = 0;i < 4;++i){\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif(0 <= tx && 0 <= ty && tx < w && ty < h && board[ty][tx] == '.'){\n\t\t\tc += dfs(tx, ty);\n\t\t}\n\t}\n\treturn c;\n}\n\nint main(){\n\tint sx, sy;\n\twhile(cin >> w >> h, w){\n\t\tfor(int i = 0;i < h;++i){\n\t\t\tfor(int j = 0;j < w;++j){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j] == '@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(sx, sy) << endl;\n//\t\tfor(int i = 0;i < h;++i){\n//\t\t\tfor(int j = 0;j < w;++j){\n//\t\t\t\tcout << board[i][j];\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n\tint w,h,ct;\n\tstring s;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0) break;\n\t\tint a[w+2][h+2];\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tfor(int j=0;j<w+2;j++){\n\t\t\t\ta[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tint num=1;\n\t\tfor(int i=1;i<h+1;i++){\n\t\t\tcin>>s;\n\t\t\tfor(int j=1;j<w+1;j++){\n\t\t\t\tif(s[j-1]=='.'){\n\t\t\t\t\ta[j][i]=1;\n\t\t\t\t}\n\t\t\t\telse if(s[j-1]=='#'){\n\t\t\t\t\ta[j][i]=0;\n\t\t\t\t}\n\t\t\t\telse if(s[j-1]=='@'){\n\t\t\t\t\ta[j][i]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo{\n\t\t\tct=0;\n\t\t\tfor(int i=1;i<h+1;i++){\n\t\t\t\tfor(int j=1;j<w+1;j++){\n\t\t\t\t\tif(a[j][i]==2&&a[j-1][i]==1){\n\t\t\t\t\t\ta[j-1][i]=2;\n\t\t\t\t\t\tct++;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[j][i]==2&&a[j+1][i]==1){\n\t\t\t\t\t\ta[j+1][i]=2;\n\t\t\t\t\t\tct++;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[j][i]==2&&a[j][i-1]==1){\n\t\t\t\t\t\ta[j][i-1]=2;\n\t\t\t\t\t\tct++;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[j][i]==2&&a[j][i+1]==1){\n\t\t\t\t\t\ta[j][i+1]=2;\n\t\t\t\t\t\tct++;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while(ct>0);\n\t\tcout<<num<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#define pb push_back\n#define INF 1000000000\n\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nbool inf(int y,int x){\n\tif(y>=0&&y<h&&x>=0&&x<w)\n\treturn true;\n\treturn false;\n}\nint main(){\n\t\n\tint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n\twhile(cin>>w>>h,w||h){\n\t\tvector<string> s(h);\n\t\tvector<vector<int> > d(h,vector<int>(w,INF));\n\t\tqueue<P> que;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(s[j][k]=='@'){\n\t\t\t\t\t\td[j][k]=0;\n\t\t\t\t\t\tque.push(P(j,k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tP q=que.front();\n\t\t\tque.pop();\n\t\t\tint x=q.second,y=q.first;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\t\t\tif(inf(ny,nx)&&s[ny][nx]!='#'&&d[ny][nx]>d[y][x]+1){\n\t\t\t\t\td[ny][nx]=d[y][x]+1;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d[i][j]!=INF)\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint W, H;\nchar tile[25][25];\nint cnt;\nint x, y;\n\nvoid dfs(int y, int x){\n\ttile[y][x] = '#';\n\tcnt++;\n\tint dy[4] = { 0, 1, 0, -1 };\n\tint dx[4] = { 1, 0, -1, 0 };\n\tfor (int i = 0; i < 4; i++){\n\t\tint Y = y + dy[i];\n\t\tint X = x + dx[i];\n\t\tif (0 <= Y&&Y < H && 0 <= X&&X < W&&tile[Y][X] != '#'){\n\t\t\tdfs(Y, X);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile (cin >> W >> H, W != 0 && H != 0){\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(y, x);\n\t\tcout << cnt << endl;\n\t\tcnt = 0;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n\nint ans;\nchar maze[27][27];\nvoid dfs(int x,int y){\n\tint dx[4] = {1,-1, 0, 0};\n\tint dy[4] = {0, 0, 1, -1};\n\tmaze[x][y]='#';\n\trep(i,4){\n\t\tint nx = dx[i] + x;\n\t\tint ny = dy[i] + y;\n\t\tif(maze[nx][ny]=='.'){\n\t\t\tans++;\n\t\t\tdfs(nx,ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\trep(i,25)rep(j,25)\n\t\t\tmaze[i][j]='#';\n\t\tans=0;\n\t\tif(w==0&&h==0)return 0;\n\t\trep(i,h)rep(j,w)\n\t\t\tcin>>maze[i][j];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(maze[i][j]=='@'){\n\t\t\t\tdfs(i,j);\n\t\t\t\tcout<<ans+1<<endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring place[20];\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\nint serch(int n,int m,int y,int x)\n{\n\tint ans=1;\n\tplace[y][x]='#';\n\tfor(int i=0,ax,ay;i<4;i++)if((ay=dy[i]+y)<m&&(ax=dx[i]+x)<n&&ay>=0&&ax>=0&&place[ay][ax]=='.')ans+=serch(n,m,ay,ax);\n\treturn ans;\n}\nint main() {\n\tint n,m,y,x;\n\twhile(cin>>n>>m,n,m){\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>place[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(place[i][j]=='@'){\n\t\t\t\t\tx=j;\n\t\t\t\t\ty=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<serch(n,m,y,x)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nint W,H;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nchar ma[21][21];\nint sx,sy;\n\nint bfs(){\n  int count=1;\n  int d[21][21];\n  queue<P> que;\n   for(int i=0;i<W;i++)\n   for(int j=0;j<H;j++) d[i][j]=1000000;\n  que.push(P(sx,sy));\n  d[sx][sy]=0;\n\n  while(!que.empty()){\n    P p=que.front(); que.pop();\n    for(int i=0;i<4;i++){\n\tint nx=p.first+dx[i],ny=p.second+dy[i];\n\tif(0<=nx && nx<W && 0<=ny && ny<H && ma[nx][ny]!='#' &&\n\t   d[nx][ny] == 1000000){\n\t  que.push(P(nx,ny));\n\t  d[nx][ny]=0;\n\t  // cout<<nx<<\"  \"<<ny<<endl;\n\t  count++;\n      }\n    }\n  }\n    return count;\n  }\n\n\nint main(){\n  while(1){\n  cin>>H>>W;\n  if(H+W==0) break;\n  for(int i=0;i<W;i++){\n    for(int j=0;j<H;j++){\n      cin>>ma[i][j];\n      if(ma[i][j]=='@') {\n\tsx=i;\n\tsy=j;\n      }\n    }\n  }\n  \n  int ans =bfs();\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cctype>\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repi(i,l,n) for(int (i)=(int)(l);(i)<(int)(n);(i)++)\n#define d_arr(arr, h, w) rep(i,(h) ){ cout << \"[\"; rep(j,(w) ) { cout << (arr)[i][j] << \", \"; } cout << \"]\" << endl;}\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x);\n#define fs first\n#define sc second\n\ntypedef pair<int ,int> P;\n\nchar grid[20][20];\nbool arrived[20][20];\nint dx[4] ={1,0,-1,0};\nint dy[4] ={0,1,0,-1};\nint w,h;\n\n//i,jから初めて到達可能なタイルの数の最大値(i,j)含む\nvoid rec(int i,int j){\n//    printf(\"i:%d j:%d\\n\",i,j);\n    arrived[i][j] = true;\n    grid[i][j] = '#';\n    int ret = 0;\n    rep(k,4) {\n        int next_j = j+dx[k];\n        int next_i = i+dy[k];\n        if( next_j < w && 0 <= next_j &&\n            next_i < h && 0 <= next_i &&\n            grid[next_i][next_j] == '.')\n        {\n            rec(next_i,next_j);\n        }\n    }\n}\n\nint main()\n{\n    P start;\n    while(1){\n        cin >> w >> h;\n        rep(i,20) rep(j,20) arrived[i][j] = false;\n        rep(i,h){\n            rep(j,w){\n                cin >> grid[i][j];\n                if( grid[i][j] == '@' ){ start.first=i;start.second=j; }\n            }\n        }\n        rec(start.first,start.second);\n        int ret=0;\n        rep(i,20){\n            rep(j,20){\n                if(arrived[i][j] == true ){\n                    ret+=1;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nint d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nint movex[4] = {-1,1,0,0};\nint movey[4] = {0,0,-1,1};\n\nint main(){\n  while(1){\n    cin >> m >> n;\n    if(!n && !m)break;\n    char field[102][102];\n    char now;\n    int x,y;\n    queue<P> que;\n    lep(i,0,n+1)lep(j,0,m+1)field[i][j] = '#';\n    lep(i,1,n){\n      lep(j,1,m){\n        cin >> now;\n        field[i][j] = now;\n        if(now == '@'){\n          que.push(P(i,j));\n          // cout << i << \" \" << j << endl;\n        }\n      }\n    }\n    ll ans = 1;\n    while(!que.empty()){\n      P move = que.front(); que.pop();\n      rep(i,0,4){\n        if(field[move.first + movex[i]][move.second + movey[i]] == '.'){\n          ans++;\n          que.push(P(move.first + movex[i],move.second + movey[i]));\n          field[move.first + movex[i]][move.second + movey[i]] = '#';\n        }\n      }\n    }\n    print(ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nchar t[20][20];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ans,h,w;\nqueue<P> q;\n\nint bfs(int x, int y){\n\n  q.push( P(x, y) );\n  \n  while( !q.empty() ){\n    P now = q.front();\n    q.pop();\n    for( int i = 0 ; i < 4 ; i++ ){\n      int nx = now.first + dx[i];\n      int ny = now.second + dy[i];\n      if( 0 <= nx && nx < w && 0 <= ny && ny <= h \n\t  && t[ny][nx] == '.' ){\n\tt[ny][nx] = '#';\n\tq.push( P(nx, ny) );\n\tans++;\n      }\n    }\n  }\n  return ans;\n}\n\nint main(void){\n\n  int x,y;\n  while( cin >> w >> h, h + w ){\n\n    memset( t, 0, sizeof(t) );\n    ans = 1;\n\n    for( int i = 0 ; i < h ; i++ ){\n      for( int j = 0 ; j < w ; j++ ){\n\tcin >> t[i][j];\n\tif( t[i][j] == '@' ){\n\t  x = j;\n\t  y = i;\n\t}\n      }\n    }\n    cout << bfs(x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) Rep(i, 0, n)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nint h, w;\nint dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n\nbool in(int y, int x) { return 0 <= y && y < h && 0 <= x && x < w; }\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1)\n    {\n        cin >> w >> h;\n        if (w == 0 && h == 0)\n            break;\n        vector<string> s(h);\n        rep(i, h) cin >> s[i];\n        queue<P> que;\n        int vis[30][30] = {};\n        rep(i, h) rep(j, w) if (s[i][j] == '@')\n        {\n            que.push({i, j});\n            vis[i][j] = 1;\n        }\n        int ans = 1;\n        while (!que.empty())\n        {\n            P p = que.front();\n            que.pop();\n            int y = p.first, x = p.second;\n            rep(i, 4)\n            {\n                int ny = y + dy[i], nx = x + dx[i];\n                if (!in(ny, nx) || vis[ny][nx] || s[ny][nx] == '#')\n                    continue;\n                vis[ny][nx] = 1;\n                ans++;\n                que.push({ny, nx});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <algorithm>\n# include <cassert>\n# include <cctype>\n# include <cstdio>\n# include <cstdlib>\n# include <cstring>\n# include <cmath>\n# include <iostream>\n# include <map>\n# include <queue>\n# include <set>\n# include <sstream>\n# include <stack>\n# include <string>\n# include <vector>\n# include <iomanip>\n\n# define rep(i, n) for (int i = 0; i < (int)(n); i++)\n# define irep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n# define FOR(i, m, n) for (int i = int(m); i < (int)(n); i++)\n\nusing namespace std;\n\nint ans;\nint next_i[] = {0, 1, 0, -1};\nint next_j[] = {1, 0, -1, 0};\n\ntemplate <typename T>\nvoid show_all (T t) {\n  rep (i, t.size()) {\n    rep (j, t[0].size()) {\n      cout << t[i][j] << ' ';\n    }\n    cout << endl;\n  }\n}\n\n\nvoid dfs (int i, int j, vector<vector<char>> &maze) {\n  rep (k, 4) {\n    int ii = i + next_i[k];\n    int jj = j + next_j[k];\n\n    if (0 <= ii && 0 <= jj && maze.size() > ii && maze[0].size() > jj && maze[ii][jj] == '.') {\n      maze[ii][jj] = '#';\n      ans++;\n      dfs(ii, jj, maze);\n    }\n  }\n}\n\nint main() {\n  int w, h;\n  int init_i, init_j;\n\n  while (cin >> w >> h && w && h) {\n    vector<vector<char>> maze;\n    ans = 1;\n\n    rep (i, h) {\n      vector<char> row(w);\n      maze.push_back(row);\n\n      rep (j, w) {\n        cin >> maze[i][j];\n        if (maze[i][j] == '@') {\n          init_i = i;\n          init_j = j;\n        }\n      }\n    }\n\n    // cout << \"before\" << endl;\n    // show_all(maze);\n    dfs(init_i, init_j, maze);\n    // cout << \"after\" << endl;\n    // show_all(maze);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nvector<vector<int>> M;\nvector<vector<int>> checked;\nint ans;\nint w, h;\n\nvoid dfs(int row, int col) {\n  ans++;\n  checked[row][col] = 1;\n  for (int i = 0; i < 4; i++) {\n    int x = col + dx[i];\n    int y = row + dy[i];\n    if (0 <= x && x < w && 0 <= y && y < h && M[y][x] == 1 &&\n        checked[y][x] == 0) {\n      dfs(y, x);\n    }\n  }\n}\nint main() {\n  while (cin >> w >> h) {\n    if (!w && !h)\n      break;\n\n    ans = 0;\n    M = vector<vector<int>>(h, vector<int>(w));\n    checked = vector<vector<int>>(h, vector<int>(w, 0));\n\n    int s_row, s_col;\n    for (int i = 0; i < h; i++) {\n      string line;\n      cin >> line;\n      for (int j = 0; j < w; j++) {\n        char c = line[j];\n        if (c == '.') {\n          M[i][j] = 1;\n        } else if (c == '#') {\n          M[i][j] = 0;\n        } else {\n          M[i][j] = 1;\n          s_row = i;\n          s_col = j;\n        }\n      }\n    }\n    dfs(s_row, s_col);\n    cout<<ans<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n    int w,h;\n    while(cin >> w >> h && w!=0){\n        int t[w+2][h+2];\n        int matrix[w*h][w*h];\n        int start;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i==0 || j==0 || i==w || j==h)\n                    t[i][j]=0;\n                char tmp; cin >> tmp;\n                if(tmp=='.'){\n                    t[i+1][j+1] = 1;\n                }\n                else if(tmp=='#'){\n                    t[i+1][j+1] = 0;\n                }\n                else{\n                    t[i+1][j+1] = 1;\n                    start = i*w+j;\n                }\n                cin >> t[i+1][j+1];\n            }\n        }\n        for(int i=0;i<w*h;i++){\n            for(int j=0;j<w*h;j++){\n                matrix[i][j] = 0;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(i==0 || j==0 || i==w || j==h)\n                    continue;\n                else{\n                    int id = i*w+h;\n                    if(t[(id-w)/w][(id-w)%w] == 1)\n                        matrix[id][id-w] = 1;\n                    if(t[(id+w)/w][(id+w)/w] == 1)\n                        matrix[id][id+w] = 1;\n                    if(t[(id-1)/w][(id-1)/w] == 1)\n                        matrix[id][id-1] = 1;\n                    if(t[(id+1)/w][(id+1)/w] == 1)\n                        matrix[id][id+1] = 1;\n                }\n            }\n        }\n        int count = 1;\n        queue<int> Q;\n        int came[w*h];\n        for(int i=0;i<w*h;i++){\n            came[i] = 0;\n        }\n        Q.push(start);\n        came[start] = 1;\n        while(Q.size()!=0){\n            int cur = Q.front();\n            for(int i=0;i<w*h;i++){\n                if(matrix[cur][i]==1 && came[i] == 0){\n                    Q.push(i);\n                    came[i] = 1;\n                    count++;\n                }\n            }\n            Q.pop();\n        }\n        cout << count << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <math.h>\n#include <algorithm>\n#include <vector> \nusing namespace std;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nstring map[20];\nint W, H;\n\nint dfs(int y, int x){\n  \n  int count = 1;\n  int i;\n  for(i = 0;i < 4;i++){\n    int next_x = x + dx[i] ,next_y = y + dy[i];\n    if(0 <= next_x && next_x < W && 0 <= next_y && next_y < H && map[next_y][next_x] == '.'){\n      map[next_y][next_x] = 'a';\n      count += dfs(next_y, next_x);\n    }\n  }\n  return count;\n}\n\n\nint main(){\n  int i, j, x, y;\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0) break;\n    bool start = false;\n    for(i = 0;i < H;i++){\n      cin >> map[i];\n      \n    }\n\n    for(i = 0;i < H;i++){\n      for(j = 0;j < W;j++){\n        if(map[i][j] == '@'){\n          x = j;\n          y = i;\n          start = true;\n          break;\n        }\n      }\n      if(start) break;\n    }\n\n    cout << dfs(y, x) << endl;\n\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint c=0,W,H;\nvector<string> grid;\nstring tmp;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0}; \nvoid dfs(int x, int y){\n  c++;\n  grid[y][x]='#';\n  REP(r,4){\n    if(x+dx[r]>=0&&x+dx[r]<W\n        &&y+dy[r]>=0&&y+dy[r]<H\n        &&grid[y+dy[r]][x+dx[r]]=='.'){\n      dfs(x+dx[r],y+dy[r]);\n    }\n  }\n}\n\nint main(void){\n  while(cin>>W>>H){\n    if(W==0) break;\n    grid.clear();\n    c = 0;\n    REP(y,H){\n      cin>>tmp;\n      grid.push_back(tmp);\n    }\n    REP(y,H)REP(x,W){\n      if(grid[y][x]=='@'){\n        dfs(x,y);\n      }\n    }\n    cout<<c<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nchar room[25][25] = {'#'};\n\nint walk(int x, int y) {\n    int ret = 1;\n    room[y][x] = '#';\n    if (room[y-1][x] == '.') ret += walk(x, y-1);\n    if (room[y+1][x] == '.') ret += walk(x, y+1);\n    if (room[y][x-1] == '.') ret += walk(x-1, y);\n    if (room[y][x+1] == '.') ret += walk(x+1, y);\n    return ret;\n}\n\nint main() {\n    int W, H;\n    while (cin >> W >> H, W || H) {\n        int x, y;\n        for (int i=0; i<25; ++i) {\n            for (int j=0; j<25; ++j) {\n                room[i][j] = '#';\n            }\n        }\n        for (int i=1; i<=H; ++i) {\n            for (int j=1; j<=W; ++j) {\n                cin >> room[i][j];\n                if (room[i][j] == '@') {\n                    room[i][j] = '.';\n                    y = i, x = j;\n                }\n            }\n        }\n        cout << walk(x, y) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \nusing namespace std;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int x,int y);\nint w,h;\n \nint count;\nbool flag;\nchar maze[21][21];\nbool reached[501][501];\n \nint main(){\n        int w,h;\n\n    while(cin>>w>>h){\n\n            if(w==0&&h==0){\n                break;\n            }\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    cin>>maze[i][j];\n                }\n            }\n\n\n// cout<<endl;\n//              for(int i=0;i<h;i++){\n//                 for(int j=0;j<w;j++){\n//                     cout<<maze[i][j];\n//                 }\n//                 cout<<endl;\n//             }\n\n//             cout<<endl;\n\n\n// cout<<endl;\n//             for(int i=0;i<21;i++){\n//                 for(int j=0;j<21;j++){\n//                     cout<<maze[i][j];\n//                 }\n//                 cout<<endl;\n//             }cout<<endl;\n\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(maze[i][j]=='@'){\n                        dfs(j,i);\n                    }\n                }\n            }\n\n            // for(int i=0;i<h;i++){\n            //     for(int j=0;j<w;j++){\n            //         cout<<maze[i][j];\n            //     }\n            //     cout<<endl;\n            // }\n\n            count=0;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(maze[i][j]=='!')count++;\n                }\n            }\n\n            cout<<count<<endl;\n\n            for(int i=0;i<22;i++){\n                for(int j=0;j<22;j++){\n                    maze[i][j]='%';\n                }\n            }\n\n            // cout<<endl;\n\n\n        }\n    \n\n\n \n    return 0;\n}\n \n \nvoid dfs(int x,int y){\n    maze[y][x]='!';\n\n    for(int i=0;i<4;i++){\n        int mx=x+dx[i];\n        int my=y+dy[i];\n        if(maze[my][mx]=='.'){\n            dfs(mx,my);\n        }\n        if(mx<0||w<=mx||my<0||h<=my){\n            continue;\n        }//??????????????´?????´???->???????????????\n\n\n\n        \n    } \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint W,H;\nint t[20][20];\nint c;\nchar ch;\n\nint dy[4] = {0,1,0,-1};\nint dx[4] = {1,0,-1,0};\n\nbool inField(int y,int x){\n  if( 0<=y && y<H && 0<=x && x<W ){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nvoid visit(int y,int x){\n  c++;\n  t[y][x]=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if( inField(ny,nx) && t[ny][nx]==0){\n      visit(ny,nx);\n    }\n  }\n}\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(W==0&&H==0)break;\n    int sy,sx;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin>>ch;\n        if(ch=='.'){\n          t[i][j]=0;\n        }\n        if(ch=='@'){\n          sy=i;\n          sx=j;\n        }\n        if(ch=='#'){\n          t[i][j]=-1;\n        }\n      }\n    }\n    c=0;\n    visit(sy,sx);\n    cout<<c<<endl;\n  }\n  return 0; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return (x < h && y < w) && (x >= 0 && y >= 0);\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\n\tmoved = 0;\n\tint initX, initY;\n\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i;\n\t\t    initY = j;\n\t\t}\n\t    }\n\t}\n\t\n\tmove(initX, initY);\n\t\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nstring tile[20];\n\nint w, h;\n\nint dfs(int x, int y){\n\tint ret = 1;\n\tif (tile[x][y] == '#') return 0;\n\ttile[x][y] = '#';\n\n\tfor (int i = 0; i < 4; i++){\n\t\tif (x + dx[i] < 0 || x + dx[i] >= h) continue;\n\t\tif (y + dy[i] < 0 || y + dy[i] >= w) continue;\n\t\tret += dfs(x + dx[i], y + dy[i]);\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile (cin >> w >> h,w){\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> tile[i];\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(x, y) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_H = 22;\nconst int MAX_W = 22;\n\nchar grid[MAX_H][MAX_W];\nbool is_checked[MAX_H][MAX_W];\n\nvoid solve(int W, int H) {\n    map<P, bool> is_exist;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n            is_checked[i][j] = false;\n            is_exist[P(i, j)] = true;\n        }\n    }\n    queue<P> Q;\n    int dh[4] = {-1, 0, 1, 0}, dw[4] = {0, -1, 0, 1};\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '@') {\n                Q.push(P(i, j));\n                is_checked[i][j] = true;\n                while (!Q.empty()) {\n                    P now_pos = Q.front();\n                    Q.pop();\n                    for (int k = 0; k < 4; k++) {\n                        P new_pos = P(now_pos.first + dh[k], now_pos.second + dw[k]);\n                        if (!is_exist[new_pos] || is_checked[new_pos.first][new_pos.second]) continue;\n                        if (grid[new_pos.first][new_pos.second] == '#') continue;\n                        is_checked[new_pos.first][new_pos.second] = true;\n                        Q.push(new_pos);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (is_checked[i][j]) ans++;\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int W, H;\n    while (true) {\n        cin >> W >> H;\n        if (W == 0 && H == 0) break;\n        solve(W, H);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\nbool c[20][20] = {} ;\nint cnt,w, h, p[20][20] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[20];\n\twhile (1) {\n\t\tfor (int i = 0; i < 400; i++) {\n\t\t\tc[i / 20][i % 20] = p[i / 20][i % 20] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n\t\t\t\t\tc[j][i] = 0;\n\t\t\t\t\tp[j][i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j][i] = 1;\n\t\t\t\tcase '.':\n\t\t\t\t\tc[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t\tif (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1 || p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w = 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h][i % h + 1] == 1 || p[i / h][i % h - 1] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w != 1 && h = 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h][i%h] == 0 && (p[i / h + 1][i % h] == 1 || p[i / h - 1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h][i%h] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*for (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j][i]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h][i%h] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N+1];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\t//memset(memo,0, sizeof(memo));\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tmemo[i][j] = 0;\n\t\t}\n\t}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nint w,h,sx,sy,visit[100][100],cnt;\nchar s[100][100];\n\nvoid dfs(int x,int y){\n    visit[x][y]=1;\n    if(x>0&&s[x-1][y]=='.'&&!visit[x-1][y]){\n        dfs(x-1,y);\n    }\n    if(x<h-1&&s[x+1][y]=='.'&&!visit[x+1][y]){\n        dfs(x+1,y);\n    }\n    if(y>0&&s[x][y-1]=='.'&&!visit[x][y-1]){\n        dfs(x,y-1);\n    }\n    if(y<w-1&&s[x][y+1]=='.'&&!visit[x][y+1]){\n        dfs(x,y+1);\n    }\n}\n\nint main(){\n    scanf(\"%d %d\",&w,&h);\n    while(w&&h){\n        for(int i=0;i<h;i++){\n            scanf(\"%s\",s[i]);\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='@'){\n                    sx=i;\n                    sy=j;\n                }\n                visit[i][j]=0;\n            }\n        }\n        dfs(sx,sy);\n        cnt=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cnt+=visit[i][j];\n            }\n        }\n        printf(\"%d\\n\",cnt);\n        scanf(\"%d %d\",&w,&h);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar f[22][22];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0}; \nint w,h,sx,sy;\nvoid dfs(int x,int y)\n{\n\tif(f[x][y]!='.')return;\n\tf[x][y]='7';\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx<0||nx>=h||ny<0||ny>=w)continue;\n\t\tif(f[nx][ny]!='.')continue;\n\t\tdfs(nx,ny);\n\t}\n\treturn;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]=='@')\n\t\t\t\t{\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tf[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy);\n\t\tint ans = 0;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(f[i][j]=='7')ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\n#define inRange(x,a,b) (a <= x && x < b)\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};\n\nint main(){\n    int h, w;\n    while(cin >> w >> h, w+h){\n        char mat[h][w];\n        int x, y;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j] == '@')    y = i, x = j, mat[i][j] = '.';\n            }\n        }\n\n        stack<pair<int,int>> s;\n        s.push({y,x});\n\n        int ans = 0;\n        while(!s.empty()){\n            pair<int,int> now = s.top();    s.pop();\n            if(mat[now.first][now.second] == '#')   continue;\n            if(mat[now.first][now.second] == '.')   ans++;\n            mat[now.first][now.second] = '#';\n            for(int k = 0; k < 4; k++){\n                int ny = now.first + dy[k];\n                int nx = now.second + dx[k];\n                if(inRange(ny, 0, h) && inRange(nx,0,w) && mat[ny][nx] == '.'){\n                    s.push({ny, nx});\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£?????????????´?1?????????\n?°?????????¨?????£??????????????????????????§?????????\n???????????????????????°????????????????±?legal??¢??°?????????????????¨?????????????????????\nx<h???y<w???????????????????????????\n#endif\n\n#include <iostream>\n#include <queue>\nusing namespace std;\nint w,h;\nint g[21][21];\nbool visited[21][21];\nint moves[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nint count;\nbool legal(int x, int y)\n{\n  if(visited[x][y]!=true&&0<=x&&x<h&&0<=y&&y<w&&g[x][y]==0)\n    return true;\n  else\n    return false;\n}\n\nvoid dfs(int x,int y)\n{\n  visited[x][y]=true;\n  count++;\n  for(int i=0;i<4;i++)\n  {\n    int newx=x+moves[i][0];\n    int newy=y+moves[i][1];\n    if(legal(newx,newy))\n    {\n      dfs(newx,newy);\n    }\n  }\n}\n\nint main()\n{\n  while(1)\n  {\n    cin>>w>>h;\n    if(w==0&&h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        g[i][j]=-1;\n        visited[i][j]=false;\n      }\n    int psx,psy;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        char s;\n        cin>>s;\n        switch(s)\n        {\n          case '.':\n            g[i][j]=0;break;\n          case '#':\n            g[i][j]=1;break;\n          case '@':\n            g[i][j]=2;psx=i;psy=j;break;\n        }\n      }\n    count=0;\n    dfs(psx,psy);\n/*    int count=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        count+=visited[i][j];\n      }\n*/  cout<<count<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nint a,b,ans;\nint q[20+5][20+5];\nchar p[20+5][20+5];\n\nusing namespace std;\nint main() {\n\tqueue<pair<int,int> > M;\n\tpair<int,int> X;\n\tcin >> a >> b;\n\tfor (int i=1; i<=b; i++){\n\t\tfor (int j=1; j<=a; j++){\n\t\t\tcin >> p[i][j];\n\t\t\tif (p[i][j] == '@'){\n\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\tans = 1;\n\t\t\t\tq[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\twhile(!M.empty()){\n\t\ta = M.front().first;\n\t\tb = M.front().second;\n\t\tM.pop();\n\t\tfor (int i=0; i<=3; i++){\t\t\n\t\t\tif (p[a+dx[i]][b+dy[i]]=='.' && q[a+dx[i]][b+dy[i]]==0){\n\t\t\t\tM.push(make_pair(a+dx[i],b+dy[i]));\n\t\t\t\tq[a+dx[i]][b+dy[i]] = 1;\n\t\t\t\tans+=1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct DataSet{\n    int x, y;\n    int ax, ay;\n    string str;\n};\n\nint search(int xSize, int ySize, int x, int y, string& s){\n    //cout << '[' << x << ',' << y << ']' << endl;\n    int ret = 0;\n    int nowPos = x + y * xSize;\n    s[nowPos] = '#';\n    ++ret;\n    \n    if(s[nowPos - 1] == '.' && x != 0){\n        ret += search(xSize, ySize, x-1, y, s);\n    }\n    if(s[nowPos + 1] == '.' && x + 1 != xSize){\n        ret += search(xSize, ySize, x+1, y, s);\n    }\n    if(s[nowPos - xSize] == '.' && y != 0){\n        ret += search(xSize, ySize,x, y-1, s);\n    }\n    if(s[nowPos + xSize] == '.' && y + 1 != ySize){\n        ret += search(xSize, ySize, x, y+1, s);\n    }\n    return ret;\n}\n\nint main()\n{\n    vector<DataSet> dataSets;\n    char word;\n    \n    while(cin){\n        DataSet dataSet;\n        cin >> dataSet.x >> dataSet.y;\n        for(int i = 0; i < dataSet.y * dataSet.x; i++){\n            cin >> word;\n            if(word == '@'){\n                dataSet.ax = i % dataSet.x;\n                dataSet.ay = i / dataSet.x;\n            }\n            //cout << line << endl;\n            dataSet.str += word;\n        }\n        dataSets.push_back(dataSet);\n    }\n    dataSets.pop_back();\n    \n    //cout << dataSets.back().x << ' ' << dataSets.back().y << endl;\n    //cout << dataSets.back().ax << ' ' << dataSets.back().ay << endl;\n    //cout << dataSets.back().str;\n    \n    for(auto dataSet : dataSets){\n        if(dataSet.x == 0) continue;\n        cout << search(dataSet.x, dataSet.y, dataSet.ax, dataSet.ay, dataSet.str) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H;\nchar board[30][30];\nbool visited[30][30];\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue;\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W && H) {\n      memset(visited, false, sizeof(visited));\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      board[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n\n      cout << cnt << endl;\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint n, m;\nchar map[20][20];\nint ans = 0;\n\nint dfs(int x, int y){\n\tif(0 <= x && x < m && 0 <= y && y < n){\n\t\tif(map[x][y] != '.') return 0;\n\t\tmap[x][y] = '@';\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i=0; i<20; i++){\n\t\t\tfor(int j=0; j<20; j++){\n\t\t\t\tmap[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tscanf(\"%s\", map[i]);\n\t\t}\n\t\tint x, y;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x-1, y);\n\t\tdfs(x+1, y);\n\t\tdfs(x, y-1);\n\t\tdfs(x, y+1);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(map[i][j] == '@') ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tans = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 20;\ntypedef pair<int, int> P;\n\nint calc(char f[][MAX_SIZE], queue<P> q, int W, int H) {\n  int n = 0;\n  while (q.size()) {\n    n++;\n    P p = q.front();\n    q.pop();\n    int di[] = {-1, 1, 0, 0};\n    int dj[] = {0, 0, -1, 1};\n    for (int k = 0; k < 4; ++k) {\n      int i = p.first  + di[k];\n      int j = p.second + dj[k];\n      if (i >= 0 && j >= 0 && i < H && j < W && f[i][j] == '.') {\n        f[i][j] = '#';\n        q.push(P(i, j));\n      }\n    }\n  }\n  return n;\n}\nint main() {\n  int W, H;\n  char f[MAX_SIZE][MAX_SIZE];\n  while (true) {\n    queue<P> q;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; ++i) {\n      cin >> f[i];\n      for (int j = 0; j < W; ++j) {\n        if (f[i][j] == '@') {\n          q.push(P(i, j));\n        }\n      }\n    }\n    cout << calc(f, q, W, H) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#define rep(i, n) for(int i = 0; i < n; i ++)\n#define ALL(T) T.begin(), T.end()\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst int INF = 1 << 24;\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nint cnt, w, h;\nchar m[100][100];\n\nvoid dfs(pii);\n\nint main(void){\n    while(cin >> w >> h, w){\n        MEMSET(m, '#');\n\n        cnt = 0;\n        pii p;\n\n        rep(y, h){\n            cin >> m[y];\n            rep(x, w) if(m[y][x] == '@') m[y][x] = '.', p = mp(x, y);\n        }\n\n        dfs(p);\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n\nvoid dfs(pii p){\n    if((p.X < 0 || w <= p.X) ||\n       (p.Y < 0 || h <= p.Y)) return;\n\n    if(m[p.Y][p.X] == '.') cnt ++;\n    else return;\n    m[p.Y][p.X] = '#';\n\n    rep(i, 4){\n        pii next = mp(p.X + dx[i], p.Y + dy[i]);\n        dfs(next);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1001001001;\n\n\nint w, h;\nint a[20][20];\nint sw, sh;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint D[20][20];\nint Ans = 1;\n\n\nint main()\n{\n    while(cin >> w, w != 0)\n    {\n        Ans = 1;\n        cin >> h;\n        \n        for(int i = 0; i < 20; i++)\n        {\n            for(int j = 0; j < 20; j++)\n            {\n                D[i][j] = inf;\n            }\n        }\n        \n        for(int i = 0; i < h; i++)\n        {\n            for(int j = 0; j < w; j++)\n            {\n                char x;\n                cin >> x;\n                if(x == '.')\n                {\n                    a[j][i] = 1;\n                }\n                else if(x == '#')\n                {\n                    a[j][i] = 0;\n                }\n                else\n                {\n                    sw = j;\n                    sh = i;\n                    a[j][i] = 100;  //  ????????§?????????\n                }\n            }\n        }\n        queue< pair<int, int> > Q;\n        pair<int, int> S;\n        S = make_pair(sw, sh);\n        Q.push(S);\n        D[sw][sh] = 0;\n        int k = 0;\n        while(! Q.empty())\n        {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int x = cur.first;\n            int y = cur.second;\n            for(int i = 0; i < 4; i++)\n            {\n                if(a[x+dx[i]][y+dy[i]] == 1 && 0 <= x+dx[i] && x+dx[i] < w && 0 <= y+dy[i] && y+dy[i] < h && D[x+dx[i]][y+dy[i]] == inf)    //  ????????????????¢????????????????????????????????????°???\n                {\n                    D[x+dx[i]][y+dy[i]] = D[x][y] + 1;\n                    Ans = Ans + 1;\n                    pair<int, int> T;\n                    T = make_pair(x+dx[i], y+dy[i]);\n                    Q.push(T);\n                }\n            }\n        }\n        cout << Ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint COUNT=0;\n\nvoid dfs(vector<string> map,int state[20][20],int x,int y,int W,int H){\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  if(x<0 || x==H || y<0 || y==W)return; //????????????\n  if(state[x][y]!=0 || map[x][y]=='#')return; //?????§????????£??????????????????????????????\n  ++COUNT;\n  state[x][y]=1;\n  for(int i=0;i<4;++i)dfs(map,state,x+dx[i],y+dy[i],W,H); //??????????????¨??¢?´¢\n}\n\nint main(){\n  int W,H,x,y;\n  vector<string> map;\n  string a;\n  while(true){\n    COUNT=0;\n    cin >> W >>H;\n  if(!W && !H)break;\n  int state[20][20]={0}; //?????§????????£???????????????\n  for(int i=0;i<H;++i){ //???????????\\???\n    cin >> a;\n    map.push_back(a);\n  }\n  for(int i=0;i<H;++i){//????????????????????¢?´¢\n    if(0<map[i].find('@') && map[i].find('@')<W){\n      y=map[i].find('@');\n      x=i;\n      break;\n    }\n  }\n    dfs(map,state,x,y,W,H);\n    cout << COUNT << endl;\n    map.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n// int count(int a, int b, int ans, int sikaku){\n//   for(int i=-1;i<1;i++){\n//     for(int j=-1;j<1;j++){\n//       if(sikaku[a+i][b+j] == 1){\n// \tsikaku[a+i][b+j] = 10;\n// \tsikaku = count(a+i,b+j,ans,sikaku);\n//       }\n//     }\n//   }\n\n//   return sikaku;\n// }\n\nint main(){\n\n  int w,h;\n  int ans;\n  char aaa;\n  int a,b;\n\n  // while(cin >> w >> h){\n  //   if(w==0&&h==0)\n  //     break;\n  //   ans = 1;\n\n  //   int space[w][h];\n  //   for(int i=0;i<w;i++)\n  //     for(int j=0;j<h;j++){\n  // \tcin >> aaa;\n  // \tif(aaa == '.')\n  // \t  space[i][j] = 1;\n  // \telse if(aaa == '#')\n  // \t  space[i][j] = 0;\n  // \telse{\n  // \t a = i;\n  // \t b = j;\n  // \t}\n  //     }\n\n  //   ans = count(a,b,ans,space);\n  // }\n  ans = 0;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint d[] = {-1,1,0,0};\n\nint count(int x,int y, char map[22][22]){\n        int c = 0; \n        map[x][y] = '#';\n        c++;\n        for(int i = 0; i < 4; i++){\n                int nx = x+d[i];\n                int ny = y+d[3-i];\n                if(map[nx][ny] == '.'){\n                        c += count(nx,ny,map);\n                }  \n        }  \n        return c; \n}\n\nint main(){\n        int w,h;\n        cin >> w >> h; \n        while(w){\n                char map[22][22];\n                memset(map,'#',sizeof(map));\n                int x,y;\n                for(int i = 1; i <= h; i++){\n                        for(int j = 1; j <= w; j++){\n                                cin >> map[i][j];\n                                if(map[i][j] == '@'){\n                                        x = i; y = j; \n                                        map[i][j] = '.';\n                                }  \n                        }  \n                }  \n                cout << count(x,y,map) << endl;\n                cin >> w >> h; \n        }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y && y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (1){\n\tscanf(\"%d %d\", &w, &h);\n\tif (w == 0 && h == 0) break;\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\tdfs(sx, sy);\n\tprintf(\"%d\\n\", tile);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint moved = 0;\nint w, h;\nchar myMap[20][20];\n\nbool safe(int x, int y){\n    return x < h && y < w;\n}\n\nvoid move(int x, int y){\n    myMap[x][y] = '#';\n    moved++;\n    if (myMap[x+1][y] == '.' && safe(x+1, y)) move(x+1, y);\n    if (myMap[x-1][y] == '.' && safe(x-1, y)) move(x-1, y);\n    if (myMap[x][y+1] == '.' && safe(x, y+1)) move(x, y+1);\n    if (myMap[x][y-1] == '.' && safe(x, y-1)) move(x, y-1);\n    return;\n}\n\nint main(){\n    while (1){\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) break;\n\n\tmoved = 0;\n\tint initX, initY;\n\t\n\tfor (int i = 0; i < h; i++){\n\t    for (int j = 0; j < w; j++){\n\t\tcin >> myMap[i][j];\n\t\tif (myMap[i][j] == '@'){\n\t\t    initX = i; initY = j;\n\t\t}\n\t    }\n\t}\n\t\n\tmove(initX, initY);\n\t\n\tcout << moved << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint W, H;\nchar b[20][20];\nint ans;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y) {\n\tans++;\n\tb[y][x] = '#';\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < W && 0 <= ny && ny < H && b[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H , W) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tcin >> b[y][x];\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (b[y][x] == '@') {\n\t\t\t\t\tdfs(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n\n\nint main(){\n    std::vector<int> tiles;\n    std::queue<int> unvisited_tile_q;\n    int width, height, counter, pos;\n    std::string line;\n\n    while(true){\n        std::cin >> width >> height;\n        if( width == 0 && height == 0 ) break;\n        tiles.resize(width*height);\n        pos = 0;\n        for( int h = 0; h < height; h++ ){\n            std::cin >> line;\n            for(std::string::iterator it = line.begin(); it != line.end(); ++it) {\n                switch(*it){\n                    case '#':\n                        tiles[pos] = 0;\n                        break;\n                    case '@':\n                        unvisited_tile_q.push(pos);\n                    case '.':\n                        tiles[pos] = 1;\n                }\n                pos++;\n            }\n        }\n\n        counter = 0;\n        while( !unvisited_tile_q.empty() ){\n            pos = unvisited_tile_q.front();\n            unvisited_tile_q.pop();\n            if( tiles[pos] == 1 ){\n                counter++;\n                tiles[pos] = -1;\n            } else continue;\n            //left\n            if ( pos - 1 >= 0 && pos % width > 0 && tiles[pos-1] == 1 ) unvisited_tile_q.push(pos-1); \n             //right\n            if ( pos + 1 <= tiles.size() && pos % width < width - 1 && tiles[pos+1] == 1 ) unvisited_tile_q.push(pos+1);\n            //up\n            if ( pos - width >= 0 && tiles[pos-width] == 1 ) unvisited_tile_q.push(pos-width);\n            //down\n            if ( pos + width < tiles.size() && tiles[pos+width] == 1 ) unvisited_tile_q.push(pos+width);\n        }\n\t    //output result\n\t    std::cout << counter << std::endl;\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int w,h;\n  while(cin>>w>>h , w+h){\n    char Map[20][20]={0};\n    int pos = 0; \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>Map[i][j];\n\tif(Map[i][j]=='@') pos=i*w+j;\n      }\n    }\n    int cnt=0;\n    queue<int> q;\n    q.push(pos);\n    while(!q.empty()){\n      pos = q.front();\n      q.pop();\n      cnt++;\n      int x=pos%w;\n      int y=pos/w;\n      if(x>=1 && Map[y][x-1]=='.'){\n\tq.push(y*w+x-1);\n\tMap[y][x-1]='@';\n      }\n      if(y>=1 && Map[y-1][x]=='.'){\n\tq.push((y-1)*w+x);\n\tMap[y-1][x]='@';\n      }\n      if(x+1<w && Map[y][x+1]=='.'){\n\tq.push(y*w+x+1);\n\tMap[y][x+1]='@';\n      }\n      if(y+1<h && Map[y+1][x]=='.'){\n\tq.push((y+1)*w+x);\n\tMap[y+1][x]='@';\n      }\n      //      cout<<\" x = \"<<x<<\" y = \"<<y<<endl;\n    }\n    cout<<cnt<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nchar field[20][20];\nbool flag[20][20];\nint W, H, ans;\n\nvoid dfs(int x, int y) {\n  //field[x][y] = '.';\n  //cout << x << ' ' << y << endl;\n  //cout << flag[x][y] << endl;\n  //cout << ans << endl;\n  for(int i = 0 ; i < 4 ; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(0 <= nx && nx < H && 0 <= ny && ny < W && field[nx][ny] == '.' &&\n       flag[nx][ny] == false) {\n      ans++; flag[nx][ny] = true; dfs(nx, ny);\n      //cout << \"OK\" << endl;\n    }\n    //else dfs(nx, ny);\n  }\n}\n\nint main(void) {\n  int x, y;\n  int res;\n  \n  while(cin >> W >> H, W != 0 && H != 0) {\n    memset(flag, false, sizeof(flag));\n    ans = 1;\n    for(int i = 0 ; i < H ; i++) {\n      for(int j = 0 ; j < W ; j++) {\n\tcin >> field[i][j];\n\tif(field[i][j] == '@') x = i, y = j;\n      }\n    }\n    /*for(int i = 0 ; i < H ; i++) {\n      for(int j = 0 ; j < W ; j++) {\n\tcout << field[i][j];\n      }\n      cout << endl;\n      }*/\n    //printf(\"@x = %d, @y = %d\\n\", x, y);\n    dfs(x, y);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define frp(i,n) for((i)=0;(i)<(n);i++)\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\nint H,W;\nint check(int n1,int n2,int rednum,vector<int> red1,vector<int> red2){\n  for(int i=0;i<rednum;i++){\n    if(n1==red1[i]&&n2==red2[i]||n1<0||n2<0||n1>=H||n2>=W){\n      return 0;\n    }\n  }\n  return 1;\n}\nint main(){\n  int i,j,now1,now2;\n  while(cin>>W>>H,W+H!=0){\n    int num=1;\n    string str2;\n    vector<string> str;\n    vector<int> red1;\n    vector<int> red2;\n    frp(i,H){\n      cin>>str2;\n      str.push_back(str2);\n    }\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='#'){\n\t  red1.push_back(i);\n\t  red2.push_back(j);\n\t}\n      }\n    }\n    queue<pair<int,int> > qii;\n    frp(i,H){\n      frp(j,W){\n\tif(str[i][j]=='@'){\n\t  qii.push(make_pair(i,j));\n\t  red1.push_back(i);\n\t  red2.push_back(j);\n\t}\n      }\n    }\n    while(!qii.empty()){\n      now1=qii.front().first;\n      now2=qii.front().second;\n      qii.pop();//?????????????´??????´?£?\n      for(i=0;i<4;i++){\n\tif(check(now1+vx[i],now2+vy[i],red1.size(),red1,red2)==1){\n\t  cout<< now1<<\" \"<<now2<<endl;\n\t  red1.push_back(now1+vx[i]);\n\t  red2.push_back(now2+vy[i]);\n\t  qii.push(make_pair(now1+vx[i],now2+vy[i]));\n\t  num++;\n\t}\n      }\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,n) for(ll i=a;i<n;i++)\n#define ALL(s) s.begin(),s.end()\n#define P pair<ll,ll>\n#define vl vector<ll>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vvl vector<vector<ll>>\n#define print(n) cout<<n<<endl\nconst int M=100010;\nconst int MOD=1000000007;\nconst int inf=1000000007;\nconst long long INF=1000000000000000007;\nusing ll=long long;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint ans=0;\nint w,h;\nchar a[22][22];\nbool f[22][22];\nvoid dfs(int H,int W){\n\tif(W<0||W>=w||H<0||H>=h||a[H][W]=='#'||f[H][W]==true)return;\n\tif(a[H][W]=='.'&&f[H][W]==false){\n\t\tf[H][W]=true;\n\t\tans++;\n\t}\n\trep(i,0,4)dfs(H+dy[i],W+dx[i]);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tans=0;\n\t\trep(i,0,22)rep(j,0,22)f[i][j]=false;\n\t\tcin>>w>>h;\n\t\tint start_x,start_y;\n\t\tif(w==0)break;\n\t\trep(i,0,h)rep(j,0,w){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]=='@')start_y=i,start_x=j;\n\t\t}\n\t\tdfs(start_y,start_x);\n\t\tprint(ans+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n\nint tansaku(char tile[20][20],int w1,int h1){\n    if(tile[w1][h1]!='.'&&tile[w1][h1]!='@')return 0;\n    tile[w1][h1]='t';\n    return 1+tansaku(tile,w1+1,h1)+tansaku(tile,w1-1,h1)+tansaku(tile,w1,h1+1)+tansaku(tile,w1,h1-1);\n}\n\nint main(){\n    int w,h;\n    int w1,h1; //スタート地点\n   // 標準入力\n   while(1){\n    std::cin >> w;\n    std::cin >> h;\n    if(w==0&&h==0)break;\n   // 配列の初期化.\n    char tile[20][20];\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            std::cin >> tile[j][i];\n            if(tile[j][i]=='@'){\n                w1=j; h1=i;\n            }\n        }\n    }\n    std::cout << tansaku(tile,w1,h1) << std::endl;\n   }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dfs(int h, int w, vector<vector<int>> &v, vector<vector<int>> &field) {\n    v[h][w] = 1;\n    int dh[] = {0, 1, 0, -1};\n    int dw[] = {-1, 0, 1, 0};\n    \n    for (int i = 0; i < 4; i++) {\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if (field[nh][nw] == 1 && v[nh][nw] == 0) {\n            dfs(nh, nw, v, field);\n        }\n    }\n    return 0;\n}\n\nint solve(int H, int W) {\n    vector<vector<int>> field(H+2, vector<int>(W+2, 0));\n    \n    int startH;\n    int startW;\n    for (int h = 1; h <= H; h++) {\n        for (int w = 1; w <= W; w++) {\n            char c; cin >> c;\n            if (c == '.') {\n                field[h][w] = 1;\n            } else if (c == '@') {\n                field[h][w] = 1;\n                startH = h;\n                startW = w;\n            }\n        }\n    }\n    \n    int ret = 0;\n    vector<vector<int>> v(H+2, vector<int>(W+2, 0));\n    dfs(startH, startW, v, field);\n    for (int h = 1; h <= H; h++) {\n        for (int w = 1; w <= W; w++) {\n            if (v[h][w] == 1) {\n                ret++;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    // Your code here!\n    int W, H;\n    vector<int> ans;\n    while (1) {\n        cin >> W >> H;\n        if (!W && !H) break;\n        ans.push_back(solve(H, W));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\nchar room[21][21];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> p;\n\n\nint main(){\n\tint x,y;\n\tqueue<p> que;\n\tint w,h;\n\tcin>>w>>h;\n\tif(w+h==0) return;\n\tfor(int a=0;a<h;a++){\n\t\tfor(int b=0;b<w;b++){\n\t\t\tcin>>room[a][b];\n\t\t\tif(room[a][b]=='@'){\n\t\t\t\tx=b,y=a;\n\t\t\t\tque.push(p(b,a));\n\t\t\t\troom[a][b]='#';\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tint cnt=1;\n\tint nx,ny;\n\twhile(que.size()){\n\t\tp ap=que.front();\n\t\tque.pop;\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tnx=ap.first+dx[i];\n\t\t\tny=ap.second+dy[i];\n\t\t\tif(0<=nx&&nx<=w&&0<=ny&&ny<=h&&room[ny][nx]!='#'){\n\t\t\t\troom[ny][nx]='#';\n\t\t\t\tque.push(p(nx,ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;char n[100][100];int k[100][100],l[100][100],sum,H,W,i,j,m,s;\n#define A(B,C) if(k[B][C]!=1){l[B][C]=1;}\nmain(){while(true){s=0;memset(l,0,sizeof(l));cin>>W>>H;if(W==0){break;}for(i=1;i<=H;i++){for(j=1;j<=W;j++){cin>>n[i][j];if(n[i][j]=='.'){k[i][j]=0;}else if(n[i][j]=='@'){k[i][j]=2;l[i][j]=1;}else{k[i][j]=1;}}}for(i=0;i<2500;i++){for(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){A(j-1,m);A(j+1,m);A(j,m-1);A(j,m+1);}}}}for(j=1;j<=H;j++){for(m=1;m<=W;m++){if(l[j][m]==1){s++;}}}cout<<s<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint W,H;\nint x[4]={0,0,1,-1};\nint y[4]={1,-1,0,0};\nint i,j;\nint count=0;\nchar room[100][100];\n\nint dfs(int, int);\n\nint main(){\n  while(1){\n    int sy,sx;\n    scanf(\"%d %d\",&W,&H);\n    if(W==0&&H==0)break;\n    for(i = 0 ; i < H ; i++){\n      scanf(\"%c\",&room[i][0]);\n      for(j = 0 ; j < W ; j++){\n\tscanf(\"%c\",&room[i][j]);\n\tif(room[i][j] == '@'){\n\t  sy = i;\n\t  sx = j; \n\t}\n      }\n    }\n    printf(\"%d\\n\", dfs(sx,sy));\n  }\n  return 0;\n}\n\nint dfs(int ax,int ay){\n  if(ax<0||ay<0)return 0;\n  if(ax>=W||ay>=H)return 0;\n  if(room[ay][ax]=='#')return 0;\n  room[ay][ax]='#';\n  int cnt=1;\n  int i;\n  for(i=0;i<4;i++){\n    int nx=ax+x[i];\n    int ny=ay+y[i];\n    cnt+=dfs(nx,ny);\n  }\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MH 20\n#define MW 20\nusing namespace std;\nchar f[MH][MW];\nbool v[MH][MW];\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nint w, h;\nint c = 0;\n\nvoid search(int x, int y) {\n\t++c;\n\tv[y][x] = true;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == false && f[ny][nx] != '#') {\n\t\t\tsearch(nx, ny);\n\t\t}\n\t}\n\treturn;\n}\n\nint search2(int x, int y) {\n\tv[y][x] = true;\n\tint res = 1;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && v[ny][nx] == false && f[ny][nx] != '#') {\n\t\t\tres += search2(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint sx, sy;\n\n\twhile (cin >> w >> h, !(w == 0 && h == 0)) {\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif (f[i][j] == '@') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = 0;\n\t\tfill(v[0], v[MH], false);\n\t\t//search(sx, sy);\n\t\t//cout << c << endl;\n\t\tcout << search2(sx, sy) << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nchar a[20][20];\nint w,h,cx,cy,count=1;\n\nvoid check(int x,int y){\n  if (a[y][x]=='.'){\n    count ++;\n    a[y][x]='*';\n    if (x>0) check(x-1,y);\n    if (x<w-1) check(x+1,y);\n    if (y>0) check(x,y-1);\n    if (y<h-1) check(x,y+1);\n  }\n}\n\nint main(){\n  cin >> w >> h;\n  while (w!=0||h!=0){\n    for (int i=0;i<h;i++){\n      for (int j=0;j<w;j++){\n\tcin >> a[i][j];\n\tif (a[i][j]=='@'){\n\t  cx=j;\n\t  cy=i;\n\t}\n      }\n    }\n\n    if (cx>0) check(cx-1,cy);\n    if (cx<w-1) check(cx+1,cy);\n    if (cy>0) check(cx,cy-1);\n    if (cy<h-1) check(cx,cy+1);\n    \n    cout << count << endl;\n    count =1;\n    cin >> w >> h;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nconst int vx[4] = {0, 1, 0, -1}, vy[4] = {1, 0, -1, 0};\n\ninline bool check(int x, int y, int H, int W) {\n  return (0 <= x && x < H && 0 <= y && y < W);\n}\n\nint solve(int& H, int& W, std::vector<std::string>& v) {\n  int ret = 1, sx, sy;\n\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; ++j) {\n      if (v[i][j] == '@') {\n        sx = i, sy = j;\n      }\n    }\n  }\n\n  bool is_searched[21][21];\n\n  std::memset(is_searched, false, sizeof is_searched);\n\n  std::queue<std::pair<int, int> > que;\n  que.push(std::make_pair(sx, sy));\n  is_searched[sx][sy] = true;\n\n  while (!que.empty()) {\n    auto p = que.front();\n    que.pop();\n\n    for (int i = 0; i < 4; ++i) {\n      int nx = p.first + vx[i], ny = p.second + vy[i];\n\n      if (check(nx, ny, H, W) && !is_searched[nx][ny] && v[nx][ny] == '.') {\n        ret++;\n        is_searched[nx][ny] = true;\n        que.push(std::make_pair(nx, ny));\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  int H, W;\n\n  while (cin >> W >> H, W | H) {\n    std::vector<std::string> v(H);\n\n    for (int i = 0; i < H; ++i) {\n      cin >> v[i];\n    }\n\n    int ans = solve(H, W, v);\n\n    cout << ans << endl;    \n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#define rep(i,l,n) for(lint i=l;i<n;i++)\n#define rer(i,l,n) for(lint i=l;i<=n;i++)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define pb(a) push_back(a)\n#define mk(a,b) make_pair(a,b)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<lint> vli;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nint h, w, ans, sy, sx;\nchar s[21][21] = {};\nint d[21][21] = {};\nint dy[4] = { 1, -1, 0, 0 };\nint dx[4] = { 0, 0, 1, -1 };\n\nvoid dfs(int y, int x){\n\tif (y < 0 || h <= y || x < 0 || w <= x || d[y][x]||s[y][x]=='#') return;\n\tans++;\n\td[y][x] = 1;\n\trep(i, 0, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tdfs(ny, nx);\n\t}\n\treturn;\n}\n\nint main(){\n\twhile (1){\n\t\tcin >> w >> h;\n\t\trep(i, 0, 21){\n\t\t\trep(j, 0, 21){\n\t\t\t\td[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif (h == 0 && w == 0) break;\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\tcin >> s[i][j];\n\t\t\t\tif (s[i][j] == '@'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tdfs(sy, sx);\n\t\to(ans);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint solve( int w, int h, vector< vector<char> > &v );\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V, int &ans );\n\nint main(int argc, char const *argv[]) {\n    vector< vector<char> > vec;\n\n    int w, h;\n    vector<int> sums;\n\n    while (1) {\n        cin >> w >> h;\n\n        if( w==0 || h==0 ) break;\n\n        vec.resize(h);\n        for (int i = 0; i < h; i++) {\n            vec[i].resize(w);\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> vec[i][j];\n            }\n        }\n\n        sums.push_back( solve( w, h, vec ) );\n    }\n\n    for( auto it = sums.begin(); it != sums.end(); it ++ ){\n        cout << *it << endl;\n    }\n\n    return 0;\n}\n\nint solve( int w, int h, vector< vector<char> > &v ){\n    int w_index, h_index, total;\n    int ans = 1;\n\n    for (auto it = v.begin(); it != v.end(); it++ ) {\n        auto iter = find(it->begin(), it->end(), '@');\n\n        if(iter!=it->end()){\n            h_index = distance( v.begin(), it );\n            w_index = distance( it->begin(), iter );\n        }\n    }\n    std::cout << \"index:\"<< w_index << \",\" << h_index << std::endl;\n    dfs( w, h, w_index, h_index, v, ans );\n\n    return ans;\n}\n\nvoid dfs( int W, int H, int w_index, int h_index, vector< vector<char> > &V , int &ans ){\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, 1, 0, -1 };\n    V[h_index][w_index] = '#';\n\n    for( int i = 0; i < 4; i++ ){\n        int nx = w_index + dx[i];\n        int ny = h_index + dy[i];\n\n        if( 0 <= nx && nx < W && 0 <= ny && ny < H && V[ny][nx] == '.' ){\n            std::cout << nx << \",\"<< ny << std::endl;\n            ans++;\n            dfs( W, H, nx, ny, V, ans );\n        }\n    }\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm> \n#include <queue>\n#include <functional>\nusing namespace std;\n\nint w, h;\nint vx[4] = { 1, 0, -1, 0 };\nint vy[4] = { 0, 1, 0, -1 };\nbool used[20][20];\nchar c[20][20];\n\nint dfs(int x, int y){\n    int ret = 1;\n    for (int i = 0; i < 4; i++){\n        int nextx = x + vx[i];\n        int nexty = y + vy[i];\n\n        if (0 < nextx && nextx < w + 1 && 0 < nexty && nexty < h + 1 && c[nextx][nexty] == '.' && !used[nextx][nexty]){\n            used[nextx][nexty] = true;\n            ret += dfs(nextx, nexty);\n        }\n    }\n\n    return ret;\n    \n}\n\nint main(void){\n\n    while (true){\n\n        cin >> w >> h;\n\n        if (w == 0 && h == 0)break;\n\n        for (int i = 0; i <= 20; i++){\n            for (int j = 0; j <= 20; j++){\n                used[i][j] = false;\n            }\n        }\n\n        int sx, sy;\n\n        for (int i = 1; i <= h; i++){\n            for (int j = 1; j <= w; j++){\n                cin >> c[j][i];\n                if (c[j][i] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        cout << dfs(sx, sy) << endl;\n    }\n \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string>v;\nvector<int>ansl;\nstring s;\nint ary[100005] = {0};\nchar mp[22][22];\nint cnt = 0;\nint d_x[] = {0,1,0,-1};\nint d_y[] = {1,0,-1,0};\nint W,H;\n\nvoid dfs(int x,int y){\n  mp[y][x] = '#';\n  cnt++;\n  for(int d = 0;d<4;d++){\n    int nx = x+d_x[d],ny = y+d_y[d];\n    if((nx>=0)&&(ny>=0)&&(ny<H)&&(nx<W)&&(mp[ny][nx] == '.')){\n      dfs(nx,ny);\n    }\n  }\n}\nint main(){\n  cin >>W>>H;\n\n  while((W!=0)&&(H!=0)){\n    cnt = 0;\n    for(int i = 0;i<22;i++){\n      for(int j = 0;j<22;j++){\n        mp[i][j] = '#';\n      }\n    }\n    for(int i = 0;i<H;i++){\n      for(int j = 0;j<W;j++){\n        cin >>mp[i][j];\n      }\n    }\n    for (int y = 0; y < H; y++){\n      for (int x = 0; x < W; x++) {\n        if (mp[y][x] == '@') {\n          dfs(x, y);\n        }\n      }\n    }\n    cout <<cnt<<endl;\n    cin >>W>>H;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint array[20][20];\nint h, w, sx, sy;\nint ans;\n\nvoid out_array(void);\nvoid input(void);\nvoid search(int, int);\n\nint main(){\n\twhile(true){\n\t\t\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\treturn 0;\n\t\t}\n\n\t\tinput();\n\t\tans = 0;\n\t\tsearch(sx, sy);\n\t\tcout << ans << endl;\n\n\t}\n}\nvoid out_array(void){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tcout << array[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid input(void){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tswitch(c){\n\t\t\t\tcase '#':\n\t\t\t\t\tarray[i][j] = 1;//??????\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '.':\n\t\t\t\t\tarray[i][j] = 0;//?????????\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '@':\n\t\t\t\t\tarray[i][j] = 0;\n\t\t\t\t\tsx = j;//????????????\n\t\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid search(int x,int y){\n\tif(array[y][x] == 1 || x >= w || y >= h || x < 0 || y < 0){\n\t\treturn;\n\t}else{\n\t\tarray[y][x] = 1;\n\t\tans++;\n\t}\n\tsearch(x - 1, y);\n\tsearch(x + 1, y);\n\tsearch(x, y - 1);\n\tsearch(x, y + 1);\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define line() cerr << \"---------------\" << endl;\n\nint H, W;\nchar board[30][30];\nbool visited[30][30];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y) {\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if (board[nx][ny] == '#') continue;\n      if (visited[nx][ny]) continue; // これ必要な理由がわからない\n      visited[nx][ny] = true;\n      dfs(nx, ny);\n   }\n}\n\nint main() {\n   while (cin >> W >> H, W && H) {\n      memset(visited, false, sizeof(visited));\n\n      int sx = 0, sy = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            cin >> board[i][j];\n            if (board[i][j] == '@') {\n               sx = i, sy = j;\n            }\n         }\n      }\n\n      visited[sx][sy] = true;\n      dfs(sx, sy);\n\n      int cnt = 0;\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (visited[i][j]) cnt++;\n         }\n      }\n      cout << cnt << endl;\n\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<=30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint dfs(int x,int y);\nint w,h,i,j;\nchar maps[21][21];\nint dx[4]={0,-1,0,1};\nint dy[4]={-1,0,1,0};\nint sum=0;\n\nint main(){\n  int sx,sy;\n  while(1){\n    sum=0;\n    scanf(\"%d %d\",&h,&w);\n    if(h==0 && w==0) break;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\"%c\",&maps[i][j]);\n\tif(maps[i][j]=='@'){\n\t  sy=i;\n\t  sx=j;\n\t}\n      }\n    }\n    dfs(sx,sy);\n    printf(\"%d\\n\",sum);\n  }\n  return(0);\n}\n\nint dfs(int x,int y){\n  int nx,ny;\n  for(i=0;i<4;i++){\n    nx=x+dx[i];\n    ny=y+dy[i];\n    maps[y][x]='#';\n    if(0<=nx && nx<w && ny<h && maps[ny][nx]!='#'){\n      dfs(nx,ny);\n      sum++;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint field[60][60];\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\nint dfs(int x, int y);\nint main(){\n  int n,m;\n  while(cin >>n>>m,n||m){\n    for(int i=0; i<60; i++) for(int j=0; j<60; j++) field[i][j] = 1;\n    int x,y;\n    string s;\n    for(int i=0; i<m; i++){\n      cin >>s;\n      for(int j=0; j<n; j++){\n\tif(s[j] == '.') field[i+20][j+20] = 0;\n\tif(s[j] == '#') field[i+20][j+20] = 1;\n\tif(s[j] == '@'){\n\t  field[i+20][j+20] = 1;\n\t  x = i+20; y= j+20;\n\t}\n      }\n    }\n    cout <<dfs(x,y)<<endl;\n  }\n  return 0;\n}\nint dfs(int x, int y){\n  int ans = 0;\n  field[x][y] = 1;\n  ans++;\n  for(int i=0; i<4; i++){\n    if(field[x+dx[i]][y+dy[i]] == 0) ans+=dfs(x+dx[i],y+dy[i]);\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tdo {\n\t\t\tcin >> w >> h;\n\t\t} while (w < 0 || h < 0);\n\t\t\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned next = 1U;\n\t\tchar** room = new char*[h];\n\t\tunsigned** group = new unsigned*[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = 0U;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif ((group[i][j] & group[y][x]) != 0U) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int, int> P;\n\n/** Problem 1130 : Red and Black **/\nint main()\n{\n\tbool field[20][20];\n\tbool vis[20][20];\n\tint W, H, sx, sy; char c;\n\t\n\twhile (cin >> W >> H, W||H) {\n\t\tint ans = 0;\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c=='.') {\n\t\t\t\t\tfield[x][y]=true;\n\t\t\t\t} else if (c=='@') {\n\t\t\t\t\tfield[x][y]=true;\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t} else {\n\t\t\t\t\tfield[x][y] = false;\n\t\t\t\t}\n\t\t\t\tvis[x][y] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> Q;\n\t\tQ.push(P(sx, sy));\n\t\t\n\t\twhile (Q.size()!= 0) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (!vis[p.first][p.second]) {\n\t\t\t\tans++;\n\t\t\t\tvis[p.first][p.second]=true;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first+dx[i], ny=p.second+dy[i];\n\t\t\t\tif (0<= nx && nx < W && 0 <= ny && ny < H && field[nx][ny] && !vis[nx][ny])\n\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nint dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\nchar cell[20][20];\nbool used[20][20];\n\nint main(){\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tqueue<P> que;\n\t\tfor(int i = 0; i < 20; i++){\n\t\t\tfor(int j = 0; j < 20; j++) used[i][j] = 0;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> cell[i][j];\n\t\t\t\tif(cell[i][j] == '@'){\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t\tused[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint px = p.second+dx[i],py = p.first+dy[i];\n\t\t\t\tif(0<=px&&px<w&&0<=py&&py<h&&cell[py][px]=='.'&&used[py][px]==false){\n\t\t\t\t\tused[py][px] = true;\n\t\t\t\t\tque.push(P(py,px));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(used[i][j]) ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint search(int y, int x, int h, int w, char** field) {\n    field[y][x] = '0';\n    int res = 1, ny[] = {y - 1, y, y, y + 1, }, nx[] = {x, x - 1, x + 1, x, };\n    for (int i = 0; i < 4; i++) {\n        if (0 <= ny[i] && ny[i] < h && 0 <= nx[i] && nx[i] < w && field[ny[i]][nx[i]] == '.') {\n            res += search(ny[i], nx[i], h, w, field);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n        if ((w | h) == 0) {\n            break;\n        }\n        char** field = new char* [h];\n        for (int i = 0; i < h; i++) {\n            field[i] = new char [w + 1];\n        }\n        for (int i = 0; i < h; i++) {\n            cin >> field[i];\n        }\n        int output;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (field[y][x] == '@') {\n                    output = search(y, x, h, w, field);\n                }\n            }\n        }\n        cout << output << endl;\n        for (int i = 0; i < h; i++) {\n            delete[] field[i];\n        }\n        delete[] field;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nchar map[21][21];\nint w, h;\nint tile = 0;\n\nvoid dfs(int x, int y){\n    if (!(0 <= x && x < w && 0 <= y < h)) return;\n    tile++;\n    map[y][x] = '#';\n    if (map[y-1][x] == '.') dfs(x, y-1);\n    if (map[y+1][x] == '.') dfs(x, y+1);\n    if (map[y][x-1] == '.') dfs(x-1, y);\n    if (map[y][x+1] == '.') dfs(x+1, y);\n}\n\nint main(){\n    int sx, sy;\n    while (cin >> w >> h, w || h){\n\tmemset(map, '#', sizeof(map));\n\ttile = 0;\n\tfor (int i = 0; i < h; i++){\n\t    cin >> map[i];\n\t    for (int p = 0; p < w; p++){\n\t\tif (map[i][p] == '@'){\n\t\t    sx = p;\n\t\t    sy = i;\n\t\t}\n\t    }\n\t}\n\n\tdfs(sx, sy);\n\n\tcout << tile << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\n\n\nint main() {\n\tint W,H;\n\tint q[20][20];\n\tchar p[20][20];\n\tqueue<pair<int,int> > M;\n\tpair<int,int> X;\n\twhile(cin >> W >> H){\n\t\t\n\t\tif (W == 0) return 0;\n\t\tint count = 0;\n\t\tfor (int i = 1; i <= H; i++){\n\t\t\tfor (int j = 1; j <= W; j++){\n\t\t\t\tcin >> p[i][j];\n\t\t\t\tif (p[i][j] == '@'){\n\t\t\t\t\tM.push(make_pair(i,j));\n\t\t\t\t\tcount = 1;\n\t\t\t\t\tq[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!M.empty()){\n\t\t\tW = M.front().first;\n\t\t\tH = M.front().second;\n\t\t\tM.pop();\n\t\t\tfor (int i = 0; i <= 3; i++){\t\t\n\t\t\t\tif (p[W+dx[i]][H+dy[i]] == '.' && q[W+dx[i]][H+dy[i]] == 0){\n\t\t\t\t\tM.push(make_pair(W + dx[i], H + dy[i]));\n\t\t\t\t\tq[W + dx[i]][H + dy[i]] = 1;\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint W, H;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nint dfs(vector<string>& room, int x, int y){\n    room[x][y] = '#';\n    int res = 1;\n    rep(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(!inrect(nx, ny) || room[nx][ny] == '#')continue;\n        res += dfs(room, nx, ny);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> W >> H, W|H){\n        vector<string> room(H);\n        int sx = -1, sy = -1;\n        rep(i, H){\n            cin >> room[i];\n            rep(j, W)if(room[i][j] == '@')sx = i, sy = j;\n        }\n        cout << dfs(room, sx, sy) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <cstring>\n\n#define rep(i, j) for(int i = 0; i < j; i++)\n// sp_rep\n#define sp_rep(i, j) for(int i = 1; i <= j; i++)\n#define all(i) i.begin(), i.end()\n#define ll long long\n\nusing namespace std;\n\nstring Num2Str(int num)\n{\n\tstringstream ss;\n\tss << num;\n\treturn ss.str();\n}\n\nint w, h, cnt;\nchar maze[20][20];\nbool reached[20][20];\n\nvoid serch(int x, int y) {\n\tif (x < 0 || w <= x || y < 0 || h <= y || maze[y][x] == '#') return;\n\tif (reached[y][x])return;\n\treached[y][x] = true;\n\tcnt++;\n\n\tserch(x + 1, y);\n\tserch(x - 1, y);\n\tserch(x, y + 1);\n\tserch(x, y - 1);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\t// code\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0)break;\n\t\tcnt = 0;\n\t\tmemset(reached, false, sizeof(reached));\n\t\tint sx, sy;\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> maze[y][x];\n\t\t\t\tif (maze[y][x] == '@') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tserch(sx, sy);\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint w,h;\nint sum;\nvector<string> tile(20);\n\nvoid search(int x,int y);\n\nint main(){\n\n  int now_x,now_y;\n  \n  while(1){\n\n\tsum=0;\n\tcin>>w>>h;\n\n\tif(w==0 && h==0)\n\t  break;\n\n\ttile.clear();\n\n\tfor(int i=0;i<h;++i)\n\t  cin>>tile[i];\n\t\t\n\tfor(int i=0;i<h;++i){\n\t  for(int j=0;j<w;++j){\n\t\tif(tile[i][j]=='@'){\n\t\t  now_x=j;\n\t\t  now_y=i;\n\t\t  break;\n\t\t}\n\t  }\n\t}\n\t\n\tsearch(now_x,now_y);\n\tcout<<sum<<endl;\n\t\n  }\n\n  return 0;\n  \n}\n  \nvoid search(int x,int y){\n\n  int i;\n  tile[y][x]='#';\n  sum++;\n  \n  if(x+1 < w){\n\tif(tile[y][x+1]=='.')\n\t  search(x+1,y);\n  }\n  \n  if(x-1 >= 0){\n\tif(tile[y][x-1]=='.')\n\t  search(x-1,y);\n  }\n  \n  if(y+1 < h){\n\tif(tile[y+1][x]=='.')\n\t  search(x,y+1);\n  }\n  \n  if(y-1 >= 0){\n\tif(tile[y-1][x]=='.')\n\t  search(x,y-1);\n  }\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint width, height;\nint ans = 0;\nchar map[20][20];\nint checked[20][20];\n\nvoid search(int x, int y);\nint main(){\n\twhile (1) {\n\t\tans = 0;\n\t\tfor (int y=0; y<20; y++) {\n\t\t\tfor (int x=0; x<20; x++) {\n\t\t\t\tmap[y][x] = '#';\n\t\t\t\tchecked[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> width >> height;\n\t\tif (width==0 && height==0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint startX, startY;\n\t\tfor (int y=0; y<height; ++y) {\n\t\t\tfor (int x=0; x<width; ++x) {\n\t\t\t\tcin >> map[y][x];\n\t\t\t\tif (map[y][x] == '@') {\n\t\t\t\t\tmap[y][x] = '.';\n\t\t\t\t\tstartX = x;\n\t\t\t\t\tstartY = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsearch(startX, startY);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\nvoid search(int x, int y) {\n\tans++;\n\tstatic const int diffX[] = {0,-1,1,0};\n\tstatic const int diffY[] = {-1,0,0,1};\n\tchecked[y][x] = 1;\n\tfor (int ite=0; ite<4; ++ite) {\n\t\tint nowX = x + diffX[ite];\n\t\tint nowY = y + diffY[ite];\n\t\tif (nowX < 0 || nowX >= 20 || nowY < 0 || nowY >= 20) continue;\n\t\tif (checked[nowY][nowX] == 0 && map[nowY][nowX] == '.') {\n\t\t\tsearch(nowX, nowY);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <ctime>\n#define INF 999999999\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=(n);i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define MOD(x) (x%(mod))\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n/*---------------------------------------------------*/\n\nchar maze[22][22];\nint sx,sy;\n\nvoid make_maze(int w,int h){\n  rep(i,22)rep(j,22)maze[i][j]='#';\n  rep(i,h)rep(j,w){\n    cin>>maze[i][j];\n    if(maze[i][j]=='@'){sy=i;sx=j;}\n  }\n  //rep(i,22){rep(j,22)cout<<maze[i][j];cout<<endl;}\n}\n\nvoid solve(int w,int h){\n  queue<int> que;\n  int cnt=0;\n  que.push(sx);que.push(sy);\n  while(que.size()){\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    rep(i,4){\n      if(maze[y+dy[i]][x+dx[i]]=='.'&&0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h){\n\tcnt++;\n\tque.push(x+dx[i]);que.push(y+dy[i]);\n\tmaze[y+dy[i]][x+dx[i]]='#';\n      }\n    }\n  }\n  cout<<cnt+1<<endl;\n}\n\nint main(){\n  int w,h;\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    make_maze(w,h);\n    solve(w,h);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w,h;\nint mcnt=0;\nchar maps[22][22];\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nvoid bfs(int y,int x,int nowcnt){\n  mcnt++;\n  maps[y][x]='#';\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if(ny>=0 && ny<h && nx>=0 && nx<w && maps[ny][nx]!='#' ){\n      bfs(ny,nx,nowcnt);\n      //    maps[ny][nx]='.';\n    }\n  }\n  return;\n}\nint main(){\n  int sy,sx;\n  while(1){\n    mcnt=0;\n    cin>>w>>h;\n    if(!(w || h ))break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>maps[i][j];\n\tif(maps[i][j]=='@'){\n\t  sy=i;\n\tsx=j;\n\t}\n      }\n    }\n    bfs(sy,sx,0);\n    cout<<mcnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//AOJ volume11 1130\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n//20170605\n//640009E\n//Yang Bo\n//\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint w, h;\nint starty, startx;\nvector< vector<char> > a(20, vector<char>(20, 'a')); //??£??\\??????\n\nint recursion(char iny, char inx)\n{\n  a[iny][inx] = '#';\n  int number = 0;\n  if (inx < w - 1)\n    if (a[iny][inx + 1] == '.')\n      number += recursion(iny, inx + 1);\n  if (iny < h - 1)\n    if (a[iny + 1][inx] == '.')\n      number += recursion(iny + 1, inx);\n  if (inx > 0)\n    if (a[iny][inx - 1] == '.')\n      number += recursion(iny, inx - 1);\n  if (iny > 0)\n    if (a[iny - 1][inx] == '.')\n      number += recursion(iny - 1, inx);\n  number += 1;\n  return number;\n  //cout << \" recursion(\" << iny << \", \"<< inx << \") = \" << number << endl; \n}\n\nint main()\n{\n  while (cin >> w >> h) {\n    if (w == 0)\n      break;\n    else {\n      for (int i = 0; i < h; i++) {\n\tfor (int j = 0; j < w; j++) {\n\t  cin >> a[i][j]; //??\\???\n\t  if (a[i][j] == '@') {\n\t    starty = i;\n\t    startx = j;\n\t    //cout << \"i = \" << i << \", j = \" << j << endl;\n\t  }\n\t}\n      }\n      int ans = recursion(starty, startx);\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint cnt;\nint w, h;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nchar tile[20][20];\n\nvoid dfs(int x, int y);\n\nint main()\n{\n\tint x, y;\n\n\twhile (true){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif (w == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", tile[i]);\n\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt = 0;\n\t\tdfs(x, y);\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\n\treturn (0);\n}\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '#';\n\tcnt++;\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && tile[ny][nx] == '.'){\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n\nusing namespace std;\nvector<int> ans;\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w + h == 0) break;\n\t\tint cf[20][20];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcf[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tbool field[20][20];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tfield[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tint px,py;\n\t\tmap<int,int> ch;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tchar t;\n\t\t\t\tcin >> t;\n\t\t\t\tif(t == '.') field[i][j] = true;\n\t\t\t\telse if(t == '@'){ px = j; py = i;field[i][j] = true;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint counta = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j]){\n\t\t\t\t\tbool ue = (i != 0 && cf[i-1][j] != -1);\n\t\t\t\t\tbool yoko = (j != 0 && cf[i][j-1] != -1);\n\t\t\t\t\tif(ue)cf[i][j] = cf[i-1][j];\n\t\t\t\t\telse if(yoko) cf[i][j] = cf[i][j-1];\n\t\t\t\t\telse{cf[i][j] = counta;counta++;}\n\t\t\t\t\tif(ue && yoko){\n\t\t\t\t\t\tif(cf[i-1][j] != cf[i][j-1]){\n\t\t\t\t\t\t\tif(cf[i-1][j] < cf[i][j-1]) ch[cf[i][j-1]] = cf[i-1][j];\n\t\t\t\t\t\t\telse ch[cf[i-1][j]] = cf[i][j-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(cf[i][j] != -1){\n\t\t\t\t\tmap<int,int>::iterator itr;\n\t\t\t\t\twhile((itr = ch.find(cf[i][j])) != ch.end()){\n\t\t\t\t\t\tcf[i][j] = ch[cf[i][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint pn = cf[py][px];\n\t\tint count = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(cf[i][j] == pn) count++;\n\t\t\t}\n\t\t}\n\t\tans.push_back(count);\n\t}\n\tfor(int i = 0;i < ans.size();i++) cout << ans[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\nint main(){\n    int W,H,x0,y0;\n    char t[20][20];\n    bool visit[20][20];\n    const int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n    typedef pair<int,int>P;\n    queue<P>Q;\n    while(cin>>W>>H){\n        if(W==0||H==0)break;\n        for(int i=0;i<H;++i){\n            for(int j=0;j<W;++j){\n                cin>>t[i][j];\n                if(t[i][j]=='@'){\n                    x0=j;\n                    y0=i;\n                }\n                visit[i][j]=true;\n            }\n        }\n        int sum=0;\n        Q.push(P(x0,y0));\n        visit[y0][x0]=false;\n        while(!Q.empty()){\n            int srcx=Q.front().first;\n            int srcy=Q.front().second;\n            Q.pop();\n            sum++;\n            for(int i=0;i<4;++i){\n                int curx=srcx+dx[i];\n                int cury=srcy+dy[i];\n                if(t[cury][curx]=='#') continue;\n                if(curx<0||curx>=W||cury<0||cury>=H) continue;\n                if(!visit[cury][curx]) continue;\n                visit[cury][curx]=false;\n                Q.push(P(curx,cury));\n            }\n            \n        }\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n//#include <pair>\n#include <tuple>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1,  0, -1, 0};\n\nint main(){\n\tint h, w;\n\twhile(cin >> w >> h,h||w){\n\t\tvector<vector<char>> m(h, vector<char>(w));\n\t\tqueue<pair<int, int>> q;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tif(m[i][j] == '@') q.emplace(i,j);\n\t\t\t}\n\t\t}\n\n\t\tbool u[20][20] = {};\n\t\twhile(not q.empty()){\n\t\t\tint y, x;\n\t\t\ttie(y, x) = q.front(); q.pop();\n\t\t\tif(u[y][x]) continue;\n\t\t\tu[y][x] = true;\n\t\t\trep(d,4){\n\t\t\t\tint ny = y + dy[d];\n\t\t\t\tint nx = x + dx[d];\n\t\t\t\tif(ny < 0 or ny >= h or nx < 0 or nx >= w) continue;\n\t\t\t\tif(m[ny][nx] == '#') continue;\n\t\t\t\tq.emplace(ny,nx);\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tcnt += u[i][j] == true;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<string> s(h);\n        for(int i=0;i<h;i++)\n            cin>>s[i];\n        int x,y;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                if(s[i][j]=='@')\n                    x=j,y=i;\n        vector<vector<int>> able(h,vector<int>(w,0));\n        able[y][x]=1;\n        for(int k=0;k<w*h;k++)\n            for(int i=0;i<h;i++)\n                for(int j=0;j<w;j++)\n                    if(able[i][j]){\n                        for(int r=0;r<4;r++)\n                            if(0<=i+dy[r] && i+dy[r]<h && 0<=j+dx[r] && j+dx[r]<w && s[i+dy[r]][j+dx[r]]!='#')\n                            able[i+dy[r]][j+dx[r]]=1;\n\n\n\n                    }\n        int res=0;\n        for(int i=0;i<h;i++)\n            for(int j=0;j<w;j++)\n                res+=able[i][j];\n        cout<<res<<endl;\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint w, h;\nchar a[20][20];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint cnt;\n\nvoid dfs(int x, int y) {\n\ta[x][y] = 0;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&a[nx][ny] == '.') {\n\t\t\tcnt++; dfs(nx, ny);\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tcnt = 1;\n\t\trep(i, h)scanf(\"%s\", a[i]);\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (a[i][j] == '@') {\n\t\t\t\tdfs(i, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w , h ,c;\nchar t[26][26];\nint dx[] = {1 , -1 , 0 ,0};\nint dy[] = {0 , 0 ,1 , -1};\nbool input(){\n//\tcout <<'a';\n \tcin >> h >>w;\n \tif(w == 0)return false;\n \t//cout << 'a';\n \tfor(int i = 0;i < 25;i++){\n\t\tfor(int j = 0 ;j < 25 ; j++){\n\t\t\tt[i][j] = 0;\n\t\t}\n\t}\n//\tcout << 'a';\n\tfor(int i = 0;i < w ;i++){\n\t\tfor(int j = 0;j < h ;j++){\n\t\t\tcin >> t[i][j];\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nvoid dfs(int  x,int y){\n\tt[x][y] = '&';\n\tfor (int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(0 <= nx && nx <= w && 0 <= ny && ny <= h && t[nx][ny] == '.')dfs(nx , ny);\n\t}\n\treturn;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < w;i++){\n\t\tfor(int j = 0;j < h;j++){\n\t\t\tif(t[i][j] == '@'){\n\t\t\t\tdfs(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i < w;i++){\n\t\tfor(int j = 0;j < h;j++){\n//\t\t\tcout << t[i][j];\n\t\t\tif(t[i][j] == '&'){\n\t\t\t\t\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n//\t\tcout << endl;\n\t}\n\n\tcout << ans << endl;\n\treturn;\n}\n\nint main(){\n\twhile(input()){\n\t\tsolve();\n\t}\n\n}\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<bool> VB;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\nVVI arr;\nvector<VB> used;\nlong H,W;\nvoid dfs(int x,int y) {\n\tif (!INARR(H,W,x,y)) return;\n\tif (used[y][x] || !arr[y][x]) return;\n\telse {\n\t\tused[y][x] = true;\n\t\tREP(i,4) dfs(x+dx[i],y+dy[i]);\n\t}\n}\nint main(void) {\n\twhile (1) {\n\tcin >> W >> H;\n\tif (W == 0 && H == 0) break;\n\tarr = VVI(H,VI(W));\n\tused = vector<VB>(H,VB(W,false));\n\tchar s;\n\tint x,y;\n\tREP(i,H) {\n\t\tREP(j,W) {\n\t\t\tcin >> s;\n\t\t\tif (s == '#') arr[i][j] = 0;\n\t\t\telse arr[i][j] = 1;\n\t\t\tif (s == '@') {\n\t\t\t\tx = j;y = i;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(x,y);\n\tlong cnt = 0;\n\tREP(i,H) REP(j,W) if (used[i][j]) cnt++;\n\tcout << (cnt) << endl;\n\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[4]={1, -1, 0, 0};\nint dy[4]={0, 0, 1, -1};\n\nint dfs(int x, int y, vector<vector<bool> >& map){\n    map[y][x] = false;\n    int num=1;\n    for(int i=0; i<4; i++){\n        if(map[y+dy[i]][x+dx[i]]){\n            num+= dfs(x+dx[i], y+dy[i], map);\n        }\n    }\n    return num;\n}\n\nint main(){\n    while(1){\n        int W,H;\n        cin >> W >> H;\n        if(W==0) break;\n\n        vector<vector<bool> > map(H+2, vector<bool>(W+2,false));\n        int sx,sy;\n        for(int y=1; y<=H; y++){\n            for(int x=1; x<=W; x++){\n                char tmp;\n                cin >> tmp;\n                if(tmp == '#'){\n                    map[y][x]=false;\n                }else{\n                    map[y][x]=true;\n                }\n                if(tmp == '@'){\n                    sx = x;\n                    sy = y;\n                }\n            }\n        }\n\n        cout << dfs(sx,sy,map) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nint main(){\n\tint w, h;\n\tstring s;\n\tint i, j;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\t\tchar tile[22][22]; int used[22][22];\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\ttile[i][0] = '#';\n\t\t\ttile[i][h + 1] = '#';\n\t\t}\n\t\tfor (j = 0; j < 22; j++) {\n\t\t\ttile[0][j] = '#';\n\t\t\ttile[h + 1][j] = '#';\n\t\t}\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tvector<int> q1,q2;\n\t\tfor (j = 1; j <= h; j++) {\n\t\t\tcin >> s;\n\t\t\tfor (i = 1; i <= w; i++) {\n\t\t\t\ttile[i][j] = s[i - 1];\n\t\t\t\tif (s[i - 1] == '@') {\n\t\t\t\t\tq1.push_back(i); q2.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q1.empty()) {\n\t\t\tint x = q1[0]; int y = q2[0]; used[x][y]=1;\n\t\t\tq1.erase(q1.begin() + 0); q2.erase(q2.begin() + 0);\n\t\t\tif (used[x - 1][y] == 0 && tile[x - 1][y]=='.') {\n\t\t\t\tq1.push_back(x - 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x + 1][y] == 0 && tile[x + 1][y] == '.') {\n\t\t\t\tq1.push_back(x + 1); q2.push_back(y);\n\t\t\t}\n\t\t\tif (used[x][y-1] == 0 && tile[x][y-1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y-1);\n\t\t\t}\n\t\t\tif (used[x][y+1] == 0 && tile[x][y+1] == '.') {\n\t\t\t\tq1.push_back(x); q2.push_back(y+1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (i = 0; i < 22; i++) {\n\t\t\tfor (j = 0; j < 22; j++) {\n\t\t\t\tif (used[i][j] == 1)count++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct locate{\n  int x;\n  int y;\n};\n \nchar graph[20][20];\nint cou = 0;\nint H,W;\n\nvoid bfs(locate z){\n  queue<locate> Q;\n  locate u;\n  locate v;\n  Q.push(z);\n \n\n  while(!Q.empty()){\n\n    u = Q.front();Q.pop();\n\n    if(graph[u.y + 1][u.x] == '.' && graph[u.y + 1][u.x] != 'N'){\n      graph[u.y + 1][u.x] = 'N';\n      cou++;\n      v.y = u.y + 1;\n      v.x = u.x;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x + 1] == '.' && graph[u.y][u.x + 1] != 'N'){\n      graph[u.y][u.x + 1] = 'N';\n      cou++;\n      v.x  = u.x + 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n\n    if(graph[u.y - 1][u.x] == '.' && graph[u.y - 1][u.x] != 'N'){\n      graph[u.y - 1][u.x] = 'N';\n      cou++;\n      v.x = u.x;\n      v.y = u.y - 1;\n      Q.push(v);\n    }\n\n    if(graph[u.y][u.x - 1] == '.' && graph[u.y][u.x - 1] != 'N'){\n      graph[u.y][u.x - 1] = 'N';\n      cou++;\n      v.x = u.x - 1;\n      v.y = u.y;\n      Q.push(v);\n    }\n    \n  }\n  /*  cout << endl;\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcout << graph[i][j];\n      }\n      cout << endl;\n      }*/\n}\n\nint main(){\n\n  int a1,a2;\n  locate a;\n  while(1){\n\n    cin >> W >> H;\n\n    if(W == 0 && H == 0) break; \n\n\n    for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n\tcin >> graph[i][j];\n\tif(graph[i][j] == '@'){\n\t  a1 = i;\n\t  a2 = j;\n\t}\n      }\n    }\n\n    /*\n      for(int i = 0; i< H ;i++){\n      for(int j = 0; j < W; j++){\n      cout << graph[i][j];\n      }\n      cout << endl;\n      }\n    */\n\n    a.y = a1;\n    a.x = a2;\n    bfs(a);\n\n    cout << cou+1 << endl;\n\n    cou = 0;\n    for(int i = 0;i < H ;i++){\n      for(int j = 0;j < W; j++){\n\tgraph[i][j] = 'N';\n      }\n    }\n    cou = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\nusing namespace std;\n#ifndef FAST_IO\n #define IOS ios_base::sync_with_stdio(false);cin.tie(nullptr);\n#endif\n\n#define int long long\n#define FILE_IO freopen(\"input.txt\",\"r\",stdin)/#define int long long\n#define f first\n#define s second\n#define endl '\\n'\n#define all(c) c.begin(),c.end()\n#define bp __builtin_popcount\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e18;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate <typename T>void print(T t){for (auto &it : t) cout << it << \" \";}\ninline int powerexp(int a, int b, int m = MOD){ int res = 1;while(b){if(b&1)res = res * a % m;a = a * a % m,b >>= 1;}return res % m;}\ninline int modinv(int a){ return powerexp(a,MOD-2,MOD);}\ninline int lcm(int a, int b){ int g = __gcd(a,b);return a/g*b;}\ninline int add(int x, int y){ x += y; if (x >= MOD) x -=  MOD; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % MOD;}\ninline int sub(int x, int y){ x -= y; if (x<0) x += MOD; return x ;}\n\n//-------------------< start here >-------------------------// \n\nconst int N = 20;\nint g[N][N];\nbool visited[N][N];\nint w, h,x ,y, cnt;\n\nint dx[] = {1, 0, 0, -1};\nint dy[] = {0, -1, 1, 0};\n\nbool check(int x, int y){\n  return (x >= 0 && y >= 0 && x < w && y < h);\t\n}\n\nvoid dfs(int c, int r){\n\tvisited[c][r] = true;\n\tcnt++;\n\tfor (int i = 0; i < 4; i++){\n\t  int nx = r + dx[i];\n\t  int ny = c + dy[i];\n\t  if (check(nx, ny) && g[ny][nx] == 1 && !visited[ny][nx]){\n\t\t  dfs(ny, nx);  \n\t\t}\n\t}\n}\n\nvoid solve(){\n  while(cin >> w >> h && w > 0 && h > 0){\n\t  cnt = 0;\n\t  memset(visited, false, sizeof visited);\n\t  for (int i = 0; i < h; i++){\n\t\tfor (int j = 0; j < w; j++){\n\t\t  char input;\n\t\t  cin >> input;\n\t\t  if (input == '.') g[i][j] = 1;\n\t\t  else if (input == '#') g[i][j] = 0;\n\t\t  else if (input == '@'){\n\t\t\t   x = i;\n\t\t\t   y = j; \n\t\t\t }\t\n\t\t  }  \n\t  }\n\t  dfs(x, y);\n\t  cout << cnt << endl;  \n\t}\t\n}\n\n//-----------------------------\n//comment from here for TOPCODER \nint32_t main(){\n   IOS;\n   solve();\n   //find();\n   #ifdef LOCAL_DEFINE\n   cerr << \"time elapsed \" << (double)clock()/CLOCKS_PER_SEC << endl;\n   #endif\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\n\n/*************** using variables ***************/\nint h, w;\nchar t[21][21];\n/**********************************************/\n\nvoid dfs(int x, int y){\n    if(t[y][x] != '.' && t[y][x] != '@') return;\n    t[y][x] = '*';\n    if(x+1 < w)  dfs(x+1, y);\n    if(x-1 >= 0) dfs(x-1, y);\n    if(y+1 < h)  dfs(x, y+1);\n    if(y-1 >= 0) dfs(x, y-1);\n    return;\n}\n\nint solve(){\n    int atx = -1, aty = -1;\n    REP(i, h){\n        if(atx != -1 && aty != -1) break;\n        REP(j, w){\n            if(t[i][j] == '@'){\n                aty = i; atx = j;\n                break;\n            }\n        }\n    }\n    dfs(atx, aty);\n    int ans = 0;\n    REP(i, h){\n        REP(j, w){\n            if(t[i][j] == '*') ans++;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> w >> h, h + w){\n        REP(i, h){\n            REP(j, w){\n                cin >> t[i][j];\n            }\n        }\n        cout << solve() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint h, w;\nint sx, sy;\nint ct;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y, vector<vector<char> > &v) {\n  v[x][y] = '#';\n  ++ct;\n  for(int i = 0; i < 4; ++i) {\n    int nx = dx[i] + x;\n    int ny = dy[i] + y;\n    if(nx >= 0 && ny >= 0 && ny < h && nx < w && v[nx][ny] == '.') {\n      dfs(nx, ny, v);\n    }\n  }\n  return;\n}\nint main() {\n  for(;;) {\n    scanf(\"%d %d\", &w, &h);\n    if(w == 0 && h == 0) break;\n    vector<vector<char> > v(w, vector<char>(h));\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        scanf(\" %c\", &v[j][i]);\n      }\n    }\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        if(v[j][i] == '@') {\n          sx = j, sy = i;\n          break;\n        }\n      }\n    }\n    dfs(sx, sy, v);\n    printf(\"%d\\n\", ct);\n    h = 0, w = 0, sx = 0, sy = 0, ct = 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nint main(){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        string screen[30];\n        bool flg[30][30]={{false}};\n\n        complex<int> pos;\n        for(int i = 0;i < h;i++){\n            cin>>screen[i];\n            for(int j = 0;j < w;j++){\n                if(screen[i][j] == '@'){\n                    pos.real() = i;\n                    pos.imag() = j;\n                }\n            }\n        }\n\n        queue< complex < int > > Q;\n        Q.push(pos);\n        while(!Q.empty()){\n            complex<int> D = Q.front();\n            Q.pop();\n            flg[D.real()][D.imag()] = true;\n            for(int i = 0;i < 4;i++){\n                int x = D.real()+dx[i],y = D.imag()+dy[i];\n                if(0<=x&&x<h&&0<=y&&y<w){\n                    if(!flg[x][y]&&screen[x][y] == '.'){\n                        complex<int>E;\n                        E.real() = x;\n                        E.imag() = y;\n                        Q.push(E);\n                    }\n                }\n            }\n        }\n\n        int cnt = 0;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cnt += flg[i][j];\n            }\n        }\n        cout<<cnt<<endl;\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans[50],cnt=0,sx,sy;\nstring m[20],t,s;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i]))\n\t\t\t\ttot+=1;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tcur.first+=dx[i]; cur.second+=dy[i];\n\t\t\t\tq.push(cur);\n\t\t}\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int i=0;i<h;++i){\n\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t\tcout << tot << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint dfs(int x, int y, int acc, vector<vector<bool> > &map)\n{\n    acc=0;\n    if(map[x][y]==false)return 0;\nmap[x][y]=false;\nfor(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n\n    acc+=dfs(nx,ny,acc,map);\n}\nacc++;\nreturn acc;\n}\n/*void dfs(int x,int y,vector<vector<bool> > &map,vector<int> &ans){\n    if(map[x][y]){\n        ans.push_back(x);\n    map[x][y]=false;\nfor(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    dfs(nx,ny,map,ans);\n}\n    }\n}*/\nint main(void)\n{\n    int h, w;\n    while (1)\n    {\n        cin >> h >> w;\n        if (h == 0)\n            break;\n        vector<vector<bool> > map(w + 2, vector<bool>(h + 2, false));\n        char temp;\n        int x, y;\n        for (int i = 1; i <= w; i++)\n        {\n            for (int j = 1; j <= h; j++)\n            {\n                cin>>temp;\n                if(temp!='#')\n                map[i][j]=true;\n                if(temp=='@'){\n                    x=i;\n                    y=j;\n                 }\n            }\n        }\n        cout<<dfs(x,y,0,map)<<endl;\n   /*     vector<int> ans;\ndfs(x,y,map,ans);\ncout<<ans.size()<<endl;*/\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace\tstd;\nint result,w,h;\nint d1[4]={-1,0,1,0},d2[4]={0,1,0,-1};\nstring a[21];\n\nvoid dfs(int x,int y){\n\n  int i;\n\n  result++;\n  a[y][x]='#';\n  for(i=0;i<4;i++) if(0<=y+d2[i] && y+d2[i]<h && 0<=x+d1[i] && x+d1[i]<w) if(a[y+d2[i]][x+d1[i]] == '.') dfs(x+d1[i],y+d2[i]);\n\n}\n\nint main(){\n\n  int x1,y1,i,j;\n\n  while(cin>>w>>h,w){\n\n    result=0;\n    for(i=0;i<h;i++) cin>>a[i];\n\n    for(i=0;i<h;i++) for(j=0;j<w;j++) if(a[i][j] == '@'){\n          x1=j;\n          y1=i;\n\t}\n\n    dfs(x1,y1);\n\n    cout<<result<<endl;\n\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <climits>\n//#include \"h.h\"\nusing namespace std;\n\n#define ll long long\n#define pint pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mp make_pair\n#define pm(first, second) pb(mp(first, second))\n#define SPACE \" \"\n#define fpf first.first\n#define fps first.second\n#define spf second.first\n#define sps second.second\n\n#define all(X) (X).begin(), (X).end()\n\nint main(){\n\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0)break;\n\t\tvector<string> S(H);\n\t\tqueue<pair<int, int>> Q;\n\t\tfor(int i = 0; i < H; i ++){\n\t\t\tcin >> S[i];\n\t\t\tfor(int j = 0; j < W; j ++){\n\t\t\t\tif(S[i][j] == '@')Q.push(mp(i, j));\n\t\t\t}\n\t\t}\n\t\tpair<int, int> P;\n\t\twhile(!Q.empty()){\n\t\t\tP = Q.front();\n\t\t\tQ.pop();\n\t\t\tS[P.first][P.second] = '@';\n\t\t\tif(P.first > 0 && S[P.first - 1][P.second] == '.')Q.push(mp(P.first - 1, P.second));\n\t\t\tif(P.first < H - 1 && S[P.first + 1][P.second] == '.')Q.push(mp(P.first + 1, P.second));\n\t\t\tif(P.second > 0 && S[P.first][P.second - 1] == '.')Q.push(mp(P.first, P.second - 1));\n\t\t\tif(P.second < W - 1 && S[P.first][P.second + 1] == '.')Q.push(mp(P.first, P.second + 1));\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < H; i ++){\n\t\t\tfor(int j = 0; j < W; j ++){\n\t\t\t\tif(S[i][j] == '@')ans ++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nint w,h;\nint ans=1;\nchar tile[21][21];\n\nvoid saiki(int x,int y){\n\tif(x<0 | x>w | y<0 | y>h)return;\n\ttile[x][y]='#';\n\tif(tile[x-1][y]=='.')ans++,saiki(x-1,y);\n\tif(tile[x+1][y]=='.')ans++,saiki(x+1,y);\n\tif(tile[x][y-1]=='.')ans++,saiki(x,y-1);\n\tif(tile[x][y+1]=='.')ans++,saiki(x,y+1);\n}\n\nint main(void){\n\tint a,b; \n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tans=1;\n\t\tfor(a=0;a<h;a++){\n\t\t\tscanf(\"%s\",tile[a]);\n\t\t}\n\t\tfor(a=0;a<h;a++){\n\t\t\tfor(b=0;b<w;b++){\n\t\t\t\tif(tile[a][b]=='@')saiki(a,b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tile[30][30];\nint W, H;\nint ix, iy;\nint cnt;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nvoid dfs(int x, int y)\n{\n\ttile[y][x] = '#';\n\n\tcnt++;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint X = x + dx[i];\n\t\tint Y = y + dy[i];\n\t\tif (0 <= X&&X < W && 0 <= Y&&Y < H&&tile[Y][X] != '#')\n\t\t{\n\t\t\tdfs(X,Y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> W >> H, W + H != 0)\n\t{\n\t\tfor (int y = 0; y < H; y++)\n\t\t{\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t{\n\t\t\t\tcin >> tile[y][x];\n\n\t\t\t\tif (tile[y][x]=='@')\n\t\t\t\t{\n\t\t\t\t\tix = x;\n\t\t\t\t\tiy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(ix,iy);\n\t\t\n\t\tcout << cnt << endl;\n\n\t\tcnt = 0;\n\t\n\t\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MAX = 20;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint map[MAX][MAX];\nint ans = 1;\n\nvoid dfs(int x, int y)\n{\n\tmap[x][y] = 2;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < MAX&&ny >= 0 && ny < MAX) {\n\t\t\tif (map[nx][ny] == 1) {\n\t\t\t\tans++;\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tans = 1;\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint x, y;\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (str.substr(j, 1) == \".\") {\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if (str.substr(j, 1) == \"@\") {\n\t\t\t\t\tmap[i][j] = 2;\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(x, y);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool map[20][20];\nint w,h;\n\n\nint Search(int x,int y, int sum){\n\n  sum++;\n  map[y][x]=false;\n\n//  cout << \"x,y=\" << x << ',' << y << endl;\n\n  if(x!=w-1){\n    if(map[y][x+1]==true){\n      sum = Search(x+1,y,sum);\n    }\n  }\n  if(x!=0){\n    if(map[y][x-1]==true){\n      sum = Search(x-1,y,sum);\n    }\n  }\n  if(y!=h-1){\n    if(map[y+1][x]==true){\n      sum = Search(x,y+1,sum);\n    }\n  }\n  if(y!=0){\n    if(map[y-1][x]==true){\n      sum = Search(x,y-1,sum);\n    }\n  }\n\n  return sum;\n\n}\n\n\nint main(){\n\n  int x,y;\n  char info;\n\n  while(cin >> w >> h){\n    if(w==0 && h==0){ break; }\n\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n          cin >> info;\n          if(info == '.'){ map[i][j]=true;}\n          else if(info == '#'){ map[i][j]=false;}\n          else{ x=j; y=i; map[i][j]=false;}\n        }\n    }\n\n    cout << Search(x,y,0) << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n//Global\nint x, y;\nconst int MAX_N = 20;\nchar maze[MAX_N][MAX_N];\nconst int INF = 1000000;\nint X, Y;//\"@\"???????????????\nint memo[MAX_N][MAX_N];\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint counter;\n\nvoid bsd(int a, int b) {\n\tmaze[b][a] = '#';\n\tmemo[b][a] = INF;\n\tcounter++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif (memo[ny][nx] == 0 && maze[ny][nx] == '.' && 0 <= nx && nx < x && 0 <= ny && ny < y) {\n\t\t\tbsd(nx, ny);\n\t\t}\n\t}\n\n}\n\n\n\n//solve\n//??±???????????¢?´¢??§\"@\"??¨???????????£?????????\".\"????????°????±???????\nvoid solve()\n{\n\t//memo????????????\n\tfor (int i = 0; i < y; i++) {\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tmemo[i][j] = 0;\n\t\t}\n\t}\n\n\t//\"@\"??¨??£??\\????????????  ??????  INF??§??????  ??????  ????????????????????£?????????????????????\".\"??§??????\n\tcounter = 0;//\"@\"??????\n\tbsd(X, Y);\n\n\n\tcout << counter << endl;\n\n}\n\n\n\n\n\n\n\n//main\nint main()\n{\n\twhile (true) {\n\t\tcin >> x >> y;\n\t\tif (x == 0 && y == 0)break;\n\t\t//\"W\"??¨\".\"??¨\"@\"?????\\???\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == '@') {\n\t\t\t\t\tX = j; Y = i;//@???????????????????¨????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n#define MAX 20\n\nbool map[MAX + 2][MAX + 2];\nbool visited[MAX + 2][MAX + 2];\n\nint vs[] = {0, 1, 0, -1};\n\nint main() {\n\t\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\t\n\t\tif(W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX + 2; i++){\n\t\t\tfor(int j = 0; j < MAX + 2; j++){\n\t\t\t\tmap[i][j] = false;\n\t\t\t\tvisited[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint rx = -1, ry = -1;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\t\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(line[j] != '#'){\n\t\t\t\t\tmap[i + 1][j + 1] = true;\n\t\t\t\t\t\n\t\t\t\t\tif(line[j] == '@'){\n\t\t\t\t\t\trx = j + 1;\n\t\t\t\t\t\try = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pair<int, int> > queue;\n\t\tqueue.push(pair<int, int>(rx, ry));\n\t\tvisited[ry][rx] = true;\n\t\tint count = 0;\n\t\twhile(!queue.empty()){\n\t\t\tpair<int, int> point = queue.front();\n\t\t\tqueue.pop();\n\t\t\tcount++;\n\t\t\t\n\t\t\tconst int x = point.first;\n\t\t\tconst int y = point.second;\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tconst int nx = x + vs[i];\n\t\t\t\tconst int ny = y + vs[(i + 1) % 4];\n\t\t\t\t\n\t\t\t\tif(visited[ny][nx]){ continue; }\n\t\t\t\tif(!map[ny][nx]) { continue; }\n\t\t\t\t\n\t\t\t\tqueue.push(pair<int, int>(nx, ny));\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < H && nx >= 0 && nx < W && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\nint W, H;\nchar X[20][20];\nbool V[20][20];\nint DX[4] = {0, -1, 1, 0};\nint DY[4] = {-1, 0, 0, 1};\n\nint main() {\n  while (cin >> W >> H) {\n    if (W == 0 && H == 0) break;\n    int sx = -1, sy = -1;\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        cin >> X[j][i];\n        V[j][i] = false;\n        if (X[j][i] == '@') sx = j, sy = i;\n      }\n    }\n\n    int c = 0;\n    queue<P> q;\n    q.push(P(sx, sy));\n\n    while (!q.empty()) {\n      int x = q.front().first,\n          y = q.front().second; q.pop();\n      if (V[x][y]) continue;\n      V[x][y] = true;\n      c++;\n\n      for (int k=0; k<4; k++) {\n        int dx = x + DX[k], dy = y + DY[k];\n        if (dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n        if (X[dx][dy] == '.') q.push(P(dx, dy));\n      }\n    }\n    cout << c << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); i++ )\n#define UREP( i, m, n ) for ( unsigned int i = (unsigned int)( m ); i < (unsigned int)( n ); i++ )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define RALL( c ) (c).rbegin(), (c).rend()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tVS board( h );\n\t\tfor ( auto &line : board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\tqueue< PII > que;\n\n\t\tREP( i, 0, h )\n\t\t{\t\t\n\t\t\tif ( 1 <= que.size() )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP( j, 0, w )\n\t\t\t{\n\t\t\t\tif ( board[i][j] == '@' )\n\t\t\t\t{\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\tque.push( MP( i, j ) );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tconst int dir[][2] = {\n\t\t\t0, 1,\n\t\t\t1, 0,\n\t\t\t0, -1,\n\t\t\t-1, 0\n\t\t};\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tPII curr = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ( board[ curr.fst ][ curr.snd ] == '#' )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboard[ curr.fst ][ curr.snd ] = '#';\n\t\t\tres++;\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tPII next = curr;\n\n\t\t\t\tnext.fst += dir[d][0];\n\t\t\t\tnext.snd += dir[d][1];\n\n\t\t\t\tif ( 0 <= next.fst && next.fst < h && 0 <= next.snd && next.snd < w )\n\t\t\t\t{\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {-1, 1, 0, 0};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < H && nx >= 0 && nx < W && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0 ; i < H; i++) {\n         cin >> board[i];\n      }\n\n      for (int i = 0 ; i < H; i++) {\n         for (int j = 0 ; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar maze[21][21];\n#define r(z,x) for(int z=0;z<x;z++)\nint ans,a,b;\nvoid bfs(int x,int y){\n\tint dx[4]={0,-1,0,1},dy[4]={1,0,-1,0};\n\tmaze[x][y]='#',ans++;\n\tr(i,4)if(maze[x+dx[i]][y+dy[i]]=='.')bfs(x+dx[i],y+dy[i]);\n}\nint main(){\n\twhile(cin>>a>>b,a||b){\n\t\tans=0;\n\t\tfill(maze[0],maze[20],'#');\n\t\tr(i,b)r(j,a)cin>>maze[i][j];\n\t\tr(i,b)r(j,a)if(maze[i][j]=='@')bfs(i,j),cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nchar map[21][21];\nint res;\nint w,h;\n\nvoid dfs(int sx, int sy) {\n    if(sx<0 || sx>w-1 || sy<0 || sy>h-1) return;\n    if(map[sy][sx] == '#') return;\n\n    res++;\n    map[sy][sx] = '#';\n\n    dfs(sx+1,sy);\n    dfs(sx,sy+1);\n    dfs(sx-1,sy);\n    dfs(sx,sy-1);\n    return;\n}\n\nint main(void)\n{\n    int px,py;\n\n    while(true)\n    {\n        res = 0;\n        scanf(\"%d%d\", &w, &h);\n        if(!w && !h) break;\n        for(int j=0; j < h; j++)\n            scanf(\"%s\", map[j]);\n\n        for(int j=0; j < h; j++)\n            for(int i=0; i < w; i++)\n                if(map[j][i] == '@')\n                    py = j, px =i;\n        dfs(px, py);\n        printf(\"%d\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<stack>\n\nusing namespace std;\n\nstruct Coord {\n  int row;\n  int col;\n};\n\nint solve (int W, int H);\n  \nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n  return 0;\n}\n\nint solve (int W, int H) {\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  for (int i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (int i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; } \n  for (int i=1; i<=H; i++) {\n    for (int j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  \n  stack<Coord> S;\n  S.push(start);\n  while (!S.empty()) {\n    Coord current = S.top(); S.pop();\n    n++;\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    for (int d=0; d<4; d++) {\n      Coord nc = current;\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col]=='.')\n\t{\n\t  M[nc.row][nc.col] = '*';\n\t  S.push(nc);\n\t}\n    } \n    \n  }\n  return n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar a[21][21];\nint c;\nvoid dfs(int y,int x){\n  c++;\n  a[y][x]=0;\nif(y!=0)\n  if(a[y-1][x]=='.')\n\tdfs(y-1,x);\nif(y!=20)\n  if(a[y+1][x]=='.')\n\tdfs(y+1,x);\nif(x!=0)\n  if(a[y][x-1]=='.'&&x!=0)\n\tdfs(y,x-1);\nif(x!=20)\n  if(a[y][x+1]=='.'&&x!=20)\n\tdfs(y,x+1);\n  return;\n}\nint main(){\n  int w,h,i,j;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++){\n\ta[i][j]=0;\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<=w;j++){\n\tscanf(\"%c\",&a[i][j]);\n      }\n    }\n    c=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(a[i][j]=='@')dfs(i,j);\n      }\n    }\n    printf(\"%d\\n\",c);\n\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\nchar room[21][21];\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> p;\n\n\nint main(){\n\tint x,y;\n\tqueue<p> que;\n\tint w,h;\n\tcin>>w>>h;\n\t\n\tfor(int a=0;a<h;a++){\n\t\tfor(int b=0;b<w;b++){\n\t\t\tcin>>room[a][b];\n\t\t\tif(room[a][b]=='@'){\n\t\t\t\tx=b,y=a;\n\t\t\t\tque.push(p(b,a));\n\t\t\t\troom[a][b]='#';\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tint cnt=1;\n\tint nx,ny;\n\twhile(que.size()){\n\t\tp ap=que.front();\n\t\tque.pop();\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tnx=ap.first+dx[i];\n\t\t\tny=ap.second+dy[i];\n\t\t\tif(0<=nx&&nx<=w&&0<=ny&&ny<=h&&room[ny][nx]!='#'){\n\t\t\t\troom[ny][nx]='#';\n\t\t\t\tque.push(p(nx,ny));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm> \n#include <queue>\n#include <functional>\nusing namespace std;\n\nint w, h;\nint vx[4] = { 1, 0, -1, 0 };\nint vy[4] = { 0, 1, 0, -1 };\nbool used[25][25];\nchar c[25][25];\n\nint dfs(int x, int y){\n    int ret = 1;\n    for (int i = 0; i < 4; i++){\n        int nextx = x + vx[i];\n        int nexty = y + vy[i];\n\n        if (0 < nextx && nextx < w + 1 && 0 < nexty && nexty < h + 1 && c[nextx][nexty] == '.' && !used[nextx][nexty]){\n            used[nextx][nexty] = true;\n            ret += dfs(nextx, nexty);\n        }\n    }\n\n    return ret;\n    \n}\n\nint main(void){\n\n    while (true){\n\n        cin >> w >> h;\n\n        if (w == 0 && h == 0)break;\n\n        for (int i = 0; i <= 20; i++){\n            for (int j = 0; j <= 20; j++){\n                used[i][j] = false;\n            }\n        }\n\n        int sx, sy;\n\n        for (int i = 1; i <= h; i++){\n            for (int j = 1; j <= w; j++){\n                cin >> c[j][i];\n                if (c[j][i] == '@'){\n                    sx = j; sy = i;\n                }\n            }\n        }\n\n        cout << dfs(sx, sy) << endl;\n    }\n \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint cnt;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nchar t[20][20];\n\nvoid fanc(int x,int y){\n\tcnt++;\n\tint ny,nx;\n\tt[y][x]=',';\n\tfor(int i=0;i<4;i++){\n\t\tny=y+dy[i];\n\t\tnx=x+dx[i];\n\t\tif(ny>=0&&nx>=0&&ny<m&&nx<n&&t[ny][nx]=='.'){\n\t\t\tfanc(nx,ny);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(1){\n\t\t\n\t\tcin >> n >> m;\n\t\t\n\t\tif(n==0) break;\n\t\t\n\t\tint nx,ny;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> t[i][j];\n\t\t\t\tif(t[i][j]=='@'){\n\t\t\t\t\tny=i;nx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tfanc(nx,ny);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nint main() {\n\tint W, H;\n\twhile ( cin >> W >> H, W || H ) {\n\t\tint m[20][20], sx, sy;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tm[y][x] = str[x] == '#' ? 0 : 1;\n\t\t\t\tif (str[x] == '@') {\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tqueue<P> Q; Q.push( P(sx, sy) );\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tint y = p.imag(), x = p.real();\n\t\t\tif (y < 0 || y >= H || x < 0 || x >= W) continue;\n\t\t\tif ( m[y][x] == 0 ) continue;\n\t\t\tm[y][x] = 0;\n\t\t\t++ans;\n\t\t\t\n\t\t\tQ.push( P(x+1, y) );\n\t\t\tQ.push( P(x-1, y) );\n\t\t\tQ.push( P(x, y-1) );\n\t\t\tQ.push( P(x, y+1) );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n#define REP(i, b, n) for (int i = (b); i < (n); i++)\n#define rep(i, n) REP(i, 0, n)\n\n#define IS_IN_RANGE(x, w, y, h) ((0 <= x) && (x < w) && (0 <= y) && (y < h))\n\n#define MAX 21\nint w, h;\nchar brd[MAX][MAX];\n\nint sx, sy;\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nint solve(int y, int x)\n{\n\tif (!IS_IN_RANGE(y, h, x, w)) return 0;\n\tif (brd[y][x] == '#') return 0;\n\tbrd[y][x] = '#';\n\tint ans = 1;\n\trep(i, 4)\n\t\tans += solve(y+dy[i], x+dx[i]);\n\treturn ans;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w|h) {\n\t\trep(j, h) rep(i, w) {\n\t\t\tcin >> brd[j][i];\n\t\t\tif (brd[j][i] == '@') {\n\t\t\t\tsy = j, sx = i;\n\t\t\t\tbrd[j][i] = '.';\n\t\t\t}\n\t\t}\n\t\tcout << solve(sy, sx) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,N) for(int i=0;i<(int)(N);i++)\n#define REP(i,N,k) for(int i=k;i<(int)(N);i++)\n\n#define vi vector<int>\n#define pb push_back\n\n#define pii pair<int,int>\n#define fi first\n#define se second\nint main(){\n\n\n//    ifstream in(\"b_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n\n    int w,h;\n    while(cin >> w >> h,w){\n        int sx,sy;\n        string s[30];\n        rep(i,h) cin >> s[i];\n        rep(y,h)rep(x,w) if(s[y][x]=='@') s[y][x]='.',sx=x,sy=y;\n\n        queue<pii> que;\n        que.push(pii(sx,sy));\n        bool u[30][30] = {};\n        u[sy][sx] = true;\n        int cnt = 1;\n        while(!que.empty()){\n            int x,y;\n            tie(x,y) = que.front();\n            que.pop();\n            rep(i,4){\n                const int dx[] = {0,1,0,-1,0};\n                int nx = x + dx[i];\n                int ny = y + dx[i+1];\n                if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n                if(s[ny][nx] == '#') continue;\n                if(u[ny][nx]) continue;\n                u[ny][nx] = true;\n                cnt += 1;\n                que.push(pii(nx,ny));\n            }\n        }\n        cout << cnt << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n08-162015?????????????????°???????????????????????????\npair???\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nint tot=1; //?????£????????????(?????????????????????)\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[100][100]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\ttot+=1;\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n}\n\nint main(){\n\tint x1,y1;\n\twhile((cin>>w>>h)&&(w!=0&&h!=0)){\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n\tcout << tot <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  RedAndBlack.cpp\n//  \n//\n//  Created by ??°????????? on 2015/10/30.\n//\n//\n\n#include <iostream>\nusing namespace std;\n\nint w, h, num = 0, room[20][20];\n\nvoid dfs(int x, int y) {\n    num++;\n    \n    room[y][x] = 0;\n    \n    // ??????????????¢?´¢\n    if (y-1 > -1 && room[y-1][x] == 1) dfs(x, y-1);\n    if (y+1 < h && room[y-1][x] == 1) dfs(x, y+1);\n    if (x-1 > -1 && room[y-1][x] == 1) dfs(x-1, y);\n    if (x+1 < w && room[y-1][x] == 1) dfs(x+1, y);\n\n    return;\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        \n        int manX, manY;\n        \n        for (int i = 0; i < h; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; j++) {\n                if (s[j] == '.') {\n                    room[i][j] = 1;\n                } else if (s[j] == '#') {\n                    room[i][j] = 0;\n                } else if (s[j] == '@') {\n                    room[i][j] = 1;\n                    manX = j;\n                    manY = i;\n                }\n            }\n        }\n        \n        dfs(manX, manY);\n        \n        cout << num << endl;\n        \n        num = 0;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int NUM = 7;\n\nvoid grooping(int y, int x, int w, int h, char** room, unsigned long*** group, unsigned long* next)\n{\n\tif (room[y][x] != '#') {\n\t\tfor (int i = y - 1; i <= y + 1; i++) {\n\t\t\tfor (int j = x - 1; j <= x + 1; j++) {\n\t\t\t\tif (i < 0 || j < 0 || i >= h || j >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((i == y && j != x) || (i != y && j == x)) {\n\t\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\t\tgroup[y][x][k] |= group[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < NUM; i++) {\n\t\t\tif (group[y][x][i] == 0UL && next[i] != 0UL) {\n\t\t\t\tgroup[y][x][i] |= next[i];\n\t\t\t\tnext[i] <<= 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long next[NUM] = { 1UL, 1UL, 1UL, 1UL, 1UL, 1UL, 1UL };\n\t\tchar** room = new char*[h];\n\t\tunsigned long*** group = new unsigned long**[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned long*[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = new unsigned long[NUM];\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tgroup[i][j][k] = 0UL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < 210; k++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tgrooping(i, j, w, h, room, group, next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfor (int k = 0; k < NUM; k++) {\n\t\t\t\t\tif ((group[i][j][k] & group[y][x][k]) != 0UL) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tdelete[] group[i][j];\n\t\t\t}\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef  vector< vector<int> > vector2d;\n\nint main() {\n  \n    int H,W,count=0,kaisuu=0,kosuu,sum,judge;\n    char map[20][20];\n    vector2d nextx,nexty; //nextx[回数][個数]\n    nextx.reserve(1000);\n    nexty.reserve(1000);\n\n  while(1){\n    cin >>W>>H;\n    if (W==0&&H==0)break;\n    \n    //マップの入力\n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cin >> map[cW][cH];\n\t  if (map[cW][cH]=='@'){\n\t    nextx[kaisuu].push_back(cW);\n\t    nexty[kaisuu].push_back(cH);\n\t  }\n\t}\n    }\n    sum = 1;\n    while(1){\n      judge = 0;\n      for(kosuu=0;kosuu<nextx[kaisuu].size();kosuu++){\n\tif (nextx[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の左側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]-1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]-1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]-1!=-1){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]=='.'){  //@の上側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]-1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]-1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nextx[kaisuu][kosuu]+1!=W){\n\t  if(map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]=='.'){  //@の右側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]+1);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]);\n\t    map[ nextx[kaisuu][kosuu]+1 ][ nexty[kaisuu][kosuu] ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n\tif (nexty[kaisuu][kosuu]+1!=H){\n\t  if(map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]=='.'){  //@の下側をチェック\n\t    //もし'@'だったらその座標を保存しそれを@に！\n\t    nextx[kaisuu+1].push_back(nextx[kaisuu][kosuu]);\n\t    nexty[kaisuu+1].push_back(nexty[kaisuu][kosuu]+1);\n\t    map[ nextx[kaisuu][kosuu] ][ nexty[kaisuu][kosuu]+1 ]='@';\n\t    sum++;\n\t    judge++;\n\t  }\n\t}\n      }\n      if (judge==0)break;\n      kaisuu++;\n    }\n    \n    cout << sum <<endl;\n    \n    for(int cH=0;cH<H;cH++){\n\tfor(int cW=0;cW<W;cW++){\n\t  cout << map[cW][cH];\n\t}\n\tcout << endl;\n    }\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int w,h;\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n    while(cin>>w>>h,w||h){\n        vector< vector<int> > field(h,vector<int>(w,1));\n        int x,y;\n        for(int i=0;i<h;i++){\n            string s;cin>>s;\n            for(int j=0;j<w;j++){\n                if(s[j]=='.') field[i][j]=0;\n                else if(s[j]=='@'){x=i;y=j;}\n            }\n        }\n        queue<P> q;\n        q.push(P(x,y));\n        int res=0;\n        while(!q.empty()){\n            P p=q.front();q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first+dx[i],ny=p.second+dy[i];\n                if(nx<0||h<=nx||ny<0||w<=ny) continue;\n                if(field[nx][ny]==1) continue;\n                res++;\n                field[nx][ny]=1;\n                q.push(P(nx,ny));\n            }\n        }\n        cout<<res+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> f;\nvoid init(){\n  f.clear();\n}\n\nint input(){\n  int w,h;\n  cin>>w>>h;\n  if(w==0&&h==0)return false;\n  string s;\n  for(int i=0;i<h;i++){\n    cin>>s;\n    f.push_back(s);\n  }\n  return true;\n}\n\nint vx[] = {0,0,1,-1};\nint vy[] = {1,-1,0,0};\n\nint rec(int x,int y){\n  if(x<0||f.size()<=x)return 0;\n  if(y<0||f[x].size()<=y)return 0;\n  if(f[x][y]!='.')return 0;\n  f[x][y]='#';\n  int res = 1;\n  for(int i=0;i<4;i++){\n    res += rec(x+vx[i],y+vy[i]);\n  }\n  return res;\n}\n\nint solve(){\n  int x,y;\n  for(int i=0;i<f.size();i++){\n    for(int j=0;j<f[i].size();j++){\n      if(f[i][j]=='@'){\n        x = i;\n        y = j;\n        f[i][j] = '.';\n      }\n    }\n  }\n  return rec(x,y);\n}\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define REP(i,l,n) for(int i=l;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define MAX 21\nint ans,baseX,baseY;\nint w,h;\nchar tile[MAX][MAX];\nvoid seek(int x,int y);\nusing namespace std;\nint main() {\n  while(1){\n    cin >> w;\n    cin >> h;\n    if(w==0&&h==0) return 0;\n    rep(i,h){\n      rep(j,w){\n        cin >> tile[i][j];\n        if(tile[i][j] == '@'){\n          baseX = i;\n          baseY = j;\n        }\n      }\n      tile[i][w] = '#';\n    }\n    rep(i,w) tile[h][i] = '#';\n    ans = 1;\n    seek(baseX,baseY);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nvoid seek(int x,int y){\n  if(tile[x+1][y] == '.'){\n    tile[x+1][y] = '#';\n    ans++;\n    seek(x+1,y);\n  }\n  if(tile[x][y+1] == '.'){\n    tile[x][y+1] = '#';\n    ans++;\n    seek(x,y+1);\n  }\n  if(tile[x-1][y] == '.'){\n    tile[x-1][y] = '#';\n    ans++;\n    seek(x-1,y);\n  }\n  if(tile[x][y-1] == '.'){\n    tile[x][y-1] = '#';\n    ans++;\n    seek(x,y-1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint W, H;\nint sx, sy;\nchar map[20][20];\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nint cnt = 0;\n\nvoid dfs(int y, int x){\n  map[y][x] = '#';\n  cnt++;\n  for(int i=0; i < 4; i++){\n    if(0 <= y + dy[i] && y + dy[i] < H && 0 <= x + dx[i] && x + dx[i]< W && map[y + dy[i]][x + dx[i]] == '.'){\n      dfs(y + dy[i], x + dx[i]);\n    }\n  }\n}\n\n\n\nint main(void){\n  while(1){\n    std::cin >> W >> H;\n    if(W == 0 && H == 0)  return 0;\n\n    for(int i=0; i < H; i++){\n      for(int j=0; j < W; j++){\n        std::cin >> map[i][j];\n        if(map[i][j] == '@'){\n          sx = j; sy = i;\n        }\n      }\n    }\n\n    cnt = 0;\n    dfs(sy, sx);\n\n    std::cout << cnt << std::endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\tbool dp[20][20];\n\tchar r[20][20];\n\tint w,h;\n\twhile(true){\n\tcin>>w>>h;\n\tif(w==0&&h==0)\n\t\tbreak;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>r[i][j];\n\t\t\tdp[i][j]=false;\n\t\t\tif(r[i][j]=='@')\n\t\t\t\tdp[i][j]=true;\n\t\t}\n\t}\n\tint count=1,cop=1;\n\twhile(true){\n\tcop=count;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tbool t=false;\n\t\t\tif(i<h-1){\n\t\t\tif(dp[i+1][j]==true&&r[i][j]=='.')\n\t\t\t\tt=true;\n\t\t\t}\n\t\t\tif(i>0){\n\t\t\tif(dp[i-1][j]==true&&r[i][j]=='.')\n\t\t\t\tt=true;\n\t\t\t}\n\t\t\tif(j<w-1){\n\t\t\tif(dp[i][j+1]==true&&r[i][j]=='.')\n\t\t\t\tt=true;\n\t\t\t}\n\t\t\tif(j>0){\n\t\t\tif(dp[i][j-1]==true&&r[i][j]=='.')\n\t\t\t\tt=true;\n\t\t\t}\n\t\t\tif(t==true&&dp[i][j]==false){\n\t\t\t\tcount++;\n\t\t\t\tdp[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tif(cop==count)\n\t\tbreak;\n\t}\n\tcout<<count<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint m,n,ans;\nchar ice[22][22];\n\nvoid saiki(int w,int h){\n\tice[w+1][h+1]='*';\n\t\n\tif(ice[w+2][h+1]=='.')saiki(w+1,h);\n\tif(ice[w+1][h+2]=='.')saiki(w,h+1);\n\tif(ice[w][h+1]=='.')saiki(w-1,h);\n\tif(ice[w+1][h]=='.')saiki(w,h-1);\n}\n\nint main(void){\n\n\tfor(;;){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(!m||!n)break;\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",&ice[i+1]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i+1][j+1]=='@')saiki(i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(ice[i+1][j]=='*')ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint standpanel;\nchar tile[31][31];\n\nvoid check(int i,int j)\n{\n\tif(tile[i][j]=='.')\n\t{\n\t\ttile[i][j]='#';\n\t\tstandpanel++;\n\t\tcheck(i-1,j);\n\t\tcheck(i,j-1);\n\t\tcheck(i+1,j);\n\t\tcheck(i,j+1);\n\t\t\n\t}\n\t\n}\n\n\nint main(){\n\tint W,H;\n\twhile(cin>> H >> W &&W&&H)\n\t{\n\t\tstandpanel = 0;\n\t\tfor(int i=0;i<=25;i++)for(int j=0;j<=25;j++)tile[i][j]='#';\n\t\tint manx,many;\n\t\tfor(int i=1;i<=W;i++)for(int j=1;j<=H;j++)\n\t\t{\n\t\t\tcin >> tile[i][j];\n\t\t\tif(tile[i][j]=='@'){manx = i;many = j;tile[i][j]='.';}\n\t\t\t\n\t\t}\n\t\tcheck(manx,many);\n\t\tcout << standpanel << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tqueue<pair<int, int> > q;\n\t\tchar map[114][514];\n\t\tbool b[114][514] = {};\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif (map[i][j] == '@')q.push(make_pair(i, j));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\twhile (q.size()) {\n\t\t\tans++;\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\tmap[x][y] = '#';\n\t\t\tb[x][y] = true;\n\t\t\tif (map[x - 1][y] == '.' && !b[x - 1][y]) {\n\t\t\t\tq.push(make_pair(x - 1, y));\n\t\t\t\tb[x - 1][y] = true;\n\t\t\t}\n\t\t\tif (map[x + 1][y] == '.' && !b[x + 1][y]) {\n\t\t\t\tq.push(make_pair(x + 1, y));\n\t\t\t\tb[x + 1][y] = true;\n\t\t\t}\n\t\t\tif (map[x][y - 1] == '.' && !b[x][y - 1]) {\n\t\t\t\tq.push(make_pair(x, y - 1));\n\t\t\t\tb[x][y - 1] = true;\n\t\t\t}\n\t\t\tif (map[x][y + 1] == '.' && !b[x][y + 1]) {\n\t\t\t\tb[x][y + 1] = true;\n\t\t\t\tq.push(make_pair(x, y + 1));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid func(int x,int y);\nint h,w;\nchar a[111][111];\nint dx[4]={0,-1,0,1};\nint dy[4]={-1,0,1,0};\nint nx,ny;\nint cnt=0;\nint main(){\n  int fx,fy;\n  while(1){\n    cin >> w >> h;\n    if(h==0 && w==0)break;\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin >> a[i][j];\n\tif(a[i][j]=='@'){\n\t  fx=i;\n\t  fy=j;\n\t}\n      }\n    }\n    func(fx,fy);\n    cout << cnt << endl;\n    cnt=0;\n  }\n}\n\n\nvoid func(int x,int y){\n  cnt++;\n  a[x][y]='0';\n  for(int i=0;i<4;i++){\n    nx=dx[i]+x;\n    ny=dy[i]+y;\n    if(nx<=h && nx>=1 && ny<=w && ny>=1 && a[nx][ny]!='#' && a[nx][ny]!='0'){\n      func(nx,ny);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#define INF 999999\n#define fst first\n#define snd second\n#define MAX 32\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long ll;\n\nint w,h,d[MAX][MAX],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},sx,sy;\nchar maze[MAX][MAX];\n\t\nvoid bfs(){\n\tint i,j;\n\tqueue<P> que;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++)d[i][j]=0;\n\tque.push(P(sx,sy));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tif(maze[p.fst][p.snd]=='#'||d[p.fst][p.snd])continue;\n\t\td[p.fst][p.snd]=1;\n\t\tfor(i=0;i<4;i++){\n\t\t\tint nx=p.fst+dx[i],ny=p.snd+dy[i];\n\t\t\tif(0<=nx&&nx<h&&0<=ny&&ny<w){\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\t\nint main(){\n\tint i,j,t;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tgetchar();\n\t\tif(w==0&&h==0)break;\n\t\tt=0;\n\t\tfor(i=0;i<MAX;i++)for(j=0;j<MAX;j++)maze[i][j]='\\0';\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&maze[i][j]);\n\t\t\t\tif(maze[i][j]=='@'){\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tbfs();\n\t\tfor(i=0;i<h;i++)for(j=0;j<w;j++)t+=d[i][j];\n\t\tprintf(\"%d\\n\",t);\n\t}\n\treturn 0;\n}\n\n\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector<vector<int>>\n#define vec vector\n#define pq priority_queue\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for (int (i) = (0); (i) < (n); ++(i))\n#define repp(i, m, n) for (int (i) = (m); (i) < (n); ++(i))\n#define debug(x) cerr << #x << \": \" << x << endl;\n#define debug2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = \"<<\"(\"<<x<<\", \"<<y<<\")\"<<endl;\n#define debug3(x, y, z) cerr<<\"(\"<<#x<<\", \"<<#y<<\", \"<<#z<<\") = \"<<\"(\"<<x<<\", \"<<y<<\", \"<<z<<\")\"<<endl;\n#define debugB(x, y) cerr<<#x<<\": \"<<bitset<y>(x) << endl;\n#define line() cerr << \"---------------\" << endl;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\ntemplate<typename T>\nvoid printA(vector<T> &printArray, char between = ' ') {\n   int paSize = printArray.size();\n   for (int i = 0; i < paSize; i++) { cerr << printArray[i] << between;}\n   if (between != '\\n') {cerr << endl;}\n}\n\n// ------------------------------------------------------------------------------------------\n\nint W, H;\nchar B[30][30];\n\nint dfs(int y, int x) {\n   int ret = 1;\n   B[y][x] = '#';\n   rep (i, 4) {\n      int nx = x + dx[i] , ny = y + dy[i];\n      if (nx < 0 || nx >= W || ny < 0 || ny >= H || B[ny][nx] == '#') continue;\n      ret += dfs(ny, nx);\n   }\n   return ret;\n}\n\nvoid solve() {\n   rep (i, H) {\n      cin >> B[i];\n   }\n   rep (i, H) {\n      rep (j, W) {\n         if (B[i][j] == '@') {\n            cout << dfs(i, j) << endl;\n            return;\n         }\n      }\n   }\n}\n\nint main() {\n   while (1) {\n      cin >> W >> H;\n      if (H*W == 0) break;\n      solve();\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint w,h;\nint g[21][21];\nbool visited[21][21];\nint moves[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nint count;\nbool legal(int x, int y)\n{\n  if(visited[x][y]!=true&&0<=x&&x<h&&0<=y&&y<w&&g[x][y]==0)\n    return true;\n  else\n    return false;\n}\n\nvoid dfs(int x,int y)\n{\n  visited[x][y]=true;\n  count++;\n  for(int i=0;i<4;i++)\n  {\n    int newx=x+moves[i][0];\n    int newy=y+moves[i][1];\n    if(legal(newx,newy))\n    {\n      dfs(newx,newy);\n    }\n  }\n}\n\nint main()\n{\n  while(1)\n  {\n    cin>>w>>h;\n    if(w==0&&h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        g[i][j]=-1;\n        visited[i][j]=false;\n      }\n    int psx,psy;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        char s;\n        cin>>s;\n        switch(s)\n        {\n          case '.':\n            g[i][j]=0;break;\n          case '#':\n            g[i][j]=1;break;\n          case '@':\n            g[i][j]=2;psx=i;psy=j;break;\n        }\n      }\n    count=0;\n    dfs(psx,psy);\n/*    int count=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n      {\n        count+=visited[i][j];\n      }\n*/  cout<<count<<endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\nusing namespace std;\nint mod = 1000000007;\n\nchar grid[22][22];\nint ans = 0;\nbool visited[22][22];\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nvoid init(){\n    rep(i, 22) rep(j, 22) {grid[i][j] = '#'; visited[i][j] = false;}\n}\n\nvoid dfs(int px, int py, int sx, int sy){\n    visited[sx][sy] = true;\n    ans++;\n    rep(i, 4){\n        int nx = sx+dx[i];\n        int ny = sy+dy[i];\n        if(grid[nx][ny] == '.' && !visited[nx][ny]){\n            dfs(sx, sy, nx, ny);\n        }\n    }\n}\n\nint main(void){\n    while(true){\n        ans = 0;\n        init();\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n        int sx, sy;\n        rep(i, H){\n            string S; cin >> S;\n            rep(j, W){\n                grid[i+1][j+1] = S[j];\n                if(S[j] == '@'){\n                    sx = i+1;\n                    sy = j+1;\n                }\n            }\n        }\n        dfs(-1, -1, sx, sy);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string>\n#include <iomanip>\n#define GROUND 0\n#define WALL 90000\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid map();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  //  char floor[MAX_W][MAX_H];\n  //int step[MAX_W][MAX_H];\n  \n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    //cout << width << \" \" << height << endl;\n    init();\n    for(int i = 0; i < height; ++i){\n      cin >> line;\n      for(int j=0; j < width ; ++j){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n\t//cout << step[j][i];\n      }\n      //cout << endl;\n    }\n    //cout << count('.') << count('#') << count('@') << endl;\n    for(int k = 0; k < 10; k++){\n      //map();\n      mark_n_all(k);\n      //mark_n(k+1,ix,iy,1,0);\n      //cout << endl;\n      //map();\n      \n      //cout << endl;\n    }\n    cout << count() << endl;\n  }\n  \n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;++i){\n    for(int j=0; j< width; ++j){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid map(){\n  for(int i = 0; i < height; ++i){\n    for(int j=0; j < width ; ++j){\n      cout << setw(5)<< step[j][i] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\t//\tcout << j <<\" \" << i << \"jツづツづ個値\"<< endl;\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\n\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >  width || y < 0 || y > height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint ans;\nchar room[22][22] = { '0' };\n\nvoid judge(int x, int y) {\n\tans++;\n\troom[x][y] = '#';\n\tif (room[x - 1][y] != '#') {\n\t\tjudge(x - 1, y);\n\t}\n\tif (room[x + 1][y] != '#') {\n\t\tjudge(x + 1, y);\n\t}\n\tif (room[x][y - 1] != '#') {\n\t\tjudge(x, y - 1);\n\t}\n\tif (room[x][y + 1] != '#') {\n\t\tjudge(x, y + 1);\n\t}\n\treturn;\n}\n\nint main(void) {\n\twhile (1) {\n\t\tint w, h, human_x, human_y;\n\t\tfor (int i = 0; i <= 22; i++) {\n\t\t\tfor (int j = 0; j <= 22; j++) {\n\t\t\t\troom[j][i] = { '#' };\n\t\t\t}\n\t\t}\n\t\tcin >> w >> h;\n\t\tif (w == 0) return 0;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> room[j][i];\n\t\t\t\tif (room[j][i] == '@') {\n\t\t\t\t\thuman_x = j;\n\t\t\t\t\thuman_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tjudge(human_x, human_y);\n\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<string.h>\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\n\nstring t[21];\n\n\nvoid dfs(int y,int x){\nint dx[4] = {1,-1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\n\n\tif((x<0||y<0)||t[x][y]!='.') return;\n\tt[x][y]='@';\t\n\trep(k,4){\n\tdfs(y+dy[k],x+dx[k]);\n}\nreturn;\n}\n\n\nint main(void){\n\n\tint w,h,sx,sy,cnt;\n\trep(i,20)rep(j,20){\nt[i][j]=='#';\t\n\t}\n\nwhile(true){\nscanf(\"%d %d\",&w,&h);\nif(!w&&!h) {break;}\nrep(i,h){\ncin >> t[i];\n}\nrep(i,h)rep(j,w){\n\n\tif(t[i][j]=='@'){\t\n\tsx =i;\n\tsy =j;\n\nt[i][j]='.';\n\t}\n\n}\ndfs(sy,sx);\ncnt =0;\n\nrep(i,h){ \n\trep(j,w)if(t[i][j]=='@') cnt++;\t\n}\n\ncout <<endl<<cnt;;\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n????????£????????????1h\n??????????????????????????????????????????????????§?????????\n#endif\n\n#include <iostream>\n#include <queue>\n#include <string.h>\n#include <utility>\nusing namespace std;\n\nint w,h;\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1}; //??????????§??????¨\nchar P[30][30]; //??§?¨?????????????????????¨???\n\nbool valid(int x,int y){ //??????????????????\n\treturn (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(P[x][y]!='#');\n}\n\nvoid bfs(int x,int y){ //???????????¢?´¢\n\tint tot=1; //?????£????????????(?????????????????????)\n\tqueue<pair<int,int> > q;\n\tpair<int,int> p;\n\tp = make_pair(x,y); //pair??????????????¨??????????????????\n\tq.push(p);\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front(); //?????¨??°?????????????????????\n\t\tq.pop();\n\t\tfor(int i=0;i<4;++i){\n\t\t\tif(valid(cur.first+dx[i],cur.second+dy[i])){\n\t\t\t\tq.push(make_pair(cur.first+dx[i],cur.second+dy[i]));\n\t\t\t\ttot++;\n\t\t\t\tP[cur.first+dx[i]][cur.second+dy[i]]='#'; //???????????£?????´???????°???????\n\t\t\t}\n\t\t}\n\t\tP[cur.first][cur.second]='#';\n\t}\n\tcout << tot <<endl;\n}\n\nint main(){\n\tint x1,y1;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\t\tfor(int j=0;j<h;++j){\n\t\t\tfor(int i=0;i<w;++i){\n\t\t\t\tcin>>P[i][j];\n\t\t\t\tif(P[i][j]=='@')\n\t\t\t\t\tx1=i; y1=j; \n\t\t\t}\n\t\t}\n\t\tbfs(x1,y1); //??????????????°????????£??\\????????¢?´¢????§?\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define MH 20\n#define MW 20\n\nchar F[MH][MW];\n\nint W, H;\nbool input() {\n    scanf(\"%d %d\", &W, &H);\n    if (W == 0 && H == 0) return false;\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", F[i]);\n    }\n    return true;\n}\n\nint dfs(int y, int x) {\n    static const int dy[] = {0, 1, 0, -1},\n                     dx[] = {1, 0, -1, 0};\n    int count = 1;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i],\n            nx = x + dx[i];\n        if (ny < 0 || ny >= H) continue;\n        if (nx < 0 || nx >= W) continue;\n        if (F[ny][nx] == '.') {\n            F[ny][nx] = '@';\n            count += dfs(ny, nx);\n        }\n    }\n    return count;\n}\n\nvoid solve() {\n    for (int y = 0; y < H; y++) {\n        for (int x = 0; x < W; x++) {\n            if (F[y][x] == '@') {\n                printf(\"%d\\n\", dfs(y, x));\n                return;\n            }\n        }\n    }\n}\n\nint main() {\n    while (input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int MAX_SIZE = 21;\nint w, h;\n\nint dx[] = {-1, 0, 0, 1},\n\tdy[] = {0, 1, -1, 0};\n\nchar field[MAX_SIZE][MAX_SIZE];\n\nbool ok(int x, int y) {\n\treturn (x >= 0 && x < w && y >= 0 && y < h) && field[y][x] == '.';\n}\n\nint solve(int x, int y) {\n\tint ret = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint curx = x + dx[i],\n\t\t\tcury = y + dy[i];\n\n\t\tif (ok(curx, cury)) {\n\t\t\tfield[cury][curx] = '#';\n\t\t\tret += solve(curx, cury) + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\tint x = -1, y = -1;\n\t\tfor (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n\t\t\tcin >> field[i][j];\n\t\t\tif (field[i][j] == '@') {\n\t\t\t\tfield[i][j] = '#';\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(x, y) + 1 << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\nchar S[21][21];\nint count = 0;\n\nvoid a(int i, int j){\n\tif(S[i][j] == '.'){\n\t\tcount++;\n\t\tS[i][j] = '#';\n\t\ta(i - 1, j);\n\t\ta(i + 1, j);\n\t\ta(i, j + 1);\n\t\ta(i, j - 1);\n\t}\n}\n\n\nint main(){\n\twhile(true){\n\t\tmemset(S,'#',sizeof(S));\n\t\tcount = 0;\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif(x == 0 && y == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tcin >> S[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint startx, starty;\n\t\tfor(int i = 0; i < y; i++){\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tif(S[i][j] == '@'){\n\t\t\t\t\tstartx = j;\n\t\t\t\t\tstarty = i;\n\t\t\t\t\tS[i][j] = '.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta(starty, startx);\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\nvoid solve() {\n  while (true) {\n    int w, h; cin >> w >> h;\n    if (w == 0) return;\n    vstr a(h); rep(i, h) cin >> a[i];\n    int sx, sy;\n    rep(i, h) rep(j, w) if (a[i][j] == '@') sx = i, sy = j;\n    int cnt = 0;\n    function<void(int, int)> rec = [&](int x, int y) {\n      cnt++;\n      a[x][y] = '#';\n      rep(i, 4) {\n        int wx = x + (i - 1) % 2;\n        int wy = y + (i - 2) % 2;\n        if (wx < 0 || wx >= h || wy < 0 || wy >= w) continue;\n        if (a[wx][wy] == '#') continue;\n        rec(wx, wy);\n      }\n    };\n    rec(sx, sy);\n    cout << cnt << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n\tint W, H;\n\twhile( cin >> W >> H, W, H ){\n\t\tchar room[20][20];\n\t\tqueue< pair<int, int> > xy;\n\t\tfor( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif( room[i][j] == '@' ){\n\t\t\t\t\txy.push(pair<int, int>(i, j));\n\t\t\t\t\troom[i][j] = '#';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << xy.front().first << ' ' << xy.front().second << endl;\n\t\tint sum = 1;\n\t\twhile( !xy.empty() ){\n\t\t\tfor( int i = 0; i < 4; i++ ){\n\t\t\t\tint x = xy.front().second + dx[i];\n\t\t\t\tint y = xy.front().first + dy[i];\n\t\t\t\t//cout << room[y][x];\n\t\t\t\tif( x < W && y < H && room[y][x] == '.' ){\n\t\t\t\t\troom[y][x] = '*';\n\t\t\t\t\txy.push(pair<int, int>(y, x));\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\txy.pop();\n\t\t}\n\t\t/*for( int i = 0; i < H; i++ ){\n\t\t\tfor( int j = 0; j < W; j++ ){\n\t\t\t\tcout << room[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nchar tile[40][40];\nint h, w;\n\nint search(int nx, int ny)\n{\n\tint sum = 0;\n\tif (ny == 0 || nx == 0 || ny == h + 1 || nx == w + 1)return (sum);\n\tif (tile[nx][ny] == '.' || tile[nx][ny] == '@'){\n\t\tsum++;\n\t}\n\t\n\ttile[nx][ny] = '#';\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tif (tile[nx + dx[i]][ny + dy[i]] != '#'){\n\t\t\tsum += search(nx + dx[i], ny + dy[i]);\n\t\t}\n\t}\n\treturn (sum);\n}\n\t\t\nint main()\n{\n\twhile (1){\n\t\t\n\t\tscanf(\"%d %d\", &w, &h);\n\t\t\n\t\tif (h == 0 && w == 0)return (0);\n\t\tint mx, my;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &tile[j][i]);\n\t\t\t\tif (tile[j][i] == '@'){\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search(mx, my));\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n\n#define BLACK 0\n#define RED 1\n#define MAN 2\n\nint count;\nint tile[20][20];\nint dx[] = {0,0,-1,1};\nint dy[] = {-1,1,0,0};\nint W,H;\nint countdebug;\n\nvoid hukasa(int width,int height);\n\n\nint main(){\n\n\tint height,width;\n\tint i,j;\n\tchar s;\n\n\twhile(scanf(\"%d %d\",&W,&H) && W && H){\n\n\t\tcount = 0;\n\n\n\t\tfor(j=0; j<H; j++){\n\t\t\tscanf(\"%*c\");\n\t\t\tfor(i=0; i<W; i++){\n\n\t\t\t\tscanf(\"%c\",&s);\n\n\t\t\t\tif(s == '.'){\n\t\t\t\t\ttile[i][j] = BLACK;\n\t\t\t\t}\n\t\t\t\telse if(s == '#'){\n\t\t\t\t\ttile[i][j] = RED;\n\t\t\t\t}\n\t\t\t\telse if(s == '@'){\n\t\t\t\t\ttile[i][j] = RED;\n\t\t\t\t\theight = j;\n\t\t\t\t\twidth = i;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\thukasa(width,height);\n\n\t\tprintf(\"%d\\n\",count+1);\n\n\t}\n\treturn 0;\n}\n\n\n\nvoid hukasa(int width,int height){\n\n\tint i;\n\n\n\tfor(i=0;i<4;i++){\n\n\t\tif(!(width + dx[i] < 0 || height + dy[i] < 0 || width + dx[i] > W - 1 || height + dy[i] > H - 1) ){\n\t\t\tif(tile[width + dx[i]][height + dy[i]] == BLACK){\n\t\t\t\ttile[width + dx[i]][height + dy[i]] = RED;\n\t\t\t\tcount++;\n\t\t\t\thukasa(width + dx[i],height + dy[i]);\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint w,h;\nchar m[22][22];\n\nvoid rec(int x,int y) {\n\tif(m[x][y] == '.') {\n\t\tm[x][y] = '!';\n\t\trec(x+1,y);\n\t\trec(x-1,y);\n\t\trec(x,y+1);\n\t\trec(x,y-1);\n\t}\n}\n\nint main() {\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tif(!(w | h)) break;\n\t\tstring s;\n\t\tfor(int i = 0;i < 22;i++)for(int j = 0;j < 22;j++) m[i][j] = '#';\n\t\tfor(int y = 1;y <= h;y++) {\n\t\t\tcin >> s;\n\t\t\tfor(int x = 1;x <= w;x++) {\n\t\t\t\tm[x][y] = s[x-1];\n\t\t\t}\n\t\t}\n\t\tfor(int x = 0;x < 22;x++)for(int y = 0;y < 22;y++) \n\t\t\tif(m[x][y] == '@') {\n\t\t\t\tm[x][y] = '.';\n\t\t\t\trec(x,y);\n\t\t\t}\n\t\tint cnt = 0;\n\t\tfor(int x = 0;x < 22;x++)for(int y = 0;y < 22;y++) \n\t\t\tif(m[x][y] == '!') cnt++;\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for (int i=(n)-1;i>=0;i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define REPS(i,f,n) for (int i=(f)-1;i>=(n);i--)\nint dx[4] = {1, 0, 0, -1};\nint dy[4] = {0, 1, -1, 0};\n\nchar board[21][21];\nint w, h;\nint x, y;// ?????¨?????????\n\nvoid slove(void){\n\tint cnt = 0;\n\tqueue<pint> q;\n\tq.push(make_pair(y, x));//?????¨????????????queue?????\\??????\n\n\twhile(!q.empty()){\n\t\tpint now = q.front(); q.pop();\n\t\trep(i, 4){\n\t\t\tint nowy = now.fi + dy[i];\n\t\t\tint nowx = now.se + dx[i];\n\t\t\tif (0 <= nowy <= h - 1 && 0 <= nowx && nowx <= w - 1){\n\t\t\t\tif (board[nowy][nowx] == '.'){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tboard[nowy][nowx] = 0;\n\t\t\t\t\tq.push(make_pair(nowy, nowx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cnt + 1);//?§?????????´????????\\??????\n\treturn;\n}\n\nvoid scan(int w, int h){\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tcin >> board[i][j];\n\t\t\tif (board[i][j] == '@'){\n\t\t\t\ty = i; x = j;\n\t\t\t}\n\t\t}\n\t\tgetchar();\n\t}\n\t/*\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tprintf(\"%c\", board[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tslove();\n\treturn;\n}\n\nint main(void){\n\trep(i, 1000){\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) break;\n\t\tscan(w, h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <numeric>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i = 0; i<n ; i++)\n#define FOR(i,a,n) for(int i=a; i<n; i++)\n#define REPSTR(i,s) for(int i=0; (s)[i]; i++)\n#define REPITR(i,s) for(auto i=(s).begin(); i!=(s).end();i++)\n\n#define RANGE(a,i,b) ((a)<=(i)&&(i)<=(b))\n\n#define pb push_back\n#define mp make_pair\n\n#define ALL(a) begin(a), end(a)\n\n#define EXIST(s,x) ((s).find(x)!=(s).end())\n\n#define SET(a,c) memset(a,c,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n\n#ifdef _DEBUG\n#define DEBUG(x) cerr<<#x<<\":\"<<x<<endl\n#else\n#define DEBUG(x)\n#endif\n\n#define PRINTJOIN(x,n) rep(i,n){if(i)cout<<\" \";cout<<x[i];}cout<<endl \n#ifdef int\n#define INF 1001001001001001001LL\n#else\n#define INF 1001001001\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef stringstream SS;\n\n#define PQ priority_queue\n\n#define FST first\n#define SEC second\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint h,w;\n\nint dfs (int i, int j, const vector<vector<bool>> & field, vector<vector<bool>> & done) {\n    if(!field[i][j]) {\n        return 0;\n    }\n    if(done[i][j]) {\n        return 0;\n    }\n    int ans=0;\n    done[i][j]=true;\n    rep(k,4){\n        if(dx[k]+i<0||dx[k]+i>=h||dy[k]+j<0||dy[k]+j>=w) continue;\n        ans+=dfs(dx[k]+i, dy[k]+j, field, done);\n    }\n\n    return ans+1;\n}\n\n\nsigned main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n    while(cin>>w>>h,w||h){\n        vector<vector<bool>> field(h,vector<bool>(w,false));\n        vector<vector<bool>> done(h,vector<bool>(w,false));\n        int si, sj;\n        rep(i,h)rep(j,w){\n            char c;\n            cin>>c;\n            field[i][j] = c=='#'?false:true;\n            if(c == '@') {\n                si=i;\n                sj=j;\n            }\n        }\n\n        cout<<dfs(si, sj, field, done)<<endl;\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint W,H;\nint nx[4],ny[4];\nstring M[128];\n\nconst int dx[4] = { 1, 0, -1, 0, } , dy[4] = { 0, 1, 0, -1, };\n\nbool good_cell(int x,int y) {\n  return min(x,y) >= 0 && x<W && y<H;\n}\n\nbool safe_cell(int x, int y) {\n  return good_cell(x,y) && M[y][x] == '.';\n}\n\nvoid neighbor4(int x, int y) {\n  for (int d=0; d<4; ++d) {\n    nx[d] = x + dx[d], ny[d] = y + dy[d];\n  }\n}\n\nvoid walk1() {\n  for (int y=0; y<H; ++y) {\n    for(int x=0; x<W; ++x) {\n      if (M[y][x] == '@') {\n\tneighbor4(x, y);\n\tfor (int i=0; i<4; ++i) {\n\t  if (good_cell(nx[i],ny[i]) == 1)\n\t  if (M[ny[i]][nx[i]] == '.') M[ny[i]][nx[i]] = '@';\n\t}\n      }\n    }\n  }\n}\n\nvoid print_map() {\n  for (int y=0; y<H; ++y) cout << M[y] << endl;\n}\n\nint main() {\n  while (cin >> W >> H && W > 0) {\n    int c=0;\n    for (int i=0; i<H; ++i)\n      cin >> M[i];\n  \n\n\nfor (int y=0; y<H; ++y) {\n  for (int x=0; x<W; ++x) {\n    if (M[y][x] == '@') {\n    }\n  }\n }\n for (int i=0; i<W*H; ++i) walk1();\n //print_map();\n for (int y=0; y<H; ++y) {\n   for(int x=0; x<W; ++x) {\n     if(M[y][x] =='@') {\n       c++;\n     }\n   }\n }\n cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nclass DoubleArray {\n    int X,Y;\n    int *top;\n    public:\n    DoubleArray(int *p,int x,int y);\n    int *operator[](int i);\n    int getx();\n    int gety();\n};\n\nDoubleArray::DoubleArray(int *p,int x,int y){\n    top = p;\n    X = x;\n    Y = y;\n}\n\nint *DoubleArray::operator[](int i){\n    return top + Y*i;\n}\nint DoubleArray::getx(){\n    return X;\n}\nint DoubleArray::gety(){\n    return Y;\n}\n\nint calc(DoubleArray &map){\n    int i,j,a=0;\n    int x = map.getx();\n    int y = map.gety();\n    queue<int> q;\n    for(i=0;i<x;i++){\n        for(j=0;j<y;j++){\n            if(map[i][j]==2){\n                q.push(i);\n                q.push(j);\n                a=1;\n                map[i][j]=0;\n            }\n        }\n    }\n    while(!q.empty()){\n        i=q.front();\n        q.pop();\n        j=q.front();\n        q.pop();\n        if(i>0) if(map[i-1][j]==1){\n            q.push(i-1);\n            q.push(j);\n            a++;\n            map[i-1][j]=0;\n        }\n        if(j>0) if(map[i][j-1]==1){\n            q.push(i);\n            q.push(j-1);\n            a++;\n            map[i][j-1]=0;\n        }\n        if(i<x-1) if(map[i+1][j]==1){\n            q.push(i+1);\n            q.push(j);\n            a++;\n            map[i+1][j]=0;\n        }\n        if(j<y-1) if(map[i][j+1]==1){\n            q.push(i);\n            q.push(j+1);\n            a++;\n            map[i][j+1]=0;\n        }\n    }\n    return a;\n}\n\nint main(){\n    int i,j,x,y,a[10000],b = 0;\n    string s;\n    char c;\n    for(b=0; b<10000; b++){\n        cin >> x;\n        cin >> y;\n        if(x==0&&y==0) break;\n        if(x>20) x=20;\n        if(y>20) y=20;\n        if(x<1||y<1) continue;\n        int m[x][y];\n        DoubleArray map(&m[0][0],x,y);\n        for(j=0;j<y;j++){\n            cin >> s;\n            for(i=0;i<x;i++){\n                c = s[i];\n                if(c=='#') map[i][j]=0;\n                if(c=='.') map[i][j]=1;\n                if(c=='@') map[i][j]=2;\n            }\n        }\n        a[b] = calc(map);\n    }\n    for(i=0;i<b;i++){\n        cout << a[i] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<string> V;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\nint main() {\n\tint w, h, x, y;\n\tcin >> w >> h;\n\tif (w == 0 && h == 0) {\n\t\treturn 0;\n\t}\n\tV map = V(h);\n\tfor (int i = 0; i < h; i++) {\n\t\tcin >> map[i];\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (map[i][j] == '@') {\n\t\t\t\tx = j;\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t}\n\tint n = 0;\n\tQ q;\n\tq.push(P(y, x));\n\twhile (q.size()) {\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif (p.first < 0 || h <= p.first || p.second < 0 || w <= p.second || map[p.first][p.second] == '#') {\n\t\t\tcontinue;\n\t\t}\n\t\t//cout << p.second << \" \" << p.first << \" \" << map[p.first][p.second] <<endl;\n\t\tmap[p.first][p.second] = '#';\n\t\tn++;\n\t\tq.push(P(p.first - 1, p.second));\n\t\tq.push(P(p.first + 1, p.second));\n\t\tq.push(P(p.first, p.second - 1));\n\t\tq.push(P(p.first, p.second + 1));\n\t}\n\tcout << n << endl;\n\treturn main();\n}"
  },
  {
    "language": "C++",
    "code": "//??¨??¢?´¢:??±???????????¢?´¢??????????????¢?´¢ \n\n//??????????????¢?????¬?????????\n \n//?????°??¢??°???????????????(?????????)????????\\???(?????????)\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\t\nint W,H;\nchar c[101][101];\nbool visited[100][100];\n \nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n \t\nvoid compute();//????????????????????£?¨? \n\t\nint main(){\n\t\n\twhile(scanf(\"%d %d\",&W,&H),W |H){\n\t    int i;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\" %s\",&c[i][0]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid compute(){\n\t\n\tmemset(visited,false,sizeof visited);  //{????????????????????????1bit??????????????????1bit????????§?????????} \n\t\n\tqueue<int> que;\n\tint i,j;\n\tfor(j=0;j<W;j++){ \n\t for(i=0;i<H;i++){\n\t  if(c[i][j]=='@'){\n\t  \tque.push(j+i*H);\n\t  \tvisited[i][j]=true;\n\t  \t break;\n\t  }\n\t }\n\t}\n  int answer=1;\n  while(!que.empty()){\n\tint cur=que.front();\n\t        que.pop();\n\t        int x=cur%H;\n\t        int y=cur/H;\n    \n\n  for(i=0;i<4;i++){\n\tint nx=x+dx[i],ny=y+dy[i];\n\t\n  \n  \n  if(!(0<=nx&&nx<W&&0<=ny&&ny<H))continue;\n  if(c[ny][nx]=='#'||visited[ny][nx])continue;\n\n  que.push(nx+ny*H);\n  visited[ny][nx]=true;\n++answer;\n    }\n   }\n cout << answer << endl;\n }"
  },
  {
    "language": "C++",
    "code": "\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility> // pair<int,int> xxxx;  make_pair(first,second);\nusing namespace std;\n\nint W,H;\nint X,Y; // 自分の位置\nchar s[20];\nchar c;\nbool tile[20][20]; // タイルの状態。trueは黒、falseは赤(または壁)。\nbool visited[20][20];\nint answer;\n\n// 右、上、左、下\nconst int dx[4] = { 1, 0, -1, 0 }; \nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool valid (int x, int y) {\n  return 0 <= x && x < H && 0 <= y && y < W && tile[x][y] ;\n}\n\nvoid init() { // 初期化\n  fill(&tile[0][0], &tile[0][0]+20*20, 0);\n  fill(&visited[0][0], &visited[0][0]+20*20, 0);\n  answer = 0;\n}\n\nvoid make_tile() { // タイル読み込み\n  for (int i=0; i<H; i++) {\n    scanf(\"%s\", s);\n    for (int j=0; j<W; j++) {\n      c = s[j];\n      if (c == '.') {\n\ttile[i][j] = true;\n      } else if (c == '#') {\n\ttile[i][j] = false;\n      } else if (c == '@') {\n\ttile[i][j] = true;\n\tX = i;\n\tY = j;\n      }\n    }\n  }\n}\n\nvoid count_tile() {\n  queue<pair<int,int>> Q; // 幅優先探索を使う。特に理由はないが、周辺から徐々に探査する感じになるのでイメージしやすい。\n  pair<int,int> cur = make_pair(X,Y);\n  Q.push(cur);\n  while (!Q.empty()) {\n    cur = Q.front();\n    Q.pop();\n    if (visited[cur.first][cur.second]) {\n      continue;\n    }\n    visited[cur.first][cur.second] = true;\n    answer++;\n    for (int i=0; i<4; i++) {\n      int a = cur.first+dx[i];\n      int b = cur.second+dy[i];\n      if (valid(a, b) && !visited[a][b]) {\n\tQ.push(make_pair(a, b));\n      }\n    }\n  }\n  printf(\"%d\\n\", answer);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &W, &H) && W && H) {\n    init();\n    make_tile();\n    count_tile();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar tyle[30][30]={'0'};\n\nint find_tyle(int i,int j){\n  if(tyle[i+1][j]=='.'){\n    tyle[i+1][j]='a';\n    find_tyle(i+1,j);\n  }\n  if(tyle[i][j+1]=='.'){\n    tyle[i][j+1]='a';\n    find_tyle(i,j+1);\n  }\n  if(tyle[i-1][j]=='.'){\n    tyle[i-1][j]='a';\n    find_tyle(i-1,j);\n  }\n  if(tyle[i][j-1]=='.'){\n    tyle[i][j-1]='a';\n    find_tyle(i,j-1);\n  }\n}\n\nint main(){\n  \n  int w,h;\n  \n  while(cin>>w>>h,w){\n    int ans=0;\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n      cin>>tyle[i][j];\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='@'){\n\t  find_tyle(i,j);\n\t  tyle[i][j]='a';\n\t}\n      }\n    }\n    for(int i=1;i<=h;++i){\n      for(int j=1;j<=w;++j){\n\tif(tyle[i][j]=='a'){\n\t  ans++;\n      }\n    }\n  }\n    cout<<ans<<endl;\n\n   for(int i=0;i<30;++i){\n      for(int j=0;j<=30;++j){\n      tyle[i][j]='0';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nint black_count( vector<vector<char>> &v,int h,int w){\n\tint ret = 0;\n\tv[h][w] = '#';\n\tif(v[h+1][w] == '.')ret += black_count(v,h+1,w)+1;\n\tif(v[h-1][w] == '.')ret += black_count(v,h-1,w)+1;\n\tif(v[h][w+1] == '.')ret += black_count(v,h,w+1)+1;\n\tif(v[h][w-1] == '.')ret += black_count(v,h,w-1)+1;\n\t\n\treturn ret;\n}\n\t\t\n\t\nint main()\n{\n\tint w,h,startw,starth;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\t\n\t\t\n\t\tif(w == 0 && h == 0)break;\n\t\tvector<vector<char>> v(h+2,vector<char>(w+2,'#'));\n\t\t\n\t\tfor(int i=1;i<h+1;i++){\n\t\t\tfor(int j=1;j<w+1;j++){\n\t\t\t\tcin >> v[i][j];\n\t\t\t\tif(v[i][j] == '@'){\n\t\t\t\t\tstarth = i;\n\t\t\t\t\tstartw = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << black_count(v,starth,startw)+1 << endl;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Shunji Lin 08-144505\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint reachable = 0;\n\nvoid DFS(bool grid[20][20], bool visited[20][20],  int row_pos, int col_pos, int H, int W);\n\nvoid DFS_aux(bool grid[20][20], bool visited[20][20], int row_pos, int col_pos, int H, int W) {\n  if (grid[row_pos][col_pos] && !visited[row_pos][col_pos]) {\n    DFS(grid, visited, row_pos, col_pos, H, W);\n  }\n    \n}\n\t \nvoid DFS(bool grid[20][20], bool visited[20][20], int row_pos, int col_pos, int H, int W) {\n  visited[row_pos][col_pos] = true; //mark as visited\n  reachable += 1; // increase reachable count\n\n  //do all four actions (up, left, down, right), unless corner cases\n  if (!(row_pos == 0)) {\n    DFS_aux(grid, visited, row_pos-1, col_pos, H, W); //up\n  }\n  if (!(col_pos == 0)) {\n    DFS_aux(grid, visited, row_pos, col_pos-1, H, W); //left\n  }\n  if (!(row_pos == H-1)) {\n    DFS_aux(grid, visited, row_pos + 1, col_pos, H, W); //down\n  }\n  if (!(col_pos == W-1)) {\n    DFS_aux(grid, visited, row_pos, col_pos + 1, H , W); //right\n  }\n}\n\n\nint main() {\n  while (true) {\n    bool grid[20][20] = {{false}};\n    bool visited[20][20] = {{false}};\n    reachable = 0;\n    int man_row = -1, man_col = -1;\n    int W, H;\n    cin >> W >> H;\n    if (W == 0 && H == 0) break;\n    for (int i = 0; i < H; i++) {\n      string line;\n      cin >> line;\n      for (int j = 0; j < W; j++) {\n\tif (line[j] == '@') {\n\t  grid[i][j] = true;\n\t  man_row = i;\n\t  man_col = j;\n\t} else if (line[j] == '.') {\n\t  grid[i][j] = true;\n\t}\n      }\n    }\n    /*\n    //print out grid\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n\tif (grid[i][j] == true) {\n\t  cout << 'b';\n\t} else if (grid[i][j] == false) {\n\t  cout << 'r';\n\t} \n      }\n      cout << endl;\n    }\n    */\n    \n    DFS(grid, visited,  man_row, man_col, H, W );\n    cout << reachable << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint h,w;\nchar mp[111][111];\nint xx[4]={0,1,0,-1};\nint yy[4]={-1,0,1,0};\nint sx,sy;\n\nint tile(int y,int x){\n    if(y<h&&x<w&&y>=0&&x>=0&&mp[y][x]!='#'){\n        mp[y][x]='#';\n        int t=0;\n        for(int i=0;i<4;i++){\n            t+=tile(y+yy[i],x+xx[i]);\n        }\n        return t+1;\n    }\nreturn 0;\n}\n\nint main(){\n    \n    while(1){\n    \n        scanf(\" %d %d\",&w,&h);\n        \n        if(w==0&&h==0)break;\n        \n        for(int i=0;i<h;i++){\n            scanf(\" %s\",mp[i]);\n            for(int j=0;j<w;j++){\n                if(mp[i][j]=='@'){\n                    sx=j;\n                    sy=i;\n                }\n            }\n        }\n        \n        cout << tile(sy,sx) << endl;\n        \n    }\n    \n    return 0;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n\nint main(){\n  while(1){\n    int h,w;\n    cin>>w>>h;\n    if(h==0&&w==0) break;\n    char a[h][w];\n    queue<pair<int,int>> q;\n    bool used[h][w];\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        used[i][j]=0;\n        if(a[i][j]=='@') q.push(make_pair(i,j));\n      }\n    }\n    int ans=0;\n    while(!q.empty()){\n      pair<int,int> p=q.front();\n      q.pop();\n      int x=p.first, y=p.second;\n      if(used[x][y]) continue;\n      used[x][y]=1;\n      ans++;\n      if(x>0){\n        if(!used[x-1][y]&&a[x-1][y]=='.'){\n          q.push(make_pair(x-1,y));\n        }\n      }\n      if(x<h-1){\n        if(!used[x+1][y]&&a[x+1][y]=='.'){\n          q.push(make_pair(x+1,y));\n        }\n      }\n      if(y>0){\n        if(!used[x][y-1]&&a[x][y-1]=='.'){\n          q.push(make_pair(x,y-1));\n        }\n      }\n      if(y<w-1){\n        if(!used[x][y+1]&&a[x][y+1]=='.'){\n          q.push(make_pair(x,y+1));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid checkboard(void);\nvoid startmove(void);\nint checked(int i,int j);\n\nchar board[20][20];\nint H,W,now[2];\n\nint main(void){\n\twhile(1){\n\t\tcin >> H >> W ;\n\t\tif (!H && !W) break;\n\t\t// count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tcin >> board[i][j];\n\t\t\t\tif(board[i][j]=='@'){\n\t\t\t\t\tnow[0]=i;\n\t\t\t\t\tnow[1]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstartmove();\n\t\tcheckboard();\n\t}\n\n}\n\n\nvoid startmove(void){\n\tint n;\n\tdo{\n\t\tn=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@')\n\t\t\t\t\tn+=checked(i,j);\n\t\t\t}\n\t\t}\n\n\t}while(n);\n}\n\nint checked(int i,int j){\n\tint a=0;\n\tif(i>=0 && board[i-1][j]=='.'){\n\t\tboard[i-1][j]='@';\n\t\ta=1;\n\t}\n\tif(i<W && board[i+1][j]=='.'){\n\t\tboard[i+1][j]='@';\n\t\ta=1;\n\t}\n\tif(j>=0 && board[i][j-1]=='.'){\n\t\tboard[i][j-1]='@';\n\t\ta=1;\n\t}\n\tif(j<H && board[i][j+1]=='.'){\n\t\tboard[i][j+1]='@';\n\t\ta=1;\n\t}\n\t// checkboard();\n\treturn a;\n}\nvoid checkboard(void){\n\t\tint count=0;\n\t\tfor(int i=0;i<W;i++){\n\t\t\tfor(int j=0;j<H;j++){\n\t\t\t\tif(board[i][j]=='@') count++; \n\t\t\t\t// cout << board[i][j];\n\t\t\t}\n\t\t}\n\t\t\tcout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 30;\nconst int MAXW = 30;\nint W, H;\nchar G[MAXH][MAXW];\n\nint dfs(int x, int y) {\n  const static int dx[] = {1,0,-1,0};\n  const static int dy[] = {0,1,0,-1};\n  G[y][x] = '#';\n  int res = 1;\n  for(int k = 0; k < 4; ++k) {\n    int nx = x + dx[k];\n    int ny = y + dy[k];\n    if(nx < 0 || nx >= W) continue;\n    if(ny < 0 || ny >= H) continue;\n    if(G[ny][nx] == '#') continue;\n    res += dfs(nx, ny);\n  }\n  return res;\n}\n\nint main() {\n  for(; cin >> W >> H && (W|H);) {\n    int sx, sy;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '@') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    cout << dfs(sx, sy) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cctype>\n\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repi(i,l,n) for(int (i)=(int)(l);(i)<(int)(n);(i)++)\n//#define d_arr(arr, h, w) rep(i,( (arr).size() ) ){ cout << \"[\"; rep(j,(w) ) { cout << (arr)[i][j] << \", \"; } cout << \"]\" << endl;}\n#define d_arr(arr, type) rep(i, sizeof(arr)/sizeof(arr)[0] ){ cout << \"[\"; rep(j,sizeof(arr[0])/sizeof(type)) { cout << (arr)[i][j] << \", \"; } cout << \"]\" << endl;}\n\nclass Coordinates\n{\n    public:\n        int x;\n        int y;\n\n        Coordinates(){ x = 0; y = 0;};\n        Coordinates(int a, int b) { x = a; y = b;}\n\n        Coordinates operator+(Coordinates p)\n        {\n            Coordinates tmp;\n            tmp.x = x + p.x;\n            tmp.y = y + p.y;\n            return tmp;\n        }\n\n        friend bool operator==(const Coordinates a, const Coordinates b)\n        {\n            return (a.x == b.x && a.y == b.y);\n        }\n        friend bool operator<(const Coordinates a, const Coordinates b)\n        {\n            return (a.x < b.x && a.y < b.y);\n        }\n        friend bool operator<=(const Coordinates a, const Coordinates b)\n        {\n            return (a.x <= b.x && a.y <= b.y);\n        }\n        void show() { cout << \"(\" <<  y << \", \" << x << \")\" << endl; }\n};\ntypedef Coordinates Coo;\n\n\nCoo dir[4] = { Coo(0,-1), Coo(1,0), Coo(0,1), Coo(-1,0) };\n\n\nchar grid[30][30];\nbool isVisit[30][30];\n//start_pos\nCoo start;\nint h,w;\n\nint four_max(int a, int b, int c, int d);\nint max(int a, int b);\nvoid dfs(Coo s);\n\nint main()\n{\n    while (cin >> w >> h) \n    {\n        if( w == 0 && h ==0) {return 0;}\n        for (int i = 0; i < h; i++) \n        {\n            for (int j = 0; j < w; j++) \n            {\n                cin >> grid[i][j];\n                if (grid[i][j] == '@') \n                {\n                    //Coo(x, y)\n                    start = Coo(j, i);\n                }\n                //ついでにisVisit初期化\n                isVisit[i][j]=false;\n            }\n        }\n        isVisit[start.y][start.x] = true;\n        dfs(start);\n        int cnt = 0;\n        rep(i,h)\n        {\n            rep(j,w)\n            {\n                if( isVisit[i][j] == true ) { cnt++; }\n            }\n        }\n\n        cout << cnt << endl;\n    }\n    return 0;\n}\n\n//x,yから始まって最大行けるredの数返す関数\nvoid dfs(Coo s)\n{\n    //s.show();\n    vector<int> maxnum;\n    rep(i, 4) \n    {\n        Coo next = s + dir[i];\n        //外に出てたら\n        if ( next.y < 0 || next.x < 0  ||  h <= next.y || w <= next.x ) { continue; }\n        //壁じゃなかったら\n        if ( grid[next.y][next.x] == '#') { continue; }\n        //既に訪れてたら\n        if (isVisit[next.y][next.x] == true ) { continue; }\n\n        isVisit[next.y][next.x] = true;\n        dfs(next);\n    }\n    return;\n}\n\n\n\nint four_max(int a, int b, int c, int d)\n{\n    return max( max(a, b), max(c, d) );\n}\n\nint max(int a, int b) \n{\n    if ( a > b)  { return a; }\n    else         { return b; }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define GROUND 0\n#define WALL 500\n#define INITIAL -1\n\nint count();\nvoid init();\nvoid mark_n(int,int,int,int,int);\nvoid mark_n_all(int);\nbool isValidPoint(int,int);\n\nusing namespace std;\nconst int MAX_W = 20;\nconst int MAX_H = 20;\nchar floor_[MAX_W][MAX_H];\n//floorツつセツづ算ツ術ツ甘鳴青板づ債ャツつエツづゥ\nint step[MAX_W][MAX_H];\nint width,height;\n\nint main(){\n  while(cin >> width >> height && width > 0){\n    string line;\n    int ix,iy;\n    init();\n    for(int i = 0; i < height; i++){\n      cin >> line;\n      for(int j=0; j < width ; j++){\n\tfloor_[j][i] = line[j];\n\tif(line[j]=='@'){\n\t  step[j][i]=GROUND;\n\t  ix = j; iy = i;\n\t}else if(line[j]=='#'){\n\t  step[j][i]=WALL;\n\t}\n      }\n    }\n    for(int k = 0; k < 300; k++){\n      mark_n_all(k);\n    }\n    cout << count() << endl;\n  }\n}\n\nint count(){\n  int result =0;\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width; j++){\n      if(step[j][i] >= 0 && step[j][i] < WALL){\n\tresult++;\n      }\n    }\n  }\n  return result;\n}\n\nvoid init(){\n  for(int i=0; i<height;i++){\n    for(int j=0; j< width;j++){\n      step[j][i]=INITIAL;\n    }   \n  }\n}\n\nvoid mark_n(int n,int x,int y,int dx,int dy){\n  int temp;\n  for(int i =0; i< 4;i++){\n    temp = dx;\n    dx = dy;\n    dy = -temp;\n    if(isValidPoint(x+dx,y+dy) && step[x+dx][y+dy]==INITIAL){\n      step[x+dx][y+dy] = n;\n    }\n  }\n}\n\nvoid mark_n_all(int n){\n  for(int i = 0; i < height; i++){\n    for(int j = 0; j < width ; j++){\n      if(step[j][i]==n){\n\tmark_n(n+1,j,i,1,0);\n      }\n    }\n  }\n}\n\nbool isValidPoint(int x,int y){\n  if(x < 0 || x >=  width || y < 0 || y >= height){\n    return false;\n  }else{\n    return true;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nchar map[20][20];\nint visited[20][20];\n\nvoid dfs(int x, int y, int w, int h) {\n    visited[x][y] = 1;\n    for (int i = -1; i <= 1; i += 2) {\n        if (0 <= x+i && x+i < h && visited[x+i][y] == 0 && map[x+i][y] == '.')\n            dfs(x+i, y, w, h);\n    }\n    for (int i = -1; i <= 1; i += 2) {\n        if (0 <= y+i && y+i < w && visited[x][y+i] == 0 && map[x][y+i] == '.')\n            dfs(x, y+i, w, h);\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    int w, h, x, y, sum;\n    string line;\n    while (cin >> w >> h, w | h) {\n        for (int i = 0; i < 20; ++i)\n            for (int j = 0; j < 20; ++j)\n                visited[i][j] = 0;\n        for (int i = 0; i < h; ++i) {\n            cin >> line;\n            for (int j = 0; j < w; ++j) {\n                map[i][j] = line[j];\n                if (line[j] == '@') {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n        dfs(x, y, w, h);\n        sum = 0;\n        for (int i = 0; i < 20; ++i)\n            for (int j = 0; j < 20; ++j)\n                sum += visited[i][j];\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX_W 20\n#define MAX_H 20\nusing namespace std;\n\nint w, h, ax, ay, cnt;\nchar t[MAX_H][MAX_W + 1];\n\nvoid PRINT() {\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      cout << t[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\n// 深さ優先探索\n// 現在位置(x, y)\nvoid dfs(int x, int y) {\n  t[y][x] = 'o';\n\n  for(int dx = -1; dx <= 1; dx++) {\n    for(int dy = -1; dy <= 1; dy++) {\n      // 4方向に限定\n      if(dx * dy == -1 || dx * dy == 1) continue;\n\n      // 現在位置を(nx, ny)に更新\n      int nx = x + dx;\n      int ny = y + dy;\n\n      // (nx, ny)は部屋の中か？ & t[nx][ny]は黒タイルか？判定\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && t[ny][nx] == '.') {\n        dfs(nx, ny);\n        //PRINT();\n        cnt++;\n      }\n    }\n  }\n  return;\n}\n\nvoid solve() {\n  cnt = 1;\n  dfs(ax, ay);\n  cout << cnt << endl;\n}\n\nint main() {\n  while(cin >> w >> h) {\n    if(w * h == 0) break;\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        cin >> t[i][j];\n        if(t[i][j] == '@') {\n          ax = j;\n          ay = i;\n        }\n      }\n    }\n    \n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvoid solve(int h,int w) {\n    vector<string> s(h);\n    cin>>s;\n    REP(i,h) {\n        REP(j,w) {\n            if(s[i][j]=='@') {\n                queue<pii> q;\n                vector<vector<bool>> vis(h,vector<bool>(w,false));\n                vis[i][j]=true;\n                q.push({i,j});\n                int ans=1;\n                while(!q.empty()) {\n                    int y=q.front().first;\n                    int x=q.front().second;\n                    q.pop();\n                    REP(d,4) {\n                        int yy=y+DY[d];\n                        int xx=x+DX[d];\n                        if(OUTOFRANGE(yy,xx,h,w)) continue;\n                        if(vis[yy][xx]) continue;\n                        if(s[yy][xx]=='#') continue;\n                        q.push({yy,xx});\n                        vis[yy][xx]=true;\n                        ans++;\n                    }\n                }\n                cout<<ans<<endl;\n                return;\n            }\n        }\n    }\n}\nsigned main() {\n    while(1) {\n        int h,w;\n        cin>>w>>h;\n        if(h+w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint a,b,sum=0;\nint y[21][21]={};\nchar x[21][21];\nvoid dfs(int aa,int bb){\nfor(int i=0;i<4;i++){\n  if(aa+dx[i]>=0 && aa+dx[i]<a && bb+dy[i]>=0 && bb+dy[i]<b && y[bb+dy[i]][aa+dx[i]]==0){\ny[bb+dy[i]][aa+dx[i]]=1;\ndfs(aa+dx[i],bb+dy[i]);\n}\n}\n}\nint main(){\nint c,d;\nwhile(1){\nscanf(\"%d %d\",&a,&b);\nif(a==0 && b==0) break;\nfor(int i=0;i<b;i++){\nscanf(\"%s\",x[i]);\n}\nfor(int i=0;i<b;i++){\nfor(int j=0;j<a;j++){\nif(x[i][j]=='.'){\ny[i][j]=0;\n}else if(x[i][j]=='#'){\ny[i][j]=2;\n}else{\n\ty[i][j]=1;\nc=j;\nd=i;\n}\n}}\ndfs(c,d);\nfor(int i=0;i<b;i++){\n  for(int j=0;j<a;j++){\n    if(y[i][j]==1){\n      sum++;\n    }\n  }\n}\nprintf(\"%d\\n\",sum);\nsum=0;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint cnt, a[23][23];  //black : 0, red : 1\n\nvoid dfs(int x, int y){\n    cnt++;\n    a[x][y] = 1;\n    if(!a[x + 1][y]) dfs(x + 1, y);\n    if(!a[x - 1][y]) dfs(x - 1, y);\n    if(!a[x][y + 1]) dfs(x, y + 1);\n    if(!a[x][y - 1]) dfs(x, y - 1);\n    return;\n}\n\nint main(){\n    while(1){\n        int i, j, w, h, si, sj;\n        char in;\n        cin >> w >> h;\n        if(w == 0)break;\n        \n        cnt = 0;\n        for(i = 0; i <= h + 1; i++){\n            a[i][0] = a[i][w + 1] = 1;\n        }\n        for(j = 0; j <= w + 1; j++){\n            a[0][j] = a[h + 1][j] = 1;\n        }\n       \n        i = 1;\n        j = 1;\n        while(i <= h){\n            while(j <= w){\n                cin >> in;\n                //cout << \"~~\" << endl;\n                if(in == '.'){\n                   a[i][j] = 0;\n                   j++; \n                }else if(in == '#'){\n                    a[i][j] = 1;\n                    j++;\n                }else if(in == '@'){\n                    si = i;\n                    sj = j;\n                    a[i][j] = 1;\n                    j++;\n                }\n                //cout << j << endl;\n            \n            \n            \n            }\n            i++;\n            j = 1;\n        }\n        dfs(si, sj);\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstring s[21];\nbool used[21][21];\nconst int dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        int sx,sy,cnt=0;\n        rep(i,h){\n            cin>>s[i];\n            rep(j,w)if(s[i][j]=='@') sx=j,sy=i;\n        }\n        memset(used,0,sizeof(used));\n        queue<pint> q;\n        q.push({sx,sy});\n        used[sy][sx]=true;\n        while(!q.empty()){\n            pint pi=q.front();q.pop();\n            ++cnt;\n            rep(i,4){\n                int tx=pi.first+dx[i],ty=pi.second+dy[i];\n                if(tx>=0&&ty>=0&&tx<w&&ty<h&&s[ty][tx]=='.'&&!used[ty][tx]){\n                    q.push({tx,ty});\n                    used[ty][tx]=true;\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n\n\n\nvoid map_ser(int x, int y, int w, int h, int map[][30], int *cnt){\n    \n    if(map[y][x] == 1){\n        *cnt+=1;\n        map[y][x] = 2;\n        if(0<=x-1 && x-1<w && 0<=y && y<h){\n            map_ser(x-1, y, w, h, map, cnt);\n        }\n        if(0<=x+1 && x+1<w && 0<=y && y<h){\n            map_ser(x+1, y, w, h, map, cnt);\n        }\n        if(0<=x && x<w && 0<=y-1 && y-1<h){\n            map_ser(x, y-1, w, h, map, cnt);\n        }\n        if(0<=x && x<w && 0<=y+1 && y+1<h){\n            map_ser(x, y+1, w, h, map, cnt);\n        }\n    }\n    else if(map[y][x] != 1){\n        return;\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    // insert code here...\n    \n    \n    /////////\n    //write//\n    /////////\n    \n    int map[30][30];\n    int cnt;\n    char tmp[100];\n    int at_x,at_y;\n    \n    while(1){\n        int w,h; cin >> w >> h;\n        if(w==0 && h==0)break;\n        cnt = 0;\n        \n        for(int i=0; i<h; i++){\n            cin >> tmp;\n            for(int j=0; j<w; j++){\n                if(tmp[j] == '.')map[i][j] = 1;\n                else if(tmp[j] == '#')map[i][j] = 0;\n                else if(tmp[j] == '@'){\n                    at_x = j;\n                    at_y = i;\n                    map[i][j] = 1;\n                }\n            }\n        }\n        map_ser(at_x, at_y, w, h, map, &cnt);\n        cout << cnt << endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef struct P{\n  int first;\n  int second;\n} PAIR;\n\nint main(void){\n  int w, h, sx, sy, x, y, i,ans;\n  char mp[22][22];\n  bool visited[22][22];\n  queue<PAIR> que;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  PAIR next, tmp;\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0) break;\n    for(y=0;y<h+2;y++){\n      if(y == 0 || y == h + 1){\n        for(x=0;x<w+2;x++) mp[y][x] = '#';\n      }else{\n        for(x=0;x<w+2;x++){\n          if(x == 0 || x == w + 1){\n            mp[y][x] = '#';\n          }else{\n            cin >> mp[y][x];\n          }\n        }\n      }\n    }\n    for(y=0;y<h+2;y++){\n      for(x=0;x<w+2;x++){\n        if(mp[y][x] == '@'){\n          sx = x;\n          sy = y;\n        }\n        visited[y][x] = false;\n      }\n    }\n    que.push(PAIR{sx, sy});\n\n    visited[sy][sx] = true;\n    ans = 1;\n    \n    while(!que.empty()){\n      next = que.front();\n      que.pop();\n      for(i=0;i<4;i++){\n        if((!visited[next.second+dy[i]][next.first+dx[i]]) && (mp[next.second+dy[i]][next.first+dx[i]] == '.')){\n          ans++;\n          visited[next.second+dy[i]][next.first+dx[i]] = true;\n          que.push(PAIR{next.first+dx[i], next.second+dy[i]});\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nchar map[32][32];\nint ans;\nint W,H;\n\nvoid func(int x,int y){\n\tmap[x][y] = '0';\n\tans++;\n\tif(map[x][y+1] == '.' && y+1<32)\n\t\tfunc(x,y+1);\n\tif(map[x][y-1] == '.' && y-1>-1)\n\t\tfunc(x,y-1);\n\tif(map[x+1][y] == '.' && x+1<32)\n\t\tfunc(x+1,y);\n\tif(map[x-1][y] == '.' && x-1>-1)\n\t\tfunc(x-1,y);\n}\n\n\nint main(void){\n\twhile(scanf(\"%d%d\",&W, &H) && H){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",map[i]);\n\t\t}\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tfunc(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\tans=0;\n\t\tfor(int i = 0; i < 32; i++){\n\t\t\tfor(int j = 0; j < 32; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint w, h;\n\nint dfs(vector<vector<char>> &a, int ii, int jj) {\n  int cnt = 1;\n  a[ii][jj] = '#';\n  rep (k, 4) {\n    if (in(ii + dx[k], 0, h) && in(jj + dy[k], 0, w) && a[ii + dx[k]][jj + dy[k]] == '.') {\n      cnt += dfs(a, ii + dx[k], jj + dy[k]);\n    }\n  }\n  return cnt;\n}\n\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (h == 0) return 0;\n    vector<vector<char> > a(h, vector<char>(w));\n    int si, sj;\n    rep (i, h) {\n      rep (j, w) {\n        cin >> a[i][j];\n        if (a[i][j] == '@') {\n          si = i;\n          sj = j;\n        }\n      }\n    }\n\n    cout << dfs(a, si, sj) << endl;\n    \n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\n#include <list>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\n\n#define PREP(i, m, n) for(int i = m; i < n; i++)\n#define MREP(i, m, n) for(int i = m - 1; i >= n; i--)\nusing namespace std;\n\nconst int dirX[] = {-1, 0, 1, 0};\nconst int dirY[] = {0, -1, 0, 1};\n\nstruct point{\n\tint x;\n\tint y;\n\tpoint(int x = 0, int y = 0):x(x), y(y){}\n};\n\nint wideSearch(point start, vector<string> &map){\n\tint count = 1;\n\tqueue<point> usablepos;\n\tusablepos.push(start);\n\twhile(1){\n\t\tif(usablepos.size() == 0) break;\n\t\tpoint current = usablepos.front();\n\t\tusablepos.pop();\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((current.y + dirY[i] >= 0 && current.y + dirY[i] < map.size()) && (current.x + dirX[i] >= 0 && current.x + dirX[i] < map[0].size())){\n\t\t\t\tif(map[current.y + dirY[i]][current.x + dirX[i]] == '.'){\n\t\t\t\t\tmap[current.y + dirY[i]][current.x + dirX[i]] = '#';\n\t\t\t\t\tpoint tmp(current.x + dirX[i], current.y + dirY[i]);\n\t\t\t\t\tcount++;\n\t\t\t\t\tusablepos.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tint w = 0, h = 0;\n\twhile(cin >> w >> h && (w != 0 || h != 0)){\n\t\tvector<string> map;\n\t\tpoint start;\n\t\tstring input;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> input;\n\t\t\tmap.push_back(input);\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\tstart.x = j;\n\t\t\t\t\tstart.y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << wideSearch(start, map) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 22\nusing namespace std;\n\nint counter = 0;\nchar tile[MAX][MAX];\n\nvoid redtile(int y, int x){\n\ttile[y][x] = '+';\n\tcounter++;\n\tif (x + 1 < MAX && tile[y][x + 1] == '.')\n\t\tredtile(y, x + 1);\n\tif (x - 1 >= 0 && tile[y][x - 1] == '.')\n\t\tredtile(y, x - 1);\n\tif (y + 1 < MAX&&tile[y + 1][x] == '.')\n\t\tredtile(y + 1, x);\n\tif (y - 1 >= 0 && tile[y - 1][x] == '.')\n\t\tredtile(y - 1, x);\n}\n\n\nint main()\n{\n\tint w, h, initi, initj;\n\twhile (cin >> w >> h, w || h){\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\ttile[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> tile[i][j];\n\t\t\t\tif (tile[i][j] == '@'){\n\t\t\t\t\ttile[i][j] = '.';\n\t\t\t\t\tiniti = i;\n\t\t\t\t\tinitj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcounter = 0;\n\t\tredtile(initi, initj);\n\t\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\nusing namespace std;\n\nint main(){\n  int W, H;\n  while(cin >> W >> H && W>0 && H>0){\n    int map[20][20];\n    for(int i=0;i<20;i++)\n      for(int j=0;j<20;j++)\n        map[i][j]=0;\n    int at[2];\n\n    for(int i=0;i<H;i++){\n      string s;\n      cin >> s;\n      for(int j=0;j<W;j++){\n        map[i][j]=(s[j]=='.'?1:(s[j]=='@'?2:0));\n        if(s[j]=='@'){\n          at[0]=i; at[1]=j;\n        }\n      }\n    }\n\n    vector<int> list[400];  //??£??\\?????????????????????????????????20*i+j?????????\n    for(int i=0;i<400;i++){\n      if(i>=20) //???\n        if(map[i/20-1][i%20]>0) list[i].push_back(i-20);\n      if(i%20>0) //???\n        if(map[i/20][(i-1)%20]>0) list[i].push_back(i-1);\n      if(i%20<19) //???\n        if(map[i/20][(i+1)%20]>0) list[i].push_back(i+1);\n      if(i<180) //???\n        if(map[i/20+1][i%20]>0) list[i].push_back(i+20);\n    }\n\n    bool d[400];\n    for(int i=0;i<400;i++) d[i]=false;\n\n    stack<int> cur;\n    cur.push(at[0]*20+at[1]);\n    d[at[0]*20+at[1]]=true;\n\n    while(!cur.empty()){\n      bool flg=false;\n      for(vector<int>::iterator it=list[cur.top()].begin();it!=list[cur.top()].end();it++){\n        if(!d[*it]){\n          flg=true;\n          cur.push(*it);\n          d[*it]=true;\n          break;\n        }\n      }\n      if(flg) continue;\n      cur.pop();\n    }\n\n    int cnt=0;\n    for(int i=0;i<400;i++)\n      if(d[i]) cnt++;\n\n    cout << cnt << endl;\n  }\n\n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\nvoid init(vec & parent, vec & size)\n{\n\tfor (int i = 0; i < parent.size(); ++i)\n\t{\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\n\n\nint find(vec & parent, int x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\treturn x = find(parent,parent[x]);\n}\n\n\nvoid unite(vec & parent, vec & size, int x, int y)\n{\n\tx = find(parent, x);\n\ty = find(parent, y);\n\n\tif (x == y)return;\n\n\tparent[y] = x;\n\tsize[x] += size[y];\n}\n\n\nint change(int y,int x,int W)\n{\n\treturn y*W + x;\n}\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0)return 0;\n\n\t\tmat color(H, vec(W));\n\t\tvec parent(W*H);\n\t\tvec size(W*H);\n\n\t\tinit(parent, size);\n\n\t\tint start;\n\n\t\tfor (int y = 0; y < H; ++y)\n\t\t{\n\t\t\tstring c;\n\t\t\tcin >> c;\n\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (c[x] == '.') { \n\t\t\t\t\t\n\t\t\t\t\tcolor[y][x] = 0; \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (c[x] == '#') { color[y][x] = 1; }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor[y][x] = 0;\n\t\t\t\t\tstart = change(y, x, W);\n\t\t\t\t}\n\n\t\t\t\tif (x != 0 && color[y][x] == color[y][x - 1])\n\t\t\t\t{\n\t\t\t\t\tunite(parent, size, change(y, x, W), change(y, x - 1, W));\n\t\t\t\t}\n\t\t\t\tif (y != 0 && color[y][x] == color[y - 1][x])\n\t\t\t\t{\t\n\t\t\t\t\tunite(parent, size, change(y, x, W), change(y - 1, x, W));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tcout << size[find(parent, start)] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n//bool c[22][22] = {};\nint cnt,w, h, p[22][22] = {};\n\nint main() {\n\tint j, f,cx,cy;\n\tchar in[21];\n\twhile (1) {\n/*\t\tfor (int i = 0; i < 484; i++) {\n\t\t\tc[i / 22][i % 22] = p[i / 22][i % 22] = 0;\n\t\t}\n*/\t\tcnt = 0;\n\t\tf = 1;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w ==0&& h == 0)\n\t\t\tbreak;\n\t\tscanf(\"\\n\", &j);\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tscanf(\"%s\", &in);\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tswitch (in[j]) {\n\t\t\t\tcase '#':\n//\t\t\t\t\tc[j+1][i+1] = 0;\n\t\t\t\t\tp[j+1][i+1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tp[j+1][i+1] = 1;\n//\t\t\t\tcase '.':\n//\t\t\t\t\tc[j+1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tprintf(\"%3d\", c[j][i]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\n\t\twhile (f == 1) {\n\t\t\tf = 0;\n\t\t/*\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tprintf(\"%3d\", p[j+1][i+1]);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\t\t\t//if (w != 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\t\t\tif (p[i / h+1][i%h+1] == 0 && (p[i / h + 2][i % h+1] == 1 || p[i / h][i % h+1] == 1 || p[i / h+1][i % h + 2] == 1 || p[i / h+1][i % h] == 1)) {\n\t\t\t\t\t\tp[i / h+1][i%h+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t\t/*if (w == 1 && h != 1) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tif (p[1][i+1] == 0 && (p[1][i + 2] == 1 || p[0][i] == 1)) {\n\t\t\t\t\t\tp[1][i+1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\tprintf(\"a\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w != 1 && h == 1) {\n\t\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\t\tif (p[i+1][1] == 0 && (p[i + 2][1] == 1 || p[i][1] == 1)) {\n\t\t\t\t\t\tp[i+1][1] = 1;\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\n\t\tfor (int i = 0; i < w*h; i++) {\n\t\t\tif (p[i / h+1][i%h+1] == 1)\n\t\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n\nint ans[1024];\nint w,h,k;\nbool b[22][22];//??°???\n\nint d(int,int);\n\nint main(void){\n  int i,j;\n  char c[20][20];\n  int p,q;//???????????§?¨?\n\n    k =0;\n  while(true){\n    //??\\???\n    scanf(\"%d%d\",&w,&h);\n    if(w==0 && h==0)break;\n    \n    for(i=0;i<h;i++){\n\tscanf(\"%s\",c[i]);\n//printf(\"%d,%s\\n\",i,c[i]);\n      }\n//printf(\"%c\\n\",c[0][1]);\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(c[i][j] =='@'){\n            p=i;\n            q=j;\n        }\n          if(c[i][j] =='#'){\n              b[i][j] = false;\n            \n          }else {\n              b[i][j] = true;\n          }\n      }\n    }\n      ans[k] = 1;\n      //printf(\"Ok\");\n    d(p,q);\n      k++;\n  }\n    for (i=0;i<k;i++){\n        printf(\"%d\\n\",ans[i]);\n    }\n  return 0;\n}\nint d(int p,int q){\n  int i,j,p1,q1;\n    b[p][q]  = false;\n  for(i=0;i<4;i++){\n    if(i==0){\n      p1=p+1;\n      q1=q;\n    } else if(i==1){\n      p1=p-1;\n      q1=q;\n    }else if(i==2){\n      p1=p;\n      q1=q+1;\n    }else {\n      p1=p;\n      q1=q-1;\n    }\n    if(p1>=0 && p1<h && q1>=0 && q1<w){\n      if(b[p1][q1] == true){\n\tans[k]++;\n          \n        d(p1,q1);\n      }\n    }\n  }\n  return 0;\n}\n     \n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {1, -1, 0, 0};\nint W, H;\nchar board[30][30];\n\nint dfs(int y, int x) {\n   board[y][x] = '#';\n   int ret = 1;\n   for (int i = 0; i < 4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if (nx >= 0 && nx < W && ny >= 0 && ny < H && board[ny][nx] == '.') {\n         ret += dfs(ny, nx);\n      }\n   }\n   return ret;\n}\n\nint main() {\n   while (cin >> W >> H, W) {\n      for (int i = 0; i < H; i++) {\n         cin >> board[i];\n      }\n      for (int i = 0; i < H; i++) {\n         for (int j = 0; j < W; j++) {\n            if (board[i][j] == '@') {\n               cout << dfs(i, j) << endl;\n            }\n         }\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int, int> pii;\npii dxdy[]={{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nchar fld[20][20];\nint d[20][20];\nconst int inf=1e8;\n\nint main(){\n\n   while(1){\n      int W, H;\n      cin>> W>> H;\n      if(!(H||W)) break;\n      int sx, sy;\n      for(int i=0; i<H; i++){\n         for(int j=0; j<W; j++){\n            cin>> fld[i][j];\n            if(fld[i][j]=='@'){\n               sy=i;\n               sx=j;\n            }\n         }\n      }\n\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++)d[i][j]=inf;\n      queue<pii> Q;\n      Q.push(pii(sy, sx));\n      d[sy][sx]=0;\n      while(!Q.empty()){\n         pii now=Q.front(); Q.pop();\n         for(pii dd: dxdy){\n            int ni=now.first+dd.first;\n            int nj=now.second+dd.second;\n            if(!(0<=ni&&ni<H&&0<=nj&&nj<W)) continue;\n            if(fld[ni][nj]=='#'||fld[ni][nj]=='@') continue;\n            if(d[ni][nj]<=d[now.first][now.second]+1) continue;\n            d[ni][nj]=d[now.first][now.second]+1;\n            Q.push(pii(ni, nj));\n         }\n      }\n\n      int ans=0;\n      for(int i=0; i<H; i++)for(int j=0; j<W; j++){\n         ans+=(d[i][j]!=inf);\n      }\n\n      cout<< ans<< endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\naccept?????????\n40?????????????????£???\n\n???????????¨??????????????¢?´¢???????????????????????????\n\n???????????????????????????????????°????????????????????????\n31-169584????????????????????????????????¨??£??????????????????????????£????????§????????????????????????????????????\n\n#endif\n\n\n#include <queue>\n#include <iostream>\nusing namespace std;\nint w,h;\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\nchar mat[100][100];\n\nbool valid(int x,int y)\n{\n    return (x>=0)&&(x<w)&&(y>=0)&&(y<h)&&(mat[x][y]!='#');\n}\n\nvoid bfs(int x,int y) {\n  int sum=1;\n  queue<pair<int,int> >Q;// ??´??°????????????????????\\????????????\n  pair<int,int>p;//?????????\n  p=make_pair(x,y);\n  Q.push(p);\n  while (! Q.empty()) {\n    pair<int,int> cur = Q.front(); // ??????????´????????????????\n    Q.pop();\n    for (int i=0;i<4;i++) { //??????????????????????????????4?????????\n      if (valid(cur.first+dx[i],cur.second+dy[i])) { //????????????????????????????????£??????\n\tQ.push(make_pair(cur.first+dx[i],cur.second+dy[i])); // dst ????¨???????????????????\n\tsum++;\n\tmat[cur.first+dx[i]][cur.second+dy[i]]='#';//2??????????????¢\n      }\n    }\n    mat[cur.first][cur.second]='#';//2??????????????¢\n  }\n  cout<<sum<<endl;\n}\n\n\nint main() {\n  int x,y;\n  while(cin>>w>>h && w!=0){\n    for(int j=0;j<h;++j){\n        for(int i=0;i<w;++i){\n            cin >> mat[i][j];\n            if(mat[i][j]=='@'){//???????±???´???\n                x=i,y=j;\n            }\n        }\n    }\n    bfs(x,y);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(v) v.begin(),v.end()\n\nusing int64 = long long;\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint main(void){\n\tint H, W;\n\twhile(cin >> H >> W && H && W){\n\t\tvector<string> f(H+2, string(W+2, '#'));\n\t\tint sy, sx;\n\t\tREP(i, H){\n\t\t\tcin >> f[i+1];\n\t\t\tREP(j, W+2){\n\t\t\t\tif(f[i+1][j] == '@'){\n\t\t\t\t\tsy = i+1;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n}\n\t\t\tf[i+1][0] = f[i+1][W+1] = '#';\n\t\t}\n\t\tbool visited[30][30] = {};\n\t\tint cnt = 0;\n\t\t\n\t\tauto dfs = [&](int y, int x){\n\t\t\tvisited[y][x] = 1;\n\t\t\tcnt++;\n\t\t\tREP(i, 4){\n\t\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\t\tif(f[yy][xx] != '#' && !visited[yy][xx]){\n\t\t\t\t\tdfs(yy, xx);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdfs(sy, sx);\n\t\tcout << cnt << endl;\n\t}\n}'\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\nusing namespace std;\nconst int INF = 1e9;\nconst int MXN = 0;\nconst int MXV = 0;\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define FOR(i, L, R) for (int i = L; i != (int)R; ++i)\n#define FORD(i, L, R) for (int i = L; i != (int)R; --i)\n#define IOS                                                                    \\\n    cin.tie(NULL);                                                             \\\n    cout.tie(NULL);                                                            \\\n    ios_base::sync_with_stdio(false);\nvector<string> room;\nint n, m;\nint ans;\nint d[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nvoid dfs(int x, int y)\n{\n    // cout << x << ' ' << y << '\\n';\n    FOR(i, 0, 4)\n    {\n        int _x = x + d[i][0];\n        int _y = y + d[i][1];\n        //     cout << _x << '-' << _y << '\\n';\n        // if (_x >= 0 && _x < n && _y >= 0 && _y < m)\n        // {\n        //     cout << room[_x][_y] << '\\n';\n        // }\n        if (_x >= 0 && _x < m && _y >= 0 && _y < n && room[_x][_y] == '.')\n        {\n            room[_x][_y] = '@';\n            ++ans;\n            dfs(_x, _y);\n        }\n    }\n}\n\nint main()\n{\n    IOS;\n    while (cin >> n >> m, n || m)\n    {\n        room.resize(m);\n        FOR(i, 0, m) { cin >> room[i]; }\n        int x = 0, y = 0;\n        FOR(i, 0, m) FOR(j, 0, n)\n        {\n            if (room[i][j] == '@')\n            {\n                x = i;\n                y = j;\n            }\n        }\n        ans = 1;\n        // cout << x << ' ' << y << '\\n';\n        dfs(x, y);\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans[50],cnt=0,sx,sy;\nstring m[20],t,s;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans[cnt]++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans[cnt]=0;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcnt++;\n\t}\n\trep(i,cnt)cout<<ans[i]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring fld[21];\nint w,h;\nbool flg[21][21];\nint ans;\n\nvoid solve(int x, int y){\n    if(flg[y][x]||fld[y][x]=='#'){\n        return;\n    }\n\n    ans++;\n    flg[y][x] = true;\n\n    int dx[] = {1,-1,0,0};\n    int dy[] = {0,0,1,-1};\n\n    for(int i=0;i<4;i++){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(nx<0||nx>=w||ny<0||ny>=h){\n            continue;\n        }\n\n        solve(nx, ny);\n    }\n}\n\n\nint main(){\n    while(cin>>w>>h,w!=0){\n        for(int i=0;i<21;i++){\n            for(int k=0;k<21;k++){\n                flg[k][i] = false;\n            }\n        }\n        ans = 0;\n\n        for(int y=0;y<h;y++){\n            cin >> fld[y];\n        }\n\n        int sx,sy;\n        for(int y=0;y<h;y++){\n            for(int x=0;x<w;x++){\n                if(fld[y][x]=='@'){\n                    sx = x;\n                    sy = y;\n                }\n            }\n        }\n\n        solve(sx, sy);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring map[21];\nint w,h;\nint dx[] = { -1, 1 , 0 , 0 };\nint dy[] = { 0 , 0 , -1, 1 };\n\nvoid check(int x , int y){\n\tint mx,my;\n\n\t//ãº¶EÌSûüÉ²×é\n\tfor(int i=0 ; i<4 ; i++){\n\t\tmx = x + dx[i];\n\t\tmy = y + dy[i];\n\t\t//tB[hOÉoÄ¢È¯êÎ²×é(0ÈãE³Èà)\n\t\tif(mx>=0 && mx<w && my>=0 && my<h){\n\t\t\tif(map[my][mx]=='.'){//^C¾Á½çhèÂÔµÄÄA\n\t\t\t\tmap[my][mx] = 'f';\n\t\t\t\tcheck( mx , my );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint sx,sy,count;\n\n\twhile(1){\n\t\t//ÏÌú»\n\t\tcount = 0;\n\n\t\t//E³ÌüÍ\n\t\tcin >> w >> h;\n\t\t\n\t\tif(w==0 && h==0)break;//0 0ªüÍ³ê½çI¹\n\n\t\t//üÍµ½lðmap[][]Éãü\n\t\tfor(int y=0 ; y<h ; y++){\n\t\t\tcin >> map[y];\n\t\t}\n\n\t\tfor(int y=0 ; y<h ; y++){\n\t\t\tfor(int x=0 ; x<w ; x++){\n\t\t\t\tif(map[y][x]=='@'){//@¾Á½çX^[gn_\n\t\t\t\t\tsy = y;\n\t\t\t\t\tsx = x;\n\t\t\t\t\tmap[y][x] = 'f';\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tcheck( sx , sy );//X^[gn_Ìx,yÀWðnµÄ²×é\n\n\t\t//^CÌJEg(fÌÂð¦é)\n\t\tfor(int y=0 ; y<h ; y++){\n\t\t\tfor(int x=0 ; x<w ; x++){\n\t\t\t\tif(map[y][x]=='f')count++;\n\t\t\t}\n\t\t}\n\n\t\t//¦ÌoÍ\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main(){\n\tint w, h; \n\twhile (cin >> w >> h) {\n\t\tif (!w && !h)return 0;\n\t\tchar map[21][21];\n\t\tbool b[21][21];\n\t\tqueue<pair<int, int> >bfs;\n\t\tfor (int i = 0; i < h; i++)for (int j = 0; j < w; j++) {\n\t\t\tcin >> map[i][j];\n\t\t\tb[i][j] = false;\n\t\t\tif (map[i][j] == '@') {\n\t\t\t\tbfs.push(make_pair(i, j));\n\t\t\t\tb[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\twhile (bfs.size() > 0) {\n\t\t\tpair<int, int>p = bfs.front();\n\t\t\tint x = p.first;\n\t\t\tint y = p.second;\n\t\t\tmap[x][y] = '#';\n\t\t\tif (x > 0){\n\t\t\t\tif (map[x - 1][y] == '.' && !b[x - 1][y]) {\n\t\t\t\t\tbfs.push(make_pair(x - 1, y));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x - 1][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < h) {\n\t\t\t\tif (map[x + 1][y] == '.' && !b[x + 1][y]) {\n\t\t\t\t\tbfs.push(make_pair(x + 1, y));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x + 1][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y > 0) {\n\t\t\t\tif (map[x][y - 1] == '.'&& !b[x][y - 1]) {\n\t\t\t\t\tbfs.push(make_pair(x, y - 1));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x][y - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < w) {\n\t\t\t\tif (map[x][y + 1] == '.' && !b[x][y + 1]) {\n\t\t\t\t\tbfs.push(make_pair(x, y + 1));\n\t\t\t\t\tans++;\n\t\t\t\t\tb[x][y + 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs.pop();\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n#define F first\n#define S second\nusing namespace std;\n\nchar c[33][33];\nint w,h;\n\nint solve(int x, int y){\n  typedef pair < int, int > P;\n  queue < P > que;\n  int count = 0;\n\n  que.push( P(x, y) );\n  \n  while(!que.empty()){\n    P q = que.front(); que.pop();\n    \n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    for(int i=0;i<4;i++){\n      int xx = dx[i] + q.F;\n      int yy = dy[i] + q.S;\n\n      if(xx < 0 || yy < 0 || xx == w || yy == h) continue;\n      if(c[yy][xx] == '#') continue;\n\n      c[yy][xx] = '#';\n      que.push( P(xx, yy) );\n      count++;\n    }\n\n  }\n\n  return count;\n}\n\nint main(){\n\n  int sx, sy;\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> c[i][j];\n\tif(c[i][j] == '@') sx = j, sy = i;\n      }\n    }\n\n    while(!que.empty()) que.pop();\n    cout << solve(sx, sy) << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint width, height;\nchar map[20][20];\nint sx, sy;\nbool used[20][20];\n\nint dfs(int x, int y){\n    used[y][x] = true;\n\n    int res = 1;\n    REP(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < width && 0 <= ny && ny < height &&\n           !used[ny][nx] && map[ny][nx] == '.'){\n            res += dfs(nx, ny);\n        }\n    }\n    \n    return res;\n}\n\nint main(){\n    while(std::cin >> width >> height, width || height){\n        REP(i, height){\n            REP(j, width){\n                std::cin >> map[i][j];\n                if(map[i][j] == '@'){\n                    sx = j; sy = i;\n                    map[i][j] = '.';\n                }\n            }\n        }\n\n        REP(i, 20){\n            REP(j, 20){\n                used[i][j] = false;\n            }\n        }\n        std::cout << dfs(sx, sy) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); (i)++)\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); (i)--)\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\nusing namespace std;\ntypedef long long lint;\ntypedef vector<vector<lint>> mat;\n\nint w, h, sx, sy;\nchar maze[30][30];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid dfs(int x, int y){\n    maze[x][y] = '$';\n    rep(i, 4){\n        int nx = x + dx[i]; int ny = y + dy[i];\n        if(0<=nx && nx<h && 0<=ny && ny<w && maze[nx][ny]=='.') dfs(nx, ny);\n    }\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(w == 0) return 0;\n        rep(i, h)rep(j, w){\n            cin >> maze[i][j];\n            if(maze[i][j] == '@') sx = i, sy = j;\n        }\n        dfs(sx, sy);\n        int cnt = 0;\n        rep(i, h)rep(j, w)if(maze[i][j] == '$') cnt++;\n        cout << cnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nvoid rec(int x,int y);\nchar map[30][30];\nbool isVisit[30][30];\nint count=0;\n//start_pos\nint start_x;\nint start_y;\nint h,w;\n\nint main()\n{\n    while (cin >> w >> h) \n    {\n        count = 0;\n        //start pos\n\n        for (int i = 0; i < h; i++) \n        {\n            for (int j = 0; j < w; j++) \n            {\n                cin >> map[j][i];\n                if (map[j][i] == '@') \n                {\n                    start_x=j;\n                    start_y=i;\n                }\n                //ついでにisVisit初期化\n                isVisit[j][i]=false;\n            }\n        }\n        rec(start_x,start_y);\n        cout <<count<<endl;\n    }\n\n}\n\nvoid rec(int x,int y)\n{\n    if ( y<0 || x<0 || h<=y || w<=x) {return;}\n    if ( map[x][y] == '#') {return;}\n    if (isVisit[x][y]) { return;}\n    isVisit[x][y] = true;\n    count++;\n\n    rec(x, y-1);\n    rec(x+1, y);\n    rec(x, y+1);\n    rec(x-1, y);\n\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\n#define ZERO(a) memset(a,0,sizeof(a))\n\nint w,h,ans;\nchar f[22][22];\nbool visited[22][22];\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool ng(int x, int y) {\n    return (x<0 or x>=w or y<0 or y>=h);\n}\n\nvoid dfs(int x, int y) {\n    if(x>=w or y>=h) return ;\n    visited[y][x] = true;\n    ans++;\n    rep(i,4) {\n        int nx = x+dx[i], ny = y+dy[i];\n        if(!ng(nx,ny) and !visited[ny][nx] and f[ny][nx]!='#')\n            dfs(nx,ny);\n    }\n\n    return ;\n}\n\nint main() {\n    while(cin>>w>>h && w) {\n        int sx=0, sy=0;\n        ans = 0;\n        ZERO(visited);\n        rep(y,h) rep(x,w) f[y][x] = '$';\n        rep(y,h) rep(x,w) {\n            cin>>f[y][x];\n            if(f[y][x] == '@') {sx=x; sy=y;}\n        }\n\n        dfs(sx,sy);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <queue>\n#include <utility>\n\n#define INF INT_MAX / 2\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nbool used[30][30];\n\nint bfs(int sy,int sx,const vector<vector<int> >&tiles){\n\tqueue<pair<int,int> > q;\n\tq.push(make_pair(sy,sx));\n\tint X = tiles[0].size();\n\tint Y = tiles.size();\n\tmemset(used,0,sizeof(used));\n\tused[sy][sx] = true;\n\tint ret= 0;\n\twhile(!q.empty()){\n\t\tP p = q.front();q.pop();\n\t\tint y = p.first;int x = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif( ny < 0 || nx < 0 || ny >= Y || nx >= X || used[ny][nx] || tiles[ny][nx]==0)continue;\n\t\t\tused[ny][nx] = true;\n\t\t\tq.push(make_pair(ny,nx));\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret+1;\n}\n\nint main(void) {\n\tint w,h;\n\twhile(cin >> w >> h,w+h!=0){\n\tvector<vector<int> >tiles(h,vector<int>(w));\n\tint sx,sy;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;cin >> c;\n\t\t\tif(c=='.')\n\t\t\t\ttiles[i][j] = 1;\n\t\t\telse if(c=='#')\n\t\t\t\ttiles[i][j] = 0;\n\t\t\telse{\n\t\t\t\ttiles[i][j] = 1;\n\t\t\t\tsx = j;sy = i;\n\t\t\t}\n\t\t}\n\t}\n\tcout << bfs(sy,sx,tiles) << endl;\n}\n}\n\n// command ctrl 上下\n// command D\n// command caps G → '' \"\"\n// vector<vector<int>> a(N,vector<int>(M,-1));"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint W,H,f[20][20],ans=0,sx,sy;\nstring m[20],t,s;\n\nvoid find(int x,int y){\n\tif(x>=W || x<0 || y>=H || y<0)return;\n\tt = m[x][y];\n\tif(t==\"#\")return;\n\tif(f[x][y]!=0)return;\n\tf[x][y] = 1;\n\tans++;\n\tfind(x+1,y);\n\tfind(x-1,y);\n\tfind(x,y+1);\n\tfind(x,y-1);\n}\n\nint main(void){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0)break;\n\t\tans=0;\n\t\trep(i,H){\n\t\t\tcin>>s;\n\t\t\trep(j,W){\n\t\t\t\tf[j][i]=0;\n\t\t\t\tm[j][i]=s[j];\n\t\t\t\tt=m[j][i];\n\t\t\t\tif(t==\"@\"){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfind(sx,sy);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint A[4][2]={-1,0,0,1,1,0,0,-1},ans,N,M;char RB[25][25];void bfs(int x, int y) {RB[x][y]='#';ans++;for (int i=0;i<4;i++) {int nx=x+A[i][0],ny=y+A[i][1];if (nx>=0 && nx<N && ny>=0 && ny<M && RB[nx][ny]=='.') bfs(nx,ny);}}\nint main() {int i,j;while (1) {scanf(\"%d %d\",&M,&N);if (!N && !M) return 0;for (i=0;i<N;scanf(\"%s\",&RB[i++]));ans=0;for (i=0;i<N;i++) for (j=0;j<M;j++) if (RB[i][j]=='@') bfs(i,j);printf(\"%d\\n\",ans);}}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAX_W 20\n#define MAX_H 20\n\nusing namespace std;\n\nchar field[MAX_H][MAX_W];\nint W, H, count;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int x, int y)\n{\n  for(int i = 0; i < 4; i++)\n    {\n      int nx, ny;\n      nx = x + dx[i], ny = y + dy[i];\n      if(nx >= 0 && nx < H && ny >= 0 && ny < W && field[nx][ny] == '.')\n\t{\n\t  field[nx][ny] = '#';\n\t  count++;\n\t  dfs(nx, ny);\n\t}\n    }\n  return;\n}\n\nvoid solve()\n{\n  int sx, sy;\n  count = 0;\n  //????§????????????¢???\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++)\n      if(field[i][j] == '@')\n      {\n\tsx = i; sy = j;\n\tbreak;\n      }\n  //???????????¨?????????'#'??????????????????\n  field[sx][sy] = '#';\n  count++;\n\n  //??±???????????¢?´¢??§????§??????????????§??????§????????????????????°?????°??????\n  dfs(sx, sy);\n}\n\nint main()\n{\n  while(1)\n  {\n    scanf(\"%d %d\\n\", &W, &H);\n    if( W == 0 && H == 0) break;\n    //??°?????????????????°field????????????\n    for(int i = 0; i < MAX_H; i++)\n      for(int j = 0; j < MAX_W; j++)\n\tfield[i][j] = 'X';\n    for(int i = 0; i < H; i++)\n    {\n      scanf(\"%s\",field[i]);\n    }\n    solve();\n    printf(\"%d\\n\", count);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define var auto\n#define ll long long\n\nusing namespace std;\n\nint ans = 0;\nint h, w;\nvector<string> grid;\nvector<vector<bool>> arrived;\nvoid dfs(int y, int x) {\n\tif (y < 0 || h <= y || x < 0 || w <= x) return;\n\tif (grid[y][x] == '#') return;\n\tif (arrived[y][x])return;\n\tarrived[y][x] = true;\n\tans++;\n\tdfs(y - 1, x);\n\tdfs(y, x + 1);\n\tdfs(y + 1, x);\n\tdfs(y, x - 1);\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\t\tgrid = vector<string>(h);\n\t\tarrived = vector<vector<bool>>(20, vector<bool>(20, false));\n\t\tans = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> grid[i];\n\t\t}\n\t\tint sy, sx;\n\t\tfor (int i = 0; i < h; i++) {;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (grid[i][j] == '@') {\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sy, sx);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W, H;\nchar c[100][101];\nbool visited[100][100];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid computer(){\n    memset(visited,false,sizeof visited);\n    queue<int> que;\n    int i, j;\n    for(i=0;i<H;i++){\n        for(j=0;j<W;j++){\n            if(c[i][j]=='@'){\n                que.push(j+i*W);\n                visited[i][j] = true;\n                goto Skip;\n            }\n        }\n    }\nSkip:;\n    \n    int answer = 1;\n    while( !que.empty()){\n        int cur = que.front(); que.pop();\n        int x = cur % W, y = cur / W;\n        \n        for(i=0;i<4;++i){\n            int nx = x + dx[i],ny = y + dy[i];\n            if(!(0<=nx && nx < W && 0<=ny && ny<H))continue;\n            if(c[ny][nx]=='#' || visited[ny][nx])continue;\n            que.push(nx+ny*W);\n            visited[ny][nx]=true;\n            ++answer;\n        }\n        \n        \n        \n    }\n    \n    cout << answer << endl;\n    \n    \n}\n\n// abcdd\n// efgeg\n\nint main(){\n    while(cin >> W >> H, W==0&&H==0){\n        int i;\n        for(i=0;i<H;++i){\n            //cin >> c[i][0];\n            scanf(\" %s\",&c[i][0]);\n        }\n        computer();\n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace\tstd;\nstatic int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nint h,w,r;\nstring s[20];\nvoid dfs(int y,int x){\n  r++;\n  s[y][x]='#';\n  for(int i=0;i<4;i++)\n      if(0<=y+dy[i]&&y+dy[i]<h&&0<=x+dx[i]&&x+dx[i]<w)\n\tif(s[y+dy[i]][x+dx[i]]=='.') dfs(y+dy[i],x+dx[i]);\n}\nint main(){\n\n  int y,x;\n  for(;cin>>w>>h,w;){\n  r=0;\n  for(int i=0;i<h;i++) cin>>s[i];\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) if(s[i][j]=='@') y=i,x=j;\n  dfs(y,x);\n  cout<<r<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\ntypedef pair<int, int> pxy;\n\nchar map[20][20];\n\nint W, H, start_x, start_y, ans = 0;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid dfs(int sx, int sy)\n{\n  stack<pxy> s;\n  s.push(pxy(sx, sy));\n  while(!s.empty()){\n    int x, y;\n    x = s.top().first;\n    y = s.top().second;\n    s.pop();\n    if(map[x][y] != '#'){\n      ans++;\n      map[x][y] = '#';\n      for(int i = 0; i < 4; i++){\n\tint next_x = x + dx[i], next_y = y + dy[i];\n\tif(next_x < W && next_x >= 0 && next_y < H && next_y >= 0){\n\t  s.push(pxy(next_x, next_y));\n\t}\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    cin >> W >> H;\n    if(W == 0 && H == 0){\n      break;\n    }else{\n      for(int i = 0; i < H; i++){\n\tfor(int j = 0; j < W; j++){\n\t  cin >> map[j][i];\n\t  if(map[j][i] == '@'){\n\t    start_x = j;\n\t    start_y = i;\n\t  }\n\t}\n      }\n      dfs(start_x, start_y);\n      cout << ans << endl;\n      ans = 0;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w, h, sx, sy;\nchar t[22][22];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid solve(){\n  stack<P> open;\n  int ans = 0;\n\n  open.push(P(sx, sy));\n  t[sy][sx] = '#';\n\n  while(!open.empty()){\n    P p = open.top();\n    open.pop();\n    ans++;\n\n    for(int i = 0; i < 4; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n\n      if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] != '.') continue;\n      t[ny][nx] = '#';\n      open.push(P(nx, ny));\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n      for(int j = 0; j < w; j++){\n        if(t[i][j] == '@'){\n          sx = j;\n          sy = i;\n          t[i][j] = '.';\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint w,h;\nstring g[100];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint dfs(int y, int x){\n  g[y][x] = '#';\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int ny = y+dy[i], nx = x+dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(g[ny][nx] == '.')res += dfs(ny,nx);\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == '@')cout << dfs(i,j) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    int w,h;\n    while (cin>>w>>h) {\n        if (w==0&&h==0) {\n            break;\n        } else {\n            std::vector<vector<char>> vec(h,vector<char>(w));\n            bool seen[h][w];\n            char c;\n            int now_H,now_W;\n            for (int i=0;i<h;i++) {\n                for (int j=0;j<w;j++) {\n                    cin>>c;\n                    vec[i][j]=c;\n                    if (c=='@') {\n                        now_H=i;\n                        now_W=j;\n                        seen[i][j]=true;\n                    } else {\n                        seen[i][j]=false;\n                    }\n                }\n            }\n            int count=1;\n            std::deque<pair<int,int>> place;\n            place.emplace_back(make_pair(now_H,now_W));\n            while (place.size()!=0) {\n                int tmp_H=place.front().first;\n                int tmp_W=place.front().second;\n                if (tmp_H+1<h&&seen[tmp_H+1][tmp_W]==false&&vec[tmp_H+1][tmp_W]!='#'&&vec[tmp_H+1][tmp_W]!='@') {\n                    tmp_H++;\n                    seen[tmp_H][tmp_W]=true;\n                    place.emplace_back(make_pair(tmp_H,tmp_W));\n                    count++;\n                } else if (tmp_H-1>=0&&seen[tmp_H-1][tmp_W]==false&&vec[tmp_H-1][tmp_W]!='#'&&vec[tmp_H-1][tmp_W]!='@') {\n                    tmp_H--;\n                    seen[tmp_H][tmp_W]=true;\n                    place.emplace_back(make_pair(tmp_H,tmp_W));\n                    count++;\n                } else if (tmp_W+1<w&&seen[tmp_H][tmp_W+1]==false&&vec[tmp_H][tmp_W+1]!='#'&&vec[tmp_H][tmp_W+1]!='@') {\n                    tmp_W++;\n                    seen[tmp_H][tmp_W]=true;\n                    place.emplace_back(make_pair(tmp_H,tmp_W));\n                    count++;\n                } else if (tmp_W-1>=0&&seen[tmp_H][tmp_W-1]==false&&vec[tmp_H][tmp_W-1]!='#'&&vec[tmp_H][tmp_W-1]!='@') {\n                    tmp_W--;\n                    seen[tmp_H][tmp_W]=true;\n                    place.emplace_back(make_pair(tmp_H,tmp_W));\n                    count++;\n                } else {\n                    place.pop_front();\n                }\n            }\n            cout<<count<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint W, H;\nchar M[22][22];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint ans;\n\nvoid dfs(int y, int x) {\n    if (M[y][x] == '#' || M[y][x] == '@') { return; }\n\n    ans++;\n    M[y][x] = '@';\n    for (int i = 0; i < 4; i++) {\n        dfs(y + dy[i], x + dx[i]);\n    }\n}\n\nint solve() {\n    int sx, sy;\n    for (sy = 1;; sy++) {\n        for (sx = 1; sx <= W; sx++) {\n            if (M[sy][sx] == '@') { goto found; }\n        }\n    }\nfound:\n\n    ans = 0;\n    M[sy][sx] = '.';\n    dfs(sy, sx);\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d \", &W, &H);\n\n        if (!W && !H) { break; }\n\n        for (int i = 0; i < 22; i++) {\n            for (int j = 0; j < 22; j++) {\n                M[i][j] = '#';\n            }\n        }\n        for (int i = 1; i <= H; i++) {\n            for (int j = 1; j <= W; j++) {\n                scanf(\"%c\", &M[i][j]);\n            }\n            char d;\n            scanf(\"%c\", &d);\n        }\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint w, h;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint dfs(vector<string>& mp, int x, int y){\n  int cnt = 0;  \n  for(int i=0;i<4;++i){\n\tint tx = x + dx[i];\n\tint ty = y + dy[i];\n\tif(tx < 0 || w <= tx || ty < 0 || h <= ty) continue;\n\tif(mp[ty][tx] == '#') continue;\n\tmp[ty][tx] = '#';\n\tcnt += dfs(mp, tx, ty) + 1;\n  }\n  return cnt;\n}\n\nint main(){\n  while(true){\n\tif(!(cin >> w >> h)) return 0;\n\tif(w == 0 && h == 0) break;\n\tvector<string> vs(h);\n\tfor(int i=0;i<h;++i)\n\t  cin >> vs[i];\n\tint x, y;\n\tfor(int i=0;i<h;++i)\n\t  for(int j=0;j<w;++j)\n\t\tif(vs[i][j] == '@') x=j, y=i;\n\tvs[y][x] = '#';\n\tcout << 1+dfs(vs,x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#define _USE_MATH_DEFINES\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\n\nstruct edge {\n    int to, cost;\n};\n\nint H, W;\nbool marked[100][100];\nint sum;\n\nvoid BFS(pii st) {\n    queue<pii> que;\n    que.push(st);\n    sum++;\n    marked[st.first][st.second] = false;\n    while (que.size() > 0) {\n        pii base = que.front();\n        que.pop();\n        int basex = base.first;\n        int basey = base.second;\n        for (int i = 0; i < 4; i++) {\n            int x = basex + dx[i];\n            int y = basey + dy[i];\n            if (x >= 0 && x < H && y >= 0 && y < W) {\n                if (marked[x][y]) {\n                    que.push(pii(x, y));\n                    sum++;\n                    marked[x][y] = false;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    while (true) {\n        cin >> W >> H;\n        if (W == 0) {\n            break;\n        }\n        for (int i = 0; i < H; i++) {\n            fill(marked[i], marked[i] + W, true);\n        }\n        pii st;\n        for (int i = 0; i < H; i++) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < W; j++) {\n                if (s[j] == '#') {\n                    marked[i][j] = false;\n                } else if (s[j] == '@') {\n                    st = pii(i, j);\n                }\n            }\n        }\n        sum = 0;\n        BFS(st);\n        cout << sum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint d[]={1,0,-1,0,1};\n\nvoid solve(int w,int h){\n    string s[h];\n    rep(i,h)cin>>s[i];\n    int sx,sy;\n    rep(i,h)rep(j,w)if(s[i][j]=='@')sx=i,sy=j;\n    queue<pair<int,int>> que;\n    que.emplace(sx,sy);\n    vector<vector<int>> used(h,vector<int>(w));\n    used[sx][sy]=1;\n    int ans=1;\n    while(que.size()){\n        int x=que.front().first,y=que.front().second;\n        que.pop();\n        rep(i,4){\n            int nx=x+d[i],ny=y+d[i+1];\n            if(nx<0||nx>=h||ny<0||ny>=w)continue;\n            if(used[nx][ny]||s[nx][ny]=='#')continue;\n            ++ans;\n            used[nx][ny]=1;\n            que.emplace(nx,ny);\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n!=0)solve(n,m);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define MAX 22\n#define INV (0)\n#define REP(i,a,e) for(int i=(a); i<=(e); ++i)\n\nvoid dfs(int map[][MAX], int i, int j, int &ans)\n{\n\tconst int di[] = {-1,0,1,0};\n\tconst int dj[] = {0,1,0,-1};\n\tif( map[i][j] == INV || map[i][j] == '#' ){\n\t\treturn ;\n\t}\n\tif( map[i][j] == '.' ){\n\t\t++ans;\n\t\tmap[i][j] = '#';\n\t}\n\tfor(int k = 0; k < 4; ++k){\n\t\tdfs( map, i + di[k], j + dj[k], ans );\n\t}\n}\n\nint main()\n{\n\twhile(true){\n\t\tint si, sj;\n\t\tint ans = 1;\n\t\tint map[MAX][MAX] = {{INV,},};\n\t\tint W,H;\n\n\t\tscanf(\"%d%d\", &W, &H);\n\n\t\tif( W == 0 && H == 0 ) break;\n\n\t\tREP(i,1,H){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\", &c);\n\t\t\tREP(j,1,W){\n\t\t\t\tscanf(\"%c\", &c);\n\t\t\t\tmap[i][j] = c;\n\t\t\t\tif( map[i][j] == '@' ){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(map,si,sj,ans);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define ALLOF(c) c.begin(), c.end()\n#define RANGEOF(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-9\n#define INF 1000000000\nusing namespace std;\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i,n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vector<vector<T>> read(int n, int m)\n{\n\tvector<vector<T>> v;\n\tREP(i,n) { v.push_back(read<T>(m)); }\n\treturn v;\n}\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss; \n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\nvoid solve();\nint main() { solve(); return 0; }\n\n/// template end ///\n\n\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, H, W);\n\t\tif (!(W|H)) { break; }\n\t\tauto field = read<string>(W);\n\t\tfor (auto &f : field) { f.insert(f.begin(), '#'); f.push_back('#'); }\n\t\tfield.insert(field.begin(), string(H+2, '#'));\n\t\tfield.push_back(string(H+2, '#'));\n\t\tW += 2; H += 2;\n\n\t\tint sx = 0, sy = 0;\n\t\tREP(x,W) REP(y,H) if (field[x][y] == '@') { sx = x; sy = y; }\n\n\t\ttypedef complex<int> P;\n\t\tqueue<P> q;\n\t\tint count = 0;\n\t\tq.push(P(sx, sy));\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tP cur = q.front(); q.pop();\n\t\t\tif (field[cur.real()][cur.imag()] == '#') { continue; }\n\t\t\tcount++;\n\t\t\tfield[cur.real()][cur.imag()] = '#';\n\t\t\tif (field[cur.real() + 1][cur.imag()] != '#') q.push(P(cur.real() + 1, cur.imag()));\n\t\t\tif (field[cur.real() - 1][cur.imag()] != '#') q.push(P(cur.real() - 1, cur.imag()));\n\t\t\tif (field[cur.real()][cur.imag() + 1] != '#') q.push(P(cur.real(), cur.imag() + 1));\n\t\t\tif (field[cur.real()][cur.imag() - 1] != '#') q.push(P(cur.real(), cur.imag() - 1));\n\t\t}\n\t\twrite(count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) FOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, s.size()) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main () {\n  cin.tie(0);\n  cout << setprecision(10);\n  vi ans;\n\n  while(1) {\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    vector<vector<char>> tiles(h);\n    P st;\n    REP(i, h) {\n      tiles[i].resize(w);\n      REP(j, w) {\n        cin >> tiles[i][j];\n        if(tiles[i][j] == '@') st = make_pair(i, j);\n      }\n    }\n    queue<P> q;\n    vector<vector<bool>> sel(h);\n    REP(i, h) {\n      sel[i].resize(w, false);\n    }\n    q.push(st);\n    sel[st.fi][st.se] = true;\n    vi dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};\n    int res = 0;\n    \n    while(!q.empty()) {\n      P now = q.front(); q.pop();\n      res++;\n      REP(i, 4) {\n        int nextx = now.fi + dx[i], nexty = now.se + dy[i];\n          \n        if(0 <= nextx && nextx <= h-1 &&\n           0 <= nexty && nexty <= w-1 &&\n           !sel[nextx][nexty] && tiles[nextx][nexty] == '.') {\n          q.push(make_pair(nextx, nexty));\n          sel[nextx][nexty] = true;\n        }\n      }\n    }\n\n    ans.pb(res);\n  }\n\n  REP(i, ans.size()) {\n    cout << ans[i] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "int main()\n{\n  int W, H, i, j, f, d, count;\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {1, 0, -1, 0};\n  char map[32][32];\n  char s[32];\n\n  while (1) {\n    gets(s);\n    sscanf(s, \"%d %d\", &W, &H); if (W == 0 && H == 0) { break; }\n    for (i = 0; i < 30; i++) {\n      strcpy(map[i], \"##############################\");\n    }\n    \n    for (i = 0; i < H; i++) {\n      gets(&map[i+1][1]);\n      map[i+1][W+1] = '#';\n      map[i+1][W+2] = '\\0';\n    }\n\n    count = 1;\n    while (1) {\n      f = 0;\n      for (i = 1; i <= H; i++) {\n        for (j = 1; j <= W; j++) {\n          if (map[i][j] == '@') {\n            for (d = 0; d < 4; d++) {\n              if (map[i+dy[d]][j+dx[d]] == '.') {\n                map[i+dy[d]][j+dx[d]] = '@';\n                count++;\n                f = 1;\n              }\n            }\n          }\n        }\n      }\n      if (!f) {\n        break;\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nint w, h;\nstring str[30];\n\nint search(int y, int x){\n\tif(x < 0 || x >= w || y < 0 || y >= h){\n\t\treturn 0;\n\t}\n\tif(str[y][x] == '#'){\n\t\treturn 0;\n\t}\n\tstr[y][x] = '#';\n\tint ret = 1;\n\tret += search(y, x - 1);\n\tret += search(y, x + 1);\n\tret += search(y - 1, x);\n\tret += search(y + 1, x);\n\treturn ret;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tint ans;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(str[i][j] == '@'){\n\t\t\t\t\tans = search(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint point(int x,int y,int w,int h){\n  int s;\n  s= y*w+x;\n  return s;\n}\n\nint point_x(int x,int w){\n  int s;\n  s=x%w;\n  return s;\n}\n\nint point_y(int x,int w){\n  int s;\n  s=x/w;\n  return s;\n}\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  while(w!=0){\n    int a[21][21]={};\n    int sx,sy;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tchar s;\n\tcin>>s;\n\tif(s=='.'){\n\t  a[i][j]=1;\n\t}else if(s=='#'){\n\t  a[i][j]=-1;\n\t}else{\n\t  a[i][j]=2;\n\t  sx=i;\n\t  sy=j;\n\t}\n      }\n    }\n\n    int d[21][21];\n    for(int i=0;i<21;i++){\n      for(int j=0;j<21;j++){\n\td[i][j]=-1;\n      }\n    }\n    queue<int>q;\n    d[sx][sy]=0;\n    int str;\n    str=point(sx,sy,w,h);\n    q.push(str);\n    while(! q.empty()){\n      int cur =q.front();\n      q.pop();\n      int x,y;\n      x=point_x(cur,w);\n      y=point_y(cur,w);\n      if(x>=1){\n\tif(a[x-1][y]==1&&d[x-1][y]==-1){\n\t  d[x-1][y]=0;\n\t  q.push(point(x-1,y,w,h));\n\t}\n      }\n      if(x<=w-2){\n\tif(a[x+1][y]==1&&d[x+1][y]==-1){\n\t  d[x+1][y]=0;\n\t  q.push(point(x+1,y,w,h));\n\t}\n      }\n      if(y>=1){\n\tif(a[x][y-1]==1&&d[x][y-1]==-1){\n\t  d[x][y-1]=0;\n\t  q.push(point(x,y-1,w,h));\n\t}\n      }\n      if(y<=h-2){\n\tif(a[x][y+1]==1&&d[x][y+1]==-1){\n\t  d[x][y+1]=0;\n\t  q.push(point(x,y+1,w,h));\n\t}\n      }\n    }\n\n    int t=0;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(d[i][j]==0){\n\t  t+=1;\n\t}\n      }\n    }\n    cout << t<< endl;\n    cin>>w>>h;\n  }\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint w, h;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tunsigned next = 1U;\n\t\tchar** room = new char*[h];\n\t\tunsigned** group = new unsigned*[h];\n\t\tint x, y;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\troom[i] = new char[w];\n\t\t\tgroup[i] = new unsigned[w];\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> room[i][j];\n\t\t\t\tif (room[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tgroup[i][j] = 0U;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\tfor (int j = w - 1; j >=0; j--) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\tif (room[i][j] != '#') {\n\t\t\t\t\tfor (int a = i - 1; a <= i + 1; a++) {\n\t\t\t\t\t\tfor (int b = j - 1; b <= j + 1; b++) {\n\t\t\t\t\t\t\tif (a < 0 || b < 0 || a >= h || b >= w) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((a == i && b != j) || (a != i && b == j)) {\n\t\t\t\t\t\t\t\tgroup[i][j] |= group[a][b];\n\t\t\t\t\t\t\t\tif (group[i][j] == 0U) {\n\t\t\t\t\t\t\t\t\tgroup[i][j] |= next;\n\t\t\t\t\t\t\t\t\tnext <<= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (group[i][j] & group[y][x]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << count << '\\n';\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tdelete[] room[i];\n\t\t\tdelete[] group[i];\n\t\t}\n\t\tdelete[] room;\n\t\tdelete[] group;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h;\nint tx[4] = {0,-1,0,1};\nint ty[4] = {-1,0,1,0};\nchar map[21][21];\n\nint slv(int x,int y){\n    map[y][x]='#';\n    int ans=0;\n    for(int i=0;i<4;++i)\n        if( x+tx[i]!=-1 || y+ty[i]!=-1 || x+tx[i]!=w || y+ty[i]!=h)\n            if( map[y+ty[i]][x+tx[i]] == '.' )\n                ans+=slv( x+tx[i], y+ty[i] ) + 1 ;\n    return ans;\n}\n\nint main()\n{\n    int ix,iy;\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        for(int i=0;i<h;++i)\n            for(int j=0;j<w;++j){\n                cin >> map[i][j];\n                if(map[i][j]=='@'){ix=j;iy=i;}\n            }\n        cout << slv( ix , iy ) + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(){\n        bool check=true;\n        int w, h, at_x, at_y;\n\n        while(1){\n                int total=1;\n                char tile[22][22] = { { 0 } };\n                scanf(\"%d %d\", &w, &h);\n                if( w == 0 && h == 0 ) break;\n                for( int i=0; i<h; i++ ){\n                        scanf(\"%s\", &tile[i+1][1]);\n                }\n                check = true;\n                while( check ){\n                        check = false;\n                        for( int y=1; y<=h; y++){\n                                for( int x=1; x<=w; x++ ){\n                                        if( tile[y][x] == '@' ){\n                                                at_x = x;\n                                                at_y = y;\n                                                if( tile[y-1][x] == '.' ){\n                                                        tile[y-1][x] = '@';\n                                                        check = true;\n                                                        total++;\n                                                }\n                                                if( tile[y+1][x] == '.' ){\n                                                        tile[y+1][x] = '@';\n                                                        check = true;\n                                                        total++;\n                                                }\n                                                if( tile[y][x-1] == '.' ){\n                                                        tile[y][x-1] = '@';\n                                                        check = true;\n                                                        total++;\n                                                }\n                                                if( tile[y][x+1] == '.' ){\n                                                        tile[y][x+1] = '@';\n                                                        check = true;\n                                                        total++;\n                                                }\n                                        }\n                                }\n                        }\n                }\n                printf(\"%d\\n\", total);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <utility>\n\nint dir[] = {0, -1, 0, 1, 0};\n\nusing namespace std;\nint main()\n{\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0 and h == 0) {\n            break;\n        }\n        vector<vector<int>> tile(h, vector<int>(w));\n        vector<vector<int>> check(h, vector<int>(w, 0));\n        int starti = 0;\n        int startj = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char c;\n                cin >> c;\n                if (c == '.') {\n                    tile[i][j] = 0;\n\n                } else if (c == '#') {\n                    tile[i][j] = -1;\n                } else {\n                    tile[i][j] = 0;\n                    starti = i;\n                    startj = j;\n                }\n            }\n        }\n\n        queue<pair<int, int>> q;\n        q.push(make_pair(starti, startj));\n        while (not q.empty()) {\n            const int pi = q.front().first;\n            const int pj = q.front().second;\n            check[pi][pj] = 1;\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                const int i_ = pi + dir[i];\n                const int j_ = pj + dir[i + 1];\n                if (i_ >= 0 and i_ < h and j_ >= 0 and j_ < w and tile[i_][j_] == 0 and check[i_][j_] == 0) {\n                    q.push(make_pair(i_, j_));\n                }\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (check[i][j] == 1) {\n                    cnt++;\n                }\n            }\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\nchar field[30][30];\nint w, h;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid init() {\n  REP(i, w) {\n    REP(j, h) {\n      field[i][j] = '?';\n    }\n  }\n}\n\nvoid trample(int x, int y) {\n  if (x < 0 or w <= x or \n      y < 0 or h <= y or \n      field[x][y] != '@') {\n    return;\n  }\n\n  REP(d, 4) {\n    int nx = x + dx[d], ny = y + dy[d];\n    if (field[nx][ny] == '.') {\n      field[nx][ny] = '@';\n      trample(nx, ny);\n    }\n  }\n}\n\nint main() {\n  while (cin >> w >> h and w) {\n    int sx, sy;\n    init();\n    REP(y, h) {\n      string row;\n      cin >> row;\n      REP(x, w) {\n        field[x][y] = row[x];\n        if (row[x] == '@') {\n          sx = x, sy = y;\n        }\n      }\n    }\n\n    trample(sx, sy);\n\n    int accessible = 0;\n    REP(y, h) {\n      REP(x, w) {\n        if (field[x][y] == '@') {\n          accessible++;\n        }\n      }\n    }\n    cout << accessible << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<set>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define MOD 1000000007\n\nchar field[25][25];\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint W, H;\nint ans;\n\nvoid dfs(int x, int y) {\n  field[y][x] = '#';\n  ans++;\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\tif (1 <= nx&&nx <= W && 1 <= ny&&ny <= H&&field[ny][nx] == '.')dfs(nx, ny);\n  }\n  return;\n}\n\nint main() {\n  while (1) {\n\tcin >> W >> H;\n\tif (H == 0 && W == 0)return 0;\n\tint sx, sy;\n\tmemset(field, 0, sizeof(field));\n\tans = 0;\n\tfor (int i = 1; i <= H; i++) {\n\t  for (int j = 1; j <= W; j++) {\n\t\tcin >> field[i][j];\n\t\tif (field[i][j] == '@') {\n\t\t  sy = i;\n\t\t  sx = j;\n\t\t}\n\t  }\n\t}\n\tdfs(sx, sy);\n\tcout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring s[21];\nint w, h, vx[4] = {1, 0, -1, 0}, vy[4] = {0, 1, 0, -1};\nbool is_search[21][21];\n\nint dfs(int x, int y) {\n  //cout << x << \" \" << y << endl;\n  is_search[x][y] = true;\n  int ret = 0, cnt = 0;\n  for(int i = 0; i < 4; ++i) {\n    if(0 <= x+vx[i] && 0 <= y+vy[i] && x+vx[i] < h && y+vy[i] < w && s[x+vx[i]][y+vy[i]] != '#' && is_search[x+vx[i]][y+vy[i]] == false) {\n      ret += dfs(x+vx[i], y+vy[i]);\n      cnt++;\n    }\n  }\n  //cout << ret+cnt << endl;\n  return ret + cnt;\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int ans, sx, sy;\n  bool flag;\n\n  while(cin >> w >> h, w | h) {\n    ans = 0; flag = false;\n    for(int i = 0; i < h; ++i) fill(is_search[i], is_search[i] + w, false);\n    for(int i = 0; i < h; ++i) cin >> s[i];\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        if(s[i][j] == '@') {\n          sx = i; sy = j;\n          flag = true;\n          break;\n        }\n      }\n      if(flag) break;\n    }\n\n    ans = dfs(sx, sy) + 1;\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 21\n\nstring str[MAX];\nint n,m,cnt,dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\nvoid dfs(int x,int y){\n  str[x][y] = '#';\n\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + dx[i] , ny = y + dy[i];\n    if(0 <= nx && nx < m && 0 <= ny && ny < n){\n      if(str[nx][ny] == '.'){\n\tcnt++;\n\tdfs(nx,ny);\n      }\n    }\n  }\n\n  return;\n}\n\nint main(){\n  while(cin >> n >> m , n + m){\n    for(int i = 0 ; i < m ; i++)\n      cin >> str[i];\n    \n    int x,y;\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < m ; j++){\n\tif(str[j][i] == '@'){\n\t  x = j;\n\t  y = i;\n\t  break;\n\t}\n      }\n    }\n    cnt = 1;\n    dfs(x,y);\n    cout << cnt << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint W,H;\nint x[4]={0,0,1,-1};\nint y[4]={1,-1,0,0};\nint i,j;\nint count=0;\nchar room[100][100];\n\nint dfs(int, int);\n\nint main(){\n  while(1){\n    int sy,sx;\n    scanf(\"%d %d\",&W,&H);\n    if(W==0&&H==0)break;\n    for(i = 0 ; i < H ; i++){\n      scanf(\"%c\",&room[i][0]);\n      for(j = 0 ; j < W ; j++){\n\tscanf(\"%c\",&room[i][j]);\n\tif(room[i][j] == '@'){\n\t  sy = i;\n\t  sx = j; \n\t}\n      }\n    }\n    printf(\"%d\\n\", dfs(sx,sy));\n  }\n  return 0;\n}\n\nint dfs(int ax,int ay){\n  if(ax<0||ay<0)return 0;\n  if(ax>=W||ay>=H)return 0;\n  if(room[ay][ax]=='#')return 0;\n  room[ay][ax]='#';\n  int cnt=1;\n  int i;\n  for(i=0;i<4;i++){\n    int nx=ax+x[i];\n    int ny=ay+y[i];\n    cnt+=dfs(nx,ny);\n  }\n  return cnt;\n  /*\n    for(i = 0 ; i < 4 ; i++){\n    int nx=ax+x[i]; int ny=ay+y[i];\n    if(nx>0&&nx<W&&ny>0&&ny<H&&room[ax][ay]=='-'){\n    dfs(nx,ny);\n    count++;\n    }else if(nx>0&&nx<W&&ny>0&&ny<H&&room[ax][ay]=='#'){\n    dfs(ax,ay);\n    }\n    }\n    printf(\"%d\\n\",count);\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define Getsign(n) ((n > 0) - (n < 0))\n\ntypedef vector<int> Ivec;\ntypedef pair<int, int> pii;\nconst pii eight_Dir[4] = { //?????????\n\t{ 0 ,1 },\n\t{ -1 ,0 },{ 1 ,0 },\n\t{ 0 ,-1 }\n};\n//pii operator+ (pii a, pii b){return { a.first + b.first, a.second + b.second };}\n//pii operator- (pii a, pii b) { return { a.first - b.first, a.second - b.second }; }\n//pii operator* (pii a, pii b) { return{ a.first * b.first, a.second * b.second }; }\n//pii operator/ (pii a, pii b) { return{ a.first / b.first, a.second / b.second }; }\n//pii operator% (pii a, pii b) { return{ a.first % b.first, a.second % b.second }; }\n\nint main() {\n\tint w, h;\n\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (w == 0)\n\t\t\treturn 0;\n\n\t\tarray<array<bool, 22>, 22> map = {}, al = {};\n\t\tqueue<pii> que;\n\t\tfor (int i = 1; h >= i; i++) {\n\t\t\tscanf(\"%*c\");\n\t\t\tfor (int j = 1; w >= j; j++) {\n\t\t\t\tchar a;\n\t\t\t\tscanf(\"%c\", &a);\n\n\t\t\t\tif (a == '@') {\n\t\t\t\t\tque.push({j,i});\n\t\t\t\t\tal[j][i] = true;\n\t\t\t\t\tmap[j][i] = true;\n\t\t\t\t}\n\t\t\t\telse if (a == '.') {\n\t\t\t\t\tmap[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cou = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpii pos = que.front();\n\t\t\tque.pop();\n\t\t\tcou++;\n\t\t\tfor (int i = 0; 4 > i; i++) {\n\t\t\t\tif (!al[pos.first + eight_Dir[i].first][pos.second + eight_Dir[i].second] && map[pos.first + eight_Dir[i].first][pos.second + eight_Dir[i].second]) {\n\t\t\t\t\tal[pos.first + eight_Dir[i].first][pos.second + eight_Dir[i].second] = true;\n\t\t\t\t\tque.push({ pos.first + eight_Dir[i].first,pos.second + eight_Dir[i].second});\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", cou);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nll dx[] = {1, -1, 0, 0};\nll dy[] = { 0,0,1,-1 };\nll W, H;\nll cnt;\nchar field[100][100];\nvoid dfs(ll y, ll x) {\n\tfield[y][x] = '#';\n\tfor (ll k = 0; k < 4; k++) {\n\t\tll ny = y + dy[k];\n\t\tll nx = x + dx[k];\n\t\tif (ny >= 0 && ny <H && nx >= 0 && nx < W) {\n\t\t\tif (field[ny][nx] == '.')\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tdfs(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\twhile (cin >> W >> H) {\n\t\tif (W == 0 && H == 0) { break; }\n\t\tcnt = 1;\n\t\tfor (ll i = 0; i < H; i++) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tfor (ll i = 0; i < H; i++) {\n\t\t\tfor (ll j = 0; j < W; j++) {\n\t\t\t\tif (field[i][j] == '@') {\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace  std;\n\nchar field[22][22];\nint count;\nvoid init()\n{\n\tfor(int i=0;i<22;i++){\n\t\tfor(int j=0;j<22;j++){\n\t\t\tfield[i][j] = '#';\n\t\t}\n\t}\n\tcount = 0;\n}\n\nvoid DFS(int x,int y)\n{\n\tcount++;\n\tfield[y][x] = '#';\n\tif(field[y][x+1] == '.')\n\t\tDFS(x+1,y);\n\tif(field[y+1][x] == '.')\n\t\tDFS(x,y+1);\n\tif(field[y][x-1] == '.')\n\t\tDFS(x-1,y);\n\tif(field[y-1][x] == '.')\n\t\tDFS(x,y-1);\n}\nint main()\n{\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tif(!w && !h){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\tint x,y;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> field[i+1][j+1];\n\t\t\t\tif(field[i+1][j+1] == '@'){\n\t\t\t\t\tx = j+1;y = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDFS(x,y);\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nvector<int> x;\nvector<int> y;\nvector<int> nextx;\nvector<int> nexty;\nint w,h;\nint count;\nbool check(int a,int b){\n  for (int i=0;i<nextx.size();i++){\n    if (nextx[i]==a&&nexty[i]==b)\n      return false;\n  }\n  return true;\n}\nint search(int **field){\n  x.clear();\n  y.clear();\n  for (int i=0;i<nextx.size();i++){\n    x.push_back(nextx[i]);\n    y.push_back(nexty[i]);\n  }\n  nextx.clear();\n  nexty.clear();\n  for (int i=0;i<x.size();i++){\n    field[x[i]][y[i]]=0;\n    count++;\n  }\n  for (int i=0;i<x.size();i++){\n    if (field[x[i]-1][y[i]]==1&&x[i]-1>=0&&check(x[i]-1,y[i])){\n      nextx.push_back(x[i]-1);\n      nexty.push_back(y[i]);\n    }\n    if (field[x[i]+1][y[i]]==1&&x[i]+1<h&&check(x[i]+1,y[i])){\n      nextx.push_back(x[i]+1);\n      nexty.push_back(y[i]);\n    }\n    if (field[x[i]][y[i]-1]==1&&y[i]-1>=0&&check(x[i],y[i]-1)){\n      nextx.push_back(x[i]);\n      nexty.push_back(y[i]-1);\n    }\n    if (field[x[i]][y[i]+1]==1&&y[i]+1<w&&check(x[i],y[i]+1)){\n      nextx.push_back(x[i]);\n      nexty.push_back(y[i]+1);\n    }\n  }\n  if (nextx.empty()){\n    return -1;\n  }\n  int *f[h];\n  for (int i=0;i<h;i++)\n    f[i]=field[i];\n  return search(f);\n}\nint main(){\n  string temp;\n  while (cin>>w>>h,w|h!=0){\n    count=0;\n    int field[h][w];\n    for (int i=0;i<h;i++){\n      cin>>temp;\n      for (int j=0;j<w;j++){\n\tif (temp[j]=='.')\n\t  field[i][j]=1;\n\tif (temp[j]=='#')\n\t  field[i][j]=0;\n\tif (temp[j]=='@'){\n\t  field[i][j]=1;\n\t  nextx.push_back(i);\n\t  nexty.push_back(j);\n\t}\n      }\n    }\n    int *f[h];\n    for (int i=0;i<h;i++)\n      f[i]=field[i];\n    search(f);\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint W,H;\nint m,n;\nint counts;\nstruct test\n{\n    char c;\n    int flag;\n    int x;\n    int y;\n};\nqueue<test>Q;\nint main()\n{\n    cin>>W>>H;\n    while(W!=0 && H!=0)\n    {\n        counts=0;\n        test A[H][W];\n        for(int i=0;i<H;i++)\n            for(int j=0;j<W;j++)\n            {\n                cin>>A[i][j].c;\n                A[i][j].flag=0;\n                A[i][j].x=i;\n                A[i][j].y=j;\n                if(A[i][j].c=='@')\n                {\n                    m=i;\n                    n=j;\n                }\n            }\n        Q.push(A[m][n]);\n        counts++;\n        A[m][n].flag=1;\n        while(!Q.empty())\n        {\n            test p=Q.front();\n            if(p.x-1>=0 && p.y>=0 && p.x-1<H && p.y<W && A[p.x-1][p.y].c=='.' && A[p.x-1][p.y].flag==0)\n            {\n                Q.push(A[p.x-1][p.y]);\n                A[p.x-1][p.y].flag=1;\n                counts++;\n            }\n            if(p.x>=0 && p.y-1>=0 && p.x<H && p.y-1<W && A[p.x][p.y-1].c=='.' && A[p.x][p.y-1].flag==0)\n            {\n                Q.push(A[p.x][p.y-1]);\n                A[p.x][p.y-1].flag=1;\n                counts++;\n            }\n            if(p.x+1>=0 && p.y>=0 && p.x+1<H && p.y<W && A[p.x+1][p.y].c=='.' && A[p.x+1][p.y].flag==0)\n            {\n                Q.push(A[p.x+1][p.y]);\n                A[p.x+1][p.y].flag=1;\n                counts++;\n            }\n            if(p.x>=0 && p.y+1>=0 && p.x<H && p.y+1<W && A[p.x][p.y+1].c=='.' && A[p.x][p.y+1].flag==0)\n            {\n                Q.push(A[p.x][p.y+1]);\n                A[p.x][p.y+1].flag=1;\n                counts++;\n            }\n            Q.pop();\n        }\n        cout<<counts<<endl;\n        cin>>W>>H;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstdint>\n#include <sys/time.h>\n\ntypedef std::int_fast32_t  s32;\ntypedef std::uint_fast32_t u32;\ntypedef std::int_fast64_t  s64;\ntypedef std::uint_fast64_t u64;\n\ntypedef std::pair<int, int> P;\n\nint main(void) {\n\n  for(;;) {\n    int W, H;\n    std::cin >> W >> H;\n    if( W == 0 and H == 0 ) break;\n    \n    std::string str[32];\n    for(int i = 0; i < H; ++i) {\n      std::cin >> str[i];\n    }\n\n    P begin;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if( str[i][j] == '@' ) {\n          begin = P(i, j);\n          str[i][j] = '.';\n        }\n      }\n    }\n    \n    std::queue<P> q;\n    q.push(begin);\n    while( not q.empty() ) {\n      P p = q.front(); q.pop();\n      if( not ( 0 <= p.first and p.first < H and 0 <= p.second and p.second < W ) ) continue;\n      if( str[p.first][p.second] != '.' ) continue; \n\n      str[p.first][p.second] = '*';\n\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};\n      for(int i = 0; i < 4; ++i) {\n        q.push( P(p.first + dx[i], p.second + dy[i]) );\n      }\n    }\n\n    int res = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if( str[i][j] == '*' ) {\n          res += 1;\n        }\n      }\n    }\n\n    std::cout << res << std::endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "main = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = (w, filter is_nonred (zip [0.. ] (concat tss))) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n    is_nonred (_,c) = c /= '#'\n\nred_black (w,ts) = length (filter is_scanned (until_fix scan ts))\n where\n  is_scanned (_,c) = c == '@'\n  scan ts' = map paint ts'\n   where\n    paint (i,c) = if c == '.' && is_adjacent i then (i,'@') else (i,c)\n    is_adjacent i = any (\\i' -> lookup i' ts' == Just '@') neighbors\n     where\n      neighbors = filter is_inborder [i-1,i+1,i-w,i+w]\n      is_inborder i' = div i' w == div i w || abs (i'-i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Sequence as S\n\nmain = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = ((w,h), S.fromList (zip [0..] (concat tss))) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n\nred_black ((w,h),ts) = S.length (S.filter is_scanned (until_fix scan ts))\n where\n  is_nonreach (_,c) = c == '.'\n  is_scanned (_,c) = c == '@'\n  replace (i,'.') = (i,'@')\n  scan ts' = fmap paint ts'\n   where\n    paint t = if is_nonreach t && is_adjacent t then replace t else t\n    is_adjacent (i,_) = (not . S.null) (S.filter is_scanned neighbors)\n     where\n      neighbors = S.filter (\\(i',_) -> elem i' [i-1,i+1,i-w,i+w] && is_inborder i') ts'\n      is_inborder i' = div i' w == div i w || abs (i' - i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>), (<*), (*>), (<$))\nimport Control.Monad\nimport Data.List\nimport Data.Array.Unboxed\n\nmain :: IO ()\nmain = do\n  [w, h] <- getl $ wrds toInt\n  unless (w == 0 && h == 0) $ do\n    solve w h <$> replicateM h getLine >>= print\n    main\n\nsolve :: Int -> Int -> [String] -> Int\nsolve w h xs = length $ filter (\\a -> snd a == '@') $ assocs $ search (iar // [(ipt,'.')]) ipt\n  where\n    iar = array ((0,0),(w-1,h-1)) [((i,j), xs !! j !! i) | i <- [0..w-1], j <- [0..h-1]] :: UArray (Int,Int) Char\n    ipt = fst $ maybe ((-1,-1),'x') id $ find (\\a -> snd a == '@') $ assocs iar\n    search :: UArray (Int, Int) Char -> (Int, Int) -> UArray (Int, Int) Char\n    search ar (i,j)\n      | ar ! (i,j) == '.' = foldl search (ar // [((i,j),'@')]) ixs\n      | otherwise = ar\n      where\n        ixs = [(ii,jj) | (ii,jj) <- [(i+1,j),(i-1,j),(i,j+1),(i,j-1)], ii >= 0, ii < w, jj >= 0, jj < h]\n\ntoInt :: String -> Int\ntoInt = read\n\nwrds :: (String -> a) -> String -> [a]\nwrds f = map f . words\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine"
  },
  {
    "language": "Haskell",
    "code": "{-\nURL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n?????????: Red and Black\n?????°\n19:08:06 ??¶?´???????????????§Haskell??§??????????????????\n19:17:53 ??¨??????????????????????????¨?????´??°??????bar???????£?????????????\n19:32:19 ????????????\n19:34:02 ??????fmap???????????????\n19:35:56 AC??????????????£??????\n19:36:06 ?????????????????¨????????????????????§????§£??¬????????????????????????\n-}\nimport Control.Monad\nimport Control.Applicative\nimport Data.List\n\nmain :: IO ()\nmain = do\n [w,h] <- (map read . words) `fmap` getLine -- w??¨h??????\n when ((w,h) /= (0,0)) $ do -- (0,0)??§????????????????????°\n  arr <- replicateM h getLine -- ??°?????????\n  print $ foo arr\n  main\n\ntype Stat = (Integer, [[Char]])\n\n\n\nfoo :: [[Char]] -> Int -- ??????????????????\"@\"?????£??\\??????\".\"?????§????????????\"@\"??????????????????\"@\"????????°?????????\nfoo arr = sum $ map(length . (filter (=='@'))) $ snd $ repetitive bar (1,arr)\n\nrepetitive :: Eq t => (t -> t) -> t -> t --??????????????????????????§?????¨????????????????±???????\nrepetitive f s = if f s == s then s else repetitive f (f s)\n\nbar :: Stat -> Stat -- \"@\"????????????\".\"???\"@\"?????????\nbar = f . f\n where f = fmap transpose . bar1 \".@\" . bar1 \"@.\" -- ???????????????????????????????????????????????????????????¨??¢???\n\nbar1 :: String -> Stat -> Stat -- replace all `bef` with \"@@\", while counting the num\nbar1 bef (num, dat) = (num + sum(map fst d'), map snd d')\n where \n  d' = map f dat -- ???????????????????????¨?????°????????????????????§????¨?\n  f :: String -> (Integer,String)\n  f str\n   | null str = (0,\"\") -- ??????????????????0???\n   | bef `isPrefixOf` str = count $ (\"@@\" ++) `fmap` f(drop 2 str) -- ?????????2???????????´????????????????????¨???????????°?????°?¢???????\n   | otherwise = (head str :) `fmap` f (tail str) -- ??¶???????????°?????????????????????????????°\n\ncount :: (Integer,a) -> (Integer,a)\ncount(a,b)=(a+1,b)"
  },
  {
    "language": "Haskell",
    "code": "main = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = ((w,h), filter is_nonred (zip [0.. ] (concat tss))) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n    is_nonred (_,c) = c /= '#'\n\nred_black ((w,h),ts) = length (filter is_scanned (until_fix scan ts))\n where\n  is_scanned (_,c) = c == '@'\n  is_nonreach (_,c) = c == '.'\n  replace (i,'.') = (i,'@')\n  scan ts' = map paint ts'\n   where\n    paint t = if is_nonreach t && is_adjacent t then replace t else t\n    is_adjacent (i,_) = (not.null) (filter is_scanned neighbors)\n     where\n      neighbors = filter (\\(i',_) -> elem i' [i-1,i+1,i-w,i+w] && is_inborder i') ts'\n      is_inborder i' = div i' w == div i w || abs (i' - i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "main = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = ((w,h), zip [0.. ] (concat tss)) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n\nred_black ((w,h),ts) = length (filter is_scanned (until_fix scan ts))\n where\n  is_scanned (_,c) = c == '@'\n  is_nonreach (_,c) = c == '.'\n  replace (i,'.') = (i,'@')\n  scan ts' = map paint ts'\n   where\n    paint t = if is_nonreach t && is_adjacent t then replace t else t\n    is_adjacent (i,_) = (not.null) (filter is_scanned neighbors)\n     where\n      neighbors = filter (\\(i',_) -> elem i' [i-1,i+1,i-w,i+w] && is_inborder i') ts'\n      is_inborder i' = div i' w == div i w || abs (i' - i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Sequence as S\n\nmain = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = ((w,h), S.fromList (zip [0..] (concat tss))) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n\nred_black ((w,h),ts) = S.length (S.filter is_scanned (until_fix scan ts))\n where\n  is_nonreach (_,c) = c == '.'\n  is_scanned (_,c) = c == '@'\n  replace (i,'.') = (i,'@')\n  scan ts' = fmap paint ts'\n   where\n    paint t = if is_nonreach t && is_adjacent t then replace t else t\n    is_adjacent (i,_) = (not.null) (S.filter is_scanned neighbors)\n     where\n      neighbors = S.filter (\\(i',_) -> elem i' [i-1,i+1,i-w,i+w] && is_inborder i') ts'\n      is_inborder i' = div i' w == div i w || abs (i' - i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\n\nmain = interact $ unlines . map (show . red_black) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = (w, filter is_nonred (zip [0.. ] (concat tss))) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (tss,xs') = splitAt h xs\n    is_nonred (_,c) = c /= '#'\n\nred_black :: (Int, [(Int,Char)]) -> Int\nred_black (w,ts) = length (filter is_scanned (until_fix scan ts))\n where\n  is_scanned (_,c) = c == '@'\n  scan ts' = map paint ts'\n   where\n    paint (i,c) = if c == '.' && is_adjacent i then (i,'@') else (i,c)\n    is_adjacent i = any (\\i' -> lookup i' ts' == Just '@') neighbors\n     where\n      neighbors = filter is_inborder [i-1,i+1,i-w,i+w]\n      is_inborder i' = div i' w == div i w || abs (i'-i) == w\n\nuntil_fix f x = if f x == x then x else until_fix f (f x)"
  },
  {
    "language": "Haskell",
    "code": "{-\nURL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1130&lang=jp\n?????????: Red and Black\n?????°\n19:08:06 ??¶?´???????????????§Haskell??§??????????????????\n19:17:53 ??¨??????????????????????????¨?????´??°??????bar???????£?????????????\n19:32:19 ????????????\n19:34:02 ??????fmap???????????????\n-}\nimport Control.Monad\nimport Control.Applicative\nimport Data.List\n\nmain :: IO ()\nmain = do\n [w,h] <- (map read . words) `fmap` getLine\n when ((w,h) /= (0,0)) $ do\n  arr <- replicateM h getLine\n  print $ foo arr\n  main\n\ntype Stat = (Integer, [[Char]])\n\nfoo :: [[Char]] -> Integer\nfoo arr = fst $ repetitive bar (1,arr)\n\nrepetitive :: Eq t => (t -> t) -> t -> t --??????????????????????????§?????¨????????????????±???????\nrepetitive f s = if f s == s then s else repetitive f (f s)\n\nbar :: Stat -> Stat -- \"@\"????????????\".\"???\"@\"?????????\nbar = f . f\n where f = fmap transpose . bar1 \".@\" . bar1 \"@.\"\n\nbar1 :: String -> Stat -> Stat -- replace all `bef` with \"@@\", while counting the num\nbar1 bef (num, dat) = (num + sum(map fst d'), map snd d')\n where \n  d' = map f dat\n  f :: String -> (Integer,String)\n  f str\n   | null str = (0,\"\")\n   | bef `isPrefixOf` str = count $ (\"@@\" ++) `fmap` f(drop 2 str)\n   | otherwise = (head str :) `fmap` f (tail str)\n\ncount :: (Integer,a) -> (Integer,a)\ncount(a,b)=(a+1,b)"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n           if(!i) for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[50][50];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h)return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* ***************************\n   ??????????§????\n   ???????????????\n   ?????\\???????????¨?????????????????¢?´¢\n   *************************** */\n\n#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ?????\\?????¨ ?§???????\ntypedef struct _que {\n  struct _que *next;\n  struct _que *prev;\n  Coord point;\n} *que, queelem;\n\ntypedef struct {\n  que head;\n  que tail;\n} *queue, queueelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_bf (int W, int H, Coord start);\nvoid display_map (int W, int H);\n\n// ?????\\?????¨\nqueue new_queue (void);\nint is_empty (queue);\nint enqueue (queue, Coord);\nCoord dequeue (queue);\n\n// main ??¢??°\nint main () {\n  int W, H;\n  while(1){\n    scanf(\"%d%d\", &W, &H);\n    // printf(\"%d %d\",W,H);\n    if(W==0&&H==0){\n      break;\n    }else{\n      printf(\"%d\\n\", solve(W,H));\n    }\n  }\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  // ??????????????°?????¨??? (??¬??\\???????????????)\n  // printf(\"??????????????°??? [%d, %d]\\n\\n\", start.row, start.col);\n\n  // ?????£?????°??????????????? 1, ????????§???????????? 0\n  return search_bf(W, H, start);\n}\n\nint search_bf (int W, int H, Coord start) {\n  queue Q = new_queue ();  // ?¨??????????????????????????????\\???\n  int count=1;\n  // ??????????????°???????¨????\n  enqueue(Q, start);                           // ??????????????°?????? enqueue\n  // ??¢?´¢\n  while (!is_empty(Q)) {\n    Coord current = dequeue(Q);                // dequeue ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    //printf(\"?????¨??°??? [%d, %d]\\n\", current.row, current.col);  // ??¬??\\???????????????\n    //display_map(W, H); // ?????¨??????????????¨??? (??¬??\\???????????????)\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      // ????????§???????????????\n      if('.'==M[nc.row+D1[d]][nc.col+D2[d]]){\n\tCoord coo;//queue???????´????????????????Coord????????°coo\n\tcoo.row=nc.row+D1[d];\n\tcoo.col=nc.col+D2[d];\n\tenqueue(Q,coo);\n\tM[nc.row+D1[d]][nc.col+D2[d]]='*';\n\tcount++;\t//?????§????????£?????´??????*????????´\n      }\n    }\n  }\n  return count;  // ??°??????????????¨????????´????????¢?´¢?????? \n}\n\nvoid display_map (int W, int H) {;\n  int i, j;\n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      printf(\"%c\", M[i][j]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\n\n/* ??°???????????\\???????¢?????????????????????? */\nqueue new_queue (void) {\n  queue q;\n  q = (queue) malloc (sizeof (queueelem));\n  if (q == NULL) return NULL;\n  q->head = NULL;\n  q->tail = NULL;\n  return q;\n}\n    \n/* ?????\\??????????????????????????? */\nint is_empty (queue q) {\n  return (q && q->head == NULL);\n}\n\n/* ??°??????????´?????????\\???????????? */\nint enqueue (queue q, Coord v) {\n  que p;\n  if (q == NULL) return 0;\n  p = (que) malloc (sizeof(queelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = NULL;\n  if (q->tail) {\n    p->prev = q->tail;\n    q->tail->next = p;\n  } else {\n    /* queue ?????? */\n    p->prev = NULL;\n    q->head = p;\n  }\n  q->tail=p;\n  return 1;\n}\n\n/* ?????\\????????????????´???????????????? */\nCoord dequeue (queue q) {\n  que p;\n  Coord v = q->head->point;\n  p = q->head;\n  if (p->next == NULL) {\n    q->head = NULL;\n    q->tail = NULL;\n  } else {\n    q->head = q->head->next;\n    q->head->prev = NULL;\n  }\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor (i = 0; i<4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void) {\n\tchar a;\n\tint i, j, x, y;\n\twhile(1){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%s\", &a);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i<21; i++) {\n\t\t\tfor (j = 0; j<21; j++) {\n\t\t\t\ts[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\n\t\tfor (i = 1; i<h; i++) {\n\t\t\tfor (j = 1; j<w; j++) {\n\t\t\t\tscanf(\"%c\", &s[i][j]);\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvoid dfs(int x, int y) {\n\tint i;\n\tif (s[y][x] == '.' || s[y][x] == '@') {\n\t\tcount++;\n\t\ts[y][x] = '#';\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tchar a;\n\tint i, j, x, y;\n\twhile(1){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%c\", &a);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i<21; i++) {\n\t\t\tfor (j = 0; j<21; j++) {\n\t\t\t\ts[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\n\t\tfor (i = 1; i<h; i++) {\n\t\t\tfor (j = 1; j<w; j++) {\n\t\t\t\tscanf(\"%c\", &s[i][j]);\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%c\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\ntypedef struct {\n  int row;               \n  int col;               \n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  while (1) {\n    int W, H;\n    scanf(\"%d%d\", &W, &H);\n    if (W==0 && H==0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n  int c = 1;               // ????????????????????????????????°???????????? 1 ??§?????????\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      nc.row += D1[d];  nc.col += D2[d]; \n      if (M[nc.row][nc.col] == '.') {\n\tM[nc.row][nc.col] = '*';               // ?????°???????????°?????????\n\tc++;                                   // ???????????????????????????????????????\n\tpush(S,nc);\n      } // nc ????????¢?´¢?????? (*) ????£? (#) ?????´?????????????????????\n    } \n  }\n  return c;  // ??°??????????????????????????°?????????\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "n,m,x,y,c,gx,gy;char map[20][20];\ncheck(x,y){map[x][y]=35;c++;if(x+1<gy&&map[x+1][y]==46)check(x+1,y);if(x>0&&map[x-1][y]==46)check(x-1,y);if(y+1<gx&&map[x][y+1]==46)check(x,y+1);if(y>0&&map[x][y-1]==46)check(x,y-1);}\nmain(){for(;scanf(\"%d%d\",&gx,&gy),gx;){for(x=0;x<20;x++)for(y=0;y<20;)map[x][y++]=35;for(c=n=0;n<gy;n++){scanf(\"%s\",map[n]);for(m=0;m<gx;m++)if(map[n][m]==64)x=n,y=m;}check(x,y);printf(\"%d\\n\",c);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 20\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( ( x <= 0 && x >= w )\n    || ( y <= 0 && y >= h )\n    || d[ y ][ x ] != '.' ) return ( 0 );\n  d[ y ][ x ] = '#';\n\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx, sy;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint h,w;\nchar map[20][21];\n\nint search(int x, int y){\n  int result=1;\n  if(x<0 || x>=w||y<0 || y>=h) return 0;\n  if(map[y][x]=='#') return 0;\n  map[y][x]='#';\n  result+=search(x-1,y);\n  result+=search(x+1,y);\n  result+=search(x,y-1);\n  result+=search(x,y+1);\n\n  return result;\n}\n\nint main(){\n  int i,j;\n  int sx, sy;\n  while(scanf(\"%d%d\", &w,&h), w!=0&&h!=0){\n    for(i=0; i<h; i++){\n      scanf(\"%s\", map[i]);\n      for(j=0; j<w; j++){\n\tif(map[i][j]=='@') sx=j,sy=i;\n      }\n    }\n    printf(\"%d\\n\", search(sx,sy));\n  }\n  return 0;\n}\n\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar room[22][22];\nint dir_x[] = {0, 1, 0, -1};\nint dir_y[] = {-1, 0, 1, 0};\n\nint visit(int x, int y)\n{\n    int ret = 1;\n    room[y][x] = '#';\n    int i;\n    for(i = 0 ; i < 4; i++){\n        if(room[y + dir_y[i]][x + dir_x[i]] != '#')\n            ret += visit(x + dir_x[i], y + dir_y[i]);\n    }\n    return ret;\n}\n\nint W, H;\n\nint main(void)\n{\n    while(1){\n        scanf(\"%d %d\", &W, &H);\n        if(W == 0 && H == 0)\n            break;\n        int i, j;\n\n        int x, y;\n        for(i = 1; i <= H; i++){\n            scanf(\"%s\", &(room[i][1]));\n        }\n        for(i = 0; i <= H + 1; i++){\n            for(j = 0; j <= W + 1; j++){\n                if(i == 0 || i == H + 1 || j == 0 || j == W + 1)\n                    room[i][j] = '#';\n                if(room[i][j] == '@'){\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", visit(x, y));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar map[20][21];\nchar count[20][20];\nint s1, s2;\nvoid solve(int y, int x) {\n\tif (!count[y][x]) {\n\t\tif (map[y][x] == '.' || map[y][x] == '@') {\n\t\t\tcount[y][x] = 1;\n\t\t\tif (y < s2 - 1) solve(y + 1, x);\n\t\t\tif (y > 0) solve(y - 1, x);\n\t\t\tif (x < s1 - 1) solve(y, x + 1);\n\t\t\tif (y > 0) solve(y, x - 1);\n\t\t}\n\t}\n}\nint main() {\n\tint i, j, ans, point[2];\n\twhile (1) {\n\t\tscanf(\"%d %d\", &s1, &s2);\n\t\tif (!(s1||s2)) break;\n\t\tfor (i = 0; i < s2; i ++) scanf(\"%s\", map[i]);\n\t\tfor (i = 0; i < s2; i ++) for (j = 0; j < s1; j ++) if (map[i][j] == '@') {\n\t\t\tpoint[0] = i; point[1] = j;\n\t\t}\n\t\tfor (i = 0; i < 20; i ++) for (j = 0; j < 20; j ++) count[i][j] = 0;\n\t\tans = 0;\n\t\tsolve(point[0], point[1]);\n\t\tfor (i = 0; i < s2; i ++) for (j = 0; j < s1; j ++) ans += count[i][j];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define W 21\n#define H 21\nint w,h;\nchar map[W][H];\nint search(int s,int t){\n\tif(s<0||t<0||s>=h||t>=w ||map[s][t]=='#')return 0;\n\tint sum=1;\n\tmap[s][t]='#';\n\tsum+=search(s-1,t);\n\tsum+=search(s,t+1);\n\tsum+=search(s+1,t);\n\tsum+=search(s,t-1);\n\treturn sum;\n}\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tint st_w,st_h;\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(!w && !h)break;\n\t\tmemset(map,' ',sizeof(map));\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&map[i][j]);\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tst_w=j;st_h=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",search(st_h,st_w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}{0,1}{0,-1}{-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1:\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\ntypedef struct {\n  int x, y;\n} Point;\n\nint W, H;\nchar mas[20][21];\nint i, j;\n\n\nint main()\n{\n  while(scanf(\"%d %d\", &W, &H), W) {\n    getchar();\n    for(i = 0; i < H; i++) {\n      scanf(\"%s\", mas[i]);\n    }\n\n    const int SIZE = 60000;\n    int head = 0, tail = 1;\n    int cnt = 0;\n    Point z[SIZE], start;\n\n    for(i = 0; i < H; i++) {\n      for(j = 0; j < W; j++) {\n\tif(mas[i][j] == '@') start = (Point){j, i};\n      }\n    }\n\n    z[head] = start;\n    const int dy[] = {0, 1, 0, -1}, dx[] = {-1, 0, 1, 0};\n\n    while(head != tail) {\n      int x = z[head].x, y = z[head].y;\n      head = (head + 1) % SIZE;\n      if(0 <= x && x < W && 0 <= y && y < H && mas[y][x] != '#') {\n\tmas[y][x] = '#';\n\t++cnt;\n\tfor(i = 0; i < 4; i++) {\n\t  int ny = dy[i] + x, nx = y + dx[i];\n\t  z[(tail + i) % SIZE] = (Point){ny, nx};\n\t}\n\ttail = (tail + 4) % SIZE;\n      }\n    }\n    printf(\"%d\\n\", cnt);\n  }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nvoid redbrack(char **a, int x, int y,int m, int h,int *c)\n{\n  (*c)++;\n  a[x][y]='#';\n  if(x-1 >= 0){\n\tif(a[x-1][y] == '.')\n\t\t{\n\t\t\tredbrack(a,x-1,y,m,h,c);\n\t\t}}\n\tif(y-1 >= 0){\n\tif(a[x][y-1] == '.')\n\t\t{ \n\t\t\tredbrack(a,x,y-1,m,h,c);\n\t\t}}\n\tif(x+1 < h){\n\tif(a[x+1][y] == '.')\n\t\t{ \n\t\t\tredbrack(a,x+1,y,m,h,c);\n\t\t}}\n\tif(y+1 < m){\n\tif(a[x][y+1] == '.')\n\t\t{ \n\t\t\tredbrack(a,x,y+1,m,h,c);\n\t\t}}\n}\n\nint main(void)\n{\n\n\tint i,j,*c;\n\tchar **a;\n\tint m,h;\n\tint x,y;\n\t\n\twhile(1)\n\t\t{\n\t\t\tc = (int *)malloc(sizeof(int));\n\t\t  *c=0;\n\t\t\tscanf(\"%d %d \",&m,&h);\n\t\t\tif(m==0 && h==0)break;\n\n\t\t\ta = (char **)malloc(sizeof(char *)*h);\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\ta[i]=(char *)malloc(sizeof(char)*m);\n\t\t\t}\n\n\t\t\tfor(i=0;i<h;i++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%s \",a[i]);\n\t\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\t  if(a[i][j]=='@')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx = i;\n\t\t\t\t\t\t\t\t\ty = j;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\tredbrack(a,x,y,m,h,c);\n\t\tprintf(\"%d\\n\",*c);\n\t\t}\n\t\t\n\t\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tdfs(x + dx[i], y + dy[i]);\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nvoid init(void){int i,j;\n\t\tfor(i=0;i<20;i++){for(j=0;j<20;j++)map[i][j]=0;}\n}\nint main(void){\n\tint i,j,memH,memW,p;\n\twhile(1){\n\tp=0;\n\tinit();\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[i]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[i][j]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\t\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[32][32];\n\nint black(int y, int x)\n{\n    if (map[y][x] == '#') return 0;\n    map[y][x] = '#';\n    return black(y - 1, x) + black(y + 1, x) + black(y, x - 1) + black(y, x + 1) + 1;\n}\n\nint main(void)\n{\n    int w, h;\n\n    while (scanf(\"%d %d\", &w, &h), w != 0){\n        int i, j;\n\n        for (j = 1; j <= w; j++){\n            map[0][j] = '#';\n            map[h + 1][j] = '#';\n        }\n        for (i = 1; i <= h; i++){\n            map[i][0] = '#';\n            scanf(\"%s\", map[i] + 1);\n            map[i][w + 1] = '#';\n        }\n        for (i = 1; i <= h; i++){\n            for (j = 1; j <= w; j++){\n                if (map[i][j] == '@'){\n                    printf(\"%d\\n\", black(i, j));\n                    i = h, j = w;\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint h, w;\nchar mp[25][25];\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\n\nint dfs(int sy, int sx);\n\nint main()\n{\n    scanf(\"%d %d\", &w, &h);\n    while (h != 0 && w != 0) {\n\n        int sy, sx;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                scanf(\" %c \", &mp[i][j]);\n\n                if (mp[i][j] == '@') {\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", dfs(sy, sx));\n        \n        scanf(\"%d %d\", &w, &h);\n    }\n\n    return 0;\n}\n\nint dfs(int y, int x)\n{\n    if (y < 0 || y >= h ||\n        x < 0 || x >= w ||\n        mp[y][x] == '#') {\n        return 0;\n    }\n\n    int rec = 1;\n    mp[y][x] = '#';\n\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n\n        rec += dfs(ny, nx);\n    }\n\n    return rec;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \nint w,h;\nchar map[20][21];\n \nint tansaku(int x,int y) {\n    int result=1;\n    if(x<0 || x>=w || y<0 || y>=h)return 0;\n    if(map[y][x]=='#')return 0;\n    map[y][x]='#';\n    result+=tansaku(x-1,y);\n    result+=tansaku(x+1,y);\n    result+=tansaku(x,y-1);\n    result+=tansaku(x,y+1);\n    return result;\n}\n \nint main(void) {\n    int i,j;\n    int sx,sy;\n    while(scanf(\"%d%d\",&w,&h),w==0&&h==0) {\n        for(i=0;i<h;i++) {\n            scanf(\"%s\",map[i]);\n            for(j=0;j<w;j++) {\n                if(map[i][j]=='@'){\nsx=j;\nsy=i;\n}\n            }\n        }\n        printf(\"%d\\n\",tansaku(sx,sy));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nconst int INF = 10000000;\n\nint W, H, bx, by;\nchar tile[22][22];\nint d[22][22];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nvoid bfs();\n\nvoid solve();\n\n\nint main(void){\n  int i, j;\n  while(scanf(\"%d%d\", &W, &H) && W && H){\n    //scanf(\"%d%d\", &W, &H);\n      for(i = 0 ; i < H; i++){\n        scanf(\"%s\", tile[i]);\n      }\n      for(i = 0; i < W; i++){\n        for(j = 0; j < H; j++){\n          if(tile[j][i] == '@'){\n            bx = i;\n            by = j;\n          }\n        }\n      }\n      //printf(\"%d %d\\n\", bx, by);\n      solve();\n    }\n  return 0;\n}\n\nvoid bfs(){\n  struct pair{\n    int first;\n    int second;\n  };\n\n  struct queue{\n    struct pair P[401];\n    int head;\n    int tail;\n  };\n\n  struct queue que;\n  que.head = 0;\n  que.tail = 0;\n  int i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      d[j][i] = INF;\n    }\n  }\n\n  que.P[que.tail].first = bx;\n  que.P[que.tail].second = by;\n  d[by][bx] = 0;\n  que.tail++;\n  //que.head++;\n\n  while(que.head < que.tail){\n    struct pair state;\n    state.first = que.P[que.head].first;\n    state.second = que.P[que.head].second;\n    que.head++;\n    //printf(\"%d %d\\n\" ,que.head, que.tail);\n    //if(p.first == gx && p.second == gy) break;\n\n    for(i = 0; i < 4; i++){\n      int nx = state.first + dx[i], ny = state.second + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && tile[ny][nx] != '#' && d[ny][nx] == INF){\n        que.P[que.tail].first = nx;\n        que.P[que.tail].second = ny;\n        que.tail++;\n        d[ny][nx] = d[state.first][state.second] + 1;\n      }\n    }\n  }\n  //return d[gx][gy];\n\n}\n\nvoid solve(){\n  bfs();\n  int ans = 0, i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      if(d[j][i] != INF) ans++;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "c,gx,gy,x,y,n,m;\nchar map[20][20];\ncheck(a,b)\n{\n  map[a][b]=35;\n  c++;\n  if(a+1<gy&&map[a+1][b]==46)\n    check(a+1,b);\n  if(a>0&&map[a-1][b]==46)\n    check(a-1,b);\n  if(b+1<gx&&map[a][b+1]==46)\n    check(a,b+1);\n  if(b>0&&map[a][b-1]==46)\n    check(a,b-1);\n}\nint main()\n{\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      for(x=0;x<20;x++)\n\tfor(y=0;y<20;)\n\t  map[x][y++]=35;\n      for(c=n=0;n<gy;n++)\n\t{\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]==64)\n\t      x=n,y=m;\n\t}\n      check(x,y);\n      printf(\"%d\\n\",c);\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "w,m[];R(char*p){*p>45?*p=0,R(p-1),R(p+1),R(p-w),R(p+w),++*m:0;}main(){for(;scanf(\"%d%*d\",&w)*w;printf(\"%d\\n\",*m))bzero(m,999),scanf(\"%[^0-9]\",++w+m),R(index(m+w,64));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint count(int x,int y);\n\nchar board[20][22];\n\nint main(void){\n    int w,h,i,j;\n    while(scanf(\"%d%d%*c\",&w,&h) && w && h){\n        for(i=0;i<20;i++) for(j=0;j<22;j++) board[i][j]=0;\n        for(i=0;i<h;i++){\n            fgets(board[i],sizeof(board[i]),stdin);\n        }\n        for(i=0;i<h;i++){\n            for(j=0;j<w;j++){\n                if(board[i][j]=='@')\n                    break;\n            }\n            if(j<w) break;\n        }\n        printf(\"%d\\n\",count(i,j));\n    }\n    return 0;\n}\n\nint count(int x,int y){\n    int ret=1;\n    if(x!=0 && board[x-1][y]=='.'){\n        board[x-1][y]='@';\n        ret+=count(x-1,y);\n    }\n    if(y!=0 && board[x][y-1]=='.'){\n        board[x][y-1]='@';\n        ret+=count(x,y-1);\n    }\n    if(x<20 && board[x+1][y]=='.'){\n        board[x+1][y]='@';\n        ret+=count(x+1,y);\n    }\n    if(y<22 && board[x][y+1]=='.'){\n        board[x][y+1]='@';\n        ret+=count(x,y+1);\n    }\n    return ret;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p;\n\twhile(1){\n\tp=0;\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[i]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[i][j]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\t\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXH 22\n#define MAXW 24\n\nint bfs(int mat[20][22],int visited[20][22],int ph,int pw,int* ans){\n\tint vector[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\tint i;\n\tvisited[ph][pw]=1;\n\t(*ans)++;\n\tfor(i=0;i<4;i++){\n\t\tint nh=ph+vector[i][0];\n\t\tint nw=pw+vector[i][1];\n\t\tif(mat[nh][nw]=='.'&&visited[nh][nw]==0){\n\t\t\tbfs(mat,visited,nh,nw,ans);\n\t\t}\n\t}\n\treturn 0;\n}\nint input(int mat[20][22],int h,int w,int* sh,int* sw){\n\tint i,j;\n\tfor(i=1;i<h+1;i++){\n\t\tfor(j=1;j<w+1;j++){\n\t\t\tint c;\n\t\t\twhile(c=getchar()){\n\t\t\t\tif(c!='\\n'){\n\t\t\t\t\tmat[i][j]=c;\n\t\t\t\t\tif(c=='@'){\n\t\t\t\t\t\t*sh=i;\n\t\t\t\t\t\t*sw=j;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tint sh,sw;\n\tint ans=0;\n\tint mat[20][22],visited[20][22];\n\tint i,j,k;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<22;j++){\n\t\t\t\tmat[i][j]='#';\n\t\t\t\tvisited[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tinput(mat,h,w,&sh,&sw);\n\t\tbfs(mat,visited,sh,sw,&ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c,gx,gy;\nchar map[20][20];\ncheck(x,y)\n{\n  map[x][y]=35;\n  c++;\n  if(x+1<gy&&map[x+1][y]==46)\n    check(x+1,y);\n  if(x>0&&map[x-1][y]==46)\n    check(x-1,y);\n  if(y+1<gx&&map[x][y+1]==46)\n    check(x,y+1);\n  if(y>0&&map[x][y-1]==46)\n    check(x,y-1);\n}\n\nint main()\n{\n  int n,m,x,y;\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      for(x=0;x<20;x++)\n\tfor(y=0;y<20;)\n\t  map[x][y++]=35;\n      for(c=n=0;n<gy;n++)\n\t{\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]==64)\n\t      x=n,y=m;\n\t}\n      check(x,y);\n      printf(\"%d\\n\",c);\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=l;i<r;i++)\n\n//union-find\n#define UFLIMIT (1<<17)\nint unicnt[UFLIMIT+10];//正ならcnt、非正なら根のindex\nvoid ufinit(int n){rep(i,0,n)unicnt[i]=1;}\nint root(int x){return unicnt[x]<=0?-(unicnt[x]=-root(-unicnt[x])):x;}\nint same(int x,int y){return root(x)==root(y);}\nvoid uni(int x,int y){if((x=root(x))==(y=root(y)))return;if(unicnt[x]<unicnt[y]){int t=x;x=y;y=t;}unicnt[x]+=unicnt[y];unicnt[y]=-x;}\n#undef UFLIMIT\n\nll d4[]={0,1,0,-1,0};\nint main(){\n\tll w,h;\n\twhile(scanf(\"%lld%lld\",&w,&h),w){\n\t\tchar s[30][30]={};\n\t\tufinit(w*h);\n\t\trep(i,1,h+1)scanf(\" %s\",s[i]+1);\n\t\trep(i,1,h+1)rep(j,1,w+1)if(s[i][j]=='.'||s[i][j]=='@'){\n\t\t\trep(k,0,4){\n\t\t\t\tll ii=i+d4[k];\n\t\t\t\tll jj=j+d4[k+1];\n\t\t\t\tif(s[ii][jj]=='.'||s[ii][jj]=='@')uni((i-1)*w+(j-1),(ii-1)*w+(jj-1));\n\t\t\t}\n\t\t}\n\t\trep(i,1,h+1)rep(j,1,w+1)if(s[i][j]=='@')printf(\"%lld\\n\",unicnt[root((i-1)*w+(j-1))]);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \nchar map[22][22], mk[22][22];\nint que[500][2], top, end;\nint m[4][2] = {{1,0},{-1,0},{0,-1},{0,1}};\n \nint main()\n{\n    int w, h, i, r, c, r2, c2, ans;\n     \n    while (scanf(\"%d%d\", &w, &h) && w) {\n        memset(mk, 0, sizeof(mk));\n        for (i = 0, r = 0; r < h; r++) {\n            scanf(\"%s\", map[r]);\n            for (c = 0; c < w; c++) if (map[r][c] == '@') {\n                que[0][0] = r, que[0][1] = c; mk[r][c] = 1, top = 0, end = 1, i = 1;\n            }\n        }\n        while (top < end) {\n            r = que[top][0], c = que[top++][1];\n            for (i = 0; i < 4; i++) {\n                r2 = r + m[i][0], c2 = c + m[i][1];\n                if (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == '#') continue;\n                if (mk[r2][c2]) continue;\n                mk[r2][c2] = 1;\n                que[end][0] = r2, que[end++][1] = c2;\n            }\n        }\n        for (ans = 0, r = 0; r < h; r++) for (c = 0; c < w; c++) ans += mk[r][c];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAPX 25\n#define MAPY 25\n\nchar data[MAPY][MAPX];\nint h,w;\n\nint search(int num, int nowx, int nowy){\n\tnum = 1;\n\tdata[nowy][nowx] = '#';\n\tif(nowx>0)if(data[nowy][nowx-1]=='.')num += search(num, nowx-1, nowy);\n\tif(nowy>0)if(data[nowy-1][nowx]=='.')num += search(num, nowx, nowy-1);\n\tif(nowx<w-1)if(data[nowy][nowx+1]=='.')num += search(num, nowx+1, nowy);\n\tif(nowy<h-1)if(data[nowy+1][nowx]=='.')num += search(num, nowx, nowy+1);\n\treturn num;\n}\n\nvoid solve(){\n\tint i,t;\n\tint sx,sy;\n\tfor(i = 0;i < h;i++){\n\t\tscanf(\"%s\", &data[i][0]);\n\t}\n\tfor(i = 0;i < h;i++){\n\t\tfor(t = 0;t < w;t++){\n\t\t\tif(data[i][t]=='@'){\n\t\t\t\tsx = t;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0,  sx, sy));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d \", &w, &h);\n\t\tif(h == 0 && w == 0)break;\n\t\tsolve(h,w);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j;\n\t\tfor(i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", s[i]);\n\t\t}\n\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAPX 25\n#define MAPY 25\nchar data[MAPY][MAPX];\nint h,w;\nint search(int num, int nowx, int nowy){\n\tnum = 1;\n\tdata[nowy][nowx] = '#';\n\tif(nowx>0)if(data[nowy][nowx-1]=='.')num += search(num, nowx-1, nowy);\n\tif(nowy>0)if(data[nowy-1][nowx]=='.')num += search(num, nowx, nowy-1);\n\tif(nowx<w-1)if(data[nowy][nowx+1]=='.')num += search(num, nowx+1, nowy);\n\tif(nowy<h-1)if(data[nowy+1][nowx]=='.')num += search(num, nowx, nowy+1);\n\treturn num;\n}\n\nvoid solve(){\n\tint i,t;\n\tint sx,sy;\n\tfor(i = 0;i < h;i++){\n\t\tscanf(\"%s\", &data[i][0]);\n\t}\n\tfor(i = 0;i < h;i++){\n\t\tfor(t = 0;t < w;t++){\n\t\t\tif(data[i][t]=='@'){\n\t\t\t\tsx = t;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0,  sx, sy));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tif(h == 0 && w == 0)break;\n\t\tsolve(h,w);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nconst int INF = 10000000;\n\nint W, H, bx, by;\nchar tile[21][21];\nint d[21][21];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nvoid bfs();\n\nvoid solve();\n\n\nint main(){\n  int i, j;\n  while(scanf(\"%d%d\", &W, &H) && (W || H)){\n    //scanf(\"%d%d\", &W, &H);\n      for(i = 0 ; i < H; i++){\n        scanf(\"%s\", tile[i]);\n      }\n      for(i = 0; i < W; i++){\n        for(j = 0; j < H; j++){\n          if(tile[j][i] == '@'){\n            bx = i;\n            by = j;\n          }\n        }\n      }\n      //printf(\"%d %d\\n\", bx, by);\n      solve();\n    }\n  return 0;\n}\n\nvoid bfs(){\n  struct pair{\n    int first;\n    int second;\n  };\n\n  struct queue{\n    struct pair P[101];\n    int head;\n    int tail;\n  };\n\n  struct queue que;\n  que.head = 0;\n  que.tail = 0;\n  int i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      d[j][i] = INF;\n    }\n  }\n\n  que.P[que.tail].first = bx;\n  que.P[que.tail].second = by;\n  d[by][bx] = 0;\n  que.tail++;\n  //que.head++;\n\n  while(que.head < que.tail){\n    struct pair state;\n    state.first = que.P[que.head].first;\n    state.second = que.P[que.head].second;\n    que.head++;\n    //printf(\"%d %d\\n\" ,que.head, que.tail);\n    //if(p.first == gx && p.second == gy) break;\n\n    for(i = 0; i < 4; i++){\n      int nx = state.first + dx[i], ny = state.second + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && tile[ny][nx] != '#' && d[ny][nx] == INF){\n        que.P[que.tail].first = nx;\n        que.P[que.tail].second = ny;\n        que.tail++;\n        d[ny][nx] = d[state.first][state.second] + 1;\n      }\n    }\n  }\n  //return d[gx][gy];\n\n}\n\nvoid solve(){\n  bfs(bx, by);\n  int ans = 0, i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      //printf(\"%d\\n\", d[i][j]);\n      if(d[j][i] != INF) ans++;\n    }\n  }\n  //printf(\"%d\\n\",INF);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define SIZE 100000\ntypedef struct{\n  int x;\n  int y;\n}Zahyo;\nZahyo  z[SIZE];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nmain(){\n  int h,w;\n  char maps[30][30];\n  int i,j;\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w == 0 && h == 0) break;\n    int cnt=0;\n    int head=0;\n    int tail=0;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",maps[i]);\n      for(j=0;j<w;j++){\n\tif(maps[i][j]=='@'){\n\t  z[0]=(Zahyo){j,i};\n\t  tail=(tail+1)%SIZE;\n\t}\n      }\n    }\n    while(head != tail){\n      int x = z[head].x; int y = z[head].y; head = (head+1) % SIZE;\n      if(0 <= x && 0 <= y && x < w && y < h && maps[y][x] != '#'){\n\tmaps[y][x] = '#';\n\tcnt++;\n\tfor(i=0;i<4;i++){\n\t  int nx = x + dx[i]; int ny = y + dy[i];\n\t  z[(tail+i) % SIZE] = (Zahyo){ nx,ny };\n\t}\n\ttail = (tail+4) % SIZE;\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(s[ny][nx] == '.'){\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tchar a;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%s\", &a);\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\t\t\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m[22][22],C;\nR(x,y){\n\tif(m[x][y]){\n\t\tm[x][y]=0;\n\t\tC++;\n\t\tR(x-1,y);\n\t\tR(x+1,y);\n\t\tR(x,y-1);\n\t\tR(x,y+1);\n\t}\n}\nmain(){\n\tint W,H,x,y,c,px,py;\n\tfor(;scanf(\"%d%d\",&W,&H),W;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(y=1;y<=H;y++){\n\t\t\tfor(x=0;x<=W;x++){\n\t\t\t\tc=getchar();\n\t\t\t\tif(c=='@')\n\t\t\t\t\tm[x][y]=1,px=x,py=y;\n\t\t\t\telse if(c=='.')\n\t\t\t\t\tm[x][y]=1;\n\t\t\t\telse if(c=='#')\n\t\t\t\t\tm[x][y]=0;\n\t\t\t}\n\t\t}\n\t\tC=0;\n\t\tR(px,py);\n\t\tprintf(\"%d\\n\",C);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,x[4000],y[4000],c,ny,nx,r,t;\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  char m[20][20];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(m[i][j]=='@'){\n\t  y[0  ]=i;\n\t  x[t=0]=j;\n\t  m[i][j]='#';\n\t}\n      }\n    }\n    for(r=c=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=x[t]+X[i];\n\tny=y[t]+Y[i];\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(m[ny][nx]=='#')continue;\n\tx[r]=nx;\n\ty[r++]=ny;\n\tm[ny][nx]='#';\n\tc++;\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\nint w,h;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,-1,1};\nint used[20][20];\nchar c[20][22];\nint cnt;\nvoid dfs(int sy,int sx){\n    used[sy][sx]=1; cnt++;\n    for(int d=0;d<4;d++){\n        int ny=sy+dy[d],nx=sx+dx[d];\n        if(c[ny][nx]=='#') continue;\n        if(ny<0||ny>=h||nx<0||nx>=w) continue;\n        if(used[ny][nx]==1) continue;\n        dfs(ny,nx);\n    }\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        getchar();\n        rep(i,h) fgets(c[i],22,stdin);\n        int starty,startx;\n        rep(i,h){\n            rep(j,w){\n                if(c[i][j]=='@'){\n                    starty=i,startx=j;\n                }\n                used[i][j]=0;\n            }\n        }\n        cnt=0;\n        dfs(starty,startx);\n        printf(\"%d\\n\",cnt);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "/* ***************************\n   ??????????§????\n   ???????????????\n   ????????????????????¨????????±???????????¢?´¢\n   *************************** */\n\n#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\nvoid display_map (int W, int H);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  int W, H;\n\n  while(1){\n    scanf(\"%d%d\", &W, &H);\n    if(W==0 && H==0)break;\n    /*if (W<1 || H<1 || W>MAX || H>MAX) {\n      printf(\"?????¢??????????????? %d X %d ?????§??§???. \\n\", MAX, MAX);\n      } else {*/\n    printf(\"%d\\n\", solve(W,H));\n    // }\n  }\n\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  // ??????????????°?????¨??? (??¬??\\???????????????)\n  //printf(\"??????????????°??? [%d, %d]\\n\\n\", start.row, start.col);\n\n  // ?????£?????°??????????????? 1, ????????§???????????? 0\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  int count = 1;\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    //printf(\"?????¨??°??? [%d, %d]\\n\", current.row, current.col);  // ??¬??\\???????????????\n    //display_map(W, H); // ?????¨??????????????¨??? (??¬??\\???????????????)\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      // ????????§???????????????\n      nc.row += D1[d]; nc.col += D2[d];\n\n      \n      if(M[nc.row][nc.col] == '.'){\n\tpush(S, nc);\n\tM[nc.row][nc.col] = '*';\n\tcount++;\n      }\n\n    }\n  }\n  return count;  \n}\n\nvoid display_map (int W, int H) {;\n  int i, j;\n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      printf(\"%c\", M[i][j]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[500][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint H,W,i,j,sh,sw;\nchar P[30][30];\n\nint dfs(int ph,int pw)\n{\n\tint m[5]={0,1,0,-1,0},i,r=0;\n\tP[ph][pw]='#';\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(P[ph+m[i]][pw+m[i+1]]=='.')\n\t\t\tr+=dfs(ph+m[i],pw+m[i+1])+1;\n\t}\n\treturn r;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),H;)\n\t{\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=W+1;j++)\n\t\t\t{\n\t\t\t\tP[i][j]=getchar();\n\t\t\t\tif(P[i][j]=='@')sh=i,sw=j,P[i][j]='.';\n\t\t\t}\n\t\tprintf(\"%d\\n\",dfs(sh,sw)+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nvoid look_for(int,int,int,int);\n\nchar map[20][20];\nint cnt;\n\nint main(){\n  int i,j,w,h;\n  while(1){\n    cnt=0;\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]=='@')\n\t  look_for(i,j,h,w);\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}\n\nvoid look_for(int h,int w,int height,int width){\n  int i,j;\n  if(map[h][w]=='.'){\n    cnt++;\n    map[h][w]='N';\n  }\n  for(i=-1;i<=1;i++){\n    for(j=-1;j<=1;j++){\n      if(i==j || i==-j || i+h<0 || j+w<0 ||i+h>height || j+w>width || (i==0 && j==0))continue;\n      if(map[i+h][w+j]=='.')look_for(i+h,j+w,height,width);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define N 20;\n\nstatic\nchar d[ 20 ][ 20 ];\nstatic\nint w, h;\n\nstatic\nint dfs (\n  int x,\n  int y\n  )\n{\n  int res;\n\n  if ( x < 0 || x >= w\n    || y < 0 || y >= h )    return ( 0 );\n  if ( d[ x ][ y ] != '.' ) return ( 0 );\n\n  d[ x ][ y ] = '#';\n  res   = 1;\n  res  += dfs ( x - 1, y );\n  res  += dfs ( x + 1, y );\n  res  += dfs ( x, y - 1 );\n  res  += dfs ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  for ( ; ; )\n  {\n    int sx = 0, sy = 0;\n    int x, y;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( y = 0; y < h; ++y )\n    for ( x = 0; x < w; ++x )\n    {\n      int ch = ' ';\n\n      while ( isspace ( ch ) )  ch = getchar ( );\n      if ( ch == '@' )\n      {\n        sx = x; sy = y;\n        d[ x ][ y ] = '.';\n      }\n      else\n      {\n        d[ x ][ y ] = ch;\n      }\n    }\n\n    printf ( \"%d\\n\", dfs ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvoid dfs(int x, int y) {\n\tint i;\n\tif (s[y][x] == '.' || s[y][x] == '@') {\n\t\tcount++;\n\t\ts[y][x] = '#';\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void) {\n\tchar a;\n\tint i, j, x, y;\n\twhile(1){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%c\", &a);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i<21; i++) {\n\t\t\tfor (j = 0; j<21; j++) {\n\t\t\t\ts[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\n\t\tfor (i = 1; i<=h; i++) {\n\t\t\tfor (j = 1; j<=w; j++) {\n\t\t\t\tscanf(\"%c\", &s[i][j]);\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%c\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%c \",Map[i][j]);\n      }\n      printf(\"\\n\");\n    }*/\n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \nchar map[22][22], mk[22][22];\nint que[500][2], top, end;\nint m[4][2] = {{1,0},{-1,0},{0,-1},{0,1}};\n \nint main()\n{\n    int w, h, i, r, c, r2, c2, ans;\n     \n    while (scanf(\"%d%d\", &w, &h) && w) {\n        memset(mk, 0, sizeof(mk));\n        for (i = 0, r = 0; r < h; r++) {\n            scanf(\"%s\", map[r]);\n            if (!i) for (c = 0; c < w; c++) if (map[r][c] == '@') {\n                que[0][0] = r, que[0][1] = c; mk[r][c] = 1, top = 0, end = 1, i = 1;\n            }\n        }\n        while (top < end) {\n            r = que[top][0], c = que[top++][1];\n            for (i = 0; i < 4; i++) {\n                r2 = r + m[i][0], c2 = c + m[i][1];\n                if (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == '#') continue;\n                if (mk[r2][c2]) continue;\n                mk[r2][c2] = 1;\n                que[end][0] = r2, que[end++][1] = c2;\n            }\n        }\n        for (ans = 0, r = 0; r < h; r++) for (c = 0; c < w; c++) ans += mk[r][c];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  while (1) {\n    int W, H;\n    scanf(\"%d%d\", &W, &H);\n    if (W==0 && H==0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n  int c = 1;               // ????????????????????????????????°???????????? 1 ??§?????????\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      nc.row += D1[d];  nc.col += D2[d]; \n      if (M[nc.row][nc.col] == '.') {\n\tM[nc.row][nc.col] = '*';               // ?????°???????????°?????????\n\tc++;                                   // ???????????????????????????????????????\n\tpush(S,nc);\n      } // nc ????????¢?´¢?????? (*) ????£? (#) ?????´?????????????????????\n    } \n  }\n  return c;  // ??°??????????????????????????°?????????\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint w;\nint h;\nchar map[20][21];\n\nint solve(int x,int y){\n  int count=1;\n\n  if(x+1<w&&map[y][x+1]=='.'){\n    map[y][x+1]='f';\n    count+=solve(x+1,y);\n  }\n  if(x-1>-1&&map[y][x-1]=='.'){\n    map[y][x-1]='f';\n    count+=solve(x-1,y);\n  }\n  if(y+1<h&&map[y+1][x]=='.'){\n    map[y+1][x]='f';\n    count+=solve(x,y+1);\n  }\n  if(y-1>-1&&map[y-1][x]=='.'){\n    map[y-1][x]='f';\n    count+=solve(x,y-1);\n  }\n  return count;\n}\n\nint main(){\n  int i,j,mx,my,found;\n  do{\n    found=0;\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n      if(!found){\n\tfor(j=0;j<w;j++){\n\t  if(map[i][j]=='@'){\n\t    mx=j;\n\t    my=i;\n\t    found=1;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",solve(mx,my));\n  }while(1);\n  return 0;\n}\n      "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nmain(){\n  int i,j,k,w,h,a[20][20],jud,c,x,y;\n  char n[22];\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&n);\n      for(j=0;j<w;j++){\n\tif(n[j]=='.') a[j][i]=1;\n\telse if(n[j]=='#') a[j][i]=0;\n\telse if(n[j]=='@') {\n\t  a[j][i]=2;\n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n    jud=1;\n    c=1;\n    for(i=0;i<500;i++){\n      jud=0;\n      if(a[x-1][y]==1&&x>0){\n\ta[x-1][y]=2;\n\tc++;\n\tx--;\n\tjud=1;\n      }\n      else if(a[x+1][y]==1&&x<w-1){\n\ta[x+1][y]=2;\n\tc++;\n\tx++;\n\tjud=1;\n      }\n      else if(a[x][y-1]==1&&y>0){\n\ta[x][y-1]=2;\n\tc++;\n\ty--;\n\tjud=1;\n      }\n      else if(a[x][y+1]==1&&y<h-1){\n\ta[x][y+1]=2;\n        c++;\n\ty++;\n\tjud=1;\n      }\n      else{\n\tfor(j=2;j<20;j++){     \n\t  if(a[x-1][y]==j&&x>0){\n\t    a[x-1][y]++;\t   \n\t    x--;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x+1][y]==j&&x<w-1){\n\t    a[x+1][y]++;\n\t    x++;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x][y-1]==j&&y>0){\n\t    a[x][y-1]++;\t    \n\t    y--;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x][y+1]==j&&y<h-1){\n\t    a[x][y+1]++;\t  \n\t    y++;\n\t    jud=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(jud==0) break;\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n  int row;\n  int col;\n} Coord;\n\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nint solve (int W, int H);\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n\nint main () {\n  int W, H;\n\n  while(W!=0 && H!=0)\n    {\n      scanf(\"%d%d\", &W, &H);\n      if(W!=0 && H!=0)\n\t{\n          printf(\"%d\\n\", solve(W,H));\n\t}\n    }\n\n  return 0;\n}\n\n\nint solve (int W, int H) {\n  stack S = new_stack ();\n  int n=0;\n  char M[H+2][W+2];\n  Coord start;\n  int i, j;\n\n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n \n  push(S,start); \n  while (!is_empty(S)) {\n    Coord current = pop(S);\n    n++;\n    int d;                                   \n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};   \n    for (d=0; d<4; d++) {\n      Coord nc = current;   \n      nc.row+=D1[d]; nc.col+=D2[d];      \n      if (M[nc.row][nc.col]=='G') {     \n\treturn 1;\n      }\n      if (M[nc.row][nc.col]=='.') {          \n\tM[nc.row][nc.col]='*';            \n\tpush(S,nc);                            \n      } \n    }\n  }\n  return n;\n}\n\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "n,m,x,y,c,gx,gy;char map[20][20];check(a,b){map[a][b]=35;c++;if(a+1<gy&&map[a+1][b]==46)check(a+1,b);if(a>0&&map[a-1][b]==46)check(b-1,b);if(b+1<gx&&map[a][b+1]==46)check(a,b+1);if(b>0&&map[a][b-1]==46)check(a,b-1);}main(){for(;scanf(\"%d%d\",&gx,&gy),gx;){for(x=0;x<20;x++)for(y=0;y<20;)map[x][y++]=35;for(c=n=0;n<gy;n++){scanf(\"%s\",map[n]);for(m=0;m<gx;m++)if(map[n][m]==64)x=n,y=m;}check(x,y);printf(\"%d\\n\",c);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 20\nint main()\n{\n  char c[MAX][MAX];\n  int checked[MAX][MAX];\n  int able[MAX][MAX];\n  int x,y;\n  int checkingx,checkingy;\n  int i,j;\n  int flag;\n  int result;\n  while(1)\n    {\n      for(i=0;i<MAX;i++)\n\tfor(j=0;j<MAX;j++)\n\t  checked[i][j]=able[i][j]=0;\n      scanf(\"%d%d\",&x,&y);\n      if((!x)&&(!y)) break;\n      for(i=0;i<y;i++)\n\tfor(j=0;j<x;j++)\n\t  {\n\t    scanf(\"%c\",&c[j][i]);\n\t    if(c[j][i]=='@')\n\t      {\n\t\tcheckingx=j;\n\t\tcheckingy=i;\n\t\tchecked[j][i]=1;\n\t\table[j][i]=1;\n\t      }\n\t    if(c[j][i]=='\\n')\n\t      {\n\t\tj--;\n\t\tcontinue;\n\t      }\n\t  }\n      while(1)\n\t{\n\t  if((checkingx>0)&&(c[checkingx-1][checkingy]=='.'))\n\t    {\n\t      able[checkingx-1][checkingy]=1;\n\t    }\n\t  if((checkingx<x-1)&&(c[checkingx+1][checkingy]=='.'))\n\t    {\n\t      able[checkingx+1][checkingy]=1;\n\t    }\n\t  if((checkingy>0)&&(c[checkingx][checkingy-1]=='.'))\n\t    {\n\t      able[checkingx][checkingy-1]=1;\n\t    }\n\t  if((checkingy<y-1)&&(c[checkingx][checkingy+1]=='.'))\n\t    {\n\t      able[checkingx][checkingy+1]=1;\n\t    }\n\t  flag=0;\n\t  for(i=0;i<y;i++)\n\t      for(j=0;j<x;j++)\n\t\tif((checked[j][i]==0)&&(able[j][i]==1))\n\t\t  {\n\t\t    checkingx=j;\n\t\t    checkingy=i;\n\t\t    checked[j][i]=1;\n\t\t    flag=1;\n\t\t  }\n\t  if(!flag) break;\n\t}\n      result=0;\n      for(i=0;i<y;i++)\n\tfor(j=0;j<x;j++)\n\t  if(checked[j][i]==1) result++;\n      printf(\"%d\\n\",result);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint func(int **a, int x, int y, int n, int m)\n{\n\tint c = 1;\n\tif(a[y][x] == 1){\n\t\treturn 0;\n\t}\n\ta[y][x] = 1;\n\t\n\tif(x-1 >= 0){\n\t\tc += func(a, x-1, y, n, m);\n\t}\n\tif(y-1 >= 0){\n\t\tc += func(a, x, y-1, n, m);\n\t}\n\tif(x+1 < n){\n\t\tc += func(a, x+1, y, n, m);\n\t}\n\tif(y+1 < m){\n\t\tc += func(a, x, y+1, n, m);\n\t}\n\t\n\treturn c;\n}\n\nint main(int argc, char **argv)\n{\n\tint **a, n, m, x, y, i, j;\n\tchar *w;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ta = (int **)calloc(m, sizeof(int));\n\t\tfor(i = 0; i < m; i++){\n\t\t\ta[i] = (int *)calloc(n, sizeof(int));\n\t\t\tw = (char *)malloc((n+1)*sizeof(char));\n\t\t\tscanf(\"%s\", w);\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tif(w[j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t} else if(w[j] == '#'){\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(w);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", func(a, x, y, n, m));\n\t\tfor(i = 0; i < m; i++){\n\t\t\tfree(a[i]);\n\t\t}\n\t\tfree(a);\n\t\tbreak;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint width, height, cnt = 0, direc[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nvoid dfs(char **s, int x, int y)\n{\n  int i, next_x = 0, next_y = 0;\n  cnt++;\n  for(i = 0; i < 4; i++)\n    {\n      next_x = x + direc[i][0];\n      next_y = y + direc[i][1];\n      //      printf(\"%d %d\\n\", next_x, next_y);\n      if(next_x >= 0 && next_x < width && next_y >= 0 && next_y < height && s[next_y][next_x] == '.')\n\t{\n\t  //      printf(\"hoge\");\n\t  s[next_y][next_x] = '#';\n\t  dfs(s, next_x, next_y);\n\t}\n    }\n}\n\nvoid search(char **s)\n{\n  int i, j;\n\n  for(i = 0; i < height; i++)\n    {\n      for(j = 0; j < width; j++)\n\t{\n\t  if(s[i][j] == '@')\n\t    {\n\t      dfs(s, j, i);\n\t    }\n\t}\n    }\n}\n\nint main(void)\n{\n  int x, y, i, j;\n  char **s;\n\n  while(1)\n    {\n      scanf(\"%d %d\", &width, &height);\n      if(width == 0 && height == 0)\n\t{\n\t  break;\n\t}\n      s = malloc(sizeof(char *) * height);\n\n      for(i = 0; i < height; i++)\n\t{\n\t  s[i] = malloc(sizeof(char) * (width + 1));\n\t  scanf(\"%s\", s[i]);\n\t}\n      \n      search(s);\n      printf(\"%d\\n\", cnt);\n      cnt = 0;\n      /* printf(\"\\n\"); */\n\n      /* for(i = 0; i < y; i++) */\n      /* \t{ */\n      /* \t  printf(\"%s\", s[i]); */\n      /* \t  printf(\"\\n\"); */\n      /* \t} */\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end++][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 20\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( ( x < 0 && x >= w )\n    || ( y < 0 && y >= h )\n    || d[ y ][ x ] != '.' ) return ( 0 );\n\n  d[ y ][ x ] = '#';\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx, sy;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#define B(a,x,b) ((a)<=(x)&&(x)<(b))\n\nchar T[400];\nint x,y,cx,cy,i;\n\nvoid R(a,b){\n\tif(B(0,a,x)&&B(0,b,y)&&!T[b*20+a]){\n\t\tT[b*20+a]=1;i++;R(a-1,b);R(a+1,b);R(a,b-1);R(a,b+1);\n\t}\n}\n\nmain(){\n\tchar c;\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<x*y;i++){\n\t\t\tint _x=i%x, _y=i/x;\n\t\t\tfor(;(c=getchar())=='\\n';);\n\t\t\tswitch(c){\n\t\t\t\tcase '@': cx=_x;cy=_y;\n\t\t\t\tcase '.': T[_y*20+_x]=0; break;\n\t\t\t\tcase '#': T[_y*20+_x]=1; break;\n\t\t\t}\n\t\t}\n\t\ti=0;\n\t\tR(cx,cy);\n\t\tprintf(\"%d\\n\",i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "T[20][20],X,Y,p,q,i;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&t)?t=0,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(x,y){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\nfor(i=0;i<X*Y;i++)switch(x=i%X,y=i/X,getchar()){\n\tcase 10:i--;break;\n\tcase'@':p=x;q=y;\n\tcase'.':t=1;break;\n\tcase'#':t=0;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define W 21\n#define H 21\nint w,h;\nchar map[W][H];\nint search(int s,int t){\n\tif(s<0||t<0||s>=h||t>=w ||map[s][t]=='#')return 0;\n\tint sum=1;\n\tmap[s][t]='#';\n\tsum+=search(s-1,t);\n\tsum+=search(s,t+1);\n\tsum+=search(s+1,t);\n\tsum+=search(s,t-1);\n\treturn sum;\n}\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tint st_w,st_h;\n\t\tscanf(\"%d %d\\n\",&w,&h);\n\t\tif(!w && !h)break;\n\t\tmemset(map,' ',sizeof(map));\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c\",&map[i][j]);if(map[i][j]=='@')\tst_w=j;st_h=i;\n\t\t\t}\n\t\t\tscanf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",search(st_h,st_w));\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 32\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( x < 0 || x >= w\n    || y < 0 || y >= h\n    || d[ y ][ x ] != '.' ) return ( 0 );\n\n  d[ y ][ x ] = '#';\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx = 0, sy = 0;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint visited[30][30];\nchar map[30][30];\nint dr[]={-1, 0, 1, 0}, dc[]={0, -1, 0, 1};\nint h, w, res;\n\nvoid dfs(int r, int c)\n{\n    int i;\n    if (visited[r][c]) return;\n    map[r][c]='X';\n    visited[r][c]=1;\n    ++res;\n    for(i=0;i<4;++i) {\n        int nr=r+dr[i], nc=c+dc[i];\n        if (nr<0 || nr>=h || nc<0 || nc>=w || visited[nr][nc] || map[nr][nc]!='.') continue;\n        dfs(nr, nc);\n    }\n}\n\nint main()\n{\n    while (1) {\n        int i, j, sr, sc;\n        scanf(\"%d%d\", &w, &h);\n        if (w==0) break;\n\n        memset(map, 0, sizeof(map));\n        memset(visited, 0, sizeof(visited));\n        for(i=0;i<h;++i) {\n            scanf(\"%s\", map[i]);\n            for(j=0;j<w;++j) if (map[i][j]=='@') { sr=i, sc=j; }\n        }\n\n        res=0;\n        dfs(sr, sc);\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[32][32];\n\nint dx[] = {0, 1, 0 ,-1};\nint dy[] = {-1, 0, 1, 0};\n\nint count = 0;\nint serch(int x, int y)\n{\n    int i;\n    if (map[y][x] == '@' || map[y][x] == '.')\n    {\n        count++;\n        map[y][x] = '#';\n        for (i = 0; i < 4; i++)\n        {\n            serch(x + dx[i], y + dy[i]);\n        }\n    }\n    return 0;\n}\nint main()\n{\n    int w, h, i, j, x, y;\n    char enter;\n    while (1)\n    {\n        scanf(\"%d %d\", &w, &h);\n        scanf(\"%c\", &enter);\n        if (w == 0 && h == 0) break;\n        for (i = 0; i < 32; i++)\n            for (j = 0; j < 32; j++)\n                map[i][j] = '#';\n        count = 0;\n        for (i = 1; i <= h; i++)\n        {\n            for (j = 1; j <= w; j++)\n            {\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == '@')\n                {\n                    x = j;\n                    y = i;\n                }\n            }\n            scanf(\"%c\", &enter);\n        }\n        serch(x, y);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][21];\nint main()\n{\n  int i,j,ii,jj;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n   \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n    int x,y;\n    int now_x,now_y;\n    int tmp;\n    int board[22][22];\n\n    while(1){\n        scanf(\"%d %d\", &x, &y);\n        \n        if(x == 0 && y == 0){\n            return 0;\n        }\n\n        for(int i = 0; i < 22; i++){\n            for(int j = 0; j < 22; j++){\n                board[i][j] = -1;\n            }\n        }\n\n        for(int i = 1; i <= y; i++){\n            for(int j = 1; j <= x; j++){\n                tmp = getchar();\n                if(tmp == '\\n'){\n                    tmp = getchar();\n                }\n                switch(tmp){\n                    case '.': board[i][j] = 1;break;\n                    case '#': board[i][j] = 0;break;\n                    case '@': board[i][j] = 2;break;\n                }\n            }\n        }\n\n        int end_flag = 0;\n        while(end_flag == 0){\n            end_flag = 1;\n\n            for(int i = 1; i <= y; i++){\n                for(int j = 1; j <= x; j++){\n                    if(board[i][j] == 2){\n                        if(board[i + 1][j] == 1){\n                            end_flag = 0;\n                            board[i + 1][j] = 2;\n                        }\n                        if(board[i - 1][j] == 1){\n                            end_flag = 0;\n                            board[i - 1][j] = 2;\n                        }\n                        if(board[i][j + 1] == 1){\n                            end_flag = 0;\n                            board[i][j + 1] = 2;\n                        }\n                        if(board[i][j - 1] == 1){\n                            end_flag = 0;\n                            board[i][j - 1] = 2;\n                        }\n                    }\n                }\n            }\n        }\n        \n        int cnt = 0;\n        for(int i = 1; i <= y; i++){\n           for(int j = 1; j <= x; j++){\n           //    printf(\"%2d\", board[i][j]);\n               if(board[i][j] == 2){\n                   cnt++;\n               }\n           }\n           //printf(\"\\n\");\n        }\n\n        printf(\"%d\\n\", cnt);\n\n    }\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1:\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int w,h,i,j,t,r,c;\n  int x[400],y[400];\n  int X[4]={0,1,0,-1};\n  int Y[4]={1,0,-1,0};\n  char m[20][20];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(m[i][j]=='@'){\n\t  y[0]=i;\n\t  x[0]=j;\n\t  m[i][j]='#';\n\t}\n      }\n    }\n    t=c=0;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tif(x[t]+X[i]<0||w<=x[t]+X[i]||\n\t   y[t]+Y[i]<0||h<=y[t]+Y[i])continue;\n\tif(m[y[t]+Y[i]][x[t]+X[i]]=='#')continue;\n\ty[r]=y[t]+Y[i];\n\tx[r]=x[t]+X[i];\n\tm[y[r  ]][x[r++]]='#';\n\tc++;//printf(\"%d %d\\n\",y[r-1],x[r-1]);\n      }\n    }\n    printf(\"%d\\n\",c+1);\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(int argc, const char * argv[]) {\n    \n    int atinclease_count=0,h,w,i,j,atcount=0;\n    char table[21][21];\n    while (1) {\n        \n        scanf(\"%d %d \",&w,&h);\n        \n        if (h==0 && w==0) {\n            break;\n        }\n        \n        for (i=0; i<h; i++) {\n                //table[i][j] = getchar();\n                scanf(\"%s\",table[i]);\n        }\n        \n        while (1) {\n            \n            for (i=0; i<h; i++) {\n                for (j=0; j<w; j++) {\n                    if (table[i][j] == '@') {\n                        if (table[i-1][j]=='.') {\n                            table[i-1][j] = '@';\n                            atinclease_count++;\n                        }\n                        \n                        if (table[i+1][j]=='.') {\n                            table[i+1][j] = '@';\n                            atinclease_count++;\n                        }\n                        \n                        if (table[i][j-1]=='.') {\n                            table[i][j-1] = '@';\n                            atinclease_count++;\n                        }\n                        \n                        if (table[i][j+1]=='.') {\n                            table[i][j+1] = '@';\n                            atinclease_count++;\n                        }\n                    }\n                }\n            }\n            \n            if(atinclease_count == 0){\n                break;\n            }\n            \n            atinclease_count=0;\n            \n        }\n        \n        for (i=0; i<h; i++) {\n            for (j=0; j<w; j++) {\n                if (table[i][j]=='@') {\n                    atcount++;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\",atcount);\n        atcount=0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[20][20];\nint W,H;\n\nint head,tail;\ntypedef struct{\n    int x;\n    int y;\n} step;\n\nstep queue[900];\nchar line[30];\n\nint pop(step **next){\n    if(head==tail)return 0;\n    *next=&(queue[head]);\n    head++;\n    return 1;\n}\n\nvoid push(int x,int y){\n    queue[tail].x=x;\n    queue[tail].y=y;\n    tail++;\n}\n\nvoid clear(void){\n    head=0;\n    tail=0;\n}\n\nint isEmpty(void){\n    if(head==tail){\n        return 1;\n    }\n    return 0;\n}\n\nint isChecked(int x,int y){\n    if(map[x][y]&16||map[x][y]&1){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n\nvoid setChecked(int x,int y){\n    map[x][y]|=16;\n}\n\nint main(void){\n    while(scanf(\"%d %d\",&W,&H),W||H){\n        int x,y,count;\n        step* next;\n        for(y=0;y<20;y++){\n            for(x=0;x<20;x++){\n                map[x][y]=0;\n            }\n        }\n        clear();\n        for(y=0;y<H;y++){\n            scanf(\"%s\", line);\n            for(x=0;x<W;x++){\n                if(line[x]=='#'){\n                    map[x][y]=1;\n                }else if(line[x]=='@'){\n                    push(x,y);\n                    setChecked(x,y);\n                }\n            }\n        }\n        count=0;\n        while(pop(&next)){\n            count++;\n            x=next->x;\n            y=next->y;\n            if(x+1<W){\n                if(!isChecked(x+1,y)){\n                    push(x+1,y);\n                    setChecked(x+1,y);\n                }\n            }\n            if(x>0){\n                if(!isChecked(x-1,y)){\n                    push(x-1,y);\n                    setChecked(x-1,y);\n                }\n            }\n            if(y+1<H){\n                if(!isChecked(x,y+1)){\n                    push(x,y+1);\n                    setChecked(x,y+1);\n                }\n            }\n            if(y>0){\n                if(!isChecked(x,y-1)){\n                    push(x,y-1);\n                    setChecked(x,y-1);\n                }\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%s\", &a);\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\t\tchar a;\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n\tint i,j,k;\n\tchar c[21];\n\tint w,h;\n\tint map[22][22];\n\tint mapindex[22*22];\n\tint map_now,mapindex_now;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0;i<22;i++){\n\t\t\tfor(j=0;j<22;j++){\n\t\t\t\tmap[i][j]=-1;\n\t\t\t\tmapindex[i*w+j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<=h;j++){\n\t\t\tgets(c);\n\t\t\tif(j!=0){\n\t\t\t\tfor(i=1;i<=w;i++){\n\t\t\t\t\tswitch(c[i-1]){\n\t\t\t\t\t\tcase '#':map[i][j]=-1;break;\n\t\t\t\t\t\tcase '@':map[i][j]=1;mapindex[1]=i+j*(w+1);break;\n\t\t\t\t\t\tcase '.':map[i][j]=0;break;\n\t\t\t\t\t\tdefault :break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(j=0;j<22;j++){\n\t\t\tfor(i=0;i<22;i++){\n\t\t\t\tprintf(\"%2d\",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t\n\t\tmap_now=1;\n\t\tmapindex_now=1;\n\t\twhile(mapindex[mapindex_now]!=0){\n\t\t\tint x=(mapindex[mapindex_now]-1)%(w+1)+1;\n\t\t\tint y=mapindex[mapindex_now]/(w+1);\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(map[x-1][y]==0){\n\t\t\t\t\t\tmap_now++;\n\t\t\t\t\t\tmap[x-1][y]=map_now;\n\t\t\t\t\t\tmapindex[map_now]=(x-1)+y*(w+1);\n\t\t\t\t\t}\n\t\t\t\t}else if(i==1){\n\t\t\t\t\tif(map[x+1][y]==0){\n\t\t\t\t\t\tmap_now++;\n\t\t\t\t\t\tmap[x+1][y]=map_now;\n\t\t\t\t\t\tmapindex[map_now]=(x+1)+y*(w+1);\n\t\t\t\t\t}\n\t\t\t\t}else if(i==2){\n\t\t\t\t\tif(map[x][y-1]==0){\n\t\t\t\t\t\tmap_now++;\n\t\t\t\t\t\tmap[x][y-1]=map_now;\n\t\t\t\t\t\tmapindex[map_now]=x+(y-1)*(w+1);\n\t\t\t\t\t}\n\t\t\t\t}else if(i==3){\n\t\t\t\t\tif(map[x][y+1]==0){\n\t\t\t\t\t\tmap_now++;\n\t\t\t\t\t\tmap[x][y+1]=map_now;\n\t\t\t\t\t\tmapindex[map_now]=x+(y+1)*(w+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapindex_now++;\n\t\t}\n\t\tprintf(\"%d\\n\",mapindex_now-1);\n\t\t/*for(j=0;j<22;j++){\n\t\t\tfor(i=0;i<22;i++){\n\t\t\t\tprintf(\"%2d\",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfor(i=0;i<10;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tprintf(\"%d\\n\",mapindex[i*w+j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p;\n\twhile(1){\n\tp=0;\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[i]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[i][j]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "int w, h;\nint map[32][32];\n\nint dx[] = {0, 1, 0 ,-1};\nint dy[] = {-1, 0, 1, 0};\n\nint count = 0;\n\nvoid solve(int x, int y)\n{\n    int i, nextX, nextY;\n    count++;\n    map[y][x] = '#';\n    for (i = 0; i < 4; i++)\n    {\n        nextX = x + dx[i];\n        nextY = y + dy[i];\n        if (0 <= nextX && nextX < w && 0 <= nextY && nextY < h)\n        {\n            if (map[nextY][nextX] != '#')\n                solve(nextX, nextY);\n        }\n    }\n}\n\nint main()\n{\n    int i, j;\n    int x, y;\n    while (1)\n    {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n        for (i = 0; i < h; i++)\n        {\n            for (j = 0; j < w; j++)\n            {\n                map[i][j] = getchar();\n                if (!(map[i][j] == '.' || map[i][j] == '#' || map[i][j] == '@'))\n                {\n                    j--;\n                    continue;\n                }\n                if (map[i][j] == '@')\n                {\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n        count = 0;\n        solve(x, y);\n        printf(\"%d\\n\", count);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar m[22][22];\nint W,H,w,h,i,j;\n\nint s(int y,int x)\n{\n\tif(m[y][x]!='.'&&m[y][x]!='@')\n\t\treturn 0;\n\tm[y][x]=0;\n\treturn s(y+1,x)+s(y-1,x)+s(y,x+1)+s(y,x-1)+1;\n\t\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=W+1;j++)\n\t\t\t{\n\t\t\t\tm[i][j]=getchar();\n\t\t\t\tif(m[i][j]=='@')\n\t\t\t\t\th=i,w=j;\n\t\t\t}\n\t\tprintf(\"%d\\n\",s(h,w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c,gx,gy;\nchar map[20][20];\ncheck(x,y)\n{\n  map[x][y]=35;\n  c++;\n  if(x+1<gy&&map[x+1][y]==46)\n    check(x+1,y);\n  if(x>0&&map[x-1][y]==46)\n    check(x-1,y);\n  if(y+1<gx&&map[x][y+1]==46)\n    check(x,y+1);\n  if(y>0&&map[x][y-1]==46)\n    check(x,y-1);\n}\n\nint main()\n{\n  int n,m,x,y;\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      for(x=0;x<20;x++)\n\tfor(y=0;y<20;)\n\t  map[x][y++]=35;\n      for(c=n=0;n<gy;n++)\n\t{\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]==64)\n\t      x=n,y=m;\n\t}\n      check(x,y);\n      printf(\"%d\\n\",c);\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1130\nRed and Black\n*/\n#include <stdio.h>\n\nchar tile[20][21];\nint W,H;\n\nvoid find_start(int * x,int * y)\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(tile[i][j] == '@')\n\t{\n\t  *x = j;\n\t  *y = i;\n\t  return;\n\t}\n  *x=*y=0;\n}\nint count_black(x,y)\n{ int ret;\n  ret=0;\n\n  if(tile[y][x]=='@' || tile[y][x]=='.')\n    {\n      ret=1;\n      tile[y][x]='*';\n      if(x < W-1)\n\tret += count_black(x+1,y);\n      if(x > 0)\n\tret += count_black(x-1,y);\n      if(y < H-1)\n\tret += count_black(x,y+1);\n      if(y > 0)\n\tret += count_black(x,y-1);\n    }\n  return(ret);\n}\n\nmain()\n{\n  int i,x,y,ret;\n\n  while(EOF!=scanf(\"%d %d\",&W, &H) && ((W > 0) || (H > 0)))\n    {\n      for(i=0;i<H;i++)\n\tscanf(\"%s\",&(tile[i][0]));\n\n      find_start(&x,&y);\n\n      ret=count_black(x,y);\n\n      printf(\"%d\\n\",ret);\n    }\n\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][21];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n   \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar m[30][30];\nint W,H,w,h,i,j;\n\nint s(int y,int x)\n{\n\tif(m[y][x]!='.')\n\t\treturn 0;\n\tm[y][x]=0;\n\treturn s(y+1,x)+s(y-1,x)+s(y,x+1)+s(y,x-1)+1;\n\t\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{ \n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<W+2;j++)\n\t\t\t{\n\t\t\t\tm[i][j]=getchar();\n\t\t\t\tif(m[i][j]=='@')\n\t\t\t\t\th=i,w=j,m[i][j]='.';\n\t\t\t}\n\t\tprintf(\"%d\\n\",s(h,w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint w, h; /* 部屋の幅と高さ */\nint t[400]; /* タイルの配置 */\nint RED = 1, BLACK = 0;\n\n/* 与えられた座標のタイルを始点としたときに到達できるタイルの数を返す */\nint search(int x, int y) {\n\tint n = 0;\n\tif (t[w * y + x] != BLACK) return n;\n\tt[w * y + x] = RED;\n\tn++;\n\tif (x > 0)     n += search(x - 1, y);\n\tif (x < w - 1) n += search(x + 1, y);\n\tif (y > 0)     n += search(x, y - 1);\n\tif (y < h - 1) n += search(x, y + 1);\n\treturn n;\n}\n\nint main(void) {\n\tint sx, sy; /* 人の初期座標 */\n\tint i, j;\n\n\t/* データセット毎の処理 */\n\twhile (scanf(\"%d%d\", &w, &h) == 2) {\n\t\tif (w < 1 || w > 20 || h < 1 || h > 20) break;\n\t\t/* タイルの配置を読み込む */\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tscanf(\"%*[^.#@]\"); /* 改行などを無視する */\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tchar c;\n\t\t\t\tscanf(\"%c\", &c);\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '@': /* 黒いタイルの上の人 (一つのデータセットに1度だけ出現) */\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\tcase '.': /* 黒いタイル */\n\t\t\t\t\tt[w * i + j] = BLACK;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#': /* 赤いタイル */\n\t\t\t\tdefault:\n\t\t\t\t\tt[w * i + j] = RED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", search(sx, sy));\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "char m[30][30];\nW,H,w,h,i,j;\n\nint s(int y,int x)\n{\n\tif(m[y][x]!='.')\n\t\treturn 0;\n\tm[y][x]=0;\n\treturn s(y+1,x)+s(y-1,x)+s(y,x+1)+s(y,x-1)+1;\n\t\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{ \n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<W+2;j++)\n\t\t\t{\n\t\t\t\tm[i][j]=getchar();\n\t\t\t\tif(m[i][j]=='@')\n\t\t\t\t\th=i,w=j,m[i][j]='.';\n\t\t\t}\n\t\tprintf(\"%d\\n\",s(h,w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n \nint width,height;\nchar map[20][21];\n \nint tansaku(int x,int y) {\n    int result=1;\n    if(x<0 || x>=width || y<0 || y>=height)return 0;\n    if(map[y][x]=='#')return 0;\n    map[y][x]='#';\n    result+=tansaku(x-1,y);\n    result+=tansaku(x+1,y);\n    result+=tansaku(x,y-1);\n    result+=tansaku(x,y+1);\n    return result;\n}\n \nint main(void) {\n    int i,j;\n    int sx,sy;\n    while(1) {\n        scanf(\"%d%d\",&width,&height);\n        if(width==0 && height==0)break;\n        for(i=0;i<height;i++) {\n            scanf(\"%s\",map[i]);\n            for(j=0;j<width;j++) {\n                if(map[i][j]=='@'){sx=j;sy=i;}\n            }\n        }\n        printf(\"%d\\n\",tansaku(sx,sy));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint map[22][22];\nint w, h;\nint v;\n\nint main(void){\n\tint i, x, y;\n\t\n\tscanf(\"%d %d\", &w, &h);\n\twhile(w && h){\n\t\tfor(i=0; i<w*h; i++){\n\t\t\tswitch (getchar()){\n\t\t\tcase 10:\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tmap[i%w + 1][i/w + 1] = 1;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\tmap[i%w + 1][i/w + 1] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '@':\n\t\t\t\tmap[x = i%w + 1][y = i/w + 1] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tv = 0;\n\t\tsearching(x, y);\n\t\tprintf(\"%d\\n\", v);\n\t\tscanf(\"%d %d\", &w, &h);\n\t}\n\t\n\treturn 0;\n}\n\nint searching(int X, int Y){\n\tif(map[X][Y] == 1){\n\t\tmap[X][Y] = 2;\n\t\tv++;\n\t\tif(X>0) searching(X-1, Y);\n\t\tif(X<w) searching(X+1, Y);\n\t\tif(Y>0) searching(X, Y-1);\n\t\tif(Y<h) searching(X, Y+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nmain(){\n  int i,j,k,w,h,a[20][20],jud,c,x,y;\n  char n[22];\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&n);\n      for(j=0;j<w;j++){\n\tif(n[j]=='.') a[j][i]=1;\n\telse if(n[j]=='#') a[j][i]=0;\n\telse if(n[j]=='@') {\n\t  a[j][i]=2;\n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n    jud=1;\n    c=1;\n    for(i=0;i<1100;i++){\n      jud=0;\n      if(a[x-1][y]==1&&x>0){\n\ta[x-1][y]=2;\n\tc++;\n\tx--;\n\tjud=1;\n      }\n      else if(a[x+1][y]==1&&x<w-1){\n\ta[x+1][y]=2;\n\tc++;\n\tx++;\n\tjud=1;\n      }\n      else if(a[x][y-1]==1&&y>0){\n\ta[x][y-1]=2;\n\tc++;\n\ty--;\n\tjud=1;\n      }\n      else if(a[x][y+1]==1&&y<h-1){\n\ta[x][y+1]=2;\n        c++;\n\ty++;\n\tjud=1;\n      }\n      else{\n\tfor(j=2;j<100;j++){     \n\t  if(a[x-1][y]==j&&x>0){\n\t    a[x-1][y]++;\t   \n\t    x--;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x+1][y]==j&&x<w-1){\n\t    a[x+1][y]++;\n\t    x++;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x][y-1]==j&&y>0){\n\t    a[x][y-1]++;\t    \n\t    y--;\n\t    jud=1;\n\t    break;\n\t  }\n\t  else if(a[x][y+1]==j&&y<h-1){\n\t    a[x][y+1]++;\t  \n\t    y++;\n\t    jud=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(jud==0) break;\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\n\tfor (int i = 0; i<4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", s[i]);\n\t\t}\n\n\t\tfor(int i = 0; i<h; i++){\n\t\t\tfor(int j = 0; j<w; j++){\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n    int x,y;\n    int now_x,now_y;\n    int tmp;\n    int board[22][22];\n    int i,j;\n    int end_flag = 0;\n    int cnt = 0;\n\n\n\n    while(1){\n        scanf(\"%d %d\", &x, &y);\n        \n        if(x == 0 && y == 0){\n            return 0;\n        }\n\n        for(i = 0; i < 22; i++){\n            for(j = 0; j < 22; j++){\n                board[i][j] = -1;\n            }\n        }\n\n        for(i = 1; i <= y; i++){\n            for(j = 1; j <= x; j++){\n                tmp = getchar();\n                if(tmp == '\\n'){\n                    tmp = getchar();\n                }\n                switch(tmp){\n                    case '.': board[i][j] = 1;break;\n                    case '#': board[i][j] = 0;break;\n                    case '@': board[i][j] = 2;break;\n                }\n            }\n        }\n\n        end_flag = 0;\n        while(end_flag == 0){\n            end_flag = 1;\n\n            for(i = 1; i <= y; i++){\n                for(j = 1; j <= x; j++){\n                    if(board[i][j] == 2){\n                        if(board[i + 1][j] == 1){\n                            end_flag = 0;\n                            board[i + 1][j] = 2;\n                        }\n                        if(board[i - 1][j] == 1){\n                            end_flag = 0;\n                            board[i - 1][j] = 2;\n                        }\n                        if(board[i][j + 1] == 1){\n                            end_flag = 0;\n                            board[i][j + 1] = 2;\n                        }\n                        if(board[i][j - 1] == 1){\n                            end_flag = 0;\n                            board[i][j - 1] = 2;\n                        }\n                    }\n                }\n            }\n        }\n        \n        cnt = 0;\n        for(i = 1; i <= y; i++){\n           for(j = 1; j <= x; j++){\n               if(board[i][j] == 2){\n                   cnt++;\n               }\n           }\n        }\n        printf(\"%d\\n\", cnt);\n    }\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nunsigned short room[22][22];\n\nvoid DFS(unsigned short x, unsigned short y);\n\nint main(void) {\n\n\tunsigned short W, H, manx, many;\n\tunsigned short i, j, count = 0;\n\tchar c[32];\n\twhile(1){\n\t\tcount=0;\n\t\tscanf(\"%hu%hu%*c\", &W, &H);\n\t\tif(W==0 && H==0) break;\n\t\tfor(i = 0; i < H + 2; i++) {\n\t\t\tif(i>0 && i<H+1) scanf(\"%s\",c);\n\t\t\tfor(j = 0; j < W + 2; j++) {\n\t\t\t\tif(i == 0 || j == 0 || i == H + 1 || j == W + 1) room[i][j] = 0;\n\t\t\t\telse{\n\t\t\t\t\t//putchar(c[j-1]);\n\t\t\t\t\tif(c[j-1]=='#') room[i][j]=0;\n\t\t\t\t\telse if(c[j-1]=='.') room[i][j]=1;\n\t\t\t\t\telse room[i][j]=2;\n\t\t\t\t}\n\n\t\t\t\tif(room[i][j] == 2) {\n\t\t\t\t\tmanx = i;\n\t\t\t\t\tmany = j;\n\t\t\t\t\troom[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDFS(manx, many);\n\n\t\tfor(i = 1; i < H + 1; i++) for(j = 1; j < W + 1; j++) count += (room[i][j] == 2);\n\n\t\tprintf(\"%hd\\n\", count);\n\t}\n\treturn 0;\n}\n\nvoid DFS(unsigned short x, unsigned short y) {\n\tif(room[x][y] != 1) return;\n\troom[x][y] = 2;\n\tDFS(x - 1, y);\n\tDFS(x + 1, y);\n\tDFS(x, y - 1);\n\tDFS(x, y + 1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define W 21\n#define H 20\n\nint tileCount(char room[H][W], int row, int col, int h, int w);\n\nint main()\n{\n  char room[H][W];\n  int h;    // 部屋の行方向のタイルの枚数\n  int w;    // 部屋の列方向のタイルの枚数\n  int row;  // 最初に人が立っている行位置\n  int col;  // 最初に人が立っている列位置\n  int i, j;\n\n  // 部屋の情報を、配列room[]に文字列として読み込む\n  scanf(\"%d%d\", &w, &h);\n  while (h != 0 && w != 0) {\n    for (i = 0; i < h; i++) {\n      scanf(\"%s\", room[i]);\n      for (j = 0; j < w; j++) {\n        if (room[i][j] == '@') {\n          row = i;  // 最初に人が立っている行位置\n          col = j;  // 最初に人が立っている列位置\n        }\n      }\n    }\n    printf(\"%d\\n\", tileCount(room, row, col, h, w));\n\n    scanf(\"%d%d\", &w, &h);\n  }\n  \n  return(0);\n}\n\nint tileCount(char room[H][W], int row, int col, int h, int w){\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  int nx,ny;\n  int i,j;\n  int cnt=0;\n  for(i=0;i<4;i++){\n    nx=col+dx[i];\n    ny=row+dy[i];\n    if(nx>=0 && ny>=0 && nx<w && ny<h && room[ny][nx]!='#'){\n      room[ny][nx]='#';\n      cnt++;\n      cnt+=tileCount(room,ny,nx,h,w);\n    }\n  }\n  return cnt;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint solve(int W, int H){\n  char room[20][20];\n  int x, y, i;\n  \n  for(i = 0; i < H; i++){\n    scanf(\"%s\\n\", room[i]);\n  }\n\n  for(y = 0; y < H; y++){\n    for(x = 0; x < W; x++){\n      if(room[y][x] == '@')\n\treturn dfs(room , W, H, x, y, 0);\n    }\n  }\n  return 0;\n}\n\nint dfs(char room[][20], int W, int H, int x, int y, int n){\n  int nx, ny, i;\n  if(room[y][x] == '@') n = 1;\n  else if(room[y][x] == '.') n++;\n\n  room[y][x] = '/';\n\n  for(i = 0; i < 4; i++){\n    switch(i){\n    case 0:  //left\n      nx = x - 1;\n      ny = y;\n      break;\n    case 1:  //up\n      nx = x;\n      ny = y - 1;\n      break;\n    case 2:  //right\n      nx = x + 1;\n      ny = y;\n      break;\n    case 3:  //down\n      nx = x;\n      ny = y + 1;\n      break;\t\t\t\t      \n    } \n    if((0 <= nx && nx < W) && (0 <= ny && ny < H)){\n      if(room[ny][nx] == '.'){\n\tn = dfs(room, W, H, nx, ny, n);\n      }\n    }\n  }\n  return n;\n}\n\nint main(void){\n  int W, H;\n  while(1){\n    scanf(\"%d %d\", &W, &H);\n    if(W == 0 && H == 0) return 0; \n    else printf(\"%d\\n\", solve(W, H));\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "int T[20][20],X,Y,x,y,p,q,i,c;\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&!T[y][x])?T[y][x]=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",i)){\n\tfor(i=0;i<X*Y;i++){\n\t\tfor(x=i%X,y=i/X;(c=getchar())=='\\n';);\n\t\tswitch(c){\n\t\t\tcase'@':p=x;q=y;\n\t\t\tcase'.':T[y][x]=0;break;\n\t\t\tcase'#':T[y][x]=1;\n\t\t}\n\t}\n\ti=0;R(p,q);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=0,w,h;\nchar Map[20][22];\nint main()\n{\n  int i,j,ii,jj,n=0;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    move(ii,jj);\n    printf(\"%d\\n\",count);\n    count=0;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 30\n\nint count;\n\nvoid paint_map(\n    int h,int w,char map[N][N],\n    int x,int y){\n  if(x==-1 || y==-1 || x==h || y==w)\n    return ;\n  if(map[x][y]=='#')\n    return ;\n\n  map[x][y]='#';\n  count++;\n\n  paint_map(h,w,map,x-1,y);\n  paint_map(h,w,map,x+1,y);\n  paint_map(h,w,map,x,y-1);\n  paint_map(h,w,map,x,y+1);\n}\n\nint main(void){\n  int i,j;\n  int w,h,sx,sy;\n  char map[N][N],hoge;\n\n  for(;;){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0 && h==0)\n      break;\n\n    for(i=0;i<h;i++){\n      scanf(\"%c\",&hoge);\n      for(j=0;j<w;j++){\n        scanf(\"%c\",&map[i][j]);\n        if(map[i][j]=='@'){\n          sy=i;\n          sx=j;\n        }\n      }\n    }\n\n    count=0;\n    paint_map(h,w,map,sy,sx);\n\n    printf(\"%d\\n\",count);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h)return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdlib.h>\n#include<stdio.h>\n#define TRUE 1\n#define MAX 22\n\nint map[MAX][MAX];\nint w,h;\nint count;\n\nvoid move();\n\nint main(void) {\n\tint x,y;\n\tchar buff;\n\tint i,j;\n\t\n\twhile(TRUE) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif(w==0 && h==0) break;\n\t\tfor(i=0;i<MAX;i++) {\n\t\t\tfor(j=0;j<MAX;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=h;i++) {\n\t\t\tfor(j=1;j<=w;j++) {\n\t\t\t\tscanf(\"%c\", &buff);\n\t\t\t\tif(buff=='.') map[j][i] = 1;\n\t\t\t\telse if(buff=='#') map[j][i] = 0;\n\t\t\t\telse if(buff=='@') {//\n\t\t\t\t\tmap[j][i] = 1;\n\t\t\t\t\tx=j;\n\t\t\t\t\ty=i;\n\t\t\t\t}//\n\t\t\t\telse j--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=0;i<MAX;i++) {\n\t\t\tfor(j=0;j<MAX;j++) {\n\t\t\t\t//printf(\"%d\", map[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\tcount = 0;\n\t\tmove(x,y);\n\t\t\n\t\tprintf(\"%d\\n\", count);\n\t}\n\t\n\texit(0);\n}\n\nvoid move(int x,int y) {\n\tif(map[x][y] == 1) {\n\t\tmap[x][y] = 2;\n\t\tcount++;\n\t}\n\telse return;\n\t//???\n\tmove(x,y+1);\n\t//???\n\tmove(x,y-1);\n\t//???\n\tmove(x-1,y);\n\t//???\n\tmove(x+1,y);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint c,gx,gy;\nchar map[20][20];\nvoid check(int x,int y)\n{\n  int n;\n  //    printf(\"check %d %d \\n\",x,y);\n  map[x][y]='#';\n  c++;\n \n  if(x+1<gy && map[x+1][y]=='.')\n      check(x+1,y);\n  if(x>0 && map[x-1][y]=='.')\n      check(x-1,y);\n  if(y+1<gx && map[x][y+1]=='.')\n      check(x,y+1);\n  if(y>0 && map[x][y-1]=='.')\n      check(x,y-1);\n}\n\nint main()\n{\n  int n,m,x,y;\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      //      puts(\"start\");\n      for(x=0;x<20;x++)\n      for(y=0;y<20;y++)\n\tmap[x][y]='#';\n      for(n=0;n<gy;n++)\n\t{\n\t  //  printf(\"now %d\\n\",n);\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]=='@')\n\t      {\n\t\tx=n,y=m;\n\t      }\n\n\n\t}\n      //      puts(\"scan end\");\n      //      for(n=0;n<gy;n++)\n      //\tputs(map[n]);\n\n      c=0;\n      check(x,y);\n     printf(\"%d\\n\",c);\n     // for(n=0;n<gy;n++)\n\t//\tputs(map[n]);\n\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst char red_tile = '#';\nconst int step[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint count_area(char t[][21], int x, int y, int w, int h) {\n    int i, count = 0;\n    if (x < 0 || w <= x || y < 0 || h <= y) return 0;\n    if (t[y][x] == red_tile) return 0;\n    t[y][x] = red_tile;\n    count += 1;\n    for (i = 0; i < 4; i++) {\n        count += count_area(t, x+step[i][0], y+step[i][1], w, h);\n    }\n    return count;\n}\n\nint main() {\n    int w, h, i, sx, sy;\n    char *p;\n    char tile[20][21];\n\n    while (scanf(\"%d%d\\n\", &w, &h) != EOF && w && h) {\n        for (i = 0; i < h; i++) {\n            scanf(\"%s\", &tile[i]);\n            if ((p = strchr(tile[i], '@')) != NULL) {\n                sx = p - (char*)&tile[i];\n                sy = i;\n            }\n        }\n        printf(\"%d\\n\", count_area(tile, sx, sy, w, h));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "T[20][20],X,Y,x,y,p,q,i,c;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&!t)?t=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\n\tfor(i=0;i<X*Y;i++){\n\t\tfor(x=i%X,y=i/X;(c=getchar())=='\\n';);\n\t\tswitch(c){\n\t\t\tcase'@':p=x;q=y;\n\t\t\tcase'.':t=0;break;\n\t\t\tcase'#':t=1;\n\t\t}\n\t}\nexit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\nint ans;\nchar s[20][21];\nint b[20][20];\nvoid dfs(int h,int w,int i,int j){\n  if(s[i][j]!='#'&&b[i][j]==0){\n    b[i][j]=1;\n    ans++;\n  }\n  else\n    return ;\n  if(i>0)\n    dfs(h,w,i-1,j);\n  if(i<h-1)\n    dfs(h,w,i+1,j);\n  if(j>0)\n    dfs(h,w,i,j-1);\n  if(j<w-1)\n    dfs(h,w,i,j+1);\n}\nint main(void){\n  int h,w,i,j;\n  //char s[20][21];\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(!w)\n      break;\n    memset(b,0,sizeof(b));\n    for(i=0;i<h;i++)\n      scanf(\"%s\",s[i]);\n    ans=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(s[i][j]=='@')\n\t  goto LOOP_END;\n      }\n    }LOOP_END:\n    dfs(h,w,i,j);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct {\n  int row;\n  int col;\n} Coord;\n\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\n\nint solve (int W, int H);\n\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n\nint main () {\n  int W, H;\n\n  while(scanf(\"%d%d\", &W, &H))\n    {\n      if(W==0&&H==0)\n\tbreak;\n      else\n\tprintf(\"%d\\n\", solve(W,H));\n    }\n\n  return 0;\n}\n\n\nint solve (int W, int H) {\n  stack S = new_stack ();  \n  char M[H+2][W+2]; \n  Coord start;   \n  int i, j, tile=1;\n\n \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n\n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n\n  push(S,start); \n\n  while (!is_empty(S)) {\n    Coord current = pop(S);                  \n    int d;                                 \n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};\n    \n    for (d=0; d<4; d++) {\n      Coord nc = current;\n      \n      if(M[nc.row + D1[d]][nc.col + D2[d]] == '.')\n\t{\n\t  nc.row += D1[d];\n\t  nc.col += D2[d];\n\t  push(S,nc);\n\t  M[nc.row][nc.col] = '*';\n\t  tile++;\n\t}\n    }\n  }\n  return tile;\n}\n\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint a[22][22];\nint w,h;\n\nint r(int x,int y){\n  int rtn = 1;\n  a[x][y] = 0;\n\n  if( a[x-1][y  ]==1 ) rtn += r( x-1,y   );\n  if( a[x  ][y-1]==1 ) rtn += r( x  ,y-1 );\n  if( a[x  ][y+1]==1 ) rtn += r( x  ,y+1 );\n  if( a[x+1][y  ]==1 ) rtn += r( x+1,y   );\n  return rtn;\n}\nint main(void){\n  int i,j;\n  char c;\n  int x,y;\n\n  while( 1 ){\n    scanf(\"%d %d \",&w,&h );\n    if( !w && !h )\n      break;\n\n    for( i=0;i<=h+1;i++){\n      for( j=0;j<=w+1;j++ ){\n\tif( i==0 || i==h+1 || j==0 || j==w+1 ){\n\t  a[i][j] = 0;\n\t  continue;\n\t}\n\n\tscanf(\"%c \",&c );\n\tif( c=='.' ){\n\t  a[i][j] = 1;// black\n\t}else if( c=='#' ){\n\t  a[i][j] = 0;// red\n\t} else{\n\t  a[i][j] = 1;\n\t  x=i;y=j;\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",r(x,y) );\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "T[22][22],X,Y,x,y,p,q,i;\n#define t T[y][x]\nvoid R(x,y){t?t=0,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\nfor(i=0;i<X*Y;i++)switch(x=i%X+1,y=i/X+1,getchar()){\n\tcase 10:i--;break;\n\tcase'@':p=x;q=y;\n\tcase'.':t=1;break;\n\tcase'#':t=0;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nconst int INF = 10000000;\n\nint W, H, bx, by;\nchar tile[21][21];\nint d[21][21];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nvoid bfs();\n\nvoid solve();\n\n\nint main(){\n  int i, j;\n  while(scanf(\"%d%d\", &W, &H) && (W || H)){\n    //scanf(\"%d%d\", &W, &H);\n      for(i = 0 ; i < H; i++){\n        scanf(\"%s\", tile[i]);\n      }\n      for(i = 0; i < W; i++){\n        for(j = 0; j < H; j++){\n          if(tile[j][i] == '@'){\n            bx = i;\n            by = j;\n          }\n        }\n      }\n      //printf(\"%d %d\\n\", bx, by);\n      solve();\n    }\n  return 0;\n}\n\nvoid bfs(){\n  struct pair{\n    int first;\n    int second;\n  };\n\n  struct queue{\n    struct pair P[101];\n    int head;\n    int tail;\n  };\n\n  struct queue que;\n  que.head = 0;\n  que.tail = 0;\n  int i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      d[j][i] = INF;\n    }\n  }\n\n  que.P[que.tail].first = bx;\n  que.P[que.tail].second = by;\n  d[by][bx] = 0;\n  que.tail++;\n  //que.head++;\n\n  while(que.head < que.tail){\n    struct pair state;\n    state.first = que.P[que.head].first;\n    state.second = que.P[que.head].second;\n    que.head++;\n    //printf(\"%d %d\\n\" ,que.head, que.tail);\n    //if(p.first == gx && p.second == gy) break;\n\n    for(i = 0; i < 4; i++){\n      int nx = state.first + dx[i], ny = state.second + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && tile[ny][nx] != '#' && d[ny][nx] == INF){\n        que.P[que.tail].first = nx;\n        que.P[que.tail].second = ny;\n        que.tail++;\n        d[ny][nx] = d[state.first][state.second] + 1;\n      }\n    }\n  }\n  //return d[gx][gy];\n\n}\n\nvoid solve(){\n  bfs();\n  int ans = 0, i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      //printf(\"%d\\n\", d[i][j]);\n      if(d[j][i] != INF) ans++;\n    }\n  }\n  //printf(\"%d\\n\",INF);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "c,gx,gy,n,m,x,y;\nchar map[20][20];\ncheck(x,y)\n{\n  map[x][y]=35;\n  c++;\n  if(x+1<gy&&map[x+1][y]==46)\n    check(x+1,y);\n  if(x>0&&map[x-1][y]==46)\n    check(x-1,y);\n  if(y+1<gx&&map[x][y+1]==46)\n    check(x,y+1);\n  if(y>0&&map[x][y-1]==46)\n    check(x,y-1);\n}\nmain()\n{\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      for(x=0;x<20;x++)\n\tfor(y=0;y<20;)\n\t  map[x][y++]=35;\n      for(c=n=0;n<gy;n++)\n\t{\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]==64)\n\t      x=n,y=m;\n\t}\n      check(x,y);\n      printf(\"%d\\n\",c);\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "W,C;char m[484];R(i){m[i]>45?m[i]=0,C++,R(i-1),R(i+1),R(i-W),R(i+W):0;}main(p){for(;scanf(\"%d%*d\",&W)*W;C=!printf(\"%d\\n\",C))memset(p=m,W++,484),scanf(\"%[^0-9]\",m+W),R(strchr(m,64)-p);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 32\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( ( x < 0 && x >= w )\n    || ( y < 0 && y >= h )\n    || d[ y ][ x ] != '.' ) return ( 0 );\n\n  d[ y ][ x ] = '#';\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx = 0, sy = 0;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[21][21];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar map[20][21];\nchar count[20][20];\nint s1, s2;\nvoid solve(int y, int x) {\n\tif (!count[y][x]) {\n\t\tif (map[y][x] == '.' || map[y][x] == '@') {\n\t\t\tcount[y][x] = 1;\n\t\t\tif (y < s2 - 1) solve(y + 1, x);\n\t\t\tif (y > 0) solve(y - 1, x);\n\t\t\tif (x < s1 - 1) solve(y, x + 1);\n\t\t\tif (x > 0) solve(y, x - 1);\n\t\t}\n\t}\n}\nint main() {\n\tint i, j, ans, point[2];\n\twhile (1) {\n\t\tscanf(\"%d %d\", &s1, &s2);\n\t\tif (!(s1||s2)) break;\n\t\tfor (i = 0; i < s2; i ++) scanf(\"%s\", map[i]);\n\t\tfor (i = 0; i < s2; i ++) for (j = 0; j < s1; j ++) if (map[i][j] == '@') {\n\t\t\tpoint[0] = i; point[1] = j;\n\t\t}\n\t\tfor (i = 0; i < 20; i ++) for (j = 0; j < 20; j ++) count[i][j] = 0;\n\t\tans = 0;\n\t\tsolve(point[0], point[1]);\n\t\tfor (i = 0; i < s2; i ++) for (j = 0; j < s1; j ++) ans += count[i][j];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nvoid look_for(int,int,int,int);\n\nchar map[20][20];\nint cnt;\n\nint main(){\n  int i,j,w,h;\n  while(1){\n    cnt=0;\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]=='@')\n\t  look_for(i,j,h,w);\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}\n\nvoid look_for(int h,int w,int height,int width){\n  int i,j;\n  if(map[h][w]=='.'){\n    cnt++;\n    map[h][w]='N';\n  }\n  for(i=-1;i<=1;i++){\n    for(j=-1;j<=1;j++){\n      if(i==j || i==-j || i+h<0 || j+w<0 ||i+h>height || j+w>width || (i==0 && j==0))continue;\n      if(map[i+h][w+j]=='.')look_for(i+h,j+w,height,width);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "a['~~'],v;f(char*p){int i=4;for(;i;--*p-45||++v-f(p))p+=\"G&G\"[--i]-36;}main(){for(;scanf(\"%*d%d\",&v)*v;printf(\"%d\\n\",v+1))for(memset(a,0,4e3);v;scanf(\"%s\",a+9*v--));}"
  },
  {
    "language": "C",
    "code": "W,H,C;char m[484];R(i){m[i]>45?m[i]=0,C++,R(i-1),R(i+1),R(i-W),R(i+W):0;}main(i){for(;scanf(\"%d%d\",&W,&H)*W;i=m,R(strchr(m,64)-i),C=!printf(\"%d\\n\",C))for(memset(m,W++,484),i=H*W;i--;)m[W+i]=getchar();}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define W 21\n#define H 21\n\ntypedef struct Queue{\n    int q_x, q_y;\n    struct Queue *next;\n} Queue;\n\nchar board[W][H];\nint check[W][H];\nQueue *top, *bot;\nint ans, wid, hei;\nint dx[4] = {0, 1, 0, -1}, \n    dy[4] = {1, 0, -1, 0};\n\nint plus_check(int a, int b);\nvoid push(int a, int b);\nQueue *pop(void);\nvoid wfs(void);\n\nint main(void)\n{\n    int i, j, x = 200, y = 200;\n\n    scanf(\"%d %d\",&wid, &hei);\n\n    while (wid) {\n        for (i = 0; i < hei; i++) {\n            scanf(\"%s\",board[i]);\n        }\n\n        top = NULL;\n        bot = NULL;\n        ans = 1;\n        for (i = 0; i < hei; i++) {\n            for (j = 0; j < wid; j++) {\n                if (board[i][j] == '@') {\n                    //printf(\"start : %d %d\\n\",i,j);\n                    x = i; \n                    y = j;\n                }\n                check[i][j] = 0;\n            }\n        }\n        check[x][y] = 1;\n        for (i = 0; i < 4; i++) {\n            if (plus_check(x+dx[i], hei) && plus_check(y+dy[i], wid)) {\n                if (board[x + dx[i]][y + dy[i]] == '.') {\n                    push(x + dx[i], y + dy[i]);\n                    check[x + dx[i]][y + dy[i]] = 1;\n                }\n            }\n        }\n        wfs();\n        printf(\"%d\\n\",ans);\n        scanf(\"%d %d\",&wid, &hei);\n    }\n    return 0;\n}\n\nvoid wfs(void) \n{\n    int i;\n    Queue *now;\n    now = pop();\n    while (now != NULL) {\n        ans++;\n        for (i = 0; i < 4; i++) {\n            if (plus_check(now->q_x+dx[i], hei) && \n                    plus_check(now->q_y+dy[i], wid)) {\n                if (board[now->q_x + dx[i]][now->q_y + dy[i]] == '.'\n                        && !check[now->q_x + dx[i]][now->q_y + dy[i]] )  {\n                    push(now->q_x + dx[i], now->q_y + dy[i]);\n                    check[now->q_x + dx[i]][now->q_y + dy[i]] = 1;\n                }\n            }\n        }\n        now = pop();\n    }\n}\n\nvoid push(int a, int b)\n{\n    Queue *new;\n    //printf(\"%d %d\\n\",a, b);\n    new = (Queue *)malloc(sizeof(Queue));\n    new->q_x = a;\n    new->q_y = b;\n    new->next = NULL;\n    if (bot == NULL) {\n        bot = new;\n        top = new;\n    } else {\n        top->next = new;\n        top = new;\n    }\n}\n\nQueue *pop(void)\n{\n    Queue *tmp;\n    tmp = bot;\n    if (bot != NULL) {\n        bot = bot->next;\n    }\n    return tmp;\n}\n\nint plus_check(int a, int b)\n{\n    if (a < 0 || b <= a) {\n        return 0;\n    } else {\n        return 1;\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint W, H;\nchar map[20][20];\nint count;\n\nvoid visit2(int, int);\n\nvoid visit() {\n  int i, j;\n  count = 0;\n\n  for(i = 0; i < H; i++) {\n    for(j = 0; j < W; j++) {\n      if(map[i][j] == '@') {\n\tcount++;\n\tmap[i][j] = '#';\n\tvisit2(j, i);\n\treturn;\n      }\n    }\n  }\n}\n\nvoid visit2(int x, int y) {\n  int dir[4][2] = {{1, 0},\n\t\t   {0, 1},\n\t\t   {-1,0},\n\t\t   {0,-1}};\n  int dx, dy;\n  int i;\n  for(i = 0; i < 4; i++) {\n    dx = x + dir[i][0];\n    dy = y + dir[i][1];\n    if(dx >= 0 && dx < W && dy >= 0 && dy < H) {\n      if(map[dy][dx] == '.') {\n\tcount++;\n\tmap[dy][dx] = '#';\n\tvisit2(dx, dy);\n      }\n    }\n  }\n}\n\nint main() {\n  int i, j;\n  int a;\n  while(1) {\n    scanf(\"%d %d\", &W, &H);\n    if(W == 0 && H == 0) break;\n    for(i = 0; i < 20; i++) {\n      for(j = 0; j < 20; j++) {\n\tmap[i][j] = '#';\n      }\n    }\n\n    for(i = 0; i < H; i++) {\n      getchar();\n      for(j = 0; j < W; j++) {\n\tscanf(\"%c\", &map[i][j]);\n      }\n    }\n    visit();\n    printf(\"%d\\n\", count);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[32][32];\n\nint black(int y, int x)\n{\n    if (map[y][x] != '.' && map[y][x] != '@') return 0;\n    map[y][x] = '#';\n    return black(y - 1, x) + black(y + 1, x) + black(y, x - 1) + black(y, x + 1) + 1;\n}\n\nint main(void)\n{\n    int w, h;\n\n    while (scanf(\"%d %d\", &w, &h), w != 0){\n        int i, j;\n\n        for (i = 1; i <= h; i++) scanf(\"%s\", map[i] + 1);\n        for (i = 1; i <= h; i++){\n            for (j = 1; j <= w; j++){\n                if (map[i][j] == '@'){\n                    printf(\"%d\\n\", black(i, j));\n                    i = h, j = w;\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[21][21];\nint main()\n{\n  int i,j,ii,jj;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n   \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}{0,1}{0,-1}{-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1])=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1:\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint tf[20][20];\n\nint judge(int x,int y,int w,int h){\n  int cnt=1;\n  int i,j;\n  tf[x][y]=1;\n  if(x-1>=0){\n    if(tf[x-1][y]==0){\n      cnt+=judge(x-1,y,w,h);\n    }\n  }\n  if(y-1>=0){\n    if(tf[x][y-1]==0){\n      cnt+=judge(x,y-1,w,h);\n    }\n  }\n  if(x+1<=h-1){\n    if(tf[x+1][y]==0){\n      cnt+=judge(x+1,y,w,h);\n    }\n  }\n  if(y+1<=w-1){\n    if(tf[x][y+1]==0){\n      cnt+=judge(x,y+1,w,h);\n    }\n  }\n  return cnt;\n}\n\nvoid doit(int w,int h){\n  char maze[h][w+1];\n  int x,y;\n  int i,j;\n  for(i=0;i<h;i++){\n    scanf(\"%s\",maze[i]);\n    for(j=0;j<w;j++){\n      if(maze[i][j]=='#'){\n\ttf[i][j]=1;\n      }\n      else{\n\ttf[i][j]=0;\n\tif(maze[i][j]=='@'){\n\t  x=i;\n\t  y=j;\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",judge(x,y,w,h));\n}\n\nint main(){\n  int w,h;\n  scanf(\"%d %d\",&w,&h);\n  while(w!=0){\n    doit(w,h);\n    scanf(\"%d %d\",&w,&h);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \nchar map[22][22], mk[22][22];\nint que[500][2], top, end;\nint m[4][2] = {{1,0},{-1,0},{0,-1},{0,1}};\n \nint main()\n{\n    int w, h, i, r, c, r2, c2, ans;\n     \n    while (scanf(\"%d%d\", &w, &h) && w) {\n        memset(mk, 0, sizeof(mk));\n        for (i = 0, r = 0; r < h; r++) {\n            scanf(\"%s\", map[r]);\n            if (!i) for (c = 0; c < w; c++) if (map[r][c] == '@') {\n                que[0][0] = r, que[0][1] = c; mk[r][c] = 1, top = 0, end = 1, i = 1;\n            }\n        }\n        while (top < end) {\n            r = que[top][0], c = que[top++][1];\n            for (i = 0; i < 4; i++) {\n                r2 = r + m[i][0], c2 = c + m[i][1];\n                if (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == '#') continue;\n                if (mk[r2][c2]) continue;\n                mk[r2][c2] = 1;\n                que[end][0] = r2, que[end++][1] = c2;\n            }\n        }\n        for (ans = 0, r = 0; r < h; r++) for (c = 0; c < w; c++) ans += mk[r][c];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[20][20];\nint W,H;\n\nint head,tail;\ntypedef struct{\n    int x;\n    int y;\n} step;\n\nstep queue[900];\nchar line[30];\n\nint pop(step **next){\n    if(head==tail)return 0;\n    *next=&(queue[head]);\n    head++;\n    return 1;\n}\n\nvoid push(int x,int y){\n    queue[tail].x=x;\n    queue[tail].y=y;\n    tail++;\n}\n\nvoid clear(void){\n    head=0;\n    tail=0;\n}\n\nint isEmpty(void){\n    if(head==tail){\n        return 1;\n    }\n    return 0;\n}\n\nint isChecked(int x,int y){\n    if(map[x][y]&16||map[x][y]&1){\n        return 1;\n    }else{\n        return 0;\n    }\n}\n\nvoid setChecked(int x,int y){\n    map[x][y]|=16;\n}\n\nint main(void){\n    while(scanf(\"%d %d\",&W,&H),W||H){\n        int x,y,count;\n        step* next;\n        for(y=0;y<20;y++){\n            for(x=0;x<20;x++){\n                map[x][y]=0;\n            }\n        }\n        clear();\n        for(y=0;y<H;y++){\n            scanf(\"%s\", line);\n            for(x=0;x<W;x++){\n                if(line[x]=='#'){\n                    map[x][y]=1;\n                }else if(line[x]=='@'){\n                    push(x,y);\n                }\n            }\n        }\n        count=-1;\n        while(pop(&next)){\n            count++;\n            x=next->x;\n            y=next->y;\n            if(x+1<W){\n                if(!isChecked(x+1,y)){\n                    push(x+1,y);\n                    setChecked(x+1,y);\n                }\n            }\n            if(x>0){\n                if(!isChecked(x-1,y)){\n                    push(x-1,y);\n                    setChecked(x-1,y);\n                }\n            }\n            if(y+1<H){\n                if(!isChecked(x,y+1)){\n                    push(x,y+1);\n                    setChecked(x,y+1);\n                }\n            }\n            if(y>0){\n                if(!isChecked(x,y-1)){\n                    push(x,y-1);\n                    setChecked(x,y-1);\n                }\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nvoid look_for(int,int,int,int);\n\nchar map[20][20];\nint cnt;\n\nint main(){\n  int i,j,w,h;\n  while(1){\n    cnt=0;\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]=='@')\n\t  look_for(i,j,h,w);\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}\n\nvoid look_for(int h,int w,int height,int width){\n  int i,j;\n    cnt++;\n    map[h][w]='N';\n  for(i=-1;i<=1;i++){\n    for(j=-1;j<=1;j++){\n      if(i==j || i==-j || i+h<0 || j+w<0 ||i+h>=height || j+w>=width || (i==0 && j==0))continue;\n      if(map[i+h][w+j]=='.')look_for(i+h,j+w,height,width);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  while (1) {\n    int W, H;\n    scanf(\"%d%d\", &W, &H);\n    if (W==0 && H==0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n  int c = 1;               // ????????????????????????????????°???????????? 1 ??§?????????\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      nc.row += D1[d];  nc.col += D2[d]; \n      if (M[nc.row][nc.col] == '.') {\n\tM[nc.row][nc.col] = '*';               // ?????°???????????°?????????\n\tc++;                                   // ???????????????????????????????????????\n\tpush(S,nc);\n      } // nc ????????¢?´¢?????? (*) ????£? (#) ?????´?????????????????????\n    } \n  }\n  return c;  // ??°??????????????????????????°?????????\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "import java.util.*;\n    \npublic class Main {\n  private static Scanner sc = new Scanner(System.in);\n  public static void main(String...args) {\n    while(sc.hasNext()) {\n      final int W = sc.nextInt();\n      final int H = sc.nextInt();\n      if (W == 0 && H == 0)\n        break;\n      solve(W, H);\n    }\n  }\n  private static void solve(final int W, final int H) {\n    final char[][] map = new char[H][];\n    for(int i = 0; i < H; i++)\n      map[i] = sc.next().toCharArray();\n    final Deque<Integer> deq = new ArrayDeque<Integer>();\n    for(int i = 0; i < H; i++)\n      for(int j = 0; j < W; j++)\n        if(map[i][j] == '@')\n          deq.offer(i * W + j);\n    int ans = 0;\n    while(!deq.isEmpty()) {\n      final int p = deq.poll();\n      final int i = p / W;\n      final int j = p % W;\n      for(int d = 0; d < 4; d++) {\n        final int ni = i + di[d];\n        final int nj = j + dj[d];\n        if(0 <= ni && ni < H && 0 <= nj && nj < W && map[ni][nj] == '.') {\n          map[ni][nj] = '#';\n          deq.offer(ni * W + nj);\n          ans++;\n        }\n      }\n    }\n    System.out.println(ans);\n  }\n  private static final int[] di = { 1, 0, -1, 0};\n  private static final int[] dj = { 0, 1, 0, -1 };\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=0;\nchar Map[20][21];\nint main()\n{\n  int i,j,ii,jj,w,h;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    // printf(\"%d %d\\n\",w,h);\n    if(w==0&&h==0)break;\n    for(i=0;i<20;i++){\n      for(j=0;j<21;j++)Map[i][j]='#';\n    }\n    for(i=0;i<h;i++){\n      scanf(\"%s\",Map[i]);\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    move(ii,jj);\n    printf(\"%d\\n\",count);\n    count=0;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main() {\n\n\tchar **c;     //?????????\n\tint W ,H;     //?????????????¨??????¨??????\n\tint i,j;      //???????????¨?????°\n\tint a=0;      //??????????´???¨??????????????°\n\tint count;    //??????\n\tint flag;     //??¢?´¢????¶?????????????????????????????????°\n\tint A[10000]; //??????????´???¨??????\n\n\tfor(;;) {\n\n\tscanf(\"%d %d\",&W,&H); //?¨??????¨???????????\\???\n\n\tif(W==0&&H==0) break;\n\n\tc = malloc(sizeof(char *) * H);\n\n\tfor(i=0;i<H;i++) {\n\t\tc[i] = malloc(sizeof(char)*W);\n\t}\n\n\tfor(i=0;i<H;i++)\n\t\tscanf(\"%s\",c[i]); //??????????????\\???\n\n\tcount=1;\n\tflag=1;\n\n\twhile(flag) { //??¢?´¢????§?\n\t\tflag = 0;\n\t\tfor(i=0;i<H;i++) {\n\t\t\tfor(j=0;j<W;j++) {\n\t\t\t\tif(c[i][j]=='@') {\n\t\t\t\t\tif(i!=0&&c[i-1][j]=='.') { //???????§????\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tc[i-1][j]='@';\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=W-1&&c[i][j+1]=='.') { //???????§????\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tc[i][j+1]='@';\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(i!=H-1&&c[i+1][j]=='.') { //???????§????\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tc[i+1][j]='@';\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j!=0&&c[i][j-1]=='.') { //???????§????\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tc[i][j-1]='@';\n\t\t\t\t\t\tflag=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} //??¢?´¢????¶???????flag??????????¶???????\n\n\tA[a]=count;\n\ta++;\n\n\tfree(c);\n\t}\n\n\tfor(i=0;i<a;i++)\n\t\tprintf(\"%d\\n\",A[i]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "w,h,c,j,g;char*p,f[999],*q;main(i){for(;scanf(\"%d%d\",&w,&h),w++;printf(\"%d\\n\",c)){memset(f,35,900);for(i=1;i<=h;i++)scanf(\"%s\",f+i*w+i+1),f[strchr(f,0)-f]=35;for(c=g=1;g;)for(p=f,g=0;p=strchr(p+1,64);)for(j=0;j<2;j++)*(q=(p+j*w+1))-46||(*q=64,g|=c++),*(q=(p-j*w-1))-46||(*q=64,g|=c++);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p=0;\n\twhile(1){\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[i]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[i][j]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<string.h>\n#include<stdio.h>\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint w,h;\nchar map[22][22];\n\nint dfs(int y,int x){\n\tint i,res=1;\n\tif(map[y][x]=='#')return 0;\n\tmap[y][x]='#';\n\tfor(i=0;i<4;i++)\n\t\tres += dfs(y+dy[i],x+dx[i]);\n\treturn res;\n}\nint main(){\n\tint i,j;\n\tint sy,sx;\n\twhile(scanf(\"%d%d\",&w,&h)==2&&(w|h)){\n\t\tmemset(map,'#',sizeof(map));\n\t\tscanf(\"\\n\");\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%c\",&map[i][j]);\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%*c\");\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(sy,sx));\n\t}\n}"
  },
  {
    "language": "C",
    "code": "T[20][20],X,Y,x,y,p,q,i;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&(t=1))?t=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\nfor(i=0;i<X*Y;i++)switch(x=i%X,y=i/X,getchar()){\n\tcase 10:i--;break;\n\tcase'@':p=x;q=y;\n\tcase'.':t=0;break;\n\tcase'#':t=1;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\t\tint w,h,dx[]={0,0,1,-1},dy[]={1,-1,0,0},k;\n\t\tchar s[100][100];\n\tvoid func(int y,int x){\n\t\tint i;\n\t\ts[y][x]='#';\n\t\tk++;\n\t\tfor(i=0;i<4;i++)\n\t\t\tif(dy[i]+y>=0&&dy[i]+y<h&&dx[i]+x>=0&&dx[i]+x<w&&s[y+dy[i]][x+dx[i]]=='.')\n\t\t\t\tfunc(y+dy[i],x+dx[i]);\n}\n\tint main(){\n\t\tint i,j,x,y;\n\t\twhile(scanf(\"%d %d\",&w,&h),w||h){\n\t\t\tk=0;\n\t\t\tfor(i=0;i<h;i++)\n\t\t\t\tscanf(\"%s\",s[i]);\n\t\t\tfor(i=0;i<h;i++)\n\t\t\t\tfor(j=0;j<w;j++)\n\t\t\t\t\tif(s[i][j]=='@'){\n\t\t\t\t\t\tx=j;\n\t\t\t\t\t\ty=i;\n\t\t\t}\n\t\t\tfunc(y,x);\n\t\t\tprintf(\"%d\\n\",k);\n\t\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[32][32];\n\nint dx[] = {0, 1, 0 ,-1};\nint dy[] = {-1, 0, 1, 0};\n\nint count = 0;\nint serch(int x, int y)\n{\n    int i;\n    if (map[y][x] == '@' || map[y][x] == '.')\n    {\n        count++;\n        map[y][x] = '#';\n        for (i = 0; i < 4; i++)\n        {\n            serch(x + dx[i], y + dy[i]);\n        }\n    }\n    return 0;\n}\nvoid main()\n{\n    int w, h, i, j, x, y;\n    char enter;\n    while (1)\n    {\n        scanf(\"%d %d\", &w, &h);\n        scanf(\"%c\", &enter);\n        if (w == 0 && h == 0) break;\n        for (i = 0; i < 32; i++)\n            for (j = 0; j < 32; j++)\n                map[i][j] = '#';\n        count = 0;\n        for (i = 1; i <= h; i++)\n        {\n            for (j = 1; j <= w; j++)\n            {\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == '@')\n                {\n                    x = j;\n                    y = i;\n                }\n            }\n            scanf(\"%c\", &enter);\n        }\n        serch(x, y);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\nchar map[21][21];\nint sum;\nvoid snake(int x,int y){\n    if(map[y][x+1] == '.'){\n        sum++;\n        map[y][x+1]=0;\n        snake(x+1,y);\n    }\n    if(map[y+1][x] == '.'){\n        sum++;\n        map[y+1][x]=0;\n        snake(x,y+1);\n    }\n    if(x != 0){\n    if(map[y][x-1] == '.'){\n        sum++;\n        map[y][x-1]=0;\n        snake(x-1,y);\n    }\n    }\n    if(y != 0){\n    if(map[y-1][x] == '.'){\n        sum++;\n        map[y-1][x]=0;\n        snake(x,y-1);\n    }\n    }\n}\n\nint main(void){\n    int w,h,start[2],i,o,sign;\n    for(;scanf(\"%d %d\",&w,&h),h;){\n        memset(map,0,sizeof(map));\n        sum=0;\n        sign=0;\n        for(i=0;i<h;i++){\n            scanf(\"%s\",map[i]);\n            if(sign == 0){\n                for(o=0;o<w;o++)\n                    if(map[i][o] == '@'){\n                        sign=1;\n                        start[0]=o;\n                        start[1]=i;\n                    }\n            }\n        }\n        snake(start[0],start[1]);\n        printf(\"%d\\n\",sum+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint a[22][22];\nint w,h;\n\nvoid pr(){\n  int i,j;\n  for( i=0;i<=h+1;i++ ){\n    for( j=0;j<=w+1;j++ ){\n      if( a[i][j]==0 )\n\tprintf(\"#\");\n      else\n\tprintf(\" \");\n    }\n    printf(\"\\n\");\n  }\n  return ;\n}\n\nint r(int x,int y){\n  int rtn = 1;\n  a[x][y] = 0;\n\n  if( a[x-1][y  ]==1 ) rtn += r( x-1,y   );\n  if( a[x  ][y-1]==1 ) rtn += r( x  ,y-1 );\n  if( a[x  ][y+1]==1 ) rtn += r( x  ,y+1 );\n  if( a[x+1][y  ]==1 ) rtn += r( x+1,y   );\n  return rtn;\n}\nint main(void){\n  int i,j;\n  char c;\n  int x,y;\n\n  while( 1 ){\n    scanf(\"%d %d \",&w,&h );\n    if( !w && !h )\n      break;\n\n    for( i=0;i<=h+1;i++){\n      for( j=0;j<=w+1;j++ ){\n\tif( i==0 || i==h+1 || j==0 || j==w+1 ){\n\t  a[i][j] = 0;\n\t  continue;\n\t}\n\n\tscanf(\"%c \",&c );\n\tif( c=='.' ){\n\t  a[i][j] = 1;// black\n\t}else if( c=='#' ){\n\t  a[i][j] = 0;// red\n\t} else{\n\t  a[i][j] = 1;\n\t  x=i;y=j;\n\t}\n      }\n    }\n    pr();\n\n    printf(\"%d\\n\",r(x,y) );\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y);\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d\", &w);\n\t\tscanf(\"%d\", &h);\n\n\t\tif(!w && !h){\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = 0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", s[i]);\n\t\t}\n\n\t\tfor(int i = 0; i<h; i++){\n\t\t\tfor(int j = 0; j<w; j++){\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\n\tfor (int i = 0; i<4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZE 20\n\n/* ---------------------------------------------------------------------------- */\n\ntypedef unsigned short point;\n#define point(y, x) (((y)<<8) | (x))\n#define x(pt) ((pt) & 255)\n#define y(pt) (((pt)>>8) & 255)\n\n/* ---------------------------------------------------------------------------- */\n\npoint queue[SIZE*SIZE], pp, gp;\n#define put(pt) (queue[pp++] = pt)\n#define get() (queue[gp++])\n#define empty() (gp == pp)\n#define init() (pp = gp = 0)\n\n/* ---------------------------------------------------------------------------- */\n\n#define search(y, x) (count++, map[y][x] = 'w', put(point(y, x)))\n\nchar map[SIZE][SIZE+1];\n\nint main(void)\n{\n    int w, h, x, y, count; point p;\n\n    while(scanf(\"%d %d%*c\", &w, &h), w+h)\n    {\n        /* init, input */\n\n        init(); count = 0;\n        for(y=0; y<h; y++) gets(map[y]);\n\n        /* search for start */\n\n        for(y=0; y<h; y++)\n            for(x=0; x<w; x++)\n                if(map[y][x] == '@') goto OUTER;\n      OUTER:\n\n        /* search */\n\n        search(y, x);\n\n        while(!empty())\n        {\n            p = get(); x = x(p), y = y(p);\n            if(x-1 >= 0 && map[y][x-1] == '.') search(y, x-1);\n            if(x+1 <  w && map[y][x+1] == '.') search(y, x+1);\n            if(y-1 >= 0 && map[y-1][x] == '.') search(y-1, x);\n            if(y+1 <  h && map[y+1][x] == '.') search(y+1, x);\n        }\n\n        printf(\"%d\\n\", count);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "a['~~'],v;f(char*p){int i=4;for(;i;--*p-45||++v-f(p))p+=\"G&G\"[--i]-36;}main(){for(;scanf(\"%*d%d\",&v)*v;f(memchr(a,64,4e3)),printf(\"%d\\n\",v+1))for(;v;scanf(\"%s\",a+9*v--));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint func(int **a, int x, int y, int n, int m)\n{\n\tint c = 1;\n\tif(a[y][x] == 1){\n\t\treturn 0;\n\t}\n\ta[y][x] = 1;\n\t\n\tif(x-1 >= 0){\n\t\tc += func(a, x-1, y, n, m);\n\t}\n\tif(y-1 >= 0){\n\t\tc += func(a, x, y-1, n, m);\n\t}\n\tif(x+1 < n){\n\t\tc += func(a, x+1, y, n, m);\n\t}\n\tif(y+1 < m){\n\t\tc += func(a, x, y+1, n, m);\n\t}\n\t\n\treturn c;\n}\n\nint main(int argc, char **argv)\n{\n\tint **a, n, m, x, y, i, j;\n\tchar *w;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ta = (int **)calloc(m, sizeof(int));\n\t\tfor(i = 0; i < m; i++){\n\t\t\ta[i] = (int *)calloc(n, sizeof(int));\n\t\t\tw = (char *)malloc((n+1)*sizeof(char));\n\t\t\tscanf(\"%s\", w);\n\t\t\tfor(j = 0; j < n; j++){\n\t\t\t\tif(w[j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t} else if(w[j] == '#'){\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree(w);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", func(a, x, y, n, m));\n\t\tfor(i = 0; i < m; i++){\n\t\t\tfree(a[i]);\n\t\t}\n\t\tfree(a);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint count(int x,int y);\n\nchar board[20][22];\n\nint main(void){\n    int w,h,i,j;\n    while(scanf(\"%d%d%*c\",&w,&h) && w && h){\n        for(i=0;i<h;i++) for(j=0;j<w;j++) board[i][j]=0;\n        for(i=0;i<h;i++){\n            fgets(board[i],sizeof(board[i]),stdin);\n        }\n        for(i=0;i<h;i++){\n            for(j=0;j<w;j++){\n                if(board[i][j]=='@')\n                    break;\n            }\n            if(j<w) break;\n        }\n        printf(\"%d\\n\",count(i,j));\n    }\n    return 0;\n}\n\nint count(int x,int y){\n    int ret=1;\n    if(x!=0 && board[x-1][y]=='.'){\n        board[x-1][y]='@';\n        ret+=count(x-1,y);\n    }\n    if(y!=0 && board[x][y-1]=='.'){\n        board[x][y-1]='@';\n        ret+=count(x,y-1);\n    }\n    if(x<20 && board[x+1][y]=='.'){\n        board[x+1][y]='@';\n        ret+=count(x+1,y);\n    }\n    if(y<22 && board[x][y+1]=='.'){\n        board[x][y+1]='@';\n        ret+=count(x,y+1);\n    }\n    return ret;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[21][21];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        printf(\"%c \",Map[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n  char tmp[1000];\n  int h,w;\n  char *board[40];\n\n  while(scanf(\"%d%d\",&w,&h),w+h){\n    int i,j;\n    memset(tmp,'#',sizeof(tmp));\n    for(i=1;i<=h;i++){\n      char buff[40];\n      scanf(\"%s\",buff);\n      board[i]=&tmp[(w+2)*i];\n      memcpy(board[i]+1,buff,w);\n    }\n    board[0]=tmp;\n    board[h+1]=&tmp[(w+2)*(h+1)];\n\n    int f=1;\n    int ans=1;\n    while(f){\n      f=0;\n      for(i=1;i<h+1;i++){\n\tfor(j=1;j<w+1;j++){\n\t  if(board[i][j]=='@'){\n\t    int x,y;\n\t    for(y=-1;y<=1;y++){\n\t      for(x=-1;x<=1;x++){\n\t\tif(x*y!=0) continue;\n\t\tif(board[i+y][j+x]=='.'){\n\t\t  board[i+y][j+x]='@';\n\t\t  f=1;\n\t\t  ans++;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nvoid look_for(int,int,int,int);\n\nchar map[20][20];\nint cnt;\n\nint main(){\n  int i,j,w,h;\n  while(1){\n    cnt=0;\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]=='@')\n\t  look_for(i,j,h,w);\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}\n\nvoid look_for(int h,int w,int height,int width){\n  int i,j;\n  cnt++;\n  map[h][w]='N';\n  for(i=-1;i<=1;i++){\n    for(j=-1;j<=1;j++){\n      if(i==j || i==-j || i+h<0 || j+w<0 ||i+h>height || j+w>width || (i==0 && j==0))continue;\n      if(map[i+h][w+j]=='.')look_for(i+h,j+w,height,width);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\t\tchar a;\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdlib.h>\n#include<stdio.h>\n#define TRUE 1\n#define MAX 22\n\nint map[MAX][MAX];\nint w,h;\nint count;\n\nvoid move();\n\nint main(void) {\n\tint x,y;\n\tchar buff;\n\tint i,j;\n\t\n\twhile(TRUE) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif(w==0 && h==0) break;\n\t\tfor(i=0;i<MAX;i++) {\n\t\t\tfor(j=0;j<MAX;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=w;i++) {\n\t\t\tfor(j=1;j<=h;j++) {\n\t\t\t\tscanf(\"%c\", &buff);\n\t\t\t\tif(buff=='.') map[i][j] = 1;\n\t\t\t\telse if(buff=='#') map[i][j] = 0;\n\t\t\t\telse if(buff=='@') {\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t}\n\t\t\t\telse j--;\n\t\t\t}\n\t\t\t//scanf(\"\\n\");\n\t\t\t//scanf(\"%c\", &buff);\n\t\t}\n\t\tcount = 1;\n\t\tmove(x,y);\n\t\t\n\t\tprintf(\"%d\\n\", count);\n\t}\n\t\n\texit(0);\n}\n\nvoid move(int x,int y) {\n\tif(map[x][y] == 1) {\n\t\tmap[x][y] = 2;\n\t\tcount++;\n\t}\n\telse return;\n\t//???\n\tmove(x,y+1);\n\t//???\n\tmove(x,y-1);\n\t//???\n\tmove(x-1,y);\n\t//???\n\tmove(x+1,y);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\nvoid display_map (int W, int H);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  int W, H;\n\n  while(1){\n    scanf(\"%d%d\", &W, &H);\n    if(W==0 && H==0)break;\n    printf(\"%d\\n\", solve(W,H));\n\n  }\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  // ??????????????°?????¨??? (??¬??\\???????????????)\n  printf(\"??????????????°??? [%d, %d]\\n\\n\", start.row, start.col);\n\n  // ?????£?????°??????????????? 1, ????????§???????????? 0\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n    // printf(\"?????¨??°??? [%d, %d]\\n\", current.row, current.col);  // ??¬??\\???????????????\n    display_map(W, H); // ?????¨??????????????¨??? (??¬??\\???????????????)\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      // ????????§???????????????\n      nc.row += D1[d]; nc.col += D2[d];\n      if(M[nc.row][nc.col] == 'G') ;\n      if(M[nc.row][nc.col] == '.'){\n\tM[nc.row][nc.col] = '*';\n\tpush(S,nc);\n      }// nc ????????¢?´¢??????(*)????£?(#)?????´?????????????????????\n    }\n  }\n  return c;  //??°??????????????¨????????´????????¢?´¢???????????´???????????????????????????\n}\n\nvoid display_map (int W, int H) {;\n  int i, j;\n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      printf(\"%c\", M[i][j]);\n    }\n    putchar('\\n');\n  }\n  putchar('\\n');\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end++][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "W,C;char m[484];R(char*i){*i>45?*i=0,C++,R(i-1),R(i+1),R(i-W),R(i+W):0;}main(){for(;scanf(\"%d%*d\",&W)*W;C=!printf(\"%d\\n\",C))memset(m,W++,484),scanf(\"%[^0-9]\",m+W),R(strchr(m,64));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h)return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}{0,1}{0,-1}{-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1])=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1:\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0;, a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "int w, h;\nint map[32][32];\n\nint dx[] = {0, 1, 0 ,-1};\nint dy[] = {-1, 0, 1, 0};\n\nint count = 0;\n\nvoid solve(int x, int y)\n{\n    int i, nextX, nextY;\n    count++;\n    map[y][x] = '#';\n    for (i = 0; i < 4; i++)\n    {\n        nextX = x + dx[i];\n        nextY = y + dy[i];\n        if (0 <= nextX && nextX < w && 0 <= nextY && nextY < h)\n        {\n            if (map[nextY][nextX] != '#')\n                solve(nextX, nextY);\n        }\n    }\n}\n\nint main()\n{\n    int i, j;\n    int x, y;\n    while (1)\n    {\n        scanf(\"%d %d\", &w, &h);\n        if (w == 0 && h == 0)\n            break;\n        for (i = 0; i < h; i++)\n        {\n            for (j = 0; j < w; j++)\n            {\n                map[i][j] = getchar();\n                if (!(map[i][j] == '.' || map[i][j] == '#' || map[i][j] == '@'))\n                {\n                    j--;\n                    continue;\n                }\n                if (map[i][j] == '@')\n                {\n                    x = j;\n                    y = i;\n                }\n            }\n        }\n        count = 0;\n        solve(x, y);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "a['~~'],v;f(char*p){int i=4;for(;i;--*p-45||++v-f(p))p+=\"G&G\"[--i]-36;}main(){for(;scanf(\"%*d%d\",&v)*v;f(memchr(a,64,4e3)),printf(\"%d\\n\",v+1))for(memset(a,0,4e3);v;scanf(\"%s\",a+9*v--));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint W,H;\nchar map[20][20];\nint c;\n\nint noru(int x,int y){\n        int go[4][2]={{1,0},{-1,0},{0,1},{0,-1}};\n        int i;\n\n        if(map[x][y]=='#')\n                return;\n        if(x<0 || y<0 || x>=W || y>=H)\n                return;\n\n        c++;\n        map[x][y]='#';\n        for(i=0;i<4;i++)\n                noru(x+go[i][0],y+go[i][1]);\n        return;\n}\n\nshowmap(){\n        int i,j;\n        for(i=0;i<H;i++){\n                for(j=0;j<W;j++)\n                        putchar(map[j][i]);\n                puts(\"\");\n        }\n}\nmain(){\n        int i,j;\n        int x,y;\n\n        while(scanf(\"%d %d\",&W,&H)!=EOF){\n                if(W==0)\n                        break;\n                for(i=0;i<H;i++){\n                        for(j=0;j<W;j++){\n                                scanf(\" %c\",&map[j][i]);\n                                if(map[j][i]=='@'){\n                                        x=j;\n                                        y=i;\n                                }\n                        }\n                }\n\n                c=0;\n                noru(x,y);\n                printf(\"%d\\n\",c);\n        }\n        return 0;\n}"
  },
  {
    "language": "C",
    "code": "/* ***************************\n   \n   aoj-1130\n   \n   *************************** */\n\n#include<stdio.h>\n#include<stdlib.h>\n\n#define MAX 20\n\n// ????????¨?????¨ ?§???????\ntypedef struct {\n  int row;               // ?????????\n  int col;               // ?????????\n} Coord;\n\n// ??????????????¨ ?§???????\ntypedef struct _stack {\n  struct _stack *next;\n  Coord point;\n} *stack, stackelem;\n\nchar M[MAX+2][MAX+2];    // ?????¢?????°??????????????§???\n\n// ????????????????????£?¨?\nint solve (int W, int H);\nint search_df (int W, int H, Coord start);\nvoid display_map (int W, int H);\n\n// ??????????????¨\nstack  new_stack (void);\nint is_empty (stack);\nint push (stack, Coord);\nCoord top (stack);\nCoord pop (stack);\n\n// main ??¢??°\nint main () {\n  int W, H;\n  while(1){\n    scanf(\"%d %d\", &W, &H);\n    if (W == 0 && H == 0) break;\n    printf(\"%d\\n\", solve(W,H));\n  }\n\n  return 0;\n}\n\n// ?????£?????¢?´¢ \nint solve (int W, int H) {\n  Coord start;             // ??????????????°???\n  int i, j;\n\n  //  ?£?????????????????¨???? \n  for (i=0; i<=W+1; i++) { M[0][i] = '#'; M[H+1][i] = '#'; }\n  for (i=1; i<=H; i++) { M[i][0] = '#'; M[i][W+1] = '#'; }\n  // ??????????????\\??? \n  for (i=1; i<=H; i++) {\n    for (j=1; j<=W; j++) {\n      scanf(\" %c\", &M[i][j]);\n      if (M[i][j]=='@') {\n\tstart.row = i;\n\tstart.col = j;\n      }\n    }\n  }\n\n  // ?????????????????°?????????\n  return search_df(W, H, start);\n}\n\nint search_df (int W, int H, Coord start) {\n  stack S = new_stack ();  // ?¨?????????????????????????????????????\n\n  // ??????????????°???????¨????\n  push(S,start);                               // ??????????????°?????? push\n  int tilenum = 1;                             // ?????????????????°\n  // ??¢?´¢\n  while (!is_empty(S)) {\n    Coord current = pop(S);                    // pop ???????????????\n    int d;                                     // ??????\n    int D1[]={1,0,-1,0}; int D2[]={0,-1,0,1};  // ????????¢?????¶?????¨\n\n    for (d=0; d<4; d++) {\n      Coord nc = current;                      // Next Cell\n      nc.row += D1[d];\n      nc.col += D2[d];\n      if(M[nc.row][nc.col] == '.') {\n        M[nc.row][nc.col] = '*';\n        tilenum += 1;\n        push(S,nc);\n      }\n    }\n  }\n  return tilenum;\n}\n\n/* ??°??????????????????????¢?????????????????????? */\nstack new_stack (void) {\n  stack s;\n  s = (stack) malloc (sizeof (stackelem));\n  if (s == NULL) return NULL;\n  s->next = NULL;\n  return s;\n}\n    \n/* ???????????????????????????????????? */\nint is_empty (stack s) {\n  return (s && s->next == NULL);\n}\n\n/* ??°??????????´???????????????\\ */\nint push (stack s, Coord v) {\n  stack p;\n  if (s == NULL) return 0;\n  p = (stack) malloc (sizeof (stackelem));\n  if (p == NULL) return 0;\n  p->point = v;\n  p->next = s->next;\n  s->next =  p;\n  return 1;\n}\n\n/* ?????????????´?????????? */\nCoord top (stack s) {\n  if (s && s->next) \n    return s->next->point;\n  exit (1);\n}\n\n/* ????????? */\nCoord pop (stack s) {\n  stack p;\n  Coord v = top (s);\n  p = s->next;\n  s->next = p->next;\n  free (p);\n  return v;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid visit(int i,int j);\n\nint v[21][21],count,H,W;\nchar s[21][21];\n\nint main(void){\n  int i,j;\n  \n  while(1){\n\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++)\n\ts[i][j]='#';\n}\n    for(i=0;i<21;i++){\n      for(j=0;j<21;j++)\n\tv[i][j]=0;\n    }\n    count=0;\n    scanf(\"%d %d\",&W,&H);\n    if(W==0 && H==0)break;\n\n    for(i=0;i<H;i++){\n      for(j=0;j<W;j++){\n\tscanf(\" %c\",&s[i][j]);\n      }\n    }\n\n    for(i=0;i<H;i++){\n      for(j=0;j<W;j++){\n\tif(s[i][j]=='@'){\n\t  visit(i,j);\n\t}\n      }\n    }\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}\n\nvoid visit(int i,int j){\n  v[i][j]=1;\n  count++;\n  if(s[i+1][j]=='.' && i<H && v[i+1][j]==0)visit(i+1,j);\n  if(s[i-1][j]=='.' && i!=0 && v[i-1][j]==0)visit(i-1,j);\n  if(s[i][j+1]=='.' && j<W && v[i][j+1]==0)visit(i,j+1);\n  if(s[i][j-1]=='.' && j!=0 && v[i][j-1]==0)visit(i,j-1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p;\n\twhile(1){\n\tp=0;\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[i]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[i][j]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid fact(int ,int);\n\nchar c[21][21];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nint w, h, count;\n\nint main()\n{\n  int a, i, j, b1 , b2;\n\n  while(1){\n    scanf(\"%d%d\\n\",&w,&h);\n    if(w == 0 && h == 0)\n      break;\n    /*scanf(\"%c\",&c[0][0]);*/\n    for(i = 0 ; i < h ; i++){\n      for(j = 0 ; j < w+1 ; j++){\n\tscanf(\"%c\",&c[i][j]);\n\tif(c[i][j] == '@'){\n\t  b1 = j;\n\t  b2 = i;\n\t} \n      }\n    }\n    count = 1;\n    fact(b1,b2);\n    printf(\"%d\\n\",count);\n  }\n  return 0;\n}\n\nvoid fact(int b1 ,int b2)\n{\n  int i, x, y;\n\n  for(i = 0 ; i < 4 ; i++){\n    y = b1 + dy[i];\n    x = b2 + dx[i];\n    if(y < 0 || x < 0 || y >= w || x >= h)\n      continue;\n    if(c[x][y] == '.'){\n      c[x][y] = '#';\n      count++;\n      fact(y,x);\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nmain(){\n  int W,H,i,j,flg,cnt,x[]={0,1,0,-1},y[]={1,0,-1,0},a,b,c,d;\n  char tmp[20][20];\n  while(1){\n    flg=1;\n    scanf(\"%d %d\",&W,&H);\n    if(W==0&&H==0)break;\n    for(i=0;i<H;i++) scanf(\"%s\",tmp[i]);\n    cnt=1;\n    while(flg==1){\n      flg=0;\n      for(i=0;i<H;i++){\n\tfor(j=0;j<W;j++){\n\t  if(tmp[i][j]=='@'){\n\t    for(a=0;a<4;a++){\n\t      for(b=i+x[a],c=j+y[a];b>=0&&b<H&&c>=0&&c<W;b+=x[a],c+=y[a]){\n\t\tif(tmp[b][c]=='#')break;\n\t\telse if(tmp[b][c]=='.'){\n\t\t  tmp[b][c]='@';\n\t\t  flg=1;\n\t\t  cnt++;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAPX 25\n#define MAPY 25\nchar data[MAPY][MAPX];\nint h,w;\nint search(int num, int nowx, int nowy){\n\tnum = 1;\n\tdata[nowy][nowx] = '#';\n\tif(nowx>0   && data[nowy][nowx-1]=='.')num += search(num, nowx-1, nowy);\n\tif(nowy>0   && data[nowy-1][nowx]=='.')num += search(num, nowx, nowy-1);\n\tif(nowx<w-1 && data[nowy][nowx+1]=='.')num += search(num, nowx+1, nowy);\n\tif(nowy<h-1 && data[nowy+1][nowx]=='.')num += search(num, nowx, nowy+1);\n\treturn num;\n}\n\nvoid solve(){\n\tint i,t;\n\tint sx,sy;\n\tfor(i = 0;i < h;i++)\n\t\tscanf(\"%s\", data[i]);\n\tfor(i = 0;i < h;i++){\n\t\tfor(t = 0;t < w;t++){\n\t\t\tif(data[i][t]=='@'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = t;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0,  sx, sy));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tif(h == 0 && w == 0)break;\n\t\tsolve(h,w);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p=0;\n\tscanf(\"%d%d\",&W,&H);\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[H]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[H][W]==\"@\"){memH=i;memW=j;break;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar map[30][30];\nint x, y;\nint num;\n\nint dfs(int sy, int sx)\n{\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int i;\n    num++;\n    map[sy][sx] = 'x';\n    \n    for (i = 0; i < 4; i++){\n        if (0 <= sx + dx[i] && sx + dx[i] < x && 0 <= sy + dy[i] && sy + dy[i] < y && map[sy + dy[i]][sx + dx[i]] == '.'){\n            dfs(sy + dy[i], sx + dx[i]);\n        }\n    }\n    \n    return (num);\n}\n\nint main(void)\n{\n    int i, j;\n    int sy, sx;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (!(x + y)){\n            break;\n        }\n        getchar();\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == '@'){\n                    sy = i;\n                    sx = j;\n                }\n            }\n            getchar();\n        }\n        \n        num = 0;\n        printf(\"%d\\n\", dfs(sy, sx));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 32\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( ( x < 0 && x >= w )\n    || ( y < 0 && y >= h )\n    || d[ y ][ x ] != '.' ) return ( 0 );\n\n  d[ y ][ x ] = '#';\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx, sy;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "\n#define B(a,x,b) ((a)<=(x)&&(x)<(b))\n\nchar T[999];\nint x,y,cx,cy,i,c;\n\nvoid R(a,b){\n\tif(B(0,a,x)&&B(0,b,y)&&T[b*20+a]){\n\t\tT[b*20+a]=0;i++;R(a-1,b);R(a+1,b);R(a,b-1);R(a,b+1);\n\t}\n}\n\nmain(){\n\tfor(;scanf(\"%d%d\",&x,&y),x;){\n\t\tfor(i=0;i<x*y;i++){\n\t\t\tint _x=i%x, _y=i/x;\n\t\t\tfor(;(c=getchar())!='\\n';);\n\t\t\tswitch(c){\n\t\t\t\tcase '@': cx=_x;cy=_y;\n\t\t\t\tcase '.': T[_y*20+_x]=1; break;\n\t\t\t\tcase '#': T[_y*20+_x]=0; break;\n\t\t\t}\n\t\t}\n\t\ti=0;\n\t\tR(cx,cy);\n\t\tprintf(\"%d\\n\",i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 20\n\nstatic char d[ N ][ N ];\nstatic int  w, h;\n\nstatic int\nsolve (\n  int x,\n  int y\n  )\n{\n  int res = 1;\n\n  if ( ( x < 0 && x >= w )\n    || ( y < 0 && y >= h )\n    || d[ y ][ x ] != '.' ) return ( 0 );\n  d[ y ][ x ] = '#';\n\n  res += solve ( x - 1, y );\n  res += solve ( x + 1, y );\n  res += solve ( x, y - 1 );\n  res += solve ( x, y + 1 );\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int sx, sy;\n\n    scanf ( \" %d %d\", &w, &h );\n    if ( !( w | h ) ) break ;\n\n    for ( i = 0; i < h; ++i )\n    {\n      char * v;\n\n      scanf ( \" %s\", d[ i ] );\n\n      v = strchr ( d[ i ], '@' );\n      if ( v != NULL )\n      {\n        sx = v - d[ i ];\n        sy = i;\n        *v = '.';\n      }\n    }\n\n    printf ( \"%d\\n\", solve ( sx, sy ) );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXH 22\n#define MAXW 24\n\nint bfs(int mat[20][22],int visited[20][22],int ph,int pw,int* ans){\n\tint vector[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\tint i;\n\tvisited[ph][pw]=1;\n\t(*ans)++;\n\tfor(i=0;i<4;i++){\n\t\tint nh=ph+vector[i][0];\n\t\tint nw=pw+vector[i][1];\n\t\tif(mat[nh][nw]=='.'&&visited[nh][nw]==0){\n\t\t\tbfs(mat,visited,nh,nw,ans);\n\t\t}\n\t}\n\treturn 0;\n}\nint input(int mat[20][22],int h,int w,int* sh,int* sw){\n\tint i,j;\n\tfor(i=1;i<h+1;i++){\n\t\tfor(j=1;j<w+1;j++){\n\t\t\tint c;\n\t\t\twhile(c=getchar()){\n\t\t\t\tif(c!='\\n'){\n\t\t\t\t\tmat[i][j]=c;\n\t\t\t\t\tif(c=='@'){\n\t\t\t\t\t\t*sh=i;\n\t\t\t\t\t\t*sw=j;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tint sh,sw;\n\tint ans=0;\n\tint mat[20][22],visited[20][22];\n\tint i,j,k;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<22;j++){\n\t\t\t\tmat[i][j]='#';\n\t\t\t\tvisited[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tinput(mat,h,w,&sh,&sw);\n\t\tbfs(mat,visited,sh,sw,&ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n\nint w, h;\nchar field[MAX_SIZE][MAX_SIZE + 1];\n\nint out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dfs(int x, int y) {\n\tstatic const int dx[] = {1, 0, -1, 0};\n\tstatic const int dy[] = {0, 1, 0, -1};\n\n\tint count = 1;\n\tfield[y][x] = '#';\n\n\tfor(int dir = 0; dir < 4; ++dir) {\n\t\tconst int nx = x + dx[dir];\n\t\tconst int ny = y + dy[dir];\n\n\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\tcount += dfs(nx, ny);\n\t}\n\n\treturn count;\n}\n\nint main() {\n\twhile(scanf(\"%d %d\", &w, &h) == 2 && w) {\n\t\tint x, y;\n\t\tint sx, sy;\n\n\t\tfor(y = 0; y < h; ++y) {\n\t\t\tscanf(\"%s\", field[y]);\n\n\t\t\tfor(x = 0; x < w; ++x) {\n\t\t\t\tif(field[y][x] == '@') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", dfs(sx, sy));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 20\nint main()\n{\n  char c[MAX][MAX];\n  int checked[MAX][MAX];\n  int able[MAX][MAX];\n  int x,y;\n  int checkingx,checkingy;\n  int i,j;\n  int flag;\n  int result;\n  while(1)\n    {\n      for(i=0;i<MAX;i++)\n\tfor(j=0;j<MAX;j++)\n\t  checked[i][j]=able[i][j]=0;\n      scanf(\"%d%d\",&x,&y);\n      if((!x)&&(!y)) break;\n      for(i=0;i<y;i++)\n\tfor(j=0;j<x;j++)\n\t  {\n\t    scanf(\"%c\",&c[j][i]);\n\t    if(c[j][i]=='@')\n\t      {\n\t\tcheckingx=j;\n\t\tcheckingy=i;\n\t\tchecked[j][i]=1;\n\t\table[j][i]=1;\n\t      }\n\t    if(c[j][i]=='\\n')\n\t      {\n\t\tj--;\n\t\tcontinue;\n\t      }\n\t  }\n      \n\n      \n      while(1)\n\t{\n\t  /*\n\t  for(i=0;i<y;i++)\n\t    {\n\t      for(j=0;j<x;j++)\n\t\t{\n\t\t  printf(\"%c\",c[j][i]);\n\t\t}\n\t      printf(\"\\n\");\n\t    }\n\t  */\n\t  if((checkingx>0)&&(c[checkingx-1][checkingy]=='.'))\n\t    {\n\t      able[checkingx-1][checkingy]=1;\n\t      //printf(\"able: %d,%d\\n\",checkingx-1,checkingy);\n\t    }\n\t  if((checkingx<x-1)&&(c[checkingx+1][checkingy]=='.'))\n\t    {\n\t      able[checkingx+1][checkingy]=1;\n\t      //printf(\"able: %d,%d\\n\",checkingx+1,checkingy);\n\t    }\n\t  if((checkingy>0)&&(c[checkingx][checkingy-1]=='.'))\n\t    {\n\t      able[checkingx][checkingy-1]=1;\n\t      //printf(\"able: %d,%d\\n\",checkingx,checkingy-1);\n\t    }\n\t  if((checkingy<y-1)&&(c[checkingx][checkingy+1]=='.'))\n\t    {\n\t      able[checkingx][checkingy+1]=1;\n\t      //printf(\"able: %d,%d\\n\",checkingx,checkingy+1);\n\t    }\n\t  flag=0;\n\t  for(i=0;i<y;i++)\n\t    {\n\t      for(j=0;j<x;j++)\n\t\t{\n\t\t  if((checked[j][i]==0)&&(able[j][i]==1))\n\t\t    {\n\t\t      checkingx=j;\n\t\t      checkingy=i;\n\t\t      checked[j][i]=1;\n\t\t      flag=1;\n\t\t      //printf(\"NEXT: %d,%d\\n\",j,i);\n\t\t      break;\n\t\t    }\n\t\t}\n\t      if(flag) break;\n\t    }\n\t  if(!flag) break;\n\t}\n      result=0;\n      for(i=0;i<y;i++)\n\tfor(j=0;j<x;j++)\n\t  if(checked[j][i]==1) result++;\n      printf(\"%d\\n\",result);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "w,m[];R(char*p){*p>45?*p=0,R(p-1),R(p+1),R(p-w),R(p+w),++*m:0;}main(){for(;scanf(\"%d%*d\",&w)*w;printf(\"%d\\n\",*m))bzero(m,999),scanf(\"%[^0-9]\",++w+m),R(strchr(m+w,64));}"
  },
  {
    "language": "C",
    "code": "T[20][20],X,Y,x,y,p,q,i;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&!t)?t=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\nfor(i=0;i<X*Y;i++)switch(x=i%X,y=i/X,getchar()){\n\tcase 10:i--;break;\n\tcase'@':p=x;q=y;\n\tcase'.':t=0;break;\n\tcase'#':t=1;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint width,height;\nchar map[20][21];\n\nint tansaku(int x,int y) {\n\tint result=1;\n\tif(x<0 || x>=width || y<0 || y>=height)return 0;\n\tif(map[y][x]=='#')return 0;\n\tmap[y][x]='#';\n\tresult+=tansaku(x-1,y);\n\tresult+=tansaku(x+1,y);\n\tresult+=tansaku(x,y-1);\n\tresult+=tansaku(x,y+1);\n\treturn result;\n}\n\nint main(void) {\n\tint i,j;\n\tint sx,sy;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tscanf(\"%s\",map[i]);\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]=='@'){sx=j;sy=i;}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",tansaku(sx,sy));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p=0;\n\twhile(1){\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[H]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[H][W]=='@'){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAPX 25\n#define MAPY 25\n\nint search(int num, int h, int w, int nowx, int nowy, char data[MAPY][MAPX]){\n\tnum = 1;\n\tdata[nowy][nowx] = '#';\n\tif(nowx>0   && data[nowy][nowx-1]=='.')num += search(num, h, w, nowx-1, nowy, data);\n\tif(nowy>0   && data[nowy-1][nowx]=='.')num += search(num, h, w, nowx, nowy-1, data);\n\tif(nowx<w-1 && data[nowy][nowx+1]=='.')num += search(num, h, w, nowx+1, nowy, data);\n\tif(nowy<h-1 && data[nowy+1][nowx]=='.')num += search(num, h, w, nowx, nowy+1, data);\n\treturn num;\n}\n\nvoid solve(int h, int w){\n\tchar data[MAPY][MAPX];\n\tint i,t;\n\tint sx,sy;\n\tfor(i = 0;i < h;i++)\n\t\tscanf(\"%s\", data[i]);\n\tfor(i = 0;i < h;i++){\n\t\tfor(t = 0;t < w;t++){\n\t\t\tif(data[i][t]=='@'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = t;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0, h, w, sx, sy, data));\n}\n\nint main(){\n\tint h,w;\n\twhile(1){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tif(h == 0 && w == 0)break;\n\t\tsolve(h,w);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][22];\nint main()\n{\n  int i,j,ii,jj;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n   \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n   \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nunsigned short room[22][22];\n\nvoid DFS(unsigned short x, unsigned short y);\n\nint main(void) {\n\n\tunsigned short W, H, manx, many;\n\tunsigned short i, j, count = 0;\n\n\tscanf(\"%hu%hu\", &W, &H);\n\tfor(i = 0; i < H + 2; i++) {\n\t\tfor(j = 0; j < W + 2; j++) {\n\t\t\tif(i == 0 || j == 0 || i == H + 1 || j == W + 1) room[i][j] = 0;\n\t\t\telse scanf(\"%hu\", &room[i][j]);\n\n\t\t\tif(room[i][j] == 2) {\n\t\t\t\tmanx = i;\n\t\t\t\tmany = j;\n\t\t\t\troom[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tDFS(manx, many);\n\n\tfor(i = 1; i < H + 1; i++) for(j = 1; j < W + 1; j++) count += (room[i][j] == 2);\n\n\tprintf(\"%hd\\n\", count);\n\treturn 0;\n}\n\nvoid DFS(unsigned short x, unsigned short y) {\n\tif(room[x][y] != 1) return;\n\troom[x][y] = 2;\n\tDFS(x - 1, y);\n\tDFS(x + 1, y);\n\tDFS(x, y - 1);\n\tDFS(x, y + 1);\n}"
  },
  {
    "language": "C",
    "code": "T[20][20],X,Y,x,y,p,q,i;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&!t)?t=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;i=0,R(p,q),printf(\"%d\\n\",i))\nfor(i=0;i<X*Y;i++)switch(x=i%X,y=i/X,getchar()){\n\tcase 10:i--;break;\n\tcase'@':p=x;q=y;\n\tcase'.':t=0;break;\n\tcase'#':t=1;\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "W,H,C;\nchar m[22*22];\nR(i){\n\tif(m[i]=='.'){\n\t\tm[i]=0;\n\t\tC++;\n\t\tR(i-1);\n\t\tR(i+1);\n\t\tR(i-W);\n\t\tR(i+W);\n\t}\n}\nmain(){\n\tint i;\n\tchar*p;\n\tfor(;scanf(\"%d%d\",&W,&H)*W;){\n\t\tmemset(m,0,sizeof(m));\n\t\tW++;\n\t\tfor(i=H*W;i--;)\n\t\t\tm[W+i]=getchar();\n\t\tC=0;\n\t\tp=strchr(m+W,'@');\n\t\tm[p-m]='.';\n\t\tR(p-m);\n\t\tprintf(\"%d\\n\",C);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint c,gx,gy;\nchar map[20][20];\nvoid check(int x,int y)\n{\n  int n;\n  //    printf(\"check %d %d \\n\",x,y);\n  map[x][y]='#';\n  c++;\n \n  if(x+1<gy && map[x+1][y]=='.')\n      check(x+1,y);\n  if(x>0 && map[x-1][y]=='.')\n      check(x-1,y);\n  if(y+1<gx && map[x][y+1]=='.')\n      check(x,y+1);\n  if(y>0 && map[x][y-1]=='.')\n      check(x,y-1);\n}\n\nint main()\n{\n  int n,m,x,y;\n  for(;scanf(\"%d%d\",&gx,&gy),gx;)\n    {\n      //      puts(\"start\");\n      for(x=0;x<20;x++)\n      for(y=0;y<20;y++)\n\tmap[x][y]='#';\n      for(n=0;n<gy;n++)\n\t{\n\t  //  printf(\"now %d\\n\",n);\n\t  scanf(\"%s\",map[n]);\n\t  for(m=0;m<gx;m++)\n\t    if(map[n][m]=='@')\n\t      {\n\t\tx=n,y=m;\n\t      }\n\n\n\t}\n      //      puts(\"scan end\");\n      //      for(n=0;n<gy;n++)\n      //\tputs(map[n]);\n\n      c=0;\n      check(x,y);\n     printf(\"%d\\n\",c);\n     // for(n=0;n<gy;n++)\n\t//\tputs(map[n]);\n\n    }\n  exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1 };\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tchar C[30][30];\n\t\tint B[30][30];\n\n\t\tint sx = -1; int sy = -1;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> C[i][j];\n\t\t\t\tB[i][j] = 0;\n\t\t\t\tif (C[i][j] == '@')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pi> Q;\n\t\tQ.push(pi(sy, sx));\n\t\tB[sy][sx] = 1;\n\t\tint ans = 1;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint ty = Q.front().first; int tx = Q.front().second;\n\t\t\tQ.pop();\n\n\t\t\tfor (int r = 0; r < 4; r++)\n\t\t\t{\n\t\t\t\tint y = ty + dd[r];\n\t\t\t\tint x = tx + dd[r + 1];\n\t\t\t\tif (y < 0 || y >= H || x < 0 || x >= W)continue;\n\t\t\t\tif (C[y][x] == '#')continue;\n\t\t\t\tif (B[y][x])continue;\n\t\t\t\tans++;\n\t\t\t\tB[y][x] = 1;\n\t\t\t\tQ.push(pi(y, x));\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[32][32];\n\nint dx[] = {0, 1, 0 ,-1};\nint dy[] = {-1, 0, 1, 0};\n\nint count = 0;\nint serch(int x, int y)\n{\n    int i;\n    if (map[y][x] == '@' || map[y][x] == '.')\n    {\n        count++;\n        map[y][x] = '#';\n        for (i = 0; i < 4; i++)\n        {\n            serch(x + dx[i], y + dy[i]);\n        }\n    }\n    return 0;\n}\nvoid main()\n{\n    int w, h, i, j, x, y;\n    char enter;\n    while (1)\n    {\n        scanf(\"%d %d\", &w, &h);\n        scanf(\"%c\", &enter);\n        if (w == 0 && h == 0) break;\n        for (i = 0; i < 32; i++)\n            for (j = 0; j < 32; j++)\n                map[i][j] = '#';\n        count = 0;\n        for (i = 1; i <= h; i++)\n        {\n            for (j = 1; j <= w; j++)\n            {\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == '@')\n                {\n                    x = j;\n                    y = i;\n                }\n            }\n            scanf(\"%c\", &enter);\n        }\n        serch(x, y);\n        printf(\"%d\\n\", count);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y)((x>y)?x:y)\nchar m[22][22];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\ntypedef struct p{\n\tint x,y;\n}P;\nP q[405],sq[405];\nint main(){\n\tint i,j,w,h,qn,sqn,ans,nx,ny;\n\tchar s[22];\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0)break;\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(i=0;i<=w+1;i++)m[0][i]=m[h+1][i]='#';\n\t\tfor(i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",s);\n\t\t\tstrcpy(m[i]+1,s);\n\t\t\tm[i][0]=m[i][w+1]='#';\n\t\t\tfor(j=1;j<=w;j++)if(m[i][j]=='@')q[0].x=j,q[0].y=i,m[i][j]='#';\n\t\t}\n\t\tans=1;qn=1;\n\t\twhile(qn!=0){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tnx=q[i].x+dx[j];\n\t\t\t\t\tny=q[i].y+dy[j];\n\t\t\t\t\tif(m[ny][nx]=='.'){\n\t\t\t\t\t\tsq[sqn].x=nx;\n\t\t\t\t\t\tsq[sqn].y=ny;\n\t\t\t\t\t\tans++;sqn++;\n\t\t\t\t\t\tm[ny][nx]='#';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t}\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",m[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            if (!i)for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end++][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar d[30][30]={0};\nint c;\nvoid f(int y,int x){\n  if(d[y][x]-'.')return;\n  c++;\n  d[y][x]=0;\n  f(y+1,x);\n  f(y,x+1);\n  f(y-1,x);\n  f(y,x-1);\n}\nint main(){\n  int w,h,x,y,i,j;\n  while(scanf(\"%d %d\",&w,&h),w,h){\n    for(i=0;i<30*30;i++)d[i/30][i%30]=0;\n    for(i=c=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c\",&d[i+1][j+1]);\n\tif(d[i+1][j+1]=='@')d[y=i+1][x=j+1]='.';\n      }\n    }\n    f(y,x);\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint w,h,sx,sy,cnt;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar mas[50][50];\n\nvoid start(void);\nvoid fbs(int x,int y);\n\nmain(){\n  int i;\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0){\n      break;\n    }\n    for(i=0;i<h;i++){\n      scanf(\"%s\",mas[i]);\n    }\n    cnt=0;\n    start();\n    fbs(sx,sy);\n    printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}\n\nvoid start(void){\n  int i,j;\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(mas[i][j]=='@'){\n\tsx=j;\n\tsy=i;\n\tbreak;\n\tbreak;\n      }\n    }\n  }\n  return;\n}\n\nvoid fbs(int x,int y){\n  int i;\n  cnt++;\n  mas[y][x]='#';\n  for(i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(nx>=0 && nx<w && ny>=0 && ny<h && mas[ny][nx]=='.'){\n      fbs(nx,ny);\n    }\n  }\n  return ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[50][50];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    \n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h)return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    /* for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        printf(\"%c \",Map[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\nprintf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0, 0, 1, -1 };\nint dy[] = { 1, -1, 0, 0 };\n\nvoid dfs(int x, int y) {\n\tint i;\n\tif (s[y][x] == '.' || s[y][x] == '@') {\n\t\tcount++;\n\t\ts[y][x] = '#';\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tdfs(x + dx[i], y + dy[i]);\n\t\t}\n\t}\n}\n\nint main(void) {\n\tchar a;\n\tint i, j, x, y;\n\twhile(1){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%c\", &a);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i<21; i++) {\n\t\t\tfor (j = 0; j<21; j++) {\n\t\t\t\ts[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\n\t\tfor (i = 1; i<h; i++) {\n\t\t\tfor (j = 1; j<w; j++) {\n\t\t\t\tscanf(\"%c\", &s[i][j]);\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%c\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define SIZE 100000\ntypedef struct{\n  int x;\n  int y;\n}Zahyo;\nZahyo  z[SIZE];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nmain(){\n  int h,w;\n  int head=0;\n  int tail=0;\n  int cnt=0;\n  char maps[30][30];\n  int i,j;\n  scanf(\"%d %d\",&w,&h);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%c\",&maps[i][j]);\n      if(maps[i][j]=='@'){\n\tz[0]=(Zahyo){j,i};\n\ttail=(tail+1)%SIZE;\n      }\n    }\n  }\n  while(head != tail){\n    int x = z[head].x; int y = z[head].y; head = (head+1) % SIZE;\n    if(0 <= x && 0 <= y && x < w && y < h && maps[y][x] != '#'){\n      maps[y][x] = '#';\n      cnt++;\n      for(i=0;i<4;i++){\n\tint nx = x + dx[i]; int ny = y + dy[i];\n\tz[(tail+i) % SIZE] = (Zahyo){ nx,ny };\n      }\n      tail = (tail+4) % SIZE;\n    }\n  }\n  printf(\"%d\\n\",cnt);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n\n\nint main()\n{\n\tint i,j,k;\n\tint n,m;\n\n\twhile(1)\n\t{\n\t\tint a[22][22]={0};\n\t\tint d[401][2]={0}; //四方探索候補x,y\n\t\tint e=0; //現時点での四方探索候補数\n\t\tint f=0; //現時点での四方探索済み数\n\t\tchar c[21];\n\t\tfor(i=0;i<22;i++){for(j=0;j<22;j++){a[i][j]=-2;}}\n\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif((n==0)&&(m==0)){break;}\n\t\telse\n\t\t{\n\t\t\tfor(i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tscanf(\"%s\",c);\n\t\t\t\tfor(j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(c[j]=='.'){a[j+1][i+1]=1;} //1は未探索\n\t\t\t\t\telse if(c[j]=='#'){a[j+1][i+1]=-2;} //-2は探索済み＆行けない\n\t\t\t\t\telse if(c[j]=='@'){a[j+1][i+1]=-1;d[e][0]=(j+1);d[e][1]=(i+1);e++;} //-1は探索済み＆行ける\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(e!=f)\n\t\t\t{\n\t\t\t\tint e1=0;\n\t\t\t\tint f1=0;\n\t\t\t\tfor(i=f;i<e;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j==0)\n\t\t\t\t\t\t{if(a[d[f+f1][0]+1][d[f+f1][1]]==1){\n\t\t\t\t\t\t\t\ta[d[f+f1][0]+1][d[f+f1][1]]=-1;\n\t\t\t\t\t\t\t\td[e+e1][0]=(d[f+f1][0]+1);\n\t\t\t\t\t\t\t\td[e+e1][1]=(d[f+f1][1]);\n\t\t\t\t\t\t\t\te1++;}}\n\t\t\t\t\t\tif(j==1)\n\t\t\t\t\t\t{if(a[d[f+f1][0]-1][d[f+f1][1]]==1){\n\t\t\t\t\t\t\t\ta[d[f+f1][0]-1][d[f+f1][1]]=-1;\n\t\t\t\t\t\t\t\td[e+e1][0]=(d[f+f1][0]-1);\n\t\t\t\t\t\t\t\td[e+e1][1]=(d[f+f1][1]);\n\t\t\t\t\t\t\t\te1++;}}\n\t\t\t\t\t\tif(j==2)\n\t\t\t\t\t\t{if(a[d[f+f1][0]][d[f+f1][1]+1]==1){\n\t\t\t\t\t\t\t\ta[d[f+f1][0]][d[f+f1][1]+1]=-1;\n\t\t\t\t\t\t\t\td[e+e1][0]=(d[f+f1][0]);\n\t\t\t\t\t\t\t\td[e+e1][1]=(d[f+f1][1]+1);\n\t\t\t\t\t\t\t\te1++;}}\n\t\t\t\t\t\tif(j==3)\n\t\t\t\t\t\t{if(a[d[f+f1][0]][d[f+f1][1]-1]==1){\n\t\t\t\t\t\t\t\ta[d[f+f1][0]][d[f+f1][1]-1]=-1;\n\t\t\t\t\t\t\t\td[e+e1][0]=(d[f+f1][0]);\n\t\t\t\t\t\t\t\td[e+e1][1]=(d[f+f1][1]-1);\n\t\t\t\t\t\t\t\te1++;}}\n\t\t\t\t\t}\n\t\t\t\t\tf1++;\n\t\t\t\t}\n\t\t\t\te+=e1;\n\t\t\t\tf+=f1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",e);\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nchar map[21][21];\nint width, height;\nint x, y;\n\n#define fors(i, n) for (int i = 0; i < n; i++)\n\nint parse()\n{\n\tscanf(\"%d %d\", &width, &height);\n\tif (width == 0 || height == 0)\n\t\treturn 0;\n\tfors(i, 21) fors(j, 21) map[i][j] = 'F';\n\tfors(i, height)\n\t{\n\t\tscanf(\"%s\", map[i]);\n\t\tfors(j, width)\n\t\t{\n\t\t\tif (map[i][j] == '@')\n\t\t\t\tx = j, y = i;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint dfs(int y, int x)\n{\n\tif (map[y + 1][x] == '.')\n\t\tmap[y + 1][x] = '@', dfs(y + 1, x);\n\tif (map[y - 1][x] == '.')\n\t\tmap[y - 1][x] = '@', dfs(y - 1, x);\n\tif (map[y][x + 1] == '.')\n\t\tmap[y][x + 1] = '@', dfs(y, x + 1);\n\tif (map[y][x - 1] == '.')\n\t\tmap[y][x - 1] = '@', dfs(y, x - 1);\n}\n\nint main()\n{\n\twhile (parse())\n\t{\n\t\tint res = 0;\n\t\tdfs(y, x);\n\t\tfors(i, width)\n\t\t{\n\t\t\tfors(j, height)\n\t\t\t{\n\t\t\t\tif (map[j][i] == '@')\n\t\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nconst int INF = 10000000;\n\nint W, H, bx, by;\nchar tile[22][22];\nint d[22][22];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nvoid bfs();\n\nvoid solve();\n\n\nint main(void){\n  int i, j;\n  while(scanf(\"%d%d\", &W, &H) && W && H){\n    //scanf(\"%d%d\", &W, &H);\n      for(i = 0 ; i < H; i++){\n        scanf(\"%s\", tile[i]);\n      }\n      for(i = 0; i < W; i++){\n        for(j = 0; j < H; j++){\n          if(tile[j][i] == '@'){\n            bx = i;\n            by = j;\n          }\n        }\n      }\n      //printf(\"%d %d\\n\", bx, by);\n      solve();\n    }\n  return 0;\n}\n\nvoid bfs(){\n  struct pair{\n    int first;\n    int second;\n  };\n\n  struct queue{\n    struct pair P[101];\n    int head;\n    int tail;\n  };\n\n  struct queue que;\n  que.head = 0;\n  que.tail = 0;\n  int i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      d[j][i] = INF;\n    }\n  }\n\n  que.P[que.tail].first = bx;\n  que.P[que.tail].second = by;\n  d[by][bx] = 0;\n  que.tail++;\n  //que.head++;\n\n  while(que.head < que.tail){\n    struct pair state;\n    state.first = que.P[que.head].first;\n    state.second = que.P[que.head].second;\n    que.head++;\n    //printf(\"%d %d\\n\" ,que.head, que.tail);\n    //if(p.first == gx && p.second == gy) break;\n\n    for(i = 0; i < 4; i++){\n      int nx = state.first + dx[i], ny = state.second + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && tile[ny][nx] != '#' && d[ny][nx] == INF){\n        que.P[que.tail].first = nx;\n        que.P[que.tail].second = ny;\n        que.tail++;\n        d[ny][nx] = d[state.first][state.second] + 1;\n      }\n    }\n  }\n  //return d[gx][gy];\n\n}\n\nvoid solve(){\n  bfs();\n  int ans = 0, i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      if(d[j][i] != INF) ans++;\n    }\n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXH 22\n#define MAXW 24\n\nint bfs(int mat[MAXH][MAXW],int visited[MAXH][MAXW],int ph,int pw,int* ans){\n\tint vector[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\tint i;\n\tvisited[ph][pw]=1;\n\t(*ans)++;\n\tfor(i=0;i<4;i++){\n\t\tint nh=ph+vector[i][0];\n\t\tint nw=pw+vector[i][1];\n\t\tif(mat[nh][nw]=='.'&&visited[nh][nw]==0){\n\t\t\tbfs(mat,visited,nh,nw,ans);\n\t\t}\n\t}\n\treturn 0;\n}\nint input(int mat[MAXH][MAXW],int h,int w,int* sh,int* sw){\n\tint i,j;\n\tfor(i=1;i<h+1;i++){\n\t\tfor(j=1;j<w+1;j++){\n\t\t\tint c;\n\t\t\twhile(c=getchar()){\n\t\t\t\tif(c!='\\n'){\n\t\t\t\t\tmat[i][j]=c;\n\t\t\t\t\tif(c=='@'){\n\t\t\t\t\t\t*sh=i;\n\t\t\t\t\t\t*sw=j;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tint sh,sw;\n\tint ans=0;\n\tint mat[MAXH][MAXW],visited[MAXH][MAXW];\n\tint i,j,k;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<MAXH;i++){\n\t\t\tfor(j=0;j<MAXW;j++){\n\t\t\t\tmat[i][j]='#';\n\t\t\t\tvisited[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tinput(mat,h,w,&sh,&sw);\n\t\tbfs(mat,visited,sh,sw,&ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint W, H;\n\tint map[21][21];\n\tchar in[21];\n\tint x, y;\n\tint flag;\n\tint count;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (y = 1; y <= H; y++){\n\t\t\tscanf(\"%s\", in);\n\t\t\tfor (x = 1; x <= W; x++){\n\t\t\t\tswitch (in[x - 1]){\n\t\t\t\t  case '.':\n\t\t\t\t    map[y][x] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t  \n\t\t\t\t  case '#':\n\t\t\t\t    map[y][x] = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\t  case '@':\n\t\t\t\t    map[y][x] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount = 1;\n\t\tdo {\n\t\t\tflag = 0;\n\t\t\tfor (y = 1; y <= H; y++){\n\t\t\t\tfor (x = 1; x <= W; x++){\n\t\t\t\t\tif (map[y][x] == 1){\n\t\t\t\t\t\tif (y - 1 >= 1 && map[y - 1][x] == 0){\n\t\t\t\t\t\t\tmap[y - 1][x] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y + 1 <= H && map[y + 1][x] == 0){\n\t\t\t\t\t\t\tmap[y + 1][x] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x - 1 >= 1 && map[y][x - 1] == 0){\n\t\t\t\t\t\t\tmap[y][x - 1] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 <= W && map[y][x + 1] == 0){\n\t\t\t\t\t\t\tmap[y][x + 1] = 1;\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (flag == 1);\n\t\t\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define W 21\n#define H 20\n\nint tileCount(char room[H][W], int row, int col, int h, int w);\n\nint main()\n{\n  char room[H][W];\n  int h;    // 部屋の行方向のタイルの枚数\n  int w;    // 部屋の列方向のタイルの枚数\n  int row;  // 最初に人が立っている行位置\n  int col;  // 最初に人が立っている列位置\n  int i, j;\n\n  // 部屋の情報を、配列room[]に文字列として読み込む\n  scanf(\"%d%d\", &w, &h);\n  while (h != 0 && w != 0) {\n    for (i = 0; i < h; i++) {\n      scanf(\"%s\", room[i]);\n      for (j = 0; j < w; j++) {\n        if (room[i][j] == '@') {\n          row = i;  // 最初に人が立っている行位置\n          col = j;  // 最初に人が立っている列位置\n        }\n      }\n    }\n    printf(\"%d\\n\", tileCount(room, row, col, h, w));\n\n    scanf(\"%d%d\", &w, &h);\n  }\n  \n  return(0);\n}\n\nint tileCount(char room[H][W], int row, int col, int h, int w)\n{\n  int i,ans = 0;\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  for(i=0;i<4;i++){\n    int nx = col + dx[i];\n    int ny = row + dy[i];\n    if(nx >= 0 && ny >= 0 && nx < w && ny < h && room[ny][nx]!='#'){\n      room[ny][nx] = '#';\n      ans += tileCount(room ,ny ,nx ,h ,w) + 1;\n    }\n\n  }\n  return ans;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint W,H,map[20][20]={{0}};\nchar tile[20][21];\nvoid search(int h,int w){\n\tif(tile[h][w]=='#'||map[h][w]==1||h<0||h>=H||w<0||w>=W)return;\n\tmap[h][w]=1;\n\tsearch(h,w+1);\n\tsearch(h,w-1);\n\tsearch(h-1,w);\n\tsearch(h+1,w);\n}\nint main(void){\n\tint i,j,memH,memW,p=0;\n\twhile(1){\n\tscanf(\"%d%d\",&W,&H);\n\tif(W==0&&H==0)break;\n\tfor(i=0;i<H;i++){scanf(\"%s\",tile[H]);}\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(tile[H][W]==64){memH=i;memW=j;}}}\n\tsearch(memH,memW);\n\tfor(i=0;i<H;i++){for(j=0;j<W;j++){if(map[i][j]==1)p++;}}\n\tprintf(\"%d\\n\",p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint W,H;\n\tchar room[20][20];\n\tint i,j,k;\n\tint count;\n\tscanf(\"%d %d\",&W,&H);\n\twhile(!(W==0&&H==0)){\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\"%s\",room[i]);\n\t\t}\n\t\tfor(i=0;i<W*H;i++){\n\t\t\tfor(j=1;j<H;j++){\n\t\t\t\tfor(k=0;k<W;k++){\n\t\t\t\t\tif(room[j][k]!='#' && room[j-1][k]=='@'){\n\t\t\t\t\t\troom[j][k]='@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<H;j++){\n\t\t\t\tfor(k=1;k<W;k++){\n\t\t\t\t\tif(room[j][k]!='#' && room[j][k-1]=='@'){\n\t\t\t\t\t\troom[j][k]='@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<H-1;j++){\n\t\t\t\tfor(k=0;k<W;k++){\n\t\t\t\t\tif(room[j][k]!='#' && room[j+1][k]=='@'){\n\t\t\t\t\t\troom[j][k]='@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<H;j++){\n\t\t\t\tfor(k=0;k<W-1;k++){\n\t\t\t\t\tif(room[j][k]!='#' && room[j][k+1]=='@'){\n\t\t\t\t\t\troom[j][k]='@';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tif(room[i][j]=='@'){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t\tscanf(\"%d %d\", &W,&H);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(s[ny][nx] == '.'){\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tchar a;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%s\", &a);\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\t\t\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint w,h;\nchar array[21][21];\nint search(int x,int y)\n{\n\t\tif(x<0||y<0||x>=w||y>=h)\n\t\t\treturn 0;\n\t\tif(array[x][y]=='#')\n\t\t\treturn 0;\n\t\telse{\n\t\t\t\tarray[x][y]='#';\n\t\t\t\treturn 1+search(x-1,y)+search(x+1,y)+search(x,y-1)+search(x,y+1);\n\t\t}\n}\n\t\t\t\nint main()\n{\n\t\tint i,j;\n\t\twhile(scanf(\"%d%d\",&h,&w)&&w!=0&&h!=0){\n\t\t\t\tfor(i=0;i<w;i++)\n\t\t\t\t\tscanf(\"%s\",array[i]);\n\t\t\t\tfor(i=0;i<w;i++)\n\t\t\t\t\tfor(j=0;j<h;j++){\n\t\t\t\t\t\t\t\tif(array[i][j]=='@')\n\t\t\t\t\t\t\t\t\tprintf(\"%d\\n\",search(i,j));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid run(int a[][25],int b[][25],int x,int y,int w,int h){\n\tif(x-1>=0&&b[x-1][y]==0&&a[x-1][y]==1){\n\t\tb[x-1][y]=1;\n\t\trun(a,b,x-1,y,w,h);\n\t}\n\tif(y-1>=0&&b[x][y-1]==0&&a[x][y-1]==1){\n\t\tb[x][y-1]=1;\n\t\trun(a,b,x,y-1,w,h);\n\t}\n\tif(x+1<=w-1&&b[x+1][y]==0&&a[x+1][y]==1){\n\t\tb[x+1][y]=1;\n\t\trun(a,b,x+1,y,w,h);\n\t}\n\tif(y+1<=h-1&&b[x][y+1]==0&&a[x][y+1]==1){\n\t\tb[x][y+1]=1;\n\t\trun(a,b,x,y+1,w,h);\n\t}\n}\n\nint get_ans(int b[][25],int w,int h){\n\tint i,j;\n\tint ans=0;\n\tfor(i=0;i<w;i++){\n\t\tfor(j=0;j<h;j++){\n\t\t\tif(b[i][j]==1)ans+=1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint a[25][25];\t\t//?????????1,?????????-1,?????¨??°???0\n\tint b[25][25];\t//??°?????????????????????true\n\tint w,h;\n\tchar c;\n\tint x,y;\t//?????£???????????§?¨?\n\tint i,j,k,l;\n\tint ans;\n\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tscanf(\"%c\",&c);\n\t\tif(w==0&&h==0)break;\n\t\tfor(j=0; j<h; j++){\n\t\t\tfor(i=0; i<w; i++){\n\t\t\t\tb[i][j]=0;\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif(c=='.')a[i][j]=1;\n\t\t\t\tif(c=='#')a[i][j]=-1;\n\t\t\t\tif(c=='@'){\n\t\t\t\t\ta[i][j]=0;\n\t\t\t\t\tx=i;\n\t\t\t\t\ty=j;\n\t\t\t\t\tb[x][y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%c\",&c);\n\t\t}\n\t\t// for(i=0; i<h; i++){\n\t\t// \tfor(j=0; j<w; j++){\n\t\t// \t\tprintf(\"%d \",a[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t\t// printf(\"\\n\\n\");\n\t\t// for(i=0; i<h; i++){\n\t\t// \tfor(j=0; j<w; j++){\n\t\t// \t\tprintf(\"%d \",b[j][i]);\n\t\t// \t}\n\t\t// \tprintf(\"\\n\");\n\t\t// }\n\t\trun(a,b,x,y,w,h);\n\t\tprintf(\"%d\\n\",get_ans(b,w,h));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int T[20][20],X,Y,x,y,p,q,i,c;\n#define t T[y][x]\nvoid R(x,y){(0<=x&&x<X&&0<=y&&y<Y&&!t)?t=1,i++,R(x-1,y),R(x+1,y),R(x,y-1),R(x,y+1):0;}\nmain(){for(;scanf(\"%d%d\",&X,&Y),X;printf(\"%d\\n\",i)){\n\tfor(i=0;i<X*Y;i++){\n\t\tfor(x=i%X,y=i/X;(c=getchar())=='\\n';);\n\t\tswitch(c){\n\t\t\tcase'@':p=x;q=y;\n\t\t\tcase'.':t=0;break;\n\t\t\tcase'#':t=1;\n\t\t}\n\t}\n\ti=0;R(p,q);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "// Aizu 1130: Red and Black\n// 2017.9.13 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar map[22][22], mk[22][22];\nint que[500][2], top, end;\nint m[4][2] = {{1,0},{-1,0},{0,-1},{0,1}};\n\nint main()\n{\n\tint w, h, i, r, c, r2, c2, ans;\n\t\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (i = 0, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tif (!i) for (c = 0; c < w; c++) if (map[r][c] == '@') {\n\t\t\t\tque[0][0] = r, que[0][1] = c; mk[r][c] = 1, top = 0, end = 1, i = 1;\n\t\t\t}\n\t\t}\n\t\twhile (top < end) {\n\t\t\tr = que[top][0], c = que[top++][1];\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + m[i][0], c2 = c + m[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || map[r2][c2] == '#') continue;\n\t\t\t\tif (mk[r2][c2]) continue;\n\t\t\t\tmk[r2][c2] = 1;\n\t\t\t\tque[end][0] = r2, que[end++][1] = c2;\n\t\t\t}\n\t\t}\n\t\tfor (ans = 0, r = 0; r < h; r++) for (c = 0; c < w; c++) ans += mk[r][c];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nconst int INF = 10000000;\n\nint W, H, bx, by;\nchar tile[21][21];\nint d[21][21];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nvoid bfs();\n\nvoid solve();\n\n\nint main(){\n  int i, j;\n  while(scanf(\"%d%d\", &W, &H) && (W || H)){\n    //scanf(\"%d%d\", &W, &H);\n      for(i = 0 ; i < H; i++){\n        scanf(\"%s\", tile[i]);\n      }\n      for(i = 0; i < W; i++){\n        for(j = 0; j < H; j++){\n          if(tile[j][i] == '@'){\n            bx = i;\n            by = j;\n          }\n        }\n      }\n      //printf(\"%d %d\\n\", bx, by);\n      solve();\n    }\n  return 0;\n}\n\nvoid bfs(){\n  struct pair{\n    int first;\n    int second;\n  };\n\n  struct queue{\n    struct pair P[101];\n    int head;\n    int tail;\n  };\n\n  struct queue que;\n  que.head = 0;\n  que.tail = 0;\n  int i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      d[j][i] = INF;\n    }\n  }\n\n  que.P[que.tail].first = bx;\n  que.P[que.tail].second = by;\n  d[by][bx] = 0;\n  que.tail++;\n  //que.head++;\n\n  while(que.head < que.tail){\n    struct pair state;\n    state.first = que.P[que.head].first;\n    state.second = que.P[que.head].second;\n    que.head++;\n    //printf(\"%d %d\\n\" ,que.head, que.tail);\n    //if(p.first == gx && p.second == gy) break;\n\n    for(i = 0; i < 4; i++){\n      int nx = state.first + dx[i], ny = state.second + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && tile[ny][nx] != '#' && d[ny][nx] == INF){\n        que.P[que.tail].first = nx;\n        que.P[que.tail].second = ny;\n        que.tail++;\n        d[ny][nx] = d[state.first][state.second] + 1;\n      }\n    }\n  }\n  //return d[gx][gy];\n\n}\n\nvoid solve(){\n  bfs(bx, by);\n  int ans = 0, i, j;\n  for(i = 0; i < W; i++){\n    for(j = 0; j < H; j++){\n      //printf(\"%d\\n\", d[i][j]);\n      if(d[j][i] != INF) ans++;\n    }\n  }\n  //printf(\"%d\\n\",INF);\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "w,h,c,j,g;char*p,f[999],*q;main(i){for(;scanf(\"%d%d\",&w,&h),w++;printf(\"%d\\n\",c)){memset(f,35,900);for(i=1;i<=h;i++)scanf(\"%s\",f+i*w+i+1),f[strchr(f,0)-f]=35;for(c=g=1;g;)for(p=f,g=0;p=strchr(p+1,64);)for(j=0;j<2;j++)*(q=(p+j*w+1))-46||(*q=64,g|=c++),*(q=(p-j*w-1))-46||(*q=64,g|=c++);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}{0,1}{0,-1}{-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(map[a1][b1])=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1:\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0;, a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 20\n\nint w, h;\nchar field[MAX_SIZE][MAX_SIZE + 1];\n\nint out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nint dfs(int x, int y) {\n\tstatic const int dx[] = {1, 0, -1, 0};\n\tstatic const int dy[] = {0, 1, 0, -1};\n\n\tint count = 1;\n\tint dir;\n\n\tfield[y][x] = '#';\n\n\tfor(dir = 0; dir < 4; ++dir) {\n\t\tconst int nx = x + dx[dir];\n\t\tconst int ny = y + dy[dir];\n\n\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\tcount += dfs(nx, ny);\n\t}\n\n\treturn count;\n}\n\nint main() {\n\twhile(scanf(\"%d %d\", &w, &h) == 2 && w) {\n\t\tint x, y;\n\t\tint sx, sy;\n\n\t\tfor(y = 0; y < h; ++y) {\n\t\t\tscanf(\"%s\", field[y]);\n\n\t\t\tfor(x = 0; x < w; ++x) {\n\t\t\t\tif(field[y][x] == '@') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", dfs(sx, sy));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d %d \", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile1[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tscanf(\"%d %d\", &w, &h);\n\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i;\n\t\tfor(i = 0; i < h; i++){\n\t\t\tscanf(\"%s\", s[i]);\n\t\t}\n\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(int j = 0; j<w; j++){\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <string.h>\n\nint w,h;\nint dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\nchar map[22][22];\n\nint solve(int i,int j){\n  int k,total=1;\n\n  map[i][j] = '#';\n  for(k=0;k<4;k++){\n    if(map[i+dir[k][0]][j+dir[k][1]]=='.'){total+=solve(i+dir[k][0],j+dir[k][1]);}\n  }\n\n  return total;\n}\n\nint main(void){\n  int i,j,si,sj;\n\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n\n    memset(map,'#',sizeof(map));\n    for(i=1;i<=h;i++){\n      scanf(\"%s\",&map[i][1]);\n      map[i][w+1] = '#';\n      for(j=1;j<=w;j++){\n        if(map[i][j]=='@'){si=i,sj=j;}\n      }\n    }\n\n    printf(\"%d\\n\",solve(si,sj));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "W,C;R(char*i){*i>45?*i=0,C++,R(i-1),R(i+1),R(i-W),R(i+W):0;}main(d,m){for(;scanf(\"%d%*d\",&W)*W;C=!printf(\"%d\\n\",C))memset(m,W++,484),scanf(\"%[^0-9]\",m+W),R(strchr(m,64));}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n    int x,y;\n    int now_x,now_y;\n    int tmp;\n    int board[22][22];\n    int i,j;\n    int end_flag = 0;\n    int cnt = 0;\n\n\n\n    while(1){\n        scanf(\"%d %d\", &x, &y);\n        \n        if(x == 0 && y == 0){\n            return 0;\n        }\n\n        for(i = 0; i < 22; i++){\n            for(j = 0; j < 22; j++){\n                board[i][j] = -1;\n            }\n        }\n\n        for(i = 1; i <= y; i++){\n            for(j = 1; j <= x; j++){\n                tmp = getchar();\n                if(tmp == '\\n'){\n                    tmp = getchar();\n                }\n                switch(tmp){\n                    case '.': board[i][j] = 1;break;\n                    case '#': board[i][j] = 0;break;\n                    case '@': board[i][j] = 2;break;\n                }\n            }\n        }\n\n        while(end_flag == 0){\n            end_flag = 1;\n\n            for(i = 1; i <= y; i++){\n                for(j = 1; j <= x; j++){\n                    if(board[i][j] == 2){\n                        if(board[i + 1][j] == 1){\n                            end_flag = 0;\n                            board[i + 1][j] = 2;\n                        }\n                        if(board[i - 1][j] == 1){\n                            end_flag = 0;\n                            board[i - 1][j] = 2;\n                        }\n                        if(board[i][j + 1] == 1){\n                            end_flag = 0;\n                            board[i][j + 1] = 2;\n                        }\n                        if(board[i][j - 1] == 1){\n                            end_flag = 0;\n                            board[i][j - 1] = 2;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for(i = 1; i <= y; i++){\n           for(j = 1; j <= x; j++){\n               if(board[i][j] == 2){\n                   cnt++;\n               }\n           }\n        }\n\n        printf(\"%d\\n\", cnt);\n\n    }\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\tint tile[22][22],x,y,flag,W,H,i,j;\n\tchar c;\n\t\n\twhile(0<=scanf(\"%d%d\",&W,&H)){\n\t\tif(W==0 && H==0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(i=0;i<22;i++){\n\t\t\tfor(j=0;j<22;j++){\n\t\t\t\ttile[i][j]='#';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tscanf(\" %c \",&tile[j][i]);\n\t\t\t\tif(tile[j][i]=='\\n'){\n\t\t\t\t\tscanf(\"%c\",&tile[j][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n/* \t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tprintf(\"%c \",tile[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n */\t\t\n\t\tflag=0;\n\t\twhile(flag==0){\n\t\t\tflag=1;\n\t\t\tfor(i=1;i<=H;i++){\n\t\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\t\tif(tile[j][i]=='.' && (tile[j+1][i]=='@' || tile[j-1][i]=='@' || tile[j][i-1]=='@' || tile[j][i+1]=='@')){\n\t\t\t\t\t\ttile[j][i]='@';\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tflag=0;\n\t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tif(tile[j][i]=='@') ++flag;\n\t\t\t}\n\t\t}\n\t\n\t\tprintf(\"%d\\n\",flag);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y){\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor(i = 0; i<4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h && s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(0){\n\t\tchar a;\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%s\", &a);\n\t\tif(!w && !h){\t\n\t\t\tbreak;\n\t\t}\n\t\tcount = 0;\n\t\tint i, j, x, y;\n\t\t\n\t\tfor(i = 0; i<h; i++){\n\t\t\tfor(j = 0; j<w; j++){\n\t\t\t\tscanf(\"%s\", s[i][j]);\n\t\t\t\tif(s[i][j] == '@'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%s\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar map[30][30];\nint cnt=0;\nint w,h;\n\nvoid DFS(int x,int y);\nint main(){\n\n  int i,j;\n\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0) break;\n    \n    for(i=0;i<h;i++){\n      scanf(\"%s\",map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(map[i][j]=='@'){\n\t  DFS(j,i);\n\t  break;\n\t}\n      }\n    }\n    \n    printf(\"%d\\n\",cnt);\n    cnt=0;\n  }\n  \n  return 0;\n}\n\n\nvoid DFS(int x,int y){\n\n  if(x<0 || y<0 || x>=w || y>=h) return;\n  if(map[y][x]=='&' || map[y][x]=='#') return;\n\n  map[y][x]='&';\n  cnt++;\n\n  DFS(x+1,y); DFS(x,y+1);\n  DFS(x-1,y); DFS(x,y-1);\n\n\n  return ;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXH 22\n#define MAXW 24\n\nint bfs(int mat[MAXH][MAXW],int visited[MAXH][MAXW],int ph,int pw,int* ans){\n\tint vector[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\tint i;\n\tvisited[ph][pw]=1;\n\t(*ans)++;\n\tfor(i=0;i<4;i++){\n\t\tint nh=ph+vector[i][0];\n\t\tint nw=pw+vector[i][1];\n\t\tif(mat[nh][nw]=='.'&&visited[nh][nw]==0){\n\t\t\tbfs(mat,visited,nh,nw,ans);\n\t\t}\n\t}\n\treturn 0;\n}\nint input(int mat[MAXH][MAXW],int h,int w,int* sh,int* sw){\n\tint i,j;\n\tfor(i=1;i<h+1;i++){\n\t\tfor(j=1;j<w+1;j++){\n\t\t\tint c;\n\t\t\twhile(c=getchar()){\n\t\t\t\tif(c!='\\n'){\n\t\t\t\t\tmat[i][j]=c;\n\t\t\t\t\tif(c=='@'){\n\t\t\t\t\t\t*sh=i;\n\t\t\t\t\t\t*sw=j;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint w,h;\n\tint sh,sw;\n\tint ans=0;\n\tint mat[MAXH][MAXW],visited[MAXH][MAXW];\n\tint i,j,k;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tans=0;\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<22;j++){\n\t\t\t\tmat[i][j]='#';\n\t\t\t\tvisited[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tinput(mat,h,w,&sh,&sw);\n\t\tbfs(mat,visited,sh,sw,&ans);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint Walk(int, int, int, int, int);\n\nint map[20][20];\n\nint main()\n{\n\tchar input[21];\n\tint i, j, ans, w, h, sH, sW;\n\t\n\twhile(1)\n\t{\n\t\tsH = sW = 0;\n\t\t\n\t\tscanf(\"%d %d\", &w, &h);\n\t\t\n\t\tif(w == 0 && h == 0) break;\n\t\t\n\t\tfor(i = 0; i < h; i++)\n\t\t{\n\t\t\tscanf(\" %s\", input);\n\t\t\t\n\t\t\tfor(j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif(input[j] == '.')\n\t\t\t\t{\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t} else if(input[j] == '#') {\n\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\tsH = i;\n\t\t\t\t\tsW = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = Walk(0, sH, sW, h, w);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n\nint Walk(int count, int h, int w, int maxH, int maxW)\n{\n\tint i, j, ans, dh, dw, ch, cw;\n\t\n\tmap[h][w] |= 2;\n\tans = count + 1;\n\t\n\tfor(i = 0; i < 4; i++)\n\t{\n\t\tdw = cos(90 * i * M_PI / 180);\n\t\tdh = sin(90 * i * M_PI / 180);\n\t\t\n\t\tch = h + dh;\n\t\tcw = w + dw;\n\t\t\n\t\tif(ch > -1 && ch < maxH && cw > -1 && cw < maxW && (map[ch][cw] & 3) == 1)\n\t\t{\n\t\t\tans = Walk(ans ,ch, cw, maxH, maxW);\n\t\t}\n\t}\n\t\n\treturn ans;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAPX 25\n#define MAPY 25\nchar data[MAPY][MAPX];\nint h,w;\nint search(int num, int nowx, int nowy){\n\tnum = 1;\n\tdata[nowy][nowx] = '#';\n\tif(nowx>0   && data[nowy][nowx-1]=='.')num += search(num, nowx-1, nowy);\n\tif(nowy>0   && data[nowy-1][nowx]=='.')num += search(num, nowx, nowy-1);\n\tif(nowx<w-1 && data[nowy][nowx+1]=='.')num += search(num, nowx+1, nowy);\n\tif(nowy<h-1 && data[nowy+1][nowx]=='.')num += search(num, nowx, nowy+1);\n\treturn num;\n}\n\nvoid solve(){\n\tint i,t;\n\tint sx,sy;\n\tfor(i = 0;i < h;i++)\n\t\tscanf(\"%s\", data[i]);\n\tfor(i = 0;i < h;i++){\n\t\tfor(t = 0;t < w;t++){\n\t\t\tif(data[i][t]=='@'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = t;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", search(0,  sx, sy));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\", &h, &w);\n\t\tif(h == 0 && w == 0)break;\n\t\tsolve(h,w);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n \nint w,h;\nchar map[20][21];\n \nint search(int x,int y) {\n    int result=1;\n    if(x<0 || x>=w || y<0 || y>=h)return 0;\n    if(map[y][x]=='#')return 0;\n    map[y][x]='#';\n    result+=search(x-1,y);\n    result+=search(x+1,y);\n    result+=search(x,y-1);\n    result+=search(x,y+1);\n    return result;\n}\n \nint main(void) {\n    int i,j;\n    int sx,sy;\n    while(1) {\n        scanf(\"%d%d\",&w,&h);\n        if(w==0 && h==0)break;\n        for(i=0;i<h;i++) {\n            scanf(\"%s\",map[i]);\n            for(j=0;j<w;j++) {\n                if(map[i][j]=='@'){sx=j;sy=i;}\n            }\n        }\n        printf(\"%d\\n\",search(sx,sy));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar s[21][21];\nint count, h, w;\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nvoid dfs(int x, int y) {\n\tcount++;\n\ts[y][x] = '#';\n\tint i;\n\tfor (i = 0; i<4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif (s[ny][nx] == '.') {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main(void) {\n\tchar a;\n\tint i, j, x, y;\n\twhile(1){\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tscanf(\"%c\", &a);\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i<21; i++) {\n\t\t\tfor (j = 0; j<21; j++) {\n\t\t\t\ts[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\n\t\tfor (i = 1; i<h; i++) {\n\t\t\tfor (j = 1; j<w; j++) {\n\t\t\t\tscanf(\"%c\", &s[i][j]);\n\t\t\t\tif (s[i][j] == '@') {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%c\", &a);\n\t\t}\n\t\tdfs(x, y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            if (!i) for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end++][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 20\n\nint cur;\n\nvoid goAble(char map[N][N],int h,int w,int x,int y){\n  if(x<0 || w<=x || y<0 || h<=y) return ;\n  if(map[y][x]=='#' || map[y][x]=='+') return ;\n\n  map[y][x]='+';\n  cur++;\n\n  goAble(map,h,w,x-1,y);\n  goAble(map,h,w,x+1,y);\n  goAble(map,h,w,x,y-1);\n  goAble(map,h,w,x,y+1);\n\n  return ;\n}\n\nint main(void){\n  int i,j;\n  int w,h;\n  char map[N][N];\n  char hoge;\n  int x,y;\n\n  for(;;){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n\n    for(i=0;i<h;i++){\n      scanf(\"%c\",&hoge);\n      for(j=0;j<w;j++){\n        scanf(\"%c\",&map[i][j]);\n        if(map[i][j]=='@'){\n          x=j;\n          y=i;\n        }\n      }\n    }\n\n    cur=0;\n    goAble(map,h,w,x,y);\n\n    printf(\"%d\\n\",cur);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(){\n\twhile(1){\n\t\tint W, H;\n\t\tchar s[100];\n\t\tchar map[50][50];\n\t\tint i;\n\t\tint count = 0;\n\n\t\tscanf(\"%d %d\\n\", &W, &H);\n\t\t// printf(\"%d,%d\\n\", W, H);\n\t\tif((W | H) == 0) break;\n\n\t\tfor(i = 0; i < H + 2; i++){\n\t\t\tint j;\n\n\t\t\tfor(j = 0; j < W + 2; j++){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor(i = 0; i < H; i++){\n\t\t\tint j;\n\n\t\t\t/* fgets(s, 100, stdin); */\n\t\t\tfor(j = 0;j < W; j++){\n\t\t\t\tint end = 0;\n\t\t\t\tchar c;\n\n\t\t\t\tc = getchar();\n\n\t\t\t\tswitch(c){\n\t\t\t\tcase '.':\n\t\t\t\t\tmap[i + 1][j + 1] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tmap[i + 1][j + 1] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '@':\n\t\t\t\t\tmap[i + 1][j + 1] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tend = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(end) break;\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\n\t\twhile(1){\n\t\t\tint end = 0;\n\n\t\t\tfor(i = 0; i < H + 2; i++){\n\t\t\t\tint j;\n\n\t\t\t\tfor(j = 0; j < W + 2; j++){\n\t\t\t\t\tif(map[i][j] == 1){\n\t\t\t\t\t\tif(map[i + 1][j] == 0) map[i + 1][j] = end = 1;\n\t\t\t\t\t\tif(map[i - 1][j] == 0) map[i - 1][j] = end = 1;\n\t\t\t\t\t\tif(map[i][j + 1] == 0) map[i][j + 1] = end = 1;\n\t\t\t\t\t\tif(map[i][j - 1] == 0) map[i][j - 1] = end = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(end == 0) break;\n\t\t}\n\n\t\tfor(i = 1; i < H + 1; i++){\n\t\t\tint j;\n\n\t\t\tfor(j = 1; j < W + 1; j++){\n\t\t\t\tif(map[i][j] == 1) count++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", count);\n\t}\n\n\texit(EXIT_SUCCESS);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tint x;\n\tint y;\n} point;\n\nint tile[20][20];\npoint stack[400];\nint sp=0;\n\nvoid stack_push(point i){\n\tstack[sp++]=i;\n}\n\npoint stack_pop(){\n\treturn stack[--sp];\n}\n\nint stack_empty(){\n\treturn !sp;\n}\n\nint main()\n{\n    int i,j,w,h;\n    point human;\n\n\n    while(1){\n\t\tfor(i=0;i<20;i++)\n\t\t\tfor(j=0;j<20;j++)\n\t\t\t\ttile[i][j]='#';\n\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tretry:\n\t\t\t\ttile[j][i]=getchar();\n\t\t\t\tif(tile[j][i]!='@' && tile[j][i]!='.' && tile[j][i]!='#')\n\t\t\t\t\tgoto retry;\n\t\t\t\tif(tile[j][i]=='@'){\n\t\t\t\t\thuman.x=j; human.y=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack_push(human);\n\t\ttile[human.x][human.y]='#';\n\n\t\tint count=0;\n\n\t\twhile(!stack_empty()){\n\t\t\tpoint current=stack_pop();\n\t\t\tpoint temp;\n\n\t\t\tcount++;\n\n\t\t\tif(current.x+1<20 && tile[current.x+1][current.y]=='.'){\n\t\t\t\ttile[current.x+1][current.y]='#';\n\t\t\t\ttemp.x=current.x+1; temp.y=current.y;\n\t\t\t\tstack_push(temp);\n\t\t\t}\n\t\t\tif(current.x-1>=0 && tile[current.x-1][current.y]=='.'){\n\t\t\t\ttile[current.x-1][current.y]='#';\n\t\t\t\ttemp.x=current.x-1; temp.y=current.y;\n\t\t\t\tstack_push(temp);\n\t\t\t}\n\t\t\tif(current.y+1<20 && tile[current.x][current.y+1]=='.'){\n\t\t\t\ttile[current.x][current.y+1]='#';\n\t\t\t\ttemp.x=current.x; temp.y=current.y+1;\n\t\t\t\tstack_push(temp);\n\t\t\t}\n\t\t\tif(current.y-1>=0 && tile[current.x][current.y-1]=='.'){\n\t\t\t\ttile[current.x][current.y-1]='#';\n\t\t\t\ttemp.x=current.x; temp.y=current.y-1;\n\t\t\t\tstack_push(temp);\n\t\t\t}\n\t\t}\n\n\n\t\tprintf(\"%d\\n\",count);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar t[21][21]={0};\nint  h,w;\n\nvoid at(int i,int j);\nint main(){\n  int i,j,a,b,cnt=0;\n  scanf(\"%d %d\",&w,&h);\n  \n  while(w!=0 || h!=0){\n    \n    for(i=0;i<h;i++){\n      scanf(\"%s\",t[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(t[i][j]=='@'){\n\t  t[i][j]='.';\n\t  a=i; b=j;\n\t}\n      }\n    }\n    \n    at(a,b);\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(t[i][j]=='@') cnt++;\n      }\n    }\n    \n    printf(\"%d\\n\",cnt);\n    cnt=0;\n    scanf(\"%d %d\",&w,&h);\n  }\n  return 0;\n}\n\nvoid at(int i,int j){\n\n  if(t[i][j]=='#') return;\n  if(t[i][j]=='@') return;\n  if(i==h || j==w || i==-1 || j==-1) return;\n\n\n  t[i][j]='@';\n  at(i+1,j);\n  at(i-1,j);\n  at(i,j+1);\n  at(i,j-1);\n  \n  return;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid move(int,int);\nint count=1,w,h;\nchar Map[20][20];\nint main()\n{\n  int i,j,ii,jj;\n  char ch;\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",&Map[i]);\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(Map[i][j]=='@'){\n          ii=i;\n\t  jj=j;\n\t}\n      }\n    }\n    if(Map[ii-1][jj]=='.')move(ii-1,jj); \n    if(Map[ii+1][jj]=='.')move(ii+1,jj);\n    if(Map[ii][jj-1]=='.')move(ii,jj-1); \n    if(Map[ii][jj+1]=='.')move(ii,jj+1);\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%c \",Map[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"%d\\n\",count);\n    count=1;\n  }\n  return 0;\n}\n\nvoid move(int hh,int ww)\n{\n  if(hh<0||ww<0||ww>w||hh>h||Map[hh][ww]=='#')return;\n  Map[hh][ww]='#';\n  count++;\n  if(Map[hh-1][ww]=='.')move(hh-1,ww); \n  if(Map[hh+1][ww]=='.')move(hh+1,ww);\n  if(Map[hh][ww-1]=='.')move(hh,ww-1); \n  if(Map[hh][ww+1]=='.')move(hh,ww+1);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include<string.h>\n\nint que[400][2], top, end;\nint dir[4][2]={{1,0}, {0,1}, {0,-1}, {-1,0}};\nchar tile1[22][22], tile2[22][22];\n\nint main(void)\n{\n    int w, h, i, a1, a2, b1, b2, ans;\n    \n    while(scanf(\"%d%d\", &w, &h)&&w){\n        memset(tile1, 0, sizeof(tile1));\n        for(i=0, a1=0; a1<h; a1++){\n            scanf(\"%s\", tile2[a1]);\n            for(b1=0; b1<w; b1++){\n                if(tile2[a1][b1]=='@'){\n                    que[0][0]=a1, que[0][1]=b1;\n                    tile1[a1][b1]=1, top=0, end=1, i=1;\n                }\n            }\n        }\n        while(top<end){\n            a1=que[top][0], b1=que[top++][1];\n            for(i=0; i<4; i++){\n                a2=a1+dir[i][0], b2=b1+dir[i][1];\n                if(a2<0||a2>=h||b2<0||b2>=w||tile2[a2][b2]=='#')\n                    continue;\n                tile1[a2][b2]=1;\n                que[end][0]=a2, que[end++][1]=b2;\n            }\n        }\n        for(ans=0, a1=0; a1<h; a1++)\n            for(b1=0; b1<w; b1++)\n                ans+=tile1[a1][b1];\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define SIZE 100000\ntypedef struct{\n  int x;\n  int y;\n}Zahyo;\nZahyo  z[SIZE];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nmain(){\n  int h,w;\n  char maps[30][30];\n  int i,j;\n  while(1){\n  scanf(\"%d %d\",&w,&h);\n  if(w == 0 && h == 0) break;\n  int cnt=0;\n    int head=0;\n    int tail=0;\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%c\",&maps[i][j]);\n      if(maps[i][j]=='@'){\n\tz[0]=(Zahyo){j,i};\n\ttail=(tail+1)%SIZE;\n      }\n    }\n  }\n  while(head != tail){\n    int x = z[head].x; int y = z[head].y; head = (head+1) % SIZE;\n    if(0 <= x && 0 <= y && x < w && y < h && maps[y][x] != '#'){\n      maps[y][x] = '#';\n      cnt++;\n      for(i=0;i<4;i++){\n\tint nx = x + dx[i]; int ny = y + dy[i];\n\tz[(tail+i) % SIZE] = (Zahyo){ nx,ny };\n      }\n      tail = (tail+4) % SIZE;\n    }\n  }\n  printf(\"%d\\n\",cnt);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<stdbool.h>\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\n\nint r,h,w;\nint fl[32][32];\nchar s[32][32];\n\nvoid rep(int p,int q){\n  if(p<0 || h<=p){return;}\n  if(q<0 || w<=q){return;}\n  if(fl[p][q]==1){return;}\n  if(s[p][q]=='#'){return;}\n  //printf(\"<%d %d>\\n\",p,q);\n  int i;\n  fl[p][q]=1;\n  r++;\n  for(i=0;i<4;i++){\n    rep(p+dx4[i],q+dy4[i]);\n  }\n}\n\nint main(){\n  int i,j,p,q;\n  while(scanf(\"%d%d\",&w,&h),w!=0){\n    r=0;\n    for(i=0;i<h;i++){\n      scanf(\"%s\",s[i]);\n      for(j=0;j<w;j++){\n        fl[i][j]=0;\n        if(s[i][j]=='@'){p=i;q=j;}\n      }\n    }\n    rep(p,q);\n    printf(\"%d\\n\",r);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "n,m,x,y,c,gx,gy;char map[20][20];check(x,y){map[x][y]=35;c++;if(x+1<gy&&map[x+1][y]==46)check(x+1,y);if(x>0&&map[x-1][y]==46)check(x-1,y);if(y+1<gx&&map[x][y+1]==46)check(x,y+1);if(y>0&&map[x][y-1]==46)check(x,y-1);}main(){for(;scanf(\"%d%d\",&gx,&gy),gx;){for(x=0;x<20;x++)for(y=0;y<20;)map[x][y++]=35;for(c=n=0;n<gy;n++){scanf(\"%s\",map[n]);for(m=0;m<gx;m++)if(map[n][m]==64)x=n,y=m;}check(x,y);printf(\"%d\\n\",c);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n    int W=0,H=0;\n    int ans[100000]={0};\n    char board[21][21];\n    int quex[100000]={0};\n    int quey[100000]={0};\n    int count=0;\n    int queC=0;\n    while(1){\n        scanf(\"%d %d\",&W,&H);\n        if(W==0&&H==0){\n            break;\n        }\n        for(int i=0;i<H;i++){\n            scanf(\"%s\",board[i]);\n            for(int j=0;j<W;j++){\n                if(board[i][j]=='@'){\n                    quex[0]=j;\n                    quey[0]=i;\n                }\n            }\n        }\n        queC=0;\n        while(1){\n          \n            int sw=0;\n            if(quex[queC]!=0){\n                if(board[quey[queC]][quex[queC]-1]=='.'){\n                    queC+=1;\n                    quex[queC]=quex[queC-1]-1;\n                    quey[queC]=quey[queC-1];\n                    board[quey[queC]][quex[queC]]='#';\n                    ans[count]++;\n                    sw=1;\n                }\n            }\n            if(quex[queC]!=W-1){\n                if(board[quey[queC]][quex[queC]+1]=='.'){\n                    queC+=1;\n                    quex[queC]=quex[queC-1]+1;\n                    quey[queC]=quey[queC-1];\n                    board[quey[queC]][quex[queC]]='#';\n                    ans[count]++;\n                    sw=1;\n                }\n            }\n            if(quey[queC]!=0){\n                if(board[quey[queC]-1][quex[queC]]=='.'){\n                    queC+=1;\n                    quex[queC]=quex[queC-1];\n                    quey[queC]=quey[queC-1]-1;\n                    board[quey[queC]][quex[queC]]='#';\n                    ans[count]++;\n                    sw=1;\n                }\n            }\n            if(quey[queC]!=H-1){\n                if(board[quey[queC]+1][quex[queC]]=='.'){\n                    queC+=1;\n                    quex[queC]=quex[queC-1];\n                    quey[queC]=quey[queC-1]+1;\n                    board[quey[queC]][quex[queC]]='#';\n                    ans[count]++;\n                    sw=1;\n                }\n            }\n            if(sw==0){\n                queC-=1;\n            }\n           \n            if(queC<0){\n                ans[count]+=1;\n                break;\n            }\n        }\n        count++;\n    }\n    for(int i=0;i<count;i++){\n        printf(\"%d\\n\",ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint a[20][20];\nint w,h,i,j,o,p;\nchar str[20];\nchar kara;\nint count;\n\nvoid go(int x, int y) {\n  //  printf(\"start go\\n\");\n  //  printf(\"a[%d][%d] = %d\\n\",x,y,a[x][y]);\n\n  a[x][y] = 2;\n\n  // printf(\"a[%d][%d] = %d\\n\",x,y,a[x][y]);\n  \n  if(a[x+1][y] == 1 && w -1 > x) {\n    count++;\n    go(x+1,y);\n  }\n  if(a[x-1][y] == 1 && 0 < x) {\n    count++;\n    go(x-1,y);\n  } if(a[x][y+1] == 1 && h-1 > y) {\n    count++;\n    go(x,y+1);\n  }  if(a[x][y-1] == 1 && 0 < y) {\n    //printf(\"start y-1\\n\");\n    count++;\n      go(x,y-1);\n  }\n\n}\n\n\n\nint main() {\n\n\n\n  while(1) {\n  scanf(\"%d %d\",&w,&h);\n  \n  if(w == 0 && h == 0) break;\n\n\n  // @ = 0  . = 1 # = 2\n    for(j=0;j<h;j++) {\n      scanf(\"%s\",str);\n      for(i=0;i<w;i++) {\n      \n      if(str[i] == '.') {\n\ta[i][j] = 1;\n      }else if(str[i] == '@') {\n\ta[i][j] = 0;\n\to = i;\n\tp  = j;\n      }else if(str[i] == '#') {\n\t  a[i][j] = 2;\n\t}\n      }\n    }\n\n    /*    for(i=0;i<h;i++) {\n      for(j=0;j<w;j++){\n\tprintf(\"%d \",a[j][i]);\n      }\n      printf(\"\\n\");\n    }\n    */\n\n    //  printf(\"o = %d\\np = %d\\n\",o,p);\n    count = 0;\n    go(o,p);\n\n\n    /*   printf(\"\\n\");\n  for(i=0;i<h;i++) {\n      for(j=0;j<w;j++){\n\tprintf(\"%d \",a[j][i]);\n      }\n      printf(\"\\n\");\n    }\n    */\n\n    printf(\"%d\\n\",count+1);\n\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.Scanner\n\nvar map: Array<CharArray>? = null\nval sides = arrayOf(Pair(-1,0), Pair(0,-1), Pair(0,1), Pair(1,0))\nfun main(args: Array<String>) {\n\tval scanner = Scanner(System.`in`)\n\twhile(true){\n\t\tval w = scanner.nextInt()\n\t\tval h = scanner.nextInt()\n\t\tif (w==0 && h==0) break\n\t\tvar xbeg: Int = -1\n\t\tvar ybeg: Int = -1\n\t\tmap = Array(h){\n\t\t\tval cs = scanner.next().toCharArray()\n\t\t\tval x = cs.indexOf('@')\n\t\t\tif (x!=-1) {\n\t\t\t\txbeg=x\n\t\t\t\tybeg=it\n\t\t\t}\n\t\t\treturn@Array cs\n\t\t}\n\t\tprintln(rec(xbeg, ybeg, w, h))\n\t}\n\n}\n\nfun rec(x: Int, y: Int, w: Int, h: Int): Int{\n\tvar ans = 1\n\tfor (side in sides){\n\t\tval nx = x+side.first\n\t\tval ny = y+side.second\n\t\tif (nx !in 0 until w) continue\n\t\tif (ny !in 0 until h) continue\n\t\tif  (map!![ny][nx]=='.') {\n\t\t\tmap!![ny][nx]='@'\n\t\t\tans += rec(nx, ny, w, h)\n\t\t}\n\t}\n\treturn ans\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n    \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic final int INF=Integer.MAX_VALUE;\nstatic final long LINF=Long.MAX_VALUE;\nstatic final int[] dx={-1,0,1,0},dy={0,-1,0,1};\nstatic int ans=0;\n \nstatic void solve(){\n while(true){\n  int n=ir.nextInt();\n  int m=ir.nextInt();\n  if(n==0&&m==0) return;\n  ans=0;\n  char[][] map=ir.nextCharMap(m,n);\n  for(int i=0;i<m;i++){\n   for(int j=0;j<n;j++){\n    if(map[i][j]=='@'){\n     dfs(i,j,map,m,n);\n     break;\n    }\n   }\n  }\n  out.println(ans);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\npublic static void dfs(int x,int y,char[][] map,int m,int n){\n ans++;\n map[x][y]='#';\n for(int i=0;i<4;i++){\n  int nx=x+dx[i];\n  int ny=y+dy[i];\n  if(nx>=0&&nx<m&&ny>=0&&ny<n&&map[nx][ny]!='#'){\n   dfs(nx,ny,map,m,n);\n  }\n }\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public BigInteger nextBigInteger(){return new BigInteger(next());}\n \n public BigDecimal nextBigDecimal(){return new BigDecimal(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[] vx = {-1, 0, 0, 1};\n\tint[] vy = {0, -1, 1, 0};\n\tint n, m;\n\t\n\tchar[][] map;\n\tboolean[][] visited;\n\t\n\tint dfs(int x, int y) {\n\t\tif (visited[y][x]) return 0;\n\t\t\n\t\tvisited[y][x] = true;\n\t\tint res = 1;\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tif (0 <= nx && nx < m && 0 <= ny && ny < n && map[ny][nx] == '.') {\n\t\t\t\tres += dfs(nx, ny);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tm = in.nextInt();\n\t\t\tn = in.nextInt();\n\t\t\tif (m == 0) break;\n\t\t\t\n\t\t\tint sx = 0, sy = 0;\n\t\t\tmap = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvisited = new boolean[n][m];\n\t\t\t\n\t\t\tSystem.out.println(dfs(sx, sy));\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// Red and Black\nimport java.util.Scanner;\n\npublic class Main {\n\tint w, h;\n\tString[] field;\n\tboolean[][] visited;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new String[h];\n\t\t\tvisited = new boolean[h][w];\n\t\t\tint result = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfield[i] = sc.next();\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (field[i].charAt(j) == '@') {\n\t\t\t\t\t\tresult = visit(j, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tint visit(int x, int y) {\n\t\tint result = 1;\n\t\tvisited[y][x] = true;\n\t\tif (x > 0 && field[y].charAt(x - 1) != '#' && !visited[y][x - 1])\n\t\t\tresult += visit(x - 1, y);\n\t\tif (x < w - 1 && field[y].charAt(x + 1) != '#' && !visited[y][x + 1])\n\t\t\tresult += visit(x + 1, y);\n\t\tif (y > 0 && field[y - 1].charAt(x) != '#' && !visited[y - 1][x])\n\t\t\tresult += visit(x, y - 1);\n\t\tif (y < h - 1 && field[y + 1].charAt(x) != '#' && !visited[y + 1][x])\n\t\t\tresult += visit(x, y + 1);\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[200];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 200; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0 || h==0) break;\n\t\t\ttile = new int[w][h];\n\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int x, int y) {\n\n\t\tint m = 0;\n\t\ttile[x][y] = 0;\n\n\t\tif(x>0 && tile[x-1][y]==1)m+=canMove(x-1,y);\n\t\tif(x<w-1 && tile[x+1][y]==1)m+=canMove(x+1,y);\n\t\tif(y>0 && tile[x][y-1]==1)m+=canMove(x,y-1);\n\t\tif(y<h-1 && tile[x][y+1]==1)m+=canMove(x,y+1);\n\n\n\t\treturn m++;\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n   public static void main(String a[]) throws java.io.IOException{\n       Scanner scan =new Scanner (System.in);\n       Pair pair= new Pair();\n       Queue<Pair> fifo = new LinkedList<Pair>();\n\n       while(true){\n\n           int W =scan.nextInt();\n           int H =scan.nextInt();\n           if((W|H)==0)break;\n           char  [][] map = new char [H][W];\n           for(int i=0;i<H;i++){\n               String  tmp =scan.next();\n               for(int j=0;j<W;j++){\n                   map[i][j] = tmp.charAt(j);\n                   if(tmp.charAt(j)=='@'){\n                       \n                       pair.x=j;\n                       pair.y=i;\n                       fifo.add(pair);\n                       map[i][j] = '#';\n                   }\n               }\n           }\n          int count =1;\n          while(fifo.peek()!=null){  \n           pair = fifo.poll();\n           int x=pair.x;\n           int y=pair.y;\n           int[] dx ={0,1,0,-1};\n           int[] dy ={1,0,-1,0};\n          for(int i=0;i<4;i++){\n              int nx =x+dx[i];\n              int ny =y+dy[i];\n              if(0<=nx&&nx<W&&0<=ny&&ny<H&&map[ny][nx]!='#'){\n                  Pair npair =new Pair();\n                  npair.x=nx;\n                  npair.y=ny;\n                  fifo.add(npair);\n                  map[ny][nx] = '#';\n                  count++;\n              }\n          } \n          }\n          System.out.println(count);\n\n       \n       }\n}\n}\n\nclass Pair{\n    public int x;\n    public int y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.io.IOException;\n\nclass Main \n{\n\tprivate static int[][] field;\n\tprivate static int W, H;\n\tprivate static Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint[] s;\n\n\t\twhile(init())\n\t\t{\n\t\t\ts = find_start();\n\t\t\tdfs(s[0], s[1]);\n\n\t\t\tSystem.out.println(calc());\n\t\t}\n\t}\n\n\tprivate static boolean init() throws IOException\n\t{\n\t\tString str;\n\t\t\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\n\t\tif(W == 0 && H == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfield = new int[H][W];\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tstr = sc.next();\n\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tswitch(str.charAt(j))\n\t\t\t\t{\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static int[] find_start()\n\t{\n\t\tint[] s = new int[2];\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t{\n\t\t\t\t\ts[0] = i;\n\t\t\t\t\ts[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprivate static void dfs(int i, int j)\n\t{\n\t\t// System.out.println(\"(\"+i+\",\"+j+\")\");\n\n\t\tif(0 < i && i < H - 1)\n\t\t{\n\t\t\t// up\n\t\t\tif(field[i - 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i - 1][j] = 1;\n\t\t\t\tdfs(i - 1, j);\n\t\t\t}\n\n\t\t\t// down\n\t\t\tif(field[i + 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i + 1][j] = 1;\n\t\t\t\tdfs(i + 1, j);\n\t\t\t}\n\t\t}\n\t\telse if(i == 0)\n\t\t{\n\t\t\t// down\n\t\t\tif(field[i + 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i + 1][j] = 1;\n\t\t\t\tdfs(i + 1, j);\n\t\t\t}\n\t\t}\n\t\telse if(i == H - 1)\n\t\t{\n\t\t\t// up\n\t\t\tif(field[i - 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i - 1][j] = 1;\n\t\t\t\tdfs(i - 1, j);\n\t\t\t}\n\t\t}\n\n\t\tif(0 < j && j < W - 1)\n\t\t{\n\t\t\t// left\n\t\t\tif(field[i][j - 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j - 1] = 1;\n\t\t\t\tdfs(i, j - 1);\n\t\t\t}\n\n\t\t\t// right\n\t\t\tif(field[i][j + 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t\tdfs(i, j + 1);\n\t\t\t}\n\t\t}\n\t\telse if(j == 0)\n\t\t{\n\t\t\t// right\n\t\t\tif(field[i][j + 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t\tdfs(i, j + 1);\n\t\t\t}\n\t\t}\n\t\telse if(j == W - 1)\n\t\t{\n\t\t\t// left\n\t\t\tif(field[i][j - 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j - 1] = 1;\n\t\t\t\tdfs(i, j - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int calc()\n\t{\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tString[] board;\n\tboolean[][] dp;\n\tint h,w;\n\tint[] vx = new int[]{1,0,-1,0};\n\tint[] vy = new int[]{0,1,0,-1};\n\tint ret = 0;\n\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w==0) break;\n\t\t\tint i,j;\n\t\t\tret = 0;\n\t\t\tboard = new String[h];\n\t\t\tdp = new boolean[h][w];\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tboard[i] = cin.next();\n\t\t\t}\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(board[i].charAt(j)=='@'){\n\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\tdp[i][j] = true;\n\t\t\t\t\t\tdfs(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tvoid dfs(int y, int x){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny = y + vy[i];\n\t\t\tint nx = x + vx[i];\n\t\t\tif(ok(ny,nx)){\n\t\t\t\tret++;\n\t\t\t\tdp[ny][nx] = true;\n\t\t\t\tdfs(ny,nx);\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean ok(int y, int x){\n\t\treturn y>= 0 && x>=0 && y<h && x<w && board[y].charAt(x)=='.' && !dp[y][x];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class RedandBlack {\n    static int c = 0;\n    static int[][] directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n    static int[][] m;\n\n    public static void spreadFrom(int x, int y) {\n        if (m[y][x] == 0) {\n            m[y][x] = 1;\n            c++;\n        }\n\n        for (int k =0; k < 4; k++) {\n            int nx = x + directions[k][0];\n            int ny = y + directions[k][1];\n            if (nx >= 0 && nx < m[y].length && ny >= 0 && ny < m.length) {\n                spreadFrom(nx, ny);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            c = 0;\n            int W = sc.nextInt();\n            int H = sc.nextInt();\n            if (W == 0 && H == 0)\n                break;\n            m = new int[H][W];\n            int[] start = new int[2];\n            for (int i = 0; i < H; i++) {\n                String rowStr = sc.next();\n                for (int j = 0; j < W; j++) {\n                    int point;\n                    switch (Character.toString(rowStr.charAt(j))) {\n                        case \".\":\n                            point = 1;\n                            break;\n                        case \"#\":\n                            point = 0;\n                            break;\n                        case \"@\":\n                            point = 2;\n                            start[0] = i;\n                            start[1] = j;\n                            break;\n                        default:\n                            throw new NoSuchElementException();\n                    }\n                    m[i][j] = point;\n                }\n            }\n            spreadFrom(start[0], start[1]);\n            System.out.println(c);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint[][] land,looked;\n\tint sx,sy,w,h,count;\n\tint[] dx={-1,1,0,0},dy={0,0,-1,1};\n\t\n\tScanner stdin =new Scanner(System.in);\n\tQueue qx=new LinkedList();Queue qy=new LinkedList();\n\t\n\t\n\tvoid Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tw=stdin.nextInt();\n\t\t\th=stdin.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tland=new int[h][w];\n\t\t\tlooked=new int[h][w];\n\t\t\tcount=1;\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s=stdin.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s.charAt(j)=='.') land[i][j]=1;\n\t\t\t\t\telse if(s.charAt(j)=='@'){\n\t\t\t\t\t\tland[i][j]=0;\n\t\t\t\t\t\tsx=i;\n\t\t\t\t\t\tsy=j;\n\t\t\t\t\t}else land[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlooked=land.clone();\n\t\t\t//System.out.println(land[5][8]);\n\t\t\tbfs(sx,sy);\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tvoid bfs(int sx,int sy){\n\t\t//System.out.println(sx+\" \"+sy);\n\t\tlooked[sx][sy]=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx=sx+dx[i];\n\t\t\tint yy=sy+dy[i];\n\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w){\n\t\t\t\tif(land[xx][yy]==1){\n\t\t\t\t\tif(looked[xx][yy]==1)count++;\n\t\t\t\t\tbfs(xx,yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int w, h, c;\n    static int[][] map;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if (w == 0 && h == 0) {\n                break;\n            }\n            map = new int[h][w];\n\n            int sx = 0;\n            int sy = 0;\n\n            for (int i = 0; i < h; i++) {\n                String line = sc.next();\n                for (int j = 0; j < w; j++) {\n                    char c = line.charAt(j);\n                    if (c == '#') {\n                        map[i][j] = 1;\n                    } else if (c == '.') {\n                        map[i][j] = 0;\n                    } else {\n                        sx = j;\n                        sy = i;\n                        map[i][j] = 0;\n                    }\n                }\n            }\n            // printArray(map);\n            c = 0;\n            check(sy, sx);\n            System.out.println(c);\n        }\n    }\n\n    public static void check(int y, int x) {\n        if (y < 0 || x < 0 || y >= h || x >= w) {\n            return;\n        }\n        if (map[y][x] == 1) {\n            return;\n        }\n        map[y][x] = 1;\n        c++;\n        check(y + 1, x);\n        check(y - 1, x);\n        check(y, x + 1);\n        check(y, x - 1);\n    }\n\n    public static void printArray(int[][] a) {\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[0].length; j++) {\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Main{\n\tstatic int answer;\n\tstatic char tiles[][];\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String args[]){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tString str = new String();\n\n\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile(true){\n\t\t\t\tstr = br.readLine();\n\t\t\t\tString strs[] = str.split(\" \");\n\t\t\t\tw = Integer.parseInt(strs[0]);\n\t\t\t\th = Integer.parseInt(strs[1]);\n\n\t\t\t\tif(w == 0) break;\n\t\t\t\tanswer = 0;\n\t\t\t\ttiles = new char[h][w];\n\n\t\t\t\tint x = 0, y = 0;\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\tSystem.out.println(\"readLine \" + i);\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\ttiles[i][j] = str.charAt(j);\n\t\t\t\t\t\tif(tiles[i][j] == '@'){\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdf(x, y);\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tstatic void df(int x, int y){\n\t\t//System.out.println(\"位置: (\" + x + \",\" + y + \")\");\n\t\ttiles[y][x] = '#';\n\t\tanswer++;\n\n\t\t// 上\n\t\tif(y > 0 && tiles[y-1][x] != '#')\n\t\t\tdf(x, y-1);\n\n\t\t// 右\n\t\tif(x < w-1 && tiles[y][x+1] != '#')\n\t\t\tdf(x+1, y);\n\n\t\t// 下\n\t\tif(y < h-1 && tiles[y+1][x] != '#')\n\t\t\tdf(x, y+1);\n\n\t\t// 左\n\t\tif(x > 0 && tiles[y][x-1] != '#')\n\t\t\tdf(x-1, y);\n\n\t}\n\n\n\tstatic void printArray(ArrayList<Integer[]> array){\n\t\tSystem.out.println(\"PrintArray \" + array.size());\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tInteger set[] = array.get(i);\n\t\t\tSystem.out.print(\"(\" + set[0] + \", \" + set[1] + \")\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(char matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class p1130 {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint w = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tint h = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tif(w == 0 && h == 0){\n\t\t\t\t\treturn;\n\t\t\t\t} \n\t\t\t\tint[][] field = new int[h][w];\n\t\t\t\tint[] pos = new int[2]; \n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tString str = br.readLine();\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(str.charAt(j)=='.'){\n\t\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\t} else if(str.charAt(j)=='#'){\n\t\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t\t\tpos[0] = i;\n\t\t\t\t\t\t\tpos[1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing */\n\t\t\t\tint res = search(pos[0],pos[1],field,h,w);\n\t\t\t\t\n\t\t\t\t/* output */\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static int search(int posi, int posj, int[][] field,int h,int w){\n\t\tint sum = 1;\n\t\tfield[posi][posj] = 2;\n\t\t\n\t\t//up\n\t\tif(posi>0&&field[posi-1][posj]==1){\n\t\t\tsum += search(posi-1,posj,field,h,w);\n\t\t}\n\t\t//right\n\t\tif(posj<w-1&&field[posi][posj+1]==1){\n\t\t\tsum += search(posi,posj+1,field,h,w);\n\t\t}\n\t\t\n\t\t//down\n\t\tif(posi<h-1&&field[posi+1][posj]==1){\n\t\t\tsum += search(posi+1,posj,field,h,w);\n\t\t}\n\t\t\n\t\t//left\n\t\tif(posj>0&&field[posi][posj-1]==1){\t\t\t\n\t\t\tsum += search(posi,posj-1,field,h,w);\n\t\t}\n\n\t\treturn sum;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]){\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n            sc.close();\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tstatic int a,b;\n\tstatic int ans=0;\n\tstatic int[][] takeshi;\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tb=s.nextInt();\n\t\t\ta=s.nextInt();\n\t\t\tif(a==0)System.exit(0);\n\t\t\ttakeshi=new int[a][b];\n\t\t\tString now;\n\t\t\tint p=0,q=0;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tnow=s.next();\n\t\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\t\tif(now.charAt(j)=='#')takeshi[i][j]=0;\n\t\t\t\t\telse if(now.charAt(j)=='.')takeshi[i][j]=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\ttakeshi[i][j]=0;\n\t\t\t\t\t\tp=i;\n\t\t\t\t\t\tq=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(solve(p,q));\n\t\t}\n\t}\n\tstatic int solve(int m,int n){\n\t\tint ret=0;\n\t\t\n\t\ttakeshi[m][n]=0;\n\t\t\n\t\tif(m>0)\n\t\t\tif(takeshi[m-1][n]==1)ret+=solve(m-1,n);\n\t\tif(m<a-1)\n\t\t\tif(takeshi[m+1][n]==1)ret+=solve(m+1,n);\n\t\tif(n>0)\n\t\t\tif(takeshi[m][n-1]==1)ret+=solve(m,n-1);\n\t\tif(n<b-1)\n\t\t\tif(takeshi[m][n+1]==1)ret+=solve(m,n+1);\n\t\t\n\t\t\n\t\treturn ret+1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[500];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 500; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 500; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in);\n      int N = sc.nextInt();\n      int M = sc.nextInt(); sc.nextLine(); //nextIntの後残る改行文字を消す\n      int count=0;\n      String[] line = new String[M];\n      for(int i=0;i<M;i++){\n      \tline[i]=sc.nextLine();\n      } \n      String[][] a = new String[N][M];\n      for(int j=0;j<M;j++){\n       for(int k=0;k<N;k++){\n        a[k][j]=String.valueOf(line[j].charAt(k));\n       }\n      }\n      for(int t=0;t<60;t++){\n       for(int p=0;p<M;p++){\n        for(int q=0;q<N;q++){\n         if((a[q][p].equals(\"@\"))&&(a[Math.max(0,q-1)][p].equals(\".\"))){\n         \ta[Math.max(0,q-1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.max(0,p-1)].equals(\".\"))){\n         \ta[q][Math.max(0,p-1)]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[Math.min(N-1,q+1)][p].equals(\".\"))){\n         \ta[Math.min(N-1,q+1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.min(M-1,p+1)].equals(\".\"))){\n         \ta[q][Math.min(M-1,p+1)]=\"@\";\n         }\n        }\n       }\n      }\n      for(int r=0;r<M;r++){\n       for(int s=0;s<N;s++){\n         if(a[s][r].equals(\"@\")){\n         \tcount++;\n         }\n       }\n      }\n     System.out.println(count);\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans = 0;\n\tint x, y;\n\n\tvoid calc () {\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tsc.close();\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\nsc.close();\nreturn;\n}\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tDeque<int[]> quque = new ArrayDeque<int[]>();\n\t\t\n\t\twhile(true) {\n\t\t\tString str = br.readLine();\n\t\t\tint sPos = str.indexOf(\" \");\n\t\t\tint w = Integer.parseInt(str.substring(0, sPos));\n\t\t\tint h = Integer.parseInt(str.substring(sPos+1));\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint[] personXY = new int[2];\n\t\t\tfor(int y = 0; y < h; y++) {\n\t\t\t\tstr = br.readLine();\n\t\t\t\t\n\t\t\t\tfor(int x = 0; x < w; x++) {\n\t\t\t\t\tchar c = str.charAt(x);\n\t\t\t\t\tif(c == '@') {\n\t\t\t\t\t\tpersonXY[0] = x;\n\t\t\t\t\t\tpersonXY[1] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[y][x] = c == '.' ? 0\n\t\t\t\t\t\t          : c == '#' ? 1 : 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(Arrays.deepToString(map));\n\t\t\t\n\t\t\tquque.addLast(personXY);\n\t\t\t\n\t\t\tint movable = 0;\n\t\t\t\n\t\t\twhile(!quque.isEmpty()) {\n\t\t\t\tint[] xy = quque.pollFirst();\n\t\t\t\tint x = xy[0];\n\t\t\t\tint y = xy[1];\n\t\t\t\t\n\t\t\t\tif(map[y][x] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tmap[y][x] = 1;\n\t\t\t\tmovable++;\n\t\t\t\tif(0 < x && map[y][x-1] == 0) {\n\t\t\t\t\tquque.addLast(new int[]{x-1, y});\n\t\t\t\t}\n\t\t\t\tif(x+1 < map[y].length && map[y][x+1] == 0) {\n\t\t\t\t\tquque.addLast(new int[]{x+1, y});\n\t\t\t\t}\n\t\t\t\tif(0 < y && map[y-1][x] == 0) {\n\t\t\t\t\tquque.addLast(new int[]{x, y-1});\n\t\t\t\t}\n\t\t\t\tif(y+1 < map.length && map[y+1][x] == 0) {\n\t\t\t\t\tquque.addLast(new int[]{x, y+1});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(movable);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n  static Scanner sc = new Scanner(System.in);\n  static int ans;\n  static char[][] map;\n  static int width, height;\n\n  public static void main(String [] args){\n    while(true){\n      ans = 0;\n      width = sc.nextInt();\n      height = sc.nextInt();\n      if(width == 0 && height ==0) break;\n      int x = 0, y = 0;\n      map = new char[height][width];\n      char[] line = new char[width];\n      for(int i = 0; i < height; i++){\n        line = sc.next().toCharArray();\n        for(int j = 0; j < width; j++){\n          map[i][j] = line[j];\n          if(line[j] == '@'){\n            x = j;\n            y = i;\n          }\n        }\n      }\n      dfs(x, y);\n      System.out.println(ans);\n    }\n  }\nstatic void dfs(int x, int y){\n    ans++;\n    int next_x, next_y;\n    int[] dx = {0, -1 ,0 ,1}, dy = {1, 0, -1, 0};\n    for(int i = 0; i < dx.length; i++){\n      next_x = x + dx[i];\n      next_y = y + dy[i];\n      if(next_x < 0 || next_x >= width || next_y < 0 || next_y >= height) continue;\n      else if(map[next_y][next_x] != '.') continue;\n      map[next_y][next_x] = 'a';\n      dfs(next_x, next_y);\n    }\n    return ;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tchar[][] map;\n\tint count = 0;\n\tint w;\n\tint h;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\t//boolean fl = false;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tmap[i][j] = '#';\n\t\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\t\tsearchTile(i-1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tsearchTile(i+1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tsearchTile(i,j-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tsearchTile(i,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//fl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(fl){\n\t\t\t\t//\tbreak;\n\t\t\t\t//}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic void searchTile(int y,int x){\n\t\tif(map[y][x] == '#'){\n\t\t\treturn;\n\t\t}\n\t\tcount++;\n\t\tmap[y][x] = '#';\n\t\tif(y != 0){\n\t\t\tsearchTile(y-1,x);\n\t\t}\n\t\tif(y != h-1){\n\t\t\tsearchTile(y+1,x);\n\t\t}\n\t\tif(x != 0){\n\t\t\tsearchTile(y,x-1);\n\t\t}\n\t\tif(x != w-1){\n\t\t\tsearchTile(y,x+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                sc.close();\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Red and Black\npublic class Main{\n\n\tstatic int c, h, w;\n\tstatic int[][] move = {{1,0},{-1,0},{0,1},{0,-1}};\n\tstatic char[][] m;\n\t\n\tstatic void dfs(int i, int j){\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i + move[k][0];\n\t\t\tint nj = j + move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'){\n\t\t\t\tm[ni][nj] = '#';\n\t\t\t\tc++;\n\t\t\t\tdfs(ni,nj);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][w];\n\t\t\tint si = 0;\n\t\t\tint sj = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tm[i][j] = s[j];\n\t\t\t\t\tif(s[j]=='@'){\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = 1;\n\t\t\tm[si][sj] = '#';\n\t\t\tdfs(si,sj);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main \n{\n\tstatic class Spot\n\t{\n\t\tint x;\n\t\tint y;\n\t\t\n\t\tpublic Spot(int x, int y)\n\t\t{\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true)\n\t\t{\n\t\t\tint w = sc.nextInt();\n\t\t\tif(w == 0)break;\n\t\t\tint h = sc.nextInt();\n\t\t\tboolean[][] grid = new boolean[w][h];\n\t\t\t\n\t\t\tint startx = -1;\n\t\t\tint starty = -1;\n\t\t\t\n\t\t\tfor(int y = 0; y < h; y++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int x = 0; x < w; x++)\n\t\t\t\t{\n\t\t\t\t\tgrid[x][y] = (s.charAt(x) == '.' || s.charAt(x) == '@');\n\t\t\t\t\tif(!grid[x][y])\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"WALL \" + x + \" \" +y);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(s.charAt(x) == '@')\n\t\t\t\t\t{\n\t\t\t\t\t\tstartx = x;\n\t\t\t\t\t\tstarty = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tStack<Spot> queue = new Stack<Spot>();\n\t\t\t\n\t\t\tqueue.add(new Spot(startx, starty));\n\t\t\t\n\t\t\twhile(!queue.isEmpty())\n\t\t\t{\n\t\t\t\tSpot spot = queue.pop();\n\t\t\t\tint x = spot.x;\n\t\t\t\tint y = spot.y;\n\t\t\t\tif(grid[x][y])\n\t\t\t\t{\n\t\t\t\t\tgrid[x][y] = false;\n\t\t\t\t\tcount++;\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(\"Add \" + x + \" \" + y);\n\t\t\t\t\t\n\t\t\t\t\tif(x > 0 && grid[x-1][y])queue.add(new Spot(x-1, y));\n\t\t\t\t\tif(y > 0 && grid[x][y-1])queue.add(new Spot(x, y-1));\n\t\t\t\t\tif(x < w-1 && grid[x+1][y])queue.add(new Spot(x+1, y));\n\t\t\t\t\tif(y < h-1 && grid[x][y+1])queue.add(new Spot(x, y+1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"False: \" + x + \" \" + y);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ1130();\n\t}\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\t\n\tvoid AOJ1130(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(),sx=0,sy=0,ans=0;\n\t\t\tif(X==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line[x];\n\t\t\t\t\tif(line[x]=='@'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<C1130> open=new LinkedList<C1130>();\n\t\t\topen.add(new C1130(sx,sy));\n\t\t\tboolean[][] close=new boolean[X][Y];\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tans++;\n\t\t\t\tC1130 now=open.poll();\n\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]=='.' && !close[now.x+vx[i]][now.y+vy[i]]){\n\t\t\t\t\t\topen.add(new C1130(now.x+vx[i], now.y+vy[i]));\n\t\t\t\t\t\tclose[now.x+vx[i]][now.y+vy[i]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C1130{\n\t\tint x,y;\n\t\tC1130(int x,int y){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t}\n\t}\n\t\n\t// TLE MLE WA\n\tvoid AOJ0223(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(),\tY=sc.nextInt();\n\t\t\tif(X==0)\tbreak;\n\t\t\tint tx=sc.nextInt(), ty=sc.nextInt(), kx=sc.nextInt(), ky=sc.nextInt();\n\t\t\tint[][] b=new int[X+1][Y+1];\n\t\t\tfor(int y=1; y<=Y; y++){\n\t\t\t\tfor(int x=1; x<=X; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<C0223> open=new LinkedList<C0223>();\n\t\t\topen.add(new C0223(tx,ty,kx,ky,0));\n\t\t\tint[][][][] close2=new int[X+1][Y+1][X+1][Y+1];\n\t\t\tclose2[tx][ty][kx][ky]=-1;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC0223 now=open.poll();\n\t\t\t\tif(now.ans()){\n\t\t\t\t\tans=now.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.sec>=99)\tbreak;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(0<now.tx+vx[i]&&now.tx+vx[i]<=X && 0<now.ty+vy[i]&&now.ty+vy[i]<=Y && 0<now.kx-vx[i]&&now.kx-vx[i]<=X && 0<now.ky-vy[i]&&now.ky-vy[i]<=Y){\n\t\t\t\t\t\ttx=now.tx;\tty=now.ty;\tkx=now.kx;\tky=now.ky;\n\t\t\t\t\t\tif(b[tx+vx[i]][ty+vy[i]]==0){\n\t\t\t\t\t\t\ttx+=vx[i];\tty+=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[kx-vx[i]][ky-vy[i]]==0){\n\t\t\t\t\t\t\tkx-=vx[i];\tky-=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"TEMP:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t//if(tx==kx && ty==ky)\tans=ans<0?now.sec+1:min(ans,now.sec+1);\n\t\t\t\t\t\tif(close2[tx][ty][kx][ky]==0 || close2[tx][ty][kx][ky]>now.sec+1){\n\t\t\t\t\t\t\t//out.println(\"ADD:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t\topen.add(new C0223(tx,ty,kx,ky,now.sec+1));\n\t\t\t\t\t\t\tclose2[tx][ty][kx][ky]=now.sec+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tclass C0223{\n\t\tint tx,ty,kx,ky,sec;\n\t\tC0223(int tx, int ty, int kx, int ky, int sec){\n\t\t\tthis.tx=tx;\tthis.ty=ty;\tthis.kx=kx;\tthis.ky=ky;\tthis.sec=sec;\n\t\t}\n\t\tboolean ans(){\n\t\t\tif(this.tx==this.kx && this.ty==this.ky)\treturn true;\n\t\t\telse\treturn false;\n\t\t}\n\t}\n\t\n\t\n\t// WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\t\n\t// WA\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[w+2][h+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t\tint[] vx={1,0,-1,0}, vy={0,1,0,-1};\n\t\t\tint xx=sx, yy=sy, cc=b[sx][sy], v=0, count=0, max=w*h;\n\t\t\tif(cc<1){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif(xx==gx && yy==gy && b[xx][yy]==cc){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tif(count>=max){\n\t\t\t\t\tout.println(\"NG\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//b[xx][yy]=6;\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tout.println(\"X\"+xx+\" Y\"+yy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\txx-=vx[v];\tyy-=vy[v];\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\tout.println(\"END : X\"+xx+\" Y\"+yy);\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//debug\n\t\t\tde0207(b,w,h);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t\tArrayList<Integer> prime = new ArrayList<Integer>();\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[1]=false;\n\t\tfor (int i=2; i<=N; i++) {\n\t\t\tif(list[i]) {\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)\tlist[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[1]=false;\n\t\tfor(int i=2; i<=N; i++) {\n\t\t\tif(list[i]) {\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)     list[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0)     return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);char[][]a;for(int w,h,x,y,i,j;(w=s.nextInt()+2)>2;System.out.println(f(a,x,y))){a=new char[h=s.nextInt()+2][w];for(i=x=y=1;i<h-1;++i){j=0;for(char c:s.next().toCharArray()){a[i][++j]=c=='#'?0:c;if(a[i][j]>63){x=i;y=j;}}}}}static int f(char[][]a,int x,int y){if(a[x][y]<1)return 0;a[x][y]=0;return f(a,x-1,y)+f(a,x+1,y)+f(a,x,y-1)+f(a,x,y+1)+1;}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w+h==0) break;\n\t\t\tint[][] tile = new int[h+2][w+2];\n\t\t\tint start_x = 0, start_y = 0;\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tString temp = sc.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tif(temp.charAt(j-1)=='.'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t}else if(temp.charAt(j-1)=='@'){\n\t\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\t\tstart_x = j;\n\t\t\t\t\t\tstart_y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = Main.Count_tile(tile, start_x, start_y);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic final int[] dx = {1, 0, -1, 0};\n\tstatic final  int[] dy = {0, 1, 0, -1};\n\n\tstatic int Count_tile(int[][] tile, int x, int y){\n\t\tint sum = 1;\n\t\ttile[y][x] = 0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(tile[y+dy[i]][x+dx[i]]==1){\n\t\t\t\tsum += Main.Count_tile(tile, x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Pos{\n\t\tint x, y;\n\n\t\tpublic Pos(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] is_visited = new boolean[H][W];\n\t\t\tboolean[][] is_wall = new boolean[H][W];\n\t\t\t\n\t\t\tint s_x = -1, s_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tis_visited[i][j] = false;\n\t\t\t\t\tis_wall[i][j] = ch[j] == '#';\n\t\t\t\t\t\n\t\t\t\t\tif(ch[j] == '@'){\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Pos> queue = new LinkedList<Pos>();\n\t\t\t\n\t\t\tqueue.add(new Pos(s_x, s_y));\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tPos pos = queue.poll();\n\t\t\t\t\n\t\t\t\tif(is_visited[pos.y][pos.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tis_visited[pos.y][pos.x] = true;\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tif(pos.x != 0 && !is_wall[pos.y][pos.x - 1] && !is_visited[pos.y][pos.x - 1]){\n\t\t\t\t\tqueue.add(new Pos(pos.x - 1, pos.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.x != W-1 && !is_wall[pos.y][pos.x + 1] && !is_visited[pos.y][pos.x + 1]){\n\t\t\t\t\tqueue.add(new Pos(pos.x + 1, pos.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.y != 0 && !is_wall[pos.y - 1][pos.x] && !is_visited[pos.y - 1][pos.x]){\n\t\t\t\t\tqueue.add(new Pos(pos.x, pos.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.y != H-1 && !is_wall[pos.y + 1][pos.x] && !is_visited[pos.y + 1][pos.x]){\n\t\t\t\t\tqueue.add(new Pos(pos.x, pos.y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class Main {\n\n  int H,W;\n  int sy,sx;\n  int cnt;\n  boolean[][] map;\n  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; \n  public static void main(String[] args) {\n    new Main().run();\n  }\n  public void run() {\n\n    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out) ) {\n\n      String[] lines;\n      // StringBuilder buf = new StringBuilder();\n      while(true) {\n        lines = in.readLine().split(\" \");\n        W = Integer.parseInt(lines[0]);\n        H = Integer.parseInt(lines[1]);\n\n        if( W==0 && H==0) break;\n\n        map = new boolean[H][W];\n\n        String line;\n        for(int y=0; y<H; y++) {\n          char ch;\n          line = in.readLine();\n          for(int x=0; x<W; x++) {\n            ch = line.charAt(x);\n            map[y][x] = ch == '#' ? false : true;\n            if(ch == '@') {\n              sy = y; sx = x;\n            }\n          }\n        }\n\n        cnt = 0;\n        dfs(sy,sx);\n        // buf.append(cnt).append(\"\\n\");\n        out.println(cnt);\n      }\n\n      // System.out.print(buf);\n      out.flush();\n    }\n    catch(IOException e) {\n      System.err.println(e);\n    }\n  }\n\n  private void dfs(int y, int x) {\n    map[y][x] = false;\n    cnt++;\n\n    for(int i=0; i<4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {\n        dfs(ny,nx);\n      }\n    }\n    return;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0 || h==0) break;\n\t\t\t\n\t\t\ttile = new int[w][h];\n\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int x, int y) {\n\n\t\tint m = 0;\n\t\ttile[x][y] = 0;\n\n\t\tif(x>0)if(tile[x-1][y]==1)m+=canMove(x-1,y);\n\t\tif(x<w-1)if(tile[x+1][y]==1)m+=canMove(x+1,y);\n\t\tif(y>0)if(tile[x][y-1]==1)m+=canMove(x,y-1);\n\t\tif(y<h-1)if(tile[x][y+1]==1)m+=canMove(x,y+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\tvoid run(){\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = s.nextInt();\n\t\t\tint h = s.nextInt();\n\t\t\tif(w == 0 && h == w)break;\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tString tile[][] = new String[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\ttile[i] = s.next().split(\"\");\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(tile[i][j].charAt(0) == '@'){\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint chkP[][] = new int[h][w];\n\t\t\tint cnt = cntTile(tile,chkP,'.',x,y);\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\t\n\tint cntTile(String[][] panel,int[][] chkP,char tile,int x,int y){\n\t\tchkP[x][y] = -1; \n\t\tint cnt = 0;\n\t\tif(x + 1 < panel.length    && chkP[x + 1][y] != -1 && panel[x + 1][y].charAt(0) == tile)cnt += cntTile(panel,chkP,tile,x + 1,y);\n\t\tif(x     > 0               && chkP[x - 1][y] != -1 && panel[x - 1][y].charAt(0) == tile)cnt += cntTile(panel,chkP,tile,x - 1,y);\n\t\tif(y + 1 < panel[x].length && chkP[x][y + 1] != -1 && panel[x][y + 1].charAt(0) == tile)cnt += cntTile(panel,chkP,tile,x,y + 1);\n\t\tif(y     > 0               && chkP[x][y - 1] != -1 && panel[x][y - 1].charAt(0) == tile)cnt += cntTile(panel,chkP,tile,x,y - 1);\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (c[j] == '@') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t} else if (c[j] == '#')\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(sy, sx));\n\n\t\t}\n\t}\n\n\tprivate int dfs(int y, int x) {\n\t\tint ans = 0;\n\t\tif (!isOK(y, x) || map[y][x])\n\t\t\treturn ans;\n\n\t\tmap[y][x] = true;\n\t\tans++;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tans += dfs(ny, nx);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint w, h, sy, sx;\n\tboolean[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class RedandBlack {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile = new char[22][22];\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            System.out.println(countBlackTile(x, y)/4);\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 0;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]) + 1;\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n                sc.close();\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint w = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tint h = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tif(w == 0 && h == 0){\n\t\t\t\t\treturn;\n\t\t\t\t} \n\t\t\t\tint[][] field = new int[h][w];\n\t\t\t\tint[] pos = new int[2]; \n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tString str = br.readLine();\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(str.charAt(j)=='.'){\n\t\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\t} else if(str.charAt(j)=='#'){\n\t\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t\t\tpos[0] = i;\n\t\t\t\t\t\t\tpos[1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tSystem.out.print(field[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t/* processing */\n\t\t\t\tint res = search(pos[0],pos[1],field,h,w);\n\t\t\t\t\n\t\t\t\tres = 0;\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(field[i][j]==2){\n\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* output */\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static int search(int posi, int posj, int[][] field,int h,int w){\n\t\tint sum = 1;\n\t\tfield[posi][posj] = 2;\n\t\t\n\t\t//up\n\t\tif(posi>0&&field[posi-1][posj]==1){\n\t\t\tsum = 1 + search(posi-1,posj,field,h,w);\n\t\t}\n\t\t//right\n\t\tif(posj<w-1&&field[posi][posj+1]==1){\n\t\t\tsum = 1 + search(posi,posj+1,field,h,w);\n\t\t}\n\t\t\n\t\t//down\n\t\tif(posi<h-1&&field[posi+1][posj]==1){\n\t\t\tsum = 1 + search(posi+1,posj,field,h,w);\n\t\t}\n\t\t\n\t\t//left\n\t\tif(posj>0&&field[posi][posj-1]==1){\t\t\t\n\t\t\tsum = 1 + search(posi,posj-1,field,h,w);\n\t\t}\n\n\t\treturn sum;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "package aoj;\n\nimport java.util.Scanner;\n\n/**\n * AOJ id=1130\n * Red and Black\n * @author scache\n *\n */\npublic class Main1130 {\n\tpublic static void main(String[] args) {\n\t\tMain1130 p = new Main1130();\n\t}\n\n\tpublic Main1130() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\tif(w==0) break;\n\t\t\th = sc.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tsolve(map);\n\t\t}\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map;\n\tpublic void solve(char[][] map) {\n\t\tint sx = -1;\n\t\tint sy = -1;\n\t\tfor(int i=0;i<map.length;i++){\n\t\t\tfor(int j=0;j<map[i].length;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sx>=0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(rec(sx, sy));\n\t\t\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tprivate int rec(int curx, int cury) {\n\t\tif(map[cury][curx]=='#')\n\t\t\treturn 0;\t\n\t\t\n\t\tmap[cury][curx] = '#';\n\t\tint res = 1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = curx + dx[i];\n\t\t\tint ny = cury + dy[i];\n\t\t\t\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\tcontinue;\n\t\t\tres += rec(nx, ny);\n\t\t}\n\t\t\n\t\t\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int w, h;\n    char[][] map;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt(); h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            map = new char[h][w];\n            int sx = 0, sy = 0;\n            for(int i=0; i<h; i++){\n                map[i] = sc.next().toCharArray();\n                for(int j=0; j<w; j++){\n                    if(map[i][j]=='@'){ sx = j; sy = i;}\n                }\n            }\n\n            System.out.println(bfs(sx, sy));\n        }\n    }\n\n    int[] dx = {1, -1, 0, 0};\n    int[] dy = {0, 0, 1, -1};\n\n    int bfs(int sx, int sy){\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{sx, sy});\n        boolean[][] v = new boolean[h][w];\n        int cnt = 0;\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int x = qq[0], y = qq[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n            cnt++;\n\n            for(int i=0; i<4; i++){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h || map[ny][nx]=='#') continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Point {\n\n\tfinal int y;\n\tfinal int x;\n\n\tPoint( final int y, final int x ) {\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t}\t\n}\n\nclass Main {\n\n    public static void main( final String[] args ) throws IOException {\n\n\t\tfinal BufferedReader br = new BufferedReader( new InputStreamReader(System.in ) );\n\n\t\twhile ( true ) {\n\n\t\t\tfinal int[] hw = parse( br.readLine().split( \" \" ) );\n\t\t\tfinal int width = hw[ 0 ];\n\t\t\tfinal int height = hw[ 1 ];\n\t\t\tif ( height == 0 && width == 0 ) break;\n\t\t\tfinal char[][] map = new char[ height ][];\n\t\t\tfor ( int i = 0; i < height; i++ ) {\n\t\t\t\tmap[ i ] = br.readLine().toCharArray();\n\t\t\t}\n\t\t\tsolve( map );\n\t\t}\t\n    }\n\n\tstatic void solve( final char[][] map ) {\n\t\tfinal Point start = findStart( map );\n\t\tSystem.out.println( dfs( map, start.y, start.x ) );\n\t}\n\n\tstatic final int[] dx = { -1, 0, 1, 0 };\n\tstatic final int[] dy = { 0, 1, 0, -1 };\n\t\n\tstatic int dfs( final char[][] map, final int y, final int x ) {\n\t\tint count = 1;\n\t\tmap[ y ][ x ] = 'o';\n\t\t\n\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\tfinal int nx = x + dx[ i ];\n\t\t\tfinal int ny = y + dy[ i ];\n\t\t\tif ( 0 <= ny && ny < map.length &&\n\t\t\t\t 0 <= nx && nx < map[ ny ].length &&\n\t\t\t\t map[ ny ][ nx ] == '.' ) {\n\n\t\t\t\tcount += dfs( map, ny, nx );\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tstatic Point findStart( final char[][] map ) {\n\t\tfor ( int y = 0; y < map.length; y++ ) {\n\t\t\tfor ( int x = 0; x < map[ y ].length; x++ ) {\n\t\t\t\tif ( map[ y ][ x ] == '@' ) {\n\t\t\t\t\treturn new Point( y, x );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int[] parse( String[] sinput ) {\n\t\tfinal int[] input = new int[ sinput.length ];\n\t\tfor ( int i = 0; i < input.length; i++ ) {\n\t\t\tinput[ i ] = Integer.parseInt( sinput[ i ].trim() );\n\t\t}\n\t\treturn input;\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Field{\n\tStringBuilder map;\n\tint width;\n\tint height;\n\t\n\tField(int w,int h, String[] buf) throws IOException{\n\t\twidth = w;\n\t\theight= h;\n\t\tmap= new StringBuilder();\n\t\tStringBuilder edge= new StringBuilder();\n\t\tfor(int i=0;i<w+2;i++){\n\t\t\tedge.append(\"#\");\n\t\t}\n\t\tmap.append(edge);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tmap.append(\"#\");\n\t\t\tmap.append(buf[i]);\n\t\t\tmap.append(\"#\");\n\t\t}\n\t\tmap.append(edge);\n\t\t\n\t\tSystem.out.println(map.length());\n\t}\n\t\n\tint point2int(int x, int y){\n\t\treturn (width+2)*y + x;\n\t}\n\tint int2x(int n){\n\t\treturn n%(width+2);\n\t}\n\tint int2y(int n){\n\t\treturn n/(width+2);\n\t}\n\t\n\tint[] neighbor(int x, int y){\n\t\tint[] neib= {point2int(x,y-1),point2int(x-1,y),point2int(x+1,y),point2int(x,y+1)};\n\t\treturn neib;\n\t}\n\tint[] neighbor(int n){\n\t\tint x= int2x(n); int y= int2y(n);\n\t\tint[] neib= {point2int(x,y-1),point2int(x-1,y),point2int(x+1,y),point2int(x,y+1)};\n\t\treturn neib;\n\t}\n\n\tchar charAt(int x, int y){\n\t\treturn map.charAt(point2int(x,y));\n\t}\n\tchar charAt(int n){\n\t\tint x= int2x(n); int y= int2y(n);\n\t\treturn map.charAt(point2int(x,y));\n\t}\n\t\n\tint countRange(){\n\t\tint cnt=0;\n\t\tfor(int i=0;i<map.length();i++){\n\t\t\tif( map.charAt(i)=='@' ){ cnt++; }\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid traverse(){\n\t\tDeque<Integer> dfs= new LinkedList<Integer>();\n\t\tdfs.push(map.indexOf(\"@\"));\n\t\twhile( !dfs.isEmpty() ){\n\t\t\tint tmp  = dfs.peek();\n\t\t\tboolean reached= true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint next= neighbor(tmp)[i];\n\t\t\t\tif( charAt(next)=='.' ){\n\t\t\t\t\tmap.setCharAt(next, '@');\n\t\t\t\t\tdfs.push(next);\n\t\t\t\t\treached= false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(reached){ dfs.pop(); }\n\t\t}\n\t\t\n\t\tSystem.out.println(map);\n\t\tSystem.out.println(countRange());\n\t}\n}\n\npublic class Main{\n    public static void main(String args[]) throws Exception{\n    \tBufferedReader br= new BufferedReader(new InputStreamReader(System.in));\n    \tint width,height;\n    \twhile(true){\n    \t\tString[] buf= br.readLine().split(\" \");\n    \t\twidth = Integer.parseInt(buf[0]);\n    \t\theight= Integer.parseInt(buf[1]);\n    \t\tif( width!=0 || height!=0 ){\n    \t\t\tString[] buf_map= new String[height];\n    \t\t\tfor(int i=0;i<height;i++){\n    \t\t\t\tbuf_map[i]= br.readLine();\n    \t\t\t}\n    \t\t\tField f= new Field(width,height,buf_map); \n    \t\t\tf.traverse();\n    \t\t} else{ break; }\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans = 0;\n\tint x, y;\n\n\tvoid calc () {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans = 0;\n\tint x, y;\n\n\tvoid calc () {\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (in.hasNext()) {\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif (w != 0 && h != 0) {\n\t\t\t\tchar[][] tile = new char[h + 2][];\n\t\t\t\tint fx = -1;\n\t\t\t\tint fy = -1;\n\t\t\t\ttile[0] = new char[w + 2];\n\t\t\t\tArrays.fill(tile[0], '#');\n\t\t\t\tfor (int y = 0; y < h; y++) {\n\t\t\t\t\tsb.setLength(0);\n\t\t\t\t\tsb.append('#').append(in.next()).append('#');\n\t\t\t\t\tString line = sb.toString();\n\t\t\t\t\ttile[y + 1] = line.toCharArray();\n\t\t\t\t\tif (line.contains(\"@\")) {\n\t\t\t\t\t\tfy = y + 1;\n\t\t\t\t\t\tfx = line.indexOf('@');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttile[h + 1] = new char[w + 2];\n\t\t\t\tArrays.fill(tile[h + 1], '#');\n\t\t\t\ttile[fy][fx] = '.';\n\t\t\t\tfill(fx, fy, tile);\n\t\t\t\tint count = 0;\n\t\t\t\tfor (char[] l : tile) {\n\t\t\t\t\tfor (char c : l) {\n\t\t\t\t\t\tif (c == '@') count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(count);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void fill(int fx, int fy, char[][] tile) {\n\t\tif (tile[fy][fx] == '.') {\n\t\t\ttile[fy][fx] = '@';\n\t\t\tfill(fx + 1, fy, tile);\n\t\t\tfill(fx - 1, fy, tile);\n\t\t\tfill(fx, fy + 1, tile);\n\t\t\tfill(fx, fy - 1, tile);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static int[] moveX = {0,0,-1,1};\n\tpublic static int[] moveY = {-1,1,0,0};\n\tpublic static char[][] map;\n\tpublic static boolean[][] check;\n\t\n\tpublic static void dfs (int y, int x) {\n\t\t\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\t\n\t\t\tif (0 <= nextX && nextX < map[0].length && \n\t\t\t\t0 <= nextY && nextY < map.length && \n\t\t\t\tmap[nextY][nextX] == '.' && \n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\t\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main (String[] args) {\n\t\t\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\t\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\t\n\t\t\tif (x == 0 && y == 0) break;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tint startX = 0, startY = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\t\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdfs(startY,startX);\n\t\t\t\n\t\t\tfor (boolean[] ch : check) {\n\t\t\t\tfor (boolean c : ch)\n\t\t\t\t\tif (c) ans++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "class Main{\n    \n    \n    public static void main(String[] args){\n        \n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n   public static void main(String a[]) throws java.io.IOException{\n       Scanner scan =new Scanner (System.in);\n       Pair pair= new Pair();\n       Queue<Pair> fifo = new LinkedList<Pair>();\n\n       while(true){\n\n           int W =scan.nextInt();\n           int H =scan.nextInt();\n           if((W|H)==0)break;\n           char  [][] map = new char [H][W];\n           for(int i=0;i<H;i++){\n               String  tmp =scan.next();\n               for(int j=0;j<W;j++){\n                   map[i][j] = tmp.charAt(j);\n                   if(tmp.charAt(j)=='@'){\n                       \n                       pair.x=j;\n                       pair.y=i;\n                       fifo.add(pair);\n                   }\n               }\n           }\n          int count =0;\n          while(fifo.peek()!=null){  \n           pair = fifo.poll();\n           int x=pair.x;\n           int y=pair.y;\n           int[] dx ={0,1,0,-1};\n           int[] dy ={1,0,-1,0};\n          for(int i=0;i<4;i++){\n              int nx =x+dx[i];\n              int ny =y+dy[i];\n              if(0<=nx&&nx<W&&0<=ny&&ny<H&&map[ny][nx]!='#'){\n                  Pair npair =new Pair();\n                  npair.x=nx;\n                  npair.y=ny;\n                  fifo.add(npair);\n                  map[ny][nx] = '#';\n                  count++;\n              }\n          } \n          }\n          System.out.println(count);\n\n       \n       }\n}\n}\n\nclass Pair{\n    public int x;\n    public int y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\tint w,h;\n\tint[][] field;\n\tint sx,sy;\n\tScanner stdin=new Scanner(System.in);\n\tint[] dx={-1,0,1,0};\n\tint[] dy={0,-1,0,1};\n\tint count;\n\t\n\t\n\t\n\tpublic void Solve(){\n\t\tw=1;\n\t\twhile(true){\n\t\t\t\n\t\t\tcount=0;\n\t\t\tw=stdin.nextInt();\n\t\t\th=stdin.nextInt();\n\t\t\tif(w==0&&h==0)break;\n\t\t\tfield=new int [h][w];\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString str=stdin.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tchar c=str.charAt(j);\n\t\t\t\t\tif(c=='.') field[i][j]=1;\n\t\t\t\t\tif(c=='#') field[i][j]=0;\n\t\t\t\t\tif(c=='@'){\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\t\tsx=i;\n\t\t\t\t\t\tsy=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(sx+\"s\"+sy);\n\t\t\tdfs(sx,sy);\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tpublic void dfs(int x,int y){\n\t\tcount++;\n\t\tfield[x][y]=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx=x+dx[i];\n\t\t\tint yy=y+dy[i];\n\t\t\t\n\t\t\t\n\t\t\tif(xx>=0&&xx<h&&yy>=0&&yy<w){\n\t\t\t\tif(field[xx][yy]==1){\n\t\t\t\t\t//System.out.println(xx+ \" \"+yy);\n\t\t\t\t\tdfs(xx,yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\t\n\tstatic int count, H, W;\n\tstatic int[][] move = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n\tstatic char[][] r;\n\t\n\tstatic void dfs(int i, int j) {\n\t\tfor(int k=0; k<4; k++) {\n\t\t\tint ni = i + move[k][0];\n\t\t\tint nj = j + move[k][1];\n\t\t\tif(0<=ni && ni<H && 0<=nj && nj<W && r[ni][nj] != '#') {\n\t\t\t\tr[ni][nj] = '#';\n\t\t\t\tcount++;\n\t\t\t\tdfs(ni, nj);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tW = sc.nextInt();\n\t\t\t\tH = sc.nextInt();\n\t\t\t\tif(W+H == 0) break;\n\t\t\t\t\n\t\t\t\tr = new char[H][W];\n\t\t\t\tint si = 0;\n\t\t\t\tint sj = 0;\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<H; i++) {\n\t\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\t\t\tr[i][j] = s[j];\n\t\t\t\t\t\tif(s[j] == '@') {\n\t\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\t\tsj = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 1;\n\t\t\t\tr[si][sj] = '#';\n\t\t\t\tdfs(si, sj);\n\t\t\t\tSystem.out.println(count);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[200];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int r = 0;\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tr = 0;\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tString fs;\n\t\t\tint[][] fi = new int[h][w];\n\t\t\tint[][] l = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tl[i][j] = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfs = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (fs.charAt(j) == '.')\n\t\t\t\t\t\tfi[i][j] = 1;\n\t\t\t\t\tif (fs.charAt(j) == '#')\n\t\t\t\t\t\tfi[i][j] = 0;\n\t\t\t\t\tif (fs.charAt(j) == '@') {\n\t\t\t\t\t\tfi[i][j] = 1;\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tloop(x, y, fi, l);\n\t\t\tSystem.out.println(r);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tpublic static void loop(int x, int y, int[][] fi, int[][] l) {\n\t\tr++;\n\t\tl[x][y] = 1;\n\t\tif (x > 0)\n\t\t\tif (fi[x - 1][y] != 0 && l[x - 1][y] == 0)\n\t\t\t\tloop(x - 1, y, fi, l);\n\t\tif (x < h - 1)\n\t\t\tif (fi[x + 1][y] != 0 && l[x + 1][y] == 0)\n\t\t\t\tloop(x + 1, y, fi, l);\n\t\tif (y > 0)\n\t\t\tif (fi[x][y - 1] != 0 && l[x][y - 1] == 0)\n\t\t\t\tloop(x, y - 1, fi, l);\n\t\tif (y < w - 1)\n\t\t\tif (fi[x][y + 1] != 0 && l[x][y + 1] == 0)\n\t\t\t\tloop(x, y + 1, fi, l);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] v1 = { 0, 1, 0, -1 };\n\tstatic int[] v2 = { 1, 0, -1, 0 };\n\tstatic int[][] field;\n\tstatic int count = 0;\n\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = cin.nextInt();\n\t\t\tint h = cin.nextInt();\n\t\t\tif(w+h==0){break;}\n\t\t\t\n\t\t\tint startx = 0, starty = 0;\n\t\t\tcount=0;\n\t\t\tfield = new int[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tString str = cin.next();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (str.charAt(j-1) == '.') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t} else if (str.charAt(j-1) == '#') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (str.charAt(j-1) == '@') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tstartx = i;\n\t\t\t\t\t\tstarty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs(startx, starty);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic void bfs(int x, int y) {\n\t\tfield[x][y] = 2;\n\t\tcount++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint xx = x + v1[i];\n\t\t\tint yy = y + v2[i];\n\t\t\tif (field[xx][yy] == 1) {\n\t\t\t\t\n\n\t\t\t\tbfs(xx, yy);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w=sc.nextInt();\n\t\t\tint h=sc.nextInt();\n\t\t\tString gomi = sc.nextLine();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint start_w=0,start_h=0;\n\t\t\tfor(int i=0;i<h;++i){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString[] line2=line.split(\"\");\n\t\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\t\tif(line2[j].equals(\"#\")){\n\t\t\t\t\t\tmap[i][j]=-1;\n\t\t\t\t\t} else if(line2[j].equals(\"@\")){\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t\tstart_w=j; start_h=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] flag = new int[h][w];\n\t\t\tflag[start_h][start_w]=1;\n\t\t\tint count=1;\n\t\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\t\tqueue.add(new Node(start_h, start_w));\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode cur = queue.remove();\n\t\t\t\tif(cur.h!=0){\n\t\t\t\t\tif(map[cur.h-1][cur.w]==0 && flag[cur.h-1][cur.w]==0){\n\t\t\t\t\t\tcount++; flag[cur.h-1][cur.w]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h-1,cur.w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.h!=h-1){\n\t\t\t\t\tif(map[cur.h+1][cur.w]==0 && flag[cur.h+1][cur.w]==0){\n\t\t\t\t\t\tcount++; flag[cur.h+1][cur.w]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h+1,cur.w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.w!=0){\n\t\t\t\t\tif(map[cur.h][cur.w-1]==0 && flag[cur.h][cur.w-1]==0){\n\t\t\t\t\t\tcount++; flag[cur.h][cur.w-1]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h,cur.w-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.w!=w-1){\n\t\t\t\t\tif(map[cur.h][cur.w+1]==0 && flag[cur.h][cur.w+1]==0){\n\t\t\t\t\t\tcount++; flag[cur.h][cur.w+1]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h,cur.w+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\nclass Node{\n\tint h,w;\n\tNode(int w,int h){\n\t\tthis.h=w;\n\t\tthis.w=h;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.*;\n\npublic class Main {\n\tstatic class Data{\n\t\tint x,y;\n\t\tpublic Data(int xx, int yy){\n\t\t\tx = xx;\n\t\t\ty = yy;\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = in.nextInt();\n\t\t\tint h = in.nextInt();\n\t\t\tif((w|h)==0) break;\n\t\t\tboolean[][] field = new boolean[h][w];\n\t\t\tint[][] counter = new int[h][w];\n\t\t\tint sx=0,sy=0;\n\t\t\t\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tString str = in.next();\n\t\t\t\tchar[] ch = str.toCharArray();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tcounter[i][j] = 0;\n\t\t\t\t\tif(ch[j]=='#') field[i][j] = false;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t\t\tif(ch[j] == '@'){\n\t\t\t\t\t\t\tsx = i;\n\t\t\t\t\t\t\tsy = j;\n\t\t\t\t\t\t\tcounter[i][j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Data> queue = new LinkedList<Data>();\n\t\t\tqueue.add(new Data(sx,sy));\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tData now = queue.poll();\n\t\t\t\tif(now.x>0 && field[now.x-1][now.y] && counter[now.x-1][now.y]==0){\n\t\t\t\t\tcounter[now.x-1][now.y]=1;\n\t\t\t\t\tqueue.add(new Data(now.x-1,now.y));\n\t\t\t\t}\n\t\t\t\tif(now.y>0 && field[now.x][now.y-1] && counter[now.x][now.y-1]==0){\n\t\t\t\t\tcounter[now.x][now.y-1]=1;\n\t\t\t\t\tqueue.add(new Data(now.x,now.y-1));\n\t\t\t\t}\n\t\t\t\tif(now.x<h-1 && field[now.x+1][now.y] && counter[now.x+1][now.y]==0){\n\t\t\t\t\tcounter[now.x+1][now.y]=1;\n\t\t\t\t\tqueue.add(new Data(now.x+1,now.y));\n\t\t\t\t}\n\t\t\t\tif(now.y<w-1 && field[now.x][now.y+1] && counter[now.x][now.y+1]==0){\n\t\t\t\t\tcounter[now.x][now.y+1]=1;\n\t\t\t\t\tqueue.add(new Data(now.x,now.y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tans += counter[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\t\n\tpublic static boolean is_ok(int x, int y, int H, int W){\n\t\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] can_enter = new boolean[MAX][MAX];\n\t\tboolean[][] visited = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint s_x = -1, s_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\tcan_enter[i][j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcan_enter[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(input[j] == '@'){\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\t\tvisited[s_y][s_x] = true;\n\t\t\tx_queue.add(s_x);\n\t\t\ty_queue.add(s_y);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!x_queue.isEmpty()){\n\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(nx, ny, H, W)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(!can_enter[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main\n{\n    int dx[]={-1,0,1,0};\n    int dy[]={0,1,0,-1};\n    char[][] map;\n    void run()\n    {\n\tScanner sc=new Scanner(System.in);\n\twhile(true){\n\t    int W=sc.nextInt();\n\t    int H=sc.nextInt();sc.nextLine();\n\t    if(W==0&&H==0)break;\n\t    \n\t    int startX=0,startY=0;\n\t    map=new char[H+2][W+2];\n\t    for(int i=0;i<H+2;i++){\n\t\tArrays.fill(map[i],'#');\n\t    }\n\t    for(int i=1;i<H+1;i++){\n\t\tchar[] s=sc.next().toCharArray();\n\t\tfor(int j=0;j<W;j++){\t\n\t\t    if(s[j]=='@'){\n\t\t\tstartY=i;\n\t\t\tstartX=j+1;\n\t\t    }\n\t\t    map[i][j+1]=s[j];\t\n\t\t}\n\t    }\n\t    System.out.println(DFS(startY,startX));\n\t}\n    }\n    int DFS(int y,int x)\n    {\n\tif(map[y][x]=='#')return 0;\n\tmap[y][x]='#';\n\tint sum=1;\n\tfor(int i=0;i<4;i++){\n\t    sum+=DFS(y+dy[i],x+dx[i]);\n\t}\n\treturn sum;\n    }\n    \n    public static void main(String[] args)\n    {\n\tnew Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int[] moveX = {0,0,-1,1};\n\tstatic int[] moveY = {-1,1,0,0};\n\tstatic char[][] map;\n\tstatic boolean[][] check;\n\tstatic int ans;\n\tstatic int x, y;\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\tvoid calc () {\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tstatic int W, H;\n\tstatic char[][] tile;\n\n\tstatic int move(int x, int y) {\n\t\tint count = 1;\n\n\t\tif (y + 1 < H) {\n\t\t\tif (tile[y + 1][x] == '.') {\n\t\t\t\ttile[y + 1][x] = 'o';\n\t\t\t\tcount += move(x, y + 1);\n\t\t\t}\n\t\t}\n\t\tif (y - 1 >= 0) {\n\t\t\tif (tile[y - 1][x] == '.') {\n\t\t\t\ttile[y - 1][x] = 'o';\n\t\t\t\tcount += move(x, y - 1);\n\t\t\t}\n\t\t}\n\t\tif (x + 1 < W) {\n\t\t\tif (tile[y][x + 1] == '.') {\n\t\t\t\ttile[y][x + 1] = 'o';\n\t\t\t\tcount += move(x + 1, y);\n\t\t\t}\n\t\t}\n\t\tif (x - 1 >= 0) {\n\t\t\tif (tile[y][x - 1] == '.') {\n\t\t\t\ttile[y][x - 1] = 'o';\n\t\t\t\tcount += move(x - 1, y);\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tString temp;\n\t\tint atX = 0, atY = 0;\n\t\tint num;\n\t\tScanner s = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tW = s.nextInt();\n\t\t\tH = s.nextInt();\n\t\t\t\n\t\t\tif(W==0 && H==0) break;\n\n\t\t\ttile = new char[H][W];\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttemp = s.next();\n\t\t\t\ttile[i] = temp.toCharArray();\n\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (tile[i][j] == '@') {\n\t\t\t\t\t\tatX = j;\n\t\t\t\t\t\tatY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnum = move(atX, atY);\n\n\t\t\tSystem.out.println(num);\n\t\t}\n\t\ts.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic boolean t = true;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tint s_x = 0,s_y = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] tmp = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(tmp[j] == '@'){\n\t\t\t\t\t\ttmp[j] = '.';\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j] = tmp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\tlist.add((s_x << 16) + s_y);\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile(!list.isEmpty()){\n\t\t\t\tint t = list.poll();\n\t\t\t\tint x = t >> 16;\n\t\t\t\tint y = t & 0x00ff;\n\t\t\t\t\n\t\t\t\tif(map[y][x] == '.'){\n\t\t\t\t\tcount++;\n\t\t\t\t\tmap[y][x] = 'x';\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x > 0){\n\t\t\t\t\tlist.push(((x - 1) << 16) + y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < (w-1)){\n\t\t\t\t\tlist.push(((x + 1) << 16) + y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y > 0){\n\t\t\t\t\tlist.push((x << 16) + (y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < (h-1)){\n\t\t\t\t\tlist.push((x << 16) + (y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Scanner;\n\n/**\n * \n * AOJ - 1130 Red and Black\n * \n * @author yuichirw\n *\n */\npublic class Main {\n\n\tstatic int w,h,sx,sy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};\n\tstatic String[] field;\n\tstatic boolean[][] visited;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tvisited = new boolean[h][w];\n\t\t\tSystem.out.println(dfs(sx, sy));\n\t\t}\n\t}\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0 && h == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfield = new String[h];\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfield[i] = sc.next();\n\t\t\tint tmp = field[i].indexOf('@');\n\t\t\tif(tmp != -1) {\n\t\t\t\tsy = i; sx = tmp;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic int dfs(int x, int y) {\n\t\tif(!inField(x, y) || field[y].charAt(x) == '#' || visited[y][x] == true) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tvisited[y][x] = true;\n\t\tint ret = 1;\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tret += dfs(x + dx[i], y + dy[i]);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic boolean inField(int x, int y) {\n\t\tif(x >= 0 && x < w && y >= 0 && y < h) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nclass Main\n{\n\t\n\tstatic int H,W,h,w;\n\tstatic int ans =0;\n\tstatic int  base[][];\n\tpublic static void main(String arg[])\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tans=0;\n\t\t\tint W=in.nextInt();\n\t\t\tint H=in.nextInt();\n\t\t\tif((H|W)==0)\n\t\t\t\treturn;\n\t\t\tbase=new int [H][W];\n\t\t\tString str;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tstr=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(str.charAt(j)=='#')\n\t\t\t\t\t\tbase[i][j]=0;\n\t\t\t\t\telse if(str.charAt(j)=='.')\n\t\t\t\t\t\tbase[i][j]=1;\n\t\t\t\t\telse if(str.charAt(j)=='@')\n\t\t\t\t\t{\n\t\t\t\t\t\th=i;\n\t\t\t\t\t\tw=j;\n\t\t\t\t\t\tbase[i][j]=1;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(h,w,H,W));\n\t\t}\n\t}\n\t\n\tpublic static int solve(int m, int n,int H,int W)\n\t{\n\t\tif((0<=m&&m<H)&&(0<=n&&n<W))\n\t\t{\n\t\t\tif(base[m][n]==0||base[m][n]==2)\n\t\t\t\treturn 0;\n\t\t\telse if(base[m][n]==1)\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tbase[m][n]=2;\n\t\t\t\tif(m-1>=0&&base[m-1][n]==1)\n\t\t\t\t\tsolve(m-1,n,H,W);\n\t\t\t\tif(m+1<H&&base[m+1][n]==1)\n\t\t\t\t\tsolve(m+1,n,H,W);\n\t\t\t\tif(n-1>=0&&base[m][n-1]==1)\n\t\t\t\t\tsolve(m,n-1,H,W);\n\t\t\t\tif(n+1<W&&base[m][n+1]==1)\n\t\t\t\t\tsolve(m,n+1,H,W);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tString tile[][] = new String[22][22];\n\t\t\tint num = 1;\n\t\t\tint num_before = 0;\n\t\t\tfor(int i = 0; i < 22; i++){\n\t\t\t\tfor(int j = 0; j < 22; j++){\n\t\t\t\t\ttile[i][j] = \"#\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tint W = scan.nextInt();\n\t\t\tint H = scan.nextInt();\n\t\t\tif(W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tfor(int i = 1; i <= H; i++){\n\t\t\t\tString tile_row = scan.next();\n\t\t\t\tfor(int j = 0; j < W ; j++){\n\t\t\t\t\ttile[i][j + 1] = tile_row.substring(j,j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i <= W * H; i++){\n\t\t\t\tfor(int j = 1; j <= H; j++){\n\t\t\t\t\tfor(int l = 1; l <= W; l++){\n\t\t\t\t\t\tif(tile[j][l].equals(\"@\")){\n\t\t\t\t\t\t\tif(tile[j - 1][l].equals(\".\")){\n\t\t\t\t\t\t\t\ttile[j - 1][l] = \"@\";\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(tile[j + 1][l].equals(\".\")){\n\t\t\t\t\t\t\t\ttile[j + 1][l] = \"@\";\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(tile[j][l - 1].equals(\".\")){\n\t\t\t\t\t\t\t\ttile[j][l - 1] = \"@\";\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(tile[j][l + 1].equals(\".\")){\n\t\t\t\t\t\t\t\ttile[j][l + 1] = \"@\";\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(num == num_before)\n\t\t\t\t\tbreak;\n\t\t\t\tnum_before =num;\n\t\t\t}\n\t\t\tSystem.out.println(num);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic boolean[][] black;\n\tstatic int[][] count;\n\tstatic int W, H;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner s = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tW = s.nextInt();\n\t\t\tH = s.nextInt();\n\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tblack = new boolean[H][W];\n\t\t\tcount = new int[H][W];\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString str = s.next();\n\t\t\t\tfield[i] = str.toCharArray();\n\t\t\t}\n\n\t\t\tint x = 0, y = 0;\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (field[i][j] == '.')\n\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\telse if (field[i][j] == '@') {\n\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t} else\n\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSearch(x, y);\n\n\t\t\t// for (int i = 0; i < H; i++) {\n\t\t\t// for (int j = 0; j < W; j++) {\n\t\t\t// // System.out.print(field[i][j]);\n\t\t\t// System.out.print(black[i][j]);\n\t\t\t// }\n\t\t\t// System.out.println();\n\t\t\t// }\n\n\t\t\tint ans = 0;\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tans += count[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t\ts.close();\n\t}\n\n\tpublic static void Search(int x, int y) {\n\t\tint[] dx = { 1, 0, -1, 0 };\n\t\tint[] dy = { 0, 1, 0, -1 };\n\n\t\tblack[y][x] = false;\n\t\tcount[y][x] = 1;\n\n\t\tfor (int i = 0; i < dx.length; i++) {\n\t\t\tint sx = x + dx[i];\n\t\t\tint sy = y + dy[i];\n\n\t\t\tif (sx < W && sy < H && sx >= 0 && sy >= 0)\n\t\t\t\tif (black[sy][sx])\n\t\t\t\t\tSearch(sx, sy);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int h;\n\tprivate static int w;\n\tstatic boolean[][] access;\n\tstatic boolean[][] map;\n\tstatic int cnt;\n\t\n\tstatic void Search(int x, int y){\n\t\tif(!access[x][y]){\n\t\t\tcnt++;\n\t\t\taccess[x][y]=true;\n\t\t\tif(x+1<h&&map[x+1][y]){\n\t\t\t\tSearch(x+1,y);\n\t\t\t}\n\t\t\tif(y+1<w&&map[x][y+1]){\n\t\t\t\tSearch(x,y+1);\n\t\t\t}\n\t\t\tif(x-1>=0&&map[x-1][y]){\n\t\t\t\tSearch(x-1,y);\n\t\t\t}\n\t\t\tif(y-1>=0&&map[x][y-1]){\n\t\t\t\tSearch(x,y-1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tw = stdIn.nextInt();\n\t\t\th = stdIn.nextInt();\n\t\t\tif(w==0&&h==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\taccess = new boolean[h][w];\n\t\t\tmap = new boolean[h][w];\n\t\t\tint x = -1, y = -1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] tmp = stdIn.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(tmp[j]=='.'){\n\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tmp[j]=='@'){\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tSearch(x,y);\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic int[] moveX = {0,0,-1,1};\n\tstatic int[] moveY = {-1,1,0,0};\n\tstatic char[][] map;\n\tstatic boolean[][] check;\n\tstatic int ans;\n\tstatic int x, y;\n\n\tpublic static void main (String[] args) {\n\t\tMain.calc();\n\t}\n\t\n\tpublic static void calc () {\n\n\t\twhile (true) {\n\t\t\t\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\n\t\t\tif (x == 0) break;\n\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void dfs (int y, int x) {\n\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\t\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n    static int c = 0;\n    static int[][] directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n    static int[][] m;\n\n    public static void spreadFrom(int x, int y) {\n        if (m[y][x] == 0) {\n            m[y][x] = 1;\n            c++;\n        }\n\n        for (int k =0; k < 4; k++) {\n            int nx = x + directions[k][0];\n            int ny = y + directions[k][1];\n            if (nx >= 0 && nx < m[y].length && ny >= 0 && ny < m.length) {\n                spreadFrom(nx, ny);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            c = 0;\n            int W = sc.nextInt();\n            int H = sc.nextInt();\n            if (W == 0 && H == 0)\n                break;\n            m = new int[H][W];\n            int[] start = new int[2];\n            for (int i = 0; i < H; i++) {\n                String rowStr = sc.next();\n                for (int j = 0; j < W; j++) {\n                    int point;\n                    switch (Character.toString(rowStr.charAt(j))) {\n                        case \".\":\n                            point = 1;\n                            break;\n                        case \"#\":\n                            point = 0;\n                            break;\n                        case \"@\":\n                            point = 2;\n                            start[0] = i;\n                            start[1] = j;\n                            break;\n                        default:\n                            throw new NoSuchElementException();\n                    }\n                    m[i][j] = point;\n                }\n            }\n            spreadFrom(start[0], start[1]);\n            System.out.println(c);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile = new char[22][22];\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            System.out.println(countBlackTile(x, y)/4);\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 0;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]) + 1;\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main{\n\tstatic int answer;\n\tstatic char tiles[][];\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String args[]){\n\t\t// 標準入力準備\n\t\t// BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tScanner sc = new Scanner(System.in);\n\t\tString str = new String();\n\n\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile(true){\n\t\t\t\tw = sc.nextInt();\n\t\t\t\th = sc.nextInt();\n\n\t\t\t\tif(w == 0) break;\n\n\t\t\t\tanswer = 0;\n\t\t\t\ttiles = new char[h][w];\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tstatic void solve(){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint x = 0, y = 0;\n\t\ttry{\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tSystem.out.println(\"readLine \" + i);\n\t\t\t\tString str = br.readLine();\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\ttiles[i][j] = str.charAt(j);\n\t\t\t\t\tif(tiles[i][j] == '@'){\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\n\t\tprintMatrix(tiles);\n\t\t//df(x, y);\n\t\tSystem.out.println(answer);\n\t}\n\n\tstatic void df(int x, int y){\n\t\tSystem.out.println(\"位置: (\" + x + \",\" + y + \")\");\n\t\ttiles[y][x] = '#';\n\t\tanswer++;\n\n\t\t// 上\n\t\tif(y >= 0 && tiles[x][y-1] != '#')\n\t\t\tdf(x, y-1);\n\n\t\t// 右\n\t\tif(x < w && tiles[x+1][y] != '#')\n\t\t\tdf(x+1, y);\n\n\t\t// 下\n\t\tif(y < h && tiles[x][y+1] != '#')\n\t\t\tdf(x, y+1);\n\n\t\t// 左\n\t\tif(x >= 0 && tiles[x-1][y] != '#')\n\t\t\tdf(x-1, y);\n\n\t}\n\n\n\tstatic void printArray(ArrayList<Integer[]> array){\n\t\tSystem.out.println(\"PrintArray \" + array.size());\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tInteger set[] = array.get(i);\n\t\t\tSystem.out.print(\"(\" + set[0] + \", \" + set[1] + \")\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(char matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile = new char[22][22];\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            /*for (int i = 0; i <= H+1; i++){\n                for(int j = 0; j <= W+1; j++){\n                    System.out.print(tile[i][j]);\n                }\n                System.out.println();\n            }*/\n            //System.out.println(tile[y][x]);\n            System.out.println(countBlackTile(x, y));\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 1;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]);\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic final char CHECKED = 'C';\n\tstatic final char BLACK = '.';\n\tstatic final char START = '@';\n\tvoid run(){\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = s.nextInt();\n\t\t\tint h = s.nextInt();\n\t\t\tif(w == 0 && h == w)break;\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tchar tile[][] = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tString row = s.next();\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\ttile[i][j] = row.charAt(j);\n\t\t\t\t\tif(tile[i][j] == START){\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cntTile(tile,x,y));\n\t\t}\n\t}\n\n\tint cntTile(char[][] panel,int x,int y){\n\t\t//??????????????´??????????????\\????????¢?´¢???????????????0????????´?????????\n\t\tif(x > panel.length - 1)return 0;\n\t\tif(x < 0)return 0;\n\t\tif(y > panel.length - 1)return 0;\n\t\tif(y < 0)return 0;\n\t\tpanel[x][y] = CHECKED;\n\t\tint cnt = 0;\n\t\t//??±???????????¢?´¢????????????????????¢?´¢??????????????°?????????\n\t\tif(panel[x + 1][y] == BLACK)\n\t\t\t\tcnt += cntTile(panel,x + 1,y);\n\t\tif(panel[x - 1][y] == BLACK)\n\t\t\t\tcnt += cntTile(panel,x - 1,y);\n\t\tif(panel[x][y + 1] == BLACK)\n\t\t\t\tcnt += cntTile(panel,x,y + 1);\n\t\tif(panel[x][y - 1] == BLACK)\n\t\t\t\tcnt += cntTile(panel,x,y - 1);\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\n/*\n * Original Code\n\tint cntTile(String[][] panel,int[][] chkP,char tile,int x,int y){\n\t\tchkP[x][y] = -1;\n\t\tint cnt = 0;\n\t\tif(x + 1 < panel.length ){\n\t\t\tif(chkP[x + 1][y] != -1 && panel[x + 1][y].charAt(0) == tile)\n\t\t\t\tcnt += cntTile(panel,chkP,tile,x + 1,y);\n\t\t}\n\t\tif(x > 0 ){\n\t\t\tif(chkP[x - 1][y] != -1 && panel[x - 1][y].charAt(0) == tile)\n\t\t\t\tcnt += cntTile(panel,chkP,tile,x - 1,y);\n\t\t}\n\t\tif(y + 1 < panel[x].length ){\n\t\t\tif(chkP[x][y + 1] != -1 && panel[x][y + 1].charAt(0) == tile)\n\t\t\t\tcnt += cntTile(panel,chkP,tile,x,y + 1);\n\t\t}\n\t\tif(y > 0 ){\n\t\t\tif(chkP[x][y - 1] != -1 && panel[x][y - 1].charAt(0) == tile)\n\t\t\t\tcnt += cntTile(panel,chkP,tile,x,y - 1);\n\t\t}\n\t\tcnt++;\n\t\treturn cnt;\n\t}\n\n*/\npublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class RedAndBlack {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(new File(\"aojIn.txt\"));\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                sc.close();\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static int w = 1, h = 1,possible=0;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tpossible=0;\n\t\t\tScanner scan = new Scanner(System.in);\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif(w==0&&h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString space = scan.nextLine();\t\n\t\t\tString data[] = new String[h];\n\t\t\tfor (int i=0;i<h;++i) {\n\t\t\t\tdata[i]=scan.nextLine();\n\t\t\t}\n\t\t\tint[][] d = new int[h][w];\n\t\t\tString[] redata = new String[w];\n\t\t\tfor (int i=0;i<h;++i) {\n\t\t\t\tredata=data[i].split(\"\");\n\t\t\t\tfor (int j=0;j<w;++j) {\n\t\t\t\t\tif(redata[j].equals(\".\")){\n\t\t\t\t\t\td[i][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(redata[j].equals(\"#\")){\n\t\t\t\t\t\td[i][j]=2;\n\t\t\t\t\t}\n\t\t\t\t\tif(redata[j].equals(\"@\")){\n\t\t\t\t\t\td[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i=0;i<h;++i) {\n\t\t\t\tfor (int j=0;j<w;++j) {\n\t\t\t\t\tif(d[i][j]==0){\n\t\t\t\t\t\tpossible++;\n\t\t\t\t\t\tcheak(d,i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(possible);\n\t\t}\n\t}\n\tpublic static void cheak(int[][] data, int i, int j) {\n\t\tif(i-1>=0){\n\t\t\tif(data[i-1][j]==1){\n\t\t\t\tpossible++;\n\t\t\t\tdata[i-1][j]=0;\n\t\t\t\tcheak(data,i-1,j);\n\t\t\t}\n\t\t}\n\t\tif(j-1>=0){\n\t\t\tif(data[i][j-1]==1){\n\t\t\t\tpossible++;\n\t\t\t\tdata[i][j-1]=0;\n\t\t\t\tcheak(data,i,j-1);\n\t\t\t}\n\t\t}\n\t\tif(j+1<w){\n\t\t\tif(data[i][j+1]==1){\n\t\t\t\tpossible++;\n\t\t\t\tdata[i][j+1]=0;\n\t\t\t\tcheak(data,i,j+1);\n\t\t\t}\n\t\t}\n\t\tif(i+1<h){\n\t\t\tif(data[i+1][j]==1){\n\t\t\t\tpossible++;\n\t\t\t\tdata[i+1][j]=0;\n\t\t\t\tcheak(data,i+1,j);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class RedAndBlack {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H, res;\n\tstatic char [][]field;\n\tstatic int[]dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsearch_Start();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tstatic boolean read(){\n\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\tif(W == 0 && H == 0)\n\t\t\treturn false;\n\t\t\n\t\tfield = new char[H][W];\n\t\tres = 0;\n\t\t\n\t\tString line;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t\tfield[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void search_Start(){\n\t\t/**\n\t\t * ツづ慊つクツづ債スツタツーツトツ地ツ点ツづーツ探ツつキツ。\n\t\t */\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t/**\n\t\t\t\t * ツ個ゥツづつつッツつスツづァツ探ツ催オツ開ツ始\n\t\t\t\t */\n\t\t\t\tif(field[i][j] == '@')\n\t\t\t\t\tdfs(j, i);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x, int y){\n\t\tfield[y][x] = '#';\n\t\tres++;\n\t\tint mx = 0, my = 0;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tmx = x + dx[i]; my = y + dy[i];\n\t\t\tif( 0 <= mx && mx < W && 0 <= my && my < H && field[my][mx] == '.')\n\t\t\t\tdfs(mx, my);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tprivate static void solve() {\n\t\tScanner scn = new Scanner(System.in);\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tint W = scn.nextInt();\n\t\t\tint H = scn.nextInt();\n\t\t\tint count=0;\n\t\t\tif(W==0&&H==0) break;\n\t\t\tchar[][] map = new char[H+2][W+2];\n\t\t\tfor(int x=0;x<H+2;x++){\n\t\t\t\tfor(int y=0;y<W+2;y++){\n\t\t\t\t\tmap[x][y]='#';\n\t\t\t\t}\n\t\t\t}\n\t\t\tint startx=1;\n\t\t\tint starty=1;\n\t\t\tfor(int x=1;x<H+1;x++){\n\t\t\t\tString tmp=scn.next();\n\t\t\t\tfor(int y=1;y<W+1;y++){\n\t\t\t\t\tmap[x][y]=tmp.charAt(y-1);\n\t\t\t\t\tif(map[x][y]=='@'){\n\t\t\t\t\t\tstartx=x;\n\t\t\t\t\t\tstarty=y;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[x][y]=='.'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapcount(map,startx,starty);\n\t\t\tfor(int x=1;x<H+1;x++){\n\t\t\t\tfor(int y=1;y<W+1;y++){\n\t\t\t\t\tif(map[x][y]=='.'){\n\t\t\t\t\t\tcount--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr.println(count+1);\n\t\t}\n\t\tpr.flush();\n\t\tscn.close();\n\t}\n\n\tprivate static void mapcount(char[][] map, int startx, int starty) {\n\t\tif(map[startx][starty+1]=='.'){\n\t\t\tmap[startx][starty+1]='#';\n\t\t\tmapcount(map,startx,starty+1);\n\t\t}\n\t\tif(map[startx+1][starty]=='.'){\n\t\t\tmap[startx+1][starty]='#';\n\t\t\tmapcount(map,startx+1,starty);\n\t\t}\n\t\tif(map[startx][starty-1]=='.'){\n\t\t\tmap[startx][starty-1]='#';\n\t\t\tmapcount(map,startx,starty-1);\n\t\t}\n\t\tif(map[startx-1][starty]=='.'){\n\t\t\tmap[startx-1][starty]='#';\n\t\t\tmapcount(map,startx-1,starty);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tpublic static void main(String[] args) {\n\t\tsearch();\n\t}\n\t\n\tpublic static void search(){\n\t\tQueue<Integer> xqueue = new LinkedList<Integer>();\n\t\tQueue<Integer> yqueue = new LinkedList<Integer>();\n\t\t\n\t\tint X; int Y;\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\tString[][] grid;\n\t\tint[][] visit;\n\t\tint currentX = 0;; int currentY = 0;\n\n\t\tX = input.nextInt();\n\t\tY = input.nextInt();\n\t\tif(X == 0 && Y ==0){\n\t\t\tinput.close();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\t\n\t\tgrid = new String[Y][X];\n\t\tvisit = new int[Y][X];\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tString[] tmp = input.next().split(\"\");\n\t\t\tfor(int z = 1; z < tmp.length; z++){\n\t\t\t\tgrid[i][z-1] = tmp[z];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(grid[i][j].equals(\"@\")){\n\t\t\t\t\tcurrentX = j; currentY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tyqueue.offer(currentY);\n\t\txqueue.offer(currentX);\n\t\t\t\t\t\t\t\t\n\t\twhile(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\n\t\t\tif(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\tcurrentY = yqueue.poll();\n\t\t\t\tcurrentX = xqueue.poll();\n\t\t\t}\n\t\t\t\n\t\t\tif(visit[currentY][currentX] == 0 && !(grid[currentY][currentX].equals(\"#\"))){\n\t\t\t\tvisit[currentY][currentX] = 1;\n\t\t\t\tif(currentY > 0 && currentY < Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < visit.length; i++){\n\t\t\tfor(int j = 0; j < visit[i].length; j++){\n\t\t\t\tif(visit[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t\tsearch();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    static Scanner kbd = new Scanner(System.in);\n    public static void main(String[] args){\n\twhile(kbd.hasNext()){\n\t    int n = kbd.nextInt(); //横=x\n\t    int m = kbd.nextInt(); //縦=y\n\t    if(n!=0 && m!=0){\n\t\tsolve(n, m);\n\t    }\n\t}\n    }\n\n    static void solve(int n, int m){\n\tint[][] field = new int[n][m];  //マップ(横*縦)\n\tStack[] s = new Stack[2];  //行ける場所確保\n\ts[0] = new Stack(n*m);     // x座標\n\ts[1] = new Stack(n*m);     // y座標\n\n\tint i, j;\n\tint x=0, y=0, cnt=0; // 現在座標と踏んだタイルの数 \n\tfor(i=0; i<m; i++){\n\t    String ss = kbd.next();\n\t    for(j=0; j<ss.length(); j++){\n\t\tString f = ss.substring(j, j+1);\n\t\tif(f.equals(\".\")){\n\t\t    field[j][i] = 1; // 1 = まだ踏んでいない\n\t\t}\n\t\telse if(f.equals(\"#\")){\n\t\t    field[j][i] = -1;  // -1 = 進めない\n\t\t}\n\t\telse if(f.equals(\"@\")){\n\t\t    field[j][i] = 0;  // 0 = スタートor 通過済み\n\t\t    x = j;\n\t\t    y = i;\n\t\t    cnt = 1;\n\t\t}\n\t    }\n\t}\n\t//フィールドセットここまで\n\n\tsearch(s, field, x, y, n, m);\n\twhile(!(s[0].isEmpty() && s[1].isEmpty())){\n\t    x = (Integer)s[0].pop();\n\t    y = (Integer)s[1].pop();\n\t    if(field[x][y]==1){\n\t\tfield[x][y] = 0;\n\t\tcnt++;\n\t    }\n\t    search(s, field, x, y, n, m);\n\t    //System.out.println(x+\" \"+y);\n\t}\n\tSystem.out.println(cnt);\n    }\n\n    static void search(Stack[] s, int[][] field, int x, int y, int n, int m){\n\tint a=x+1, b=x-1, c=y+1, d=y-1;\n\tif(a<n && field[a][y]==1){\n\t    s[0].push(a);\n\t    s[1].push(y);\n\t    //System.out.println((x+1)+\" \"+y);\n\t}\n\tif(b>=0 && field[b][y]==1){\n\t    s[0].push(b);\n\t    s[1].push(y);\n\t    //System.out.println((x-1)+\" \"+y);\n\t}\n\tif(c<m && field[x][c]==1){\n\t    s[0].push(x);\n\t    s[1].push(c);\n\t    //System.out.println(x+\" \"+(y+1));\n\t}\n\tif(d>=0 && field[x][d]==1){\n\t    s[0].push(x);\n\t    s[1].push(d);\n\t    //System.out.println(x+\" \"+(y-1));\n\t}\n    }\n}\n\nclass Stack{\n    Object[] stack;\n    int sp;\n    public Stack(int n){\n\tstack = new Object[n];\n\tsp = 0;\n    }\n    public void push(Object x){\n\tstack[sp++] = x;\n    }\n    public Object pop(){\n\treturn stack[--sp];\n    }\n    public boolean isEmpty(){\n\treturn sp == 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int w;\n\tstatic int h;\n\tstatic char[][] tiles;\n\tstatic boolean[][] check;\n\tstatic int count;\n\t\n\tstatic int go(int i,int j,int count) {\n\t\tif(!check[i][j]) {\n\t\t\tcheck[i][j] = true;\n\t\t\tcount++;\n\t\t\tif(i-1>=0 && tiles[i-1][j] == '.') {\n\t\t\t\t//System.err.println(count);\n\t\t\t\tcount = go(i-1,j,count);\n\t\t\t}\n\t\t\tif(i+1<h && tiles[i+1][j] == '.') {\n\t\t\t\t//System.err.println(count);\n\t\t\t\tcount = go(i+1,j,count);\n\t\t\t}\n\t\t\tif(j-1>=0 && tiles[i][j-1] == '.') {\n\t\t\t\t//System.err.println(count);\n\t\t\t\tcount = go(i,j-1,count);\n\t\t\t}\n\t\t\tif(j+1<w && tiles[i][j+1] == '.') {\n\t\t\t\t//System.err.println(count);\n\t\t\t\tcount = go(i,j+1,count);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\t\n    public static void main(String[] args) {\n    \tScanner sc = new Scanner(System.in);\n    \twhile(true) {\n    \t\tw = Integer.parseInt(sc.next());\n    \t\th = Integer.parseInt(sc.next());\n    \t\tif(w==0 && h==0) break;\n    \t\ttiles = new char[h][w];\n    \t\tcheck = new boolean[h][w];\n    \t\tfor(int i=0;i<h;i++) {\n    \t\t\ttiles[i] = sc.next().toCharArray();\n    \t\t}\n    \t\t/*for(int i=0;i<h;i++) {\n    \t\t\tfor(int j=0;j<w;j++) {\n    \t\t\t\tSystem.out.print(tiles[i][j]+\" \");\n    \t\t\t}\n    \t\t\tSystem.out.println();\n    \t\t}*/\n    \t\tint m = 0;\n    \t\tint n = 0;\n    \t\tloop:for(int i=0;i<h;i++) {\n    \t\t\tfor(int j=0;j<w;j++) {\n    \t\t\t\tif(tiles[i][j] == '@') {\n    \t\t\t\t\tm = i;\n    \t\t\t\t\tn = j;\n    \t\t\t\t\tbreak loop;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tint count = go(m,n,0);\n    \t\tSystem.out.println(count);\n    \t}\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0) break;\n\n\t\t\ttile = new int[w][h];\n\t\t\tString s;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\ts = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int a, int b) {\n\n\t\tint m = 0;\n\t\ttile[a][b] = 0;\n\n\t\tif(a>0)if(tile[a-1][b]==1)m+=canMove(a-1,b);\n\t\tif(a<w-1)if(tile[a+1][b]==1)m+=canMove(a+1,b);\n\t\tif(b>0)if(tile[a][b-1]==1)m+=canMove(a,b-1);\n\t\tif(b<h-1)if(tile[a][b+1]==1)m+=canMove(a,b+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main\n{\n\tprivate static StringBuffer map[];\n\tprivate static int count;\n\tstatic int[] dx = {0, 1, 0 ,-1};\n\tstatic int[] dy = {-1, 0, 1, 0};\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true)\n\t\t{\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\tmap = new StringBuffer[m];\n\t\t\tcount = 0;\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tString str = sc.next();\n\t\t\t\tif (str.indexOf('@') != -1)\n\t\t\t\t{\n\t\t\t\t\tx = str.indexOf('@');\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tmap[i] = new StringBuffer(str);\n\t\t\t}\n\t\t\twalk(x, y);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tprivate static void walk(int x, int y)\n\t{\n\t\tcount++;\n\t\tmap[y].setCharAt(x, '#');\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\ttry{\n\t\t\t\tif (map[y+dy[i]].charAt(x+dx[i]) == '.') walk(x+dx[i], y+dy[i]);\n\t\t\t}catch (IndexOutOfBoundsException e){}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tstatic int[] v1 = { 0, 1, 0, -1 };\n\tstatic int[] v2 = { 1, 0, -1, 0 };\n\tstatic int[][] field;\n\tstatic int count = 0;\n\tpublic static void main(String[] args) {\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = cin.nextInt();\n\t\t\tint h = cin.nextInt();\n\t\t\tif(w+h==0){break;}\n\t\t\t\n\t\t\tint startx = 0, starty = 0;\n\t\t\tcount=0;\n\t\t\tfield = new int[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tString str = cin.next();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (str.charAt(j-1) == '.') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t} else if (str.charAt(j-1) == '#') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (str.charAt(j-1) == '@') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tstartx = i;\n\t\t\t\t\t\tstarty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tInteger[] start = {startx,starty};\n\t\t\tStack<Integer[]> s = new Stack<Integer[]>();\n\t\t\ts.add(start);\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tInteger[] a = s.pop().clone();\n\t\t\t\tcount++;\n\t\t\t\tfield[a[0]][a[1]]=2;\n\t\t\t\tfor(int i = 0;i<4;i++){\n\t\t\t\t\tint xx = a[0]+v1[i];\n\t\t\t\t\tint yy = a[1]+v2[i];\n\t\t\t\t\tif(field[xx][yy]==1){\n\t\t\t\t\t\tInteger[] next={xx,yy};\n\t\t\t\t\t\ts.add(next.clone());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  void run() {\n    for (; ; ) {\n      int W = ni();\n      int H = ni();\n\n      if ( (W | H) == 0 ) break;\n\n      boolean[][] field = new boolean[ H + 2 ][ W + 2 ];\n\n      int sx = 0;\n      int sy = 0;\n      for ( int i = 1; i <= H; ++i ) {\n        char[] str = sc.next().toCharArray();\n        for ( int j = 1; j <= W; ++j ) {\n          if ( str[ j - 1 ] == '@' ) {\n            sx = j;\n            sy = i;\n          }\n          if ( str[ j - 1 ] == '.' ) {\n            field[ i ][ j ] |= true;\n          }\n        }\n      }\n\n      int cnt = 1;\n      Queue<Integer> qx = new LinkedList<Integer>();\n      Queue<Integer> qy = new LinkedList<Integer>();\n      qx.add(sx);\n      qy.add(sy);\n      boolean[][] done = new boolean[ H + 2 ][ W + 2 ];\n      done[ sy ][ sx ] = true;\n      while ( qx.size() > 0 ) {\n        int x = qx.poll();\n        int y = qy.poll();\n\n        for ( int[] d : ofs ) {\n          int nx = x + d[ 0 ];\n          int ny = y + d[ 1 ];\n          if ( !done[ ny ][ nx ] && field[ ny ][ nx ] ) {\n            done[ ny ][ nx ] |= true;\n            qx.add(nx);\n            qy.add(ny);\n            ++cnt;\n          }\n        }\n      }\n\n      System.out.println(cnt);\n    }\n  }\n\n  int[][] ofs = new int[][]{\n      { 0, 1 },\n      { 1, 0 },\n      { -1, 0 },\n      { 0, -1 }\n  };\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\n\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\tst = new StringTokenizer(sc.nextLine());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\t\t\tint h = Integer.parseInt(st.nextToken());\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tboolean[][] room = new boolean[h][w];\n\t\t\tString s;\n\t\t\tint posx, posy;\n\t\t\tposx = posy = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s.substring(j,j+1).equals(\".\"))\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\telse if (s.substring(j,j+1).equals(\"@\")) {\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\t\tposx = i;\n\t\t\t\t\t\tposy = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tint[] dx = {-1, 0, 1, 0};\n\t\t\tint[] dy = {0, -1, 0, 1};\n\t\t\t\n\t\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\tqx.add(posx);\n\t\t\tqy.add(posy);\n\t\t\tint ans = 0;\n\t\t\tint x, y;\n\t\t\twhile (!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tans++;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h \n\t\t\t\t\t\t\t&& y+dy[i] >= 0 && y+dy[i] < w\n\t\t\t\t\t\t\t&& room[x+dx[i]][y+dy[i]]) {\n\t\t\t\t\t\troom[x+dx[i]][y+dy[i]] = false;\n\t\t\t\t\t\tqx.add(x+dx[i]);\n\t\t\t\t\t\tqy.add(y+dy[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint H, W;\n\tint[] dx = {1, 0, -1, 0};\n\tint[] dy = {0, 1, 0, -1};\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif((H | W) == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i = 0; i < H; ++i){\n\t\t\t\tfield[i] = sc.nextLine().toCharArray(); \n\t\t\t}\n\t\t\tfor(int i = 0; i < H; ++i){\n\t\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\t\tSystem.out.println(dfs(field, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(char[][] field, int y, int x){\n\t\tif(y < 0 || H <= y || x < 0 || W <= x){\n\t\t\treturn 0;\n\t\t}\n\t\tif(field[y][x] == '#'){\n\t\t\treturn 0;\n\t\t}\n\t\tfield[y][x] = '#';\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tret += dfs(field, y+dy[i], x+dx[i]);\n\t\t}\n\t\treturn ret+1;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic int H,W;\n\tstatic int f[][];\n\tstatic int dx[]={1,-1,0,0};\n\tstatic int dy[]={0,0,1,-1};\n\tstatic int cnt;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tint sw=-1;\n\t\t\tint sh=-1;\n\t\t\tf=new int[H][W];\n\t\t\tcnt=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString s=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(s.charAt(j)=='#')\n\t\t\t\t\t\tf[i][j]=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tf[i][j]=0;\n\n\t\t\t\t\tif(s.charAt(j)=='@')\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=j;\n\t\t\t\t\t\tsh=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sw,sh);\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tstatic  int dfs(int w,int h)\n\t{\n\t\tcnt++;\n\t\tf[h][w]=1;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nw=dx[i]+w;\n\t\t\tint nh=dy[i]+h;\n\t\t\tif(nw>=0&&nw<W&&nh>=0&&nh<H&&f[nh][nw]==0)\n\t\t\t\tdfs(nw,nh);\n\t\t}\n\t\treturn cnt;\n\t}\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));       \n\t\ttry {\n\t\t\tString line;\n\t\t\twhile(true){\n\t\t\t\t/* input */\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint w = Integer.parseInt(line.split(\" \")[0]);\n\t\t\t\tint h = Integer.parseInt(line.split(\" \")[1]);\n\t\t\t\tif(w == 0 && h == 0){\n\t\t\t\t\treturn;\n\t\t\t\t} \n\t\t\t\tint[][] field = new int[h][w];\n\t\t\t\tint[] pos = new int[2]; \n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tString str = br.readLine();\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(str.charAt(j)=='.'){\n\t\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\t} else if(str.charAt(j)=='#'){\n\t\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t\t\tpos[0] = i;\n\t\t\t\t\t\t\tpos[1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* processing */\n\t\t\t\tint res = search(pos[0],pos[1],field,h,w);\n\t\t\t\t\n\t\t\t\t/* output */\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static int search(int posi, int posj, int[][] field,int h,int w){\n\t\tint sum = 1;\n\t\tfield[posi][posj] = 2;\n\t\t\n\t\t//up\n\t\tif(posi>0&&field[posi-1][posj]==1){\n\t\t\tsum += search(posi-1,posj,field,h,w);\n\t\t}\n\t\t//right\n\t\tif(posj<w-1&&field[posi][posj+1]==1){\n\t\t\tsum += search(posi,posj+1,field,h,w);\n\t\t}\n\t\t\n\t\t//down\n\t\tif(posi<h-1&&field[posi+1][posj]==1){\n\t\t\tsum += search(posi+1,posj,field,h,w);\n\t\t}\n\t\t\n\t\t//left\n\t\tif(posj>0&&field[posi][posj-1]==1){\t\t\t\n\t\t\tsum += search(posi,posj-1,field,h,w);\n\t\t}\n\n\t\treturn sum;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayDeque;\nimport java.util.Scanner;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class Main{\n\tstatic final Scanner s=new Scanner(System.in);\n\tstatic long[] fal_rnd(int size){\n\t\tAtomicInteger l=new AtomicInteger(-1),r=new AtomicInteger(size);\n\t\tlong[] res=new long[size];\n\t\tINS(size).unordered().parallel().mapToLong(Long::parseLong).forEach(v->res[ThreadLocalRandom.current().nextBoolean()?l.incrementAndGet():r.decrementAndGet()]=v);\n\t\treturn res;\n\t}\n\tstatic IntStream REPS(int v){\n\t\treturn IntStream.range(0,v);\n\t}\n\tstatic Stream<String> INS(long size){\n\t\treturn StreamSupport.stream(Spliterators.spliterator(s,size,Spliterator.NONNULL&Spliterator.IMMUTABLE),false).limit(size);\n\t}\n\t\n\tstatic long r,c;\n\tpublic static void main(String[] __){\n\t\twhile(true){\n\t\t\tc=s.nextInt();\n\t\t\tr=s.nextInt();\n\t\t\tif(r+c==0) return;\n\t\t\tchar[][] f=INS(r).map(String::toCharArray).toArray(char[][]::new);\n\t\t\t\n\t\t\t\n\t\t\tArrayDeque<Point> deque=new ArrayDeque<>();\n\t\t\t\n\t\t\tserachStart:\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\t\tif(f[i][j]=='@'){\n\t\t\t\t\t\tdeque.add(new Point(i,j));\n\t\t\t\t\t\tf[i][j]='#';\n\t\t\t\t\t\tbreak serachStart;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res=1;\n\t\t\twhile(!deque.isEmpty()){\n\t\t\t\tfor(int l=deque.size();l>0;l--){\n\t\t\t\t\tPoint poll=deque.pollFirst();\n\t\t\t\t\tfor(int d=0;d<dr.length;d++) {\n\t\t\t\t\t\tPoint p=(Point)(poll.clone());\n\t\t\t\t\t\tp.translate(dr[d],dc[d]);\n\t\t\t\t\t\tif(ranged(p)&&f[p.x][p.y]=='.') {\n\t\t\t\t\t\t\tdeque.addLast(p);\n\t\t\t\t\t\t\tf[p.x][p.y]='#';\n\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tstatic int[] dr={0,1,0,-1},dc={-1,0,1,0};\n\tstatic boolean ranged(Point p){\n\t\treturn 0<=p.x&&p.x<r&&0<=p.y&&p.y<c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint value[][] = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswitch (buffer.charAt(j)) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tvalue[i][j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tvalue[i][j] = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint dx[] = { -1, 1, 0, 0 };\n\t\t\tint dy[] = { 0, 0, 1, -1 };\n\n\t\t\tint z=0;\n\t\t\tint sum = 0;\n\t\t\tfor (int c = 0; c < 403; c++) {\n\t\t\t\tz=0;\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (value[i][j] == 2) {\n\t\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\t\tint ni = i + dy[k];\n\t\t\t\t\t\t\t\tint nj = j + dx[k];\n\n\t\t\t\t\t\t\t\tif(ni < 0){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(ni >= h){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nj < 0){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(nj >= w){\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(value[ni][nj] == 1){\n\t\t\t\t\t\t\t\t\tvalue[ni][nj] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue[i][j] = 3;\n\t\t\t\t\t\t\tz++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += z;\n\t\t\t\tif(z == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\n\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint w = Integer.parseInt(sc.next());\n\t\t\tint h = Integer.parseInt(sc.next());\n//\t\t\tout.printf(\"%d %d\\n\", w, h);\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tboolean[][] room = new boolean[h][w];\n\t\t\tString s;\n\t\t\tint posx, posy;\n\t\t\tposx = posy = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s.substring(j,j+1).equals(\".\"))\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\telse if (s.substring(j,j+1).equals(\"@\")) {\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\t\tposx = i;\n\t\t\t\t\t\tposy = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tint[] dx = {-1, 0, 1, 0};\n\t\t\tint[] dy = {0, -1, 0, 1};\n\t\t\t\n\t\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\tqx.add(posx);\n\t\t\tqy.add(posy);\n\t\t\tint ans = -1;\n\t\t\tint x, y;\n\t\t\twhile (!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tans++;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h \n\t\t\t\t\t\t\t&& y+dy[i] >= 0 && y+dy[i] < w\n\t\t\t\t\t\t\t&& room[x+dx[i]][y+dy[i]]) {\n\t\t\t\t\t\troom[x+dx[i]][y+dy[i]] = false;\n\t\t\t\t\t\tqx.add(x+dx[i]);\n\t\t\t\t\t\tqy.add(y+dy[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.awt.event.FocusAdapter;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\nimport javax.naming.InitialContext;\n \npublic class Main {\n     \n\tstatic int W, H;\n\tstatic int[][] map;\n\tstatic int sx, sy;\n\t\n    static void start()\n    {\n    \tLinkedList<Point> queue = new LinkedList<Point>();\n    \tqueue.offer(new Point(sx, sy));\n    \t\n    \tint[][] check = new int[H][W];\n    \tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tcheck[y][x] = 0;\n\t\t\t}\n\t\t}\n    \t\n    \twhile (!queue.isEmpty()) {\n\t\t\tPoint p = queue.poll();\n\t\t\tif(check[p.y][p.x] == 1) continue;\n\t\t\tif(map[p.y][p.x] == 1) continue;\n\t\t\tcheck[p.y][p.x] = 1;\n\t\t\tif(0 < p.x) queue.offer(new Point(p.x-1, p.y));\n\t\t\tif(p.x < W-1) queue.offer(new Point(p.x+1, p.y));\n\t\t\tif(0 < p.y) queue.offer(new Point(p.x, p.y-1));\n\t\t\tif(p.y < H-1) queue.offer(new Point(p.x, p.y+1));\n\t\t}\n    \t\n    \tint count = 0;\n    \tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif(check[y][x] == 1) count++;\n\t\t\t}\n\t\t}\n    \t\n    \tSystem.out.println(count);\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tW = sca.nextInt();\n        \tH = sca.nextInt();\n        \tif(W == 0) break;\n        \t\n        \tmap = new int[H][W];\n        \tfor (int y = 0; y < H; y++) {\n        \t\tString str = sca.next();\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tswitch (str.charAt(x)) {\n\t\t\t\t\tcase '.': map[y][x] = 0; break;\n\t\t\t\t\tcase '#': map[y][x] = 1; break;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tmap[y][x] = 0;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t\tsx = x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int count = 0;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint w = 0,h = 0;\n\t\tString str = \"\";\n\t\tint firstX = 0,firstY = 0;\n\n\t\twhile(sc.hasNext()){\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\n\t\t\tchar[][] tiles = new char[h][w];\n\t\t\t\n\t\t\t// テ」ツつソテ」ツつ、テ」ツδォテ、ツスツ愿ヲツ按?\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tstr = sc.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\ttiles[i][j] = str.charAt(j);\n\t\t\t\t\tif(tiles[i][j]=='@'){\n\t\t\t\t\t\tfirstX = j; \n\t\t\t\t\t\tfirstY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// テ・ツ?催・ツクツーテゥツ鳴凝・ツァツ?\n\t\t\twalkTiles(firstY,firstX,tiles);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic void walkTiles(int y,int x,char[][] tiles){\n\t\tif(y>tiles.length-1 || x<0 || y<0 || x>tiles[y].length-1) return;\n\t\tif(tiles[y][x] == '#') return;\n\t\t\n\t\tcount++;\n\t\ttiles[y][x] = '#';\n\t\t\n\t\t// テ・ツ?催・ツクツーテゥツδィテ・ツ按?\n\t\twalkTiles(y-1,x,tiles);\n\t\twalkTiles(y,x+1,tiles); \n\t\twalkTiles(y+1,x,tiles);\n\t\twalkTiles(y,x-1,tiles);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n    static int count=0;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\tint w = 0,h = 0,sx = 0,sy = 0;\n\tchar[][] tiles;\n\t\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\n\t    tiles = new char[h][];\n\n\t    for(int i = 0;i<h;i++){\n\t\ttiles[i] = sc.next().toCharArray();\n\t    }\n\t    \n\t    for(int i = 0;i<tiles.length;i++){\n\t\tfor(int j = 0;j<tiles[i].length;j++){\n\t\t    if(tiles[i][j]=='@'){ sy=i; sx=j;}\n\t\t}\n\t    }\n\t    \n\t    goTiles(sy,sx,tiles);\n\t    System.out.println(count);\n\t    count=0;\n\t}\n    }\n    public static void goTiles(int y,int x,char[][] tiles){\n\tif(y>=tiles.length || y<0) return;\n\tif(x>=tiles[y].length || x<0) return;\n\tif(tiles[y][x]=='#' || tiles[y][x]=='N') return;\n\t\n\tcount++;\n\ttiles[y][x] = 'N';\n\t//System.out.println(\"now: \"+y+\",\"+x+\" count: \"+count);\n\t\n\tgoTiles(y-1,x,tiles);\n\tgoTiles(y,x+1,tiles);\n\tgoTiles(y+1,x,tiles);\n\tgoTiles(y,x-1,tiles);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]){\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n            sc.close();\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew aoj1130().doIt();\n\t}\n\tclass aoj1130{\n\t\tboolean map[][];\n\t\tint x[] = {-1,1,0,0};\n\t\tint y[] = {0,0,-1,1};\n\t\tint H,W;\n\t\tint cnt = 0;\n\t\t\n\t\tvoid dfs(int h,int w){\n\t\t\tif(map[h][w]){\n\t\t\t\tcnt++;\n\t\t\t\tmap[h][w] = false;\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(h + y[i] < H && w + x[i] < W && h + y[i] >= 0 && w + x[i] >= 0){\n\t\t\t\t\tif(map[h + y[i]][w + x[i]] == true){\n\t\t\t\t\t\tdfs(h+y[i],w+x[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tW = sc.nextInt();\n\t\t\t\tH = sc.nextInt();\n\t\t\t\tif(H + W == 0)break;\n\t\t\t\tmap = new boolean[H][W];\n\t\t\t\tint sh = 0,sw = 0;\n\t\t\t\tfor(int h = 0;h < H;h++){\n\t\t\t\t\tString str = sc.next();\n\t\t\t\t\tchar ctr[] = str.toCharArray();\n\t\t\t\t\tfor(int w = 0;w < W;w++){\n\t\t\t\t\t\tif(ctr[w] == '.') map[h][w] = true;\n\t\t\t\t\t\telse if(ctr[w] == '@'){\n\t\t\t\t\t\t\tmap[h][w] = true;\n\t\t\t\t\t\t\tsh = h;\n\t\t\t\t\t\t\tsw = w;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdfs(sh,sw);\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic final int RED = 1;\n\tstatic final int BLACK = 2;\n\tstatic final int VISITED = 3;\n\n\tstatic final int UP = 1;\n\tstatic final int DOWN = 2;\n\tstatic final int RIGHT = 3;\n\tstatic final int LEFT = 4;\n\tstatic final int START = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString tmp = br.readLine();\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString[] tmpArray = tmp.split(\" \");\n\n\t\t\tint width = Integer.parseInt(tmpArray[0]);\n\t\t\tint height = Integer.parseInt(tmpArray[1]);\n\n\t\t\tint[][] tiles = new int[height][width];\n\n\t\t\tint currentX = 0;\n\t\t\tint currentY = 0;\n\n\t\t\tfor(int i = 0; i < height; i++){\n\t\t\t\tString tmpStr = br.readLine();\n\t\t\t\tfor(int j = 0; j < width ; j++){\n\t\t\t\t\tchar tmpChar = tmpStr.charAt(j);\n\t\t\t\t\tif(tmpChar == '.' || tmpChar == '@'){\n\t\t\t\t\t\ttiles[i][j] = BLACK;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttiles[i][j] = RED;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmpChar == '@'){\n\t\t\t\t\t\tcurrentX = j;\n\t\t\t\t\t\tcurrentY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(visit(tiles, currentX, currentY, START));\n\t\t}\n\t}\n\n\tstatic int visit(int[][] tiles, int curX, int curY, int dest){\n\t\tint result = 1;\n\t\t\n\t\tif(!available(tiles, curX, curY)){\n\t\t\treturn 0;\n\t\t}\n\t\ttiles[curY][curX] = VISITED;\n\t\t\n\t\tresult += visit(tiles, curX-1, curY, dest);\n\t\tresult += visit(tiles, curX+1, curY, dest);\n\t\tresult += visit(tiles, curX, curY-1, dest);\n\t\tresult += visit(tiles, curX, curY+1, dest);\n\t\t\n\t\treturn result;\n\t}\n\n\tprivate static boolean available(int[][] tiles, int curX, int curY) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tif(curX < 0 || curX >= tiles[0].length || curY < 0 || curY >= tiles.length || tiles[curY][curX] == RED || tiles[curY][curX] == VISITED){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(new File(\"aojIn.txt\"));\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                sc.close();\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew AOJ1130().doIt();\n\t}\n\t\n\tclass AOJ1130{\n\t\t\n\t\tint w,h;\n\t\tchar[][] map;\n\t\tint sx[] = {1,0,-1,0};\n\t\tint sy[] = {0,1,0,-1};\n\t\tvoid dfs(int x,int y){\n\t\t\tmap[y][x] = '*';\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = x+sx[i];\n\t\t\t\tint ny = y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tif(map[ny][nx]=='#'||map[ny][nx]=='*')continue;\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve(){\n\t\t\tint startx=0,starty=0;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='@'){\n\t\t\t\tstartx = s;starty = i;break;\n\t\t\t}\n\t\t\tdfs(startx,starty);\n\t\t\tint cnt = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(map[i][s]=='*')cnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(in.hasNext()){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tmap = new char[h][w];\n\t\t\t\tfor(int i=0;i<h;i++)map[i] = in.next().toCharArray();\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[64];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n    ArrayList<Board> bs;\n\n    public static void main(String[] args) {\n        Main m = new Main();\n        m.read();\n        m.solve();\n    }\n\n    private void read() {\n        String line;\n        char[] ls;\n        String[] elems;\n        bs = new ArrayList<>();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n            while ((line = br.readLine()) != null && !line.equals(\"\")) {\n                elems = line.split(\" \");\n                int w = Integer.parseInt(elems[0]);\n                int h = Integer.parseInt(elems[1]);\n                if (w == 0 && h == 0)\n                    break;\n                Board b = new Board(w, h);\n                for (int i = 0; i < h; i++) {\n                    ls = br.readLine().toCharArray();\n                    for (int j = 0; j < w; j++) {\n                        if (ls[j] == '@') {\n                            b.board[i][j] = true;\n                            b.init = new Tuple(i, j);\n                        }\n                        else {\n                            b.board[i][j] = ls[j] == '.';\n                        }\n                    }\n                }\n                this.bs.add(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() {\n        for (Board b: bs) {\n            boolean[][] graph = b.board;\n            boolean[][] used = new boolean[b.h][b.w];\n            Queue<Tuple> queue = new LinkedList<>();\n            queue.add(b.init);\n            int ans = 0;\n            while (!queue.isEmpty()) {\n                Tuple crr = queue.poll();\n                if (used[crr.fst][crr.snd])\n                    continue;\n                used[crr.fst][crr.snd] = true;\n                ans++;\n                int x, y;\n                for (int dx = -1; dx <= 1; dx++) {\n                    for (int dy = -1; dy <= 1; dy++) {\n                        if (dx != 0 && dy != 0)\n                            continue;\n                        x = crr.snd + dx;\n                        y = crr.fst + dy;\n                        if (0 <= x && x < b.w && 0 <= y && y < b.h)\n                            if (graph[y][x] && !used[y][x])\n                                queue.add(new Tuple(y, x));\n                    }\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    private class Board {\n        int w, h;\n        Tuple init;\n        boolean[][] board;\n        Board(int w, int h) {\n            this.w = w;\n            this.h = h;\n            board = new boolean[h][w];\n        }\n    }\n\n    private class Tuple {\n        int fst, snd;\n        Tuple(int f, int s) {\n            fst = f;\n            snd = s;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tstatic char map[][]=new char[20][20];\n\tstatic int ans; \n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w=sc.nextInt();\n\t\t\tint h=sc.nextInt();\n\t\t\tint x=0,y=0;\n\t\t\tans=0;\n\t\t\tif(w==0&&h==0)break;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j]=str.charAt(j);\n\t\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\t\tx=j;y=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(x, y, w, h);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void dfs(int x,int y,int w, int h){\n\t\tint x_m[]={1,0,-1,0};\n\t\tint y_m[]={0,1,0,-1};\n\t\tans++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+x_m[i];\n\t\t\tint ny=y+y_m[i];\n\t\t\tmap[y][x]='#';\n\t\t\tif(0<=nx&&0<=ny&&nx<w&&ny<h&&map[ny][nx]=='.'){\n\t\t\t\tdfs(nx, ny, w, h);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans = 0;\n\tint x, y;\n\n\tvoid calc () {\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int c = 0;\n    static int[][] directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n    static int[][] m;\n\n    public static void spreadFrom(int x, int y) {\n        if (m[y][x] != 1) {\n            m[y][x] = 1;\n            c++;\n        }\n\n        for (int k = 0; k < 4; k++) {\n            int nx = x + directions[k][0];\n            int ny = y + directions[k][1];\n            if (nx >= 0 && nx < m[y].length && ny >= 0 && ny < m.length && m[ny][nx] == 0) {\n                spreadFrom(nx, ny);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            c = 0;\n            int W = sc.nextInt();\n            int H = sc.nextInt();\n            if (W == 0 && H == 0)\n                break;\n            m = new int[H][W];\n            int[] start = new int[2];\n            for (int i = 0; i < H; i++) {\n                String rowStr = sc.next();\n                for (int j = 0; j < W; j++) {\n                    int point = 1;\n                    switch (Character.toString(rowStr.charAt(j))) {\n                        case \".\":\n                            point = 0;\n                            break;\n                        case \"#\":\n                            point = 1;\n                            break;\n                        case \"@\":\n                            point = 2;\n                            start[0] = j;\n                            start[1] = i;\n                            break;\n                    }\n                    m[i][j] = point;\n                }\n            }\n            spreadFrom(start[0], start[1]);\n            System.out.println(c);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint ans, w,h;\n\tchar [][] data;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j = 0 ; j < w; j++){\n\t\t\t\t\tdata[i][j] = s.charAt(j);\n\t\t\t\t\tif(data[i][j] == '@'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(sx, sy);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void dfs(int sx, int sy) {\n\t\tans++;\n\t\tdata[sy][sx] = '*';\n\t\tfor(int i = 0 ; i < 4; i++){\n\t\t\tint yy = sy + vy[i];\n\t\t\tint xx= sx + vx[i];\n\t\t\t\n\t\t\tif(0 <= yy&& yy < h && 0<= xx && xx < w){\n\t\t\t\tif(data[yy][xx] == '.'){\n\t\t\t\t\tdfs(xx,yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tprivate int solvec(int n) {\n\t\tint a = n / 500;\n\t\tif(n % 500 != 0) a++;\n\t\tint aa = a / 3;\n\t\tint aaa = a% 3;\n\t\tdouble sum = (double)850 * aa * 3 * 88 / 100 + 850 * aaa;\n\t\treturn (int)sum;\n\t}\n\n\tprivate int solveb(int n) {\n\t\tint a = n / 300;\n\t\tif(n % 300 != 0) a++;\n\t\tint aa = a / 4;\n\t\tint aaa = a% 4;\n\t\tdouble sum = (double)550 * aa * 4 * 85 / 100 + 550 * aaa;\n\t\treturn (int)sum;\n\t}\n\n\tprivate int solvea(int n) {\n\t\tint a = n / 200;\n\t\tif(n % 200 != 0) a++;\n\t\tint aa = a / 5;\n\t\tint aaa = a% 5;\n\t\tdouble sum = (double)380 * aa * 5 * 8 / 10 + 380 * aaa;\n\t\treturn (int)sum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main\n{\n    int dx[]={-1,0,1,0};\n    int dy[]={0,1,0,-1};\n    char[][] map;\n    void run()\n    {\n\tScanner sc=new Scanner(System.in);\n\twhile(true){\n\t    int W=sc.nextInt();\n\t    int H=sc.nextInt();sc.nextLine();\n\t    if(W==0&&H==0)break;\n\t    \n\t    int startX=0,startY=0;\n\t    map=new char[H+2][W+2];\n\t    for(int i=0;i<H+2;i++){\n\t\tArrays.fill(map[i],'#');\n\t    }\n\t    for(int i=1;i<H+1;i++){\n\t\tchar[] s=sc.next().toCharArray();\n\t\tfor(int j=0;j<W;j++){\t\n\t\t    if(s[j]=='@'){\n\t\t\tstartY=i;\n\t\t\tstartX=j+1;\n\t\t    }\n\t\t    map[i][j+1]=s[j];\t\n\t\t}\n\t    }\n\t    System.out.println(DFS(startY,startX));\n\t}\n    }\n    int DFS(int y,int x)\n    {\n\tif(map[y][x]=='#')return 0;\n\tmap[y][x]='#';\n\tint sum=1;\n\tfor(int i=0;i<4;i++){\n\t    sum+=DFS(y+dy[i],x+dx[i]);\n\t}\n\treturn sum;\n    }\n    \n    public static void main(String[] args)\n    {\n\tnew AOJ1130().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "#include <iostream>\n\nint H, W;\nint map[20][20];\nint c;\nusing namespace std;\n\nvoid printArray();\nvoid check(int, int);\n\nint main() {\n  cin  >> W >> H;\n  int sy, sx;\n  for (int i = 0; i < H; i++) {\n    string line;\n    cin >> line;\n    for (int j = 0; j < W; j++) {\n      if (line[j] == '@') {\n        sy = i;\n        sx = j;\n        map[i][j] = 0;\n      } else if (line[j] == '.') {\n        map[i][j] = 0;\n      } else if (line[j] == '#') {\n        map[i][j] = 1;\n      }\n    }\n  }\n  // printArray();\n  c = 0;\n  check(sy, sx);\n  // printArray();\n  cout << c << endl;\n  return 0;\n}\n\nvoid check(int y, int x) {\n  if (y < 0 || x < 0 || y >= H || x >= W || map[y][x] == 1) {\n    return;\n  }\n  map[y][x] = 1;\n  c++;\n  check(y + 1, x);\n  check(y - 1, x);\n  check(y, x + 1);\n  check(y, x - 1);\n}\n\nvoid printArray() {\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cout << map[i][j];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0 || h==0) break;\n\t\t\t\n\t\t\ttile = new int[w][h];\n\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\tString s = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int x, int y) {\n\n\t\tint m = 0;\n\t\ttile[x][y] = 0;\n\n\t\tif(x>0 && tile[x-1][y]==1)m+=canMove(x-1,y);\n\t\tif(x<w-1 && tile[x+1][y]==1)m+=canMove(x+1,y);\n\t\tif(y>0 && tile[x][y-1]==1)m+=canMove(x,y-1);\n\t\tif(y<h-1 && tile[x][y+1]==1)m+=canMove(x,y+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n \npublic class Main {\n\tstatic int turn(char[][] f,int herew,int hereh,int w,int h){\n\t\tint cnt  = 0;\n\t\tf[hereh][herew] = '#';\n\t\tif(hereh>0)\n\t\t\tif(f[hereh-1][herew]=='.')\n\t\t\t\tcnt += turn(f,herew,hereh-1,w,h);\n\t\tif(hereh<h-1)\n\t\t\tif(f[hereh+1][herew]=='.')\n\t\t\t\tcnt += turn(f,herew,hereh+1,w,h);\n\t\tif(herew>0)\n\t\t\tif(f[hereh][herew-1]=='.')\n\t\t\t\tcnt += turn(f,herew-1,hereh,w,h);\n\t\tif(herew<w-1)\n\t\t\tif(f[hereh][herew+1]=='.')\n\t\t\t\tcnt += turn(f,herew+1,hereh,w,h);\n\t\treturn cnt+1;\n\t}\n\t\n    public static void main(String[] args) {\n        try(Scanner sc = new Scanner(System.in)){\n        \twhile(sc.hasNext()) {\n        \t\tint w = sc.nextInt();\n        \t\tint h = sc.nextInt();\n        \t\tif(w+h==0)break;\n        \t\tchar[][] f = new char[h+1][w+1];\n        \t\tint hereh = 0;\n        \t\tint herew = 0;\n        \t\tfor(int i=0;i<h;i++) {\n        \t\t\tString str =sc.next();\n        \t\t\tfor(int j=0;j<w;j++) {\n        \t\t\t\tf[i][j] = str.charAt(j);\n        \t\t\t\tif(f[i][j]=='@') {\n        \t\t\t\t\thereh =i;\n        \t\t\t\t\therew = j;\n        \t\t\t\t\tf[i][j]='#';\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tSystem.out.println(turn(f,herew,hereh,w,h));\n        \t}\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h;\n\tint[][] map;\n\tint[][] cost;\n\t\n\tpublic void loop(int y, int x){\n\t\tcost[y][x]++;\n\t\tif(x!=0 && map[y][x-1]==0 && cost[y][x-1]==0){\n\t\t\tloop(y,x-1);\n\t\t}\n\t\tif(x!=w-1 && map[y][x+1]==0 && cost[y][x+1]==0){\n\t\t\tloop(y,x+1);\n\t\t}\n\t\tif(y!=0 && map[y-1][x]==0 && cost[y-1][x]==0){\n\t\t\tloop(y-1,x);\n\t\t}\n\t\tif(y!=h-1 && map[y+1][x]==0 && cost[y+1][x]==0){\n\t\t\tloop(y+1,x);\n\t\t}\t\n\t}\n\t\n\tpublic void check(){\n\t\tint count=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(cost[i][j]>0)count++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tMain A = new Main();\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tA.w = sc.nextInt();\n\t\t\tA.h = sc.nextInt();\n\t\t\tif((A.w|A.h)==0)break;\n\t\t\t\n\t\t\tA.map = new int[A.h][A.w];\n\t\t\tA.cost = new int[A.h][A.w];\n\t\t\t\n\t\t\tString t = \"\";\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tfor(int i=0;i<A.h;i++){\n\t\t\t\tt = sc.next();\n\t\t\t\tfor(int j=0;j<A.w;j++){\n\t\t\t\t\tif(t.codePointAt(j)==35){\n\t\t\t\t\t\tA.map[i][j] = 1;\n\t\t\t\t\t}else if(t.codePointAt(j)==64){\n\t\t\t\t\t\tA.map[i][j] = 2;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tA.loop(y, x);\n\t\t\tA.check();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static int[] moveX = {0,0,-1,1};\n\tpublic static int[] moveY = {-1,1,0,0};\n\tpublic static char[][] map;\n\tpublic static boolean[][] check;\n\n\tpublic static void dfs (int y, int x) {\n\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static void main (String[] args) {\n\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\n\t\t\tif (x == 0 || y == 0) break;\n\n\t\t\tint ans = 0;\n\t\t\tint startX = 0, startY = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdfs(startY,startX);\n\n\t\t\tfor (boolean[] ch : check) {\n\t\t\t\tfor (boolean c : ch)\n\t\t\t\t\tif (c) ans++;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Serializable;\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tprivate long lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tpublic Main() {\n\t\tFastIO io = new FastIO();\n\t\tQueue<Point> que =new ArrayDeque<>();\n\t\tfor(;;) {\n\t\tint w=io.nextInt();int h=io.nextInt();\n\t\tif(w==0&&h==0)break;\n\t\tint sx=0,sy=0;\n\t\tboolean dist [][] = new boolean[h][w];\n\t\tchar f[][]=new char[h][w];\n\t\tfor(int i=0;i<h;i++)f[i]=io.next().toCharArray();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(f[i][j]=='@') {sy=i;sx=j;}\n\t\tque.add(new Point(sx,sy));\n\n\t\tint dx[]= {1,0,-1,0};int dy[]= {0,1,0,-1};\n\t\twhile(!que.isEmpty()) {\n\t\t\tPoint p=que.poll();\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx=p.x+dx[i];int ny=p.y+dy[i];\n\t\t\t\tif(nx<0||nx>w-1||ny<0||ny>h-1)continue;\n\t\t\t\tif(f[ny][nx]=='.'&&dist[ny][nx]==false) {\n\t\t\t\tque.add(new Point(nx,ny));\n\t\t\t\tdist[ny][nx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count=1;//最初から立ってるマス\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(dist[i][j]==true)count++;\n\t\tSystem.out.println(count);\n\t}\n\t}\n\n\tpublic class FastIO {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int read = 0;\n\t\tprivate int length = 0;\n\t\tpublic final PrintWriter out = new PrintWriter(System.out, false);\n\t\tpublic final PrintWriter err = new PrintWriter(System.err, false);\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (read < length) return true;\n\t\t\tread = 0;\n\t\t\ttry {\n\t\t\t\tlength = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn length > 0;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[read++] : -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate boolean isNumber(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[read])) read++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\tif (!hasNextByte())  throw new NoSuchElementException();\n\t\t\treturn (char)readByte();\n\t\t}\n\n\t\tpublic char[][] nextChar(int height) {\n\t\t\tchar[][] ret = new char[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b;\n\t\t\twhile (isPrintableChar(b = readByte())) sb.appendCodePoint(b);\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (!isNumber(b)) throw new NumberFormatException();\n\t\t\twhile (true) {\n\t\t\t\tif (isNumber(b)) {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n\t\t\t\telse throw new NumberFormatException();\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextInt(int width) {\n\t\t\tint[] ret = new int[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[] nextLong(int width) {\n\t\t\tlong[] ret = new long[width];\n\t\t\tfor (int i = 0;i < width;++ i) ret[i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int[][] nextInt(int width, int height) {\n\t\t\tint[][] ret = new int[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long[][] nextLong(int width, int height) {\n\t\t\tlong[][] ret = new long[height][width];\n\t\t\tfor (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean nextBoolean(String T) {\n\t\t\treturn next().equals(T);\n\t\t}\n\n\t\tpublic boolean[] nextBoolean(char T) {\n\t\t\tchar[] s = next().toCharArray();\n\t\t\tboolean[] ret = new boolean[s.length];\n\t\t\tfor (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic boolean[][] nextBoolean(char T, int height) {\n\t\t\tboolean[][] ret = new boolean[height][];\n\t\t\tfor (int i = 0;i < ret.length;++ i) {\n\t\t\t\tchar[] s = next().toCharArray();\n\t\t\t\tret[i] = new boolean[s.length];\n\t\t\t\tfor (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tprotected void finalize() throws Throwable {\n\t\t\ttry {\n\t\t\t\tsuper.finalize();\n\t\t\t} finally {\n\t\t\t\tin.close();\n\t\t\t\tout.close();\n\t\t\t\terr.close();\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(boolean b) {\n\t\t\tout.print(b);\n\t\t}\n\n\t\tpublic void print(char c) {\n\t\t\tout.print(c);\n\t\t}\n\n\t\tpublic void print(char[] s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void print(double d) {\n\t\t\tout.print(d);\n\t\t}\n\n\t\tpublic void print(float f) {\n\t\t\tout.print(f);\n\t\t}\n\n\t\tpublic void print(int i) {\n\t\t\tout.print(i);\n\t\t}\n\n\t\tpublic void print(long l) {\n\t\t\tout.print(l);\n\t\t}\n\n\t\tpublic void print(Object obj) {\n\t\t\tout.print(obj);\n\t\t}\n\n\t\tpublic void print(String s) {\n\t\t\tout.print(s);\n\t\t}\n\n\t\tpublic void print(Object[] object, char c) {\n\t\t\tout.print(object[0]);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(c);\n\t\t\t\tout.print(object[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(Object[] object, String str) {\n\t\t\tout.print(object[0]);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(str);\n\t\t\t\tout.print(object[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(Object[][] object, char c, char c2) {\n\t\t\tprint(object[0], c);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(c2);\n\t\t\t\tprint(object[i], c);\n\t\t\t}\n\t\t}\n\n\t\tpublic void print(Object[][] object, String str, String str2) {\n\t\t\tprint(object[0], str);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(str2);\n\t\t\t\tprint(object[i], str);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printf(String format, Object... args) {\n\t\t\tout.printf(format, args);\n\t\t}\n\n\t\tpublic void printf(Locale l, String format, Object... args) {\n\t\t\tout.printf(l, format, args);\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(boolean b) {\n\t\t\tout.println(b);\n\t\t}\n\n\t\tpublic void println(char c) {\n\t\t\tout.println(c);\n\t\t}\n\n\t\tpublic void println(char[] s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void println(double d) {\n\t\t\tout.println(d);\n\t\t}\n\n\t\tpublic void println(float f) {\n\t\t\tout.println(f);\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tout.println(i);\n\t\t}\n\n\t\tpublic void println(long l) {\n\t\t\tout.println(l);\n\t\t}\n\n\t\tpublic void println(Object obj) {\n\t\t\tout.println(obj);\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tout.println(s);\n\t\t}\n\n\t\tpublic void println(Object[] object, char c) {\n\t\t\tout.print(object[0]);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(c);\n\t\t\t\tout.print(object[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(Object[] object, String str) {\n\t\t\tout.print(object[0]);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(str);\n\t\t\t\tout.print(object[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(Object[][] object, char c, char c2) {\n\t\t\tprint(object[0], c);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(c2);\n\t\t\t\tprint(object[i], c);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void println(Object[][] object, String str, String str2) {\n\t\t\tprint(object[0], str);\n\t\t\tfor (int i = 1;i < object.length;++ i) {\n\t\t\t\tout.print(str2);\n\t\t\t\tprint(object[i], str);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tout.flush();\n\t\t\terr.flush();\n\t\t}\n\t}\n\n\tpublic enum BoundType {\n\t\tCLOSED, OPEN;\n\t}\n\n\tpublic static class Range<C> implements Serializable{\n\n\tprivate static final long serialVersionUID = 6582232757238309626L;\n\tprotected C lower;\n\tprotected C upper;\n\tprotected BoundType lowerType;\n\tprotected BoundType upperType;\n\tprivate Comparator<? super C> comparator;\n\n\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\tthis(lower, lowerType, upper, upperType, null);\n\t}\n\n\tprotected Range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\tthis.lower = lower;\n\t\tthis.upper = upper;\n\t\tthis.lowerType = lowerType;\n\t\tthis.upperType = upperType;\n\t\tthis.comparator = comparator;\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType) {\n\t\tif (lower != null && upper != null) {\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) throw new IllegalArgumentException();\n\t\t\telse if (comp == 0) {\n\t\t\t\tif (lowerType == BoundType.OPEN && upperType == BoundType.OPEN) throw new IllegalArgumentException();\n\t\t\t\telse if (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t\t\t}\n\t\t}\n\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t}\n\n\tpublic static <C> Range<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, Comparator<? super C> comparator) {\n\t\tif (lower != null && upper != null) {\n\t\t\tint comp = comparator.compare(lower, upper);\n\t\t\tif (comp > 0) throw new IllegalArgumentException();\n\t\t\telse if (comp == 0) {\n\t\t\t\tif (lowerType == BoundType.OPEN && upperType == BoundType.OPEN) throw new IllegalArgumentException();\n\t\t\t\telse if (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)return new Range<C>(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t\t\t}\n\t\t}\n\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> all() {\n\t\treturn range(null, BoundType.OPEN, null, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> all(Comparator<? super C> comparator) {\n\t\treturn range(null, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> atMost(C upper) {\n\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> atMost(C upper, Comparator<? super C> comparator) {\n\t\treturn range(null, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> lessThan(C upper) {\n\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> lessThan(C upper, Comparator<? super C> comparator) {\n\t\treturn range(null, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> downTo(C upper, BoundType boundType) {\n\t\treturn range(null, BoundType.OPEN, upper, boundType);\n\t}\n\n\tpublic static <C> Range<C> downTo(C upper, BoundType boundType, Comparator<? super C> comparator) {\n\t\treturn range(null, BoundType.OPEN, upper, boundType, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> atLeast(C lower) {\n\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> atLeast(C lower, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.CLOSED, null, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> greaterThan(C lower) {\n\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> greaterThan(C lower, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.OPEN, null, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> upTo(C lower, BoundType boundType) {\n\t\treturn range(lower, boundType, null, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> upTo(C lower, BoundType boundType, Comparator<? super C> comparator) {\n\t\treturn range(lower, boundType, null, BoundType.OPEN, comparator  );\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> open(C lower, C upper) {\n\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> open(C lower, C upper, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> openClosed(C lower, C upper) {\n\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> openClosed(C lower, C upper, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> closedOpen(C lower, C upper) {\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t}\n\n\tpublic static <C> Range<C> closedOpen(C lower, C upper, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> closed(C lower, C upper) {\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> closed(C lower, C upper, Comparator<? super C> comparator) {\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> singleton(C value) {\n\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> singleton(C value, Comparator<? super C> comparator) {\n\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> empty() {\n\t\treturn range(null, BoundType.CLOSED, null, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> empty(Comparator<? super C> comparator) {\n\t\treturn range(null, BoundType.CLOSED, null, BoundType.CLOSED, comparator);\n\t}\n\n\tpublic static <C extends Comparable<? super C>> Range<C> encloseAll(Iterable<C> values) {\n\t\tC lower = values.iterator().next();\n\t\tC upper = lower;\n\t\tfor (C i : values) {\n\t\t\tif (lower.compareTo(i) > 0) lower = i;\n\t\t\tif (upper.compareTo(i) < 0) upper = i;\n\t\t}\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t}\n\n\tpublic static <C> Range<C> encloseAll(Iterable<C> values, Comparator<? super C> comparator) {\n\t\tC lower = values.iterator().next();\n\t\tC upper = lower;\n\t\tfor (C i : values) {\n\t\t\tif (comparator.compare(lower, i) > 0) lower = i;\n\t\t\tif (comparator.compare(upper, i) < 0) upper = i;\n\t\t}\n\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, comparator);\n\t}\n\n\tprotected int compareLower(C value) {\n\t\treturn compareLower(value, BoundType.CLOSED);\n\t}\n\n\tprotected int compareLower(C value, BoundType boundType) {\n\t\treturn compareLower(lower, lowerType, value, boundType);\n\t}\n\n\tprotected int compareLower(C lower, BoundType lowerType, C value) {\n\t\treturn compareLower(lower, lowerType, value, BoundType.CLOSED);\n\t}\n\n\tprotected int compareLower(C lower, BoundType lowerType, C value, BoundType boundType) {\n\t\tif (lower == null) return value == null ? 0 : -1;\n\t\telse if (value == null) return 1;\n\t\tint compare;\n\t\tif (comparator == null) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tComparable<C> comp = (Comparable<C>)lower;\n\t\t\tcompare = comp.compareTo(value);\n\t\t} else compare = comparator.compare(lower, value);\n\t\tif (compare == 0) {\n\t\t\tif (lowerType == BoundType.CLOSED) -- compare;\n\t\t\tif (boundType == BoundType.CLOSED) ++ compare;\n\t\t}\n\t\treturn compare;\n\t}\n\n\tprotected int compareUpper(C value) {\n\t\treturn compareUpper(value, BoundType.CLOSED);\n\t}\n\n\tprotected int compareUpper(C value, BoundType boundType) {\n\t\treturn compareUpper(upper, upperType, value, boundType);\n\t}\n\n\tprotected int compareUpper(C upper, BoundType upperType, C value) {\n\t\treturn compareUpper(upper, upperType, value, BoundType.CLOSED);\n\t}\n\n\tprotected int compareUpper(C upper, BoundType upperType, C value, BoundType boundType) {\n\t\tif (upper == null) return value == null ? 0 : 1;\n\t\tif (value == null) return -1;\n\t\tint compare;\n\t\tif (comparator == null) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tComparable<C> comp = (Comparable<C>)upper;\n\t\t\tcompare = comp.compareTo(value);\n\t\t} else compare = comparator.compare(upper, value);\n\t\tif (compare == 0) {\n\t\t\tif (upperType == BoundType.CLOSED) ++ compare;\n\t\t\tif (boundType == BoundType.CLOSED) -- compare;\n\t\t}\n\t\treturn compare;\n\t}\n\n\tpublic boolean hasLowerBound() {\n\t\treturn lower != null;\n\t}\n\n\tpublic C lowerEndpoint() {\n\t\tif (hasLowerBound()) return lower;\n\t\tthrow new IllegalStateException();\n\t}\n\n\tpublic BoundType lowerBoundType() {\n\t\tif (hasLowerBound()) return lowerType;\n\t\tthrow new IllegalStateException();\n\t}\n\n\tpublic boolean hasUpperBound() {\n\t\treturn upper != null;\n\t}\n\n\tpublic C upperEndpoint() {\n\t\tif (hasUpperBound()) return upper;\n\t\tthrow new IllegalStateException();\n\t}\n\n\tpublic BoundType upperBoundType() {\n\t\tif (hasUpperBound()) return upperType;\n\t\tthrow new IllegalStateException();\n\t}\n\n\t/**\n\t * この区間が空集合か判定します。\n\t * @return 空集合ならばtrue\n\t */\n\tpublic boolean isEmpty() {\n\t\treturn lower == null && upper == null && lowerType == BoundType.CLOSED;\n\t}\n\n\t/**\n\t * 与えられた引数が区間の左側に位置するか判定します。<br>\n\t * 接する場合は区間の左側ではないと判定します。\n\t * @param value 調べる引数\n\t * @return 区間の左側に位置するならtrue\n\t */\n\tpublic boolean isLess(C value) {\n\t\treturn isLess(value, BoundType.CLOSED);\n\t}\n\n\tprotected boolean isLess(C value, BoundType boundType) {\n\t\treturn compareLower(value, boundType) > 0;\n\t}\n\n\t/**\n\t * 与えられた引数が区間の右側に位置するか判定します。<br>\n\t * 接する場合は区間の右側ではないと判定します。\n\t * @param value 調べる引数\n\t * @return 区間の右側に位置するならtrue\n\t */\n\tpublic boolean isGreater(C value) {\n\t\treturn isGreater(value, BoundType.CLOSED);\n\t}\n\n\tprivate boolean isGreater(C value, BoundType boundType) {\n\t\treturn compareUpper(value, boundType) < 0;\n\t}\n\n\t/**\n\t * 与えられた引数が区間内に位置するか判定します。<br>\n\t * 接する場合も区間内に位置すると判定します。\n\t * @param value 調べる引数\n\t * @return 区間内に位置するならtrue\n\t */\n\tpublic boolean contains(C value) {\n\t\treturn !isLess(value) && !isGreater(value) && !isEmpty();\n\t}\n\n\t/**\n\t * 与えられた引数すべてが区間内に位置するか判定します。<br>\n\t * 接する場合も区間内に位置すると判定します。\n\t * @param value 調べる要素\n\t * @return 全ての要素が区間内に位置するならtrue\n\t */\n\tpublic boolean containsAll(Iterable<? extends C> values) {\n\t\tfor (C i : values) if (!contains(i)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * 与えられた区間がこの区間に内包されるか判定します。<br>\n\t *\n\t * @param other\n\t * @return 与えられた区間がこの区間に内包されるならtrue\n\t */\n\tpublic boolean encloses(Range<C> other) {\n\t\treturn !isLess(other.lower, other.lowerType) && !isGreater(other.upper, other.upperType);\n\t}\n\n\t/**\n\t * 与えられた区間がこの区間と公差するか判定します。<br>\n\t * 接する場合は公差するものとします。\n\t * @param value 調べる引数\n\t * @return 区間が交差するならtrue\n\t */\n\tpublic boolean isConnected(Range<C> other) {\n\t\tC lower, upper;\n\t\tBoundType lowerType, upperType;\n\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\tlower = other.lower;\n\t\t\tlowerType = other.lowerType;\n\t\t} else {\n\t\t\tlower = this.lower;\n\t\t\tlowerType = this.lowerType;\n\t\t}\n\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\tupper = other.upper;\n\t\t\tupperType = other.upperType;\n\t\t} else {\n\t\t\tupper = this.upper;\n\t\t\tupperType = this.upperType;\n\t\t}\n\t\tif (lower == null || upper == null) return true;\n\t\tint comp = compareLower(lower, lowerType, upper, upperType);\n\t\treturn comp <= 0;\n\t}\n\t/**\n\t * この区間との積集合を返します。\n\t * @param connectedRange 積集合を求める区間\n\t * @return 積集合\n\t */\n\tpublic Range<C> intersection(Range<C> connectedRange) {\n\t\tif (!isConnected(connectedRange)) throw new IllegalArgumentException();\n\t\tC lower, upper;\n\t\tBoundType lowerType, upperType;\n\t\tif (isLess(connectedRange.lower, connectedRange.lowerType)) {\n\t\t\tlower = connectedRange.lower;\n\t\t\tlowerType = connectedRange.lowerType;\n\t\t} else {\n\t\t\tlower = this.lower;\n\t\t\tlowerType = this.lowerType;\n\t\t}\n\t\tif (isGreater(connectedRange.upper, connectedRange.upperType)) {\n\t\t\tupper = connectedRange.upper;\n\t\t\tupperType = connectedRange.upperType;\n\t\t} else {\n\t\t\tupper = this.upper;\n\t\t\tupperType = this.upperType;\n\t\t}\n\t\tif (comparator == null) {\n\t\t\treturn new Range<C>(lower, lowerType, upper, upperType);\n\t\t}\n\t\treturn range(lower, lowerType, upper, upperType, comparator);\n\t}\n\n\t/**\n\t * この区間との和集合を返します。\n\t * @param other 和集合を求める区間\n\t * @return 和集合\n\t */\n\tpublic Range<C> span(Range<C> other) {\n\t\tif (other.isEmpty()) return new Range<C>(lower, lowerType, upper, upperType);\n\t\tC lower, upper;\n\t\tBoundType lowerType, upperType;\n\t\tif (isLess(other.lower, other.lowerType)) {\n\t\t\tlower = this.lower;\n\t\t\tlowerType = this.lowerType;\n\t\t} else {\n\t\t\tlower = other.lower;\n\t\t\tlowerType = other.lowerType;\n\t\t}\n\t\tif (isGreater(other.upper, other.upperType)) {\n\t\t\tupper = this.upper;\n\t\t\tupperType = this.upperType;\n\t\t} else {\n\t\t\tupper = other.upper;\n\t\t\tupperType = other.upperType;\n\t\t}\n\t\treturn new Range<C>(lower, lowerType, upper, upperType, comparator);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object object) {\n\t\tif (this == object) return true;\n\t\tif (object instanceof Range) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tRange<C> comp = (Range<C>) object;\n\t\t\treturn compareLower(comp.lower, comp.lowerType) == 0 && compareUpper(comp.upper, comp.upperType) == 0 && lowerType == comp.lowerType && upperType == comp.upperType;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tif (lower == null && upper == null) return 0;\n\t\telse if (lower == null) return upper.hashCode();\n\t\telse if (upper == null) return lower.hashCode();\n\t\treturn lower.hashCode() ^ upper.hashCode();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (isEmpty()) return \"()\";\n\t\treturn (lowerType == BoundType.OPEN ? \"(\" : \"[\") + (lower == null ? \"\" : lower.toString()) + \"..\" + (upper == null ? \"\" : upper.toString()) + (upperType == BoundType.OPEN ? \")\" : \"]\");\n\t}\n}\n\n\tpublic interface IterableFunction<T> {\n\t\tpublic T next(T value);\n\t}\n\n\tpublic static class IterableRange<C> extends Range<C> implements Iterable<C>{\n\n\t\tprivate static final long serialVersionUID = -8258795284144976352L;\n\t\tprotected IterableFunction<C> func;\n\n\t\tprotected IterableRange(C lower, BoundType lowerType, C upper, BoundType upperType, IterableFunction<C> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType);\n\t\t\tthis.func = func;\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> range(C lower, BoundType lowerType, C upper, BoundType upperType, IterableFunction<C> func) {\n\t\t\tif (lower == null || upper == null) throw new IllegalArgumentException();\n\t\t\tint comp = lower.compareTo(upper);\n\t\t\tif (comp > 0) throw new IllegalArgumentException();\n\t\t\telse if (comp == 0 && (lowerType == BoundType.OPEN || upperType == BoundType.OPEN)) throw new IllegalArgumentException();\n\t\t\treturn new IterableRange<C>(lower, lowerType, upper, upperType, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> open(C lower, C upper, IterableFunction<C> func) {\n\t\t\tif (lower == null) throw new IllegalArgumentException();\n\t\t\treturn range(func.next(lower), BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> openClosed(C lower, C upper, IterableFunction<C> func) {\n\t\t\tif (lower == null) throw new IllegalArgumentException();\n\t\t\treturn range(func.next(lower), BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closedOpen(C lower, C upper, IterableFunction<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> closed(C lower, C upper, IterableFunction<C> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static <C extends Comparable<? super C>> IterableRange<C> singleton(C value, IterableFunction<C> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\t\tprivate class Iter implements Iterator<C> {\n\t\t\tC now;\n\t\t\tIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn !isGreater(now);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final C next() {\n\t\t\t\tC ret = now;\n\t\t\t\tnow = func.next(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<C> iterator() {\n\t\t\treturn new Iter();\n\t\t}\n\n\t\tpublic int getDistance() {\n\t\t\tC check = upper;\n\t\t\tint ret = 0;\n\t\t\twhile (lower != check) {\n\t\t\t\tcheck = func.next(check);\n\t\t\t\t++ ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpublic static class IntRange extends IterableRange<Integer>{\n\n\t\tprivate static final long serialVersionUID = -2492737284164864881L;\n\n\t\tprivate final boolean useFastIter;\n\n\t\tprivate static class Next implements IterableFunction<Integer> {\n\n\t\t\t@Override\n\t\t\tpublic Integer next(Integer value) {\n\t\t\t\treturn value + 1;\n\t\t\t}\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tsuper(lower, lowerType, upper, upperType, new Next());\n\t\t\tuseFastIter = true;\n\t\t}\n\n\t\tprotected IntRange(int lower, BoundType lowerType, int upper, BoundType upperType, IterableFunction<Integer> func) {\n\t\t\tsuper(lower, lowerType, upper, upperType, func);\n\t\t\tuseFastIter = false;\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType) {\n\t\t\tif (lower > upper) return new IntRange(0, BoundType.CLOSED, 0, BoundType.OPEN);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange range(int lower, BoundType lowerType, int upper, BoundType upperType, IterableFunction<Integer> func) {\n\t\t\tif (lower > upper) return new IntRange(0, BoundType.CLOSED, 0, BoundType.OPEN, func);\n\t\t\tif (lowerType == BoundType.OPEN) ++ lower;\n\t\t\tif (upperType == BoundType.OPEN) -- upper;\n\t\t\treturn new IntRange(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int lower, int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange open(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange open(int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange openClosed(int lower, int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(lower, BoundType.OPEN, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN);\n\t\t}\n\n\t\tpublic static IntRange closedOpen(int lower, int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.OPEN, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int lower, int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(lower, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange closed(int upper, IterableFunction<Integer> func) {\n\t\t\treturn range(0, BoundType.CLOSED, upper, BoundType.CLOSED, func);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED);\n\t\t}\n\n\t\tpublic static IntRange singleton(int value, IterableFunction<Integer> func) {\n\t\t\treturn range(value, BoundType.CLOSED, value, BoundType.CLOSED, func);\n\t\t}\n\n\t\tprivate class FastIter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic FastIter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\treturn now++;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\tprivate class Iter implements Iterator<Integer> {\n\t\t\tint now;\n\t\t\tpublic Iter() {\n\t\t\t\tnow = lower;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic final boolean hasNext() {\n\t\t\t\treturn now <= upper;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final Integer next() {\n\t\t\t\tint ret = now;\n\t\t\t\tnow = func.next(now);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic final void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator() {\n\t\t\treturn useFastIter ? new FastIter() : new Iter();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getDistance() {\n\t\t\tint ret = upper - lower;\n\t\t\tif (upperType == BoundType.CLOSED) ++ ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic int getClosedLower() {\n\t\t\treturn lower;\n\t\t}\n\n\t\tpublic int getOpenLower() {\n\t\t\treturn lower - 1;\n\t\t}\n\n\t\tpublic int getClosedUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper : upper - 1;\n\t\t}\n\n\t\tpublic int getOpenUpper() {\n\t\t\treturn upperType == BoundType.CLOSED ? upper + 1 : upper;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int w,h;\n\tstatic char map[][]=new char[21][21];\n\tstatic int dx[] = {0,1,0,-1};\n\tstatic int dy[] = {1,0,-1,0};\n\tstatic int max=9999999;\n\tstatic int[][] kioku =new int[21][21];\n\tstatic void dfs(int x,int y,int sum){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = dx[i]+x;\n\t\t\tint ny = dy[i]+y;\n\t\t\tif(nx<0|nx>=w||ny<0||ny>=h||map[ny][nx]=='#'||kioku[ny][nx]!=max)continue;\n\t\t\tkioku[ny][nx]=1;\n\t\t\tdfs(nx,ny,sum+1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tint sx=0,sy=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString test = in.next();\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tkioku[i][s]=max;\n\t\t\t\t\tmap[i][s]=test.charAt(s);\n\t\t\t\t\tif(test.charAt(s)=='@'){\n\t\t\t\t\t\tsx=s;sy=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx,sy,0);\n\t\t\tint result = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tif(kioku[i][s]==max)continue;\n\t\t\t\t\tresult += kioku[i][s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\n\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile;\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            tile = new char[H+2][W+2];\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            /*for (int i = 0; i <= H+1; i++){\n                for(int j = 0; j <= W+1; j++){\n                    System.out.print(tile[i][j]);\n                }\n                System.out.println();\n            }\n            System.out.println(tile[y][x]);*/\n            System.out.println(countBlackTile(x, y));\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 1;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]);\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\telse calc(w,h);\n\t\t}\n\t}\n\n\tpublic void calc(int w, int h){\n\t\tint[][] tile = new int[w][h];\n\t\tint nowX = 0;\n\t\tint nowY = 0;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tString line = sc.nextLine();\n\t\t\tfor(int i = 0; i < w; i++){\n\t\t\t\tchar c = line.charAt(i);\n\t\t\t\tif(c == '.') tile[i][j] = 1;\n\t\t\t\telse if(c == '@'){\n\t\t\t\t\ttile[i][j] = 1;\n\t\t\t\t\tnowX = i;\n\t\t\t\t\tnowY = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(calc2(tile, tile, nowX, nowY));\n\t}\n\tpublic int calc2(int[][] tile, int[][] tile2, int X, int Y){\n\t\ttile2[X][Y] = 0;\n \t\tint ue = 0;\n\t\tif(Y > 0 && tile[X][Y-1] == 1 && tile2[X][Y-1] != 0) \n\t\t\tue = calc2(tile, tile2, X, Y-1);\n\t\tint shita = 0;\n\t\tif(Y < tile[X].length - 1 && tile[X][Y+1] == 1 && tile2[X][Y+1] != 0) \n\t\t\tshita = calc2(tile, tile2, X, Y+1);\n\t\tint hidari = 0;\n\t\tif(X > 0 && tile[X-1][Y] == 1 && tile2[X-1][Y] != 0)\n\t\t\thidari = calc2(tile, tile2, X-1, Y);\n\t\tint migi = 0;\n\t\tif(X < tile.length - 1 && tile[X+1][Y] == 1 && tile2[X+1][Y] != 0)\n\t\t\tmigi = calc2(tile, tile2, X+1, Y);\n\t\t\n\t\treturn ue + shita + migi + hidari + 1;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0) break;\n\n\t\t\ttile = new int[w][h];\n\t\t\tString s;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\ts = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int a, int b) {\n\n\t\tint m = 0;\n\t\ttile[a][b] = 0;\n\n\t\tif(a>0)if(tile[a-1][b]==1)m+=canMove(a-1,b);\n\t\tif(a<w-1)if(tile[a+1][b]==1)m+=canMove(a+1,b);\n\t\tif(b>0)if(tile[a][b-1]==1)m+=canMove(a,b-1);\n\t\tif(b<h-1)if(tile[a][b+1]==1)m+=canMove(a,b+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main\n{\n\tprivate static StringBuffer map[];\n\tprivate static int count;\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true)\n\t\t{\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\tmap = new StringBuffer[m];\n\t\t\tcount = 0;\n\t\t\tint x = 0, y = 0;\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tString str = sc.next();\n\t\t\t\tif (str.indexOf('@') != -1)\n\t\t\t\t{\n\t\t\t\t\tx = str.indexOf('@');\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\tmap[i] = new StringBuffer(str);\n\t\t\t}\n\t\t\twalk(x, y);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tprivate static void walk(int x, int y)\n\t{\n\t\tcount++;\n\t\tmap[y].setCharAt(x, '#');\n\t\ttry{\n\t\t\tif (map[y-1].charAt(x) == '.') walk(x, y - 1);\n\t\t}catch (IndexOutOfBoundsException e){}\n\t\ttry{\n\t\t\tif (map[y+1].charAt(x) == '.') walk(x, y + 1);\n\t\t}catch (IndexOutOfBoundsException e){}\n\t\ttry{\n\t\t\tif (map[y].charAt(x+1) == '.') walk(x + 1, y);\n\t\t}catch (IndexOutOfBoundsException e){}\n\t\ttry{\n\t\t\tif (map[y].charAt(x-1) == '.') walk(x - 1, y);\n\t\t}catch (IndexOutOfBoundsException e){}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in);\n      int N = sc.nextInt();\n      int M = sc.nextInt(); sc.nextLine(); //nextIntの後残る改行文字を消す\n      int count=0;\n      String[] line = new String[M];\n      for(int i=0;i<M;i++){\n      \tline[i]=sc.nextLine();\n      } \n      String[][] a = new String[N][M];\n      for(int j=0;j<M;j++){\n       for(int k=0;k<N;k++){\n        a[k][j]=String.valueOf(line[j].charAt(k));\n       }\n      }\n      for(int t=0;t<60;t++){\n       for(int p=0;p<M;p++){\n        for(int q=0;q<N;q++){\n         if((a[q][p].equals(\"@\"))&&(a[Math.max(0,q-1)][p].equals(\".\"))){\n         \ta[Math.max(0,q-1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.max(0,p-1)].equals(\".\"))){\n         \ta[q][Math.max(0,p-1)]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[Math.min(N-1,q+1)][p].equals(\".\"))){\n         \ta[Math.min(N-1,q+1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.min(M-1,p+1)].equals(\".\"))){\n         \ta[q][Math.min(M-1,p+1)]=\"@\";\n         }\n        }\n       }\n      }\n      for(int r=0;r<M;r++){\n       for(int s=0;s<N;s++){\n         if(a[s][r].equals(\"@\")){\n         \tcount++;\n         }\n       }\n      }\n     System.out.println(count);\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tboolean[][] map;\n\tint W, H;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\t\tif( (W|H) == 0 ) break;\n\t\t\tmap = new boolean[H+2][W+2];\n\t\t\tint sx=-1, sy=-1;\n\t\t\t\n\t\t\tfor(int i=1;i<=H;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tfor(int j=1;j<=W;j++) {\n\t\t\t\t\t if(l.charAt(j-1) == '@' ) { sx = j; sy = i; }\n\t\t\t\t\t map[i][j] = l.charAt(j-1) == '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(sx, sy));\n\t\t}\n\t}\n\tint[] dx = {1,0,-1,0};\n\tint[] dy = {0,-1,0,1};\n\tint dfs(int x, int y) {\n\t\tmap[y][x] = false;\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if(map[y+dy[i]][x+dx[i]]) {\n\t\t\tcnt += dfs(x+dx[i], y+dy[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[64];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int cnt;\n\tstatic char[][] map = new char[21][21];\n\tstatic int w,h;\n\tstatic int dfs(int y, int x, char[][] v){\n\t\t  int my[] = {-1,0,1,0};\n\t\t  int mx[] = {0,-1,0,1};\n\t\t  int ret = 1;\n\t\t  for(int i=0;i<4;i++){\n\t\t\t    int ny = y + my[i], nx = x + mx[i];\n\t\t\t    if(0<=ny&&ny<h&&0<=nx&&nx<w && v[ny][nx] == '.'){\n\t\t\t      v[ny][nx] = '#';\n\t\t\t      ret += dfs(ny, nx, v);\n\t\t\t    }\n\t\t  }\n\t\t  return ret;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tString[] str = new String[h];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tstr[i] = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] =str[i].charAt(j);\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]=='@')System.out.println(dfs(i,j,map));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Main{\n\tstatic int answer;\n\tstatic char tiles[][];\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String args[]){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t//Scanner sc = new Scanner(System.in);\n\t\tString str = new String();\n\n\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile(true){\n\t\t\t\tstr = br.readLine();\n\t\t\t\tString strs[] = str.split(\" \");\n\t\t\t\tw = Integer.parseInt(strs[0]);\n\t\t\t\th = Integer.parseInt(strs[1]);\n\n\t\t\t\tif(w == 0) break;\n\t\t\t\tanswer = 0;\n\t\t\t\ttiles = new char[h][w];\n\n\t\t\t\tint x = 0, y = 0;\n\t\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\t\t//System.out.println(\"readLine \" + i);\n\t\t\t\t\tstr = br.readLine();\n\t\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\t\ttiles[i][j] = str.charAt(j);\n\t\t\t\t\t\tif(tiles[i][j] == '@'){\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdf(x, y);\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tstatic void df(int x, int y){\n\t\t//System.out.println(\"位置: (\" + x + \",\" + y + \")\");\n\t\ttiles[y][x] = '#';\n\t\tanswer++;\n\n\t\t// 上\n\t\tif(y > 0 && tiles[y-1][x] != '#')\n\t\t\tdf(x, y-1);\n\n\t\t// 右\n\t\tif(x < w-1 && tiles[y][x+1] != '#')\n\t\t\tdf(x+1, y);\n\n\t\t// 下\n\t\tif(y < h-1 && tiles[y+1][x] != '#')\n\t\t\tdf(x, y+1);\n\n\t\t// 左\n\t\tif(x > 0 && tiles[y][x-1] != '#')\n\t\t\tdf(x-1, y);\n\n\t}\n\n\n\tstatic void printArray(ArrayList<Integer[]> array){\n\t\tSystem.out.println(\"PrintArray \" + array.size());\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tInteger set[] = array.get(i);\n\t\t\tSystem.out.print(\"(\" + set[0] + \", \" + set[1] + \")\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(char matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  private void run() {\n    while(sc.hasNext()) {\n      final int w = sc.nextInt();\n      final int h = sc.nextInt();\n      sc.nextLine();\n\n      if(w == 0 && h == 0) break;\n\n      final Tiles map = new Tiles(w, h);\n      int px = -1;\n      int py = -1;\n\n      for(int y = 0; y < h; y++) {\n        String line = sc.nextLine();\n        for(int x = 0; x < w; x++) {\n          switch(line.charAt(x)) {\n          case '.' : map.setBlack(x, y); break;\n          case '#' : map.setRed(x, y);   break;\n          case '@' : map.setBlack(x, y); px = x; py = y; break;\n          }\n        }\n      }\n\n      System.out.println(map.blackArea(px, py));\n    }\n  }\n\n  private final Scanner sc = new Scanner(System.in);\n}\n\nclass Tiles {\n  public Tiles(int w, int h) {\n    this.w = w;\n    this.h = h;\n    this.map = new int[w * h];\n\n    for(int i = 0; i < w * h; i++) map[i] = -1;\n  }\n\n  public void setBlack(int x, int y) {\n    final int pos = x + y * w;\n\n    map[pos] = -1;\n\n    if(x != 0 && map[pos - 1] != RED) union(pos, pos - 1);\n    if(y != 0 && map[pos - w] != RED) union(pos, pos - w);\n  }\n\n  public void setRed(int x, int y) {\n    map[x + y * w] = RED;\n  }\n\n  public int blackArea(int x, int y) {\n    return - map[root(x + y * w)];\n  }\n\n  private void union(int a, int b) {\n    a = root(a);\n    b = root(b);\n\n    if(a != b) {\n      if(map[a] < map[b]) {\n        map[a] += map[b];\n        map[b] = a;\n      }\n      else {\n        map[b] += map[a];\n        map[a] = b;\n      }\n    }\n  }\n\n  private int root(int a) {\n    if(map[a] < 0) return a;\n\n    map[a] = root(map[a]);\n    return map[a];\n  }\n\n  private final int w;\n  private final int h;\n  private final int[] map;\n\n  private static final int RED = 10000000;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int w;\n\tstatic int h;\n\tpublic boolean[][] map;\n\t\n\tMain(boolean[][] map) {\n\t\tthis.map = map;\n\t}\n\t\t\n\tint solve(int y, int x) {\n\t\tif (y < 0 || x < 0 || y >= h || x >= w || !map[y][x]) return 0;\n\t\tmap[y][x] = false;\n\t\treturn solve(y + 1, x) + solve(y - 1, x) + solve(y, x + 1) + solve(y, x - 1) + 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tboolean[][] room = new boolean[h][];\n\t\t\tint y = 0;\n\t\t\tint x = 0;\n\t\t\tscan.nextLine();\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\troom[i] = new boolean[w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = scan.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswitch (str.charAt(j)) {\n\t\t\t\t\t\tcase '.': room[i][j] = true; break;\n\t\t\t\t\t\tcase '#': room[i][j] = false; break;\n\t\t\t\t\t\tcase '@':\n\t\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(new Main(room).solve(y, x));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static char[][] map;\n\tpublic static int[] dx = {0,0,1,-1};\n\tpublic static int[] dy = {1,-1,0,0};\n\n\tpublic static int dfs(int x, int y){\n\t\tint ans=1;\n\t\tmap[y][x] = '#';\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif(0<=nx && nx<map[0].length && 0<=ny && ny<map.length && map[ny][nx] == '.'){\n\t\t\t\tans += dfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc= new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\n\t\t\tmap = new char[h][w];\n\t\t\tint x=0, y=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]=='@'){x=j; y=i; map[i][j]='.';}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(x,y));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n// ??±???????????¢?´¢\npublic class Main {\n    static int w, h;\n    static int[][] map;\n    static int c;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if ((w | h) == 0) {\n                break;\n            }\n            map = new int[h][w];\n            int sx = 0;\n            int sy = 0;\n            c = 0;\n            for (int i = 0; i < h; i++) {\n                String line = sc.next();\n                for (int j = 0; j < w; j++) {\n                    if (line.charAt(j) == '@') {\n                        sy = i;\n                        sx = j;\n                        map[i][j] = 0;\n                    } else {\n                        map[i][j] = line.charAt(j) == '.' ? 0 : 1;\n                    }\n                }\n            }\n            dfs(sy, sx);\n            System.out.println(c);\n        }\n    }\n\n    public static void dfs(int y, int x) {\n        if (y < 0 || y >= h || x < 0 || x >= w) {\n            return;\n        }\n        if (map[y][x] == 1) {\n            return;\n        }\n        map[y][x] = 1;\n        int[] d = new int[] { 0, 1, 0, -1, 0 };\n        for (int i = 0; i < 4; i++) {\n            dfs(y + d[i], x + d[i + 1]);\n        }\n        c++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\n\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\tst = new StringTokenizer(sc.nextLine());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\t\t\tint h = Integer.parseInt(st.nextToken());\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tboolean[][] room = new boolean[h][w];\n\t\t\tString s;\n\t\t\tint posx, posy;\n\t\t\tposx = posy = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s.substring(j,j+1).equals(\".\"))\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\telse if (s.substring(j,j+1).equals(\"@\")) {\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\t\tposx = i;\n\t\t\t\t\t\tposy = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tint[] dx = {-1, 0, 1, 0};\n\t\t\tint[] dy = {0, -1, 0, 1};\n\t\t\t\n\t\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\tqx.add(posx);\n\t\t\tqy.add(posy);\n\t\t\tint ans = -1;\n\t\t\tint x, y;\n\t\t\twhile (!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tans++;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h \n\t\t\t\t\t\t\t&& y+dy[i] >= 0 && y+dy[i] < w\n\t\t\t\t\t\t\t&& room[x+dx[i]][y+dy[i]]) {\n\t\t\t\t\t\troom[x+dx[i]][y+dy[i]] = false;\n\t\t\t\t\t\tqx.add(x+dx[i]);\n\t\t\t\t\t\tqy.add(y+dy[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n    \npublic class Main {\n  private static Scanner sc = new Scanner(System.in);\n  public static void main(String...args) {\n    while(sc.hasNext()) {\n      final int W = sc.nextInt();\n      final int H = sc.nextInt();\n      if (W == 0 && H == 0)\n        break;\n      solve(W, H);\n    }\n  }\n  private static void solve(final int W, final int H) {\n    final char[][] map = new char[H][];\n    for(int i = 0; i < H; i++)\n      map[i] = sc.next().toCharArray();\n    final Deque<Integer> deq = new ArrayDeque<Integer>();\n    for(int i = 0; i < H; i++)\n      for(int j = 0; j < W; j++)\n        if(map[i][j] == '@')\n          deq.offer(i * W + j);\n    int ans = 0;\n    while(!deq.isEmpty()) {\n      ans++;\n      final int p = deq.poll();\n      final int i = p / W;\n      final int j = p % W;\n      for(int d = 0; d < 4; d++) {\n        final int ni = i + di[d];\n        final int nj = j + dj[d];\n        if(0 <= ni && ni < H && 0 <= nj && nj < W && map[ni][nj] == '.') {\n          map[ni][nj] = '#';\n          deq.offer(ni * W + nj);\n        }\n      }\n    }\n    System.out.println(ans);\n  }\n  private static final int[] di = { 1, 0, -1, 0};\n  private static final int[] dj = { 0, 1, 0, -1 };\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\t\n\tString[] tile;\n\tboolean[][] board;\n\n\tvoid doIt() {\n\t\tScanner stdIn =new Scanner(System.in);\n\n\t\twhile(stdIn.hasNext()) {\n\t\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\n\t\t\tint width = stdIn.nextInt();\n\t\t\tint height = stdIn.nextInt();\n\t\t\tif(width + height == 0) break;\n\t\t\ttile = new String[height];\n\t\t\tboard = new boolean[height][width];\n\t\t\tfor(int r = 0; r < height; r++) {\n\t\t\t\ttile[r] = stdIn.next();\n\t\t\t\tfor(int c = 0; c < width; c++) {\n\t\t\t\t\tif(tile[r].charAt(c) == '@') {\n\t\t\t\t\t\tqx.add(c);\n\t\t\t\t\t\tqy.add(r);\n\t\t\t\t\t\tboard[r][c] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[] fdx = new int[]{1, -1, 0, 0};\n\t\t\tint[] fdy = new int[]{0, 0, -1, 1};\n\t\t\tint count = 1;//既に現在地は訪れているので含めておく\n\t\t\twhile(!qx.isEmpty()) {\n\t\t\t\tint nowx = qx.poll();\n\t\t\t\tint nowy = qy.poll();\n\t\t\t\tfor(int r = 0; r < fdx.length; r++) {\n\t\t\t\t\tint nextx = nowx + fdx[r];\n\t\t\t\t\tint nexty = nowy + fdy[r];\n\t\t\t\t\tif(!(nextx >= 0 && nexty >= 0 && nextx < width && nexty < height)) continue;\n\t\t\t\t\tif(tile[nexty].charAt(nextx) != '#' && !board[nexty][nextx]) {\n\t\t\t\t\t\tqx.add(nextx);\n\t\t\t\t\t\tqy.add(nexty);\n\t\t\t\t\t\tboard[nexty][nextx] = true;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic int[] moveX = {0,0,-1,1};\n\tstatic int[] moveY = {-1,1,0,0};\n\tstatic char[][] map;\n\tstatic boolean[][] check;\n\tstatic int ans;\n\tstatic int x, y;\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\t\n\tvoid calc () {\n\n\t\twhile (true) {\n\t\t\t\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\n\t\t\tif (x == 0) break;\n\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\t\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic boolean t = true;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 || h == 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tint s_x = 0,s_y = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] tmp = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(tmp[j] == '@'){\n\t\t\t\t\t\ttmp[j] = '.';\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j] = tmp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\tlist.add((s_x << 16) + s_y);\n\t\t\tint count = 0;\n\t\t\t\n\t\t\twhile(!list.isEmpty()){\n\t\t\t\tint t = list.poll();\n\t\t\t\tint x = t >> 16;\n\t\t\t\tint y = t & 0x00ff;\n\t\t\t\t\n\t\t\t\tSystem.out.println(x + \",\" + y);\n\t\t\t\t\n\t\t\t\tif(map[y][x] == '.'){\n\t\t\t\t\tcount++;\n\t\t\t\t\tmap[y][x] = 'x';\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x > 0){\n\t\t\t\t\tlist.push(((x - 1) << 16) + y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < (w-1)){\n\t\t\t\t\tlist.push(((x + 1) << 16) + y);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y > 0){\n\t\t\t\t\tlist.push((x << 16) + (y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y < (h-1)){\n\t\t\t\t\tlist.push((x << 16) + (y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n    \npublic class Main {\n  private static Scanner sc = new Scanner(System.in);\n  public static void main(String...args) {\n    while(sc.hasNext()) {\n      final int W = sc.nextInt();\n      final int H = sc.nextInt();\n      if (W == 0 && H == 0)\n        break;\n      solve(W, H);\n    }\n  }\n  private static void solve(final int W, final int H) {\n    final char[][] map = new char[H][];\n    for(int i = 0; i < H; i++)\n      map[i] = sc.next().toCharArray();\n    final Deque<Integer> deq = new ArrayDeque<Integer>();\n    for(int i = 0; i < H; i++)\n      for(int j = 0; j < W; j++)\n        if(map[i][j] == '@')\n          deq.offer(i * W + j);\n    int ans = 0;\n    while(!deq.isEmpty()) {\n      final int p = deq.poll();\n      final int i = p / W;\n      final int j = p % W;\n      for(int d = 0; d < 4; d++) {\n        final int ni = i + di[d];\n        final int nj = j + dj[d];\n        if(0 <= ni && ni < H && 0 <= nj && nj < W && map[ni][nj] == '.') {\n          map[ni][nj] = '#';\n          deq.offer(ni * W + nj);\n          ans++;\n        }\n      }\n    }\n    System.out.println(ans);\n  }\n  private static final int[] di = { 1, 0, -1, 0};\n  private static final int[] dj = { 0, 1, 0, -1 };\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int w,h;\n\tstatic char map[][]=new char[25][25];\n\tstatic int dx[] = {0,1,0,-1};\n\tstatic int dy[] = {1,0,-1,0};\n\tstatic int[][] kioku =new int[25][25];\n\tstatic void dfs(int x,int y){\n\t\tif(x<0||x>=w||y<0||y>=h)return;\n\t\tif(kioku[y][x]!=0||map[y][x]=='#')return;\n\t\tkioku[y][x]=1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdfs(x+dx[i],y+dy[i]);\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tint sx=0,sy=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString test = in.next();\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tkioku[i][s]=0;\n\t\t\t\t\tmap[i][s]=test.charAt(s);\n\t\t\t\t\tif(test.charAt(s)=='@'){\n\t\t\t\t\t\tsx=s;sy=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx,sy);\n\t\t\tint result = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tresult += kioku[i][s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint x0 = 9, y0 = 9;\n\t\t// int count = 0;\n\t\tint[] count = new int[500];\n\t\tint dataset = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// StringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t// int x = Character.getNumericValue(sb.charAt(0));\n\t\t// int y = Character.getNumericValue(sb.charAt(2));\n\n\t\tfor (dataset = 0; dataset < 64; dataset++) {\n\n\t\t\tint k = 0;\n\t\t\tString str = br.readLine();\n\t\t\tString box[] = str.split(\" \");\n\t\t\tint x = Integer.parseInt(box[0]);\n\t\t\tint y = Integer.parseInt(box[1]);\n\n\t\t\tif (x == 0 && y == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\tboolean[][] can = new boolean[x][y];\n\t\t\t\tboolean[][] black = new boolean[x][y];\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\n\t\t\t\t\tStringBuffer sb = new StringBuffer(new String(br.readLine()));\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (sb.charAt(i) == '#') {\n\t\t\t\t\t\t\tblack[i][j] = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sb.charAt(i) == '@') {\n\t\t\t\t\t\t\t\tx0 = i;\n\t\t\t\t\t\t\t\ty0 = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tblack[i][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // iのループ\n\t\t\t\t} // jのループ\n\n\t\t\t\tcan[x0][y0] = true;\n\n\t\t\t\tint px = x0;\n\t\t\t\tint py = y0;\n\n\t\t\t\tdo {\n\t\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\t\tpx = i;\n\t\t\t\t\t\t\t\tpy = j;\n\n\t\t\t\t\t\t\t\tif (py > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px][py - 1]) {// 上\n\t\t\t\t\t\t\t\t\t\tcan[px][py - 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (py < y - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px][py + 1]) {// 下\n\t\t\t\t\t\t\t\t\t\tcan[px][py + 1] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px > 0) {\n\t\t\t\t\t\t\t\t\tif (black[px - 1][py]) {// 左\n\t\t\t\t\t\t\t\t\t\tcan[px - 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (px < x - 1) {\n\t\t\t\t\t\t\t\t\tif (black[px + 1][py]) {// 右\n\t\t\t\t\t\t\t\t\t\tcan[px + 1][py] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t} while (k < x * y);\n\n\t\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\t\tfor (int i = 0; i < x; i++) {\n\t\t\t\t\t\tif (can[i][j]) {\n\t\t\t\t\t\t\tcount[dataset]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (dataset = 0; dataset < 500; dataset++) {\n\t\t\tif (count[dataset] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count[dataset]);\n\t\t}\n\n\t}// main\n\n}// class\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint x, y;\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\twhile (x != 0) {\n\t\t\tchar map[][] = new char[y][x];\n\t\t\tload(sc, map);\n\t\t\tQueue<Point> que = new LinkedList<Point>();\n\t\t\tfor (int i = 0;i < map.length;i ++) {\n\t\t\t\tfor (int j = 0;j < map[i].length;j ++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tque.add(new Point(j, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dx[] = {-1, 0, 1, 0};\n\t\t\tint dy[] = {0, 1, 0, -1};\n\t\t\tint count = 0;\n\t\t\twhile(!que.isEmpty()) {\n\t\t\t\tPoint p = que.poll();\n\t\t\t\tif (p.x < 0 || p.x >= x || p.y < 0 || p.y >= y) continue;\n\t\t\t\tif (map[p.y][p.x] == '#') continue;\n\t\t\t\tcount ++;\n\t\t\t\tmap[p.y][p.x]= '#'; \n\t\t\t\tfor (int i = 0;i < 4;i ++) {\n\t\t\t\t\tque.add(new Point(p.x + dx[i], p.y + dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static char[][] load(Scanner sc, char[][] map) {\n\t\tfor (int i = 0;i < map.length;i ++) {\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t}\n\t\treturn map;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h;\n    char[][] map;\n    int c;\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n\n    void run(){\n\twhile(true){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(h==0 && w==0) break;\n\t    c = 1;\n\t    map = new char[h][w];\n\t    int sx=0, sy=0;\n\t\n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tmap[i] = s.toCharArray();\n\t\tfor(int k=0; k<w; k++)\n\t\t    if(map[i][k]=='@'){\n\t\t\tsx = k;\n\t\t\tsy = i;\n\t\t    }\n\t    }\n\n\t    solve(sx, sy);\n\t    System.out.println(c);\n\t}\n    }\n\n    void solve(int x, int y){\n\tint p, q;\n\tStack<int[]> st = new Stack<int[]>();\n\t\n\tfor(int i=0; i<4; i++){\n\t    p = x+dx[i];\n\t    q = y+dy[i];\n\t    if(p<0 || p>=w || q<0 || q>=h) continue;\n\t    if(map[q][p]=='.'){\n\t\t//System.out.println(q+\" \"+p);\n\t\tst.push(new int[]{q, p});\n\t    }\n\t}\n\t\n\twhile(!st.isEmpty()){\n\t    int[] a = st.pop();\n\t    x = a[1];\n\t    y = a[0];\n\t    //System.out.println(map[y][x]+\" \"+y+\" \"+x);\n\t    if(map[y][x]!='.') continue;\n\t    for(int i=0; i<4; i++){\n\t\tp = x+dx[i];\n\t\tq = y+dy[i];\n\t\tif(p<0 || p>=w || q<0 || q>=h) continue;\n\t\tif(map[q][p]=='.'){\n\t\t    //System.out.println(q+\" \"+p);\n\t\t    st.push(new int[]{q, p});\n\t\t}\n\t    }\n\t    c++;\n\t    map[y][x] = '#';\n\t}\n    }\n}\n\t\t    "
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static Scanner sc = new Scanner(System.in);\n    static int w,h;\n    static char[][] map;\n    static int[] dx = {-1, 0, 0, 1};\n    static int[] dy = { 0,-1, 1, 0}; \n    \n    \n    public static void main(String[] args){\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0&&h==0)break;\n            \n            map = new char[h][w];\n            \n            for(int i=0;i<h;i++){\n                map[i] = sc.next().toCharArray();\n            }\n            loop:\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(map[i][j]=='@'){\n                        dfs(j,i);\n                        break loop;\n                    }\n                }\n            }\n            \n            int ans=0;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    if(map[i][j]=='*'){\n                        ans++;\n                    }\n                }\n            }\n            \n            System.out.println(ans);\n            \n        }\n        \n    }\n    \n    static void dfs(int x,int y){\n        map[y][x]='*';\n        for(int i=0;i<4;i++){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if(nx>=0 && nx<w && ny>=0 && ny<h && map[ny][nx]=='.'){\n                dfs(nx,ny);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w=sc.nextInt();\n\t\t\tint h=sc.nextInt();\n\t\t\tString gomi = sc.nextLine();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tint start_w=0,start_h=0;\n\t\t\tfor(int i=1;i<=h;++i){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString[] line2=line.split(\"\");\n\t\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\t\tif(line2[j].equals(\".\")){\n\t\t\t\t\t\tmap[i][j+1]=1;\n\t\t\t\t\t} else if(line2[j].equals(\"@\")){\n\t\t\t\t\t\tmap[i][j+1]=2;\n\t\t\t\t\t\tstart_w=j+1; start_h=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count=1;\n\t\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\t\tqueue.add(new Node(start_h, start_w));\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode cur = queue.remove();\n\t\t\t\tif(map[cur.h-1][cur.w]==1){\n\t\t\t\t\tcount++; map[cur.h-1][cur.w]=0;\n\t\t\t\t\tqueue.add(new Node(cur.h-1,cur.w));\n\t\t\t\t}\n\t\t\t\tif(map[cur.h+1][cur.w]==1){\n\t\t\t\t\tcount++; map[cur.h+1][cur.w]=0;\n\t\t\t\t\tqueue.add(new Node(cur.h+1,cur.w));\n\t\t\t\t}\n\t\t\t\tif(map[cur.h][cur.w-1]==1){\n\t\t\t\t\tcount++; map[cur.h][cur.w-1]=0;\n\t\t\t\t\tqueue.add(new Node(cur.h,cur.w-1));\n\t\t\t\t}\n\t\t\t\tif(map[cur.h][cur.w+1]==1){\n\t\t\t\t\tcount++; map[cur.h][cur.w+1]=0;\n\t\t\t\t\tqueue.add(new Node(cur.h,cur.w+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n\nclass Node{\n\tint h,w;\n\tNode(int w,int h){\n\t\tthis.h=w;\n\t\tthis.w=h;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic boolean solve() {\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tint sy = -1, sx = -1;\n\n\t\tchar[][] table = new char[h][w];\n\t\tfor (int i=0; i<h; i++) {\n\t\t\ttable[i] = in.next().toCharArray();\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (table[i][j] == '@') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dx = { 0, 1, 0,-1};\n\t\tint[] dy = { 1, 0,-1, 0};\n\n\t\tArrayDeque<Integer> que = new ArrayDeque<>();\n\t\tint cnt = 0;\n\t\tque.add(sy*w+sx);\n\n\t\tboolean[][] visited = new boolean[h][w];\n\t\tvisited[sy][sx] = true;\n\n\t\twhile (que.size() > 0) {\n\t\t\tint c = que.pollFirst();\n\t\t\tcnt++;\n\t\t\tint cy = c/w, cx = c%w;\n\t\t\tfor (int k=0; k<4; k++) {\n\t\t\t\tint ny = cy + dy[k], nx = cx + dx[k];\n\t\t\t\tif (ny < 0 || nx < 0 || h <= ny || w <= nx) continue;\n\t\t\t\tif (table[ny][nx] == '#' || visited[ny][nx]) continue;\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\tque.add(ny*w+nx);\n\t\t\t}\n\t\t}\n\n\t\tout.println(cnt);\n\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n   public static void main(String a[]) throws java.io.IOException{\n       Scanner scan =new Scanner (System.in);\n       Pair pair= new Pair();\n       Queue<Pair> fifo = new LinkedList<Pair>();\n\n       while(true){\n           int W =scan.nextInt();\n           int H =scan.nextInt();\n           if((W|H)==0)break;\n           String [][] map = new String[H][W];\n           for(int i=0;i<H;i++){\n               String [] tmp =scan.next().split(\"\\\\B\");\n               for(int j=0;j<W;j++){\n                   map[i][j] = tmp[j];\n                   if(tmp[j].equals(\"@\")){\n                       pair.x=j;\n                       pair.y=i;\n                       fifo.add(pair);\n                   }\n               }\n           }\n          int count =0;\n          while(fifo.peek()!=null){  \n           pair = fifo.poll();\n           int x=pair.x;\n           int y=pair.y;\n           int[] dx ={0,1,0,-1};\n           int[] dy ={1,0,-1,0};\n           map[y][x] = \"#\";\n          for(int i=0;i<4;i++){\n              int nx =x+dx[i];\n              int ny =y+dy[i];\n              if(0<=nx&&nx<W&&0<=ny&&ny<H&&!(map[ny][nx].equals(\"#\"))){\n                  pair.x=nx;\n                  pair.y=ny;\n                  fifo.add(pair);\n                  count++;\n              }\n          }\n          }\n          System.out.println(count);\n\n       }\n       }\n}\n\nclass Pair{\n    public int x;\n    public int y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\n\t\t\tint[][] map = new int[m][n];\n\t\t\tInteger[] start = new Integer[2];\n\t\t\tint island = 1;\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = scanner.next();\n\t\t\t\tfor (int j = 0; j < line.length(); j++) {\n\t\t\t\t\tchar place = line.charAt(j);\n\t\t\t\t\tif (place == '.') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (place == '@') {\n\t\t\t\t\t\tstart[0] = i;\n\t\t\t\t\t\tstart[1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDeque<Integer[]> deque = new ArrayDeque<>();\n\t\t\tdeque.addFirst(start);\n\t\t\twhile (deque.size() > 0) {\n\t\t\t\tInteger[] poll = deque.pollFirst();\n\t\t\t\tif (poll[0] > 0 && map[poll[0] - 1][poll[1]] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0] - 1, poll[1] };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0] - 1][poll[1]] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[0] < m - 1 && map[poll[0] + 1][poll[1]] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0] + 1, poll[1] };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0] + 1][poll[1]] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[1] > 0 && map[poll[0]][poll[1] - 1] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0], poll[1] - 1 };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0]][poll[1] - 1] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[1] < n - 1 && map[poll[0]][poll[1] + 1] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0], poll[1] + 1 };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0]][poll[1] + 1] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(island);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nextChar() {\n\t\ttry {\n\t\t\tint b = System.in.read();\n\t\t\twhile (b != -1 && (b == ' ' || b == '\\r' || b == '\\n'))\n\t\t\t\t;\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * AOJ id=1130\n * Red and Black\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0) break;\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tsolve(map);\n\t\t}\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map;\n\tpublic void solve(char[][] map) {\n\t\tint sx = -1;\n\t\tint sy = -1;\n\t\tfor(int i=0;i<map.length;i++){\n\t\t\tfor(int j=0;j<map[i].length;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sx>=0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(rec(sx, sy));\n\t\t\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tprivate int rec(int curx, int cury) {\n\t\tif(map[cury][curx]=='#')\n\t\t\treturn 0;\t\n\t\t\n\t\tmap[cury][curx] = '#';\n\t\tint res = 1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = curx + dx[i];\n\t\t\tint ny = cury + dy[i];\n\t\t\t\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\tcontinue;\n\t\t\tres += rec(nx, ny);\n\t\t}\n\t\t\n\t\t\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    static int n,m;\n    static boolean[][] ss;\n    static int cnt;\n\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n\n        // ?????????????§???????\n        String[] a;\n        while(true) {\n            a = GetSubStringLine();\n            m = Integer.parseInt(a[0]);\n            n = Integer.parseInt(a[1]);\n            if (m == 0 && n == 0) {\n                break;\n            }\n            ss = new boolean[n][m];\n            int x = 0,y = 0;\n            cnt = 0;\n            for (int i=0;i<n;i++) {\n                String sss = sc.nextLine();\n                for (int j=0;j<sss.length();j++) {\n                    switch (sss.charAt(j)) {\n                        case '.':\n                            ss[i][j] = true;\n                            break;\n                        case '#':\n                            ss[i][j] = false;\n                            break;\n                        case '@':\n                            ss[i][j] = true;\n                            x = j;\n                            y = i;\n                            break;\n                    }\n                }\n            }\n            dfs(y,x);\n            System.out.println(cnt);\n        }\n    }\n\n    static void dfs(int y, int x) {\n        if (y < 0 || y >= n || x < 0 || x>= m) {\n            return;\n        }\n        if (!ss[y][x]) {\n            return;\n        }\n        ss[y][x] = false;\n        cnt++;\n        dfs(y-1,x);\n        dfs(y,x-1);\n        dfs(y+1,x);\n        dfs(y,x+1);\n    }\n\n    public static String[] GetSubStringLine() {\n        String s = sc.nextLine();\n        return s.split(\" \");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint[][] land,looked;\n\tint sx,sy,w,h,count;\n\tint[] dx={-1,1,0,0},dy={0,0,-1,1};\n\t\n\tScanner stdin =new Scanner(System.in);\n\tQueue qx=new LinkedList();Queue qy=new LinkedList();\n\t\n\t\n\tvoid Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tw=stdin.nextInt();\n\t\t\th=stdin.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tland=new int[h][w];\n\t\t\tlooked=new int[h][w];\n\t\t\tcount=1;\n\t\t\t\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s=stdin.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s.charAt(j)=='.') land[i][j]=1;\n\t\t\t\t\telse if(s.charAt(j)=='@'){\n\t\t\t\t\t\tland[i][j]=0;\n\t\t\t\t\t\tsx=i;\n\t\t\t\t\t\tsy=j;\n\t\t\t\t\t}else land[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tlooked=land.clone();\n\t\t//System.out.println(land[5][8]);\n\t\tbfs(sx,sy);\n\t\tSystem.out.println(count);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tvoid bfs(int sx,int sy){\n\t\t//System.out.println(sx+\" \"+sy);\n\t\tlooked[sx][sy]=0;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint xx=sx+dx[i];\n\t\t\tint yy=sy+dy[i];\n\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w){\n\t\t\t\tif(land[xx][yy]==1){\n\t\t\t\t\tif(looked[xx][yy]==1)count++;\n\t\t\t\t\tbfs(xx,yy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static int[] moveX = {0,0,-1,1};\n\tpublic static int[] moveY = {-1,1,0,0};\n\tpublic static char[][] map;\n\tpublic static boolean[][] check;\n\tpublic static int ans, x, y;\n\t\n\tpublic static boolean read () {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\n\t\tif (x == 0 && y == 0) return false;;\n\n\t\tans = 0;\n\t\tmap = new char[y][x];\n\t\tcheck = new boolean[y][x];\n\n\t\tfor (int i = 0; i < y; i++)\n\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void dfs (int y, int x) {\n\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\t\n\tpublic static void calc () {\n\t\t\n\t\twhile (read()) {\n\t\t\tmain:\n\t\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\t\tbreak main;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (boolean[] ch : check) {\n\t\t\t\t\tfor (boolean c : ch)\n\t\t\t\t\t\tif (c) ans++;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main (String[] args) {\n\t\t\n\t\tMain.calc();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        while(true){\n\t        int w = sc.nextInt();\n    \t    int h = sc.nextInt();\n        \tif(w==0 && h==0){\n        \t\tbreak;\n        \t}\n        \tString[] str = new String[h];\n        \tint start_x = 0;\n        \tint start_y = 0;\n        \tint[] dx = {-1,0,1,0};\n        \tint[] dy = {0,-1,0,1};\n        \tboolean[][] judge = new boolean[w][h];\n        \tfor(int i=0;i<h;i++){\n        \t\tstr[i] = sc.next();\n        \t\tfor(int j=0;j<w;j++){\n        \t\t\tif(str[i].charAt(j)=='@'){\n        \t\t\t\tstart_x = j;\n        \t\t\t\tstart_y = i;\n        \t\t\t}\n        \t\t}\n        \t}\n        \tjudge[start_x][start_y] = true;\n        \tArrayList<Point> list = new ArrayList<Point>();\n        \tPoint point = new Point(start_x,start_y);\n        \tlist.add(point);\n        \tint count = 1;\n        \twhile(!list.isEmpty()){\n        \t\tpoint = list.get(0);\n        \t\tlist.remove(0);\n        \t\tfor(int i=0;i<4;i++){\n        \t\t\tif(point.x==0 && i==0){\n        \t\t\t\tcontinue;\n        \t\t\t}\n        \t\t\telse if(point.x==w-1 && i==2){\n        \t\t\t\tcontinue;\n        \t\t\t}\n        \t\t\telse if(point.y==0 && i==1){\n        \t\t\t\tcontinue;\n        \t\t\t}\n        \t\t\telse if(point.y==h-1 && i==3){\n        \t\t\t\tcontinue;\n        \t\t\t}\n        \t\t\tif(str[point.y+dy[i]].charAt(point.x+dx[i])=='.' && !judge[point.x+dx[i]][point.y+dy[i]]){\n        \t\t\t\tPoint p = new Point(point.x+dx[i],point.y+dy[i]);\n        \t\t\t\tlist.add(p);\n        \t\t\t\tjudge[p.x][p.y] = true;\n        \t\t\t\tcount++;\n        \t\t\t}\n        \t\t}\n        \t}\n        \tout.println(count);\n        \tout.flush();\n        \t}\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\tsearch(input, input.nextInt(), input.nextInt());\n\t}\n\t\n\tpublic static void search(Scanner input, int x, int y){\n\t\tQueue<Integer> xqueue = new LinkedList<Integer>();\n\t\tQueue<Integer> yqueue = new LinkedList<Integer>();\n\t\t\n\t\tint X; int Y;\n\t\t\n\t\t\n\t\t\n\t\tString[][] grid;\n\t\tint[][] visit;\n\t\tint currentX = 0;; int currentY = 0;\n\n\t\tX = x;\n\t\tY = y;\n\t\tif(X == 0 && Y ==0){\n\t\t\tSystem.exit(0);\n\t\t}\n\t\t\n\t\tgrid = new String[Y][X];\n\t\tvisit = new int[Y][X];\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tString[] tmp = input.next().split(\"\");\n\t\t\tfor(int z = 1; z < tmp.length; z++){\n\t\t\t\tgrid[i][z-1] = tmp[z];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(grid[i][j].equals(\"@\")){\n\t\t\t\t\tcurrentX = j; currentY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tyqueue.offer(currentY);\n\t\txqueue.offer(currentX);\n\t\t\t\t\t\t\t\t\n\t\twhile(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\n\t\t\tif(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\tcurrentY = yqueue.poll();\n\t\t\t\tcurrentX = xqueue.poll();\n\t\t\t}\n\t\t\t\n\t\t\tif(visit[currentY][currentX] == 0 && !(grid[currentY][currentX].equals(\"#\"))){\n\t\t\t\tvisit[currentY][currentX] = 1;\n\t\t\t\tif(currentY > 0 && currentY < Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < visit.length; i++){\n\t\t\tfor(int j = 0; j < visit[i].length; j++){\n\t\t\t\tif(visit[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t\tsearch(input, input.nextInt(), input.nextInt());\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tstatic int[] v1 = { 0, 1, 0, -1 };\n\tstatic int[] v2 = { 1, 0, -1, 0 };\n\tstatic int[][] field;\n\tstatic int count = 0;\n\tpublic static void main(String[] args) {\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = cin.nextInt();\n\t\t\tint h = cin.nextInt();\n\t\t\tif(w+h==0){break;}\n\t\t\t\n\t\t\tint startx = 0, starty = 0;\n\t\t\tcount=0;\n\t\t\tfield = new int[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tString str = cin.next();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (str.charAt(j-1) == '.') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t} else if (str.charAt(j-1) == '#') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (str.charAt(j-1) == '@') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tstartx = i;\n\t\t\t\t\t\tstarty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tInteger[] start = {startx,starty};\n\t\t\tStack<Integer[]> s = new Stack<Integer[]>();\n\t\t\ts.add(start);\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tInteger[] a = s.pop();\n\t\t\t\tcount++;\n\t\t\t\tfield[a[0]][a[1]]=2;\n\t\t\t\tfor(int i = 0;i<4;i++){\n\t\t\t\t\tint xx = a[0]+v1[i];\n\t\t\t\t\tint yy = a[1]+v2[i];\n\t\t\t\t\tif(field[xx][yy]==1){\n\t\t\t\t\t\tInteger[] next={xx,yy};\n\t\t\t\t\t\ts.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tstatic int H,W;\n\tstatic int f[][];\n\tstatic int dx[]={1,-1,0,0};\n\tstatic int dy[]={0,0,1,-1};\n\tstatic int cnt;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tint sw=-1;\n\t\t\tint sh=-1;\n\t\t\tf=new int[H][W];\n\t\t\tcnt=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString s=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(s.charAt(j)=='#')\n\t\t\t\t\t\tf[i][j]=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tf[i][j]=0;\n\n\t\t\t\t\tif(s.charAt(j)=='@')\n\t\t\t\t\t{\n\t\t\t\t\t\tsw=j;\n\t\t\t\t\t\tsh=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(sw,sh));\n\t\t}\n\t}\n\n\tstatic  int dfs(int w,int h)\n\t{\n\t\tcnt++;\n\t\tf[h][w]=1;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nw=dx[i]+w;\n\t\t\tint nh=dy[i]+h;\n\t\t\tif(nw>=0&&nw<W&&nh>=0&&nh<H&&f[nh][nw]==0)\n\t\t\t\tdfs(nw,nh);\n\t\t}\n\t\treturn cnt;\n\t}\n\tstatic public void debug(Object... o)\n\t{\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  boolean[][] done;\n  char[][] field;\n\n  int[][] ofs = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\n\n  int dfs(int x, int y) {\n    if ( done[ y ][ x ] || field[ y ][ x ] == '#' )\n      return 0;\n\n    int sum = 1;\n    done[ y ][ x ] = true;\n    for ( int[] d : ofs ) {\n      sum += dfs( x + d[ 0 ], y + d[ 1 ] );\n    }\n\n    return sum;\n  }\n\n  void run() {\n    for ( ;; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n\n      if ( ( w | h ) == 0 ) {\n        break;\n      }\n\n      done = new boolean[h + 2][w + 2];\n      field = new char[h + 2][w + 2];\n\n      for ( int i = 0; i < h + 2; ++i ) {\n        for ( int j = 0; j < w + 2; ++j ) {\n          field[ i ][ j ] = '#';\n        }\n      }\n\n      int sx = 0;\n      int sy = 0;\n      for ( int i = 1; i <= h; ++i ) {\n        char[] str = ns().toCharArray();\n        for ( int j = 1; j <= w; ++j ) {\n          field[ i ][ j ] = str[ j - 1 ];\n          if ( field[ i ][ j ] == '@' ) {\n            sx = j;\n            sy = i;\n          }\n        }\n      }\n\n      System.out.println( dfs( sx, sy ) );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  String ns() {\n    return sc.next();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass P\n{\n\tint x;\n\tint y;\n\tP(int x, int y)\n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\npublic class Main \n{\n\tstatic int[] dx = {1, 0, -1, 0};\n\tstatic int[] dy = {0, -1, 0, 1};\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(stdIn.hasNext())\n\t\t{\n\t\t\tint W = stdIn.nextInt();\n\t\t\tint H = stdIn.nextInt();\n\t\t\tif(W == 0 && H == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tQueue<P> que = new ArrayDeque<P>();\n\t\t\tfor(int i = 0; i < H; ++i)\n\t\t\t{\n\t\t\t\tString s = stdIn.next();\n\t\t\t\tfor(int j = 0; j < W; ++j)\n\t\t\t\t{\n\t\t\t\t\tif(s.charAt(j) == '@')\n\t\t\t\t\t{\n\t\t\t\t\t\tP p = new P(j, i);\n\t\t\t\t\t\tque.add(p);\n\t\t\t\t\t\tfield[i][j] = '#';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfield[i][j] = s.charAt(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 1;\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor(int i = 0; i < dx.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tP np = new P(0, 0);\n\t\t\t\t\tnp.x = p.x + dx[i];\n\t\t\t\t\tnp.y = p.y + dy[i];\n\t\t\t\t\tif((0 <= np.x && np.x < W) && (0 <= np.y && np.y < H) && field[np.y][np.x] == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\tque.add(np);\n\t\t\t\t\t\tfield[np.y][np.x] = '#';\n\t\t\t\t\t\t++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main {\n\tstatic int w,h,sx,sy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};\n\tstatic String[] field;\n\tstatic boolean[][] visited;\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0 && h == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfield = new String[h];\n\t\t\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfield[i] = sc.next();\n\t\t\tint tmp = field[i].indexOf('@');\n\t\t\tif(tmp != -1) {\n\t\t\t\tsy = i; sx = tmp;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tvisited = new boolean[h][w];\n\t\tQueue<Point> que = new LinkedList<Point>();\n\t\tPoint s = new Point(sx, sy);\n\t\t\n\t\tque.add(s);\n\t\tvisited[sy][sx] = true;\n\t\tint ans = 1;\n\t\twhile(!que.isEmpty()) {\n\t\t\tPoint p = que.poll();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tPoint next = new Point(p.x + dx[i], p.y + dy[i]);\n\t\t\t\tif(!inField(next) || field[next.y].charAt(next.x) == '#' || visited[next.y][next.x] == true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tque.add(next);\n\t\t\t\t\tvisited[next.y][next.x] = true;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic boolean inField(Point p) {\n\t\tif(p.x >= 0 && p.x < w && p.y >= 0 && p.y < h) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans;\n\tint x, y;\n\n\tvoid calc () {\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tif (x == 0) break;\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tint w, h;\n\tchar[][] map;\n\t\n\tint count;\n\t\n\tvoid dfs(int x, int y) {\n\t\tint[] dx = new int[]{0, 0, -1, 1};\n\t\tint[] dy = new int[]{1, -1, 0, 0};\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h && map[ny][nx] == '.') {\n\t\t\t\tmap[ny][nx] = '#';\n\t\t\t\tcount++;\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint solve() {\n\t\tcount = 1;\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tif (map[y][x] == '@') {\n\t\t\t\t\tdfs(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString output = \"\";\n\t\twhile (sc.hasNext()) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif (w == 0 && h == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsc.skip(\"\\n\");\n\t\t\t\tmap = new char[h][];\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tString row = sc.nextLine();\n\t\t\t\t\tmap[i] = row.toCharArray();\n\t\t\t\t}\n\t\t\t\toutput += solve() + \"\\n\";\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.print(output);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\tstatic class P{\n\t\tint x;\n\t\tint y;\n\t\tpublic P(int x,int y){\n\t\t\tthis.x=x;this.y=y;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(!(obj instanceof P))return false;\n\t\t\tP p=(P)obj;\n\t\t\treturn p.x==x && p.y==y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tTest:while(true){\n\t\t\tint w=sc.nextInt(),h=sc.nextInt();\n\t\t\tif(w==0 && h==0)return;\n\t\t\tboolean[][] wall=new boolean[h][w];\n\t\t\tQueue<P> pq=new LinkedList<P>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] mc=sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tswitch(mc[j]){\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\twall[i][j]=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\twall[i][j]=true;\n\t\t\t\t\t\tpq.offer(new P(j,i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res=1;\n\n\t\t\tint[][] d=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tP p=pq.poll();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint x=p.x+d[i][0];\n\t\t\t\t\tint y=p.y+d[i][1];\n\t\t\t\t\tif(0<=x && x<w && 0<=y && y<h){\n\t\t\t\t\t\tif(!wall[y][x]){\n\t\t\t\t\t\t\twall[y][x]=true;\n\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t\tpq.add(new P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(res);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic int[] nextIntArray(int n){\n\t\tint[] res=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres[i]=sc.nextInt();\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void pr(Object o) {\n\t\tout.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tout.println(o);\n\t}\n\tpublic static void ln() {\n\t\tout.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    private static boolean[][] fld;\n\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int w = 0;\n            int h = 0;\n            int y = 0;\n            int x = 0;\n            while((w = scn.nextInt()) > 0 | (h = scn.nextInt()) > 0) {\n                fld = new boolean[h][w];\n                for(int i = 0; i < h; i++) {\n                    char[] ary = scn.next().toCharArray();\n                    for(int j = 0; j < w; j++) {\n                        switch(ary[j]) {\n                            case '@':\n                                y = i;\n                                x = j;\n                            case '.':\n                                fld[i][j] = true;\n                                break;\n                            case '#':\n                                fld[i][j] = false;\n                                break;\n                            default:\n                                assert false;\n                        }\n                    }\n                }\n                System.out.println(count(y, x));\n            }\n        }\n    }\n\n    public static int count(int y, int x) {\n        int rslt = 0;\n        try {\n            if(fld[y][x]) {\n                fld[y][x] = false;\n                rslt += count(~-y, x);\n                rslt += count(y, ~-x);\n                rslt += count(y, -~x);\n                rslt += count(-~y, x);\n                rslt++;\n            }\n        } catch(ArrayIndexOutOfBoundsException ignore) {}\n        return rslt;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int w,h;\n\tstatic char map[][]=new char[21][21];\n\tstatic int dx[] = {0,1,0,-1};\n\tstatic int dy[] = {1,0,-1,0};\n\tstatic int max=9999999;\n\tstatic int[][] kioku =new int[21][21];\n\tstatic void dfs(int x,int y,int sum){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = dx[i]+x;\n\t\t\tint ny = dy[i]+y;\n\t\t\tif(nx<0|nx>=w||ny<0||ny>=h||map[ny][nx]=='#'||kioku[ny][nx]!=max)continue;\n\t\t\tkioku[ny][nx]=1;\n\t\t\tdfs(nx,ny,sum+1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw=in.nextInt();\n\t\t\th=in.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tint sx=0,sy=0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString test = in.next();\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tkioku[i][s]=max;\n\t\t\t\t\tmap[i][s]=test.charAt(s);\n\t\t\t\t\tif(test.charAt(s)=='@'){\n\t\t\t\t\t\tsx=s;sy=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx,sy,0);\n\t\t\tint result = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int s=0;s<w;s++){\n\t\t\t\t\tif(kioku[i][s]==max)continue;\n\t\t\t\t\tresult += kioku[i][s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(result);\n\t\t}\n\n\n\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/*\n * stackバージョン\n * なぜかWrong answer。。。\n */\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tstatic int[] v1 = { 0, 1, 0, -1 };\n\tstatic int[] v2 = { 1, 0, -1, 0 };\n\tstatic int[][] field;\n\tstatic int count = 0;\n\tpublic static void main(String[] args) {\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = cin.nextInt();\n\t\t\tint h = cin.nextInt();\n\t\t\tif(w+h==0){break;}\n\t\t\t\n\t\t\tint startx = 0, starty = 0;\n\t\t\tcount=0;\n\t\t\tfield = new int[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tString str = cin.next();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (str.charAt(j-1) == '.') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t} else if (str.charAt(j-1) == '#') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (str.charAt(j-1) == '@') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t\tstartx = i;\n\t\t\t\t\t\tstarty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tInteger[] start = {startx,starty};\n\t\t\tStack<Integer[]> s = new Stack<Integer[]>();\n\t\t\ts.add(start);\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tInteger[] a = s.pop();\n\t\t\t\tcount++;\n\t\t\t\tfor(int i = 0;i<4;i++){\n\t\t\t\t\tint xx = a[0]+v1[i];\n\t\t\t\t\tint yy = a[1]+v2[i];\n\t\t\t\t\tif(field[xx][yy]==1){\n\t\t\t\t\t\tInteger[] next={xx,yy};\n\t\t\t\t\t\tfield[xx][yy]=2;\n\t\t\t\t\t\ts.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n//1130 Red and Black\n\npublic class Main {\n\tint height,width,startx,starty;\n\tScanner sc = new Scanner(System.in);\n\tchar[][] field;\n\tboolean[][] visited;\n\tint count = 0;\n\tvoid run(){\n\t\tsc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tcount = 0;\n\t\t\twidth = sc.nextInt();\n\t\t\theight = sc.nextInt();\n\t\t\tif(width == 0 && height == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tfield = new char[height][width];\n\t\t\tvisited = new boolean[height][width];\n\t\t\tfor(int i = 0; i < visited.length; i++){\n\t\t\t\tfor(int j = 0; j < visited[i].length; j++){\n\t\t\t\t\tvisited[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < height; i++){\n\t\t\t\tfield[i] = sc.nextLine().toCharArray();\n\t\t\t\t//System.out.println(field[i]);\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < field.length;i++){\n\t\t\t\tfor(int j = 0; j < field[i].length; j++){\n\t\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\t\tstartx = j;\n\t\t\t\t\t\tstarty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t\tdfs(starty,startx);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tpublic void dfs(int y, int x){\n\t\tif(y + 1 < height && visited[y+1][x] == false && field[y+1][x] == '.'){\n\t\t\tvisited[y+1][x] = true;\n\t\t\tcount++;\n\t\t\tdfs(y+1,x);\n\t\t}\n\t\tif(y - 1 > -1 && visited[y-1][x] == false && field[y-1][x] == '.'){\n\n\t\t\tvisited[y-1][x] = true;\n\t\t\tcount++;\n\t\t\tdfs(y-1,x);\n\t\t}\n\t\tif(x + 1 < width && visited[y][x+1] == false && field[y][x+1] == '.'){\n\t\t\tvisited[y][x+1] = true;\n\t\t\tcount++;\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\tif(x - 1 > -1 && visited[y][x-1] == false && field[y][x-1] == '.'){\n\t\t\tvisited[y][x-1] = true;\n\t\t\tcount++;\n\t\t\tdfs(y,x-1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class RedAndBlack {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class Main {\n\n  int H,W;\n  int sy,sx;\n  int cnt;\n  boolean[][] map;\n  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; \n  public static void main(String[] args) {\n    new Main().run();\n  }\n  public void run() {\n\n    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out) ) {\n\n      String[] lines;\n      // StringBuilder buf = new StringBuilder();\n      while(true) {\n        lines = in.readLine().split(\" \");\n        W = Integer.parseInt(lines[0]);\n        H = Integer.parseInt(lines[1]);\n\n        if( W==0 && H==0) break;\n\n        map = new boolean[H][W];\n\n        String line;\n        for(int y=0; y<H; y++) {\n          char ch;\n          line = in.readLine();\n          for(int x=0; x<W; x++) {\n            ch = line.charAt(x);\n            map[y][x] = ch == '#' ? false : true;\n            if(ch == '@') {\n              sy = y; sx = x;\n            }\n          }\n        }\n\n        cnt = 0;\n        dfs(sy,sx);\n        // buf.append(cnt).append(\"\\n\");\n        out.println(cnt);\n      }\n\n      // System.out.print(buf);\n      out.flush();\n    }\n    catch(IOException e) {\n      System.err.println(e);\n    }\n  }\n\n  private void dfs(int y, int x) {\n    map[y][x] = false;\n    cnt++;\n\n    for(int i=0; i<4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {\n        dfs(ny,nx);\n      }\n    }\n    return;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static boolean visited[][];\n\tpublic static String[][] map;\n\tstatic int numberOfBlack;\n\t\n\tpublic static void CheckBlackTiles(int a, int b,int w,int h) {\n\t\tnumberOfBlack++;\n\t\tvisited[a][b] = true;\n\t\tif(a+1<h && map[a+1][b].equals(\".\")&& visited[a+1][b]==false) {\n\t\t\tCheckBlackTiles(a+1,b,w,h);\n\t\t}\n\t\tif(a-1>=0 && map[a-1][b].equals(\".\")&& visited[a-1][b]==false) {\n\t\t\tCheckBlackTiles(a-1,b,w,h);\n\t\t}\n\t\tif(b+1<w && map[a][b+1].equals(\".\") && visited[a][b+1]==false) {\n\t\t\tCheckBlackTiles(a,b+1,w,h);\n\t\t}\n\t\tif(b-1>=0 && map[a][b-1].equals(\".\") && visited[a][b-1]==false) {\n\t\t\tCheckBlackTiles(a,b-1,w,h);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w;\n\t\tint h;\n\t\t\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w==0||h==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tnumberOfBlack=0;\n\t\t\tmap = new String[h][w];\n\t\t\tvisited = new boolean[h][w];\n\n\t\t\t\n\t\t\tfor(int i=0; i<h;i++){    \n                String buffer=in.next();\n                //文字列格納後に1文字ずつ分離\n                for(int l=0; l<buffer.length();l++) {\n                \tmap[i][l]= String.valueOf(buffer.charAt(l));\n                \tvisited[i][l]= false;\n                }\n\t\t\t}\n\n\t\t\tfor(int i=0; i<h;i++){\n                for(int k=0; k<w;k++){\n                \tif(map [i][k].equals(\"@\")&&visited[i][k]==false){\n                \t\tCheckBlackTiles(i,k,w,h);\n                    }\n                }      \n\t\t\t}\n\t\t\tSystem.out.println(numberOfBlack);\n\t\t}\n\t\tin.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\t\n\tint count = 1;\n\t\n\tvoid run() throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] dataSet = br.readLine().split(\" \");\n\t\tint W = Integer.parseInt(dataSet[0]);\n\t\tint H = Integer.parseInt(dataSet[1]);\n\t\t\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\t\n\t\twhile (W != 0 || H != 0) {\n\t\t\tint startW = 0;\n\t\t\tint startH = 0;\n\t\t\tchar[][] tile = new char[H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString line = br.readLine();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\ttile[i][j] = line.charAt(j);\n\t\t\t\t\tif (line.charAt(j) == '@') {\n\t\t\t\t\t\tstartW = i; \n\t\t\t\t\t\tstartH = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrace(startW, startH, tile, H, W);\n\t\t\tresult.add(count);\n\t\t\tcount = 1;\n\t\t\tdataSet = br.readLine().split(\" \");\n\t\t\tW = Integer.parseInt(dataSet[0]);\n\t\t\tH = Integer.parseInt(dataSet[1]);\n\t\t}\n\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\tSystem.out.println(result.get(i));\n\t\t}\n\t}\n\t\n\tvoid trace(int i, int j, char tile[][], int H, int W) {\n\t\tint up = 0;\n\t\tint down = 0;\n\t\tint right = 0;\n\t\tint left = 0;\n\t\t\n\t\t// ??????????????¢?´¢\n\t\tif (i - 1 >= 0) {\n\t\t\tif (tile[i - 1][j] == '.') {\n\t\t\t\tcount++;\n\t\t\t\ttile[i - 1][j] = '%';\n\t\t\t\tup = i - 1;\n\t\t\t\ttrace(up, j, tile, H, W);\n\t\t\t}\n\t\t}\n\t\t// ??????????????¢?´¢\n\t\tif (j + 1 < W) {\n\t\t\tif (tile[i][j + 1] == '.') {\n\t\t\t\tcount++;\n\t\t\t\ttile[i][j + 1] = '%';\n\t\t\t\tright = j + 1;\n\t\t\t\ttrace(i, right, tile, H, W);\n\t\t\t}\n\t\t}\n\t\t// ??????????????¢?´¢\n\t\tif (i + 1 < H) {\n\t\t\tif (tile[i + 1][j] == '.') {\n\t\t\t\tcount++;\n\t\t\t\ttile[i + 1][j] = '%';\n\t\t\t\tdown = i + 1;\n\t\t\t\ttrace(down, j, tile, H, W);\n\t\t\t}\n\t\t}\n\t\t// ??????????????¢?´¢\n\t\tif (j - 1 >= 0) {\n\t\t\tif (tile[i][j - 1] == '.') {\n\t\t\t\tcount++;\n\t\t\t\ttile[i][j - 1] = '%';\n\t\t\t\tleft = j - 1;\n\t\t\t\ttrace(i, left, tile, H, W);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static Scanner sc = new Scanner(System.in);\n    public static int h;\n    public static int w;\n    public static int x;\n    public static int y;\n    public static int res;\n    public static boolean[][] b;\n    public static void main(String[] args) throws Exception {\n        while (sc.hasNext()) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            x = 0;\n            y = 0;\n            res = 0;\n            b = new boolean[h][w];\n\n            for (int i = 0; i < h; i++) {\n                String s = sc.next();\n                for (int j = 0; j < w; j++) {\n                    if (s.charAt(j)=='#') {\n                        b[i][j] = true;\n                    } else if (s.charAt(j)=='@') {\n                        x = i;\n                        y = j;\n                    }\n                }\n            }\n            \n            solve(x, y);\n            \n            System.out.println(res);\n        }\n    }\n    \n    public static void solve(int x, int y) {\n        b[x][y] = true;\n        res++;\n        int[] d = {-1,0,1,0,0,-1,0,1};\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d[i*2];\n            int ny = y + d[i*2+1];\n            if ( 0 <= nx && nx < h && 0 <= ny && ny < w && b[nx][ny] == false) {\n                solve(nx, ny);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static boolean[][] visited;\n    public static char[][] map;\n    public static int[] moveR = {0,0,1,-1};\n    public static int[] moveC = {-1,1,0,0};\n    public static int R;\n    public static int C;\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        // int TC = Integer.parseInt(sc.next(), 10);\n        \n        while (true) {\n            C = sc.nextInt();\n            R = sc.nextInt();\n            if (C == 0 && R == 0) break;\n            \n            int rPos = -1;\n            int cPos = -1;\n            visited = new boolean[R][C];\n            \n            map = new char[R][C];\n            for (int r = 0; r < R; r++) {\n                String line = sc.next();\n                for (int c = 0; c < C; c++) {\n                    map[r][c] = line.charAt(c);\n                    if (map[r][c] == '@') {\n                        rPos = r;\n                        cPos = c;\n                    }\n                }\n            }\n            \n            System.out.println(floodFill(rPos, cPos));\n        }\n    }\n    \n    public static int floodFill(int r, int c) {\n        if (r < 0 || r >= R || c < 0 || c >= C) return 0;\n        if (visited[r][c] || map[r][c] == '#') return 0;\n        visited[r][c] = true;\n        int ret = 1;\n        for (int m = 0; m < 4; m++) {\n            ret += floodFill(r + moveR[m], c + moveC[m]);\n        }\n        return ret;\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]) throws FileNotFoundException {\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n\n    }\n\n    static int solve(char[][] input) {\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tnew A1130().ans(sc);\n\t}\n\n}\n\nclass Code {\n\n}\n\nclass A1130 {\n\n\tint[] xdis = { -1, 0, +1, 0 };\n\tint[] ydis = { 0, -1, 0, +1 };\n\n\tint[][] cm;\n\n\tpublic void ans(Scanner sc) {\n\t\twhile (true) {\n\t\t\tString str = sc.nextLine();\n\t\t\tString[] cut = str.split(\" \");\n\t\t\tint W = Integer.parseInt(cut[0], 10);\n\t\t\tint H = Integer.parseInt(cut[1], 10);\n\n\t\t\tif (W == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcm = new int[H][W];\n\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tfor (int h = 0; h < H; h++) {\n\t\t\t\tString map = sc.nextLine();\n\t\t\t\tfor (int w = 0; w < W; w++) {\n\t\t\t\t\tchar c = map.charAt(w);\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tcm[h][w] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tx = w;\n\t\t\t\t\t\ty = h;\n\t\t\t\t\t\tcm[h][w] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tcm[h][w] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trec(x, y);\n\n\n\t\t\tint count=0;\n\t\t\tfor (int h = 0; h < H; h++) {\n\t\t\t\tfor (int w = 0; w < W; w++) {\n\t\t\t\t\tif(cm[h][w]==1){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\n\t\t}\n\t}\n\n\tvoid rec(int x, int y) {\n\t\tif (y < 0 || cm.length <= y) {\n\t\t\treturn;\n\t\t}\n\t\tif (x < 0 || cm[0].length <= x) {\n\t\t\treturn;\n\t\t}\n\t\tif (cm[y][x] != 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tcm[y][x] = 1;\n\t\tfor (int i = 0; i < xdis.length; i++) {\n\t\t\trec(x + xdis[i], y + ydis[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner sc;\n\tint w;\n\tint h;\n\tint[][] map;\n\tP s;\n\tint count;\n\tboolean[][] visited;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tcount =0;\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h ==0) break;\n\t\t\tvisited = new boolean[h+2][w+2];\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor (int i=1;i<h+1;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j=1;j<w+1;j++) {\n\t\t\t\t\tvisited[i][j] = false;\n\t\t\t\t\tif (str.charAt(j-1)=='.') visited[i][j] = true;\n\t\t\t\t\telse if(str.charAt(j-1)=='#') visited[i][j] = false;\n\t\t\t\t\telse if(str.charAt(j-1) == '@'){\n\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\ts = new P(j,i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tsolve(s);\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\tvoid solve(P p) {\n\t\tcount++;\n\t\tvisited[p.y][p.x] = false;\n\t\tfor (int i=0;i<4;i++) \n\t\t\tif (visited[p.y+dy[i]][p.x+dx[i]]) solve(new P(p.x+dx[i],p.y+dy[i])); \n\t}\n\t\t\n\t\n\t\n\tclass P {\n\t\tint x;\n\t\tint y;\n\t\tP(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\t\n\tstatic char board[][] = new char[30][30];\n\tstatic int dx[] = {1,-1, 0, 0};\n\tstatic int dy[] = {0, 0, 1, -1};\n\t\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = in.nextInt(), h = in.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\tint sx=0, sy=0;\n\t\t\tfor(int i=0; i<30; i++)for(int j=0; j<30; j++) board[i][j] = '#';\n\t\t\tfor(int i=1; i<=h; i++){\n\t\t\t\tString line = in.next();\n\t\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\t\tboard[i][j] = line.charAt(j-1);\n\t\t\t\t\tif(board[i][j] == '@'){\n\t\t\t\t\t\tsx = i;\n\t\t\t\t\t\tsy = j;\n\t\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx,sy);\n\t\t\tint cnt=0;\n\t\t\tfor(int i=1; i<=h; i++)\n\t\t\t\tfor(int j=1; j<=w; j++)\n\t\t\t\t\tif(board[i][j] == '@')\n\t\t\t\t\t\tcnt++;\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\t\n\tprivate static void dfs(int i, int j){\n\t\tif(board[i][j] != '.') return ;\n\t\tboard[i][j] = '@';\n\t\tfor(int k=0; k<4; k++){\n\t\t\tdfs(i+dx[k], j+dy[k]);\n\t\t}\n\t\treturn ;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package AOJ_1130;\nimport java.util.*;\n\nclass Main {\n    static char[][] table = new char[31][31];\n    static int[][] visited = new int[31][31];\n    static int w,h;\n    public static void main(String args[]){\n\tScanner in = new Scanner(System.in);\n\tfor(;;){\n\t    w = in.nextInt();\n\t    h = in.nextInt();\n\t    if(w == 0 && h == 0) break;\n\t    for(int i=0;i<31;i++)\n\t\tfor(int j=0;j<31;j++) visited[i][j] = 0;\n\t    for(int i=0;i<h;i++){\n\t\tString line = in.next();\n\t\tfor(int j=0;j<w;j++){\n\t\t    table[i][j] = line.charAt(j);\n\t\t}\n\t    }\n\t    for(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t    if(table[i][j] == '@') dfs(i,j);\n\t\t}\n\t    }\n\t    int cnt =0;\n\t    for(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t    cnt += visited[i][j];\n\t\t}\n\t    }\n\t    System.out.println(cnt);\n\t}\n    }\n    static void dfs(int y, int x){\n\tint dx[] = {1,0,-1,0};\n\tint dy[] = {0,1,0,-1};\n\tvisited[y][x] = 1;\n\tfor(int i=0;i<4;i++){\n\t    int xx = x+dx[i];\n\t    int yy = y+dy[i];\n\t    if(xx >= 0 && xx < w && yy >= 0 && yy < h && table[yy][xx] == '.' && visited[yy][xx] == 0)\n\t\tdfs(yy,xx);\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tchar[][] map;\n\tint count = 0;\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint w = scan.nextInt();\n\t\t\tint h = scan.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tmap[i] = scan.next().toCharArray();\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tboolean fl = false;\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\tif(map[i][j] == '@'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tmap[i][j] = '#';\n\t\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\t\tsearchTile(i-1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i != h-1){\n\t\t\t\t\t\t\tsearchTile(i+1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\t\tsearchTile(i,j-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != w-1){\n\t\t\t\t\t\t\tsearchTile(i,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfl = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fl){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tpublic void searchTile(int y,int x){\n\t\tif(map[y][x] == '#'){\n\t\t\treturn;\n\t\t}\n\t\tcount++;\n\t\tmap[y][x] = '#';\n\t\tif(y != 0){\n\t\t\tsearchTile(y-1,x);\n\t\t}\n\t\tif(y != map.length-1){\n\t\t\tsearchTile(y+1,x);\n\t\t}\n\t\tif(x != 0){\n\t\t\tsearchTile(y,x-1);\n\t\t}\n\t\tif(x != map[0].length-1){\n\t\t\tsearchTile(y,x+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n   public static void main(String a[]) throws java.io.IOException{\n       Scanner scan =new Scanner (System.in);\n       Pair pair= new Pair();\n       Queue<Pair> fifo = new LinkedList<Pair>();\n\n       while(true){\n\n           int W =scan.nextInt();\n           int H =scan.nextInt();\n           if((W|H)==0)break;\n           char  [][] map = new char [H][W];\n           for(int i=0;i<H;i++){\n               String  tmp =scan.next();\n               for(int j=0;j<W;j++){\n                   map[i][j] = tmp.charAt(j);\n                   if(tmp.charAt(j)=='@'){\n                       \n                       pair.x=j;\n                       pair.y=i;\n                       fifo.add(pair);\n                   }\n               }\n           }\n          int count =0;\n          while(fifo.peek()!=null){  \n           pair = fifo.poll();\n           int x=pair.x;\n           int y=pair.y;\n           int[] dx ={0,1,0,-1};\n           int[] dy ={1,0,-1,0};\n          for(int i=0;i<4;i++){\n              int nx =x+dx[i];\n              int ny =y+dy[i];\n              if(0<=nx&&nx<W&&0<=ny&&ny<H&&map[ny][nx]!='#'){\n                  Pair npair =new Pair();\n                  npair.x=nx;\n                  npair.y=ny;\n                  fifo.add(npair);\n                  map[ny][nx] = '#';\n                  count++;\n              }\n          } \n          \n          System.out.println(count);\n\n       }\n       }\n}\n\nclass Pair{\n    public int x;\n    public int y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int w, h;\n  boolean[][] done;\n  char[][] field;\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n\n  int dfs(int x, int y) {\n    if (field[y][x] == '#') {\n      return 0;\n    }\n    if (done[y][x]) {\n      return 0;\n    }\n    done[y][x] = true;\n    int cnt = 1;\n    for (int[] d : ofs) {\n      int nx = x + d[0];\n      int ny = y + d[1];\n      cnt += dfs(nx, ny);\n    }\n    return cnt;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      done = new boolean[h + 2][w + 2];\n      field = new char[h + 2][w + 2];\n      for (int i = 0; i < h + 2; ++i) {\n        Arrays.fill(field[i], '#');\n      }\n      int x = -1, y = -1;\n      for (int i = 1; i <= h; ++i) {\n        String str = \" \" + sc.next();\n        for (int j = 1; j <= w; ++j) {\n          field[i][j] = str.charAt(j);\n          if (field[i][j] == '@') {\n            x = j;\n            y = i;\n          }\n        }\n      }\n      System.out.println(dfs(x, y));\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tint[] moveX = {0,0,-1,1};\n\tint[] moveY = {-1,1,0,0};\n\tchar[][] map;\n\tboolean[][] check;\n\tint ans = 0;\n\tint x, y;\n\n\tvoid calc () {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\n\t\t\tif (x == 0) break;\n\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic final char CHECKED = 'C';\n\tstatic final char BLACK = '.';\n\tstatic final char START = '@';\n\tvoid run(){\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = s.nextInt();\n\t\t\tint h = s.nextInt();\n\t\t\tif(w == 0 && h == w)break;\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tchar tile[][] = new char[h][w];\n\t\t\tfor(int i = 0;i < h;i++){\n\t\t\t\tString row = s.next();\n\t\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\t\ttile[i][j] = row.charAt(j);\n\t\t\t\t\tif(tile[i][j] == START){\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ttile[i][j] = BLACK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cntTile(tile,y,x));\n\t\t}\n\t}\n\n\tint cntTile(char[][] panel,int y,int x){\n\t\t//??????????????´??????????????\\????????¢?´¢???????????????0????????´?????????\n\t\tif(y >= panel.length)return 0;\n\t\tif(y < 0)return 0;\n\t\tif(x >= panel[0].length)return 0;\n\t\tif(x < 0)return 0;\n\t\tint cnt = 0;\n\t\tif(panel[y][x] == BLACK){\n\t\t\tpanel[y][x] = CHECKED;\n\t\t\tcnt++;\n\t\t\t//??±???????????¢?´¢????????????????????¢?´¢??????????????°?????????\n\t\t\tcnt += cntTile(panel,y + 1,x);\n\t\t\tcnt += cntTile(panel,y - 1,x);\n\t\t\tcnt += cntTile(panel,y,x + 1);\n\t\t\tcnt += cntTile(panel,y,x - 1);\n\t\t\treturn cnt;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\npublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile = new char[22][22];\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            for (int i = 0; i <= H+1; i++){\n                for(int j = 0; j <= W+1; j++){\n                    System.out.print(tile[i][j]);\n                }\n                System.out.println();\n            }\n            System.out.println(tile[y][x]);\n            System.out.println(countBlackTile(x, y));\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 1;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]);\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int w, h, count, before;\n\tstatic int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0, 1}};\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif(w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] pos = new int[2];\n\t\t\tint [][] c = new int[h][w];\n\t\t\tchar abc;\n\t\t\tString str = new String();\n\t\t\tfor(int i = 0; i < h; i++){/* ????????? */\n\t\t\t\tstr = sc.nextLine();/* ?????§???????????? */\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tabc = str.charAt(j);\n\t\t\t\t\tif(abc == '#'){\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t}else if(abc == '.'){\n\t\t\t\t\t\tc[i][j] = 1;\n\t\t\t\t\t}else if(abc == '@'){\n\t\t\t\t\t\tc[i][j] = 1;\n\t\t\t\t\t\tpos[0] = i;\n\t\t\t\t\t\tpos[1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tbefore = 1;\n\t\t\tint y;\n\t\t\ty = search(c , pos[0], pos[1]);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tpublic static int search(int[][] c, int i, int j){\n\t\tif(c[i][j] == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tc[i][j] = 0;\n\t\tcount++;\n\t\t\n\t\tint d = before + 2/* ????????°????????????????????´???????§???? */;\n\t\tif(d > 3){\n\t\t\td -= 4;\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\td++;\n\t\t\tif(d > 3){\n\t\t\t\td -= 4;\n\t\t\t}\n\t\t\t\n\t\t\tbefore = d;\n\t\t\tint x = i + dir[d][0], y = j + dir[d][1];\n\t\t\tif((x >= 0) && (x < h) && (y >= 0) && (y < w)){\n\t\t\t\tint z = search(c, x, y);\n\t\t\t}\n\t\t}\t\t\n\t\treturn 1;\n\t}"
  },
  {
    "language": "Java",
    "code": "import java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tsearch();\n\t}\n\t\n\tpublic static void search(){\n\t\tQueue<Integer> xqueue = new LinkedList<Integer>();\n\t\tQueue<Integer> yqueue = new LinkedList<Integer>();\n\t\t\n\t\tint X; int Y;\n\t\t\n\t\tScanner input = new Scanner(System.in);\n\t\t\n\t\tString[][] grid;\n\t\tint[][] visit;\n\t\tint currentX = 0;; int currentY = 0;\n\n\t\tX = input.nextInt();\n\t\tY = input.nextInt();\n\t\tif(X == 0 && Y ==0){\n\t\t\tinput.close();\n\t\t\tSystem.exit(0);\n\t\t}\n\t\t\n\t\tgrid = new String[Y][X];\n\t\tvisit = new int[Y][X];\n\t\t\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tString[] tmp = input.next().split(\"\");\n\t\t\tfor(int z = 1; z < tmp.length; z++){\n\t\t\t\tgrid[i][z-1] = tmp[z];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(grid[i][j].equals(\"@\")){\n\t\t\t\t\tcurrentX = j; currentY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tyqueue.offer(currentY);\n\t\txqueue.offer(currentX);\n\t\t\t\t\t\t\t\t\n\t\twhile(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\n\t\t\tif(yqueue.peek() != null && xqueue.peek() != null){\n\t\t\t\tcurrentY = yqueue.poll();\n\t\t\t\tcurrentX = xqueue.poll();\n\t\t\t}\n\t\t\t\n\t\t\tif(visit[currentY][currentX] == 0 && !(grid[currentY][currentX].equals(\"#\"))){\n\t\t\t\tvisit[currentY][currentX] = 1;\n\t\t\t\tif(currentY > 0 && currentY < Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == 0 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY == Y-1 && currentX == 0){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(currentY > 0 && currentY < Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY+1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY+1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX == X-1){\n\t\t\t\t\tif(grid[currentY-1][currentX].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY-1); xqueue.offer(currentX);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}else if(currentY == Y-1 && currentX > 0 && currentX < X-1){\n\t\t\t\t\tif(grid[currentY][currentX+1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[currentY][currentX-1].equals(\".\")){\n\t\t\t\t\t\tyqueue.offer(currentY); xqueue.offer(currentX-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\tfor(int i = 0; i < visit.length; i++){\n\t\t\tfor(int j = 0; j < visit[i].length; j++){\n\t\t\t\tif(visit[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t\tsearch();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0) break;\n\n\t\t\ttile = new int[w][h];\n\t\t\tString s;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\ts = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tpublic int canMove (int a, int b) {\n\n\t\tint m = 0;\n\t\ttile[a][b] = 0;\n\n\t\tif(a>0)if(tile[a-1][b]==1)m+=canMove(a-1,b);\n\t\tif(a<w-1)if(tile[a+1][b]==1)m+=canMove(a+1,b);\n\t\tif(b>0)if(tile[a][b-1]==1)m+=canMove(a,b-1);\n\t\tif(b<h-1)if(tile[a][b+1]==1)m+=canMove(a,b+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint m,n;\n\tint[][] a;\n\tint x0,y0;\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[n][m];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tif(s.charAt(i)=='@'){\n\t\t\t\t\t\tx0=i;\n\t\t\t\t\t\ty0=j;\n\t\t\t\t\t}else if(s.charAt(i)=='#'){\n\t\t\t\t\t\ta[j][i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tboolean[][] visited=new boolean[n][m];\n\t\tint ans=0;\n\t\t\n\t\tque.offer(new P(x0,y0));\n\t\tvisited[y0][x0]=true;\n\t\t\n\t\tint[] dx={0,0,-1,1};\n\t\tint[] dy={-1,1,0,0};\n\t\t\n\t\tfor(;!que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tans++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tP q=new P(p.x+dx[i],p.y+dy[i]);\n\t\t\t\tif(q.x>=0&&q.x<m&&q.y>=0&&q.y<n&&a[q.y][q.x]==0&&!visited[q.y][q.x]){\n\t\t\t\t\tque.offer(q);\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(ans+\"\");\n\t}\n\t\n\tclass P{\n\t\tint x,y;\n\t\tP(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    static int count;//BÂ\\È^C\n    static int w;//xûüÌ·³\n    static int h;//yûüÌ·³\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tw = sc.nextInt();//x\n\th = sc.nextInt();//y\n\n\twhile(w!=0 && h!=0){\n\t    count = 0;\n\t    char[][] tile = new char[h][w];//^Cð»ÌÜÜi[\n\t    int[][] pass = new int[h][w];//Êßµ½ÚóB0(ÊÁÄÈ¢)Æ1(ÊÁ½)ÅL^\n\t    int posX = 0;//»ÝnÌxÀW\n\t    int posY = 0;//»ÝnÌyÀW\n\t    //^Cú»\n\t    for(int i=0; i<h; i++){\n\t\tString line = sc.next();//êsÇÝñÅ©ç\n\t\tfor(int j=0; j<w; j++){\n\t\t    tile[i][j] = line.charAt(j);\n\t\t    if(tile[i][j]=='@'){//»ÝÊuðL^\n\t\t\tposX = j;\n\t\t\tposY = i;\n\t\t    }\n\t\t}\n\t    }\n\t    solve(tile,pass,posX,posY);\n\t    System.out.println(count);\n\t    \n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t}\n    }\n\n    public static void solve(char[][] tile, int[][] pass,int posX, int posY){\n\tif(pass[posY][posX]==0){//Êßµ½Úó\n\t    pass[posY][posX] = 1;\n\t    count++;\n\t}else return;//ÊßµÄ½çreturn\n\n\tif(posY-1>=0 && tile[posY-1][posX]=='.'){//ãûü\n\t    solve(tile,pass,posX,posY-1);\n\t}\n\tif(posX+1<=w-1 && tile[posY][posX+1]=='.'){//Eûü\n\t    solve(tile,pass,posX+1,posY);\n\t}\n\tif(posY+1<=h-1 && tile[posY+1][posX]=='.'){//ºûü\n\t    solve(tile,pass,posX,posY+1);\n\t}\n\tif(posX-1>=0 && tile[posY][posX-1]=='.'){//¶ûü\n\t    solve(tile,pass,posX-1, posY);\n\t}\n\n\treturn;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (c[j] == '@') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t} else if (c[j] == '#')\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tdfs(sy, sx);\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate void dfs(int y, int x) {\n\t\tmap[y][x] = true;\n\t\tans++;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint w, h, sy, sx, ans;\n\tboolean[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = \"\";\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            int w = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n            int h = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n            char[][] map = new char[h + 2][w + 2];\n\n            ArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n            int count = 0;\n\n            for (int i = 1; i < h + 1; i++) {\n                line = br.readLine();\n                for (int j = 1; j < w + 1; j++) {\n                    map[i][j] = line.charAt(j - 1);\n                    if (map[i][j] == '@') {\n                        queue.offer(new int[]{i, j});\n                        map[i][j] = '#';\n                        count++;\n                    }\n                }\n            }\n\n            int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n            int[] curr;\n            int ni, nj;\n            while (queue.size() > 0) {\n\n                curr = queue.poll();\n                for (int i = 0; i < dir.length; i++) {\n                    ni = curr[0] + dir[i][0];\n                    nj = curr[1] + dir[i][1];\n                    if (map[ni][nj] == '.') {\n                        queue.offer(new int[]{ni, nj});\n                        map[ni][nj] = '#';\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H, res;\n\tstatic char [][]field;\n\tstatic int[]dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsearch_Start();\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\tstatic boolean read(){\n\t\tW = sc.nextInt(); H = sc.nextInt();\n\t\tif(W == 0 && H == 0)\n\t\t\treturn false;\n\t\t\n\t\tfield = new char[H][W];\n\t\tres = 0;\n\t\t\n\t\tString line;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tline = sc.next();\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t\tfield[i][j] = line.charAt(j);\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void search_Start(){\n\t\t/**\n\t\t * ツづ慊つクツづ債スツタツーツトツ地ツ点ツづーツ探ツつキツ。\n\t\t */\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t/**\n\t\t\t\t * ツ個ゥツづつつッツつスツづァツ探ツ催オツ開ツ始\n\t\t\t\t */\n\t\t\t\tif(field[i][j] == '@')\n\t\t\t\t\tdfs(j, i);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void dfs(int x, int y){\n\t\tfield[y][x] = '#';\n\t\tres++;\n\t\tint mx = 0, my = 0;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tmx = x + dx[i]; my = y + dy[i];\n\t\t\tif( 0 <= mx && mx < W && 0 <= my && my < H && field[my][mx] == '.')\n\t\t\t\tdfs(mx, my);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int a,b;\n    static int[][] tile;\n    public static void main(String args[]){\n\n        Scanner s=new Scanner(System.in);\n\n        while(true){\n            b=s.nextInt();\n            a=s.nextInt();\n            if(a==0)System.exit(0);\n            tile=new int[a][b];\n            String now;\n            int p=0,q=0;\n            for(int i=0;i<a;i++){\n                now=s.next();\n                for(int j=0;j<b;j++){\n                    if(now.charAt(j)=='#')tile[i][j]=0;\n                    else if(now.charAt(j)=='.')tile[i][j]=1;\n                    else{\n                        tile[i][j]=0;\n                        p=i;\n                        q=j;\n                    }\n                }\n            }\n\n\n            System.out.println(solve(p,q));\n        }\n    }\n    static int solve(int m,int n){\n        int count=0;\n\n        tile[m][n]=0;\n\n        if(m>0)\n            if(tile[m-1][n]==1)count+=solve(m-1,n);\n        if(m<a-1)\n            if(tile[m+1][n]==1)count+=solve(m+1,n);\n        if(n>0)\n            if(tile[m][n-1]==1)count+=solve(m,n-1);\n        if(n<b-1)\n            if(tile[m][n+1]==1)count+=solve(m,n+1);\n\n\n        return count+1;\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void search(int x,int y,int w,int h,String[][] map,Boolean[][] memo){\n\t\tif(x < 0 || x > w-1 || y < 0 || y > h-1 || map[x][y].equals(\"#\")) return;\n\t\tif(memo[x][y]) return;\n\t\tmemo[x][y] = true; \n\t\t//System.out.println(x+\",\"+y+\"true\");\n\t\tsearch(x+1,y,w,h,map,memo);\n\t\tsearch(x,y-1,w,h,map,memo);\n\t\tsearch(x-1,y,w,h,map,memo);\n\t\tsearch(x,y+1,w,h,map,memo);\n\t} \n\t\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = scan.nextInt();\n\t\t\tint h = scan.nextInt();\n\t\t\tint count = 0;\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tString[][] map = new String[w][h];\n\t\t\tBoolean[][] memo = new Boolean[w][h];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString str = scan.next(); \n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmemo[j][i] = false;\n\t\t\t\t\tmap[j][i] = String.valueOf(str.charAt(j));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[j][i].equals(\"@\")){\n\t\t\t\t\t\tsearch(j,i,w,h,map,memo);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t//System.out.print(map[j][i]);\n\t\t\t\t\t//System.out.println();\n\t\t\t\t\tif(memo[j][i] == true) count++;\n\t\t\t\t}\n\t\t\t\t//System.out.println(\"\");\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\t/*\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tSystem.out.print(memo[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scanner.nextInt();\n\n\t\t\tint[][] map = new int[m][n];\n\t\t\tInteger[] start = new Integer[2];\n\t\t\tint island = 1;\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tString line = scanner.next();\n\t\t\t\tfor (int j = 0; j < line.length(); j++) {\n\t\t\t\t\tchar place = line.charAt(j);\n\t\t\t\t\tif (place == '.') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (place == '@') {\n\t\t\t\t\t\tstart[0] = i;\n\t\t\t\t\t\tstart[1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\t\tdeque.addFirst(start);\n\t\t\twhile (deque.size() > 0) {\n\t\t\t\tInteger[] poll = deque.pollFirst();\n\t\t\t\tif (poll[0] > 0 && map[poll[0] - 1][poll[1]] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0] - 1, poll[1] };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0] - 1][poll[1]] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[0] < m - 1 && map[poll[0] + 1][poll[1]] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0] + 1, poll[1] };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0] + 1][poll[1]] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[1] > 0 && map[poll[0]][poll[1] - 1] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0], poll[1] - 1 };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0]][poll[1] - 1] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t\tif (poll[1] < n - 1 && map[poll[0]][poll[1] + 1] == 1) {\n\t\t\t\t\tInteger[] push = { poll[0], poll[1] + 1 };\n\t\t\t\t\tdeque.addFirst(push);\n\t\t\t\t\tmap[poll[0]][poll[1] + 1] = 0;\n\t\t\t\t\tisland++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(island);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nextChar() {\n\t\ttry {\n\t\t\tint b = System.in.read();\n\t\t\twhile (b != -1 && (b == ' ' || b == '\\r' || b == '\\n'))\n\t\t\t\t;\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n   public static void main(String a[]) throws java.io.IOException{\n       Scanner scan =new Scanner (System.in);\n       Pair pair= new Pair();\n       Queue<Pair> fifo = new LinkedList<Pair>();\n\n       while(true){\n\n           int W =scan.nextInt();\n           int H =scan.nextInt();\n           if((W|H)==0)break;\n           char  [][] map = new char [H][W];\n           for(int i=0;i<H;i++){\n               String  tmp =scan.next();\n               for(int j=0;j<W;j++){\n                   map[i][j] = tmp.charAt(j);\n                   if(tmp.charAt(j)=='@'){\n                       \n                       pair.x=j;\n                       pair.y=i;\n                       fifo.add(pair);\n                   }\n               }\n           }\n          int count =0;\n          while(fifo.peek()!=null){  \n           pair = fifo.poll();\n           int x=pair.x;\n           int y=pair.y;\n           int[] dx ={0,1,0,-1};\n           int[] dy ={1,0,-1,0};\n          for(int i=0;i<4;i++){\n              int nx =x+dx[i];\n              int ny =y+dy[i];\n              if(0<=nx&&nx<W&&0<=ny&&ny<H&&map[ny][nx]!='#'){\n                  Pair npair =new Pair();\n                  npair.x=nx;\n                  npair.y=ny;\n                  fifo.add(npair);\n                  map[ny][nx] = '#';\n                  count++;\n              }\n          } \n          }\n          System.out.println(count);\n\n       \n       }\n}\n}\n\nclass Pair{\n    public int x;\n    public int y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main2 {\n\tstatic int[] v1 = { 0, 1, 0, -1 };\n\tstatic int[] v2 = { 1, 0, -1, 0 };\n\tstatic int[][] field;\n\tstatic int count = 0;\n\tpublic static void main(String[] args) {\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = cin.nextInt();\n\t\t\tint h = cin.nextInt();\n\t\t\tif(w+h==0){break;}\n\t\t\t\n\t\t\tint startx = 0, starty = 0;\n\t\t\tcount=0;\n\t\t\tfield = new int[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tString str = cin.next();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (str.charAt(j-1) == '.') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t} else if (str.charAt(j-1) == '#') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (str.charAt(j-1) == '@') {\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tstartx = i;\n\t\t\t\t\t\tstarty = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tInteger[] start = {startx,starty};\n\t\t\tStack<Integer[]> s = new Stack<Integer[]>();\n\t\t\ts.add(start);\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tInteger[] a = s.pop();\n\t\t\t\tcount++;\n\t\t\t\tfield[a[0]][a[1]]=2;\n\t\t\t\tfor(int i = 0;i<4;i++){\n\t\t\t\t\tint xx = a[0]+v1[i];\n\t\t\t\t\tint yy = a[1]+v2[i];\n\t\t\t\t\tif(field[xx][yy]==1){\n\t\t\t\t\t\tInteger[] next={xx,yy};\n\t\t\t\t\t\ts.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tint H = sc.nextInt();\n\t\t\tboolean[][] f = new boolean[H + 2][W + 2];\n\t\t\tArrayList<Point> ps = new ArrayList<Point>();\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tchar[] line = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (line[j] == '@') {\n\t\t\t\t\t\tps.add(new Point(i + 1, j + 1));\n\t\t\t\t\t} else if (line[j] == '.') {\n\t\t\t\t\t\tf[i + 1][j + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 1;\n\t\t\twhile (!ps.isEmpty()) {\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : ps) {\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tint nr = p.x + DR[i];\n\t\t\t\t\t\tint nc = p.y + DC[i];\n\t\t\t\t\t\tif (f[nr][nc]) {\n\t\t\t\t\t\t\t++ans;\n\t\t\t\t\t\t\tf[nr][nc] = false;\n\t\t\t\t\t\t\tnext.add(new Point(nr, nc));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tps = next;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Main {\n\n\tstatic String matrix[][];\n\tstatic int fin[][];\n\tstatic int color[][];\n\n\tstatic final int WHITE = 0;\n\tstatic final int GRAY = 1;\n\tstatic final int BLACK = 2;\n\n\tstatic int w;\n\tstatic int h;\n\n\tstatic int sx;\n\tstatic int sy;\n\n\tstatic final int dx[] = { 1, 0, -1, 0 };\n\tstatic final int dy[] = { 0, 1, 0, -1 };\n\n\tstatic int count = 0;\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile (true) {\n\n\t\t\tString str[] = br.readLine().split(\" \");\n\t\t\tw = Integer.parseInt(str[0]);\n\t\t\th = Integer.parseInt(str[1]);\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\n\t\t\tmatrix = new String[h][w];\n\t\t\tfin = new int[h][w];\n\t\t\tcolor = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tstr = br.readLine().split(\"\");\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (str[j].equals(\"@\")) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tmatrix[i][j] = str[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx, sy);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic void dfs(int x, int y) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tfin[i][j] = -1;\n\t\t\t\tcolor[i][j] = WHITE;\n\t\t\t}\n\t\t}\n\t\tcount = 0;\n\t\tdfs_visit(x, y);\n\t}\n\n\tstatic void dfs_visit(int x, int y) {\n\t\tcolor[y][x] = GRAY;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\n\t\t\tif (nx < w && nx >= 0 && ny >= 0 && ny < h) {\n\t\t\t\tif (color[ny][nx] == WHITE && matrix[ny][nx].equals(\".\")) {\n\t\t\t\t\tdfs_visit(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor[y][x] = BLACK;\n\t\tfin[y][x] = ++count;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by macbookpro on 2017/07/10.\n */\npublic class Main {\n    static int[][] array;\n    static int counter=1;\n    static int w;\n    static int h;\n    static boolean[][] confirm;\n\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            String[] firstLine=sc.nextLine().split(\" \");\n\n\n            w=Integer.parseInt(firstLine[0]);\n            if(w==0){\n                break;\n            }\n\n            h=Integer.parseInt(firstLine[1]);\n            array=new int[h][w];\n            confirm=new boolean[h][w];\n\n\n            for(boolean[] tmp:confirm){\n                Arrays.fill(tmp,false);\n            }\n\n\n\n            int sh=0;\n            int sw=0;\n\n\n            for(int i=0; i<h; i++){\n                String tiles=sc.nextLine();\n\n                for(int j=0; j<w; j++){\n                    char cell= tiles.charAt(j);\n\n                    if(cell=='.') {\n                        array[i][j]=1;//??????1??§??¨???\n                    }else if(cell=='#'){\n                        array[i][j]=0;//??????0??§??¨???\n                    }else{\n                        array[i][j]=1;\n                        sh=i;\n                        sw=j;\n                    }\n                }\n            }\n\n\n\n            counter=1;\n\n            confirm[sh][sw]=true;\n\n            if(sw!=w-1 && array[sh][sw+1]==1) {\n                rightmove(sh,sw+1);\n            }\n\n            if(sh!=0&&array[sh-1][sw]==1){\n                upmove(sh-1,sw);\n            }\n\n            if(sh!=h-1 && array[sh+1][sw]==1){\n                downmove(sh+1,sw);\n            }\n\n            if (sw != 0 && array[sh][sw - 1] == 1) {\n                leftmove(sh,sw-1);\n            }\n\n\n\n            System.out.println(counter);\n        }\n    }\n\n\n\n    static void rightmove(int m, int n){\n\n       if(confirm[m][n]!=true){\n           counter++;\n           confirm[m][n]=true;\n\n           if(n!=w-1 && array[m][n+1]==1) {\n               rightmove(m, n + 1);\n           }if(m!=h-1 && array[m+1][n]==1){\n               downmove(m+1,n);\n           }if(m!=0&&array[m-1][n]==1){\n               upmove(m-1,n);\n           }\n       }\n\n\n\n    }\n\n\n    static void leftmove(int m, int n){\n\n        if(confirm[m][n]!=true){\n\n            counter++;\n            confirm[m][n] = true;\n\n            if (n != 0 && array[m][n - 1] == 1) {\n                leftmove(m,n-1);\n            }\n            if (m != h - 1 && array[m + 1][n] == 1) {\n                downmove(m + 1, n);\n            }\n            if (m != 0 && array[m - 1][n] == 1) {\n                upmove(m - 1, n);\n            }\n        }\n    }\n\n\n    static void upmove(int m, int n){\n\n        if(confirm[m][n]!=true){\n\n            counter++;\n            confirm[m][n] = true;\n            if (n != w - 1 && array[m][n + 1] == 1) {\n                rightmove(m, n + 1);\n            }\n            if (n != 0 && array[m][n - 1] == 1) {\n                leftmove(m, n - 1);\n            }\n            if (m != 0 && array[m - 1][n] == 1) {\n                upmove(m - 1, n);\n            }\n        }\n    }\n\n\n    static void downmove(int m, int n){\n        if(confirm[m][n]!=true){\n\n            counter++;\n            confirm[m][n] = true;\n            if (n != w - 1 && array[m][n + 1] == 1) {\n                rightmove(m, n + 1);\n            }\n            if (n != 0 && array[m][n - 1] == 1) {\n                leftmove(m, n - 1);\n            }\n            if (m != h-1 && array[m + 1][n] == 1) {\n                downmove(m + 1, n);\n            }\n\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class DFSKurihara {\n\tint H, W;\n\tint[] dx = {1, 0, -1, 0};\n\tint[] dy = {0, 1, 0, -1};\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif((H | W) == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tfor(int i = 0; i < H; ++i){\n\t\t\t\tfield[i] = sc.nextLine().toCharArray(); \n\t\t\t}\n\t\t\tfor(int i = 0; i < H; ++i){\n\t\t\t\tfor(int j = 0; j < W; ++j){\n\t\t\t\t\tif(field[i][j] == '@'){\n\t\t\t\t\t\tSystem.out.println(dfs(field, i, j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(char[][] field, int y, int x){\n\t\tif(y < 0 || H <= y || x < 0 || W <= x){\n\t\t\treturn 0;\n\t\t}\n\t\tif(field[y][x] == '#'){\n\t\t\treturn 0;\n\t\t}\n\t\tfield[y][x] = '#';\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tret += dfs(field, y+dy[i], x+dx[i]);\n\t\t}\n\t\treturn ret+1;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DFSKurihara().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tint w = 1;\n\t\t\tint h = 1;\n\t\t\tint moveCan = 0;\n\n\t\t\tw = scan.nextInt();\n\t\t\th = scan.nextInt();\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\n\t\t\tchar[][] table = new char[h][w];\n\t\t\t// int[][] num = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t// for (int j = 0; j < w; j++) {\n\t\t\t\ttable[i]/* [j] */= scan.next().toCharArray();\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tmoveCan = AtCheck(table, w, h);\n\t\t\tSystem.out.println(moveCan);\n\t\t}\n\n\t\tscan.close();\n\t}\n\n\tpublic static int AtCheck(char table[][], int w, int h) {\n\t\tint befAtNum = 0;\n\t\tint aftAtNum = 0;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@')\n\t\t\t\t\tbefAtNum++;\n\t\t\t}\n\t\t}\n\n\t\tint[][] atPlace = new int[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@') {\n\t\t\t\t\tatPlace[i][j] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i - 1][j - 1]=='.')\n\t\t\t\t\t// atPlace[i - 1][j - 1] = 1;\n\t\t\t\t\tif (j != 0 && table[i][j - 1] == '.')\n\t\t\t\t\t\tatPlace[i][j - 1] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i + 1][j - 1]=='.')\n\t\t\t\t\t// atPlace[i + 1][j - 1] = 1;\n\t\t\t\t\tif (i != 0 && table[i - 1][j] == '.')\n\t\t\t\t\t\tatPlace[i - 1][j] = 1;\n\t\t\t\t\tif (i != (h - 1) && table[i + 1][j] == '.')\n\t\t\t\t\t\tatPlace[i + 1][j] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i - 1][j + 1]=='.')\n\t\t\t\t\t// atPlace[i - 1][j + 1] = 1;\n\t\t\t\t\tif (j != (w - 1) && table[i][j + 1] == '.')\n\t\t\t\t\t\tatPlace[i][j + 1] = 1;\n\t\t\t\t\t// if (i != (h - 1) && j != (w - 1) && i != 0 && j != 0\n\t\t\t\t\t// && table[i + 1][j + 1]=='.')\n\t\t\t\t\t// atPlace[i + 1][j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (atPlace[i][j] == 1)\n\t\t\t\t\ttable[i][j] = '@';\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '@')\n\t\t\t\t\taftAtNum++;\n\t\t\t}\n\t\t}\n\t\tif (befAtNum != aftAtNum) {\n\t\t\treturn AtCheck(table, w, h);\n\t\t} else {\n\t\t\treturn aftAtNum;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = \"\";\n\n        while (!(line = br.readLine()).equals(\"0 0\")) {\n            int w = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n            int h = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n            char[][] map = new char[h + 2][w + 2];\n\n            ArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n            int count = 0;\n\n            for (int i = 1; i < h + 1; i++) {\n                line = br.readLine();\n                for (int j = 1; j < w + 1; j++) {\n                    map[i][j] = line.charAt(j - 1);\n                    if (map[i][j] == '@') {\n                        queue.offer(new int[]{i, j});\n                        map[i][j] = '#';\n                        count++;\n                    }\n                }\n            }\n\n            int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n            while (queue.size() > 0) {\n\n                int[] curr = queue.poll();\n                char tile;\n                for (int i = 0; i < dir.length; i++) {\n                    tile = map[curr[0] + dir[i][0]][curr[1] + dir[i][1]];\n                    if (tile == '.') {\n                        queue.offer(new int[]{\n                                curr[0] + dir[i][0], curr[1] + dir[i][1]\n                        });\n                        map[curr[0] + dir[i][0]][curr[1] + dir[i][1]] = '#';\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] tile;\n\n\tpublic static void main  (String[]args) {\n\n\t\tScanner in = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\n\t\t\tif(w==0 || h==0) break;\n\n\t\t\ttile = new int[w][h];\n\t\t\tString s;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int i=0; i<w; i++) {\n\t\t\t\ts = in.next();\n\t\t\t\tfor (int j=0; j<h; j++) {\n\n\t\t\t\t\tif(s.charAt(j)=='#') {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t}else if(s.charAt(j)=='.') {\n\t\t\t\t\t\ttile[i][j]=1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\ttile[i][j]=0;\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(canMove(x,y));\n\n\t\t}\n\n\t}\n\n\tstatic int canMove (int a, int b) {\n\n\t\tint m = 0;\n\t\ttile[a][b] = 0;\n\n\t\tif(a>0)if(tile[a-1][b]==1)m+=canMove(a-1,b);\n\t\tif(a<w-1)if(tile[a+1][b]==1)m+=canMove(a+1,b);\n\t\tif(b>0)if(tile[a][b-1]==1)m+=canMove(a,b-1);\n\t\tif(b<h-1)if(tile[a][b+1]==1)m+=canMove(a,b+1);\n\n\t\treturn m++;\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.in;\nimport static java.lang.System.out;\n\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tStringTokenizer st;\n\t\twhile (true) {\n\t\t\tst = new StringTokenizer(sc.nextLine());\n\t\t\tint w = Integer.parseInt(st.nextToken());\n\t\t\tint h = Integer.parseInt(st.nextToken());\n\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tboolean[][] room = new boolean[h][w];\n\t\t\tString s;\n\t\t\tint posx, posy;\n\t\t\tposx = posy = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s.substring(j,j+1).equals(\".\"))\n\t\t\t\t\t\troom[i][j] = true;\n\t\t\t\t\telse if (s.substring(j,j+1).equals(\"@\")) {\n\t\t\t\t\t\troom[i][j] = false;\n\t\t\t\t\t\tposx = i;\n\t\t\t\t\t\tposy = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tint[] dx = {-1, 0, 1, 0};\n\t\t\tint[] dy = {0, -1, 0, 1};\n\t\t\t\n\t\t\tQueue<Integer> qx = new LinkedList<Integer>();\n\t\t\tQueue<Integer> qy = new LinkedList<Integer>();\n\t\t\tqx.add(posx);\n\t\t\tqy.add(posy);\n\t\t\tint ans = 0;\n\t\t\tint x, y;\n\t\t\twhile (!qx.isEmpty()) {\n\t\t\t\tx = qx.poll();\n\t\t\t\ty = qy.poll();\n\t\t\t\tans++;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h \n\t\t\t\t\t\t\t&& y+dy[i] >= 0 && y+dy[i] < w\n\t\t\t\t\t\t\t&& room[x+dx[i]][y+dy[i]]) {\n\t\t\t\t\t\troom[x+dx[i]][y+dy[i]] = false;\n\t\t\t\t\t\tqx.add(x+dx[i]);\n\t\t\t\t\t\tqy.add(y+dy[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int W, H;\n\tstatic char[][] field;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tif(W == 0 && H == 0)return false;\n\t\t\n\t\tfield = new char[H][W];\n\t\t\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfield[i] = sc.next().toCharArray();\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tint res = 0;\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '@')dfs(j, i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[0].length; j++){\n\t\t\t\tif(field[i][j] == '*')res++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\tstatic void dfs(int x, int y){\n\t\tfield[y][x] = '*';\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(0 <= nx && nx < W && 0 <= ny && ny < H && field[ny][nx] == '.'){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if (w == 0 && h == 0) {\n                break;\n            }\n            char[][] field = new char[h][];\n            int ww = 0;\n            int hh = 0;\n            for (int i = 0; i < h; i++) {\n                field[i] = sc.next().toCharArray();\n                for (int j = 0; j < w; j++) {\n                    if (field[i][j] == '@') {\n                        ww = j;\n                        hh = i;\n                        field[i][j] = '.';\n                    }\n                }\n            }\n            Counter cn = new Counter();\n            search(hh, ww, field, cn);\n            sb.append(cn.count).append(\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    \n    static void search(int hh, int ww, char[][] field, Counter cn) {\n        if (hh < 0 || hh >= field.length || ww < 0 || ww >= field[hh].length || field[hh][ww] != '.') {\n            return;\n        }\n        cn.up();\n        field[hh][ww] = '#';\n        search(hh - 1, ww, field, cn);\n        search(hh + 1, ww, field, cn);\n        search(hh, ww - 1, field, cn);\n        search(hh, ww + 1, field, cn);\n    }\n    \n    static class Counter {\n        int count = 0;\n        \n        public void up() {\n            count++;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in);\n      while(true){\n      int N = sc.nextInt();\n      int M = sc.nextInt(); sc.nextLine(); //nextIntの後残る改行文字を消す\n      if(N==0&&M==0){break;}\n      int count=0;\n      String[] line = new String[M];\n      for(int i=0;i<M;i++){\n      \tline[i]=sc.nextLine();\n      } \n      String[][] a = new String[N][M];\n      for(int j=0;j<M;j++){\n       for(int k=0;k<N;k++){\n        a[k][j]=String.valueOf(line[j].charAt(k));\n       }\n      }\n      for(int t=0;t<60;t++){\n       for(int p=0;p<M;p++){\n        for(int q=0;q<N;q++){\n         if((a[q][p].equals(\"@\"))&&(a[Math.max(0,q-1)][p].equals(\".\"))){\n         \ta[Math.max(0,q-1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.max(0,p-1)].equals(\".\"))){\n         \ta[q][Math.max(0,p-1)]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[Math.min(N-1,q+1)][p].equals(\".\"))){\n         \ta[Math.min(N-1,q+1)][p]=\"@\";\n         }\n         if((a[q][p].equals(\"@\"))&&(a[q][Math.min(M-1,p+1)].equals(\".\"))){\n         \ta[q][Math.min(M-1,p+1)]=\"@\";\n         }\n        }\n       }\n      }\n      for(int r=0;r<M;r++){\n       for(int s=0;s<N;s++){\n         if(a[s][r].equals(\"@\")){\n         \tcount++;\n         }\n       }\n      }\n     System.out.println(count);\n      }\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static final int MAX = 20;\n\t\n\tpublic static boolean is_ok(int x, int y, int H, int W){\n\t\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][] can_enter = new boolean[MAX][MAX];\n\t\tboolean[][] visited = new boolean[MAX][MAX];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint s_x = -1, s_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\tcan_enter[i][j] = false;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcan_enter[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(input[j] == '@'){\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\t\tvisited[s_y][s_x] = true;\n\t\t\tx_queue.add(s_x);\n\t\t\ty_queue.add(s_y);\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(!x_queue.isEmpty()){\n\t\t\t\tfinal int x = x_queue.poll();\n\t\t\t\tfinal int y = y_queue.poll();\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(nx, ny, H, W)){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(!can_enter[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n/**\n * @author yousack\n */\npublic class Main {\n    static Scanner in = new Scanner(System.in);\n        \n    public static void main(String[] args) {\n        while (true) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n\n            if (W == 0 && H == 0) {\n                break;\n            } else {\n                char[][] field = new char[H][W];\n                int r = 0, c = 0;\n\n                for (int i = 0; i < H; i++) {\n                    field[i] = in.next().toCharArray();\n                    for (int j = 0; j < W; j++) {\n                        if (field[i][j] == '@') {\n                            field[i][j] = '.';\n                            r = i;\n                            c = j;\n                        }\n                    }\n                }\n                \n                dfs(field, r, c);\n            }\n        }\n    }\n    \n    public static void dfs(char[][] f, int r, int c) {\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.add(new int[]{r, c});\n        int counter = 0;\n        int[][] dirArray = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        \n        while (!queue.isEmpty()) {\n            int[] curPos = queue.poll();\n            int curR = curPos[0], curC = curPos[1];\n            if (f[curR][curC] == '.') {\n                counter++;\n                f[curR][curC] = '@';\n                for (int[] next : dirArray) {\n                    if (ok(curR + next[0], curC + next[1], f.length, f[0].length)) {\n                        queue.add(new int[]{curR + next[0], curC + next[1]});\n                    }\n                }\n            }\n        }\n\n        System.out.println(counter);\n    }\n    \n    public static boolean ok(int posR, int posC, int boundR, int boundC) {\n        return 0 <= posR && posR < boundR && 0 <= posC && posC < boundC;         \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w=sc.nextInt();\n\t\t\tint h=sc.nextInt();\n\t\t\tString gomi = sc.nextLine();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint start_w=0,start_h=0;\n\t\t\tfor(int i=0;i<h;++i){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString[] line2=line.split(\"\");\n\t\t\t\tfor(int j=0;j<w;++j){\n\t\t\t\t\tif(line2[j].equals(\"#\")){\n\t\t\t\t\t\tmap[i][j]=-1;\n\t\t\t\t\t} else if(line2[j].equals(\"@\")){\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t\tstart_w=j; start_h=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count=1;\n\t\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\t\tqueue.add(new Node(start_h, start_w));\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode cur = queue.remove();\n\t\t\t\tif(cur.h!=0){\n\t\t\t\t\tif(map[cur.h-1][cur.w]==0){\n\t\t\t\t\t\tcount++; map[cur.h-1][cur.w]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h-1,cur.w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.h!=h-1){\n\t\t\t\t\tif(map[cur.h+1][cur.w]==0){\n\t\t\t\t\t\tcount++; map[cur.h+1][cur.w]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h+1,cur.w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.w!=0){\n\t\t\t\t\tif(map[cur.h][cur.w-1]==0){\n\t\t\t\t\t\tcount++; map[cur.h][cur.w-1]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h,cur.w-1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cur.w!=w-1){\n\t\t\t\t\tif(map[cur.h][cur.w+1]==0){\n\t\t\t\t\t\tcount++; map[cur.h][cur.w+1]=1;\n\t\t\t\t\t\tqueue.add(new Node(cur.h,cur.w+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\nclass Node{\n\tint h,w;\n\tNode(int w,int h){\n\t\tthis.h=w;\n\t\tthis.w=h;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package com.company;\n\nimport java.io.File;\nimport java.util.Scanner;\n\n/**\n * Created by YuyaKita on 2015/05/18.\n */\npublic class Main {\n    static final int MAX_W = 20, MAX_H = 20;\n    static int W, H;\n    static char[][] tiles = new char[MAX_H + 1][MAX_W + 1];\n    static int count = 0;\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n\n    public static void main(String args[]){\n\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            W = sc.nextInt();\n            H = sc.nextInt();\n            if (W == 0 && H == 0){\n                break;\n            }\n            sc.nextLine();\n            for (int i = 0; i < H; i++) {\n                tiles[i] = sc.nextLine().toCharArray();\n            }\n\n            System.out.println(solve(tiles));\n        }\n            sc.close();\n\n    }\n\n    static int solve(char[][] input) {javascript:void(0)\n        count = 0;\n        for (int i = 0; i < W; i++) {\n            for (int j = 0; j < H; j++) {\n                if (tiles[j][i] == '@') dfs(i, j);\n            }\n        }\n        return count;\n    }\n\n    static void dfs(int x, int y) {\n        count++;\n        tiles[y][x] = '#';\n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && tiles[ny][nx] == '.') {\n\n                dfs(nx, ny);\n            }\n        }\n\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main\n{\n\tprivate static final int[] D = { 1, 0, -1, 0 };\n\t\n\tprivate static int W, H;\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W==0 && H==0) break;\n\t\t\t\n\t\t\tboolean[][] red = new boolean[W][H];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor (int y = 0; y < H; y++)\n\t\t\t{\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\t{\n\t\t\t\t\tchar c = line.charAt(x);\n\t\t\t\t\tswitch (c)\n\t\t\t\t\t{\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tred[x][y] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tsx = x;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(red, sx, sy));\n\t\t}\n\t}\n\t\n\tprivate static boolean valid(int x, int y)\n\t{\n\t\treturn 0 <= x && x < W && 0 <= y && y < H;\n\t}\n\t\n\tprivate static int dfs(boolean[][] red, int sx, int sy)\n\t{\n\t\tred[sx][sy] = true;\n\t\t\n\t\tint count = 1;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint x = sx + D[i];\n\t\t\tint y = sy + D[(i + 1) % 4];\n\t\t\tif (valid(x, y) && !red[x][y])\n\t\t\t{\n\t\t\t\tcount += dfs(red, x, y);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().solve();\n\t}\n\n\tprivate void solve() throws IOException {\n\t\ttry {\n\t\t\tsolveA();\n\t\t} finally {\n\t\t\tif (in != null) {\n\t\t\t\tin.close();\n\t\t\t}\n\t\t\tif (out != null) {\n\t\t\t\tout.flush();\n\t\t\t\tout.close();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void solveA() {\n\t\tint w = nextInt();\n\t\tint h = nextInt();\n\n\t\twhile (w != 0 && h != 0) {\n\t\t\tchar[][] map = Stream.generate(() -> next().toCharArray()).limit(h).toArray(char[][]::new);\n\n\t\t\tint wkH = 0;\n\t\t\tint wkW = 0;\n\t\t\tboolean isDiscover = false;\n\t\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\t\tfor (int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\twkH = i;\n\t\t\t\t\t\twkW = j;\n\t\t\t\t\t\tisDiscover = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isDiscover) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong res = recursiveA(map, new boolean[h][w], h, w, wkH, wkW);\n\t\t\tout.println(res);\n\n\t\t\tw = nextInt();\n\t\t\th = nextInt();\n\t\t}\n\n\t}\n\n\tprivate long recursiveA(char[][] map, boolean[][] visit, int h, int w, int cH, int cW) {\n\t\tif (cH >= h || cW >= w || cH < 0 || cW < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (map[cH][cW] == '#') {\n\t\t\treturn 0;\n\t\t}\n\t\tif (visit[cH][cW]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvisit[cH][cW] = true;\n\t\tlong res = 1;\n\n\t\tfinal int[] d = new int[] { 0, 1, 0, -1 };\n\n\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\tint wkY = cH + d[i ^ 1];\n\t\t\tint wkX = cW + d[i];\n\t\t\tres += recursiveA(map, visit, h, w, wkY, wkX);\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int w, h;\n    static int[][] map;\n    static int c;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if ((w | h) == 0) {\n                break;\n            }\n            map = new int[h][w];\n            int sx = 0;\n            int sy = 0;\n            c = 0;\n            for (int i = 0; i < h; i++) {\n                String line = sc.next();\n                for (int j = 0; j < w; j++) {\n                    if (line.charAt(j) == '@') {\n                        sy = i;\n                        sx = j;\n                        map[i][j] = 0;\n                    } else {\n                        map[i][j] = line.charAt(j) == '.' ? 0 : 1;\n                    }\n                }\n            }\n            dfs(sy, sx);\n            System.out.println(c);\n        }\n    }\n\n    public static void dfs(int y, int x) {\n        if (y < 0 || y >= h || x < 0 || x >= w) {\n            return;\n        }\n        if (map[y][x] == 1) {\n            return;\n        }\n        map[y][x] = 1;\n        int[] d = new int[] { 0, 1, 0, -1, 0 };\n        for (int i = 0; i < 4; i++) {\n            dfs(y + d[i], x + d[i + 1]);\n        }\n        c++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n//18:55~19:33 44~54\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0&&h==0) break;\n\t\t\tString gomi = sc.nextLine();\n\t\t\tint[][] map = new int[h][w];\n\t\t\tQueue<Man> st = new LinkedList<>();\n\t\t\tint count=0;\n\t\t\tfor(int j=0;j<h;++j){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString[] line_b = line.split(\"\");\n\t\t\t\tfor (int i=0;i<w;++i){\n\t\t\t\t\tif(line_b[i].matches(\"#\")) map[j][i]=-1;\n\t\t\t\t\telse if(line_b[i].matches(\"@\")){\n\t\t\t\t\t\tmap[j][i]=1;\n\t\t\t\t\t\tst.add(new Man(i,j));\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!st.isEmpty()){\n\t\t\t\tMan syori = st.remove();\n\t\t\t\tif(-1<syori.remove_y()-1){\n\t\t\t\t\tif(map[syori.remove_y()-1][syori.remove_x()]==0){\n\t\t\t\t\t\tst.add(new Man(syori.remove_x(),syori.remove_y()-1));\n\t\t\t\t\t\tmap[syori.remove_y()-1][syori.remove_x()]=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(-1<syori.remove_x()-1){\n\t\t\t\t\tif(map[syori.remove_y()][syori.remove_x()-1]==0){\n\t\t\t\t\t\tst.add(new Man(syori.remove_x()-1,syori.remove_y()));\n\t\t\t\t\t\tmap[syori.remove_y()][syori.remove_x()-1]=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(syori.remove_x()+1<w){\n\t\t\t\t\tif(map[syori.remove_y()][syori.remove_x()+1]==0){\n\t\t\t\t\t\tst.add(new Man(syori.remove_x()+1,syori.remove_y()));\n\t\t\t\t\t\tmap[syori.remove_y()][syori.remove_x()+1]=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(syori.remove_y()+1<h){\n\t\t\t\t\tif(map[syori.remove_y()+1][syori.remove_x()]==0){\n\t\t\t\t\t\tst.add(new Man(syori.remove_x(),syori.remove_y()+1));\n\t\t\t\t\t\tmap[syori.remove_y()+1][syori.remove_x()]=1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}\n\nclass Man{\n\tprivate int x,y;\n\tMan(int x,int y){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\tint remove_x(){\n\t\treturn this.x;\n\t}\n\tint remove_y(){\n\t\treturn this.y;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.NoSuchElementException;\nimport java.util.Scanner;\n\npublic class Main {\n    static int c = 0;\n    static int[][] directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};\n    static int[][] m;\n\n    public static void spreadFrom(int x, int y) {\n        if (m[y][x] == 0) {\n            m[y][x] = 1;\n            c++;\n        }\n\n        for (int k =0; k < 4; k++) {\n            int nx = x + directions[k][0];\n            int ny = y + directions[k][1];\n            if (nx >= 0 && nx < m[y].length && ny >= 0 && ny < m.length) {\n                spreadFrom(nx, ny);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int W = sc.nextInt();\n        int H = sc.nextInt();\n        m = new int[H][W];\n        int[] start = new int[2];\n        for (int i = 0; i < H; i++) {\n            int[] row = new int[W];\n            String rowStr = sc.next();\n            for (int j = 0; j < W; j++) {\n                int point;\n                switch (Character.toString(rowStr.charAt(j))) {\n                    case \".\":\n                        point = 1;\n                        break;\n                    case \"#\":\n                        point = 0;\n                        break;\n                    case \"@\":\n                        point = 2;\n                        start[0] = i;\n                        start[1] = j;\n                        break;\n                    default:\n                        throw new NoSuchElementException();\n                }\n                m[i][j] = point;\n            }\n        }\n        System.out.println(c);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.io.IOException;\n\nclass Main \n{\n\tprivate static int[][] field;\n\tprivate static int W, H;\n\tprivate static Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint[] s;\n\n\t\twhile(init())\n\t\t{\n\t\t\ts = find_start();\n\t\t\tdfs(s[0], s[1]);\n\n\t\t\tSystem.out.println(calc());\n\t\t}\n\t}\n\n\tprivate static boolean init() throws IOException\n\t{\n\t\tString str;\n\t\t\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\n\t\tif(W == 0 && H == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfield = new int[H][W];\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tstr = sc.next();\n\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tswitch(str.charAt(j))\n\t\t\t\t{\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '#':\n\t\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '@':\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static int[] find_start()\n\t{\n\t\tint[] s = new int[2];\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t{\n\t\t\t\t\ts[0] = i;\n\t\t\t\t\ts[1] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprivate static void dfs(int i, int j)\n\t{\n\t\t// System.out.println(\"(\"+i+\",\"+j+\")\");\n\n\t\tif(0 < i && i < H - 1)\n\t\t{\n\t\t\t// up\n\t\t\tif(field[i - 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i - 1][j] = 1;\n\t\t\t\tdfs(i - 1, j);\n\t\t\t}\n\n\t\t\t// down\n\t\t\tif(field[i + 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i + 1][j] = 1;\n\t\t\t\tdfs(i + 1, j);\n\t\t\t}\n\t\t}\n\t\telse if(i == 0 && H != 1)\n\t\t{\n\t\t\t// down\n\t\t\tif(field[i + 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i + 1][j] = 1;\n\t\t\t\tdfs(i + 1, j);\n\t\t\t}\n\t\t}\n\t\telse if(i == H - 1 && H != 1)\n\t\t{\n\t\t\t// up\n\t\t\tif(field[i - 1][j] == 0)\n\t\t\t{\n\t\t\t\tfield[i - 1][j] = 1;\n\t\t\t\tdfs(i - 1, j);\n\t\t\t}\n\t\t}\n\n\t\tif(0 < j && j < W - 1)\n\t\t{\n\t\t\t// left\n\t\t\tif(field[i][j - 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j - 1] = 1;\n\t\t\t\tdfs(i, j - 1);\n\t\t\t}\n\n\t\t\t// right\n\t\t\tif(field[i][j + 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t\tdfs(i, j + 1);\n\t\t\t}\n\t\t}\n\t\telse if(j == 0 && W != 1)\n\t\t{\n\t\t\t// right\n\t\t\tif(field[i][j + 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j + 1] = 1;\n\t\t\t\tdfs(i, j + 1);\n\t\t\t}\n\t\t}\n\t\telse if(j == W - 1 && W != 1)\n\t\t{\n\t\t\t// left\n\t\t\tif(field[i][j - 1] == 0)\n\t\t\t{\n\t\t\t\tfield[i][j - 1] = 1;\n\t\t\t\tdfs(i, j - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int calc()\n\t{\n\t\tint cnt = 0;\n\n\t\tfor(int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif(field[i][j] == 1)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint w, h;\n\tchar[][] c;\n\tint[] dx = {0, -1, 1, 0};\n\tint[] dy = {-1, 0, 0, 1};\n\n\tint f(int x, int y) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || c[y][x] != '.') {\n\t\t\treturn 0;\n\t\t}\n\t\tc[y][x] = '#';\n\t\tint res = 1;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres += f(nx, ny);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tc = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tc[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint sx = 0, sy = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (c[i][j] == '@') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(f(sx, sy));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class RedandBlack {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile;\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            tile = new char[H+2][W+2];\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            /*for (int i = 0; i <= H+1; i++){\n                for(int j = 0; j <= W+1; j++){\n                    System.out.print(tile[i][j]);\n                }\n                System.out.println();\n            }\n            System.out.println(tile[y][x]);*/\n            System.out.println(countBlackTile(x, y));\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 1;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]);\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int topx = 0;\n  static int topy = 0;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n/*answer*/\n    int w, h, i, j, res;\n    char[][] field;\n    int[][] count;\n    int[] nowx, nowy;\n    String str;\n\n    for(;;){\n      w = sc.nextInt(); h = sc.nextInt();\n      if(w == 0 && h == 0)break;\n      field = new char[h][w]; count = new int[h][w];\n      nowx = new int[h * w + 1]; nowy = new int[h * w + 1];\n      for(i = 0;i < h;i++)for(j = 0;j < w;j++)count[i][j] = 0;\n      res = 0;\n\n      for(i = 0;i < h;i++){\n        str = sc.next();\n        for(j = 0;j < w;j++){\n          field[i][j] = str.charAt(j);\n          if(field[i][j] == '@'){\n            pushx(nowx, i); pushy(nowy, j); count[i][j]++; res++;\n          }\n        }\n      }\n\n      for(;;){\n        if(topx == 0)break;\n        i = seetopx(nowx); j = seetopy(nowy);\n        if(i != 0 && field[i - 1][j] == '.' && count[i - 1][j] == 0){\n          pushx(nowx, i - 1); pushy(nowy, j); count[i - 1][j]++; res++;\n        }else if(j != 0 && field[i][j - 1] == '.' && count[i][j - 1] == 0){\n          pushx(nowx, i); pushy(nowy, j - 1); count[i][j - 1]++; res++;\n        }else if(i != h - 1 && field[i + 1][j] == '.' && count[i + 1][j] == 0){\n          pushx(nowx, i + 1); pushy(nowy, j); count[i + 1][j]++; res++;\n        }else if(j != w - 1 && field[i][j + 1] == '.' && count[i][j + 1] == 0){\n          pushx(nowx, i); pushy(nowy, j + 1); count[i][j + 1]++; res++;\n        }else{\n          i = popx(nowx); j = popy(nowy);\n        }\n      }\n\n      out.println(res);\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n  private static int popx(int[] stack){\n    return stack[--topx];\n  }\n  private static void pushx(int[] stack, int a){\n    stack[topx++] = a; return;\n  }\n  private static int seetopx(int[] stack){\n    return stack[topx - 1];\n  }\n  private static int popy(int[] stack){\n    return stack[--topy];\n  }\n  private static void pushy(int[] stack, int a){\n    stack[topy++] = a; return;\n  }\n  private static int seetopy(int[] stack){\n    return stack[topy - 1];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n    \npublic class Main {\n  private static Scanner sc = new Scanner(System.in);\n  public static void main(String...args) {\n    while(sc.hasNext()) {\n      final int W = sc.nextInt();\n      final int H = sc.nextInt();\n      if (W == 0 && H == 0)\n        break;\n      solve(W, H);\n    }\n  }\n  private static void solve(final int W, final int H) {\n    final char[][] map = new char[H][];\n    for(int i = 0; i < H; i+;)\n      map[i] = sc.next().toCharArray();\n    final Deque<Integer> deq = new ArrayDeque<Integer>();\n    for(int i = 0; i < H; i++)\n      for(int j = 0; j < W; j++)\n        if(map[i][j] == '@')\n          deq.offer(i * W + j);\n    int ans = 0;\n    while(!deq.isEmpty()) {\n      final int p = deq.poll();\n      final int i = p / W;\n      final int j = p % W;\n      for(int d = 0; d < 4; d++) {\n        final int ni = i + di[d];\n        final int nj = j + dj[d];\n        if(0 <= ni && ni < H && 0 <= nj && nj < W && map[ni][nj] == '.') {\n          map[ni][nj] = '#';\n          deq.offer(ni * W + nj);\n          ans++;\n        }\n      }\n    }\n    System.out.println(ans);\n  }\n  private static final int[] di = { 1, 0, -1, 0};\n  private static final int[] dj = { 0, 1, 0, -1 };\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic final int RED = 1;\n\tstatic final int BLACK = 2;\n\tstatic final int VISITED = 3;\n\n\tstatic final int UP = 1;\n\tstatic final int DOWN = 2;\n\tstatic final int RIGHT = 3;\n\tstatic final int LEFT = 4;\n\tstatic final int START = 0;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true){\n\t\t\tString tmp = br.readLine();\n\t\t\t/*\n\t\t\tif(tmp == null){\n\t\t\t\tbreak;\n\t\t\t}*/\n\n\t\t\tString[] tmpArray = tmp.split(\" \");\n\n\t\t\tint width = Integer.parseInt(tmpArray[0]);\n\t\t\tint height = Integer.parseInt(tmpArray[1]);\n\n\t\t\tif(width == 0 && height == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] tiles = new int[height][width];\n\n\t\t\tint currentX = 0;\n\t\t\tint currentY = 0;\n\n\t\t\tfor(int i = 0; i < height; i++){\n\t\t\t\tString tmpStr = br.readLine();\n\t\t\t\tfor(int j = 0; j < width ; j++){\n\t\t\t\t\tchar tmpChar = tmpStr.charAt(j);\n\t\t\t\t\tif(tmpChar == '.' || tmpChar == '@'){\n\t\t\t\t\t\ttiles[i][j] = BLACK;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttiles[i][j] = RED;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(tmpChar == '@'){\n\t\t\t\t\t\tcurrentX = j;\n\t\t\t\t\t\tcurrentY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(visit(tiles, currentX, currentY, START));\n\t\t}\n\t}\n\n\tstatic int visit(int[][] tiles, int curX, int curY, int dest){\n\t\tint result = 1;\n\t\t\n\t\tif(!available(tiles, curX, curY)){\n\t\t\treturn 0;\n\t\t}\n\t\ttiles[curY][curX] = VISITED;\n\t\t\n\t\tresult += visit(tiles, curX-1, curY, dest);\n\t\tresult += visit(tiles, curX+1, curY, dest);\n\t\tresult += visit(tiles, curX, curY-1, dest);\n\t\tresult += visit(tiles, curX, curY+1, dest);\n\t\t\n\t\treturn result;\n\t}\n\n\tprivate static boolean available(int[][] tiles, int curX, int curY) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tif(curX < 0 || curX >= tiles[0].length || curY < 0 || curY >= tiles.length || tiles[curY][curX] == RED || tiles[curY][curX] == VISITED){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tchar[][] tile = new char[W][H];\n\t\t\tboolean[][] visited = new boolean[W][H];\n\t\t\t\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\t\ttile[j][i] = line.charAt(j);\n\t\t\t\t\t\n\t\t\t\t\tif(tile[j][i] == '@') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<XY> queue = new LinkedList<XY>();\n\t\t\t\n\t\t\t// init \n\t\t\tint count = 0;\n\t\t\tqueue.offer(new XY(sx, sy));\n\t\t\t\n\t\t\twhile(queue.size() > 0) {\n\t\t\t\tbfs(W, H, queue, tile, visited);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tpublic static void bfs(int W, int H, LinkedList<XY> queue, char[][] tile, boolean[][] visited) {\n\t\tXY current = queue.poll();\n\t\tint cx = current.x;\n\t\tint cy = current.y;\n\t\t\n\t\tint[] dx = new int[]{0, 1, 0, -1};\n\t\tint[] dy = new int[]{1, 0, -1, 0};\n\t\tfor(int i = 0; i < dx.length; i++) {\n\t\t\tint x = cx + dx[i];\n\t\t\tint y = cy + dy[i];\n\t\t\tif (x >= 0 && x < W && y >= 0 && y < H && !visited[x][y] && tile[x][y] == '.') {\n\t\t\t\tqueue.offer(new XY(x, y));\n\t\t\t\tvisited[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass XY {\n\tint x;\n\tint y;\n\tXY(int x, int y) { \n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static int[] moveX = {0,0,-1,1};\n\tpublic static int[] moveY = {-1,1,0,0};\n\tpublic static char[][] map;\n\tpublic static boolean[][] check;\n\tpublic static int ans = 0;\n\tpublic static int x, y;\n\n\tpublic static void main (String[] args) {\n\t\tnew Main().calc();\n\t}\n\n\tvoid calc () {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\n\t\t\tif (x == 0) break;\n\n\t\t\tans = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tans = 1;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid dfs (int y, int x) {\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\tans++;\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/05/29.\n */\npublic class Main {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[][] tile = new char[22][22];\n    static char black_tile = '.', red_tile = '#', player_tile = '@';\n    static int W = 0, H = 0;\n\n    public static void main(String args[]) {\n        int x = 0, y = 0;\n        while ((W = sc.nextInt()) != 0 && (H = sc.nextInt()) != 0) {\n            for (int i = 0; i <= W + 1; i++) tile[0][i] = red_tile;\n            for (int i = 1; i <= H; i++) tile[i] = (red_tile + sc.next() + red_tile).toCharArray();\n            for (int i = 0; i <= W + 1; i++) tile[H + 1][i] = red_tile;\n            outer:\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (tile[i][j] == player_tile) {\n                        x = j;\n                        y = i;\n                        break outer;\n                    }\n                }\n            }\n            System.out.println(countBlackTile(x, y)/4);\n        }\n    }\n\n    static int countBlackTile(int x, int y) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {-1, 0, 1, 0};\n        int count = 0;\n        if (tile[y][x] == red_tile) return 0;\n        else {\n            tile[y][x] = red_tile;\n            for(int i = 0; i < 4; i++) {\n                count += countBlackTile(x + dx[i], y + dy[i]) + 1;\n            }\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    private static final Scanner scn = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int w = 0;\n        int h = 0;\n        int y = 0;\n        int x = 0;\n        while((w = scn.nextInt()) > 0 | (h = scn.nextInt()) > 0) {\n            boolean[][] fld = new boolean[h][w];\n            for(int i = 0; i < h; i++) {\n                char[] ary = scn.next().toCharArray();\n                for(int j = 0; j < w; j++) {\n                    switch(ary[j]) {\n                      case '@':\n                        y = i;\n                        x = j;\n                      case '.':\n                        fld[i][j] = true;\n                        break;\n                      case '#':\n                        fld[i][j] = false;\n                        break;\n                      default:\n                        assert false;\n                    }\n                }\n            }\n            Counter counter = new Counter(fld, y, x);\n            counter.start();\n            try {\n                counter.join();\n            } catch(InterruptedException ignore) {}\n            System.out.println(counter.getSum());\n        }\n    }\n}\n\nclass Counter extends Thread {\n    private int y;\n    private int x;\n    private static int sum;\n    private static boolean[][] fld;\n\n    public Counter(boolean[][] fld, int y, int x) {\n        this(y, x);\n        this.sum = 0;\n        this.fld = fld;\n    }\n\n    private Counter(int y, int x) {\n        this.y = y;\n        this.x = x;\n    }\n\n    public int getSum() {\n        return sum;\n    }\n\n    @Override\n    public synchronized void run() {\n        try {\n            if(fld[y][x]) {\n                sum++;\n                fld[y][x] = false;\n                Counter top = new Counter(-~y, x);\n                Counter left = new Counter(y, ~-x);\n                Counter right = new Counter(y, -~x);\n                Counter bottom = new Counter(~-y, x);\n                top.start();\n                left.start();\n                right.start();\n                bottom.start();\n                try {\n                    top.join();\n                    left.join();\n                    right.join();\n                    bottom.join();\n                } catch(InterruptedException ignore) {}\n            }\n        } catch(ArrayIndexOutOfBoundsException ignore) {}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic char filed[][];\n\tstatic int mx[]={-1,0,1,0};\n\tstatic int my[]={0,-1,0,1};\n\tstatic int w,h,count;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint i,j,x=0,y=0;\n\t\tchar ch[];\n\t\twhile(true){\n\t\t\tcount=0;\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\t\t\tif(w+h==0) break;\n\t\t\t\n\t\t\tfiled=new char[h][w];\n\t\t\tch=new char[w];\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tch=sc.next().toCharArray();\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tfiled[i][j]=ch[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(filed[i][j]=='@'){\n\t\t\t\t\t\ty=i;\n\t\t\t\t\t\tx=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiled[y][x]='#';\n\t\t\tserch(x,y);\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic void serch(int x,int y){\n\t\tint i,nx,ny;\n\t\tcount++;\n\t\tfor(i=0;i<4;i++){\n\t\t\tnx=x+mx[i];\n\t\t\tny=y+my[i];\n\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h && filed[ny][nx]!='#'){\n\t\t\t\tfiled[ny][nx]='#';\n\t\t\t\tserch(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Field{\n\tStringBuilder map;\n\tint width;\n\tint height;\n\t\n\tField(int w,int h, String[] buf) throws IOException{\n\t\twidth = w;\n\t\theight= h;\n\t\tmap= new StringBuilder();\n\t\tStringBuilder edge= new StringBuilder();\n\t\tfor(int i=0;i<w+2;i++){\n\t\t\tedge.append(\"#\");\n\t\t}\n\t\tmap.append(edge);\n\t\tfor(int i=0;i<h;i++){\n\t\t\tmap.append(\"#\");\n\t\t\tmap.append(buf[i]);\n\t\t\tmap.append(\"#\");\n\t\t}\n\t\tmap.append(edge);\n\t}\n\t\n\tint point2int(int x, int y){\n\t\treturn (width+2)*y + x;\n\t}\n\tint int2x(int n){\n\t\treturn n%(width+2);\n\t}\n\tint int2y(int n){\n\t\treturn n/(width+2);\n\t}\n\t\n\tint[] neighbor(int x, int y){\n\t\tint[] neib= {point2int(x,y-1),point2int(x-1,y),point2int(x+1,y),point2int(x,y+1)};\n\t\treturn neib;\n\t}\n\tint[] neighbor(int n){\n\t\tint x= int2x(n); int y= int2y(n);\n\t\tint[] neib= {point2int(x,y-1),point2int(x-1,y),point2int(x+1,y),point2int(x,y+1)};\n\t\treturn neib;\n\t}\n\n\tchar charAt(int x, int y){\n\t\treturn map.charAt(point2int(x,y));\n\t}\n\tchar charAt(int n){\n\t\tint x= int2x(n); int y= int2y(n);\n\t\treturn map.charAt(point2int(x,y));\n\t}\n\t\n\tint countRange(){\n\t\tint cnt=0;\n\t\tfor(int i=0;i<map.length();i++){\n\t\t\tif( map.charAt(i)=='@' ){ cnt++; }\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tvoid traverse(){\n\t\tDeque<Integer> dfs= new LinkedList<Integer>();\n\t\tdfs.push(map.indexOf(\"@\"));\n\t\twhile( !dfs.isEmpty() ){\n\t\t\tint tmp  = dfs.peek();\n\t\t\tboolean reached= true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint next= neighbor(tmp)[i];\n\t\t\t\tif( charAt(next)=='.' ){\n\t\t\t\t\tmap.setCharAt(next, '@');\n\t\t\t\t\tdfs.push(next);\n\t\t\t\t\treached= false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(reached){ dfs.pop(); }\n\t\t}\n\n\t\tSystem.out.println(countRange());\n\t}\n}\n\npublic class Main{\n    public static void main(String args[]) throws Exception{\n    \tBufferedReader br= new BufferedReader(new InputStreamReader(System.in));\n    \tint width,height;\n    \twhile(true){\n    \t\tString[] buf= br.readLine().split(\" \");\n    \t\twidth = Integer.parseInt(buf[0]);\n    \t\theight= Integer.parseInt(buf[1]);\n    \t\tif( width!=0 || height!=0 ){\n    \t\t\tString[] buf_map= new String[height];\n    \t\t\tfor(int i=0;i<height;i++){\n    \t\t\t\tbuf_map[i]= br.readLine();\n    \t\t\t}\n    \t\t\tField f= new Field(width,height,buf_map); \n    \t\t\tf.traverse();\n    \t\t} else{ break; }\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] dx = { 0, 1, 0, -1 };\n    static int[] dy = { -1, 0, 1, 0 };\n    static long INF = Long.MAX_VALUE;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if (w == 0 && h == 0) {\n                return;\n            }\n            List<String> str = new ArrayList<>();\n            for (int i = 0; i < h; i++) {\n                str.add(sc.next());\n            }\n            int x = 0, y = 0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (str.get(i).charAt(j) == '@') {\n                        y = i;\n                        x = j;\n                    }\n                }\n            }\n            long[][] dist = bfs(new Point(x, y), str, h, w);\n            // System.out.println(Arrays.deepToString(dist));\n            long ans = 0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (dist[i][j] == INF) {\n                        continue;\n                    }\n                    ans++;\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n\n    public static long[][] bfs(Point s, List<String> str, int h, int w) {\n        long[][] dist = new long[h][w];\n        for (long[] d : dist) {\n            Arrays.fill(d, INF);\n        }\n        Queue<Point> que = new LinkedList<>();\n        dist[s.y][s.x] = 0;\n        que.offer(s);\n        while (!que.isEmpty()) {\n            Point p = que.poll();\n            // System.out.println(p);\n            for (int i = 0; i < 4; i++) {\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                if (nx < 0 || ny < 0 || nx >= w || ny >= h) {\n                    continue;\n                }\n                if (str.get(ny).charAt(nx) == '.' && dist[p.y][p.x] + 1 < dist[ny][nx]) {\n                    dist[ny][nx] = 1;\n                    que.offer(new Point(nx, ny));\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n\nclass Point {\n    int x;\n    int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public String toString() {\n        return String.format(\"(x = %d, y = %d)\", this.x, this.y);\n    }\n\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte())\n            return buffer[ptr++];\n        else\n            return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]))\n            ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n            throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int w, h, count, before;\n\tstatic int[][] dir = {{-1,0}, {0,-1}, {1,0}, {0, 1}};\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif(w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] pos = new int[2];\n\t\t\tint [][] c = new int[h][w];\n\t\t\tchar abc;\n\t\t\tString str = new String();\n\t\t\tfor(int i = 0; i < h; i++){/* ????????? */\n\t\t\t\tstr = sc.nextLine();/* ?????§???????????? */\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tabc = str.charAt(j);\n\t\t\t\t\tif(abc == '#'){\n\t\t\t\t\t\tc[i][j] = 0;\n\t\t\t\t\t}else if(abc == '.'){\n\t\t\t\t\t\tc[i][j] = 1;\n\t\t\t\t\t}else if(abc == '@'){\n\t\t\t\t\t\tc[i][j] = 1;\n\t\t\t\t\t\tpos[0] = i;\n\t\t\t\t\t\tpos[1] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcount = 0;\n\t\t\tbefore = 1;\n\t\t\tint y;\n\t\t\ty = search(c , pos[0], pos[1]);\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tpublic static int search(int[][] c, int i, int j){\n\t\tif(c[i][j] == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tc[i][j] = 0;\n\t\tcount++;\n\t\t\n\t\tint d = before + 2/* ????????°????????????????????´???????§???? */;\n\t\tif(d > 3){\n\t\t\td -= 4;\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\td++;\n\t\t\tif(d > 3){\n\t\t\t\td -= 4;\n\t\t\t}\n\t\t\t\n\t\t\tbefore = d;\n\t\t\tint x = i + dir[d][0], y = j + dir[d][1];\n\t\t\tif((x >= 0) && (x < h) && (y >= 0) && (y < w)){\n\t\t\t\tint z = search(c, x, y);\n\t\t\t}\n\t\t}\t\t\n\t\treturn 1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package aoj;\n\nimport java.util.Scanner;\n\n/**\n * AOJ id=1130\n * Red and Black\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\tif(w==0) break;\n\t\t\th = sc.nextInt();\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\tsolve(map);\n\t\t}\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map;\n\tpublic void solve(char[][] map) {\n\t\tint sx = -1;\n\t\tint sy = -1;\n\t\tfor(int i=0;i<map.length;i++){\n\t\t\tfor(int j=0;j<map[i].length;j++){\n\t\t\t\tif(map[i][j]=='@'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sx>=0)\n\t\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(rec(sx, sy));\n\t\t\n\t}\n\n\tint[] dx = { -1, 0, 1, 0 };\n\tint[] dy = { 0, -1, 0, 1 };\n\tprivate int rec(int curx, int cury) {\n\t\tif(map[cury][curx]=='#')\n\t\t\treturn 0;\t\n\t\t\n\t\tmap[cury][curx] = '#';\n\t\tint res = 1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = curx + dx[i];\n\t\t\tint ny = cury + dy[i];\n\t\t\t\n\t\t\tif(nx<0 || w<=nx || ny<0 || h<=ny)\n\t\t\t\tcontinue;\n\t\t\tres += rec(nx, ny);\n\t\t}\n\t\t\n\t\t\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tstatic int w;\n\tstatic int h;\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc.nextLine();\n\t\t\tint[][] map = new int[w][h];\n\t\t\tString line;\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tline = sc.nextLine();\n\t\t\t\tfor(int j = 0; j < w ; j++){\n\t\t\t\t\tif(line.charAt(j) == '.'){\n\t\t\t\t\t\tmap[j][i] = 1;\n\t\t\t\t\t}else if(line.charAt(j) == '#'){\n\t\t\t\t\t\tmap[j][i] = 0;\n\t\t\t\t\t}else if(line.charAt(j) == '@'){\n\t\t\t\t\t\tmap[j][i] = 2;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap = Sosaku(x , y, map);\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(map[j][i] == 2){\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\n\tprivate static int[][] Sosaku(int x, int y, int[][] map) {\n\t\tif(x < w - 1 && map[x + 1][y] == 1){\n\t\t\tmap[x + 1][y] = 2;\n\t\t\tmap = Sosaku(x + 1, y, map);\n\t\t}\n\t\tif(x > 0 && map[x -1][y] == 1){\n\t\t\tmap[x - 1][y] = 2;\n\t\t\tmap = Sosaku(x - 1, y, map);\n\t\t}\n\t\tif(y < h - 1 && map[x][y + 1] == 1){\n\t\t\tmap[x][y + 1] = 2;\n\t\t\tmap = Sosaku(x, y + 1, map);\n\t\t}\n\t\tif(y > 0 && map[x][y - 1] == 1){\n\t\t\tmap[x][y - 1] = 2;\n\t\t\tmap = Sosaku(x, y - 1, map);\n\t\t}\n\t\treturn map;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static int[] moveX = {0,0,-1,1};\n\tpublic static int[] moveY = {-1,1,0,0};\n\tpublic static char[][] map;\n\tpublic static boolean[][] check;\n\n\tpublic static void dfs (int y, int x) {\n\n\t\tfor (int i = 0; i < moveX.length; i++) {\n\t\t\tint nextX = x + moveX[i];\n\t\t\tint nextY = y + moveY[i];\n\n\t\t\tif (0 <= nextX && nextX < map[0].length &&\n\t\t\t\t0 <= nextY && nextY < map.length &&\n\t\t\t\tmap[nextY][nextX] == '.' &&\n\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\tdfs(nextY,nextX);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tpublic static void main (String[] args) {\n\n\t\twhile (true) {\n\t\t\tScanner sc = new Scanner(System.in);\n\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\n\t\t\tif (x == 0) break;\n\n\t\t\tint ans = 0;\n\t\t\tint startX = 0, startY = 0;\n\t\t\tmap = new char[y][x];\n\t\t\tcheck = new boolean[y][x];\n\n\t\t\tfor (int i = 0; i < y; i++)\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\n\t\t\tmain:\n\t\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tif (map[i][j] == '@') {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tbreak main;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdfs(startY,startX);\n\n\t\t\tfor (boolean[] ch : check) {\n\t\t\t\tfor (boolean c : ch)\n\t\t\t\t\tif (c) ans++;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic char[] l = new char[] {'q','w','e','r','t','a','s','d','f','g','z','x','c','v','b'};\n\tstatic String[][] map;\n\tstatic boolean[][] vmap;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = stdIn.nextInt();\n\t\t\tint h = stdIn.nextInt();\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\tmap = new String[h][w];\n\t\t\tvmap = new boolean[h][w];\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tString a = stdIn.next();\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tmap[i][j] = String.valueOf(a.charAt(j));\n\t\t\t\t\tif(a.charAt(j) == '@') {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorv(y,x);\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(vmap[i][j]) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void sorv(int y,int x) {\n\t\tif(y < 0 || x < 0) return;\n\t\tif(y >= map.length || x >= map[y].length) return;\n\t\tif(map[y][x].equals(\"#\")) return;\n\t\tif(vmap[y][x]) return;\n\t\tvmap[y][x] = true;\n\t\tsorv(y+1,x);\n\t\tsorv(y-1,x);\n\t\tsorv(y,x+1);\n\t\tsorv(y,x-1);\n\t\t\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AOJ11\n{\n    public static void Main()\n    {\n        int W, H;\n        string[] field = new string[20];\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, -1, 0, 1 };\n        Queue q = new Queue();\n        while (true)\n        {\n            string[] v = Console.ReadLine().Split(' ');\n            W = Int32.Parse(v[0]); H = Int32.Parse(v[1]);\n            if (W == 0 && H == 0) break;\n            for (int i = 0; i < H; i++) field[i] = Console.ReadLine();\n            bool[,] flag = new bool[H, W];\n            for (int i = 0; i < H; i++)\n            {\n                for (int j = 0; j < W; j++)\n                {\n                    if (field[i][j] == '@')\n                    {\n                        q.Enqueue(new KeyValuePair<int, int>(i, j));\n                        flag[i, j] = true;\n                        goto stop;\n                    }\n                }\n            }\n        stop:\n            while (q.Count > 0)\n            {\n                KeyValuePair<int, int> T = (KeyValuePair<int, int>)q.Peek();\n                int y = T.Key; int x = T.Value;\n                q.Dequeue();\n                for (int i = 0; i < 4; i++)\n                {\n                    if (x + dx[i] < 0 || W <= x + dx[i] || y + dy[i] < 0 || H <= y + dy[i]) continue;\n                    if (field[y + dy[i]][x + dx[i]] == '#' || flag[y + dy[i], x + dx[i]] == true) continue;\n                    flag[y + dy[i], x + dx[i]] = true;\n                    q.Enqueue(new KeyValuePair<int, int>(y + dy[i], x + dx[i]));\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (flag[i, j] == true) cnt++;\n            Console.WriteLine(cnt);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CompetitiveProg\n{\n    class Program\n    {\n        static int w, h;\n        static int[,] room;\n        static bool[,] roomVisited;\n        static int count;\n        static void Main(string[] args)\n        {\n            var ans = new List<int>();\n            while(true)\n            {\n                count = 0;\n                var wh = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n                if (wh[0] == 0 && wh[1] == 0) break;\n                w = wh[0]; h = wh[1];\n                room = new int[w, h];\n                roomVisited = new bool[w, h];\n                int[] start = new int[2];\n                for (int j = 0; j < h; j++)\n                {\n                    var row = Console.ReadLine();\n                    var i = 0;\n                    foreach (var r in row)\n                    {\n                        switch (r)\n                        {\n                            case '.':\n                                room[i, j] = 1;\n                                break;\n                            case '#':\n                                room[i, j] = 0;\n                                break;\n                            case '@':\n                                room[i, j] = 1;\n                                start = new[] { i, j };\n                                break;\n                        }\n                        i++;\n                    }\n\n\n                }\n                for (int i = 0; i < w; i++)\n                {\n                    for (int j = 0; j < h; j++)\n                    {\n                        roomVisited[i, j] = false;\n                    }\n                }\n                dfs(start[0], start[1]);\n                ans.Add(count);\n            }\n            foreach (var c in ans)\n            {\n                Console.WriteLine(c);\n            }\n            \n\n        }\n        static void dfs(int startx,int starty)\n        {\n            if (roomVisited[startx, starty]) return;\n            roomVisited[startx, starty] = true;\n            count++;\n            if ((startx - 1 >= 0) && room[startx - 1, starty]==1)\n            {\n                dfs(startx - 1, starty);\n            }\n            if ((starty - 1 >= 0)&& room[startx , starty-1]==1)\n            {\n                dfs(startx, starty-1);\n            }\n            if ((startx + 1<w)&& room[startx + 1, starty]==1)\n            {\n                dfs(startx + 1, starty);\n            }\n            if ((starty + 1 < h) && room[startx , starty+1] == 1)\n            {\n                dfs(startx, starty+1);\n            }\n        }\n       \n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class AOJ11\n{\n    public static void Main()\n    {\n        int W, H;\n        string[] field = new string[20];\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, -1, 0, 1 };\n        Queue q = new Queue();\n        while (true)\n        {\n            string[] v = Console.ReadLine().Split(' ');\n            W = Int32.Parse(v[0]); H = Int32.Parse(v[1]);\n            if (W == 0 && H == 0) break;\n            for (int i = 0; i < H; i++) field[i] = Console.ReadLine();\n            bool[,] flag=new bool[ H, W];\n            for (int i = 0; i < H; i++)\n            {\n                for (int j = 0; j < W; j++)\n                {\n                    if (field[i][j] == '@')\n                    {\n                        q.Enqueue(new KeyValuePair<int, int>(i, j));\n                        flag[i, j] = true;\n                        break;\n                    }\n                }\n                if (q.Count != 0) break;\n            }\n            while (q.Count > 0)\n            {\n                KeyValuePair<int, int> T = (KeyValuePair<int,int>)q.Peek();\n                int y = T.Key; int x = T.Value;\n                q.Dequeue();\n                for (int i = 0; i < 4; i++)\n                {\n                    if (x + dx[i] < 0 || W <= x + dx[i] || y + dy[i] < 0 || H <= y + dy[i]) continue;\n                    if (field[y + dy[i]][x + dx[i]] == '#' || flag[y + dy[i], x + dx[i]] == true) continue;\n                    flag[y + dy[i], x + dx[i]] = true;\n                    q.Enqueue(new KeyValuePair<int, int>(y+dy[i],x+dx[i]));\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (flag[i, j] == true) cnt++;\n            Console.WriteLine(cnt);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            for (;;)\n            {\n                var w = ri;\n                var h = ri;\n                if (w == 0) return;\n                var s = Enumerate(h, x => rs);\n                var vis = Enumerate(h, x => new bool[w]);\n                var q = new Queue<int>();\n                var ans = 0;\n                for (int i = 0; i < h; i++)\n                    for (int j = 0; j < w; j++)\n                        if (s[i][j] == '@') { q.Enqueue(i * w + j); vis[i][j] = true; }\n\n                while (q.Any())\n                {\n                    var p = q.Dequeue();\n                    ans++;\n                    var px = p / w;\n                    var py = p % w;\n                    for (int k = 0; k < 4; k++)\n                    {\n                        var nx = px + dx[k];\n                        var ny = py + dy[k];\n                        if (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n                        if (s[nx][ny] == '#') continue;\n                        if (!vis[nx][ny])\n                        {\n                            vis[nx][ny] = true;\n                            q.Enqueue(nx * w + ny);\n                        }\n                    }\n                }\n                IO.Printer.Out.WriteLine(ans);\n            }\n        }\n\n        const long INF = 1L << 60;\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace _1130\n{\n    class Program\n    {\n        static int ret = 0;\n        static bool[,] tile;\n        static void bfs(int x,int y)\n        {\n            tile[x,y] = false; ret++;\n            if (tile[x + 1,y]) bfs(x + 1,y);\n            if (tile[x - 1,y]) bfs(x - 1,y);\n            if (tile[x,y + 1]) bfs(x,y + 1);\n            if (tile[x,y - 1]) bfs(x,y - 1);\n        }\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                ret = 0;\n                int[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n                if (x.Max() == 0) break;\n                tile = new bool[x[1] + 2,x[0] + 2]; int[] start = new int[2];\n                for (int i = 0; i < x[1]; i++)\n                {\n                    string s = Console.ReadLine();\n                    for (int j = 0; j < x[0]; j++)\n                    {\n                        if (s[j] == '@')\n                        {\n                            start[0] = i + 1; start[1] = j + 1;\n                        }\n                        tile[i + 1,j + 1] = s[j] == '.';\n                    }\n                }\n                bfs(start[0],start[1]);\n                Console.WriteLine(ret);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\npublic static class P\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var wh = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            var w = wh[0];\n            var h = wh[1];\n            if (w == 0) break;\n            var map = Enumerable.Repeat(0, h).SelectMany(_ => Console.ReadLine()).ToArray();\n\n            List<int>[] graph = Enumerable.Repeat(0, h * w).Select(_ => new List<int>()).ToArray();\n            for (int i = 0; i < h - 1; i++)\n                for (int j = 0; j < w; j++)\n                { var id = i * w + j; graph[id].Add(id + w); graph[id + w].Add(id); }\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w - 1; j++)\n                { var id = i * w + j; graph[id].Add(id + 1); graph[id + 1].Add(id); }\n\n            var sInd = Array.IndexOf(map, '@');\n\n\n            int res = 0;\n            var arrived = new bool[w * h];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(sInd);\n            arrived[sInd] = true;\n            while (stack.Count != 0)\n            {\n                var elem = stack.Pop();\n                res++;\n                foreach (var item in graph[elem])\n                {\n                    if (map[item] == '#') continue;\n                    if (arrived[item]) continue;\n                    arrived[item] = true;\n                    stack.Push(item);\n                }\n            }\n            Console.WriteLine(res);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\n\nnamespace Test1 {\n\n    class ClassMain {\n\n        public static int cnt = 0;\n\n        public static void countUp(char[,] map, int y, int x) {\n            if (x < 0 || map.GetLength(1) <= x\n                || y < 0 || map.GetLength(0) <= y) {\n                    return;\n            }\n            if (map[y, x] != '.') { return; }\n            cnt++;\n            map[y, x] = 'X';\n            countUp(map, y - 1, x);\n            countUp(map, y, x-1);\n            countUp(map, y + 1, x);\n            countUp(map, y, x+1);            \n        }\n\n        public static void Main(String[] args) {\n            string line;\n            while ((line = Console.ReadLine()) != null) {\n                int[] ints = line.Split(' ').Select(int.Parse).ToArray();\n                int n = ints[0]; \n                //int n = int.Parse(line);                \n                if(n==0){break;}\n                int y = ints[1];\n\n                cnt = 0;\n                char[,] map = new char[y, n];\n                int startX = -1, startY = -1;\n                for (int i = 0; i < y; i++) {\n                    string str = Console.ReadLine();\n                    for (int j = 0; j < n; j++) {\n                        map[i, j] = str[j];\n                        if (str[j] == '@') {\n                            startX = j; startY = i;\n                        }\n                    }\n                }\n                //stored.\n\n                map[startY, startX] = '.';\n                countUp(map, startY, startX);\n                Console.WriteLine(cnt);\n\n            }   \n        }   \n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Cnt\n{\n    public int count { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map = new int[h, w];\n            var sx = 0; var sy = 0;\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                    if (s[j] == '#') map[i, j] = 2;\n                    else if (s[j] == '@') { sx = i; sy = j; }\n            }\n            var cnt = new Cnt();\n            goDfs(map, sx, sy, dx, dy ,cnt);\n            Console.WriteLine(cnt.count);\n        }\n    }\n    public static void goDfs (int[,] map, int x, int y, int[] dx, int[] dy ,Cnt cnt)\n    {\n        var h = map.GetLength(0);\n        var w = map.GetLength(1);\n        map[x, y] = 1;\n        cnt.count++;\n        for (int i = 0; i < 4; i++)\n        {\n            var nx = x + dx[i];  var ny = y + dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0) goDfs(map, nx, ny, dx, dy ,cnt);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nclass Program{\n  \n  static int w ,h;   \n  static int wn, hn;\n  static char [ ,]Dataset ;\n  static bool [,] Counted ;\n  static int output = 0;\n  \n  \n  static void Main(string[] args){\n    while (true){\n      string[] read = Console.ReadLine().Split(' ');\n      w = int.Parse(read[0]);\n      h = int.Parse(read[1]);\n      if(w == 0 || h == 0)break;\n      \n      Dataset = new char[w,h];\n      for(int i = 0; i < h ; i++){\n        string iread = Console.ReadLine();\n        for(int j = 0; j< w ; j++){\n          Dataset[j,i] = iread[j]; \n          if(Dataset[j,i] == '@' ){wn = j; hn = i;}\n        }\n      }\n      \n      Counted = new bool[w ,h] ;\n      Check();\n      Console.WriteLine(output);\n      output = 0;\n    }\n    \n    \n  } \n  \n  static void Check( ){\n      Counted[wn,hn]= true;\n      output ++;\n      \n        if(wn != 0 && !Counted[wn - 1 ,hn] && Dataset[wn -1,hn] != '#' ){\n          wn --;Check();wn++;\n        }if(hn != 0 && ! Counted[wn,hn - 1] && Dataset[wn,hn - 1] != '#'){\n          hn --;Check();hn++;\n        }if(wn != w - 1 && !Counted[wn + 1,hn] && Dataset[wn + 1,hn]  != '#'){\n          wn ++;Check();wn--;\n        }if(hn != h - 1 && !Counted[wn,hn + 1] && Dataset[wn,hn + 1] != '#'){\n          hn ++;Check();hn--;\n        }\n    }\n  \n}\n/*\n\n    int a,b,c;\n    a = int.Parse(Console.ReadLine()); //標準入力\n    string[] str = Console.ReadLine().Split(' ');//2つ以上のスペース区切り入力の取得\n    b = int.Parse(str[0]);  //数値で受け取りたい場合は変換する\n    c = int.Parse(str[1]);\n　　Console.Write(\"改行なし a = {0} b = {1} c = {2}\", a, b, c)//改行なし出力\n    Console.WriteLine(\"改行あり a = {0} b = {1} c = {2}\", a, b, c);//改行付き出力\n\n*/"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using Debug;\n//using static System.Globalization.CultureInfo;\n//using Edge = Pair<long, int>;\nusing System.Text;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solve();\n        //WriteLine(Solve());\n    }\n    static int[] wh;\n    static char[][] gred;\n    static void Solve()\n    {\n        wh = Input.ar;\n        while (wh[0] != 0 || wh[1] != 0)\n        {\n            var st = new Pair<int, int>();\n            gred = Input.gred(wh[1]);\n            for (var i = 0; i < wh[1]; i++)\n                for (var j = 0; j < wh[0]; j++)\n                    if (gred[i][j] == '@')\n                        st = new Pair<int, int>(i, j);\n            WriteLine(bfs(st));\n            wh = Input.ar;\n        }\n    }\n    static int[] gh = new[] { 0, 0, 1, -1 };\n    static int[] gw = new[] { 1, -1, 0, 0 };\n    static int bfs(Pair<int,int> st)\n    {\n        var que = new Queue<Pair<int, int>>();\n        var th = new bool[wh[1],wh[0]];\n        que.Enqueue(new Pair<int, int>(st.v1, st.v2));\n        th[st.v1, st.v2] = true;var res = 1;\n        while (que.Any())\n        {\n            var p = que.Dequeue();\n            for (var i = 0; i < 4; i++)\n            {\n                var h = p.v1 + gh[i];\n                var w = p.v2 + gw[i];\n                if (!Search.Inside(h, w, wh.Reverse().ToArray()) || th[h,w]||gred[h][w]=='#') continue;\n                que.Enqueue(new Pair<int, int>(h, w));res++;th[h, w] = true;\n            }\n        }\n        return res;\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public  static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public  static long numL => ToInt64(read);\n    public static char[][] gred(int h) \n        => Enumerable.Repeat(0, h).Select(_ => read.ToCharArray()).ToArray();\n    public static int[] ar1D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => num).ToArray();\n    public static long[] arL1D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => numL).ToArray();\n    public static string[] strs(int n)\n        => Enumerable.Repeat(0, n).Select(_ => read).ToArray();\n    public static int[][] ar2D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => ar).ToArray();\n    public static long[][] arL2D(int n)\n        => Enumerable.Repeat(0, n).Select(_ => arL).ToArray();\n    public static T getValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public  const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public  const int MOD = 1000000007;\n}\n\npublic class Search\n{\n    public static int UpperBound<T>(IList<T> array,T value)\n        where T : IComparable<T>\n    {\n        var low = 0;\n        var high = array.Count;\n        while (high > low)\n        {\n            var mid = (high + low) / 2;\n            if (array[mid].CompareTo(value) == 1) high = mid;\n            else low = mid + 1;\n        }\n        return low;\n    }\n    \n    public static int LowerBound<T>(IList<T> array,T value)\n        where T : IComparable<T>\n    {\n        var low = 0;\n        var high = array.Count;\n        while (high > low)\n        {\n            var mid = (high + low) / 2;\n            if (array[mid].CompareTo(value) != -1) high = mid;\n            else low = mid + 1;\n        }\n        return low;\n    }\n\n    public static T Max<T>(params T[] array)\n        => array.Max();\n    public static T Min<T>(params T[] array)\n        => array.Min();\n    public static bool Inside(int h, int w, int[] hw)\n        => 0 <= h && h < hw[0] && 0 <= w && w < hw[1];\n    public static bool IsPrime(long num)\n    {\n        if (num % 2 == 0 || num == 1) return num == 2;\n        for (var i = 3L; i * i <= num; i += 2)\n            if (num % i == 0) return false;\n        return true;\n    }\n\n}\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() : this(default(T1), default(T2)) { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1;this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public static Pair<T1, T2> MakePair()\n    {\n        var r = ReadLine().Split(' ');\n        return new Pair<T1, T2>(Input.getValue<T1>(r[0]), Input.getValue<T2>(r[1]));\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace CSharpSample01\n{\n    public class Point\n    {\n        public int h;\n        public int w;\n        public Point(int i, int j)\n        {\n            h = i;\n            w = j;\n        }\n    }\n\n\n    class Program\n    {\n    \n        static void Main(string[] args)\n        {\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int W = int.Parse(input[0]);\n                int H = int.Parse(input[1]);\n\n                if(H == 0 && W == 0)\n                {\n                    break;\n                }\n\n                char[,] masu = new char[H, W];\n                Point start = new Point(0, 0);\n                bool[,] visited = new bool[H, W];\n                \n                for(int i = 0; i < H; i++)\n                {\n                    string s = Console.ReadLine();\n\n                    for(int j = 0; j < W; j++)\n                    {\n                        if(s[j] == '@')\n                        {\n                            start.h = i;\n                            start.w = j;\n                        }\n                        masu[i, j] = s[j];\n                    }\n                }\n\n                Stack<Point> stack = new Stack<Point>();\n                stack.Push(start);\n                int reach_num = 1;\n                int h = start.h;\n                int w = start.w;\n                Point now_point;\n\n                while (true)\n                {               \n                    bool can_go = false;\n\n                    if(h - 1 >= 0 && masu[h - 1, w] == '.' && !visited[h - 1, w])\n                    {\n                        visited[h - 1, w] = true;\n                        reach_num++;\n                        stack.Push(new Point(h, w));\n                        h--;\n                        can_go = true;\n                    }\n                    else if (h + 1 < H && masu[h + 1, w] == '.' && !visited[h + 1, w])\n                    {\n                        visited[h + 1, w] = true;\n                        reach_num++;\n                        stack.Push(new Point(h, w));\n                        h++;\n                        can_go = true;\n                    }\n                    else if (w - 1 >= 0 && masu[h, w - 1] == '.' && !visited[h, w - 1])\n                    {\n                        visited[h, w - 1] = true;\n                        reach_num++;\n                        stack.Push(new Point(h, w));\n                        w--;\n                        can_go = true;\n                    }\n                    else if (w + 1 < W && masu[h, w + 1] == '.' && !visited[h, w + 1])\n                    {\n                        visited[h, w + 1] = true;\n                        reach_num++;\n                        stack.Push(new Point(h, w));\n                        w++;\n                        can_go = true;\n                    }\n\n                    if (!can_go)\n                    {\n                        if(stack.Count == 0)\n                        {\n                            break;\n                        }\n                        now_point = stack.Pop();\n                        h = now_point.h;\n                        w = now_point.w;\n                    }\n\n                }\n\n                Console.WriteLine(reach_num);\n                \n            }\n            \n        \n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\n\npublic class AOJ11\n{\n    public static void Main()\n    {\n        int W, H;\n        string[] field = new string[20];\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, -1, 0, 1 };\n        Queue q = new Queue();\n        while (true)\n        {\n            string[] v = Console.ReadLine().Split(' ');\n            W = Int32.Parse(v[0]); H = Int32.Parse(v[1]);\n            if (W == 0 && H == 0) break;\n            for (int i = 0; i < H; i++) field[i] = Console.ReadLine();\n            bool[,] flag=new bool[ H, W];\n            for (int i = 0; i < H; i++)\n            {\n                for (int j = 0; j < W; j++)\n                {\n                    if (field[i][j] == '@')\n                    {\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        flag[i, j] = true;\n                        break;\n                    }\n                }\n                if (q.Count != 0) break;\n            }\n            while (q.Count > 0)\n            {\n                Tuple<int, int> T = (Tuple<int,int>)q.Peek();\n                int y = T.Item1; int x = T.Item2;\n                q.Dequeue();\n                for (int i = 0; i < 4; i++)\n                {\n                    if (x + dx[i] < 0 || W <= x + dx[i] || y + dy[i] < 0 || H <= y + dy[i]) continue;\n                    if (field[y + dy[i]][x + dx[i]] == '#' || flag[y + dy[i], x + dx[i]] == true) continue;\n                    flag[y + dy[i], x + dx[i]] = true;\n                    q.Enqueue(new Tuple<int, int>(y+dy[i],x+dx[i]));\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (flag[i, j] == true) cnt++;\n            Console.WriteLine(cnt);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Tool;\n\nnamespace AtCoder\n{\n    class AC\n    {\n        const int mod = 1000000007;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n\n        static int[] dx = { 0, 0, 1, -1 };\n        static int[] dy = { 1, -1, 0, 0 };\n\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            //Console.SetOut(sw);\n            var cin = new Scanner();\n\n            while (true)\n            {\n                var input = cin.SplitRead();\n                if (input[0] == 0 && input[1] == 0) { return; }\n\n                int W = input[0];\n                int H = input[1];\n                char[,] tile = new char[H + 2, W + 2];\n                bool[,] seen = new bool[H + 2, W + 2];\n                int x0 = -1;\n                int y0 = -1;\n                for(var i = 0; i < H + 2; i++)\n                {\n                    if (i == 0 || i == H + 1)\n                    {\n                        for(var j = 0; j < W + 2; j++)\n                        {\n                            seen[i, j] = false;\n                            tile[i, j] = '#';\n                        }\n                        continue;\n                    }\n                    string s = Console.ReadLine();\n                    for(var j = 0; j < W + 2; j++)\n                    {\n                        seen[i, j] = false;\n                        tile[i, j] = j == 0 || j == W + 1 ? '#' : s[j - 1];\n                        if (tile[i,j] == '@')\n                        {\n                            x0 = i;\n                            y0 = j;\n                        }\n                    }\n                }\n                Dfs(tile, seen, x0, y0);\n                long ans = 0;\n                for(var i = 0; i < H + 2; i++)\n                {\n                    for(var j = 0; j < W + 2; j++)\n                    {\n                        ans += seen[i, j] ? 1 : 0;\n                    }\n                }\n\n                Console.WriteLine(ans);\n\n            }\n            //Console.Out.Flush();\n        }\n\n        public static void Dfs(char[,] tile, bool[,] seen, int curx, int cury)\n        {\n            seen[curx, cury] = true;\n            for(var i = 0; i < 4; i++)\n            {\n                int nextx = curx + dx[i];\n                int nexty = cury + dy[i];\n                if (seen[nextx, nexty] || tile[nextx, nexty] == '#')  { continue; }\n                Dfs(tile, seen, nextx, nexty);\n            }\n            return;\n        }\n\n        \n    }\n    public class Scanner\n    {\n        public int[] SplitRead()\n        {\n            int[] array = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return array;\n        }\n        public long[] SplitReadL()\n        {\n            long[] array = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return array;\n        }\n    }\n\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            for (var i = 0; i < array.Length; i++)\n            {\n                array[i] = initialvalue;\n            }\n        }\n        static public long Modulo(long value, long mod)\n        {\n            long r = value % mod;\n\n            if (r * mod < 0)\n            {\n                r += mod;\n            }\n            return r;\n        }\n    }\n\n    \n\n}\n\n\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V1130{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            while(true){\n                var W = sr.Next<int>();\n                var H = sr.Next<int>();\n                var S = sr.Next<string>(H);\n                if(W + H == 0) break;\n\n                var visit = new bool[H, W].ToJaggedArray();\n                var que = new Queue<int>();\n\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        if(S[i][j] == '@'){\n                            visit[i][j] = true;\n                            que.Enqueue(j);\n                            que.Enqueue(i);\n                        }\n                    }\n                }\n\n                var dx = new[]{0, 1, 0, -1};\n                var dy = new[]{1, 0, -1, 0};\n                Func<int, int, bool> isInside = (x, y) => 0 <= x && x < W && 0 <= y && y < H;\n\n                while(que.Count > 0){\n                    var x = que.Dequeue();\n                    var y = que.Dequeue();\n                    for(var i = 0; i < dx.Length; i++){\n                        var nx = x + dx[i];\n                        var ny = y + dy[i];\n                        if(isInside(nx, ny) && S[ny][nx] == '.' && !visit[ny][nx]){\n                            visit[ny][nx] = true;\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                        }\n                    }\n                }\n\n                Console.WriteLine(visit.SelectMany(a => a).Count(b => b));\n            }\n            //---------------------------------\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        } \n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   var dy=[0,0,-1,1];\n   var dx=[-1,1,0,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || yy>=H || xx<0 || xx>=W)continue;\n      if(yx[yy][xx]==\".\"){cnt++;yx[yy][xx]=cnt;bomb(yy,xx);}\n   }\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var WH=(Arr.shift()).split(\" \").map(Number);\n   var W=ab[0];\n   var H=ab[1];\n   if(W==0 && H==0)break;\n      var yx=[];\n      var Y,X;\n      for(var i=0;i<H;i++){\n         var arr=(Arr.shift()).split(\"\");\n         if(arr.indexOf(\"@\")!=-1){Y=i;X=arr.indexOf(\"@\");}\n         yx.push(arr);\n      }\n      var cnt=1;\n      bomb(Y,X);\n      console.log(cnt);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   var dy=[0,0,-1,1];\n   var dx=[-1,1,0,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || yy>=H || xx<0 || xx>=W)continue;\n      if(yx[yy][xx]==\".\"){cnt++;yx[yy][xx]=cnt;bomb(yy,xx);}\n   }\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var WH=(Arr.shift()).split(\" \").map(Number);\n   var W=WH[0];\n   var H=WH[1];\n   if(W==0 && H==0)break;\n      var yx=[];\n      var Y,X;\n      for(var i=0;i<H;i++){\n         var arr=(Arr.shift()).split(\"\");\n         if(arr.indexOf(\"@\")!=-1){Y=i;X=arr.indexOf(\"@\");}\n         yx.push(arr);\n      }\n      var cnt=1;\n      bomb(Y,X);\n      console.log(cnt);\n}"
  },
  {
    "language": "Ruby",
    "code": "def dfs cx, cy, lines, visited\n  return 0 if visited.include? [cx, cy]\n  visited << [cx, cy]\n\n  # p [cx, cy]\n  # p [lines[cy][cx + 1], lines[cy][cx - 1], lines[cy + 1][cx], lines[cy - 1][cx]]\n  res = 1\n  res += dfs cx + 1, cy, lines, visited if lines[cy][cx + 1] == \".\"\n  res += dfs cx - 1, cy, lines, visited if lines[cy][cx - 1] == \".\"\n  res += dfs cx, cy + 1, lines, visited if lines[cy + 1][cx] == \".\"\n  res += dfs cx, cy - 1, lines, visited if lines[cy - 1][cx] == \".\"\n\n  res\nend\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if w == 0\n  x = 0\n  y = 0\n  lines = [[\"#\"] * (w + 2)] # ??????\n  1.upto(h) do |i|\n    line = \"##{gets.chomp}#\".split \"\" # ??????\n    idx = line.index(\"@\")\n    if idx\n      line[idx] = \".\"\n      x = idx\n      y = i\n    end\n    lines << line\n  end\n  lines << [\"#\"] * (w + 2) # ??????\n\n  # require \"pp\"\n  # pp lines\n  # p [[x, y]]\n  puts dfs x, y, lines, []\nend"
  },
  {
    "language": "Ruby",
    "code": "# Red and Black\nrequire 'scanf'\n\ndef get_player_pos(map)\n  x = 0\n  y = 0\n\n  map.each_with_index do |row, yy|\n    x = row.index('@')\n    y = yy\n    break if x\n  end\n\n  [x, y]\nend\n\ndef walk(map, x, y)\n  map[y][x] = 'x'\n\n  walk(map, x, y + 1) if map[y + 1][x] == '.'\n  walk(map, x, y - 1) if map[y - 1][x] == '.'\n  walk(map, x + 1, y) if map[y][x + 1] == '.'\n  walk(map, x - 1, y) if map[y][x - 1] == '.'\nend\n\ndef count_walked(map)\n  w = 0\n\n  map.each do |row|\n    w += row.count('x')\n  end\n\n  w\nend\n\nwhile true\n  w, h = gets.scanf('%d %d')\n\n  break if w == 0 && h == 0\n\n  wall = '#' * (w + 2)\n  map = [wall]\n\n  h.times do\n    map << '#' + gets.chop + '#'\n  end\n\n  map << wall\n\n  pos = get_player_pos(map)\n\n  walk(map, *pos)\n  puts count_walked(map)\nend"
  },
  {
    "language": "Ruby",
    "code": "def calc(f, q, w, h)\n  n = 0\n  while q.size > 0\n    n += 1\n    p = q.shift\n    [[-1, 0], [0, -1], [0, 1], [1, 0]].each do |d|\n      i, j = p[0] + d[0], p[1] + d[1]\n      if i >= 0 && i < h && j >= 0 && j < w && f[i][j] == '.'\n        f[i][j] = '#'\n        q.push([i, j])\n      end\n    end\n  end\n  n\nend\nloop do\n  f, q = [], []\n  w, h = gets.split.map(&:to_i)\n  break if w + h == 0\n  h.times do |i|\n    f[i] = gets.chomp.split('')\n    j = f[i].index('@')\n    q[0] = [i, j] if j\n  end\n  puts calc(f, q, w, h)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef reachable_from(s, reached = Set.new, root = true)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treachable_from(v, reached, false) \n\t\t}\n\t\troot ? reached : nil\n\tend\nend\n\nloop{\n\tn, m = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tc = (1..m).map{ ['#'] + gets.chomp.split(\"\") + ['#'] }\n\ttmp = ['#'] * (n + 2)\n\tc = [tmp] + c + [tmp]\n\n\tg = Graph.new\n\tnodes = (0..m+1).map{|y| (0..n+1).map{|x| g.add_node(c[y][x])}}\t\n\ts = nil\n\n\tfor y in 0..m+1\n\t\tfor x in 0..n+1\n\t\t\tu = nodes[y][x]\n\t\t\tnext if u.label == '#'\n\t\t\ts = u if u.label == '@'\n\t\t\t[[0,1], [0,-1], [1,0], [-1,0]].each{|dy, dx|\n\t\t\t\tv = nodes[y+dy][x+dx]\n\t\t\t\tg.add_edge(u, v) if v.label == '.'\t\n\t\t\t}\n\t\tend\n\tend\n\t\n\tputs g.reachable_from(s).size\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  w, h = gets.split.map(&:to_i)\n  break if h == 0\n\n  field = h.times.map do\n    gets.chomp.split(//)\n  end\n\n\n  i, j = -> () {\n    field.each.with_index do |f, i|\n      f.each.with_index do |c, j|\n        return [i,j] if c == '@'\n      end\n    end\n  }.()\n\n  field[i][j] = '.'\n\n  walk = -> (x, y) {\n    return 0 if x < 0 || y < 0 || x >= h || y >= w\n    return 0 if field[x][y] != '.'\n    field[x][y] = 'x'\n    return 1 + \n      walk.(x+1, y) +\n      walk.(x-1, y) +\n      walk.(x, y-1) +\n      walk.(x, y+1)\n  }\n\n  cnt = walk.(i, j)\n\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "$stack = []\n$x=0\n$y=0\n$cnt = 0\n\ndef calc(x,y)\n\t$stack.push([x,y])\n\twhile $stack.size() != 0 do\n\t\t(posx,posy) = $stack.pop()\n\t\tif posx+1 < $x then\n\t\t\tcheck(posx+1,posy)\n\t\tend\n\t\tif posx-1 >= 0 then\n\t\t\tcheck(posx-1,posy)\n\t\tend\n\t\tif posy+1 < $y then\n\t\t\tcheck(posx,posy+1)\n\t\tend\n\t\tif posy-1 >= 0 then\n\t\t\tcheck(posx,posy-1)\n\t\tend\n\tend\nend\n\ndef check(x,y)\n\ttmp = $bord[y][x]\n\tif tmp == 0 then\n\t\t$bord[y][x] = 2\n\t\t$stack.push([x,y])\n\t\t$cnt += 1\n\tend\nend\n\t\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsx = 0\n\t\tsy = 0\n\t\t$cnt = 1 \n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tfor i in 1..$y\n\t\t\tline = gets\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = 0\n\t\t\t\tif line[j] == \"#\" then\n\t\t\t\t\ttmp = 1\n\t\t\t\telsif line[j] == \"@\" then\n\t\t\t\t\ttmp = 2\n\t\t\t\t\tsx = j\n\t\t\t\t\tsy = i-1\n\t\t\t\tend\n\t\t\t\t$bord[i-1][j] = tmp\n\t\t\tend\n\t\tend\n\t\tcalc(sx,sy)\n\t\tprint $cnt\n\t\tprint(\"\\n\")\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def ans b, m, n\n  r = 1\n  while true\n    r_new = r\n    m.times do |m0|\n      n.times do |n0|\n        if b[n0][m0] == '@' then\n\n          if (n0 - 1 >= 0) and (b[n0-1][m0] == '.') then\n            b[n0-1][m0] = '@'\n            r_new += 1\n          end\n\n          if (n0 + 1 < n) and (b[n0+1][m0] == '.') then\n            b[n0+1][m0] = '@'\n            r_new += 1\n          end\n\n          if (m0 - 1 >= 0) and (b[n0][m0-1] == '.') then\n            b[n0][m0-1] = '@'\n            r_new += 1\n          end\n\n          if (m0 + 1 < m) and (b[n0][m0+1] == '.') then\n            b[n0][m0+1] = '@'\n            r_new += 1\n          end\n        end\n      end\n    end\n    if r_new == r then\n      break\n    else\n      r = r_new\n    end      \n  end\n  return r\nend\n\nwhile true do\n\n  mn = $stdin.gets.chop.split(/ /).map { |x| x.to_i }\n  m = mn[0]\n  n = mn[1]\n\n  if m == 0 and n == 0 then\n    break\n  else\n    b = []\n    n.times do\n      b.push $stdin.gets.chomp\n    end\n\n    r = ans b, m, n\n    printf(\"%d\\n\", r)\n  end\n  \nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "# Red and Black\nrequire 'scanf'\n\ndef get_player_pos(map)\n  x = 0\n  y = 0\n\n  map.each_with_index do |row, yy|\n    x = row.index('@')\n    y = yy\n    break if x\n  end\n\n  [x, y]\nend\n\ndef walk(map, x, y)\n  map[y][x] = 'x'\n\n  walk(map, x, y + 1) if map[y + 1][x] == '.'\n  walk(map, x, y - 1) if map[y - 1][x] == '.'\n  walk(map, x + 1, y) if map[y][x + 1] == '.'\n  walk(map, x - 1, y) if map[y][x - 1] == '.'\nend\n\ndef count_walked(map)\n  w = 0\n\n  map.each do |row|\n    w += row.count('x')\n  end\n\n  w\nend\n\nwhile true\n  w, h = gets.scanf('%d %d')\n\n  break if w == 0 && h == 0\n\n  wall = '#' * (w + 2)\n  map = [wall]\n\n  h.times do\n    map << '#' + gets.chop + '#'\n  end\n\n  map << wall\n\n  pos = get_player_pos(map)\n\n  puts pos.join(', ')\n  puts map.join(\"\\n\")\n\n  walk(map, *pos)\n  puts count_walked(map)\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(x, y, dir, s, w, h)\n  @vis[y][x] = 1\n  (x>0 && dir!=1 && s[y][x-1]==\".\" && @vis[y][x-1]==0) ? (lf = 1+solve(x-1,y,2,s,w,h)):(lf = 0)\n  (x<w-1 && dir!=2 && s[y][x+1]==\".\" && @vis[y][x+1]==0) ? (ri = 1+solve(x+1,y,1,s,w,h)):(ri = 0)\n  (y>0 && dir!=3 && s[y-1][x]==\".\" && @vis[y-1][x]==0) ? (up = 1+solve(x,y-1,4,s,w,h)):(up = 0)\n  (y<h-1 && dir!=4 && s[y+1][x]==\".\" && @vis[y+1][x]==0) ? (dw = 1+solve(x,y+1,3,s,w,h)):(dw = 0)\n  return lf+ri+up+dw\nend\n  \n\nwhile (ln = gets.chomp) != \"0 0\"\n  w,h = ln.split.map(&:to_i)\n  s = h.times.map{gets.chomp.split(\"\")}\n  \n  @vis = Array.new(h).map{Array.new(w,0)}\n  for i in 0..(h-1)\n    for j in 0..(w-1)\n      if s[i][j] == \"@\"\n        sx = j\n        sy = i\n        break\n      end\n    end\n  end\n  \n  puts solve(sx, sy, 0, s, w, h)+1\nend\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### main\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if (w | h) == 0\n\n  tls = h.times.map{w.times.map{true}}\n  sx = sy = 0\n\n  for y in (0...h)\n    line = gets.strip\n    for x in (0...w)\n      case line[x]\n      when '#'\n        tls[y][x] = false\n      when '@'\n        sx = x\n        sy = y\n      end\n    end\n  end\n  #p tls\n  #p [sx, sy]\n\n  visited = h.times.map{w.times.map{false}}\n  visited[sy][sx] = true\n  count = 1\n  q = [[sx, sy]]\n\n  while ! q.empty?\n    x, y = q.shift\n\n    DXYS.each do |dx, dy|\n      x0 = x + dx\n      y0 = y + dy\n      if x0 >= 0 && x0 < w && y0 >= 0 && y0 < h &&\n          tls[y0][x0] && ! visited[y0][x0]\n        visited[y0][x0] = true\n        count += 1\n        q << [x0, y0]\n      end\n    end\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "def move(x,y,a)\n  return if(x < 0)\n  return if(y < 0)\n  return if(a.size <= y)\n  return if(a[0].size <= x)\n  return if(a[y][x] == \"#\")\n  a[y][x] = \"#\"\n  @ans += 1\n  move(x + 1, y ,a)\n  move(x - 1, y, a)\n  move(x, y + 1, a)\n  move(x, y - 1, a)\nend\nwhile (true)\n  w,h = gets.split.map &:to_i\n  break if(w == 0)\n  d = []\n  @ans = 0\n  x = y = 0\n  h.times do |i|\n    d[i] = gets.chomp\n    if(d[i].include?(\"@\"))\n      y = i\n      x = d[i].index(\"@\")\n    end\n  end\n  move(x, y, d)\n  p @ans\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\nrequire 'set'\n\nclass Number\n  def initialize num\n    @num = num\n  end\n\n  def == num\n    @num == num\n  end\n\n  attr_reader :num\nend\n\ndef main\n  loop do\n    w,h = gets.chomp.split(' ').map(&:to_i)\n    break if (w|h) == 0\n    puts solve(w, h)\n  end\nend\n\ndef solve w, h\n  grid = Array.new(h+1).map{Array.new(w+1, 0)}\n  sets = []\n  start_h = 0\n  start_w = 0\n  h.times do |i|\n    line = gets.chomp\n    line.each_char.with_index do |c, j|\n      grid[i+1][j+1] = case c\n      when '.' then Number.new(1)\n      when '@'\n        start_h = i + 1\n        start_w = j + 1\n        Number.new(1)\n      when '#' then Number.new(0)\n      end\n\n      next if grid[i+1][j+1] == 0\n\n      if grid[i+1][j] == 0 and grid[i][j+1] == 0\n        sets << Set.new([grid[i+1][j+1]])\n        next\n      end\n\n      left_set = nil\n      top_set = nil\n      sets.each do |set|\n        if set.include?(grid[i+1][j])\n          set << grid[i+1][j+1]\n          left_set = set\n        end\n\n        if set.include?(grid[i][j+1])\n          set << grid[i+1][j+1]\n          top_set = set\n        end\n      end\n\n      if left_set.nil? or top_set.nil?\n        next\n      end\n\n      union_set = nil\n      unless left_set.equal?(top_set)\n        union_set = left_set + top_set\n        sets.delete(left_set)\n        sets.delete(top_set)\n        sets << union_set\n      end\n    end\n  end\n\n  result = 0\n  sets.each do |set|\n    if set.include?(grid[start_h][start_w])\n      result = set.size\n      break\n    end\n  end\n  result\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "while true\n    w, h = gets.chomp.split.map(&:to_i)\n    break if [w, h] == [0, 0]\n\n    map = []\n    x, y = nil, nil\n    h.times{|j|\n        line = gets.chomp\n        map << line\n        if z = line.index(\"@\")\n            x, y = z, j\n        end\n    }\n#    map.each{|m| puts m}\n#    puts \"x#{x} y#{y}\"\n    sum = 0\n    list = [[x, y]]\n    until list.empty?\n        x2, y2 = list.pop\n        if map[y2][x2] != \"#\"\n            map[y2][x2] = \"#\"\n            sum += 1\n            list << [x2+1, y2] if x2 < w-1 && map[y2][x2+1] == \".\"\n            list << [x2-1, y2] if x2 > 0 && map[y2][x2-1] == \".\"\n            list << [x2, y2+1] if y2 < h-1 && map[y2+1][x2] == \".\"\n            list << [x2, y2-1] if y2 > 0 && map[y2-1][x2] == \".\"\n        end\n    end\n    puts sum\n#    puts\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs a,x,y\n\ta[x][y]=\"o\" if a[x][y] != \"o\"\n\tdfs a,x-1,y if x-1 >= 0 && a[x-1][y] == \".\"\n\tdfs a,x+1,y if x+1 < a.length && a[x+1][y] == \".\"\n\tdfs a,x,y-1 if y-1 >= 0 && a[x][y-1] == \".\"\n\tdfs a,x,y+1 if y+1 < a[0].length && a[x][y+1] == \".\"\nend\n\nwhile true\n\targs = gets.split(\" \").map{|e|e.to_i}\n\tbreak if args[0] == 0 && args[1] == 0\n\ta=[]\n\tstart=[-1,-1]\n\targs[1].times{|i|\n\t\ta.push gets.chomp\n\t\tif a[i].index(\"@\") != nil\n\t\t\tstart=i,a[i].index(\"@\")\n\t\tend\n\t}\n\tdfs a,start[0],start[1]\n\tcount = 0\n\ta.each{|e|count+=e.count(\"o\")}\n\tp count\nend"
  },
  {
    "language": "Ruby",
    "code": "while (w, h = gets.chomp.split(\" \").map{|str| str.to_i}) != [0, 0]\n\tqueue = []\n\ttable = []\n\tfor y in 0..(h - 1)\n\t\ttable << gets.chomp.split(\"\").map.with_index do |char, x|\n\t\t\tif char == \".\"\n\t\t\t\t0\n\t\t\telsif char == \"#\"\n\t\t\t\t-1\n\t\t\telsif char == \"@\"\n\t\t\t\tqueue << [y, x]\n\t\t\t\t0\n\t\t\tend\n\t\tend\n\tend\n\twhile !queue.empty?\n\t\ty, x = queue.shift\n\t\tif table[y][x] == 0\n\t\t\ttable[y][x] = 1\n\t\t\tqueue << [y, x - 1] if x != 0 \n\t\t\tqueue << [y - 1, x] if y != 0\n\t\t\tqueue << [y, x + 1] if x != w - 1\n\t\t\tqueue << [y + 1, x] if y != h - 1\n\t\tend\n\tend\n\tputs table.flatten.count(1)\nend"
  },
  {
    "language": "Ruby",
    "code": "@dx = [-1, 0, 1, 0]\n@dy = [0, 1, 0, -1]\n@field = []\n\ndef is_inside(x, y)\n  return x >= 0 && y >= 0 && x < @field[0].length && y < @field.length\nend\n\ndef count(x, y)\n  ret = 1\n  @field[y][x] = '#'\n  (0 ... @dx.length).each do |i|\n    if is_inside(x+@dx[i], y+@dy[i]) and @field[y+@dy[i]][x+@dx[i]] == '.' then\n      ret += count(x+@dx[i], y+@dy[i])\n    end\n  end\n  return ret\nend\n\nuntil (n, m = gets.split.map(&:to_i)) == [0, 0]\n  @field = []\n  m.times {@field << gets.chomp}\n  x = 0\n  y = 0\n  (0 ... m).each do |i|\n    x = @field[i].index('@')\n    if x != nil then\n      y = i\n      break\n    end\n  end\n  puts count(x, y)\nend"
  },
  {
    "language": "Ruby",
    "code": "# field[x][y], field[h][w]\n\ndef debug_field(field)  \n  puts field.map {|x| x.join(\"\")}.join(\"\\n\")\nend\n\ndef bfs(h, w, i, j, field)\n  items = []\n  items << [i, j]\n  field[i][j] = '#'\n  count = 1\n  until items.empty?\n    v = items.shift\n    [[1, 0], [0, 1],\n     [-1, 0], [0, -1]].each do |dx, dy|\n      x_new, y_new = [v[0] + dx, v[1] + dy]\n      next if x_new >= h or x_new < 0\n      next if y_new >= w or y_new < 0\n      next if field[x_new][y_new] == '#'\n      count += 1\n      field[x_new][y_new] = '#'\n      items << [x_new, y_new]\n    end\n  end\n  count\nend\n\ndef solve(height, width, field)\n  field.each.with_index do |row, i|\n    row.each.with_index do |t, j|\n      return puts bfs(height, width, i, j, field) if t == '@'\n    end\n  end\nend\n\ndata = $stdin.read.split(\"\\n\")\nuntil data.empty?\n  width, height = data[0].split(\" \").map(&:to_i)\n  field = data[1..-1].map(&:chars)\n  solve height, width, field\n  data = data[(height + 1)..-1]\nend"
  },
  {
    "language": "Ruby",
    "code": "while true do\n    w,h=gets.chomp.split(\" \").map(&:to_i)\n    break if w == 0 && h == 0\n\n    tiles = []\n    (0..(h-1)).each do |i|\n        s = gets.chomp\n        if j = s.index(\"@\")\n            @init_pos = [i, j]\n        end\n        tiles.push(s)\n    end\n\n    ret = 0\n    memo = {}\n    (0..(h-1)).each { |i| memo[i] = {} }\n    targets = [@init_pos]\n    memo[@init_pos[0]][@init_pos[1]] = true\n    ret += 1\n    while !targets.empty? do\n        position = targets.shift\n        row = position[0]\n        col = position[1]\n        \n        if row != 0 && memo[row-1][col] == nil && tiles[row-1][col] == \".\"\n            targets.push([row-1, col])\n            memo[row-1][col] = true\n            ret += 1\n        end\n        if row != h-1 && memo[row+1][col] == nil && tiles[row+1][col] == \".\"\n            targets.push([row+1, col])\n            memo[row+1][col] = true\n            ret += 1\n        end\n        if col != 0 && memo[row][col-1] == nil && tiles[row][col-1] == \".\"\n            targets.push([row, col-1])\n            memo[row][col-1] = true\n            ret += 1\n        end\n        if col != w-1 && memo[row][col+1] == nil && tiles[row][col+1] == \".\"\n            targets.push([row, col+1])\n            memo[row][col+1] = true\n            ret += 1\n        end\n    end\n    puts ret\nend\n"
  },
  {
    "language": "Ruby",
    "code": "require 'pp'\n\nwhile (w, h = gets.chomp.split(\" \").map{|str| str.to_i}) != [0, 0]\n\tqueue = []\n\ttable = []\n\tfor y in 0..(h - 1)\n\t\ttable << gets.chomp.split(\"\").map.with_index do |char, x|\n\t\t\tif char == \".\"\n\t\t\t\t0\n\t\t\telsif char == \"#\"\n\t\t\t\t-1\n\t\t\telsif char == \"@\"\n\t\t\t\tqueue << [y, x]\n\t\t\t\t0\n\t\t\tend\n\t\tend\n\tend\n\twhile !queue.empty?\n\t\ty, x = queue.shift\n\t\tif table[y][x] == 0\n\t\t\ttable[y][x] = 1\n\t\t\tadd = []\n\t\t\tadd << [y, x - 1] if x != 0 \n\t\t\tadd << [y - 1, x] if y != 0\n\t\t\tadd << [y, x + 1] if x != w - 1\n\t\t\tadd << [y + 1, x] if y != h - 1\n\t\t\tqueue += add\n\t\tend\n\tend\n\tputs table.flatten.count(1)\nend"
  },
  {
    "language": "Ruby",
    "code": "def search(a, x, y, w, h, count)\n  if x+1 < w and a[y][x+1] != nil and a[y][x+1] == '.' and not count.include? [x+1,y]\n    count << [x+1,y]\n    search(a, x+1, y, w, h, count)\n  end\n  if x-1 >= 0 and a[y][x-1] != nil and a[y][x-1] == '.' and not count.include? [x-1,y]\n    count << [x-1,y]\n    search(a, x-1, y, w, h, count)\n  end\n  if y+1 < h and a[y+1][x] != nil and a[y+1][x] == '.' and not count.include? [x,y+1]\n    count << [x,y+1]\n    search(a, x, y+1, w, h, count)\n  end\n  if y-1 >= 0 and a[y-1][x] != nil and a[y-1][x] == '.' and not count.include? [x,y-1]\n    count << [x,y-1]\n    search(a, x, y-1, w, h, count)\n  end\nend\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  exit if w == 0 and h == 0\n  a = h.times.map.with_index{gets.chomp.chars}\n\n  x = y = 0\n  y = a.find_index{|a| a.index(\"@\")}\n  x = a[y].index(\"@\")\n\n  count = []\n  search(a, x, y, w, h, count)\n  puts (count.length + 1)\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tsc = bufio.NewScanner(os.Stdin)\n)\n\ntype Color int\n\nconst (\n\tColorBlack Color = iota\n\tColorRed\n)\n\ntype Node struct {\n\tID    int\n\tX, Y  int\n\tColor Color\n\tNexts []*Node\n}\n\nfunc main() {\n\tfor sc.Scan() {\n\t\tif sc.Text() == \"0 0\" {\n\t\t\tbreak\n\t\t}\n\t\tchunks := strings.Split(sc.Text(), \" \")\n\t\tw, _ := strconv.Atoi(chunks[0])\n\t\th, _ := strconv.Atoi(chunks[1])\n\n\t\t// Initialize map\n\t\tm := map[int]map[int]*Node{}\n\t\tfor x := 1; x <= w; x++ {\n\t\t\tm[x] = map[int]*Node{}\n\t\t\tfor y := 1; y <= h; y++ {\n\t\t\t\tm[x][y] = &Node{ID: x + y*w, X: x, Y: y}\n\t\t\t}\n\t\t}\n\t\tfor x := 1; x <= w; x++ {\n\t\t\tfor y := 1; y <= h; y++ {\n\t\t\t\tnexts := []*Node{}\n\t\t\t\tif n, ok := m[x-1][y]; ok {\n\t\t\t\t\tnexts = append(nexts, n)\n\t\t\t\t}\n\t\t\t\tif n, ok := m[x][y-1]; ok {\n\t\t\t\t\tnexts = append(nexts, n)\n\t\t\t\t}\n\t\t\t\tif n, ok := m[x+1][y]; ok {\n\t\t\t\t\tnexts = append(nexts, n)\n\t\t\t\t}\n\t\t\t\tif n, ok := m[x][y+1]; ok {\n\t\t\t\t\tnexts = append(nexts, n)\n\t\t\t\t}\n\t\t\t\tm[x][y].Nexts = nexts\n\t\t\t}\n\t\t}\n\n\t\t// Set colors\n\t\tqueue := []*Node{}\n\t\ttouchedIDs := map[int]struct{}{}\n\t\tfor y := 1; y <= h; y++ {\n\t\t\tsc.Scan()\n\t\t\tfor i, c := range sc.Text() {\n\t\t\t\tswitch c {\n\t\t\t\tcase '.', '@':\n\t\t\t\t\tn := m[i+1][y]\n\t\t\t\t\tn.Color = ColorBlack\n\t\t\t\t\tif c == '@' {\n\t\t\t\t\t\tqueue = append(queue, n)\n\t\t\t\t\t\ttouchedIDs[n.ID] = struct{}{}\n\t\t\t\t\t}\n\t\t\t\tcase '#':\n\t\t\t\t\tm[i+1][y].Color = ColorRed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Search\n\t\tvisitedIDs := map[int]struct{}{}\n\t\tfor {\n\t\t\tif len(queue) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tn := queue[0]\n\t\t\tqueue = queue[1:]\n\t\t\tvisitedIDs[n.ID] = struct{}{}\n\t\t\tfor _, next := range n.Nexts {\n\t\t\t\tif next.Color == ColorRed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif _, ok := touchedIDs[next.ID]; !ok {\n\t\t\t\t\tqueue = append(queue, next)\n\t\t\t\t\ttouchedIDs[n.ID] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(len(visitedIDs))\n\t}\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar (\n\tsc = bufio.NewScanner(os.Stdin)\n)\n\ntype Color int\n\nconst (\n\tColorBlack Color = iota\n\tColorRed\n)\n\nvar strByColor = map[Color]string{\n\tColorBlack: \"black\",\n\tColorRed:   \"red\",\n}\n\nfunc (c Color) String() string {\n\treturn strByColor[c]\n}\n\ntype Node struct {\n\tID      int\n\tX, Y    int\n\tColor   Color\n\tNextIDs map[int]struct{}\n}\n\nfunc (n *Node) String() string {\n\td, _ := json.Marshal(n)\n\treturn string(d)\n}\n\ntype Map struct {\n\tWidth, Height int\n\tNodes         map[int]*Node\n}\n\nfunc (m *Map) GetByID(id int) *Node {\n\treturn m.Nodes[id]\n}\n\nfunc (m *Map) Get(x, y int) *Node {\n\treturn m.Nodes[m.getID(x, y)]\n}\n\nfunc (m *Map) SetColor(x, y int, c Color) {\n\tm.Nodes[m.getID(x, y)].Color = c\n}\n\nfunc (m *Map) getID(x, y int) int {\n\treturn x + y*m.Width\n}\n\nfunc (m *Map) init() {\n\tfor x := 1; x <= m.Width; x++ {\n\t\tfor y := 1; y <= m.Height; y++ {\n\t\t\tid := m.getID(x, y)\n\t\t\tm.Nodes[id] = &Node{ID: id, X: x, Y: y}\n\t\t}\n\t}\n\tfor x := 1; x <= m.Width; x++ {\n\t\tfor y := 1; y <= m.Height; y++ {\n\t\t\tnextIDs := map[int]struct{}{}\n\t\t\tif x > 1 {\n\t\t\t\tnextIDs[m.getID(x-1, y)] = struct{}{}\n\t\t\t}\n\t\t\tif x < m.Width {\n\t\t\t\tnextIDs[m.getID(x+1, y)] = struct{}{}\n\t\t\t}\n\t\t\tif y > 1 {\n\t\t\t\tnextIDs[m.getID(x, y-1)] = struct{}{}\n\t\t\t}\n\t\t\tif y < m.Height {\n\t\t\t\tnextIDs[m.getID(x, y+1)] = struct{}{}\n\t\t\t}\n\t\t\tm.Get(x, y).NextIDs = nextIDs\n\t\t}\n\t}\n}\n\nfunc NewMap(w, h int) *Map {\n\tm := &Map{Width: w, Height: h, Nodes: map[int]*Node{}}\n\tm.init()\n\treturn m\n}\n\ntype Searcher struct {\n\tMap        *Map\n\tqueue      []*Node\n\ttouchedIDs map[int]struct{}\n\tvisitedIDs map[int]struct{}\n}\n\nfunc NewSearcher(m *Map) *Searcher {\n\treturn &Searcher{\n\t\tMap:        m,\n\t\tqueue:      []*Node{},\n\t\ttouchedIDs: map[int]struct{}{},\n\t\tvisitedIDs: map[int]struct{}{},\n\t}\n}\n\nfunc (s *Searcher) Search(start *Node) {\n\ts.enqueue(start)\n\n\tfor {\n\t\tif len(s.queue) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tfor nextID := range s.dequeue().NextIDs {\n\t\t\tn := s.Map.GetByID(nextID)\n\t\t\tif n.Color == ColorRed || s.hasTouched(n) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ts.enqueue(n)\n\t\t}\n\t}\n}\n\nfunc (s *Searcher) VisitedNodeCount() int {\n\treturn len(s.visitedIDs)\n}\n\nfunc (s *Searcher) hasTouched(n *Node) bool {\n\t_, ok := s.touchedIDs[n.ID]\n\treturn ok\n}\n\nfunc (s *Searcher) enqueue(n *Node) {\n\ts.queue = append(s.queue, n)\n\ts.touchedIDs[n.ID] = struct{}{}\n}\n\nfunc (s *Searcher) dequeue() *Node {\n\tn := s.queue[0]\n\ts.queue = s.queue[1:]\n\ts.visitedIDs[n.ID] = struct{}{}\n\treturn n\n}\n\nfunc main() {\n\tfor sc.Scan() {\n\t\tif sc.Text() == \"0 0\" {\n\t\t\tbreak\n\t\t}\n\t\tchunks := strings.Split(sc.Text(), \" \")\n\t\tw, _ := strconv.Atoi(chunks[0])\n\t\th, _ := strconv.Atoi(chunks[1])\n\n\t\tm := NewMap(w, h)\n\n\t\t// Set colors\n\t\tvar start *Node\n\t\tfor y := 1; y <= h; y++ {\n\t\t\tsc.Scan()\n\t\t\tfor i, c := range sc.Text() {\n\t\t\t\tswitch c {\n\t\t\t\tcase '.', '@':\n\t\t\t\t\tm.SetColor(i+1, y, ColorBlack)\n\t\t\t\t\tif c == '@' {\n\t\t\t\t\t\tstart = m.Get(i+1, y)\n\t\t\t\t\t}\n\t\t\t\tcase '#':\n\t\t\t\t\tm.SetColor(i+1, y, ColorRed)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Search\n\t\ts := NewSearcher(m)\n\t\ts.Search(start)\n\t\tfmt.Println(s.VisitedNodeCount())\n\t}\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n//    print_r($a);\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n$a = array();\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array( -1, 0, 1, 0);\n$dx = array( 0, 1, 0, -1);\n$fp = fopen(\"php://stdin\",\"r\");\nwhile(true){\n  fscanf( $fp, \"%d %d\", $w, $h);\n  if($w == 0 && $h == 0) break;\n    for($i = 0 ; $i < $h ; $i++ ){\n    fscanf( $fp, \"%s\", $mas[$i]);\n    for($j = 0 ; $j < $w ; $j++ ){\n      if($mas[$i][$j] == '@'){\n        $sy = $i;\n        $sx = $j;\n      }\n      $used[$i][$j] = false;\n    }\n  }\n  $que = new SplQueue();\n  $que -> push(array($sy,$sx));\n  $cnt = 0;\n  while(!$que -> isEmpty()){\n    $p = $que -> dequeue();\n    if($used[$p[0]][$p[1]]) continue;\n    $used[$p[0]][$p[1]] = true;\n    $cnt++;\n    for($i = 0 ; $i < 4 ; $i++ ){\n      $ny = $p[0] + $dy[$i];\n      $nx = $p[1] + $dx[$i];\n      if($ny >= 0 && $ny < $h && $nx >= 0 && $nx < $w && $mas[$ny][$nx] == '.'){\n        $que -> push(array($ny,$nx));\n      }\n    }\n  }\n  echo $cnt,\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j] and $a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j] and $a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1] and $a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1] and $a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n//    print_r($a);\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction search($m,$n){\n    global $sum,$b;\n    if($b[$m][$n+1]==\".\"){\n        $b[$m][$n+1]=\"-\";\n        $sum++;\n        search($m,$n+1);\n    }\n    if($b[$m][$n-1]==\".\"){\n        $b[$m][$n-1]=\"-\";\n        $sum++;\n        search($m,$n-1);\n    }\n    if($b[$m+1][$n]==\".\"){\n        $b[$m+1][$n]=\"-\";\n        $sum++;\n        search($m+1,$n);\n    }\n    if($b[$m-1][$n]==\".\"){\n        $b[$m-1][$n]=\"-\";\n        $sum++;\n        search($m-1,$n);\n    }\n}\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n    if($w==0 && $h==0)\n        break;\n    $b[0]=str_repeat(\"-\",$w+2);\n    for($i=1;$i<=$h;$i++){\n        fscanf(STDIN,\"%s\",$b[$i]);\n        $b[$i]=\"-\".$b[$i].\"-\";\n    }\n    $b[$h+1]=str_repeat(\"-\",$w+2);\n\n    $sum=1;\n    for($i=0;$i<$h+2;$i++){\n        for($j=0;$j<$w+2;$j++){\n            if($b[$i][$j]==\"@\"){\n                search($i,$j);\n                break 2;\n                }\n        }\n    }\n    echo $sum.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array( -1, 0, 1, 0);\n$dx = array( 0, 1, 0, -1);\n$fp = fopen(\"php://stdin\",\"r\");\nwhile(true){\n  fscanf( $fp, \"%d %d\", $w, $h);\n  if($w == 0 && $h == 0) break;\n    for($i = 0 ; $i < $h ; $i++ ){\n    fscanf( $fp, \"%s\", $mas[$i]);\n    for($j = 0 ; $j < $w ; $j++ ){\n      if($mas[$i][$j] == '@'){\n        $sy = $i;\n        $sx = $j;\n      }\n      $used[$i][$j] = false;\n    }\n  }\n  $que = new SplQueue();\n  $que -> push(array($sy,$sx));\n  $cnt = 0;\n  while(!$que -> isEmpty()){\n    $p = $que -> dequeue();\n    if($used[$p[0]][$p[1]]) continue;\n    $used[$p[0]][$p[1]] = true;\n    $cnt++;\n    for($i = 0 ; $i < 4 ; $i++ ){\n      $ny = $p[0] + $dy[$i];\n      $nx = $p[1] + $dx[$i];\n      if($ny >= 0 && $ny < $h && $nx >= 0 && $nx < $w && $mas[$ny][$nx] == '.'){\n        $que -> push(array($ny,$nx));\n      }\n    }\n  }\n  print($cnt.\"\\n\");\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\n//while(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n//}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction move($x, $y, $map, &$visit){\n    // x,y 座標\n    // map 与えられた地図\n    // visit 塗りつぶした箇所の地図（情報）\n    $dx = [1,-1,0,0];\n    $dy = [0,0,1,-1];\n    // 上下左右（xとy）で動きを表現する。\n    if (($map[$y][$x] == '.' || $map[$y][$x] == '@') && $visit[$y][$x] == false){\n        $visit[$y][$x] = true;\n        for ($i = 0; $i < 4; $i++){\n            if(($x + $dx[$i] < count($map[$y]) && $x + $dx[$i] >= 0) && ($y + $dy[$i] < count($map) && $y + $dy[$i] >= 0)){\n                // printmap($visit);\n                move($x + $dx[$i], $y + $dy[$i], $map, $visit);\n            }\n        }\n    }\n}\n\nfunction printmap($map){\n    foreach($map as $ma){\n        foreach($ma as $m){\n            if($m){\n                echo 'X';\n\n            } else {\n                echo '.';\n            }\n        }\n        echo \"\\n\";\n    }\n}\n\n\n$numbers = preg_split(\"/[\\s,]+/\", rtrim(fgets(STDIN)));\n$w = intval($numbers[0]);\n$h = intval($numbers[1]);\n\nwhile ($w != 0){\n    $map = [];\n    for ($i = 0; $i < $h; $i++){\n        $ar = [];\n        for ($j = 0; $j < $w; $j++){\n            $ar[] = ' ';\n        }\n        $map[] = $ar;\n    }\n    $visit = [];\n    for ($i = 0; $i < $h; $i++){\n        $ar = [];\n        for ($j = 0; $j < $w; $j++){\n            $ar[] = false;\n        }\n        $visit[] = $ar;\n    }\n    $visit1 =& $visit;\n\n    $x = 0;\n    $y = 0;\n    for ($i = 0; $i < $h; $i++){\n        $c = rtrim(fgets(STDIN));\n        for ($j = 0; $j < $w; $j++){\n            $map[$i][$j] = substr($c, $j, 1);\n            if($map[$i][$j] == '@'){\n                $x = $j;\n                $y = $i;\n            }\n        }\n    }\n\n    // printmap($map);\n    // exit;\n\n    $count = 0;\n    move($x, $y, $map, $visit1);\n    // printmap($visit1);\n    foreach ($visit1 as $vi){\n        foreach ($vi as $v){\n            if ($v){\n                $count += 1;\n            }\n        }\n    }\n    echo $count;\n    echo \"\\n\";\n\n    $numbers = preg_split(\"/[\\s,]+/\", rtrim(fgets(STDIN)));\n    $w = intval($numbers[0]);\n    $h = intval($numbers[1]);\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array(1, -1, 0, 0);\n$dx = array(0, 0, 1, -1);\n\nfunction dfs($y, $x) {\n  global $ans, $h, $w, $dx, $dy, $visited, $map;\n\n  $ans++;\n  $visited[$y][$x] = 1;\n  \n  for ($i = 0; $i < 4; $i++) {\n    $ny = $y + $dy[$i];\n    $nx = $x + $dx[$i];\n    if (0 > $ny || $ny >= $h) continue;\n    if (0 > $nx || $nx >= $w) continue;\n    if ($map[$ny][$nx] == '#') continue;\n    if ($visited[$ny][$nx]) continue;\n    dfs($ny, $nx);\n  }\n}\n\nwhile (fscanf(STDIN, \"%d %d\", $w, $h) && ($w | $h)) {\n  for ($i = 0; $i < $h; $i++) {\n    fscanf(STDIN, \"%s\", $str);\n    // $map[$i][] = str_split($str);\n    for ($j = 0; $j < $w; $j++) {\n      $map[$i][$j] = $str[$j];\n      if ($str[$j] == '@') {\n        $sy = $i;\n        $sx = $j;\n      }\n    }\n  }\n\n  $ans = 0;\n  for ($i = 0; $i < $h; $i++) {\n    for($j = 0; $j < $w; $j++) {\n      $visited[$i][$j] = 0;\n    }\n  }\n  dfs($sy, $sx);\n  \n  print $ans . \"\\n\";\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if(isset($a[$i+1][$j]) and $a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if(isset($a[$i-1][$j]) and $a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if(isset($a[$i][$j+1]) and $a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if(isset($a[$i][$j-1]) and $a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if(isset($a[$i+1][$j]) and $a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if(isset($a[$i-1][$j]) and $a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        break;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    function c_p($i,$j){\n        global $sum,$a;\n        $sum+=1;\n        $a[$i][$j]=\"#\";\n//    print_r($a);\n    }\n    \n    function search($i,$j){\n        global $a;\n        if($a[$i+1][$j]==\".\"){\n            c_p($i+1,$j);\n            search($i+1,$j);\n        }\n        if($a[$i-1][$j]==\".\"){\n            c_p($i-1,$j);\n            search($i-1,$j);\n        }\n        if($a[$i][$j+1]==\".\"){\n            c_p($i,$j+1);\n            search($i,$j+1);\n        }\n        if($a[$i][$j-1]==\".\"){\n            c_p($i,$j-1);\n            search($i,$j-1);\n        }\n    }\n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n//    print_r($a);\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n$a = array();\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>pc-a314:20150427 admin$ "
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if(isset($a[$i+1][$j]) and $a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if(isset($a[$i-1][$j]) and $a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if(isset($a[$i][$j+1]) and $a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if(isset($a[$i][$j-1]) and $a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array( -1, 0, 1, 0);\n$dx = array( 0, 1, 0, -1);\nwhile(fscanf( STDIN, \"%d %d\\n\", $w, $h) && $w){\n  for($i = 0 ; $i < $h ; $i++ ){\n    fscanf( STDIN, \"%s\\n\", $mas[$i]);\n    for($j = 0 ; $j < $w ; $j++ ){\n      if($mas[$i][$j] == '@'){\n        $sy = $i;\n        $sx = $j;\n      }\n      $used[$i][$j] = false;\n    }\n  }\n  $que = new SplQueue();\n  $que -> push(array($sy,$sx));\n  $cnt = 0;\n  while(!$que -> isEmpty()){\n    $p = $que -> dequeue();\n    if($used[$p[0]][$p[1]]) continue;\n    $used[$p[0]][$p[1]] = true;\n    $cnt++;\n    for($i = 0 ; $i < 4 ; $i++ ){\n      $ny = $p[0] + $dy[$i];\n      $nx = $p[1] + $dx[$i];\n      if($ny >= 0 && $ny < $h && $nx >= 0 && $nx < $w && $mas[$ny][$nx] == '.'){\n        $que -> push(array($ny,$nx));\n      }\n    }\n  }\n  echo $cnt,PHP_EOL;\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\n//while(1){\n    $a = array_fill(0,0,0);\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n//}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array( -1, 0, 1, 0);\n$dx = array( 0, 1, 0, -1);\nwhile(fscanf( STDIN, \"%d %d\\n\", $w, $h) && $w){\n  for($i = 0 ; $i < $h ; $i++ ){\n    fscanf( STDIN, \"%s\\n\", $mas[$i]);\n    for($j = 0 ; $j < $w ; $j++ ){\n      if($mas[$i][$j] == '@'){\n        $sy = $i;\n        $sx = $j;\n      }\n      $used[$i][$j] = false;\n    }\n  }\n  $que = new SplQueue();\n  $que -> push(array($sy,$sx));\n  $cnt = 0;\n  while(!$que -> isEmpty()){\n    $p = $que -> dequeue();\n    if($used[$p[0]][$p[1]]) continue;\n    $used[$p[0]][$p[1]] = true;\n    $cnt++;\n    for($i = 0 ; $i < 4 ; $i++ ){\n      $ny = $p[0] + $dy[$i];\n      $nx = $p[1] + $dx[$i];\n      if($ny >= 0 && $ny < $h && $nx >= 0 && $nx < $w && $mas[$ny][$nx] == '.'){\n        $que -> push(array($ny,$nx));\n      }\n    }\n  }\n  print($cnt.\"\\n\");\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n}\n\nfunction search($i,$j){\n    global $a;\n    if(isset($a[$i+1][$j]) and $a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if(isset($a[$i-1][$j]) and $a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if(isset($a[$i][$j+1]) and $a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if(isset($a[$i][$j-1]) and $a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    $a = array();\n    $sum=1;\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        exit;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\nfunction search($m,$n){\n    global $sum,$b;\n    if($b[$m][$n+1]==\".\"){\n        $b[$m][$n+1]=\"-\";\n        $sum++;\n        search($m,$n+1);\n    }\n    if($b[$m][$n-1]==\".\"){\n        $b[$m][$n-1]=\"-\";\n        $sum++;\n        search($m,$n-1);\n    }\n    if($b[$m+1][$n]==\".\"){\n        $b[$m+1][$n]=\"-\";\n        $sum++;\n        search($m+1,$n);\n    }\n    if($b[$m-1][$n]==\".\"){\n        $b[$m-1][$n]=\"-\";\n        $sum++;\n        search($m-1,$n);\n    }\n}\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n    if($w==0 && $h==0)\n        break;\n    for($i=1;$i<=$h;$i++){\n        fscanf(STDIN,\"%s\",$b[$i]);\n        $b[$i]=\"-\".$b[$i].\"-\";\n    }\n    for($k=0;$k<$w+2;$k++){\n        $b[0][$k]=\"-\";\n        $b[$h+1][$k]=\"-\";\n    }\n\n    $sum=1;\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){\n            if($b[$i][$j]==\"@\"){\n                search($i,$j);\n                break 2;\n                }\n        }\n    }\n    echo $sum.\"\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n$dy = array( -1, 0, 1, 0);\n$dx = array( 0, 1, 0, -1);\nwhile(fscanf( STDIN, \"%d %d\\n\", $w, $h) && $w){\n  for($i = 0 ; $i < $h ; $i++ ){\n    fscanf( STDIN, \"%s\\n\", $mas[$i]);\n    for($j = 0 ; $j < $w ; $j++ ){\n      if($mas[$i][$j] == '@'){\n        $sy = $i;\n        $sx = $j;\n      }\n      $used[$i][$j] = false;\n    }\n  }\n  $que = new SplQueue();\n  $que -> push(array($sy,$sx));\n  $cnt = 0;\n  while(!$que -> isEmpty()){\n    $p = $que -> dequeue();\n    if($used[$p[0]][$p[1]]) continue;\n    $used[$p[0]][$p[1]] = true;\n    $cnt++;\n    for($i = 0 ; $i < 4 ; $i++ ){\n      $ny = $p[0] + $dy[$i];\n      $nx = $p[1] + $dx[$i];\n      if($ny >= 0 && $ny < $h && $nx >= 0 && $nx < $w && $mas[$ny][$nx] == '.'){\n        $que -> push(array($ny,$nx));\n      }\n    }\n  }\n  echo \"$cnt\\n\";\n}\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfunction c_p($i,$j){\n    global $sum,$a;\n    $sum+=1;\n    $a[$i][$j]=\"#\";\n//    print_r($a);\n}\n\nfunction search($i,$j){\n    global $a;\n    if($a[$i+1][$j]==\".\"){\n        c_p($i+1,$j);\n        search($i+1,$j);\n    }\n    if($a[$i-1][$j]==\".\"){\n        c_p($i-1,$j);\n        search($i-1,$j);\n    }\n    if($a[$i][$j+1]==\".\"){\n        c_p($i,$j+1);\n        search($i,$j+1);\n    }\n    if($a[$i][$j-1]==\".\"){\n        c_p($i,$j-1);\n        search($i,$j-1);\n    }\n}\n\n\nwhile(1){\n    fscanf(STDIN,\"%d %d\\n\",$w,$h);\n\n    if($w==0 && $h==0)\n        break;\n    \n    for($i=0;$i<$h;$i++){\n        fscanf(STDIN,\"%s\\n\",$a[$i]);\n        $a[$i] = str_split($a[$i]);\n    }\n    \n//print_r($a);\n    for($i=0;$i<$h;$i++){\n        for($j=0;$j<$w;$j++){       \n            if($a[$i][$j]==\"@\"){\n                $row = $i;\n                $col = $j;\n            }\n        }\n    }\n    \n    $sum=1;\n    \n    search($row,$col);\n    echo $sum.\"\\n\";\n}\n\n\n?>"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                    data[i][j] = '#';\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h) + 1;\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                    data[i][j] = '#';\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nauto move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count = 1;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h);\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "void main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count = 1;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h);\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                    data[i][j] = '#';\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count = 1;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h);\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\nsize_t count;\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h);\n        count.writeln;\n        count = 0;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nvoid dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            ++count;\n            dfs(data, x, y, w, h);\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count = 1;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h);\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h) + 1;\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.stdio;\nimport std.conv;\nimport std.string;\nimport std.range;\n\n\nvoid main(){\n    size_t w, h, sx, sy;\n    char[][] data = new char[][](20, 20);\n    while(true){\n        auto input = readln.split;\n        w = input[0].to!int;\n        h = input[1].to!int;\n        if(!(w | h)){\n            break;\n        }\n        foreach(i; 0..h){\n            foreach(j, c; readln.chomp){\n                data[i][j] = c;\n                if(c == '@'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n        data.dfs(sx, sy, w, h).writeln;\n    }\n}\n\nenum move = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\nsize_t dfs(char[][] data, size_t sx, size_t sy, size_t w, size_t h){\n    size_t count;\n    foreach(i; 0..4){\n        size_t x = sx + move[i][0];\n        size_t y = sy + move[i][1];\n        if(0 <= x && x < w && 0 <= y && y < h && data[y][x] != '#'){\n            data[y][x] = '#';\n            count += dfs(data, x, y, w, h) + 1;\n        }\n    }\n    return count;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.algorithm, std.numeric;\nimport std.range, std.array, std.math, std.typecons, std.container, core.bitop;\n\nint[] di = [1,0,-1,0], dj = [0,1,0,-1];\nint ans;\n\nvoid main() {\n    while (1) {\n        int w, h;\n        scan(w, h);\n\n        if (!w) return;\n\n        auto bd = iota(h).map!(i => readln.chomp.to!(char[])).array;\n        int si, sj;\n\n        foreach (i ; 0 .. h) {\n            foreach (j ; 0 .. w) {\n                if (bd[i][j] == '@') {\n                    si = i, sj = j;\n                    break;\n                }\n            }\n        }\n\n        ans = 0;\n        dfs(h, w, bd, si, sj);\n\n        writeln(ans);\n    }\n}\n\nvoid dfs(int h, int w, char[][] bd, int i, int j) {\n    ans++;\n    bd[i][j] = '#';\n\n    foreach (k ; 0 .. 4) {\n        int ni = i + di[k];\n        int nj = j + dj[k];\n\n        if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n\n        if (bd[ni][nj] == '.') {\n            dfs(h, w, bd, ni, nj);\n        }\n    }\n\n}\n\n\nvoid scan(T...)(ref T args) {\n    string[] line = readln.split;\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "vec = [[1,0],[0,1],[-1,0],[0,-1]]\n\ndef dfs(nw,nh):\n    global count\n    count += 1\n    visited[nh][nw] = True\n    for x,y in vec:\n        new_w = nw + x\n        new_h = nh + y\n        if (0 <= new_w) and (new_w) < w:\n            if (0 <= new_h) and (new_h) < h:\n                if (lis_f[new_h][new_w] == \".\") and (visited[new_h][new_w] == False):\n                    dfs(new_w,new_h)\n                    \nwhile(True):\n    w,h = map(int,input().split())\n    if (w,h) == (0,0):\n        break\n    lis_f = []\n    for _ in range(h):\n        lis_f.append(list(input()))\n    \n    visited = [[False for _ in range(w)] for _ in range(h)]\n    count = 0\n    \n    id_w = 0\n    id_h = 0\n    set_w = 0\n    set_h = 0\n    while(id_h < h):\n        while(id_w < w):\n            #print(lis_f[id_h][id_w])\n            if lis_f[id_h][id_w] == \"@\":\n                set_w = id_w\n                set_h = id_h\n            id_w += 1\n        id_h += 1\n        id_w = 0\n    \n    #print(set_w,set_h)\n    \n    dfs(set_w,set_h)\n    print(count)            \n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nct=1\ndef count(Map, w,h,i, j):\n    global ct\n    dx=[1,0,-1,0]\n    dy=[0,1,0,-1]\n    for k in range(4):\n        ix=i+dy[k]\n        jx=j+dx[k]\n        if (0<=ix<h and 0<=jx<w and Map[ix][jx]=='.'):\n            Map[ix][jx]='#'\n            ct+=1\n            count(Map,w,h,ix,jx)\n\nwhile(True):\n    input = map(int, sys.stdin.readline().replace('\\n','').split(' '))\n    w,h=input\n    if(w==0 and h==0):break\n    Map=[]\n    for i in range(h):\n        s=raw_input()\n        Map.append(list(s))\n        \n    flag=False\n    for i in range(h):\n        for j in range(w):\n            if (Map[i][j]=='@'):\n                flag=True\n                Map[i][j]='#'\n                break\n        if flag:break\n\n    count(Map,w,h,i,j)\n    print ct"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport array\nimport collections\nimport itertools\n\n\nclass DepthFirstSearchWithStack(object):\n\n    def __init__(self, width, height, tiles):\n        self.width = width\n        self.height = height\n        self.tiles = tiles\n        self.reached = [array.array(\n            \"B\", (False for y in range(height))) for x in range(width)]\n        for x, y in itertools.product(range(width), range(height)):\n            if tiles[x][y] == \"@\":\n                self.start_tile = (x, y)\n                break\n\n    def search(self, x0, y0):\n        stack = collections.deque()\n        self.reached[x0][y0] = True\n        stack.append((x0, y0))\n        while stack:\n            (x, y) = stack.pop()\n            for i, j in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                if i < 0 or self.width <= i or j < 0 or self.height <= j:\n                    pass\n                elif self.tiles[i][j] == \"#\":\n                    pass\n                elif not self.reached[i][j]:\n                    self.reached[i][j] = True\n                    stack.append((i, j))\n\n    def count_reachable_tiles(self):\n        self.search(*self.start_tile)\n        reachable_tiles = sum([self.reached[x][y] for x, y in itertools.product(\n            range(self.width), range(self.height))])\n        return reachable_tiles\n\n\nif __name__ == \"__main__\":\n    while True:\n        width, height = map(int, input().split())\n        if width == 0 and height == 0:\n            break\n        else:\n            tiles = [x for x in zip(*[input() for y in range(height)])]\n            dfs = DepthFirstSearchWithStack(width, height, tiles)\n            print(dfs.count_reachable_tiles())"
  },
  {
    "language": "Python",
    "code": "anslist = []\ndef sarch(i, j, visited):\n\n    if 0 < i:\n        if visited[i - 1][j] == 0:\n            visited[i - 1][j] = 1\n            sarch(i - 1, j, visited)\n    if i < len(visited) - 1:\n        if visited[i + 1][j] == 0:\n            visited[i + 1][j] = 1\n            sarch(i + 1, j, visited)\n    if 0 < j:\n        if visited[i][j - 1] == 0:\n            visited[i][j - 1] = 1\n            sarch(i, j - 1, visited)\n    if j < len(visited[0]) - 1:\n        if visited[i][j + 1] == 0:\n            visited[i][j + 1] = 1\n            sarch(i, j + 1, visited)\n    return visited\n\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0:\n        break\n    grid = [list(input()) for i in range(h)]\n    visited = [[0 for i in range(w)] for j in range(h)]\n    starti = 0\n    startj = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == \"@\":\n                starti = i\n                startj = j\n                visited[i][j] = 1\n            elif grid[i][j] == \"#\":\n                visited[i][j] = -1\n            else:\n                visited[i][j] = 0\n\n    visited = sarch(starti, startj, visited)\n    #print(visited)\n    ans = 0\n    for i in visited:\n        for j in i:\n            if j == 1:\n                ans += 1\n    anslist.append(ans)\n\nfor i in anslist:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "data, res\n\ndef valid(x, y):\n    global data\n    return 0 <= x < W and 0 <= y < H and data[y][x] != '#'\n\ndef dfs(x, y):\n    global data, res\n    if valid(x, y):\n        res += 1\n        data[y][x] = '#'\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        for i in range(4):\n            dfs(x + dx[i], y + dy[i])\n    else:\n        return\n    \nwhile True:\n    global data, res\n    W, H = map(int, input().split())\n    if W == 0 and H == 0:\n        break\n    data = [list(input()) for _ in range(H)]\n    res = 0\n    for i in range(W):\n        for j in range(H):\n            if data[j][i] == '@':\n                dfs(i, j)\n                break\n    print(res)"
  },
  {
    "language": "Python",
    "code": "data, res\n\ndef valid(x, y):\n    global data\n    return 0 <= x < W and 0 <= y < H and data[y][x] != '#'\n\ndef dfs(x, y):\n    global data, res\n    if valid(x, y):\n        res += 1\n        data[y][x] = '#'\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        for i in range(4):\n            dfs(x + dx[i], y + dy[i])\n    else:\n        return\n    \nwhile True:\n    global data, res\n    W, H = map(int, input().split())\n    if not W:\n        break\n    data = [list(input()) for _ in range(H)]\n    res = 0\n    for i in range(W):\n        for j in range(H):\n            if data[j][i] == '@':\n                dfs(i, j)\n                break\n    print(res)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\nwhile True:\n    W, H = map(int, input().split())\n    if W == 0 and H == 0:\n        break\n    \n    sx = -1\n    sy = -1\n    mat = [[None for _ in range(W)] for _ in range(H)]\n    for i in range(H):\n        s = input()\n        for j in range(W):\n            if s[j] == \"@\":\n                sx = j\n                sy = i\n            mat[i][j] = s[j]\n    \n    ans = 0\n    q = deque()\n    q.append((sx, sy))\n    while q:\n        (cx, cy) = q.popleft()\n        ans += 1\n        for dx, dy in dxy:\n            nx = cx + dx\n            ny = cy + dy\n            if 0 <= nx < W and 0 <= ny < H:\n                if mat[ny][nx] == \".\":\n                    mat[ny][nx] = \"#\"\n                    q.append((nx, ny))\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "#data????§???????[y???][x???]??§??????\n\nif __name__ == \"__main__\":\n    while 1:\n        w,h = list(map(int,input().strip().split()))\n        if w == h == 0:break\n        data = []\n        data = []\n        for _ in range(h):data.append(list(input()))\n        visited = []\n        position =(0,0)\n        for i in range(h):\n            if '@'in data[i]:position = (i,data[i].index('@'))\n        stack = []\n        count = 0\n        stack.append(position)\n        while len(stack) !=0:\n            y,x= stack.pop()\n            count +=1\n            if y-1 >= 0 and not (y-1,x)in visited and data[y -1][x] == '.':\n                visited.append((y-1,x))\n                stack.append((y-1,x))\n            if x -1 >= 0 and not (y,x-1)in visited and data[y][x-1] == '.':\n                visited.append((y,x-1))\n                stack.append((y,x-1))\n            if y +1 < h and not (y+1,x)in visited and data[y +1][x] == '.':\n                visited.append((y+1,x))\n                stack.append((y+1,x))\n            if x + 1 < w and not (y,x+1)in visited and data[y][x +1] == '.':\n                visited.append((y,x+1))\n                stack.append((y,x+1))\n\n        print(count)"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input().split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn\n\t\tif m[cy][cx] = '.'v or  m[cy][cx] = '@'\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef explore(now,cnt):\n    if cnt>W*H:#理論的にはW*H以下で全部回れるので\n        a=0 #無駄なコード\n    else:\n        d[now]=1\n        if now[1]+1<W:\n            if not data[now[0]][now[1]+1]==\"#\":\n                if not (now[0],now[1]+1) in d.keys():\n                    explore((now[0],now[1]+1),cnt+1)\n        if now[0]+1<H:\n            if not data[now[0]+1][now[1]]==\"#\":\n                if not (now[0]+1,now[1]) in d.keys():\n                    explore((now[0]+1,now[1]),cnt+1)\n        if now[0]-1>=0:\n            if not data[now[0]-1][now[1]]==\"#\":\n                if not (now[0]-1,now[1]) in d.keys():\n                    explore((now[0]-1,now[1]),cnt+1)\n        if now[1]-1>=0:\n            if not data[now[0]][now[1]-1]==\"#\":\n                if not (now[0],now[1]-1) in d.keys():\n                    explore((now[0],now[1]-1),cnt+1)\n    \nwhile True:\n    W,H=map(int,input().split())\n    if W==0 and H==0:\n        break\n    data=[list(input()) for _ in range(H)]\n    d=defaultdict()\n    for i in range(H):\n        for j in range(W):\n            if data[i][j]==\"@\":\n                start=(i,j)\n                break\n    now=start\n    cnt=0\n    explore(now,cnt)\n    print(len(d.keys()))\n"
  },
  {
    "language": "Python",
    "code": "move = [[0, 1], [0, -1], [1, 0], [-1, 0]]\nfrom collections import deque\ndef main(w, h):\n    field = [list(input()) for i in range(h)]\n    check = [[True] * w for i in range(h)]\n    q = deque()\n    for i in range(h):\n        for k in range(w):\n            if field[i][k] == \"@\":\n                q.append((k, i))\n                check[i][k] = False\n    ans = 1\n    while q:\n        x, y = q.popleft()\n        for mx, my in move:\n            xm = mx + x\n            ym = my + y\n            if 0 <= xm < w and 0 <= ym < h:\n                if field[ym][xm] == \".\" and check[ym][xm]:\n                    check[ym][xm] = False\n                    q.append((xm, ym))\n                    ans += 1\n    print(ans)\nwhile 1:\n    w, h = map(int, input().split())\n    if w == h == 0:\n        break\n    main(w,h)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    W, H = map(int, input().split())\n    if W == 0 and H == 0:\n        break\n    maze = []\n    for _ in range(H):\n        maze.append(list(input()))\n    visited = [[False] * W for _ in range(H)]\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    ans = 0\n\n\n    def rec(x, y):\n        global ans\n        visited[x][y] = True\n        ans += 1\n        for (dx, dy) in dxy:  # 4方向の移動を試す\n            x2 = x + dx\n            y2 = y + dy\n            if 0 <= x2 < H and 0 <= y2 < W:\n                if maze[x2][y2] == '.':\n                    if not visited[x2][y2]:\n                        rec(x2, y2)  # 再帰呼び出し\n\n\n    for h in range(H):\n        for w in range(W):\n            if maze[h][w] == '@':\n                rec(h, w)\n                break\n        else:\n            continue\n        break\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ncnt = 0\n\ndef solve():\n    while 1:\n        w, h = map(int, sys.stdin.readline().split())\n\n        if w == h == 0:\n            return\n\n        room = [list(sys.stdin.readline().rstrip()) for i in range(h)]\n\n        for i in range(h):\n            if '@' in room[i]:\n                si = i\n                sj = room[i].index('@')\n                break\n\n        global cnt\n        cnt = 0\n        dfs(w, h, room, si, sj)\n        print(cnt)\n\ndef dfs(w, h, room, i, j):\n    if i < 0 or i >= h or j < 0 or j >= w or (room[i][j] == '#'):\n        return\n\n    global cnt\n    cnt += 1\n    room[i][j] = '#'\n\n    dfs(w, h, room, i + 1, j)\n    dfs(w, h, room, i - 1, j)\n    dfs(w, h, room, i, j + 1)\n    dfs(w, h, room, i, j - 1)\n\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n1. スタート地点の座標を取得\n2. スタート地点からbfsをして到達可能な”.”の数を数える\n\"\"\"\n\nfrom collections import deque\n\ndef bfs(h, w, f, s):\n    count = 1\n    q = deque()\n    q.append(s)\n\n    move = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while q:\n        i, j = q.popleft()\n\n        for di, dj in move:\n            ni , nj = i + di, j + dj\n            if 0 <= ni < w and 0 <= nj < h and f[ni][nj] == \".\":\n                count += 1\n                q.append((ni, nj))\n                f[ni][nj] = \"#\"\n\n    return count\n\ndef search_atmark(h, w, f):\n    for i in range(h):\n        for j in range(w):\n            if f[i][j] == \"@\":\n                return (i, j)\n\ndef solve(h, w, f):\n    s = search_atmark(w, h, f)\n    return bfs(h, w, f, s)\n\nif __name__ == '__main__':\n    while(True):\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        f = [list(input()) for i in range(h)]\n        print(solve(w, h, f))\n\n"
  },
  {
    "language": "Python",
    "code": "dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\ndef rec(maze, visited, locat):\n  # ４方向全て試す\n  for i in dxy:\n    n_locat = (locat[0] + i[0], locat[1] + i[1])\n    if 0 <= n_locat[0] < len(maze) and 0 <= n_locat[1] < len(maze[0]):\n      if maze[n_locat[0]][n_locat[1]] == '.':\n        if visited[n_locat[0]][n_locat[1]] == False:\n          global count \n          count += 1\n          visited[n_locat[0]][n_locat[1]] = True\n          rec(maze, visited, n_locat)\n  return count\nwhile(True):\n  w, h = map(int, input().split())\n  if w == 0 and h == 0:\n    break\n  maze = [[]for i in range(h)]\n  visited = [[False for i in range(w)] for j in range(h)]\n  for i in range(h):\n    mazel = list(input())\n    maze[i] = mazel\n  count = 1 # @のいちを予めカウントしておく\n  for i in range(h):\n    for j in range(w):\n      if maze[i][j] == '@':\n        s = [i, j]\n        break\n    else:\n      continue\n    break\n  print(rec(maze, visited, s))\n"
  },
  {
    "language": "Python",
    "code": "#data????§???????[y???][x???]??§??????\n\nif __name__ == \"__main__\":\n    while 1:\n        w,h = list(map(int,input().strip().split()))\n        if w == h == 0:break\n        data = []\n        data = []\n        for _ in range(h):data.append(list(input()))\n        visited = []\n        for i in range(h):\n            if '@'in data[i]:stack= [(i,data[i].index('@'))]\n        count = 0\n        while len(stack) !=0:\n            y,x= stack.pop()\n            count +=1\n            if y-1 >= 0 and not (y-1,x)in visited and data[y -1][x] == '.':\n                visited.append((y-1,x))\n                stack.append((y-1,x))\n            if x -1 >= 0 and not (y,x-1)in visited and data[y][x-1] == '.':\n                visited.append((y,x-1))\n                stack.append((y,x-1))\n            if y +1 < h and not (y+1,x)in visited and data[y +1][x] == '.':\n                visited.append((y+1,x))\n                stack.append((y+1,x))\n            if x + 1 < w and not (y,x+1)in visited and data[y][x +1] == '.':\n                visited.append((y,x+1))\n                stack.append((y,x+1))\n\n        print(count)"
  },
  {
    "language": "Python",
    "code": "import copy\nw, h = map(int,input().split())\nwhile [h, w] != [0, 0]:\n    area = []\n    a = 1\n    for i in range(h):\n        area.append(list(input()))\n        area[i].insert(0,\"#\")\n        area[i].append(\"#\")\n    area.insert(0,[\"#\" for i in range(w + 2)])\n    area.append([\"#\" for i in range(w + 2)])\n\n    que = []\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            if area[i][j] == \"@\":\n                que.append([i, j])\n                break\n        else:\n            continue\n        break\n    while True:\n        nque = []\n        for i in que:\n            h1 = i[0]\n            w1 = i[1]\n            if area[h1 - 1][w1] == \".\":\n                area[h1 - 1][w1] = \"*\"\n                nque.append([h1 - 1, w1])\n                a += 1\n            if area[h1 + 1][w1] == \".\":\n                area[h1 + 1][w1] = \"*\"\n                nque.append([h1 + 1, w1])\n                a += 1\n            if area[h1][w1 - 1] == \".\":\n                area[h1][w1 - 1] = \"*\"\n                nque.append([h1, w1 - 1])\n                a += 1\n            if area[h1][w1 + 1] == \".\":\n                area[h1][w1 + 1] = \"*\"\n                nque.append([h1, w1 + 1])\n                a += 1\n        if nque == []:\n            break\n        que = copy.deepcopy(nque)\n\n    print(a)\n        \n    w, h = map(int,input().split())\n"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef search(w,h,data): \n    for i in range(h):\n        if '@' in data[i]:\n            stx,sty = i,data[i].index('@')\n\n    stack = [[stx,sty]]\n    check = [[stx,sty]]\n    while True:\n        if len(stack) != 0:\n            s = stack[-1]\n            Hnow,Wnow = s[0],s[1]\n        else:\n            return len(check)\n\n        stack.pop()\n        \n        if Hnow < h-1:\n            if (data[Hnow+1][Wnow] == '.') and ([Hnow+1,Wnow] not in check):\n                stack.append([Hnow+1,Wnow])\n                check.append([Hnow+1,Wnow])\n\n        if Wnow < w-1:\n            if (data[Hnow][Wnow+1] == '.') and ([Hnow,Wnow+1] not in check):\n                stack.append([Hnow,Wnow+1])\n                check.append([Hnow,Wnow+1])\n\n        if Hnow > 0:\n            if (data[Hnow-1][Wnow] == '.') and ([Hnow-1,Wnow] not in check):\n                stack.append([Hnow-1,Wnow])\n                check.append([Hnow-1,Wnow])\n\n        if Wnow > 0:\n            if (data[Hnow][Wnow-1] == '.') and ([Hnow,Wnow-1] not in check):\n                stack.append([Hnow,Wnow-1])\n                check.append([Hnow,Wnow-1])\n\na = []\n\n\nwhile True:\n    w,h = list(map(int,input().split()))\n    if (w == 0)and(h == 0):\n        break\n    else:\n        data = [list(input()) for l in range(h)]\n        a.append(search(w,h,data))\n\nfor i in a:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n    W, H = map(int, input().split())\n    if W | H == 0:\n        break\n    tiles = [input() for i in range(H)]\n    first = ()\n    for h in range(H):\n        index = tiles[h].find(\"@\")\n        if index != -1:\n            first = (index, h)\n            break\n    memo = {first: 0}\n    que = deque([first])\n    count = 1\n    while len(que) > 0:\n        x, y = que.popleft()\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            if (x + dx, y + dy) not in memo:\n                if (0 <= x + dx < W) and (0 <= y + dy < H) and tiles[y + dy][x + dx] == \".\":\n                    count += 1\n                    memo[(x + dx, y + dy)] = 1\n                    que.append((x + dx, y + dy))\n    print(count)\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input().split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn\n\t\tif m[cy][cx] == '.'v or  m[cy][cx] == '@'\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "def depth_first_search(x, y):\n    \"\"\"\n    ??±???????????¢?´¢?????????\n    :param x: ?????¨??°????¨?\n    :param y: ?????¨??°??????\n    :return: ?????°\n    \"\"\"\n\n    # ????????????????????§?¢??????????\n    # ??????x  ,y+1\n    # ??????x+1,y\n    # ??????x  ,y-1\n    # ??????x-1,y\n    move_list = [[0,1],[1,0],[0,-1],[-1,0]]\n    for i in range(0,4,1):\n        next_x = x+move_list[i][0]\n        next_y = y+move_list[i][1]\n        # tile_map??????????§??????§????????´??????'.'???\n        if 0 <= next_x and 0 <= next_y and \\\n            next_x < W and next_y < H and \\\n            tile_map[next_y][next_x] != '#':\n\n            # ?§?????????????????????¨??°????§??????§??????????????????\"#\"??????????????????\n            tile_map[y][x] = '#'\n            import __main__\n            __main__.move_point = __main__.move_point+1\n            depth_first_search(next_x, next_y)\n\ndef get_start_point(tile_map):\n    \"\"\"\n    @????????????????????????\n    :param tile_map:\n    :return:\n    \"\"\"\n    for i, y in enumerate(tile_map):\n        for j, x in enumerate(y):\n            if x == '@':\n                return i, j\n\ndef check_testcase():\n    with open('./1130-input.txt') as f:\n        pre_input_testcase = f.read()\n    with open('./1130-output.txt') as f:\n        pre_output_testcase = f.read()\n    pre_input_testcase = pre_input_testcase.splitlines()\n    output_testcase = pre_output_testcase.splitlines()\n\n    test_tile_size = [0]*len(output_testcase)\n    test_tile_map = [[\"\"]]*len(output_testcase)\n    map_info_cnt = 0\n    map_info_index = 0\n    for v in pre_input_testcase:\n        if map_info_cnt == 0:\n            W, H = [int(x) for x in v.split(' ')]\n            test_tile_size.append([W, H])\n            map_info_cnt = H\n            map_info_index = map_info_index+1\n        else:\n            print(map_info_index)\n            test_tile_map[map_info_index]=test_tile_map[map_info_index].append(v)\n            map_info_cnt = map_info_cnt -1\n    import ipdb;ipdb.set_trace()\n\nif __name__ == \"__main__\":\n    move_point = 0\n    while (True):\n        # input_1 : tile????????????\n        tile_size = input('').split(' ')\n        W, H = [int(x) for x in tile_size]\n        if W == 0 and H == 0:\n            break\n        tile_map=[''] * H\n        for i in range(0, H, 1):\n            # input_2 : tile???????????????????????????\n            map_line = list(input(''))\n            tile_map[i] = map_line\n        start_H, start_W = get_start_point(tile_map)\n        depth_first_search(start_W, start_H)\n        print(move_point)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10**6)\n\nW = None\nH = None\nMMAP = None\nD = [(0,1),(0,-1),(1,0),(-1,0)]\n\ndef main():\n    global W,H,MMAP,D\n    while True:\n        W,H = map(int,input().split())\n        if not W and not H:\n            return\n        MMAP = [[] for _ in range(H)] # tiles[y][x]\n        sx,sy = 0,0\n        for y in range(H):\n            row = list(input())\n            if \"@\" in row:\n                sy = y\n                sx = row.index(\"@\")\n            MMAP[y] = row\n        # gprint(tiles)\n        print(calc(sx,sy))\n\ndef calc(x,y):\n    global W,H,MMAP,D\n\n    if not (x >= 0 and x < W and y >= 0 and y < H):\n        return 0\n    \n    if MMAP[y][x] == \"v\" or MMAP[y][x] == \"#\":\n        return 0\n\n    # gprint(MMAP)\n    # input()\n\n    ssum = 1\n    MMAP[y][x] = \"v\"\n\n    for dx,dy in D:\n        nx = x+dx\n        ny = y+dy\n        ssum += calc(x+dx,y+dy)\n\n    return ssum\n\ndef gprint(tiles):\n    for r in tiles:\n        print(str(\"|\".join(r)))\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "w,h=map(int,input().split())\nwhile w!=0 or h!=0:\n    maps=[]\n    flag=False\n    ans=0\n    for i in range(h):\n        k=list(input())\n        maps.append(k)\n    for i in range(h):\n        if flag:\n            break\n        for j in range(w):\n            if maps[i][j]=='@':\n                maps[i][j]='#'\n                pos_x=i\n                pos_y=j\n                flag=True\n                break\n    def check(x,y):\n        global maps\n        if 0<=x<h and 0<=y<w:\n            pass\n        else:\n            return False\n        if maps[x][y]=='#':\n            return False\n        else:\n            return True\n    def bfs(x,y):\n        global ans\n        global maps\n        for i in [[0,1],[0,-1],[1,0],[-1,0]]:\n            p=i[0]\n            q=i[1]\n            if check(x+p,y+q):\n                ans+=1\n                maps[x+p][y+q]='#'\n                bfs(x+p,y+q)\n    bfs(pos_x,pos_y)\n    print(ans+1)\n    w,h=map(int,input().split())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nmove = ((0,1),(1,0),(0,-1),(-1,0))\n\ndef inmap(x,y):\n    if 0 <= x <= Lx-1 and 0<= y <= Ly-1:\n        return True\n    return False\n\nwhile True:\n    Lx,Ly = map(int,input().split())\n    if Lx == 0:\n        break\n    curx= -1\n    cury = -1\n    orimap = [[] for _ in range(Ly)]\n    for i in range(Ly):\n        for j in input():\n            orimap[i].append(j)\n    for y in range(len(orimap)):\n        for x in range(len(orimap[y])):\n            if orimap[y][x] == \"@\":\n                curx,cury = x,y\n                orimap[y][x]=\"#\"\n                break\n        if curx != -1:\n            break\n    Q = deque()\n    Q.append([curx,cury])\n    count = 1\n    while len(Q)>0:\n        curx,cury = Q.popleft()\n        for dx,dy in move:\n            nextx = curx + dx\n            nexty = cury + dy\n            if inmap(nextx,nexty):\n                if orimap[nexty][nextx] != \"#\":\n                    orimap[nexty][nextx] = \"#\"\n                    Q.append([nextx,nexty])\n                    count += 1\n    print(count)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ny = [-1,0,1,0]\nx = [0,-1,0,1]\n\ndef main():\n\n    h,w = 0,0\n    c = []\n\n    def check(i,j):\n        return 0<=i and i<h and 0<=j and j<w\n\n    def bfs(a,b):\n        res = 0\n        d = deque()\n        d.append([a,b])\n        f = [[False]*w for _ in range(h)]\n        while len(d):\n            i,j = d.popleft()\n            if not check(i,j):continue\n            if c[i][j]=='#':continue\n            if f[i][j]==True:continue\n            res += 1\n            f[i][j]=True\n            for k in range(4):\n                d.append([i+y[k],j+x[k]])\n        return res\n\n    while True:\n        w,h = map(int,input().split())\n        if h==0 and w==0:break\n        c = []\n        for i in range(h):\n            c.append(input())\n        res = 0\n        for i in range(h):\n            for j in range(w):\n                if c[i][j]=='@':\n                    res = bfs(i,j)\n        print(res)\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "x=0\ny=0\nb=[]\nt=[]\ndir=[[1,0],[0,1],[-1,0],[0,-1]]\nans=0\n\ndef dfs(p_x,p_y):\n  global b,t,ans\n  if t[p_y][p_x] or not b[p_y][p_x]: return\n  ans+=1\n  t[p_y][p_x]=True\n  for i in dir:\n    dfs(p_x+i[0],p_y+i[1])\n\nwhile True:\n  x=0\n  y=0\n  w,h=map(int,input().split())\n  if w==0 and h==0: break\n  b=[[False]*(w+2) for i in range(h+2)]\n  t=[[False]*(w+2) for i in range(h+2)]\n  ans=0\n  for i in range(1,h+1):\n    tmp=list(input())\n    for j in range(1,w+1):\n      b[i][j]=(tmp[j-1] in {'.','@'})\n      if tmp[j-1]=='@': x=j;y=i\n  dfs(x,y)\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "dx = [-1,0,1,0]; dy = [0,-1,0,1];\nwhile 1:\n    w,h = map(int, raw_input().split())\n    if w==h==0: break;\n    m = []; s = []; sx = sy = 0;\n    m.append('#'*(w+2))\n    for i in range(h):\n        m.append(\"#\"+raw_input()+\"#\")\n    m.append('#'*(w+2))\n    f = [[0 for i in range(w+2)] for j in range(h+2)]\n    for i in range(1,h+1):\n        for j in range(1,w+1):\n            if m[i][j]=='@':\n                sx = j; sy = i;\n    s.append([sx,sy]);\n    f[sy][sx] = 1; ans = 1;\n    while len(s)>0:\n        x,y = s.pop(0)\n        for k in range(4):\n            if m[y+dy[k]][x+dx[k]]!='#' and f[y+dy[k]][x+dx[k]]==0:\n                s.append([x+dx[k],y+dy[k]])\n                f[y+dy[k]][x+dx[k]] = 1; ans += 1;\n    print ans"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input()split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn 0\n\t\tif m[cy][cx] = '.'v or  m[cy][cx] = '@'\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndx,dy = [1,0,-1,0],[0,1,0,-1]\n\nwhile True:\n\tw,h = map(int,input().split())\n\tif w == 0 and h == 0:\n\t\tbreak\n\tfield = [input() for i in range(h)]\n\tfor i in range(h):\n\t\tif '@' in field[i]:\n\t\t\tsx,sy = i,field[i].find('@')\n\tvisited = [[False for i in range(w)] for j in range(h)]\n\tque = deque()\n\tque.append((sx,sy))\n\tvisited[sx][sy] = True\n\twhile que:\n\t\tp = que.popleft()\n\t\tfor i in range(4):\n\t\t\tnx,ny = p[0] + dx[i],p[1] + dy[i]\n\t\t\tif 0 <= nx < h and 0 <= ny < w and field[nx][ny] != '#' and not visited[nx][ny]:\n\t\t\t\tvisited[nx][ny] = True\n\t\t\t\tque.append((nx,ny))\n\tcnt = 0\n\tfor i in range(h):\n\t\tfor j in range(w):\n\t\t\tcnt += visited[i][j]\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(dat):\n    H = len(dat)\n    W = len(dat[0])\n\n    for i in range(H):\n        for j in range(W):\n            if dat[i][j] == \"@\":\n                si, sj = i, j\n\n    tmp = [[0 for _ in range(W)] for _ in range(H)]\n    di = [-1,1,0,0]\n    dj = [0,0,-1,1]\n    pool = [(si, sj)]\n\n    while len(pool) > 0:\n        # print pool, i, j\n        i, j = pool.pop()\n        tmp[i][j] = 1\n        for k in range(4):\n            ni = i + di[k]\n            nj = j + dj[k]\n            if ni in range(H) and nj in range(W) and dat[ni][nj] == \".\" and tmp[ni][nj] == 0:\n                pool.append((ni, nj))\n    cnt = sum([sum(tmp[i]) for i in range(H)])\n    return cnt\n\n\nwhile True:\n    W, H = map(int, raw_input().split(\" \"))\n    if W == H == 0:\n        break\n    dat = [raw_input() for _ in range(H)]\n    print solve(dat)\n"
  },
  {
    "language": "Python",
    "code": "adjR = [-1, 0, 0, 1]\nadjC = [0, 1, -1, 0]\n\ndef isValid(row, col, ROWS, COLS):\n    return row >= 0 and row < ROWS and col >= 0 and col < COLS\n\ndef floodfill(board, row, col, ROWS, COLS):\n    global adjR\n    global adjC\n\n    if not isValid(row, col, ROWS, COLS):\n        return 0\n    if board[row][col] == '#':\n        return 0\n\n    board[row][col] = '#'\n    total = 1\n    for x in range(4):\n        rr = row + adjR[x]\n        cc = col + adjC[x]\n        total += floodfill(board, rr, cc, ROWS, COLS)\n    return total\n    \n\nif __name__ == '__main__':\n    while True:\n        COLS, ROWS = list(map(int, input().split()))\n        if ROWS == 0 and COLS == 0:\n            break\n\n        board = []\n        for i in range(ROWS):\n            line = input()\n            board.append([ c for c in line ])\n            if '@' in line:\n                row = i\n                col = line.find('@')\n        \n        print(  floodfill(board, row, col, ROWS, COLS)  )\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    a = []\n    for i in range(h):\n        t = list(input())\n        a.append(t)\n        if '@' in t:\n            x = i\n            y = t.index('@')\n    stk = [[x, y]]\n    c = 1\n    while True:\n        if stk == []:\n            break\n        x, y = stk.pop()\n        if y != w-1 and a[x][y+1] == '.':\n            a[x][y+1] = '@'\n            stk.append([x, y+1])\n        if y != 0 and a[x][y-1] == '.':\n            a[x][y-1] = '@'\n            stk.append([x, y-1])\n        if x != h-1 and a[x+1][y] == '.':\n            a[x+1][y] = '@'\n            stk.append([x+1, y])\n        if x != 0 and a[x-1][y] == '.':\n            a[x-1][y] = '@'\n            stk.append([x-1, y])\n    print(sum([t.count('@') for t in a]))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nd = [(1,0),(-1,0),(0,1),(0,-1)]\nwhile 1:\n    w,h = map(int, input().split())\n    if w == h == 0:\n        break\n    s = [input() for i in range(h)]\n    bfs_map = [[1 for i in range(w)] for j in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if s[y][x] == \"@\":\n                ans = 1\n                q = deque()\n                q.append((y,x))\n                bfs_map[y][x] = 0\n                while q:\n                    y, x = q.popleft()\n                    for dy,dx in d:\n                        y_ = y+dy\n                        x_ = x+dx\n                        if 0 <= y_ < h and 0 <= x_ < w:\n                            if bfs_map[y_][x_] and s[y_][x_] == \".\":\n                                ans += 1\n                                bfs_map[y_][x_] = 0\n                                q.append((y_,x_))\n                print(ans)\n                break\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    W,H = map(int,input().split())\n    if W == 0: break\n    src = [input() for i in range(H)]\n    for y,row in enumerate(src):\n        x = row.find('@')\n        if x < 0: continue\n        sx,sy = x,y\n        break\n    visited = [[0 for x in range(W)] for y in range(H)]\n    visited[sy][sx] = 1\n    q = deque([(sx,sy)])\n    ans = 1\n    while q:\n        x,y = q.popleft()\n        for dx,dy in zip([1,0,-1,0],[0,1,0,-1]):\n            nx,ny = x+dx,y+dy\n            if not(0 <= nx < W) or not(0 <= ny < H): continue\n            if src[ny][nx] == '#' or visited[ny][nx]: continue\n            visited[ny][nx] = 1\n            ans += 1\n            q.append((nx,ny))\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import Queue\n\nwhile True:\n    w, h = [int(_) for _ in raw_input().split()]\n    if w == h == 0:\n        break\n    dat = [list(raw_input()) for _ in xrange(h)]\n    queue = Queue.Queue()\n    for y, r in enumerate(dat):\n        if \"@\" in r:\n            queue.put([r.index(\"@\"), y])\n\n    while not queue.empty():\n        x, y = queue.get()\n        for dx, dy in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n            if not (0 <= x + dx < w) or not (0 <= y + dy < h):\n                continue\n            if dat[y + dy][x + dx] == \".\":\n                dat[y + dy][x + dx] = \"@\"\n                queue.put([x + dx, y + dy])\n\n    ans = 0\n    for r in dat:\n        ans += r.count(\"@\")\n\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    x, y = list(map(int,input().split()))\n    if x == 0:break\n\n    mx = [1,-1,0,0]\n    my = [0,0,1,-1]\n    m = []\n    for i in range(y):\n        m.append(list(input()))\n        if '@' in m[-1]:\n            sx = m[-1].index('@')\n            sy = i\n    cnt = 0\n\n    def move(cur_x, cur_y):\n        global cnt\n        if cur_y >= y or cur_y < 0 or cur_x >= x or cur_x < 0:return\n        if m[cur_y][cur_x] == '.' or m[cur_y][cur_x] == '@':\n            cnt += 1\n            m[cur_y][cur_x] = '0'\n            for i in range(4):\n                move(cur_x + mx[i],cur_y + my[i])\n    move(sx,sy)\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "import queue\n\ndef solve(w, h):\n    q = queue.Queue()\n    m = [['#' for i in range(w+2)] for j in range(h+2)]\n    for i in range(h):\n        inp = input()\n        for j in range(w):\n            m[i+1][j+1] = inp[j]\n            if m[i+1][j+1] == '@':\n                start = [i+1,j+1]\n    q.put(start)\n    c = 1\n    while not q.empty():\n        cur = q.get()\n        XY = [(1,0), (-1, 0), (0, 1), (0, -1)]\n        for x, y in XY:\n            cx = cur[0]+x\n            cy = cur[1]+y\n            if m[cx][cy] == '.':\n                m[cx][cy] = '#'\n                q.put([cx, cy])\n                c+=1\n    return c\n\nwhile True:\n    w, h = [int(i) for i in input().split()]\n    if w == 0 and h == 0:\n        break\n    print solve(w,h)"
  },
  {
    "language": "Python",
    "code": "while True:\n    w, h = map(int, input().split())\n    if h == 0:\n        break\n    m = [list(input()) for _ in range(h)]\n    sx = 0\n    sy = 0\n    for yi, row in enumerate(m):\n        if '@' in row:\n            sy = yi\n            sx = row.index('@')\n    def dfs(x, y):\n        if x < 0 or w <= x or y < 0 or h <= y or m[y][x] == '#':\n            return 0\n        else:\n            m[y][x] = '#'\n            dy = [1, -1] + [0] * 2\n            dx = [0] * 2 + [1, -1]\n            return sum([dfs(x+dx[i], y+dy[i]) for i in range(4)]) + 1\n    print(dfs(sx, sy))\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile 1:\n    W,H = map(int,input().split())\n    if W==0 and H==0:break\n    tizu = []\n    for i in range(H):\n        row = input()\n        if \"@\" in row:\n            start = (i,row.index(\"@\"))#h,w の順\n        tizu.append(row)\n    went = [[False]*W for i in range(H)]\n    went[start[0]][start[1]] = True\n    ans = 1\n    queue = deque()#append,popleft\n    queue.append(start)\n    while queue:\n        curh,curw = queue.popleft()\n        for dh,dw in ((0,1),(0,-1),(1,0),(-1,0)):\n            newh = curh + dh\n            neww = curw + dw\n            if 0<=newh<H and 0<=neww<W:\n                if tizu[newh][neww] == \".\" and not went[newh][neww]:\n                    went[newh][neww] =True\n                    queue.append((newh,neww))\n                    ans += 1\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def move_a(y,x,count):\n    count += 1\n    li[x][y] = \"#\"\n    if li[x-1][y] == \".\":\n        count = move_a(y,x-1,count)\n    if li[x+1][y]== \".\":\n        count = move_a(y,x+1, count)\n    if li[x][y-1]== \".\":\n        count = move_a(y-1,x, count)\n    if li[x][y+1]== \".\":\n        count = move_a(y+1,x, count)\n    return count\n\nwhile True:\n    yoko, tate = map(int,raw_input().split())\n    if yoko == 0 and tate == 0:\n        break\n    li = []\n    rec_list = []\n    count = 0\n    li.append([\"#\"] * (yoko + 2))\n\n    for i in range(tate):\n        temp = raw_input()\n        temp = \"#\" + temp +\"#\"\n        li.append(list(temp))\n    li.append([\"#\"]*(yoko+2))\n    for i in li:\n        if '@' in i:\n            a_posx,a_posy = i.index('@'),li.index(i)\n    print move_a(a_posx,a_posy,count)"
  },
  {
    "language": "Python",
    "code": "vx = [1, -1, 0, 0]\nvy = [0, 0, 1, -1]\n\n\ndef isBound(n, m, x, y):\n    return x < 0 or y < 0 or x >= n or y >= m\n\n\ndef dfs(x, y):\n    global field\n    global cnt\n    global v\n\n    if isBound(W, H, x, y):\n        return\n    if field[y][x] == '#':\n        return\n    if v[y][x]:\n        return\n    else:\n        v[y][x] = True\n        cnt += 1\n\n    for i in range(4):\n        nx = x + vx[i]\n        ny = y + vy[i]\n        dfs(nx, ny)\n\nwhile True:\n    W, H = map(int, raw_input().split())\n\n    if W == 0:\n        break\n\n    field = []\n    for h in range(H):\n        field.append(raw_input())\n\n    v = [[False for i in range(W)] for j in range(H)]\n\n    cnt = 0\n    for x in range(W):\n        for y in range(H):\n            if field[y][x] == '@':\n                dfs(x, y)\n    print cnt"
  },
  {
    "language": "Python",
    "code": "while True:\n    w,h = map(int,input().split())\n    if w == 0:\n        break\n    around = ''\n    for i in range(w + 2):\n        around += '#'\n    maze = [around]\n    cnt = 1\n    for i in range(h):\n        row = '#' + input() + '#'\n        maze.append(row)\n        if '@' in row:\n            loc = [[i + 1,row.index('@')]]\n    maze.append(around)\n    visted = loc\n    left = True\n    while left:\n        next_loc = []\n        for x,y in loc:\n            for i,j in ([1,0],[0,1],[-1,0],[0,-1]):\n                if maze[x + i][y + j] == '.' and [x + i,y + j] not in visted:\n                    cnt += 1\n                    next_loc.append([x + i,y + j])\n                    visted.append([x + i,y + j])\n            if  next_loc == []:\n                print(cnt)\n                left = False\n                break\n        loc = next_loc\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef dfs(s,Map,H,W):\n    dxdy = [(1,0),(-1,0),(0,1),(0,-1)]\n    for i in range(4):\n        Map[s[0]][s[1]] = '*'\n        nextPos = (s[0]+dxdy[i][0],s[1]+dxdy[i][1])\n        if nextPos[0] >= 0 and nextPos[1] >= 0 and nextPos[0] < H and nextPos[1] < W:\n            if Map[nextPos[0]][nextPos[1]] == '.':\n                dfs(nextPos,Map,H,W)\n\nwhile True:\n    W,H = map(int,input().split(\" \"))\n    if W == 0 and H == 0:\n        break\n    Map = [list(input()) for i in range(0,H)]\n    for i in range(H):\n        for j in range(W):\n            if Map[i][j] == '@':\n                S = (i,j)\n\n    dfs(S,Map,H,W)\n    print(sum([1 if Map[i][j] == '*' else 0 for i in range(H) for j in range(W)]))"
  },
  {
    "language": "Python",
    "code": "(lambda f: f(f))(lambda this, atin=lambda line, yp, ri=lambda l: room.append([{xi: x} for xi, x in enumerate(l)]): [point.__setitem__(\"x\", line.index(\"@\")), point.__setitem__(\"y\", yp), ri(line)] if \"@\" in line else ri(line), search=lambda xpoint, ypoint, srch, now: [room[ypoint][xpoint].__setitem__(xpoint, \"@\"), srch(xpoint - 1, ypoint, srch, now) + srch(xpoint + 1, ypoint, srch, now) + srch(xpoint, ypoint + 1, srch, now) + srch(xpoint, ypoint - 1, srch, now) + 1][1] if 0 <= xpoint < wh[0] and 0 <= ypoint < wh[1] and now(xpoint, ypoint) else 0, now=lambda xpoint, ypoint: room[ypoint][xpoint].get(xpoint) is \".\": [globals().__setitem__(\"wh\", list(map(int, input().split()))), globals().__setitem__(\"room\", []), globals().__setitem__(\"point\", {\"x\": None, \"y\": None}), [atin(input(), ypoint) for ypoint in range(wh[1])], [room[point[\"y\"]][point[\"x\"]].__setitem__(point[\"x\"], \".\"), print(search(point[\"x\"], point[\"y\"], search, now)), this(this)] if room else None])"
  },
  {
    "language": "Python",
    "code": "import collections\nwhile True:\n    w,h = map(int,input().split())\n    if w==0 and h==0:\n        break\n    tile=[]\n    tile.append([\"#\"]*(w+2))\n    for _ in range(h):\n        temp= list(input())\n        temp=  [\"#\"]+ temp + [\"#\"]\n        tile.append(temp)\n    tile.append([\"#\"]*(w+2))\n\n    route=[[[0,0,0,0] for i in range(w)] for j in range(h)]\n    for i in range(1,h+1):\n        for j in range(1,w+1):\n            if tile[i+1][j] ==\".\":\n                route[i-1][j-1][0]= 1\n            if tile[i-1][j] ==\".\":\n                route[i-1][j-1][1]= 1\n            if tile[i][j+1] ==\".\":\n                route[i-1][j-1][2]= 1\n            if tile[i][j-1] ==\".\":\n                route[i-1][j-1][3]= 1\n            if tile[i][j]==\"@\":\n                st=[i-1,j-1]\n\n    dir= [[1,0],[-1,0],[0,1],[0,-1]]\n    d=[[0]*w for i in range(h)]\n    d[st[0]][st[1]]=1\n    q= collections.deque()\n    q.append(st)\n    while len(q)> 0:\n        cur = q.popleft()\n        for i in range(4):\n            if route[cur[0]][cur[1]][i]==1 and d[cur[0]+dir[i][0]][cur[1]+dir[i][1]]==0:\n                d[cur[0]+dir[i][0]][cur[1]+dir[i][1]]=1\n                q.append([cur[0]+dir[i][0],cur[1]+dir[i][1]])\n\n    ans=0\n    for i in range(h):\n        for j in range(w):\n            if d[i][j] == 1:\n                ans+=1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "mx = [0, 1, 0, -1]\nmy = [-1, 0, 1, 0]\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == h == 0:\n        break\n    tiles = [[i for i in input()] for j in range(h)]\n    ax = ay = 0\n    for i in range(h):\n        for j in range(w):\n            if tiles[i][j] == '@':\n                ax, ay = j, i\n    que = [(ax, ay)]\n    tiles[ay][ax] = '#'\n    cnt = 1\n\n    while 0 < len(que):\n        new_que = []\n        for x, y in que:\n            for i in range(4):\n                nx, ny = x + mx[i], y + my[i]\n                if 0 <= nx <= w - 1 and 0 <= ny <= h - 1:\n                    if tiles[ny][nx] == '.':\n                        cnt += 1\n                        new_que.append((nx, ny))\n                        tiles[ny][nx] = '#'\n        que = new_que\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "def search(M, l, walkable):\n    i, j = (l.pop(0))\n    nexts = []\n    if i !=0:\n        nexts.append((i-1, j))\n    if i != len(M)-1:\n        nexts.append((i+1, j))\n    if j != 0:\n        nexts.append((i, j-1))\n    if j != len(M[0])-1:\n        nexts.append((i, j+1))\n\n    for nex in nexts:\n        x, y = nex\n        if M[x][y] == '.' and not nex in walkable:\n            l.append(nex)\n            walkable.append(nex)\n\ninp = ''\nwhile '0 0' != (inp = input()):\n    i, j = [int(x) for x in inp.split()]\n    M = [input() for i in range(j)]\n    l = []\n    for n in len(M):\n        if '@' in M[n]:\n            l.append((n, M[n].find('@')))\n\n    walkable = []\n    while l:\n        search(M, l, walkable)\n    print(len(walkable)+1)"
  },
  {
    "language": "Python",
    "code": "c = {\"#\":0,\n     \"@\":1,\n     \".\":2,\n     \"*\":3}\n\nd = [[0, -1],\n     [0, 1],\n     [-1, 0],\n     [1, 0]]\n\noutput = []\nwhile True:\n    w, h = input().split()\n    w = int(w)\n    h = int(h)\n\n    if w == 0:\n        break\n\n    tiles = [[0 for i in range(w)] for j in range(h)]\n    for i in range(h):\n        row = input()\n        for j in range(w):\n            tiles[i][j] = c[row[j]]\n            if tiles[i][j] == 1:\n                queue = [(j, i)]\n\n    count = 1\n    while queue:\n        x, y = queue[0]\n        queue.pop(0)\n\n        for ud, rl in d:\n            xt = x+ud\n            yt = y+rl\n            if xt >= 0 and xt <= w-1 and yt >= 0 and yt <= h-1:\n                if tiles[yt][xt] == 2:\n                    tiles[yt][xt] = 3\n                    count += 1\n                    queue.append((xt, yt))\n\n    output.append(count)\n\nfor num in output:\n    print(num)"
  },
  {
    "language": "Python",
    "code": "if __name__ == \"__main__\":\n    while 1:\n        w,h = list(map(int,input().strip().split()))\n        if w == h == 0:break\n        data = []\n        data = []\n        for _ in range(h):data.append(list(input()))\n        visited = []\n        for i in range(h):\n            if '@'in data[i]:stack= [(i,data[i].index('@'))]\n        count = 0\n        while len(stack) !=0:\n            y,x= stack.pop()\n            count +=1\n            if y-1 >= 0 and not (y-1,x)in visited and data[y -1][x] == '.':\n                visited.append((y-1,x))\n                stack.append((y-1,x))\n            if x -1 >= 0 and not (y,x-1)in visited and data[y][x-1] == '.':\n                visited.append((y,x-1))\n                stack.append((y,x-1))\n            if y +1 < h and not (y+1,x)in visited and data[y +1][x] == '.':\n                visited.append((y+1,x))\n                stack.append((y+1,x))\n            if x + 1 < w and not (y,x+1)in visited and data[y][x +1] == '.':\n                visited.append((y,x+1))\n                stack.append((y,x+1))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    W,H = [int(x) for x in input().split()]\n    if W==0 and H==0:\n        exit()\n    tiles = []\n    X = 0\n    Y = 0\n    for i in range(H):\n        tiles.append(input())\n        if '@' in tiles[i]:\n            Y = i\n            X = tiles[i].index('@')\n    d = [[9999 for j in range(H*W)] for i in range(H*W)]\n    for i in range(H*W):\n        d[i][i] = 0\n    for i in range(H):\n        for j in range(W):\n            if j>0:\n                if tiles[i][j] in '.@' and tiles[i][j-1] in '.@':\n                    d[W*i+j][W*i+j-1] = 1\n            if j<W-1:\n                if tiles[i][j] in '.@' and tiles[i][j+1] in '.@':\n                    d[W*i+j][W*i+j+1] = 1\n            if i>0:\n                if tiles[i][j] in '.@' and tiles[i-1][j] in '.@':\n                    d[W*i+j][W*i+j-W] = 1\n            if j<H-1:\n                if tiles[i][j] in '.@' and tiles[i+1][j] in '.@':\n                    d[W*i+j][W*i+j+W] = 1\n    for k in range(H*W):\n        for i in range(H*W):\n            for j in range(H*W):\n                if d[i][j] > d[i][k]+d[k][j]:\n                    d[i][j] = d[i][k]+d[k][j]\n    cnt = 0\n    for i in range(H*W):\n        if d[X+Y*H][i]<9999:\n            cnt += 1\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nct=1\ndef count(Map, w,h,i, j):\n    global ct\n    dx=[1,0,-1,0]\n    dy=[0,1,0,-1]\n    for k in range(4):\n        ix=i+dy[k]\n        jx=j+dx[k]\n        if (0<=ix<h and 0<=jx<w and Map[ix][jx]=='.'):\n            Map[ix][jx]='#'\n            ct+=1\n            count(Map,w,h,ix,jx)\n\nwhile(True):\n    input = map(int, sys.stdin.readline().replace('\\n','').split(' '))\n    w,h=input\n    if(w==0 and h==0):break\n    Map=[]\n    for i in range(h):\n        s=raw_input()\n        Map.append(list(s))\n        \n    flag=False\n    for i in range(h):\n        for j in range(w):\n            if (Map[i][j]=='@'):\n                flag=True\n                Map[i][j]='#'\n                break\n        if flag:break\n\n    ct=1\n    count(Map,w,h,i,j)\n    print ct"
  },
  {
    "language": "Python",
    "code": "c = 0\ndef calc(t, X, Y):\n    global c\n    c += 1\n    t[Y][X] = '#'\n    for x, y in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        if t[Y + y][X + x] == '.':\n            calc(t, X + x, Y + y)\n            \nwhile True:\n    c = 0\n    w, h = map(int, input().split())\n    if w == h == 0:\n        break\n    \n    t = [['#'] * (w + 2) ] + [['#'] + list(input()) + ['#'] for _ in range(h)] + [['#'] * (w + 2)]\n    for sy in range(h + 2):\n        if '@' in t[sy]:\n            sx = t[sy].index('@')\n            break\n      \n    calc(t, sx, sy)\n    print(c)\n\n        \n        \n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n#AOJ B\nfrom collections import deque\n\ndef bfs():\n    while 1:\n        W,H = map(int,input().split())\n        if W == 0 and H == 0:\n            break\n        maze = [list(input()) for _ in range(H)]\n        check = [[False for _ in range(W)] for _ in range(H)]\n        #print(maze)\n        dx = [1,0,-1,0]\n        dy = [0,1,0,-1]\n        for i in range(H):\n            for j in range(W):\n                if maze[i][j] == '@':\n                    sx,sy = j,i\n                    check[i][j] = True\n\n        ans = 1\n        que = deque()\n        que.append((sx,sy))\n        while que:\n            x,y = que.pop()\n            for i in range(4):\n                nx,ny = x + dx[i],y + dy[i]\n\n                if 0 <= nx < W and 0 <= ny < H and maze[ny][nx] == '.' and check[ny][nx] == False:\n                    que.append((nx,ny))\n                    check[ny][nx] = True\n                    ans += 1\n        print(ans)\n    return\n\nif __name__ == '__main__':\n    bfs()\n"
  },
  {
    "language": "Python",
    "code": "def dfs(x, y, W, H):\n    if x >= H or y >= W or x < 0 or y < 0:\n        return\n    if visited[x][y] == 1:\n        return\n    if gridgraph[x][y] == '.' or gridgraph[x][y] == '@':\n        visited[x][y] = 1\n        dfs(x+1, y, W, H)\n        dfs(x, y+1, W, H)\n        dfs(x-1, y, W, H)\n        dfs(x, y-1, W, H)\n    if gridgraph[x][y] == '#':\n        return\n\n    return\n\n\nwhile True:\n    W, H = map(int, input().split())\n    if W == 0 and W == 0:\n        break\n    gridgraph = [list(input()) for _ in range(H)]\n\n    visited = [[0]*W for _ in range(H)]\n\n    sx = -1\n    sy = -1\n    for i, row in enumerate(gridgraph):\n        for j in range(len(row)):\n            if row[j] == '@':\n                sx = i\n                sy = j\n    dfs(sx, sy, W, H)\n\n    ans = 0\n    for row in visited:\n        ans += sum(row)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def search(x, y, m):\n    if x >= len(m[0]) or y >= len(m):\n        return 0\n    if m[y][x] == '#':\n        return 0\n    m[y][x] = '#'\n    return 1 + search(x+1,y, m) + search(x-1,y,m) \\\n            + search(x,y+1,m) + search(x,y-1,m)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0: break\n    room = []\n    for i in range(h):\n        tmp = list(input())\n        room.append(tmp[:w])\n        if '@' in tmp:\n            y = i\n            x = tmp.index('@') \n    print(search(x, y, room))"
  },
  {
    "language": "Python",
    "code": "def dfs(x, y):\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if abs(dx) + abs(dy) == 2 or abs(dx) + abs(dy) == 2:\n                continue\n            next_x, next_y = x + dx, y + dy\n            if 0 <= next_x < H and 0 <= next_y < W and isVisited[next_x][next_y] == 0 and tile[next_x][next_y] == '.':\n                isVisited[next_x][next_y] = 1\n                dfs(next_x, next_y)\n                \n                \n\nwhile True:\n    W, H = map(int, raw_input().split())\n    if W == 0 and H == 0: break\n    tile = [raw_input() for _ in range(H)]\n    ans = 0\n    isVisited = [[0]*W for _ in range(H)]\n    for cnt, t in enumerate(tile):\n        if '@' in t:\n            sx = cnt\n            sy = t.index('@')\n            break\n    isVisited[sx][sy] = 1\n    dfs(sx, sy)\n    print sum([sum(v) for v in isVisited])"
  },
  {
    "language": "Python",
    "code": "def move_a(y,x,count):\n    count += 1\n    li[x][y] = \"#\"\n    if li[x-1][y] == \".\":\n        count = move_a(y,x-1,count)\n    if li[x+1][y]== \".\":\n        count = move_a(y,x+1, count)\n    if li[x][y-1]== \".\":\n        count = move_a(y-1,x, count)\n    if li[x][y+1]== \".\":\n        count = move_a(y+1,x, count)\n    return count\n\nwhile True:\n    yoko, tate = map(int,raw_input().split())\n    if yoko == 0 and tate == 0:\n        break\n    li = []\n    rec_list = []\n    count = 0\n    li.append([\"#\"] * (yoko + 2))\n\n    for i in range(tate):\n        temp = raw_input()\n        temp = \"#\" + temp +\"#\"\n        li.append(list(temp))\n    li.append([\"#\"]*(yoko+2))\n    print li\n    for i in li:\n        if '@' in i:\n            a_posx,a_posy = i.index('@'),li.index(i)\n    print move_a(a_posx,a_posy,count)"
  },
  {
    "language": "Python",
    "code": "def f(h,w):\n  global W,H,S,A\n  if h<0 or h>=H or w<0 or w>=W or S[h][w]==\"#\" or A[h][w]==1:\n    return\n  A[h][w] = 1\n  f(h-1,w)\n  f(h+1,w)\n  f(h,w-1)\n  f(h,w+1)\nwhile True:\n  W,H = map(int,input().split())\n  if W+H == 0:\n    break\n  S = [list(input()) for h in range(H)]\n  A = [[0 for w in range(W)] for h in range(H)]\n  for h in range(H):\n    for w in range(W):\n      if S[h][w] == \"@\":\n        f(h,w)\n        break\n  ans = 0\n  for i in A:\n    ans += sum(i)\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "d = [[-1,0],[1,0],[0,-1],[0,1]]\ndef search(w,h,x,y,m):\n    if not(0<=x<w and 0<=y<h) or m[y][x]=='#': return 0\n    m[y][x] = '#'\n    return sum([search(w,h,x+dx,y+dy,m) for dx,dy in d])+1\n\nwhile True:\n    w,h = map(int,input().split())\n    if w==h==0: break\n    m = []\n    for i,l in enumerate([list(input()) for _ in range(h)]):\n        if '@' in l: x,y = l.index('@'),i\n        m += [l]\n    print(search(w,h,x,y,m))"
  },
  {
    "language": "Python",
    "code": "import queue\ndxy=[(1,0),(0,1),(-1,0),(0,-1)]\ndef bfs(sx,sy,H,W):#幅優先探索\n    q=queue.Queue()\n    visited=[[False]*W for _ in range(H)]\n    q.put((sx,sy))\n    visited[sx][sy]=True\n    ans=1\n    while not q.empty():\n        px,py=q.get()\n        for dx,dy in dxy:\n            nx=px+dx\n            ny=py+dy\n            if 0<=nx<H and 0<=ny<W:\n                if c[nx][ny]=='.' and visited[nx][ny]==False:\n                    visited[nx][ny]=True\n                    q.put((nx,ny))\n                    ans+=1\n    return ans\nwhile True:\n    W,H=map(int,input().split())\n    if(W==0 and H==0):\n        break\n    c=[input() for _ in range(H)]\n    for i in range(H):\n        if \"@\" in c[i]:\n            sx=i\n            sy=c[i].index(\"@\")\n    print(bfs(sx,sy,H,W))\n"
  },
  {
    "language": "Python",
    "code": "\ndef depth_first_search(x, y):\n    \"\"\"\n    ??±???????????¢?´¢?????????\n    :param x: ?????¨??°????¨?\n    :param y: ?????¨??°??????\n    :return: ?????°\n    \"\"\"\n\n    # ????????????????????§?¢??????????\n    # ??????x  ,y+1\n    # ??????x+1,y\n    # ??????x  ,y-1\n    # ??????x-1,y\n    move_list = [[0,1],[1,0],[0,-1],[-1,0]]\n    for i in range(0,4,1):\n        next_x = x+move_list[i][0]\n        next_y = y+move_list[i][1]\n        # tile_map??????????§??????§????????´??????'.'???\n        if 0 <= next_x and 0 <= next_y and \\\n            next_x < W and next_y < H and \\\n            tile_map[next_y][next_x] != '#':\n\n            # ?§?????????????????????¨??°????§??????§??????????????????\"#\"??????????????????\n            tile_map[y][x] = '#'\n            import __main__\n            __main__.move_point = __main__.move_point+1\n            depth_first_search(next_x, next_y)\n\n\ndef get_start_point(tile_map):\n    \"\"\"\n    @????????????????????????\n    :param tile_map:\n    :return:\n    \"\"\"\n    for i, y in enumerate(tile_map):\n        for j, x in enumerate(y):\n            if x == '@':\n                return i, j\n\n\n\nif __name__ == \"__main__\":\n    move_point = 0\n    first = True\n    while (True):\n        # input_1 : tile????????????\n        tile_size = input('').split(' ')\n        W, H = [int(x) for x in tile_size]\n        if W == 0 and H == 0:\n            break\n        if first:\n            first = False\n        else:\n            print('')\n        tile_map=[''] * H\n        for i in range(0, H, 1):\n            # input_2 : tile???????????????????????????\n            map_line = list(input(''))\n            tile_map[i] = map_line\n        start_H, start_W = get_start_point(tile_map)\n        depth_first_search(start_W, start_H)\n        import ipdb;ipdb.set_trace()\n        print(move_point)"
  },
  {
    "language": "Python",
    "code": "def count_area(h,w):\n\tcount = 0\n\tif (h>0) and (s[h-1][w]== \".\"):\n\t\ts[h-1][w] = \"#\"\n\t\tcount += count_area(h-1,w)\n\tif (h<H-1) and (s[h+1][w]== \".\"):\n\t\ts[h+1][w] = \"#\"\n\t\tcount += count_area(h+1,w)\n\tif (w>0) and (s[h][w-1]== \".\"):\n\t\ts[h][w-1] = \"#\"\n\t\tcount += count_area(h,w-1)\n\tif (w<W-1) and (s[h][w+1]== \".\"):\n\t\ts[h][w+1] = \"#\"\n\t\tcount += count_area(h,w+1)\n\treturn count+1\n\nwhile(True):\n\tW, H = map(int, input().split())\n\tif H==0&W==0:break\n\n\ts = [list(input()) for i in range(H)]\n\t\n\tfor h in range(H):\n\t\tfor w in range(W):\n\t\t\tif s[h][w] == \"@\":\n\t\t\t\ts[h][w] = \"#\"\n\t\t\t\tprint(count_area(h,w))\n\t\t\t\tbreak\n\n\n"
  },
  {
    "language": "Python",
    "code": "def walk(x, y):\n        #print x,y\n        global s\n        global c\n        global v\n        if 0 <= x < w and 0 <= y < h:\n                if v[y][x] is False:\n                        if s[y][x] == '@' or s[y][x] == '.':\n                                v[y][x] = True\n                                c += 1\n                                #print 'hai'\n                                walk(x-1, y)\n                                walk(x, y-1)\n                                walk(x+1, y)\n                                walk(x, y+1)\n\nwhile 1:\n        c = 0\n        w,h = map(int, raw_input().split())\n        if w == 0 and h == 0: break\n        s = ['' for i in xrange(h)]\n        v = [[False for j in xrange(w)] for i in xrange(h)]\n        for i in xrange(h):\n                s[i] = raw_input()\n        for i in xrange(w):\n                for j in xrange(h):\n                        if s[j][i] == '@':\n                                walk(i, j)\n        #print v\n        print c"
  },
  {
    "language": "Python",
    "code": "from queue import Queue\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == h == 0:\n        break\n\n    tile = [input() for i in range(h)]\n    for x, col in enumerate(tile):\n        if '@' in col:\n            y = col.index('@')\n            s = (x, y)\n            break\n\n    visit = [[False for i in range(w)] for j in range(h)]\n    dx = (0, -1, 1, 0)\n    dy = (1, 0, 0, -1)\n    que = Queue()\n    que.put(s)\n    while not que.empty():\n        x, y = que.get()\n        if visit[x][y]:\n            continue\n\n        visit[x][y] = True\n        for j in range(4):\n            sx = x + dx[j]\n            sy = y + dy[j]\n            if sx < 0 or sx >= h or sy < 0 or sy >= w:\n                continue\n            if tile[sx][sy] != '#':\n                que.put((sx, sy))\n\n    ans = 0\n    for col in visit:\n        ans += col.count(True)\n\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def location(field, wanted):\n    for i, row in enumerate(field):\n        for j, cell in enumerate(row):\n            if cell == wanted:\n                return i, j\ndef count(field, wanted):\n    result = 0\n    for row in field:\n        for cell in row:\n            if cell == wanted:\n                result += 1\n    return result\ndef neighborhood(center, w, h):\n    i, j = center\n    return filter(lambda x: 0 <= x[0] and x[0] < h and 0 <= x[1] and x[1] < w,\n                  [                (i - 1, j    ),\n                   (i    , j - 1),                 (i    , j + 1),\n                                   (i + 1, j    )])\nprinted_later = []\nwhile True:\n    #入力\n    w, h = map(int, input().split())\n    if(w == 0 and h == 0):\n        break\n    field = []  # strの配列すなわちcharの配列の配列 '.':黒 '#':赤 '@':スタート (',':到達可能)\n    for i in range(h):\n        field.append(list(input()))\n    #出力　幅優先探索\n    queue = [location(field,'@')]\n    field[queue[0][0]][queue[0][1]] = ','\n    while len(queue) > 0:\n        for cell in neighborhood(queue.pop(0), w, h):\n            if field[cell[0]][cell[1]] == '.':\n                queue.append(cell)\n                field[cell[0]][cell[1]] = ','\n    printed_later.append(count(field, ','))\nfor line in printed_later:\n    print(line)\n"
  },
  {
    "language": "Python",
    "code": "dx = [-1,0,1,0]; dy = [0,-1,0,1];\nwhile 1:\n    w,h = map(int, raw_input().split())\n    if w==h==0: break;\n    m = []; s = []; sx = sy = 0;\n    m.append('#'*(w+2))\n    for i in range(h):\n        m.append(\"#\"+raw_input()+\"#\")\n    m.append('#'*(w+2))\n    f = [[0 for i in range(w+2)] for j in range(h+2)]\n    for i in range(1,h+1):\n        for j in range(1,w+1):\n            if m[i][j]=='@':\n                sx = j; sy = i;\n    s.append([sx,sy]); ans = 0;\n    while len(s)>0:\n        x,y = s.pop()\n        for k in range(4):\n            if m[y+dy[k]][x+dx[k]]!='#' and f[y+dy[k]][x+dx[k]]==0:\n                s.append([x+dx[k],y+dy[k]])\n                f[y+dy[k]][x+dx[k]] = 1\n                ans += 1;\n    print ans"
  },
  {
    "language": "Python",
    "code": "\ndef depth_first_search(x, y):\n    \"\"\"\n    ??±???????????¢?´¢?????????\n    :param x: ?????¨??°????¨?\n    :param y: ?????¨??°??????\n    :return: ?????°\n    \"\"\"\n\n    # ????????????????????§?¢??????????\n    # ??????x  ,y+1\n    # ??????x+1,y\n    # ??????x  ,y-1\n    # ??????x-1,y\n    move_list = [[0,1],[1,0],[0,-1],[-1,0]]\n    for i in range(0,4,1):\n        next_x = x+move_list[i][0]\n        next_y = y+move_list[i][1]\n        # tile_map??????????§??????§????????´??????'.'???\n        if 0 <= next_x and 0 <= next_y and \\\n            next_x < W and next_y < H and \\\n            tile_map[next_y][next_x] != '#':\n\n            # ?§?????????????????????¨??°????§??????§??????????????????\"#\"??????????????????\n            tile_map[y][x] = '#'\n            import __main__\n            __main__.move_point = __main__.move_point+1\n            depth_first_search(next_x, next_y)\n\n\ndef get_start_point(tile_map):\n    \"\"\"\n    @????????????????????????\n    :param tile_map:\n    :return:\n    \"\"\"\n    for i, y in enumerate(tile_map):\n        for j, x in enumerate(y):\n            if x == '@':\n                return i, j\n\n\n\nif __name__ == \"__main__\":\n    move_point = 0\n    first = True\n    while (True):\n        # input_1 : tile????????????\n        tile_size = input('').split(' ')\n        W, H = [int(x) for x in tile_size]\n        if W == 0 and H == 0:\n            break\n        if first:\n            first = False\n        else:\n            print('')\n        tile_map=[''] * H\n        for i in range(0, H, 1):\n            # input_2 : tile???????????????????????????\n            map_line = list(input(''))\n            tile_map[i] = map_line\n        start_H, start_W = get_start_point(tile_map)\n        depth_first_search(start_W, start_H)\n        print(move_point)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\ndef check(p):\n    global ans\n    global field\n    ans+=1\n    if(field[p[1]][p[0]]=='.'):\n        field[p[1]][p[0]]='#'\n    if(0<=p[0]+1<w and field[p[1]][p[0]+1]=='.'):\n        check((p[0]+1,p[1]))\n    if(0<=p[0]-1<w and field[p[1]][p[0]-1]=='.'):\n        check((p[0]-1,p[1]))\n    if(0<=p[1]+1<h and field[p[1]+1][p[0]]=='.'):\n        check((p[0],p[1]+1))\n    if(0<=p[1]-1<h and field[p[1]-1][p[0]]=='.'):\n        check((p[0],p[1]-1))\n    \n    \nwhile 1:\n    ans=0\n    w,h=map(int,input().split())\n    if w==0:\n        break\n    field=[]\n    for i in range(h):\n        s=input()\n        t=s.find('@')\n        if(t!=-1):\n            st=(t,i)\n        field.append(list(s))\n    check(st)\n    print(ans)\n    \n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input().split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn\n\t\tif m[cy][cx] == '.' or  m[cy][cx] == '@':\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef bfs():\n    d = [[False] * w for i in range(h)]\n    dx = [1,0,-1,0]\n    dy = [0,1,0,-1]\n\n    que = deque([])\n    que.append((sx,sy))\n    d[sx][sy] = True\n    cnt = 1\n\n    while que:\n        p = que.popleft()\n        for i in range(4):\n            nx = p[0] + dx[i]\n            ny = p[1] + dy[i]\n\n            if 0 <= nx < h and 0 <= ny < w and Map[nx][ny] != \"#\" and d[nx][ny] == False:\n                cnt += 1\n                que.append((nx,ny))\n                d[nx][ny] = True\n    return cnt\n\nwhile 1:\n    w,h = map(int,input().split())\n    if w == 0 and h == 0:\n        break\n    Map = [str(input()) for i in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if Map[i][j] == \"@\":\n                sx = i\n                sy = j\n    print(bfs())\n"
  },
  {
    "language": "Python",
    "code": "(lambda f:f(f))(lambda T,A=lambda L,yp,ri=lambda l:R.append([{xi:x}for xi,x in enumerate(l)]):[P.__setitem__(\"x\",L.index(\"@\")),P.__setitem__(\"y\",yp),ri(L)]if \"@\"in L else ri(L),S=lambda X,Y,s,u:[R[Y][X].__setitem__(X,\"@\"),s(X-1,Y,s,u)+s(X+1,Y,s,u)+s(X,Y+1,s,u)+s(X,Y-1,s,u)+1][1]if 0<=X<W[0]and 0<=Y<W[1]and u(X,Y)else 0,u=lambda X,Y:R[Y][X].get(X)is \".\",g=globals:[g().__setitem__(\"W\",list(map(int,input().split()))),g().__setitem__(\"R\",[]),g().__setitem__(\"P\",{\"x\":9,\"y\":9}),[A(input(),Y)for Y in range(W[1])],[R[P[\"y\"]][P[\"x\"]].__setitem__(P[\"x\"],\".\"),print(S(P[\"x\"],P[\"y\"],S,u)),T(T)]if R else 9])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nw, h = map(int,input().split())\nwhile [h, w] != [0, 0]:\n    area = []\n    a = 1\n    for i in range(h):\n        area.append(list(input()))\n        area[i].insert(0,\"#\")\n        area[i].append(\"#\")\n    area.insert(0,[\"#\" for i in range(w + 2)])\n    area.append([\"#\" for i in range(w + 2)])\n\n    que = []\n    for i in range(h):\n        for j in range(1, w + 1):\n            if area[i][j] == \"@\":\n                que.append([i, j])\n                break\n        else:\n            continue\n        break\n    while True:\n        nque = []\n        for i in que:\n            h1 = i[0]\n            w1 = i[1]\n            if area[h1 - 1][w1] == \".\":\n                area[h1 - 1][w1] = \"*\"\n                nque.append([h1 - 1, w1])\n                a += 1\n            if area[h1 + 1][w1] == \".\":\n                area[h1 + 1][w1] = \"*\"\n                nque.append([h1 + 1, w1])\n                a += 1\n            if area[h1][w1 - 1] == \".\":\n                area[h1][w1 - 1] = \"*\"\n                nque.append([h1, w1 - 1])\n                a += 1\n            if area[h1][w1 + 1] == \".\":\n                area[h1][w1 + 1] = \"*\"\n                nque.append([h1, w1 + 1])\n                a += 1\n        if nque == []:\n            break\n        que = copy.deepcopy(nque)\n\n    print(a)\n        \n    w, h = map(int,input().split())\n"
  },
  {
    "language": "Python",
    "code": "import collections\n\ndx = [-1,0,1,0]\ndy = [0,-1,0,1]\ndef movable(dst):\n    if dst[0]<0 or dst[0]>b-1:\n        return False\n    elif dst[1]<0 or dst[1]>a-1:\n        return False\n    elif MM[dst[0]][dst[1]] == '#':\n        return False\n    else:\n        return True\n\nwhile True:\n    c = 1\n    a,b = map(int,input().split())\n    if a==0 and b==0:\n        exit()\n    else:\n        MM = []\n        for i in range(b):\n            q = list(input())\n            MM.append(q)\n            if '@' in q:\n                st = [i, q.index('@')]\n\n        D = [[-1 for _ in range(a)] for _ in range(b)]\n        D[st[0]][st[1]] = 0 # 始点への距離は 0, 他の距離は-1\n        Q = collections.deque()\n        Q.append(st) # 始点\n        while len(Q) > 0:\n            #print(\"bfs\", Q) # 各ステップでの Q の動作を確認\n            cur = Q.popleft()\n            for dir in range(4):\n                # curからdstに移動可能かつ、dstが未訪問だったら\n                dst = [cur[0]+dx[dir], cur[1]+dy[dir]]\n                #print(dst)\n                if movable(dst) and D[dst[0]][dst[1]] == -1:\n                    D[dst[0]][dst[1]] = D[cur[0]][cur[1]]+1\n                    c += 1\n                    Q.append(dst) # Qにdstを詰める\n        print(c)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport collections\n\nx = [1, 0, -1, 0]\ny = [0, 1, 0, -1]\nwhile True:\n    W, H = map(int, sys.stdin.readline().split())\n    if W == 0:\n        break\n    \n    tile = [[0 for i in xrange(W + 2)] for j in xrange(H + 2)]\n    \n    visited = set()\n    next = set()\n    \n    for i in xrange(H):\n        line = raw_input().strip()\n        for j in xrange(W):\n            if line[j] == '.':\n                tile[i + 1][j + 1] = 1\n            if line[j] == '@':\n                tile[i + 1][j + 1] = 1\n                next.add((i + 1, j + 1))\n#    for line in tile:\n#        print line\n    while len(next) > 0:\n        temp_next = set()\n        for n in next:\n            visited.add(n)\n            for i in xrange(4):\n                temp = (n[0] + x[i], n[1] + y[i])\n                if temp not in visited and tile[temp[0]][temp[1]] == 1:\n                    temp_next.add(temp)\n        next = temp_next\n    print len(visited)"
  },
  {
    "language": "Python",
    "code": "#2:52\nimport sys\n\nsys.setrecursionlimit(10000000)\n\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\n\n\n#左上からせめて深さ優先で探索する問題\nwhile True:\n    # 地図作る\n    width,hight = map(int,input().split())\n    if width ==0 :\n        break\n    d =[]\n    for _ in range(hight):\n        d.append(list(input()))\n    \n    def dfs(x, y):\n    # いまたどり着いたはずなので1に塗りつぶす\n        d[y][x]=\"d\"\n\n    #4方向ループ\n    #あくまで方向の表し方dxは\n        for i in range(4):\n            ny = y + dx[i]\n            nx = x + dy[i]\n\n        #行ったことがなくって、迷路の範囲内で、障害物がなければ、進む\n            if 0 <= ny and ny < hight \\\n              and 0 <= nx and nx < width \\\n              and d[ny][nx] == \".\":\n                dfs(nx,ny) \n\n    \n\n\n    for y in range(hight):\n        for x in range(width):\n            if d[y][x] == \"@\":\n                dfs(x,y)\n    \n    sum = 0 \n    for _ in range(hight):\n        sum = sum + d[_].count('d')\n    print(sum)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0:\n        break\n    else:\n        m = []\n        d = deque()\n        for i in range(h):\n            r = input()\n            m.append(list(r))\n            s = r.find('@')\n            if s != -1:\n                d.append((s, i))\n        while len(d):\n            rw, rh = d.popleft()\n            m[rh][rw] = 'Y'\n            if 0 < rw and m[rh][rw-1] == '.':\n                d.append((rw-1, rh))\n                m[rh][rw-1] = 'Y'\n            if rw < w-1 and m[rh][rw+1] == '.':\n                d.append((rw+1, rh))\n                m[rh][rw+1] = 'Y'\n            if 0 < rh and m[rh-1][rw] == '.':\n                d.append((rw, rh-1))\n                m[rh-1][rw] = 'Y'\n            if rh < h-1 and m[rh+1][rw] == '.':\n                d.append((rw, rh+1))\n                m[rh+1][rw] = 'Y'\n        a = 0\n        for i in m:\n            a += i.count('Y')\n        print(a)\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\nwhile True :\n    w,h = map(int,input().split())\n    if w==0 and h ==0 :\n        break\n    maze = [input() for _ in range(h)]\n    visited = [[-1]*w for _ in range(h)]\n    for i in range(h):\n        if \"@\"  in  maze[i]:\n            x_f = i\n    for i in range(w):\n        if maze[x_f][i] ==\"@\":\n            y_f = i\n    visited[x_f][y_f] = 1\n    q = queue.Queue()\n    q.put([x_f,y_f])\n    cnt  = 1\n    while  not q.empty():\n        x,y = q.get()\n        for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n            if 0<= x+dx < h and 0<= y+dy < w:\n                if visited[x+dx][y+dy] == -1 and maze[x+dx][y+dy]=='.':\n                    cnt += 1\n                    visited[x+dx][y+dy] = 1\n                    q.put([x+dx,y+dy])\n    print(cnt)\n\n            \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\ncount = 0\ndef dfs(i, j, island):\n    global count\n    #print i, j\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    \n    if i < 0 or i >= len(island) or j < 0 or j >= len(island[0]):\n        return\n\n    if island[i][j] == '#' or island[i][j] == 'x':\n        return\n\n    island[i][j] = 'x'\n    count += 1\n    \n    for d in dxy:\n        dfs(i+d[0], j+d[1], island)\n\ndef solve(w, h, island):\n    s_i = 0\n    s_j = 0\n    for i, row in enumerate(island):\n        for j, s in enumerate(row):\n            if s == '@':\n                s_i = i\n                s_j = j\n                break\n\n    dfs(s_i, s_j, island)\n    print count\n\ndef func():\n    '''\n\n    '''\n    while True:\n        global count\n        wh = map(int, raw_input().split())\n        w = wh[0]\n        h = wh[1]\n        island = []\n        count = 0\n        for i in range(h):\n            row = []\n            line = raw_input()\n            for j in line:\n                row.append(j)\n            island.append(row)\n        \n        # for row in island:\n        #     for j in row:\n        #         print j\n        #     print ''\n\n        solve(w, h, island)\n\n\nfunc()\n    "
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nans = []\nwhile True:\n    w, h = map(int, input().split())\n    if not w and not h:\n        break\n    \n    roadmap = []\n    d = deque()\n    able = [[False for i in range(w)] for j in range(h)]\n    for i in range(h):\n        roadmap.append(input())\n        \n    \n    for i in range(h):\n        for j in range(w):\n            if roadmap[i][j] == '@':\n                able[i][j] = True\n                d.append([i, j])\n\n    \n    while len(d):\n        y, x = d.pop()\n        \n        for course in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\n            tmpy, tmpx = y + course[0], x + course[1]\n            if tmpy < 0 or tmpy >= h or tmpx < 0 or tmpx >= w:\n                continue\n                \n            if not able[tmpy][tmpx] and roadmap[tmpy][tmpx] == '.':\n                able[tmpy][tmpx] = True\n                d.append([tmpy, tmpx])\n\n    a = 0\n    for i in range(h):\n        a += len(list(filter(lambda x:x, able[i])))\n\n    ans.append(a)\n\n[print(i) for i in ans]\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0:\n        break\n    m = []\n    for _ in range(h):\n        m.append(list(input()))\n    visited = [[False] * w for _ in range(h)]\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    answer = 0\n\n\n    def rec(x, y):\n        global answer\n        visited[x][y] = True\n        answer += 1\n        for (dx, dy) in dxy:  # 4方向の移動を試す\n            x2 = x + dx\n            y2 = y + dy\n            if 0 <= x2 < h and 0 <= y2 < w:\n                if m[x2][y2] == '.':\n                    if not visited[x2][y2]:\n                        rec(x2, y2)  # 再帰呼び出し\n\n\n    for i in range(h):\n        for j in range(w):\n            if m[i][j] == '@':\n                rec(i, j)\n                break\n        else:\n            continue\n        break\n    print(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    while 1:\n        w, h = map(int, input().split())\n        if w == 0: break\n        fld = [[] for i in range(h)]\n        for i in range(h):\n            readline = input()\n            for j in range(w):\n                item = readline[j]\n                fld[i].append(item)\n                if item == '@': sy, sx = i, j\n        solve(fld, sy, sx)\n        count = 0\n        for i in range(h):\n            for j in range(w):\n                if fld[i][j] == 'A': count += 1\n        print(count)\n\ndef solve(fld, cy, cx):\n    vy = [1,-1,0,0]\n    vx = [0,0,1,-1]\n    fld[cy][cx] = 'A'\n    for i in range(4):\n        ny = cy + vy[i]\n        nx = cx + vx[i]\n        if ny < 0 or nx < 0 or ny >= len(fld) or nx >= len(fld[0]):continue\n        elif fld[ny][nx] == '.': solve(fld, ny, nx)\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "delta = ((1, 0), (0, 1), (-1, 0), (0, -1))\ndef ds(here, lb, ub, field):\n\tif field[here[1]][here[0]] == \"#\":\n\t\treturn 0\n\tresult = 1\n\tfield[here[1]][here[0]] = \"#\"\n\tfor dx, dy in delta:\n\t\tnext = (here[0]+dx,here[1]+dy)\n\t\tif lb[0] <= next[0] < ub[0] and lb[1] <= next[1] < ub[1]:\n\t\t\tresult += ds(next, lb, ub, field)\n\treturn result\nwhile 1:\n\tW, H = map(int,raw_input().split(\" \"))\n\tif W == H == 0:\n\t\tbreak\n\tfloor = [list(raw_input()) for i in range(H)]\n\tstart = None\n\tfor i in range(H):\n\t\tfor j in range(W):\n\t\t\tif floor[i][j] == \"@\":\n\t\t\t\tstart = (j,i)\n\t\t\t\tbreak\n\t\tif start is not None:\n\t\t\tbreak\n\tprint ds(start,(0,0),(W,H),floor)"
  },
  {
    "language": "Python",
    "code": "def search(M, l, walkable):\n    i, j = (l.pop(0))\n    nexts = []\n    if i !=0:\n        nexts.append((i-1, j))\n    if i != len(M)-1:\n        nexts.append((i+1, j))\n    if j != 0:\n        nexts.append((i, j-1))\n    if j != len(M[0])-1:\n        nexts.append((i, j+1))\n\n    for nex in nexts:\n        x, y = nex\n        if M[x][y] == '.' and not nex in walkable:\n            l.append(nex)\n            walkable.append(nex)\n\ninp = ''\nwhile '0 0' != (inp = input()):\n    i, j = [int(x) for x in inp.split()]\n    M = []\n    l = []\n    for n in range(j):\n        M.append(input())\n        if '@' in M[n]:\n            l.append((n, M[n].find('@')))\n\n    walkable = []\n    while l:\n        search(M, l, walkable)\n    print(len(walkable))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# conding: utf\n\nfrom logging import getLogger, StreamHandler, NullHandler, DEBUG, INFO\nlogger = getLogger(__name__)\n#handler = StreamHandler()\nhandler = NullHandler()\nlogger.setLevel(DEBUG)\nhandler.setLevel(DEBUG)\nlogger.addHandler(handler)\nlogger.propagate = False\n\ng_field = []\ng_count = 0\ng_W = -1\ng_H = -1\n\nOFFSETS = [(1,0), (-1,0), (0,1), (0,-1)]\n\ndef dfs(x, y):\n    global g_field\n    global g_count\n    global g_W\n    global g_H\n\n\n    g_count += 1\n\n    g_field[y][x] = \"-\"\n\n    for dx, dy in OFFSETS:\n        logger.debug(\"diff: {} {}\".format(dx, dy))\n        new_x = x + dx\n        new_y = y + dy\n\n        if new_x < 0 or new_x >= g_W:\n            continue\n        if new_y < 0 or new_y >= g_H:\n            continue\n        new_tile = g_field[new_y][new_x]\n        if new_tile == \"#\" or new_tile == \"-\":\n            continue\n\n        logger.debug(\"{}, {}\".format(new_x, new_y))\n        dfs(new_x, new_y)\n\n\nif __name__ == \"__main__\":\n    while True:\n        g_W, g_H = [int(s) for s in input().strip().split()]\n\n        if g_W == 0 and g_H == 0:\n            break\n        \n        g_field = []\n        for _ in range(g_H):\n            row = list(input().strip())\n            g_field.append(row)\n        g_count = 0\n\n        for y in range(g_H):\n            for x in range(g_W):\n                if g_field[y][x] == \"@\":\n                    start_x = x\n                    start_y = y\n                    break\n\n        dfs(start_x, start_y)\n\n        print(g_count)\n\n"
  },
  {
    "language": "Python",
    "code": "import queue\n\ndef solve(w, h):\n    q = queue.Queue()\n    m = [['#' for i in range(w+2)] for j in range(h+2)]\n    for i in range(h):\n        inp = input()\n        for j in range(w):\n            m[i+1][j+1] = inp[j]\n            if m[i+1][j+1] == '@':\n                start = [i+1,j+1]\n    q.put(start)\n    c = 1\n    while not q.empty():\n        cur = q.get()\n        XY = [(1,0), (-1, 0), (0, 1), (0, -1)]\n        for x, y in XY:\n            cx = cur[0]+x\n            cy = cur[1]+y\n            if m[cx][cy] == '.':\n                m[cx][cy] = '#'\n                q.put([cx, cy])\n                c+=1\n    return c\n\nwhile True:\n    w, h = [int(i) for i in input().split()]\n    if w == 0 and h == 0:\n        break\n    print(solve(w,h))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10000)\n\n\ndef dfs(x, y):\n    global cout\n    if 0 <= x < H - 1 and tile[x + 1][y] == \".\":\n        cout += 1\n        tile[x + 1][y] = \"#\"\n        dfs(x + 1, y)\n    if 0 < x < H and tile[x - 1][y] == \".\":\n        cout += 1\n        tile[x - 1][y] = \"#\"\n        dfs(x - 1, y)\n    if 0 <= y < W - 1 and tile[x][y + 1] == \".\":\n        cout += 1\n        tile[x][y + 1] = \"#\"\n        dfs(x, y + 1)\n    if 0 < y < W and tile[x][y - 1] == \".\":\n        cout += 1\n        tile[x][y - 1] = \"#\"\n        dfs(x, y - 1)\n    return 0\n\n\ndef search_start():\n    for i in range(H):\n        for j in range(W):\n            if tile[i][j] == \"@\":\n                tile[i][j] = \"#\"\n                return (i, j)\n\n\nif __name__ == \"__main__\":\n    while True:\n        W, H = map(int, input().split())\n        if W == 0 and H == 0:\n            break\n        # print(W, H)\n        tile = [list(input()) for _ in range(H)]\n        cout = 1\n        start = search_start()\n        # print(start)\n        dfs(start[0], start[1])\n        # print(*tile, sep=\"\\n\")\n        # print(\"total count : {}\".format(cout))\n        print(cout)\n\n"
  },
  {
    "language": "Python",
    "code": "class dfs:\n    def __init__(self,W,H,m):\n        self.W=W\n        self.H=H\n        self.m=m\n        self.ans=0\n        self.visited=[[False]*W for _ in range(H)]\n    def trav(self,x,y):\n        #print(x,y)\n        self.visited[x][y]=True\n        self.ans+=1\n        offset=[(-1,0),(0,-1),(1,0),(0,1)]\n        for dx,dy in offset:\n            x2=x+dx\n            y2=y+dy\n            if 0<=x2<self.H and 0<=y2<self.W and self.m[x2][y2]=='.' and self.visited[x2][y2]==False:\n                self.trav(x2,y2)\n    \n\nwhile True:\n    W,H=map(int,input().split())\n    if not (W and H): break\n    m=[]\n    for i in range(H):\n        L=list(input())\n        if '@' in L:\n            (sx,sy)=(i,L.index('@'))\n        m.append(L)\n    D=dfs(W,H,m)\n    D.trav(sx,sy)\n    print(D.ans)\n"
  },
  {
    "language": "Python",
    "code": "#演習2-22\ndef solve(w,h,tile):\n    # スタート地点探索\n    ok = False\n    for y in range(h):\n        for x in range(w):\n            if tile[y][x] == \"@\":\n                s_x = x\n                s_y = y\n                ok = True\n                break\n        if ok:\n            break\n    # 幅優先探索\n    count = 0\n    check = [[s_x, s_y]]\n    check_map = [[False for j in range(w)] for i in range(h)]\n    while len(check) > 0:\n        x, y = check.pop(0)\n        if x in range(w) and y in range(h):\n            if check_map[y][x] == False:\n                if tile[y][x] == \".\" or tile[y][x] == \"@\":\n                    check_map[y][x] = True\n                    count += 1\n                    check.append([x, y-1])\n                    check.append([x, y+1])\n                    check.append([x+1, y])\n                    check.append([x-1, y])\n    return count\n\nwhile True:\n    try:\n        w, h = map(int, input().split())\n        if w == 0:\n            break\n        tile = [\"\"] * h\n        for i in range(h):\n            tile[i] = input()\n\n        print(solve(w,h,tile))\n    except:\n        break\n    \n\n\n"
  },
  {
    "language": "Python",
    "code": "delta = ((1, 0), (0, 1), (-1, 0), (0, -1))\ndef ds(here, lb, ub, field):\n\tif field[here[1]][here[0]] == \"#\":\n\t\treturn 0\n\tresult = 1\n\tfield[here[1]][here[0]] = \"#\"\n\tfor dx, dy in delta:\n\t\tnext = (here[0]+dx,here[1]+dy)\n\t\tif lb[0] <= next[0] < ub[0] and lb[1] <= next[1] < ub[1]:\n\t\t\tresult += ds(next, lb, ub, field)\n\treturn result\nwhile 1:\n\tW, H = map(int,raw_input().split(\" \"))\n\tif W == H == 0:\n\t\tbreak\n\tfloor = [list(raw_input()) for i in range(H)]\n\tstart = None\n\tfor i in range(H):\n\t\tfor j in range(W):\n\t\t\tif floor[i][j] == \"@\":\n\t\t\t\tstart = (j,i)\n\t\t\t\tbreak\n\t\tif start is not None:\n\t\t\tbreak\n\tprint ds(start,(0,0),(W,H),floor)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef solve(W, H, field):\n    dire = [(1,0), (0,1), (-1,0), (0,-1)]\n    for i in range(H):\n        for j in range(W):\n            if (field[i][j]==\"@\"):\n                s = (i,j)\n    check = [[0]*W for i in range(H)]\n    q = deque()\n    q.append(s)\n    check[s[0]][s[1]] = 1\n    ret = 1\n    while q:\n        y, x = q.popleft()\n        for dy, dx in dire:\n            if (y+dy<H) and (y+dy>=0) and (x+dx<W) and (x+dx>=0):\n                if (field[y+dy][x+dx] == \".\") and (not check[y+dy][x+dx]):\n                    q.append((y+dy, x+dx))\n                    check[y+dy][x+dx] = 1\n                    ret += 1\n    return ret\n\ndef main():\n    ans = []\n    while True:\n        W, H = list(map(int, input().split()))\n        if (not W) and (not H):\n            break\n        field = [input() for i in range(H)]\n        ans.append(solve(W, H, field))\n    for i in ans:\n        print(i)\n    \nmain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(tiles, w, h, x, y):\n    cnt = 1\n    tiles[y][x] = '@'\n    for dx,dy in ((0,1), (0,-1), (-1,0), (1,0)):\n        if 0<=x+dx<w and 0<=y+dy<h and tiles[y+dy][x+dx]=='.':\n            cnt += dfs(tiles, w, h, x+dx, y+dy)\n    return cnt\n\ndef main():\n    while True:\n        W,H = [int(x) for x in input().split()]\n        if W==0 and H==0:\n            exit()\n        tiles = [[c for c in input()] for h in range(H)]\n        for i in range(H):\n            if '@' in tiles[i]:\n                Y = i\n                X = tiles[i].index('@')\n        answer = dfs(tiles, W, H, X, Y)\n        print(answer)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def floodfill(matrix, x, y):\n    global count\n    #\"hidden\" stop clause - not reinvoking for \"check\" or \"#\", only for \",\" or \"@\".\n    if (matrix[x][y] == \".\") or (matrix[x][y] == \"@\"):\n        count += 1\n        matrix[x][y] = \"check\"\n        #recursively invoke flood fill on all surrounding cells:\n        if x > 0:\n            floodfill(matrix, x - 1, y)\n        if x < len(matrix) - 1:\n            floodfill(matrix, x + 1, y)\n        if y > 0:\n            floodfill(matrix, x, y - 1)\n        if y < len(matrix[0]) - 1:\n            floodfill(matrix, x, y + 1)\n    return count\n\nwhile True:\n    x, y = map(int, input().split())\n    if x == y == 0: break\n    room = []\n    for i in range(y):\n        room.append([i for i in input()])\n\n    for key, list in enumerate(room):\n        if \"@\" in list:\n            ax, ay = key, list.index(\"@\")\n\n    count = 0\n    print(floodfill(room, ax, ay))"
  },
  {
    "language": "Python",
    "code": "def getter(targ,x,y):\n    #print(x,y,len(targ[0]),len(targ))\n    if 0 > x or x >= len(targ) or 0 > y or y >= len(targ[0]) or targ[x][y] == '#':\n        return 0\n    else:\n        targ[x][y] = '#'\n        return 1 + getter(targ,x+1,y) + getter(targ,x-1,y) + getter(targ,x,y+1) + getter(targ,x,y-1)\nwith open(\"input1.txt\") as f:\n    width,height = [int(n) for n in f.readline().split(\" \")]\n    global lab\n    while True:\n        lab,start = [],[]\n        for a in range(height):\n            disp = [n for n in f.readline().rstrip('\\n')]\n            if '@' in disp:\n                start.extend([disp.index('@'),a])\n            lab.append(disp)\n        else:\n            a,b = start\n            print(getter(lab,b,a))\n            width,height = [int(n) for n in f.readline().split(\" \")]\n            if width == 0 and height == 0:\n                break"
  },
  {
    "language": "Python",
    "code": "\ndef get_start(tile, h, w):\n\tfor i in range(w):\n\t\tfor j in range(h):\n\t\t\tif tile[i][j] == '@':\n\t\t\t\treturn (i, j)\n\ndirs = [(-1, 0), (0, -1), (1, 0), (0, 1)]\n\nwhile True:\n\tw, h = map(int, input().split())\n\tif (w,h) == (0,0):\n\t\tbreak\n\ttile = [list(input()) for i in range(h)]\n\tstart = get_start(tile, w, h)\n\tcount = 0\n\tq = [start]\n\twhile q:\n\t\t(x,y) = q.pop()\n\t\tfor d in dirs:\n\t\t\txx = x+d[0]\n\t\t\tyy = y+d[1]\n\t\t\tif (0 <= xx and xx < h) and (0 <= yy and yy < w):\n\t\t\t\tif tile[xx][yy] == '.':\n\t\t\t\t\ttile[xx][yy] = '_'\n\t\t\t\t\tcount += 1\n\t\t\t\t\tq.append((xx,yy))\n\tprint(count+1)\n\t"
  },
  {
    "language": "Python",
    "code": "mx = [0, 1, 0, -1]\nmy = [-1, 0, 1, 0]\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == h == 0:\n        break\n    tiles = [[i for i in input()] for j in range(h)]\n    ax = ay = 0\n    for i in range(h):\n        for j in range(w):\n            if tiles[i][j] == '@':\n                ax, ay = j, i\n    que = [(ax, ay)]\n    tiles[ay][ax] = '#'\n    cnt = 1\n\n    while 0 < len(que):\n        new_que = []\n        for x, y in que:\n            for i in range(4):\n                nx, ny = x + mx[i], y + my[i]\n                print(nx, ny)\n                if 0 <= nx <= w - 1 and 0 <= ny <= h - 1:\n                    if tiles[ny][nx] == '.':\n                        cnt += 1\n                        new_que.append((nx, ny))\n                        tiles[ny][nx] = '#'\n        que = new_que\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while 1:\n        w, h = map(int, sys.stdin.readline().split())\n\n        if w == h == 0:\n            return\n\n        room = [[False]*w for i in range(h)]\n\n        si = sj = -1\n\n        for i in range(h):\n            line = input()\n\n            for j, ch in enumerate(line):\n                if ch == '@':\n                    room[i][j] = True\n                    si = i\n                    sj = j\n                elif ch == '.':\n                    room[i][j] = True\n\n        ans = bfs(w, h, room, si, sj)\n\n        print(ans)\n\ndx = (1, 0, -1, 0,)\ndy = (0, 1, 0, -1,)\n\ndef bfs(w, h, room, si, sj):\n    visited = [[False]*w for i in range(h)]\n    visited[si][sj] = True\n    q = deque([(si, sj)])\n    cnt = 1\n\n    while q:\n        ci, cj = q.popleft()\n\n        for k in range(len(dx)):\n            ni = ci + dy[k]\n            nj = cj + dx[k]\n\n            if 0 <= ni < h and 0 <= nj < w and room[ni][nj] and not visited[ni][nj]:\n                visited[ni][nj] = True\n                q.append((ni, nj))\n                cnt += 1\n\n    return cnt\n\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "data, res = [], 0\n\ndef valid(x, y):\n    global data\n    return 0 <= x < W and 0 <= y < H and data[y][x] != '#'\n\ndef dfs(x, y):\n    global data, res\n    if valid(x, y):\n        res += 1\n        data[y][x] = '#'\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        for i in range(4):\n            dfs(x + dx[i], y + dy[i])\n    else:\n        return\n    \nwhile True:\n    global data, res\n    W, H = map(int, input().split())\n    if not W:\n        break\n    data = [list(input()) for _ in range(H)]\n    res = 0\n    for i in range(W):\n        for j in range(H):\n            if data[j][i] == '@':\n                dfs(i, j)\n                break\n    print(res)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport array\nimport itertools\nimport sys\n\n\nUNDET_POINT = (-1, -1)\n\n\nclass RecursiveDepthFirstSearch(object):\n\n    def __init__(self, width, height, tiles):\n        self.width = width\n        self.height = height\n        self.tiles = tiles\n        self.reached = [array.array(\n            \"B\", (False for j in range(height))) for i in range(width)]\n        self.start_tile = UNDET_POINT\n        for x, y in itertools.product(range(width), range(height)):\n            if tiles[x][y] == \"@\":\n                self.start_tile = (x, y)\n                break\n\n    def search(self, x, y):\n        if x < 0 or self.width <= x or y < 0 or self.height <= y:\n            pass\n        elif self.tiles[x][y] == \"#\":\n            pass\n        elif self.reached[x][y]:\n            pass\n        else:\n            self.reached[x][y] = True\n            self.search(x + 1, y)\n            self.search(x - 1, y)\n            self.search(x, y + 1)\n            self.search(x, y - 1)\n\n    def count_reachable_tiles(self):\n        self.search(*self.start_tile)\n        reachable_tiles = sum([self.reached[x][y] for x, y in itertools.product(\n            range(self.width), range(self.height))])\n        return reachable_tiles\n\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10000)\n    while True:\n        width, height = map(int, input().split())\n        if width == 0 and height == 0:\n            break\n        else:\n            tiles = [x for x in zip(*[input() for y in range(height)])]\n            dfs = RecursiveDepthFirstSearch(width, height, tiles)\n            print(dfs.count_reachable_tiles())"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "def search(M, l, walkable):\n    i, j = (l.pop(0))\n    nexts = []\n    if i !=0:\n        nexts.append((i-1, j))\n    if i != len(M)-1:\n        nexts.append((i+1, j))\n    if j != 0:\n        nexts.append((i, j-1))\n    if j != len(M[0])-1:\n        nexts.append((i, j+1))\n\n    for nex in nexts:\n        x, y = nex\n        if M[x][y] == '.' and not nex in walkable:\n            l.append(nex)\n            walkable.append(nex)\n\ninp = ''\nwhile '0 0' != (inp = input()):\n    i, j = [int(x) for x in inp.split()]\n    M = [input() for k in range(j)]\n    l = []\n    for n in range(j):\n        if '@' in M[n]:\n            l.append((n, M[n].find('@')))\n\n    walkable = []\n    while l:\n        search(M, l, walkable)\n    print(len(walkable)+1)"
  },
  {
    "language": "Python",
    "code": "while True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    # タイルの情報を文字列配列として受け取る\n    tile = [\"\"] * h\n    for i in range(h):\n        tile[i] = input()\n    # スタート地点探索\n    ok = False\n    for y in range(h):\n        for x in range(w):\n            if tile[y][x] == \"@\":\n                s_x = x\n                s_y = y\n                ok = True\n                break\n        if ok:\n            break\n    # 幅優先探索\n    count = 0\n    check = [[s_x, s_y]]\n    check_map = [[False for j in range(w)] for i in range(h)]\n    while len(check) > 0:\n        x, y = check.pop(0)\n        if x in range(w) and y in range(h):\n            if check_map[y][x] == False:\n                if tile[y][x] == \".\" or tile[y][x] == \"@\":\n                    check_map[y][x] = True\n                    count += 1\n                    check.append([x, y-1])\n                    check.append([x, y+1])\n                    check.append([x+1, y])\n                    check.append([x-1, y])\n    print(count)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    W, H = map(int, input().split())\n    room = []\n    for i in range(H):\n        room.append(input())\n    \n    for i in range(H):\n        for j in range(W):\n            if room[i][j] == '@':\n                (sx, sy) = (j, i)\n            \n    dx = (-1, 0, 1, 0)\n    dy = (0, -1, 0, 1)\n    visited = [[False] * W for i in range(H)]\n\n    def rec(x, y):\n        visited[y][x] = True\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < W and 0 <= ny < H and room[ny][nx] == '.':\n                if not visited[ny][nx]:\n                    rec(nx, ny)\n\n    if W == 0 or H == 0:\n        break\n    rec(sx, sy)\n    ans = 0\n    for a in visited:\n        for b in a:\n            if b:\n                ans += 1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\nw, h = map(int,input().split())\nwhile [h, w] != [0, 0]:\n    area = []\n    a = 1\n    for i in range(h):\n        area.append(list(input()))\n        area[i].insert(0,\"#\")\n        area[i].append(\"#\")\n    area.insert(0,[\"#\" for i in range(w + 2)])\n    area.append([\"#\" for i in range(w + 2)])\n\n    que = []\n    for i in range(h):\n        for j in range(1, w + 1):\n            if area[i][j] == \"@\":\n                que.append([i, j])\n                break\n        else:\n            continue\n        break\n    while True:\n        nque = []\n        for i in que:\n            h1 = i[0]\n            w1 = i[1]\n            if area[h1 - 1][w1] == \".\":\n                area[h1 - 1][w1] = \"*\"\n                nque.append([h1 - 1, w1])\n                a += 1\n            if area[h1 + 1][w1] == \".\":\n                area[h1 + 1][w1] = \"*\"\n                nque.append([h1 + 1, w1])\n                a += 1\n            if area[h1][w1 - 1] == \".\":\n                area[h1][w1 - 1] = \"*\"\n                nque.append([h1, w1 - 1])\n                a += 1\n            if area[h1][w1 + 1] == \".\":\n                area[h1][w1 + 1] = \"*\"\n                nque.append([h1, w1 + 1])\n                a += 1\n        if nque == []:\n            break\n        que = copy.deepcopy(nque)\n\n    print(a)\n        \n    w, h = map(int,input().split())\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\ncount = 0\ndef dfs(i, j, island):\n    global count\n    #print i, j\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    \n    if i < 0 or i >= len(island) or j < 0 or j >= len(island[0]):\n        return\n\n    if island[i][j] == '#' or island[i][j] == 'x':\n        return\n\n    island[i][j] = 'x'\n    count += 1\n    \n    for d in dxy:\n        dfs(i+d[0], j+d[1], island)\n\ndef solve(w, h, island):\n    s_i = 0\n    s_j = 0\n    for i, row in enumerate(island):\n        for j, s in enumerate(row):\n            if s == '@':\n                s_i = i\n                s_j = j\n                break\n\n    dfs(s_i, s_j, island)\n    print count\n\ndef func():\n    '''\n\n    '''\n    while True:\n        global count\n        wh = map(int, raw_input().split())\n        w = wh[0]\n        h = wh[1]\n        if w == 0 and h == 0:\n            break\n        island = []\n        count = 0\n        for i in range(h):\n            row = []\n            line = raw_input()\n            for j in line:\n                row.append(j)\n            island.append(row)\n        \n        # for row in island:\n        #     for j in row:\n        #         print j\n        #     print ''\n\n        solve(w, h, island)\n\n\nfunc()\n    "
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nimport sys\n\ndef dfs(rw,cm):\n    global flag\n    flag[rw][cm] = 1\n    if 0 <= rw - 1 and mp[rw-1][cm] == '.' and flag[rw-1][cm] == 0:\n        dfs(rw-1,cm)\n    if cm + 1 < m and mp[rw][cm+1] == '.' and flag[rw][cm+1] == 0:\n        dfs(rw,cm+1)\n    if 0 <= cm - 1 and mp[rw][cm-1] == '.' and flag[rw][cm-1] == 0:\n        dfs(rw,cm-1)\n    if rw + 1 < n and mp[rw+1][cm] == '.' and flag[rw+1][cm] == 0:\n        dfs(rw+1,cm)\n\nif __name__ == '__main__':\n    while 1:\n        m,n = map(int,input().split())\n        if m == 0 and n == 0:\n            break\n        mp = []\n        for i in range(n):\n            mp.append(list(input()))\n            if '@' in mp[-1]:\n                stj = mp[-1].index('@')\n                sti = i\n        flag = [[0 for i in range(m)] for j in range(n)]\n        dfs(sti,stj)\n        print(sum(flag[i].count(1) for i in range(n)))"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input()split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn\n\t\tif m[cy][cx] = '.'v or  m[cy][cx] = '@'\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "count = 0\nrole = {\".\": True, \"@\": False, \"#\": False}\ndef now(xpoint, ypoint):\n    return role[room[ypoint][xpoint]]\n\ndef search(xpoint, ypoint):\n    global count\n    if 0 <= xpoint < wh[0] and 0 <= ypoint < wh[1] and now(xpoint, ypoint):\n        count += 1\n        room[ypoint][xpoint] = \"@\"\n        search(xpoint - 1, ypoint)\n        search(xpoint + 1, ypoint)\n        search(xpoint, ypoint + 1)\n        search(xpoint, ypoint - 1)\n\nwhile True:\n    wh = map(int, raw_input().split())\n    room = []\n    count = 0\n    for ypoint in range(wh[1]):\n        line = raw_input().replace(\"\\n\", \"\")\n        if \"@\" in line:\n            xp = line.index(\"@\")\n            yp = ypoint\n        room.append([x for x in line])\n    if not room: break\n    room[yp][xp] = \".\"\n    search(xp, yp)\n    print count"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\n所要時間は、分位であった。\n'''\n\n\n# ライブラリのインポート\n#import re #正規表現\nimport sys\ninput = sys.stdin.readline\n#import heapq\n#import bisect\n#import collections\n#import math\n#from pprint import pprint\n\ndef main():\n    while 1:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0: break\n        mp = []\n        for i in range(h):\n            mp.append(list(input().strip()))\n            if \"@\" in mp[-1]:\n                stj = mp[-1].index(\"@\")\n                sti = i\n        flag = [[0]*w for i in range(h)]\n        #pprint(flag)\n        flag = dfs(sti, stj, flag, mp)\n        ans = sum([flag[i].count(1) for i in range(h)])\n        print(ans)\n        #pprint(flag)\ndef dfs(rw, cm, flag, mp):\n    flag[rw][cm] = 1\n    #print(rw,cm)\n    #pprint(flag)\n    try:\n        c = mp[rw][cm-1]\n        b = flag[rw][cm-1]\n    except: c = \"#\"\n    if c == \".\" and b == 0 and rw>=0 and cm>0: dfs(rw, cm-1, flag, mp)\n    try:\n        c = mp[rw-1][cm]\n        b = flag[rw-1][cm]\n    except: c = \"#\"\n    if c == \".\" and b == 0 and rw>0 and cm>=0: dfs(rw-1, cm, flag, mp)\n    try: \n        c = mp[rw][cm+1]\n        b = flag[rw][cm+1]\n    except: c = \"#\"\n    if c == \".\" and b == 0: dfs(rw, cm+1, flag, mp)\n    try: \n        c = mp[rw+1][cm]\n        b = flag[rw+1][cm]\n    except: c = \"#\"\n    if c == \".\" and b == 0: dfs(rw+1, cm, flag, mp)\n    return flag\n\n\n    \n\n\n    \nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def check(x, y, count):\n\tarray[x][y] = \"$\"\n\tcount += 1\n\tif array[x + 1][y] == \".\" : count = check(x + 1, y, count)\n\tif array[x - 1][y] == \".\" : count = check(x - 1, y, count)\n\tif array[x][y + 1] == \".\" : count = check(x, y + 1, count)\n\tif array[x][y - 1] == \".\" : count = check(x, y - 1, count)\n\treturn count\n\nwhile True:\n\th,w = map(int, raw_input().split())\n\tif h == 0 and w == 0 : break\n\n\tarray = []\n\tarray.append(list(\"$\" * (h + 2)))\n\tfor i in range(0, w) : array.append(list(\"$\" + raw_input() + \"$\"))\n\tarray.append(list(\"$\" * (h + 2)))\n\t\n\tx = 1\n\ty = 1\n\tfor i in range(1, w + 1):\n\t\tif \"@\" in array[i]:\n\t\t\tx = i\n\t\t\ty = array[i].index(\"@\")\n\t\n\tprint check(x, y, 0)"
  },
  {
    "language": "Python",
    "code": "I=input\ndef f(x,y,r):\n    if not(0<=x<len(r[0])and(0<=y<len(r)))or r[y][x]=='#':return 0\n    r[y][x]='#'\n    return 1+sum(f(x+dx,y+dy,r)for dx,dy in[[-1,0],[1,0],[0,-1],[0,1]])\nwhile 1:\n    w,h=map(int,I().split())\n    if w==0:break\n    r=[list(input()) for _ in[0]*h]\n    for a,b in enumerate(r):\n        if '@'in b:y=a;x=b.index('@');break\n    print(f(x,y,r))"
  },
  {
    "language": "Python",
    "code": "#data????§???????[y???][x???]??§??????\n\nif __name__ == \"__main__\":\n    while 1:\n        w,h = list(map(int,input().strip().split()))\n        if w == h == 0:break\n        data = []\n        data = []\n        for _ in range(h):data.append(list(input()))\n        visited = []\n        position =(0,0)\n        for i in range(h):\n            if '@'in data[i]:position = (i,data[i].index('@'))\n        stack = []\n        count = 0\n        stack.append(position)\n        while len(stack) !=0:\n            position = stack.pop()\n            count +=1\n            if position[0] -1 >= 0 and not (position[0]-1,position[1])in visited and data[position[0] -1][position[1]] == '.':\n                visited.append((position[0] -1,position[1]))\n                stack.append((position[0] -1,position[1]))\n            if position[1] -1 >= 0 and not (position[0],position[1]-1)in visited and data[position[0]][position[1]-1] == '.':\n                visited.append((position[0],position[1]-1))\n                stack.append((position[0],position[1]-1))\n            if position[0] +1 < h and not (position[0]+1,position[1])in visited and data[position[0] +1][position[1]] == '.':\n                visited.append((position[0]+1,position[1]))\n                stack.append((position[0]+1,position[1]))\n            if position[1] + 1 < w and not (position[0],position[1]+1)in visited and data[position[0]][position[1] +1] == '.':\n                visited.append((position[0],position[1] +1))\n                stack.append((position[0],position[1]+1))\n\n        print(count)"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tx,y = list(map(int,input().split()))\n\tif x == 0:\n\t\tbreak\n\n\tpp = [1,-1,0,0]\n\tqq = [0,0,1,-1]\n\tm = []\n\tfor i in range(y):\n\t\tm.append(list(input()))\n\t\tif '@' in m[-1]:\n\t\t\tss = m[-1].index('@')\n\t\t\ttt = i\n\tcnt = 0\n\n\tdef move (cx,cy):\n\t\tglobal cnt\n\t\tif cy >= y or cy < 0 or cx >= x or cx < 0:\n\t\t\treturn\n\t\tif m[cy][cx] == '.' or  m[cy][cx] == '@'\n\t\t\tcnt += 1\n\t\t\tm[cy][cx] = '0'\n\t\t\tfor i in range(4):\n\t\t\t\tmove(cx + pp[i],cy + qq[i])\n\tmove(ss,tt)\n\tprint(cnt)\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef rec(x, y, used, TILE):\n    if not(0<=x<W) or not(0<=y<H):\n        return\n    elif used[y][x]==1 or TILE[y][x]=='#':\n        return\n    else:\n        used[y][x] = 1\n        rec(x-1, y, used, TILE)\n        rec(x+1, y, used, TILE)\n        rec(x, y-1, used, TILE)\n        rec(x, y+1, used, TILE)\n\n(W, H) = map(int, raw_input().split())\nwhile W!=0:\n    used = [[0]*W for i in range(H)]\n    TILE = []\n    s = []\n    for i in range(H):\n        TILE.append(raw_input())\n    for i in range(H):\n        for j in range(W):\n            if TILE[i][j] == '@':\n                s = [i, j]\n\n    #print s[0], s[1]\n    #print used\n    #print TILE\n    rec(s[1], s[0], used, TILE)\n    Sum = 0\n    for i in range(H):\n        Sum += used[i].count(1)\n    print Sum\n    #print used.count(1)\n\n    (W, H) = map(int, raw_input().split())"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\n\nwhile True:\n    q = Queue()\n    w, h = map(int, raw_input().split())\n    tile = [[0 for i in range(w)] for j in range(h)]\n    if w == 0: break\n    for i in range(h):\n        tile[i] = raw_input()\n        for j in range(w):\n            if tile[i][j] == '@':\n                q.put([i,j])\n    #searching\n    count = 0\n    while q.empty() == False:\n        node = q.get()\n        y = node[0]\n        x = node[1]\n        count += 1\n        for i,j in zip([1,-1,0,0],[0,0,1,-1]):\n            if (0 <= y+i < h and 0 <= x+j < w) == False: continue\n            if tile[y+i][x+j] == '.':\n                tilist = list(tile[y+i])\n                tilist[x+j] = '@'\n                tile[y+i] = \"\".join(tilist)\n                q.put([y+i,x+j])\n    print count"
  },
  {
    "language": "Python",
    "code": "#coding: utf-8\n\ndef Is_black(coo):\n    a = coo[0]\n    b = coo[1]\n    if 0 <= a < l[1] and 0 <= b < l[0] and \\\n    map_list[a][b] == '.':\n        return True\n    else:\n        return False\n\nwhile True:\n    l = map(int, raw_input().split())\n    if l == [0, 0]:\n        break\n    else:\n        map_list = []\n        for i in range(l[1]):\n            row = str(raw_input())\n            if '@' in row:\n                fp = (i, row.find('@'))\n            map_list.append(row)\n        stack = [fp]\n        arrived = [fp]\n        while stack:\n            coo = stack.pop()\n            coo_a = (coo[0], coo[1] + 1)\n            coo_b = (coo[0], coo[1] - 1)\n            coo_c = (coo[0] + 1, coo[1])\n            coo_d = (coo[0] - 1, coo[1])\n            coo_l = [coo_a, coo_b, coo_c, coo_d]\n            for c in coo_l:\n                if Is_black(c) and c not in arrived:\n                    stack.append(c)\n                    arrived.append(c)\n        print len(arrived)"
  },
  {
    "language": "Python",
    "code": "def search(x, y, m):\n    if x < 0 or y < 0 \\\n            or x >= len(m[0]) or y >= len(m):\n        return 0\n    if m[y][x] == '#':\n        return 0\n    m[y][x] = '#'\n    return 1 + search(x+1,y, m) + search(x-1,y,m) \\\n            + search(x,y+1,m) + search(x,y-1,m)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0: break\n    room = []\n    for i in range(h):\n        tmp = list(input())\n        room.append(tmp[:w])\n        if '@' in tmp:\n            y = i\n            x = tmp.index('@') \n    print(search(x, y, room))"
  },
  {
    "language": "Python",
    "code": "mv=((0,1),(0,-1),(1,0),(-1,0))\n\ndef dfs(y,x):\n    global cnt\n    L[y][x]=\"\"\n    cnt+=1\n    for i,j in mv:\n        mx=x+i\n        my=y+j\n        if 0<=mx<W and 0<=my<H and L[my][mx]==\".\":\n            dfs(my,mx)\n\nwhile True:\n    W,H=map(int,raw_input().split())\n    if W==H==0:break\n    cnt=0\n    L=[list(raw_input()) for i in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if L[i][j]==\"@\":\n                x,y=j,i\n    dfs(y,x)\n    print cnt"
  },
  {
    "language": "Python",
    "code": "import collections\nwhile True:\n    w,h = map(int,input().split())\n    if w == h == 0:\n        break\n    else:\n        ans = 1\n        L = []\n        q = collections.deque()\n        for i in range(h):\n            s = input()\n            T = []\n            for j in range(w):\n                if s[j] == '@':\n                    T.append(0)\n                    q.append([i,j])\n                else:\n                    T.append(s[j])\n            L.append(T)\n        dy_dx = [[1,0],[0,1],[-1,0],[0,-1]]\n        while len(q) > 0:\n            cur = q.popleft()\n            for i in range(4):\n                y = cur[0]+dy_dx[i][0]\n                x = cur[1]+dy_dx[i][1]\n                if 0 <= x < w and 0 <= y < h:\n                    if L[y][x] == '.':\n                        L[y][x] = L[cur[0]][cur[1]]+1\n                        ans += 1\n                        q.append([y,x])\n        print(ans)\n            \n"
  },
  {
    "language": "Python",
    "code": "def fill(y,x):\n    global l,c,w,h\n    if 0<=x+1<w and 0<=y<h and l[y][x+1]==\".\":\n        c+=1\n        l[y][x+1]=1\n        fill(y,x+1)\n    if 0<=x-1<w and 0<=y<h and l[y][x-1]==\".\":\n        c+=1\n        l[y][x-1]=1\n        fill(y,x-1)\n    if 0<=x<w and 0<=y+1<h and l[y+1][x]==\".\":\n        c+=1\n        l[y+1][x]=1\n        fill(y+1,x)\n    if 0<=x<w and 0<=y-1<h and l[y-1][x]==\".\":\n        c+=1\n        l[y-1][x]=1\n        fill(y-1,x)\n    return c\n\nwhile 1:\n    w,h=map(int,input().split())\n    if not w and not h:break\n    l=[list(input()) for _ in range(h)]\n    y,x=[[n,i.index(\"@\")] for (n,i) in enumerate(l) if \"@\" in i][0]\n    l[y][x]=1\n    c=1\n    print(fill(y,x))\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(w,h,tile):\n    # スタート地点探索\n    ok = False\n    for y in range(h):\n        for x in range(w):\n            if tile[y][x] == \"@\":\n                s_x = x\n                s_y = y\n                ok = True\n                break\n        if ok:\n            break\n    # 幅優先探索\n    count = 0\n    check = [[s_x, s_y]]\n    check_map = [[False for j in range(w)] for i in range(h)]\n    while len(check) > 0:\n        x, y = check.pop(0)\n        if x in range(w) and y in range(h):\n            if check_map[y][x] == False:\n                if tile[y][x] == \".\" or tile[y][x] == \"@\":\n                    check_map[y][x] = True\n                    count += 1\n                    check.append([x, y-1])\n                    check.append([x, y+1])\n                    check.append([x+1, y])\n                    check.append([x-1, y])\n    return count\n\nwhile True:\n    try:\n        w, h = map(int, input().split())\n        if w == 0:\n            break\n        tile = [\"\"] * h\n        for i in range(h):\n            tile[i] = input()\n\n        print(solve(w,h,tile))\n    except:\n        break\n"
  },
  {
    "language": "Python",
    "code": "def getter(targ,x,y):\n    #print(x,y,len(targ[0]),len(targ))\n    if 0 > x or x >= len(targ) or 0 > y or y >= len(targ[0]) or targ[x][y] == '#':\n        return 0\n    else:\n        targ[x][y] = '#'\n        return 1 + getter(targ,x+1,y) + getter(targ,x-1,y) + getter(targ,x,y+1) + getter(targ,x,y-1)\nwidth,height = [int(n) for n in input().split(\" \")]\nglobal lab\nwhile True:\n    lab,start = [],[]\n    for a in range(height):\n        disp = [n for n in input().rstrip('\\n')]\n        if '@' in disp:\n            start.extend([disp.index('@'),a])\n        lab.append(disp)\n    else:\n        a,b = start\n        print(getter(lab,b,a))\n        width,height = [int(n) for n in input().split(\" \")]\n        if width == 0 and height == 0:\n            break"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n#rea and blac\nh,w=1,1\n\ncount=0\n\ndef search(x,y):\n    #マップの外側か壁の場合は何もしない\n    #print(x,y)\n    global count\n    if x<0 or x>w-1 or y<0 or y>h-1 or map_data[y][x]=='#':\n \n        return\n        \n    \n    #以前に到達していたら何もしない\n    if reached[y][x]:\n         return\n\n    reached[y][x]=1\n    count+=1\n    #print(\"aa\")\n\n\n\n    search(x+1,y)#右\n    search(x-1,y)#左\n    search(x,y+1)#上\n    search(x,y-1)#下\n    \n\n\n\nwhile h!=0 and w!=0: \n\n    count=0\n    #グラフの入力方法------\n\n    w,h=map(int ,raw_input().split())\n    if h==0 and w==0:\n        break\n\n    map_data = [[0]*w for _ in range(h)]\n    reached = [[0]*w for _ in range(h)]\n    for i in range(h):\n        ct = raw_input()\n        #print(len(ct))\n        for j in range(w):\n            map_data[i][j] = ct[j]\n            if ct[j]==\"@\":\n                sx=j\n                sy=i\n\n    #------\n\n\n\n    search(sx,sy)\n\n    print(count)\n    count=0\n    w=1\n    h=1\n\n"
  },
  {
    "language": "Python",
    "code": "dxy = [[1,0],[-1,0],[0,1],[0,-1]]\nn=0\ndef rec(x,y):\n    global n\n    if (x<0 or x>=h or y<0 or y>=w) or (visited[x][y] or tile[x][y]!='.'):\n        return 0\n    visited[x][y] = True\n    n += 1\n    for (dx,dy) in dxy:\n        x2 = x + dx\n        y2 = y + dy\n        rec(x2,y2)\n    return 0\n\nw,h=map(int,input().split())\nans = []\nwhile((w,h)!=(0,0)):\n    n=0\n    tile = []\n    for _ in range(h):\n        tile.append(list(input()))\n    visited = [[False] * w for _ in range(h)]\n    for a in range(h):\n        for b in range(w):\n            if(tile[a][b]=='@'):\n                pos_x = a\n                pos_y = b\n                tile[a][b]='.'\n    rec(pos_x, pos_y)\n    ans.append(n)\n    w,h=map(int,input().split())\nfor a in ans:\n    print(a)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\ncount = 0\ndef dfs(i, j, island):\n    global count\n    print i, j\n    dxy = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    \n    if i < 0 or i >= len(island) or j < 0 or j >= len(island[0]):\n        return\n\n    if island[i][j] == '#' or island[i][j] == 'x':\n        return\n\n    island[i][j] = 'x'\n    count += 1\n    \n    for d in dxy:\n        dfs(i+d[0], j+d[1], island)\n\ndef solve(w, h, island):\n    s_i = 0\n    s_j = 0\n    for i, row in enumerate(island):\n        for j, s in enumerate(row):\n            if s == '@':\n                s_i = i\n                s_j = j\n                break\n\n    dfs(s_i, s_j, island)\n    print count\n\ndef func():\n    '''\n\n    '''\n    while True:\n        global count\n        wh = map(int, raw_input().split())\n        w = wh[0]\n        h = wh[1]\n        island = []\n        count = 0\n        for i in range(h):\n            row = []\n            line = raw_input()\n            for j in line:\n                row.append(j)\n            island.append(row)\n        \n        for row in island:\n            for j in row:\n                print j\n            print ''\n\n        solve(w, h, island)\n    return None\n\n\nfunc()\n    "
  },
  {
    "language": "Python",
    "code": "def dfs(graph, sx, sy):\n    stack = [[sx, sy]]\n    visited = []\n    cnt = 0\n    while stack:\n        label = stack.pop(0)\n        try:\n            g = graph[label[1]][label[0]]\n            if (label[0] < 0) or (label[0] > graph[0].__len__() - 1):\n                continue\n            if (label[1] < 0) or (label[1] >graph.__len__() - 1):\n                continue\n            if g == '#':\n                continue\n            if [label[0], label[1]] not in visited:\n                # graph[label[1], label[0]] = '#'\n                cnt += 1\n                visited = [[label[0], label[1]]] + visited\n                stack = [[label[0]+1, label[1]], [label[0]-1, label[1]], [label[0], label[1]+1], [label[0], label[1]-1]] + stack\n        except IndexError:\n            pass\n    return cnt\n\n\nif __name__ == '__main__':\n    STR = []\n    W, H = [int(i) for i in input().split()]\n    while W != 0:\n        for j in range(H):\n            STR.append(list(input()))\n            if '@' in STR[j]:\n                sx, sy = STR[j].index('@'), j\n        print(dfs(STR, sx, sy))\n        STR = []\n        W, H = [int(i) for i in input().split()]"
  },
  {
    "language": "Python",
    "code": "def search(here, lb, ub, field):\n\tcount = 0\n\tif field[here[1]][here[0]] :\n\t\tcount += 1\n\t\tfield[here[1]][here[0]] = 0\n\t\tif lb[0] < here[0] :\n\t\t\tcount += search((here[0]-1, here[1]), lb, ub, field) \n\t\tif lb[1] < here[1] :\n\t\t\tcount += search((here[0], here[1]-1), lb, ub, field)\n\t\tif ub[0] > here[0] :\n\t\t\tcount += search((here[0]+1, here[1]), lb, ub, field)\n\t\tif ub[1] > here[1] :\n\t\t\tcount += search((here[0], here[1]+1), lb, ub, field) \n\treturn count\n\nwhile 1:\n\tw, h = map(int, raw_input().split(\" \"))\n\tif (w,h) == (0,0): \n\t\tbreak\n\tfield = [[1 for i in range(w)] for j in range(h)]\n\tfor y in range(h):\n\t\ttiles = raw_input()\n\t\tfor x in range(w):\n\t\t\tif tiles[x] == \"#\":\n\t\t\t\tfield[y][x] = 0\n\t\t\telif tiles[x] == \"@\":\n\t\t\t\there = (x,y)\n\tprint search(here, (0,0), (w-1,h-1), field)"
  },
  {
    "language": "Python",
    "code": "#data????§???????[y???][x???]??§??????\n\nif __name__ == \"__main__\":\n    while 1:\n        w,h = list(map(int,input().strip().split()))\n        if w == h == 0:break\n        data = []\n        data = []\n        for _ in range(h):data.append(list(input()))\n        visited = []\n        for i in range(h):\n            if '@'in data[i]:stack= [(i,data[i].index('@'))]\n        count = 0\n        while len(stack) !=0:\n            y,x= stack.pop()\n            count +=1\n            if y-1 >= 0 and not (y-1,x)in visited and data[y -1][x] == '.':\n                visited.append((y-1,x))\n                stack.append((y-1,x))\n            if x -1 >= 0 and not (y,x-1)in visited and data[y][x-1] == '.':\n                visited.append((y,x-1))\n                stack.append((y,x-1))\n            if y +1 < h and not (y+1,x)in visited and data[y +1][x] == '.':\n                visited.append((y+1,x))\n                stack.append((y+1,x))\n            if x + 1 < w and not (y,x+1)in visited and data[y][x +1] == '.':\n                visited.append((y,x+1))\n                stack.append((y,x+1))\n\n        print(count)"
  },
  {
    "language": "Python",
    "code": "h=0\nw=0\n\nwhile 1:\n    w,h=map(int,input().split())\n    if h==0 and w==0:\n        break\n    grid=[]\n    sx=-1\n    sy=-1\n    ans=1\n    used=[[0]*w for i in range(h)]\n    def valid(i,j):\n        return i>=0 and j>=0 and i<h and j<w and grid[i][j]=='.' and not used[i][j]\n    for i in range(h):\n        row=input()\n        grid.append(row)\n        for j in range(w):\n            if row[j]=='@':\n                sx=i\n                sy=j\n    stk=[(sx,sy)]\n    while stk:\n        x=stk[-1][0]\n        y=stk[-1][1]\n        stk.pop()\n        for d in [(1,0),(0,1),(-1,0),(0,-1)]:\n            xx=x+d[0]\n            yy=y+d[1]\n            if valid(xx,yy):\n                stk.append((xx,yy))\n                used[xx][yy]=1\n                ans+=1\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "\n\ndef search(a,b,dx,dy,t,check,li,answer):\n    for i in range(len(dx)):\n            temp = [t[0]+dx[i],t[1]+dy[i]]\n            if mapCheck(a,b,temp):\n                if check[temp[1]][temp[0]] == 0:\n                    if li[temp[1]][temp[0]] == '.':\n                        answer += 1\n                        check[temp[1]][temp[0]] = 1\n                        answer = search(a,b,dx,dy,temp,check,li,answer)\n    return answer\n                    \n                \n            \ndef mapCheck(a,b,t):\n    if t[0] <= a-1 and t[0] >=0:\n        if t[1] <= b-1 and t[1] >= 0:\n            return True\n    return False\n\nwhile True:\n    li = []\n    answer = 1\n    start = [0,0]\n    a,b = map(int, input().strip().split(' '))\n    dx = [1,0,-1,0]\n    dy = [0,1,0,-1]\n    if a == 0 and b == 0:\n        break\n    for i in range(b):\n        li.append(input().strip().split())\n    check = [[0 for i in range(a)] for j in range(b)]\n    for i in range(len(li)):\n        li[i] = str(li[i])\n        li[i] = list(li[i])\n        del li[i][0]\n        del li[i][0]\n        del li[i][len(li[i])-1]\n        del li[i][len(li[i])-1]\n        for j in range(len(li[i])):\n            if li[i][j] == '@':\n                start = [j,i]\n    print(search(a,b,dx,dy,start,check,li,answer))\n                \n                \n        \n\n\n        \n        \n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\nDy = (-1,0,1,0)\nDx = (0,1,0,-1)\n\nfrom collections import deque,defaultdict,Counter\ndef solve(H,W):\n    grid = [input() for _ in range(H)]\n    cnt = [[0]*W for _ in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '@':\n                sy,sx = i,j\n                break\n    \n    q = deque([(sy,sx)])\n    cnt[sy][sx] = 1\n    ans = 1\n    while q:\n        ny,nx = q.popleft()\n        for dy,dx in zip(Dy,Dx):\n            y = ny + dy\n            x = nx + dx\n            if y < 0 or y >= H:\n                continue\n            if x < 0 or x >= W:\n                continue\n            if grid[y][x] == '#':\n                continue\n            if cnt[y][x] == 1:\n                continue\n            cnt[y][x] = 1\n            ans += 1\n            q.append((y,x))\n    print(ans)\n    \ndef main():\n    while True:\n        W,H = map(int,input().split())\n        if H == 0 and W == 0:\n            return\n        solve(H,W)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def dfs(now,origin,drawn): # 深さ優先探索　再帰関数　originは変更しない　drawnは訪れた場所に1それ以外は0\n    positive = '.' # 進める場所\n    negative = '#' # 進めない場所(壁)\n    direct = [0,0,0,0] # [上,下,左,右]を表す\n    height = len(origin)\n    width = len(origin[0])\n    now_h = now[0]\n    now_w = now[1]\n    ### それぞれの方向について、originにおいてpositiveかつdrawnにおいて0（つまり訪れたことがある）なら進める\n    if now_h != 0 and origin[now_h-1][now_w] == positive and drawn[now_h-1][now_w] == 0:\n        direct[0] = 1\n    if now_h != height-1 and origin[now_h+1][now_w] == positive and drawn[now_h+1][now_w] == 0:\n        direct[1] = 1\n    if now_w != 0 and origin[now_h][now_w-1] == positive and drawn[now_h][now_w-1] == 0:\n        direct[2] = 1\n    if now_w != width-1 and origin[now_h][now_w+1] == positive and drawn[now_h][now_w+1] == 0:\n        direct[3] = 1\n\n    if sum(direct) == 0: # 進む先がなければ終了\n        return 0\n    d = {0:[now_h-1,now_w],1:[now_h+1,now_w],2:[now_h,now_w-1],3:[now_h,now_w+1]} # 進む先の座標を辞書にしておく\n    for i in range(4):\n        if direct[i] == 1:\n            drawn[d[i][0]][d[i][1]] = 1 # d[i]の座標に移動したのでdrawnで訪れたことを記録した\n            dfs(d[i],origin,drawn) # 再帰\n    return 0\n\nwhile True:\n    W, H = map(int,input().split()) # 入力を受け取る\n    if W == 0 and H == 0: # 両方0だったらbreak\n        break\n    tiles = [list(input()) for i in range(H)] # 入力\n    possible_tiles = [[0 for i in range(W)] for j in range(H)] # 訪れたことがある場所を記憶する\n    for h in range(H):\n        for w in range(W):\n            if tiles[h][w] == '@': # 現在地\n                now = [h,w]\n                break\n    possible_tiles[now[0]][now[1]] = 1 # 現在地は既に訪れている\n    dfs(now,tiles,possible_tiles) # 探索\n    ans = 0\n    for h in range(H):\n        for w in range(W):\n            if possible_tiles[h][w] == 1:\n                ans += 1\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def Check(A, i, j, W, H) :\n    if j-1 >= 0 :\n        if A[i][j-1] == \".\" :\n            A[i][j-1] = \"+\"\n            Check(A, i, j-1, W, H)\n    if i+1 < H :\n        if A[i+1][j] == \".\" :\n            A[i+1][j]= \"+\"\n            Check(A, i+1, j, W, H)\n    if j+1 < W :\n        if A[i][j+1] == \".\" :\n            A[i][j+1] = \"+\"\n            Check(A, i, j+1, W, H)\n    if i-1 >= 0 :\n        if A[i-1][j] == \".\" :\n            A[i-1][j] = \"+\"\n            Check(A, i-1, j, W, H)\n    return(A)\n\nwhile True :\n    W, H = map(int, input().split())\n    if W == 0 and H == 0 :\n        break\n    \n    Tile = [list(input()) for i in range(H)]\n    for i in range(H) :\n        for j in range(W) :\n            if Tile[i][j] == \"@\" :\n                my_i = i\n                my_j = j\n    Tile[my_i][my_j] = \"+\"\n    Tile_new = Check(Tile, my_i, my_j, W, H)\n    count = 0\n    for i in range(H) :\n        for j in range(W) :\n            if Tile_new[i][j] == \"+\" :\n                count += 1\n    print(count)\n"
  },
  {
    "language": "Python",
    "code": "re = open(\"input\")\ncount = 0\nrole = {\".\": True, \"@\": False, \"#\": False}\ndef now(xpoint, ypoint):\n    return role[room[ypoint][xpoint]]\n\ndef search(xpoint, ypoint):\n    global count\n    if 0 <= xpoint < wh[0] and 0 <= ypoint < wh[1] and now(xpoint, ypoint):\n        count += 1\n        room[ypoint][xpoint] = \"@\"\n        search(xpoint - 1, ypoint)\n        search(xpoint + 1, ypoint)\n        search(xpoint, ypoint + 1)\n        search(xpoint, ypoint - 1)\n\nwhile True:\n    wh = map(int, re.readline().split())\n    room = []\n    count = 0\n    for ypoint in range(wh[1]):\n        line = re.readline().replace(\"\\n\", \"\")\n        if \"@\" in line:\n            xp = line.index(\"@\")\n            yp = ypoint\n        room.append([x for x in line])\n    if not room: break\n    room[yp][xp] = \".\"\n    search(xp, yp)\n    print count"
  },
  {
    "language": "Python",
    "code": "def search(M, l, walkable):\n    i, j = (l.pop(0))\n    nexts = []\n    if i !=0:\n        nexts.append((i-1, j))\n    if i != len(M)-1:\n        nexts.append((i+1, j))\n    if j != 0:\n        nexts.append((i, j-1))\n    if j != len(M[0])-1:\n        nexts.append((i, j+1))\n\n    for nex in nexts:\n        x, y = nex\n        if M[x][y] == '.' and not nex in walkable:\n            l.append(nex)\n            walkable.append(nex)\n\ninp = ''\nwhile '0 0' != (inp = input()):\n    i, j = [int(x) for x in inp.split()]\n    M = [input() for i in range(j)]\n    l = []\n    for n in len(M):\n        if '@' in M[n]:\n            l.append((n, M[n].find('@')))\n\n    walkable = []\n    while l:\n        search(M, l, walkable)\n    print(len(walkable)+1)"
  },
  {
    "language": "Python",
    "code": "def solve(w,h):\n\tif 0 <= w < W and 0 <= h < H and tile[h][w] == \".\":\n\t\ttile[h][w] = 0\n\t\tsolve(w+1,h); solve(w,h+1); solve(w-1,h); solve(w,h-1)\nwhile 1:\n\tW,H = map(int,raw_input().split())\n\tif W == 0: break\n\ttile = [list(raw_input()) for i in range(H)]\n\tfor h in range(H):\n\t\ttry:\n\t\t\tsw = tile[h].index(\"@\")\n\t\t\tsh = h\n\t\t\ttile[sh][sw] = \".\"\n\t\t\tbreak\n\t\texcept:\n\t\t\tpass\n\tsolve(sw,sh)\n\tprint sum(tile[h].count(0) for h in range(H))"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tw,h = map(int, raw_input().split())\n\tif w == h == 0:\n\t\tbreak\n\tcount = 0\n\tcnt = 1\n\tlst = [list(raw_input()) for i in range(h)]\n\tqueue = []\n\tfor i in range(h):\n\t\tif \"@\" in lst[i]:\n\t\t\twNow, hNow = lst[i].index(\"@\"),i\n\tqueue.append([hNow, wNow])\n\twhile 1:\n\t\thNow,wNow = queue[0][0],queue[0][1]\n\t\tqueue.pop(0)\n\t\tif hNow < h-1:\n\t\t\tif lst[hNow+1][wNow] == \".\":\n\t\t\t\tqueue.append([hNow+1,wNow])\n\t\t\t\tlst[hNow+1][wNow] = \"$\"\n\t\t\t\tcnt += 1\n\t\tif wNow < w-1:\n\t\t\tif lst[hNow][wNow+1] == \".\":\n\t\t\t\tqueue.append([hNow,wNow+1])\n\t\t\t\tlst[hNow][wNow+1] = \"$\"\n\t\t\t\tcnt += 1\n\t\tif hNow > 0:\n\t\t\tif lst[hNow-1][wNow] == \".\":\n\t\t\t\tqueue.append([hNow-1,wNow])\n\t\t\t\tlst[hNow-1][wNow] = \"$\"\n\t\t\t\tcnt += 1\n\t\tif wNow > 0:\n\t\t\tif lst[hNow][wNow-1] == \".\":\n\t\t\t\tqueue.append([hNow,wNow-1])\n\t\t\t\tlst[hNow][wNow-1] = \"$\"\n\t\t\t\tcnt += 1\n\t\tif len(queue) == 0:\n\t\t\tbreak\n\tprint cnt"
  },
  {
    "language": "Python",
    "code": "from queue import *\n\n\nd = [(1,0),(0,1),(-1,0),(0,-1)]\ntemp={}\n\nwhile True:\n    W,H = (int(x) for x in input().split())\n    mmap=[]\n    visited=[]\n    flag=0\n    count=1\n    \n    q = Queue()\n    \n    if W==0 & H==0:\n        break\n    for i in range(0,H):\n        mmap.append(list(input()))\n    for i in range (0,H):\n        for j in range(0,W):\n            if mmap[i][j] == '@':\n                start=[i,j]\n    \n    q.put(start)\n    visited.append(list(start))\n    while not q.empty():\n        now = q.get()\n        for myd in d:\n            now2 = list(now)\n            now2[0] += myd[0]\n            now2[1] += myd[1]\n            if not(now2[0]==-1 or now2[0]==H or now2[1]==-1 or now2[1]==W) :\n                if mmap[now2[0]][now2[1]] != '#' :\n                    flag=0\n                    for v in visited:\n                        if now2 == v :\n                            flag=1\n                            break\n                    if flag==0:\n                        count+=1\n                        q.put(now2)\n                        visited.append(list(now2))\n    \n    print(count)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    W,H = [int(x) for x in input().split()]\n    if W==0 and H==0:\n        exit()\n    tiles = []\n    X = 0\n    Y = 0\n    for i in range(H):\n        tiles.append(input())\n        if '@' in tiles[i]:\n            Y = i\n            X = tiles[i].index('@')\n    d = [[9999 for j in range(H*W)] for i in range(H*W)]\n    for i in range(H*W):\n        d[i][i] = 0\n    for i in range(H):\n        for j in range(W):\n            if j>0:\n                if tiles[i][j] in '.@' and tiles[i][j-1] in '.@':\n                    d[W*i+j][W*i+j-1] = 1\n            if j<W-1:\n                if tiles[i][j] in '.@' and tiles[i][j+1] in '.@':\n                    d[W*i+j][W*i+j+1] = 1\n            if i>0:\n                if tiles[i][j] in '.@' and tiles[i-1][j] in '.@':\n                    d[W*i+j][W*i+j-W] = 1\n            if i<H-1:\n                if tiles[i][j] in '.@' and tiles[i+1][j] in '.@':\n                    d[W*i+j][W*i+j+W] = 1\n    for k in range(H*W):\n        for i in range(H*W):\n            for j in range(H*W):\n                if d[i][j] > d[i][k]+d[k][j]:\n                    d[i][j] = d[i][k]+d[k][j]\n    cnt = 0\n    for i in range(H*W):\n        if d[X+Y*W][i]<9999:\n            cnt += 1\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    dd = [(-1,0),(1,0),(0,-1),(0,1)]\n\n    while True:\n        w,h = LI()\n        if w == 0:\n            break\n        a = [S() for _ in range(h)]\n        q = []\n        f = collections.defaultdict(bool)\n        for i in range(h):\n            for j in range(w):\n                if a[i][j] == '@':\n                    q.append((i,j))\n        qi = 0\n        while len(q) > qi:\n            i,j = q[qi]\n            qi += 1\n            for di,dj in dd:\n                ni = i + di\n                nj = j + dj\n                if 0 <= ni < h and 0 <= nj < w and a[ni][nj] == '.' and not f[(ni,nj)]:\n                    f[(ni,nj)] = True\n                    q.append((ni,nj))\n        rr.append(len(q))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    W,H = [int(x) for x in input().split()]\n    if W==0 and H==0:\n        exit()\n    tiles = []\n    X = 0\n    Y = 0\n    for i in range(H):\n        tiles.append(input())\n        if '@' in tiles[i]:\n            Y = i\n            X = tiles[i].index('@')\n    d = [[9999 for j in range(H*W)] for i in range(H*W)]\n    for i in range(H*W):\n        d[i][i] = 0\n    for i in range(H):\n        for j in range(W):\n            if j>0:\n                if tiles[i][j] in '.@' and tiles[i][j-1] in '.@':\n                    d[W*i+j][W*i+j-1] = 1\n            if j<W-1:\n                if tiles[i][j] in '.@' and tiles[i][j+1] in '.@':\n                    d[W*i+j][W*i+j+1] = 1\n            if i>0:\n                if tiles[i][j] in '.@' and tiles[i-1][j] in '.@':\n                    d[W*i+j][W*i+j-W] = 1\n            if i<H-1:\n                if tiles[i][j] in '.@' and tiles[i+1][j] in '.@':\n                    d[W*i+j][W*i+j+W] = 1\n    for k in range(H*W):\n        for i in range(H*W):\n            for j in range(H*W):\n                if d[i][j] > d[i][k]+d[k][j]:\n                    d[i][j] = d[i][k]+d[k][j]\n    cnt = 0\n    for i in range(H*W):\n        if d[X+Y*W][i]<9999:\n            cnt += 1\n    print(cnt)"
  },
  {
    "language": "Python",
    "code": "def search(M, l, walkable):\n    i, j = (l.pop(0))\n    nexts = []\n    if i !=0:\n        nexts.append((i-1, j))\n    if i != len(M)-1:\n        nexts.append((i+1, j))\n    if j != 0:\n        nexts.append((i, j-1))\n    if j != len(M[0])-1:\n        nexts.append((i, j+1))\n\n    for nex in nexts:\n        x, y = nex\n        if M[x][y] == '.' and not nex in walkable:\n            l.append(nex)\n            walkable.append(nex)\n\ninp = ''\nwhile '0 0' != (inp = input().rstrip()):\n    i, j = [int(x) for x in inp.split()]\n    M = [input() for k in range(j)]\n    l = []\n    for n in range(j):\n        if '@' in M[n]:\n            l.append((n, M[n].find('@')))\n\n    walkable = []\n    while l:\n        search(M, l, walkable)\n    print(len(walkable)+1)"
  },
  {
    "language": "Python",
    "code": "\nwhile True:\n    W, H = [int(n) for n in input().split()]\n\n    if W == H == 0:\n        break\n\n    next_target = []\n\n    room = []\n    for n in range(H):\n        s = list(input())\n        room.append(s)\n        for y in range(W):\n            if s[y] == '@':\n                next_target.append((n, y))\n\n    result = 0\n\n    while len(next_target) > 0:\n        t = next_target.pop()\n\n        # ???\n        if t[0] - 1 >= 0 and room[t[0] - 1][t[1]] == '.':\n            next_target.append((t[0] - 1, t[1]))\n            room[t[0] - 1][t[1]] = '@'\n\n        # ???\n        if t[1] + 1 < W and room[t[0]][t[1] + 1] == '.':\n            next_target.append((t[0], t[1] + 1))\n            room[t[0]][t[1] + 1] = '@'\n\n        # ???\n        if t[0] + 1 < H and room[t[0] + 1][t[1]] == '.':\n            next_target.append((t[0] + 1, t[1]))\n            room[t[0] + 1][t[1]] = '@'\n\n        # ???\n        if t[1] - 1 >= 0 and room[t[0]][t[1] - 1] == '.':\n            next_target.append((t[0], t[1] - 1))\n            room[t[0]][t[1] - 1] = '@'\n\n        # ?????????????????????????????????\n        result += 1\n\n    print(result)"
  },
  {
    "language": "Python",
    "code": "\ndef depth_first_search(x, y):\n    \"\"\"\n    ??±???????????¢?´¢?????????\n    :param x: ?????¨??°????¨?\n    :param y: ?????¨??°??????\n    :return: ?????°\n    \"\"\"\n\n    # ????????????????????§?¢??????????\n    # ??????x  ,y+1\n    # ??????x+1,y\n    # ??????x  ,y-1\n    # ??????x-1,y\n    move_list = [[0,1],[1,0],[0,-1],[-1,0]]\n    for i in range(0,4,1):\n        next_x = x+move_list[i][0]\n        next_y = y+move_list[i][1]\n        # tile_map??????????§??????§????????´??????'.'???\n        if 0 <= next_x and 0 <= next_y and \\\n            next_x < W and next_y < H and \\\n            tile_map[next_y][next_x] != '#':\n\n            # ?§?????????????????????¨??°????§??????§??????????????????\"#\"??????????????????\n            tile_map[y][x] = '#'\n            import __main__\n            __main__.move_point = __main__.move_point+1\n            depth_first_search(next_x, next_y)\n\ndef get_start_point(tile_map):\n    \"\"\"\n    @????????????????????????\n    :param tile_map:\n    :return:\n    \"\"\"\n    for i, y in enumerate(tile_map):\n        for j, x in enumerate(y):\n            if x == '@':\n                return i, j\n\n\n\nif __name__ == \"__main__\":\n    move_point = 0\n    while (True):\n        # input_1 : tile????????????\n        tile_size = input('').split(' ')\n        W, H = [int(x) for x in tile_size]\n        if W == 0 and H == 0:\n            break\n        tile_map=[''] * H\n        for i in range(0, H, 1):\n            # input_2 : tile???????????????????????????\n            map_line = list(input(''))\n            tile_map[i] = map_line\n        start_H, start_W = get_start_point(tile_map)\n        depth_first_search(start_W, start_H)\n        print(move_point)"
  },
  {
    "language": "Python",
    "code": "W,H=(int(i) for i in input().split())\nwhile W!=0 or H!=0:\n    a=[]\n    T=[]\n    for i in range(H):\n        T.append(input())\n        a.append([])\n        for j in range(W):\n            a[i].append(0)\n #   print(T[0][0])\n    i=0\n    j=0\n    while T[i][j]!=\"@\":\n        j=0\n        while j<W and T[i][j]!=\"@\":\n            j+=1\n    #        print(j)\n        if j>=W:\n            j-=1\n        if T[i][j]!=\"@\":\n            i+=1\n  #      print(i)\n    s=[[i,j]]\n    a[i][j]=1\n    c=1\n    while s!=[]:\n        u=[]\n        for l in range(len(s)):\n            i=s[l][0]\n            j=s[l][1]\n            i-=1\n            k=0\n            while k<2:\n            #    print(j)\n                if 0<=i<H and a[i][j]==0 and T[i][j]==\".\":\n                    a[i][j]=1\n                    u.append([i,j])\n                    c+=1\n                i+=2\n                k+=1\n            i-=3\n            j-=1\n            k=0\n            while k<2:\n                if 0<=j<W and a[i][j]==0 and T[i][j]==\".\":\n                    a[i][j]=1 \n                    u.append([i,j])\n                    c+=1\n                j+=2\n                k+=1\n        s=u\n    #    print (a)\n    print(c)\n    W,H=(int(i) for i in input().split())"
  },
  {
    "language": "Python",
    "code": "from queue import Queue\n\ndef calcReachableTileNumByBFSearch(room, start_pos):\n    q = Queue()\n    q.put(start_pos)\n\n    count = 1\n    while not q.empty():\n        cur_pos = q.get()\n        D0 = [1, 0, -1, 0]\n        D1 = [0, -1, 0, 1]\n        for d in range(4):\n            nc = [0,0]\n            nc[0] = cur_pos[0]+D0[d]\n            nc[1] = cur_pos[1]+D1[d]\n            if room[nc[0]][nc[1]] == '.':\n                room[nc[0]][nc[1]] = '*'\n                q.put([nc[0],nc[1]])\n                count +=1\n    return count\n\n\ndef solve(width, height):\n    room = [['#' for i in range(width+2)] for j in range(height+2)]\n    for i in range(height):\n        row = input()\n        for j in range(width):\n            room[i+1][j+1] = row[j]\n            if room[i+1][j+1] == '@':\n                start = [i+1,j+1]\n\n    return calcReachableTileNumByBFSearch(room, start)\n\n\ndef main():\n    while True:\n        width, height = map(int, input().split())\n        if width == 0 and height == 0:\n            break\n        print(solve(width, height))\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# conding: utf\n\nfrom logging import getLogger, StreamHandler, NullHandler, DEBUG, INFO\nlogger = getLogger(__name__)\n#handler = StreamHandler()\nhandler = NullHandler()\nlogger.setLevel(DEBUG)\nhandler.setLevel(DEBUG)\nlogger.addHandler(handler)\nlogger.propagate = False\n\ng_field = []\ng_count = 0\ng_W = -1\ng_H = -1\n\nOFFSETS = [(1,0), (-1,0), (0,1), (0,-1)]\n\n\nif __name__ == \"__main__\":\n    while True:\n        g_W, g_H = [int(s) for s in input().strip().split()]\n\n        if g_W == 0 and g_H == 0:\n            break\n        \n        g_field = []\n        for _ in range(g_H):\n            row = list(input().strip())\n            g_field.append(row)\n        g_count = 0\n\n        for y in range(g_H):\n            for x in range(g_W):\n                if g_field[y][x] == \"@\":\n                    start_x = x\n                    start_y = y\n                    break\n\n        #dfs(start_x, start_y)\n        # bfs\n        queue = [(start_x, start_y)]\n        \n        while len(queue) > 0:\n            x, y = queue.pop()\n\n            g_count += 1\n            g_field[y][x] = \"-\"\n\n            for dx, dy in OFFSETS:\n                logger.debug(\"diff: {} {}\".format(dx, dy))\n                new_x = x + dx\n                new_y = y + dy\n\n                if new_x < 0 or new_x >= g_W:\n                    continue\n                if new_y < 0 or new_y >= g_H:\n                    continue\n                new_tile = g_field[new_y][new_x]\n                if new_tile == \"#\" or new_tile == \"-\":\n                    continue\n                if (new_x, new_y) in queue:\n                    continue\n                \n                logger.debug(\"{}, {}\".format(new_x, new_y))\n                queue.append((new_x, new_y))\n\n        print(g_count)\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case, dead_code)]\n\nuse std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nstruct Scanner<'a> {\n    cin : StdinLock<'a>,\n}\n\nimpl<'a> Scanner<'a> {\n    fn new(cin : StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\nstruct UnionFind {\n    size: usize,\n    pos: Vec<isize>,\n}\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let size = n;\n        let pos = vec![-1; n + 1];\n        UnionFind { size, pos }\n    }\n    fn find(&mut self, x: usize) -> usize {\n        if self.pos[x] < 0 {\n            x\n        } else {\n            let v = self.pos[x] as usize;\n            self.pos[x] = self.find(v) as isize;\n            self.pos[x] as usize\n        }\n    }\n    fn unite(&mut self, x: usize, y: usize) -> Result<(), ()> {\n        let mut x = self.find(x);\n        let mut y = self.find(y);\n        if x == y {\n            return Err(());\n        };\n        if self.pos[x] > self.pos[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.pos[x] += self.pos[y];\n        self.pos[y] = x as isize;\n        Ok(())\n    }\n    fn same(&mut self, x: usize, y: usize) -> bool {\n        self.find(x) == self.find(y)\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let x = self.find(x);\n        -self.pos[x] as usize\n    }\n}\n\n\nfn main(){\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n    loop {\n        let W: usize = sc.read();\n        let H: usize = sc.read();\n        if W == 0 { break; };\n        let mut g = Vec::new();\n        for _ in 0..H {\n            let v: String = sc.read();\n            let v = v.chars().collect::<Vec<char>>();\n            g.push(v);\n        }\n        let mut uf = UnionFind::new(H*W);\n        let mut x: usize = 0;\n        for i in 0..H {\n            for j in 0..W {\n                if g[i][j] == '@' {\n                    x = i * W + j;\n                }\n                if g[i][j] == '#' { continue; };\n                if j < W - 1 && g[i][j+1] != '#' {\n                    uf.unite(i*W + j, i*W + j + 1).ok();\n                }\n                if i + 1 < H && g[i+1][j] != '#' {\n                    uf.unite(i*W + j, i*W + j + W).ok();\n                }\n            }\n        }\n        println!(\"{}\", uf.size(x));\n    }\n}\n\n"
  }
]