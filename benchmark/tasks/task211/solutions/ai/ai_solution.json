[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 20\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint W, H;\nint count;\n\nvoid dfs(int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] == '#' || visited[x][y]) {\n        return;\n    }\n    visited[x][y] = 1;\n    count++;\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        memset(visited, 0, sizeof(visited));\n        count = 0;\n        int start_x, start_y;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '@') {\n                    start_x = i;\n                    start_y = j;\n                }\n            }\n        }\n        \n        dfs(start_x, start_y);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TileCount {\n    static int w, h;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {1, -1, 0, 0};\n    static int[] dy = {0, 0, 1, -1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            w = scanner.nextInt();\n            h = scanner.nextInt();\n            \n            if (w == 0 && h == 0) break;\n            \n            grid = new char[h][w];\n            visited = new boolean[h][w];\n            int startX = 0, startY = 0;\n            \n            scanner.nextLine();\n            for (int i = 0; i < h; i++) {\n                String line = scanner.nextLine();\n                for (int j = 0; j < w; j++) {\n                    grid[i][j] = line.charAt(j);\n                    if (grid[i][j] == '@') {\n                        startX = j;\n                        startY = i;\n                    }\n                }\n            }\n            \n            int result = dfs(startY, startX);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n    \n    static int dfs(int y, int x) {\n        if (y < 0 || y >= h || x < 0 || x >= w || \n            grid[y][x] == '#' || visited[y][x]) {\n            return 0;\n        }\n        \n        visited[y][x] = true;\n        int count = 1;\n        \n        for (int i = 0; i < 4; i++) {\n            int newY = y + dy[i];\n            int newX = x + dx[i];\n            count += dfs(newY, newX);\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-05 19:06:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main() {\n    int W, H;\n    while (cin >> W >> H, W || H) {\n        vector<string> grid(H);\n        int sx = -1, sy = -1;\n        for (int i = 0; i < H; ++i) {\n            cin >> grid[i];\n            for (int j = 0; j < W; ++j) {\n                if (grid[i][j] == '@') {\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n        \n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        queue<pair<int, int>> q;\n        q.push({sx, sy});\n        visited[sx][sy] = true;\n        int count = 0;\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            count++;\n            \n            for (int i = 0; i < 4; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] != '#' && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n        \n        cout << count << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_W 20\n#define MAX_H 20\n\nchar grid[MAX_H][MAX_W];\nint visited[MAX_H][MAX_W];\nint w, h;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint dfs(int x, int y) {\n    if (x < 0 || x >= h || y < 0 || y >= w || visited[x][y] || grid[x][y] == '#')\n        return 0;\n    \n    visited[x][y] = 1;\n    int count = 1;\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        count += dfs(nx, ny);\n    }\n    \n    return count;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &w, &h);\n        \n        if (w == 0 && h == 0)\n            break;\n        \n        memset(visited, 0, sizeof(visited));\n        \n        int start_x = -1, start_y = -1;\n        \n        for (int i = 0; i < h; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < w; j++) {\n                if (grid[i][j] == '@') {\n                    start_x = i;\n                    start_y = j;\n                }\n            }\n        }\n        \n        int result = dfs(start_x, start_y);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int W, H;\n    while (cin >> W >> H && (W != 0 || H != 0)) {\n        vector<vector<char>> grid(H, vector<char>(W));\n        int startX = -1, startY = -1;\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> grid[i][j];\n                if (grid[i][j] == '@') {\n                    startX = j;\n                    startY = i;\n                }\n            }\n        }\n\n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        queue<pair<int, int>> q;\n        q.push({startY, startX});\n        visited[startY][startX] = true;\n        int count = 1;\n\n        int dx[] = {1, -1, 0, 0};\n        int dy[] = {0, 0, 1, -1};\n\n        while (!q.empty()) {\n            int y = q.front().first;\n            int x = q.front().second;\n            q.pop();\n\n            for (int i = 0; i < 4; i++) {\n                int newY = y + dy[i];\n                int newX = x + dx[i];\n\n                if (newY >= 0 && newY < H && newX >= 0 && newX < W && \n                    grid[newY][newX] != '#' && !visited[newY][newX]) {\n                    q.push({newY, newX});\n                    visited[newY][newX] = true;\n                    count++;\n                }\n            }\n        }\n\n        cout << count << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:06:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int W, H;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int count;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            W = scanner.nextInt();\n            H = scanner.nextInt();\n            if (W == 0 && H == 0) break;\n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            count = 0;\n            int startX = 0, startY = 0;\n            for (int i = 0; i < H; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                    if (grid[i][j] == '@') {\n                        startX = i;\n                        startY = j;\n                    }\n                }\n            }\n            dfs(startX, startY);\n            System.out.println(count);\n        }\n        scanner.close();\n    }\n\n    static void dfs(int x, int y) {\n        if (x < 0 || x >= H || y < 0 || y >= W || grid[x][y] == '#' || visited[x][y]) {\n            return;\n        }\n        visited[x][y] = true;\n        count++;\n        dfs(x + 1, y);\n        dfs(x - 1, y);\n        dfs(x, y + 1);\n        dfs(x, y - 1);\n    }\n}",
    "timestamp": "2025-08-05 19:06:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def flood_fill_count(x, y, W, H, grid, visited):\n    stack = [(x, y)]\n    count = 0\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # left, right, up, down\n    \n    while stack:\n        cx, cy = stack.pop()\n        if visited[cy][cx]:\n            continue\n        visited[cy][cx] = True\n        count += 1\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < W and 0 <= ny < H and not visited[ny][nx] and grid[ny][nx] == '.':\n                stack.append((nx, ny))\n                \n    return count\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().splitlines()\n    \n    index = 0\n    results = []\n    while index < len(data):\n        W, H = map(int, data[index].split())\n        if W == 0 and H == 0:\n            break\n        index += 1\n        \n        grid = []\n        start_x = start_y = None\n        for y in range(H):\n            line = data[index]\n            grid.append(line)\n            if '@' in line:\n                start_x = line.index('@')\n                start_y = y\n            index += 1\n        \n        visited = [[False] * W for _ in range(H)]\n        reachable_count = flood_fill_count(start_x, start_y, W, H, grid, visited)\n        results.append(reachable_count)\n    \n    for result in results:\n        print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:29:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class TileTraversal {\n\n    private static final char BLACK_TILE = '.';\n    private static final char RED_TILE = '#';\n    private static final char START_POSITION = '@';\n\n    private static int W, H;\n    private static char[][] tiles;\n    private static boolean[][] visited;\n\n    private static int countReachableTiles(int x, int y) {\n        if (x < 0 || x >= W || y < 0 || y >= H || visited[y][x] || tiles[y][x] == RED_TILE) {\n            return 0;\n        }\n        \n        visited[y][x] = true;\n        int count = 1;\n\n        count += countReachableTiles(x + 1, y);\n        count += countReachableTiles(x - 1, y);\n        count += countReachableTiles(x, y + 1);\n        count += countReachableTiles(x, y - 1);\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            W = scanner.nextInt();\n            H = scanner.nextInt();\n            if (W == 0 && H == 0) {\n                break;\n            }\n\n            tiles = new char[H][W];\n            visited = new boolean[H][W];\n            int startX = 0, startY = 0;\n\n            scanner.nextLine();  // Consume the remaining line\n\n            for (int h = 0; h < H; h++) {\n                String line = scanner.nextLine();\n                for (int w = 0; w < W; w++) {\n                    tiles[h][w] = line.charAt(w);\n                    if (tiles[h][w] == START_POSITION) {\n                        startX = w;\n                        startY = h;\n                    }\n                }\n            }\n\n            // Call the DFS to count reachable tiles\n            int reachableCount = countReachableTiles(startX, startY);\n            System.out.println(reachableCount);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 02:29:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_SIZE 100\n\nint W, H;\nchar room[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nint isValid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && room[x][y] != '#' && !visited[x][y];\n}\n\nint countReachableTiles(int x, int y) {\n    visited[x][y] = 1;\n    int count = 1;\n\n    for (int i = 0; i < 4; i++) {\n        int newX = x + directions[i][0];\n        int newY = y + directions[i][1];\n        if (isValid(newX, newY)) {\n            count += countReachableTiles(newX, newY);\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &W, &H) && (W != 0 || H != 0)) {\n        int startX, startY;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", room[i]);\n            for (int j = 0; j < W; j++) {\n                visited[i][j] = 0;\n                if (room[i][j] == '@') {\n                    startX = i;\n                    startY = j;\n                }\n            }\n        }\n        \n        int result = countReachableTiles(startX, startY);\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 02:30:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_reachable_tiles(w, h, grid):\n    def is_valid_move(x, y):\n        return 0 <= x < w and 0 <= y < h and grid[y][x] != '#'\n\n    def dfs(x, y):\n        if (x, y) in visited or not is_valid_move(x, y):\n            return 0\n        \n        visited.add((x, y))\n        count = 1\n        \n        for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n            new_x, new_y = x + dx, y + dy\n            count += dfs(new_x, new_y)\n        \n        return count\n\n    start_x, start_y = None, None\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] == '@':\n                start_x, start_y = x, y\n                grid[y] = grid[y].replace('@', '.')\n                break\n        if start_x is not None:\n            break\n\n    visited = set()\n    return dfs(start_x, start_y)\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        \n        grid = [input().strip() for _ in range(h)]\n        print(count_reachable_tiles(w, h, grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:30:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        W, H = map(int, sys.stdin.readline().split())\n        if W == 0 and H == 0:\n            break\n        grid = []\n        start = (-1, -1)\n        for i in range(H):\n            line = sys.stdin.readline().strip()\n            grid.append(line)\n            if '@' in line:\n                start = (i, line.index('@'))\n        \n        if start == (-1, -1):\n            print(0)\n            continue\n        \n        visited = [[False for _ in range(W)] for _ in range(H)]\n        q = deque()\n        q.append(start)\n        visited[start[0]][start[1]] = True\n        count = 1\n        \n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        while q:\n            x, y = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W:\n                    if not visited[nx][ny] and grid[nx][ny] == '.':\n                        visited[nx][ny] = True\n                        count += 1\n                        q.append((nx, ny))\n        print(count)\n\nsolve()",
    "timestamp": "2025-08-13 02:30:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint bfs(vector<vector<char>>& tiles, int startX, int startY, int W, int H) {\n    int reachable = 0;\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startY][startX] = true;\n    \n    int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        reachable++;\n\n        for (auto& dir : directions) {\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            if (newX >= 0 && newX < W && newY >= 0 && newY < H && !visited[newY][newX] && tiles[newY][newX] == '.') {\n                visited[newY][newX] = true;\n                q.push({newX, newY});\n            }\n        }\n    }\n\n    return reachable;\n}\n\nint main() {\n    int W, H;\n    while (cin >> W >> H, W != 0 || H != 0) {\n        vector<vector<char>> tiles(H, vector<char>(W));\n        int startX = -1, startY = -1;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                cin >> tiles[i][j];\n                if (tiles[i][j] == '@') {\n                    startX = j;\n                    startY = i;\n                    tiles[i][j] = '.'; // Treat starting position as a black tile.\n                }\n            }\n        }\n\n        cout << bfs(tiles, startX, startY, W, H) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:16"
  }
]