[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n\nint findMinRoadNetwork(int N, int distances[MAX_CITIES][MAX_CITIES]) {\n    int minTotalRoadLength = 0;\n    bool roadExists[MAX_CITIES][MAX_CITIES] = {false};\n    \n    // Floyd-Warshall to verify distances\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (distances[i][k] + distances[k][j] < distances[i][j]) {\n                    return -1;\n                }\n            }\n        }\n    }\n    \n    // Reconstruct minimal road network\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            bool directRoadPossible = true;\n            \n            for (int k = 0; k < N; k++) {\n                if (k != i && k != j && \n                    distances[i][j] > distances[i][k] + distances[k][j]) {\n                    directRoadPossible = false;\n                    break;\n                }\n            }\n            \n            if (directRoadPossible) {\n                roadExists[i][j] = roadExists[j][i] = true;\n                minTotalRoadLength += distances[i][j];\n            }\n        }\n    }\n    \n    return minTotalRoadLength;\n}\n\nint main() {\n    int N;\n    int distances[MAX_CITIES][MAX_CITIES];\n    \n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &distances[i][j]);\n            \n            if (i == j && distances[i][j] != 0) {\n                return -1;\n            }\n        }\n    }\n    \n    int result = findMinRoadNetwork(N, distances);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int dist[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &dist[i][j]);\n        }\n    }\n\n    // Check if the matrix is symmetric and diagonal is zero\n    for (int i = 0; i < N; i++) {\n        if (dist[i][i] != 0) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        for (int j = i + 1; j < N; j++) {\n            if (dist[i][j] != dist[j][i]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n    }\n\n    int total = 0;\n    int possible = 1;\n\n    for (int i = 0; i < N && possible; i++) {\n        for (int j = i + 1; j < N && possible; j++) {\n            int is_necessary = 1;\n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    possible = 0;\n                    break;\n                }\n                if (dist[i][k] + dist[k][j] == dist[i][j]) {\n                    is_necessary = 0;\n                }\n            }\n            if (is_necessary && possible) {\n                total += dist[i][j];\n            }\n        }\n    }\n\n    if (possible) {\n        printf(\"%d\\n\", total);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> dist(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> dist[i][j];\n        }\n    }\n\n    long long total = 0;\n    bool possible = true;\n\n    for (int k = 0; k < N && possible; ++k) {\n        for (int i = 0; i < N && possible; ++i) {\n            for (int j = 0; j < N && possible; ++j) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    possible = false;\n                }\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<vector<bool>> needed(N, vector<bool>(N, true));\n    for (int k = 0; k < N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i != j && j != k && k != i && dist[i][j] == dist[i][k] + dist[k][j]) {\n                    needed[i][j] = false;\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            if (needed[i][j]) {\n                total += dist[i][j];\n            }\n        }\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadNetwork {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] dist = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                dist[i][j] = scanner.nextInt();\n            }\n        }\n        \n        System.out.println(solve(N, dist));\n    }\n    \n    public static int solve(int N, int[][] dist) {\n        int total = 0;\n        boolean[][] used = new boolean[N][N];\n        \n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (i == j || j == k || k == i) continue;\n                    if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                        return -1;\n                    }\n                    if (dist[i][j] == dist[i][k] + dist[k][j] && !used[i][j]) {\n                        used[i][j] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (!used[i][j]) {\n                    total += dist[i][j];\n                }\n            }\n        }\n        \n        return total;\n    }\n}",
    "timestamp": "2025-08-05 23:16:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadNetwork {\n    public static long minimumRoadLength(int N, int[][] distances) {\n        // Check if distances matrix is symmetric \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (distances[i][j] != distances[j][i]) {\n                    return -1;\n                }\n                if (distances[i][i] != 0) {\n                    return -1;\n                }\n            }\n        }\n\n        // Floyd-Warshall to verify triangle inequality\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (distances[i][k] + distances[k][j] < distances[i][j]) {\n                        return -1;\n                    }\n                }\n            }\n        }\n\n        // Use Prim's algorithm to find minimum spanning tree\n        boolean[] visited = new boolean[N];\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.weight - b.weight);\n        \n        pq.offer(new Edge(0, 0));\n        long totalRoadLength = 0;\n        int edgeCount = 0;\n\n        while (!pq.isEmpty() && edgeCount < N - 1) {\n            Edge current = pq.poll();\n            \n            if (visited[current.vertex]) continue;\n            \n            visited[current.vertex] = true;\n            totalRoadLength += current.weight;\n            edgeCount++;\n\n            for (int next = 0; next < N; next++) {\n                if (!visited[next] && distances[current.vertex][next] > 0) {\n                    pq.offer(new Edge(next, distances[current.vertex][next]));\n                }\n            }\n        }\n\n        return edgeCount == N - 1 ? totalRoadLength : -1;\n    }\n\n    static class Edge {\n        int vertex;\n        int weight;\n\n        Edge(int vertex, int weight) {\n            this.vertex = vertex;\n            this.weight = weight;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:16:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int networkExistence(int N, std::vector<std::vector<int>>& distances) {\n        // Floyd-Warshall algorithm to check and find shortest road network\n        std::vector<std::vector<int>> dist = distances;\n        \n        // Check for valid distance matrix\n        for (int i = 0; i < N; i++) {\n            if (dist[i][i] != 0) return -1;\n            for (int j = 0; j < N; j++) {\n                if (dist[i][j] != dist[j][i]) return -1;\n                if (dist[i][j] < 0) return -1;\n            }\n        }\n        \n        // Check triangle inequality\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) return -1;\n                }\n            }\n        }\n        \n        // Compute minimal road network\n        std::vector<std::vector<int>> roadNetwork(N, std::vector<int>(N, INT_MAX));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int minRoadLength = dist[i][j];\n                for (int k = 0; k < N; k++) {\n                    if (k != i && k != j) {\n                        minRoadLength = std::min(minRoadLength, \n                            dist[i][k] + dist[k][j]);\n                    }\n                }\n                roadNetwork[i][j] = roadNetwork[j][i] = minRoadLength;\n            }\n        }\n        \n        // Calculate total road length\n        int totalLength = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (roadNetwork[i][j] != INT_MAX) {\n                    totalLength += roadNetwork[i][j];\n                }\n            }\n        }\n        \n        return totalLength;\n    }\n};",
    "timestamp": "2025-08-05 23:16:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def valid_road_network(d):\n    import itertools\n\n    n = len(d)\n    road_set = set(itertools.combinations(range(n), 2))\n    roads = []\n\n    def detect_min_cost():\n        total_cost = 0\n        for i, j in road_set:\n            path = False\n            for k in range(n):\n                if d[i][k] + d[k][j] <= d[i][j]:\n                    path = True\n                total_cost += d[i][k] + d[k][j] == d[i][j]\n            if not path:\n                return False, -1\n        return True, total_cost // 2\n\n    valid, min_cost = detect_min_cost()\n    return min_cost if valid else -1\n\n# Example usage:\nd = [\n    [0, 1, 3],\n    [1, 0, 2],\n    [3, 2, 0]\n]\nprint(valid_road_network(d))  # Output should be 3, for a valid triangle network.",
    "timestamp": "2025-08-13 14:18:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TakahashiKingdom {\n    public static void main(String[] args) {\n        // Input: distance matrix\n        int[][] distances = {\n            // Example input\n            {0, 2, 4, 6},\n            {2, 0, 2, 4},\n            {4, 2, 0, 2},\n            {6, 4, 2, 0}\n        };\n\n        // Method call\n        System.out.println(findShortestRoadNetwork(distances));\n    }\n\n    public static int findShortestRoadNetwork(int[][] distances) {\n        int N = distances.length;\n        \n        // Check if the given matrix is valid\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    if (distances[i][j] > distances[i][k] + distances[k][j]) {\n                        return -1;\n                    }\n                }\n            }\n        }\n\n        int totalLength = 0;\n        boolean[][] isDirectRoad = new boolean[N][N];\n\n        // Calculate the shortest possible total length of all roads\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                boolean needed = true;\n                for (int k = 0; k < N; k++) {\n                    if (i != k && j != k && distances[i][j] == distances[i][k] + distances[k][j]) {\n                        needed = false;\n                        break;\n                    }\n                }\n                if (needed) {\n                    totalLength += distances[i][j];\n                    isDirectRoad[i][j] = true;\n                    isDirectRoad[j][i] = true;\n                }\n            }\n        }\n\n        return totalLength;\n    }\n}",
    "timestamp": "2025-08-13 14:18:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 300\n#define INF 1000000000\n\nint N;\nint dist[MAX_N][MAX_N];\nint original[MAX_N][MAX_N];\n\nbool validateRoadNetwork() {\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint findShortestRoadNetworkLength() {\n    int roadLength = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            bool necessary = true;\n            for (int k = 0; k < N; k++) {\n                if (k != i && k != j && dist[i][j] == dist[i][k] + dist[k][j]) {\n                    necessary = false;\n                    break;\n                }\n            }\n            if (necessary) {\n                roadLength += dist[i][j];\n            }\n        }\n    }\n    return roadLength;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &dist[i][j]);\n            original[i][j] = dist[i][j];\n        }\n    }\n\n    if (!validateRoadNetwork()) {\n        printf(\"-1\\n\");\n    } else {\n        int totalLength = findShortestRoadNetworkLength();\n        printf(\"%d\\n\", totalLength);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:18:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findShortestRoadNetwork(N, distanceMatrix) {\n    const MAX_VALUE = Number.MAX_SAFE_INTEGER;\n    let roads = Array.from({ length: N }, () => Array(N).fill(MAX_VALUE));\n    let totalShortestLength = 0;\n\n    // Initialize road network based on given distance matrix\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i !== j && distanceMatrix[i][j] !== distanceMatrix[j][i]) {\n                return -1; // Distance matrix is invalid\n            }\n            roads[i][j] = distanceMatrix[i][j];\n        }\n    }\n\n    // Check if a valid road network exists and calculate minimum total road length\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                if (i !== j && i !== k && j !== k) {\n                    if (distanceMatrix[i][j] > distanceMatrix[i][k] + distanceMatrix[k][j]) {\n                        return -1; // A shorter path exists which invalidates current road network\n                    }\n                }\n            }\n        }\n    }\n\n    // Sum shortest unique roads\n    for (let i = 0; i < N; i++) {\n        for (let j = i + 1; j < N; j++) {\n            let isUniqueRoad = true;\n            for (let k = 0; k < N; k++) {\n                if (k !== i && k !== j) {\n                    if (distanceMatrix[i][j] === distanceMatrix[i][k] + distanceMatrix[k][j]) {\n                        isUniqueRoad = false; // Road is part of a longer path\n                        break;\n                    }\n                }\n            }\n            if (isUniqueRoad) {\n                totalShortestLength += distanceMatrix[i][j];\n            }\n        }\n    }\n\n    return totalShortestLength;\n}",
    "timestamp": "2025-08-13 14:19:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_road_network(N, distances):\n    # Check if the input distances form a valid metric\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                # Floyd-Warshall algorithm to check triangle inequality\n                if distances[i][k] + distances[k][j] < distances[i][j]:\n                    return -1\n    \n    # Minimum spanning tree using Kruskal's algorithm\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent, parent[i])\n        return parent[i]\n    \n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n        \n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n    \n    # Create list of all edges\n    edges = []\n    for i in range(N):\n        for j in range(i+1, N):\n            edges.append((distances[i][j], i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Initialize disjoint set\n    parent = list(range(N))\n    rank = [0] * N\n    \n    # Total road length\n    total_length = 0\n    \n    # Kruskal's algorithm\n    for weight, u, v in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        \n        if x != y:\n            total_length += weight\n            union(parent, rank, x, y)\n    \n    return total_length",
    "timestamp": "2025-08-13 14:19:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findRoadNetwork(distances) {\n    const N = distances.length;\n    \n    // Check for symmetric and zero diagonal distances\n    for (let i = 0; i < N; i++) {\n        if (distances[i][i] !== 0) return -1;\n        for (let j = i + 1; j < N; j++) {\n            if (distances[i][j] !== distances[j][i]) return -1;\n        }\n    }\n    \n    // Floyd-Warshall to verify distances\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                if (distances[i][k] + distances[k][j] < distances[i][j]) return -1;\n            }\n        }\n    }\n    \n    // Prim's algorithm to find minimum spanning tree\n    const visited = new Array(N).fill(false);\n    const minEdges = new Array(N).fill(Infinity);\n    minEdges[0] = 0;\n    let totalLength = 0;\n    \n    for (let count = 0; count < N; count++) {\n        let u = -1;\n        let minVal = Infinity;\n        \n        for (let v = 0; v < N; v++) {\n            if (!visited[v] && minEdges[v] < minVal) {\n                minVal = minEdges[v];\n                u = v;\n            }\n        }\n        \n        if (u === -1) return -1;\n        \n        visited[u] = true;\n        totalLength += minVal;\n        \n        for (let v = 0; v < N; v++) {\n            if (!visited[v] && distances[u][v] < minEdges[v]) {\n                minEdges[v] = distances[u][v];\n            }\n        }\n    }\n    \n    return totalLength;\n}",
    "timestamp": "2025-08-13 14:19:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N = int(sys.stdin.readline())\n    dist = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    \n    total = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            total += dist[i][j]\n    \n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if i == j or i == k or j == k:\n                    continue\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    print(-1)\n                    return\n                if dist[i][j] == dist[i][k] + dist[k][j]:\n                    total -= dist[i][j]\n                    break\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 14:19:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N;\n    let dist = [];\n    let lines = [];\n\n    rl.on('line', (line) => {\n        lines.push(line);\n    });\n\n    rl.on('close', () => {\n        N = parseInt(lines[0]);\n        for (let i = 1; i <= N; i++) {\n            dist.push(lines[i].split(' ').map(Number));\n        }\n\n        let total = 0;\n        let possible = true;\n\n        for (let i = 0; i < N; i++) {\n            for (let j = i + 1; j < N; j++) {\n                let minDist = Infinity;\n                for (let k = 0; k < N; k++) {\n                    if (k === i || k === j) continue;\n                    minDist = Math.min(minDist, dist[i][k] + dist[k][j]);\n                }\n                if (dist[i][j] > minDist) {\n                    possible = false;\n                    break;\n                }\n                if (dist[i][j] < minDist) {\n                    total += dist[i][j];\n                }\n            }\n            if (!possible) break;\n        }\n\n        console.log(possible ? total : -1);\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:19:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool isValidRoadNetwork(const vector<vector<int>>& dist, int N) {\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            for (int k = 0; k < N; ++k)\n                if (i != k && j != k && dist[i][j] > dist[i][k] + dist[k][j])\n                    return false;\n    return true;\n}\n\nint computeMinimumRoadNetwork(const vector<vector<int>>& dist, int N) {\n    int total_length = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            bool isNecessary = true;\n            for (int k = 0; k < N; ++k) {\n                if (k != i && k != j && dist[i][j] == dist[i][k] + dist[k][j]) {\n                    isNecessary = false;\n                    break;\n                }\n            }\n            if (isNecessary) {\n                total_length += dist[i][j];\n            }\n        }\n    }\n    return total_length;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> dist(N, vector<int>(N));\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            cin >> dist[i][j];\n\n    if (!isValidRoadNetwork(dist, N)) {\n        cout << -1 << endl;\n    } else {\n        cout << computeMinimumRoadNetwork(dist, N) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:07"
  }
]